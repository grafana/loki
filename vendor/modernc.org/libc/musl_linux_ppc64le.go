// Code generated by 'ccgo -export-externs X -hide __syscall0,__syscall1,__syscall2,__syscall3,__syscall4,__syscall5,__syscall6 -nostdinc -nostdlib -o ../musl_linux_ppc64le.go -pkgname libc -static-locals-prefix _s -Iarch/powerpc64 -Iarch/generic -Iobj/src/internal -Isrc/include -Isrc/internal -Iobj/include -Iinclude copyright.c src/ctype/__ctype_b_loc.c src/ctype/isalnum.c src/ctype/isalpha.c src/ctype/isdigit.c src/ctype/islower.c src/ctype/isprint.c src/ctype/isupper.c src/ctype/isxdigit.c src/dirent/closedir.c src/dirent/opendir.c src/dirent/readdir.c src/internal/floatscan.c src/internal/intscan.c src/internal/shgetc.c src/locale/localeconv.c src/math/__fpclassify.c src/math/__fpclassifyf.c src/math/__fpclassifyl.c src/math/copysignl.c src/math/fabsl.c src/math/fmodl.c src/math/nanf.c src/math/rint.c src/math/scalbn.c src/math/scalbnl.c src/multibyte/internal.c src/multibyte/mbrtowc.c src/multibyte/mbsinit.c src/network/freeaddrinfo.c src/network/getaddrinfo.c src/network/gethostbyaddr.c src/network/gethostbyaddr_r.c src/network/gethostbyname.c src/network/gethostbyname2.c src/network/gethostbyname2_r.c src/network/gethostbyname_r.c src/network/getnameinfo.c src/network/h_errno.c src/network/inet_aton.c src/network/inet_ntop.c src/network/inet_pton.c src/network/lookup_ipliteral.c src/network/lookup_name.c src/network/lookup_serv.c src/prng/rand_r.c src/stdio/__lockfile.c src/stdio/__toread.c src/stdio/__uflow.c src/stdio/sscanf.c src/stdio/vfscanf.c src/stdio/vsscanf.c src/stdlib/bsearch.c src/stdlib/strtod.c src/stdlib/strtol.c src/string/strdup.c src/string/strlcat.c src/string/strlcpy.c src/string/strncasecmp.c src/string/strncat.c src/string/strnlen.c src/string/strspn.c src/string/strtok.c src/thread/pthread_attr_get.c src/thread/pthread_attr_setdetachstate.c src/thread/pthread_mutex_lock.c src/thread/pthread_mutexattr_destroy.c src/thread/pthread_mutexattr_init.c src/thread/pthread_mutexattr_settype.c', DO NOT EDIT.

package libc

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer

// musl as a whole is licensed under the following standard MIT license:
//
// ----------------------------------------------------------------------
// Copyright © 2005-2020 Rich Felker, et al.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ----------------------------------------------------------------------
//
// Authors/contributors include:
//
// A. Wilcox
// Ada Worcester
// Alex Dowad
// Alex Suykov
// Alexander Monakov
// Andre McCurdy
// Andrew Kelley
// Anthony G. Basile
// Aric Belsito
// Arvid Picciani
// Bartosz Brachaczek
// Benjamin Peterson
// Bobby Bingham
// Boris Brezillon
// Brent Cook
// Chris Spiegel
// Clément Vasseur
// Daniel Micay
// Daniel Sabogal
// Daurnimator
// David Carlier
// David Edelsohn
// Denys Vlasenko
// Dmitry Ivanov
// Dmitry V. Levin
// Drew DeVault
// Emil Renner Berthing
// Fangrui Song
// Felix Fietkau
// Felix Janda
// Gianluca Anzolin
// Hauke Mehrtens
// He X
// Hiltjo Posthuma
// Isaac Dunham
// Jaydeep Patil
// Jens Gustedt
// Jeremy Huntwork
// Jo-Philipp Wich
// Joakim Sindholt
// John Spencer
// Julien Ramseier
// Justin Cormack
// Kaarle Ritvanen
// Khem Raj
// Kylie McClain
// Leah Neukirchen
// Luca Barbato
// Luka Perkov
// M Farkas-Dyck (Strake)
// Mahesh Bodapati
// Markus Wichmann
// Masanori Ogino
// Michael Clark
// Michael Forney
// Mikhail Kremnyov
// Natanael Copa
// Nicholas J. Kain
// orc
// Pascal Cuoq
// Patrick Oppenlander
// Petr Hosek
// Petr Skocik
// Pierre Carrier
// Reini Urban
// Rich Felker
// Richard Pennington
// Ryan Fairfax
// Samuel Holland
// Segev Finer
// Shiz
// sin
// Solar Designer
// Stefan Kristiansson
// Stefan O'Rear
// Szabolcs Nagy
// Timo Teräs
// Trutz Behn
// Valentin Ochs
// Will Dietz
// William Haddon
// William Pitcock
//
// Portions of this software are derived from third-party works licensed
// under terms compatible with the above MIT license:
//
// The TRE regular expression implementation (src/regex/reg* and
// src/regex/tre*) is Copyright © 2001-2008 Ville Laurikari and licensed
// under a 2-clause BSD license (license text in the source files). The
// included version has been heavily modified by Rich Felker in 2012, in
// the interests of size, simplicity, and namespace cleanliness.
//
// Much of the math library code (src/math/* and src/complex/*) is
// Copyright © 1993,2004 Sun Microsystems or
// Copyright © 2003-2011 David Schultz or
// Copyright © 2003-2009 Steven G. Kargl or
// Copyright © 2003-2009 Bruce D. Evans or
// Copyright © 2008 Stephen L. Moshier or
// Copyright © 2017-2018 Arm Limited
// and labelled as such in comments in the individual source files. All
// have been licensed under extremely permissive terms.
//
// The ARM memcpy code (src/string/arm/memcpy.S) is Copyright © 2008
// The Android Open Source Project and is licensed under a two-clause BSD
// license. It was taken from Bionic libc, used on Android.
//
// The AArch64 memcpy and memset code (src/string/aarch64/*) are
// Copyright © 1999-2019, Arm Limited.
//
// The implementation of DES for crypt (src/crypt/crypt_des.c) is
// Copyright © 1994 David Burren. It is licensed under a BSD license.
//
// The implementation of blowfish crypt (src/crypt/crypt_blowfish.c) was
// originally written by Solar Designer and placed into the public
// domain. The code also comes with a fallback permissive license for use
// in jurisdictions that may not recognize the public domain.
//
// The smoothsort implementation (src/stdlib/qsort.c) is Copyright © 2011
// Valentin Ochs and is licensed under an MIT-style license.
//
// The x86_64 port was written by Nicholas J. Kain and is licensed under
// the standard MIT terms.
//
// The mips and microblaze ports were originally written by Richard
// Pennington for use in the ellcc project. The original code was adapted
// by Rich Felker for build system and code conventions during upstream
// integration. It is licensed under the standard MIT terms.
//
// The mips64 port was contributed by Imagination Technologies and is
// licensed under the standard MIT terms.
//
// The powerpc port was also originally written by Richard Pennington,
// and later supplemented and integrated by John Spencer. It is licensed
// under the standard MIT terms.
//
// All other files which have no copyright comments are original works
// produced specifically for use as part of this library, written either
// by Rich Felker, the main author of the library, or by one or more
// contibutors listed above. Details on authorship of individual files
// can be found in the git version control history of the project. The
// omission of copyright and license comments in each file is in the
// interest of source tree size.
//
// In addition, permission is hereby granted for all public header files
// (include/* and arch/*/bits/*) and crt files intended to be linked into
// applications (crt/*, ldso/dlstart.c, and arch/*/crt_arch.h) to omit
// the copyright notice and permission notice otherwise required by the
// license, and to use these files without any requirement of
// attribution. These files include substantial contributions from:
//
// Bobby Bingham
// John Spencer
// Nicholas J. Kain
// Rich Felker
// Richard Pennington
// Stefan Kristiansson
// Szabolcs Nagy
//
// all of whom have explicitly granted such permission.
//
// This file previously contained text expressing a belief that most of
// the files covered by the above exception were sufficiently trivial not
// to be subject to copyright, resulting in confusion over whether it
// negated the permissions granted in the license. In the spirit of
// permissive licensing, and of not having licensing issues being an
// obstacle to adoption, that text has been removed.
const ( /* copyright.c:194:1: */
	__musl__copyright__ = 0
)

const ( /* nameser.h:117:1: */
	ns_uop_delete = 0
	ns_uop_add    = 1
	ns_uop_max    = 2
)

const ( /* nameser.h:147:1: */
	ns_t_invalid  = 0
	ns_t_a        = 1
	ns_t_ns       = 2
	ns_t_md       = 3
	ns_t_mf       = 4
	ns_t_cname    = 5
	ns_t_soa      = 6
	ns_t_mb       = 7
	ns_t_mg       = 8
	ns_t_mr       = 9
	ns_t_null     = 10
	ns_t_wks      = 11
	ns_t_ptr      = 12
	ns_t_hinfo    = 13
	ns_t_minfo    = 14
	ns_t_mx       = 15
	ns_t_txt      = 16
	ns_t_rp       = 17
	ns_t_afsdb    = 18
	ns_t_x25      = 19
	ns_t_isdn     = 20
	ns_t_rt       = 21
	ns_t_nsap     = 22
	ns_t_nsap_ptr = 23
	ns_t_sig      = 24
	ns_t_key      = 25
	ns_t_px       = 26
	ns_t_gpos     = 27
	ns_t_aaaa     = 28
	ns_t_loc      = 29
	ns_t_nxt      = 30
	ns_t_eid      = 31
	ns_t_nimloc   = 32
	ns_t_srv      = 33
	ns_t_atma     = 34
	ns_t_naptr    = 35
	ns_t_kx       = 36
	ns_t_cert     = 37
	ns_t_a6       = 38
	ns_t_dname    = 39
	ns_t_sink     = 40
	ns_t_opt      = 41
	ns_t_apl      = 42
	ns_t_tkey     = 249
	ns_t_tsig     = 250
	ns_t_ixfr     = 251
	ns_t_axfr     = 252
	ns_t_mailb    = 253
	ns_t_maila    = 254
	ns_t_any      = 255
	ns_t_zxfr     = 256
	ns_t_max      = 65536
)

const ( /* nameser.h:210:1: */
	ns_c_invalid = 0
	ns_c_in      = 1
	ns_c_2       = 2
	ns_c_chaos   = 3
	ns_c_hs      = 4
	ns_c_none    = 254
	ns_c_any     = 255
	ns_c_max     = 65536
)

const ( /* nameser.h:221:1: */
	ns_kt_rsa     = 1
	ns_kt_dh      = 2
	ns_kt_dsa     = 3
	ns_kt_private = 254
)

const ( /* nameser.h:228:1: */
	cert_t_pkix = 1
	cert_t_spki = 2
	cert_t_pgp  = 3
	cert_t_url  = 253
	cert_t_oid  = 254
)

const ( /* nameser.h:28:1: */
	ns_s_qd  = 0
	ns_s_zn  = 0
	ns_s_an  = 1
	ns_s_pr  = 1
	ns_s_ns  = 2
	ns_s_ud  = 2
	ns_s_ar  = 3
	ns_s_max = 4
)

const ( /* nameser.h:75:1: */
	ns_f_qr     = 0
	ns_f_opcode = 1
	ns_f_aa     = 2
	ns_f_tc     = 3
	ns_f_rd     = 4
	ns_f_ra     = 5
	ns_f_z      = 6
	ns_f_ad     = 7
	ns_f_cd     = 8
	ns_f_rcode  = 9
	ns_f_max    = 10
)

const ( /* nameser.h:89:1: */
	ns_o_query  = 0
	ns_o_iquery = 1
	ns_o_status = 2
	ns_o_notify = 4
	ns_o_update = 5
	ns_o_max    = 6
)

const ( /* nameser.h:98:1: */
	ns_r_noerror  = 0
	ns_r_formerr  = 1
	ns_r_servfail = 2
	ns_r_nxdomain = 3
	ns_r_notimpl  = 4
	ns_r_refused  = 5
	ns_r_yxdomain = 6
	ns_r_yxrrset  = 7
	ns_r_nxrrset  = 8
	ns_r_notauth  = 9
	ns_r_notzone  = 10
	ns_r_max      = 11
	ns_r_badvers  = 16
	ns_r_badsig   = 16
	ns_r_badkey   = 17
	ns_r_badtime  = 18
)

const ( /* pthread_impl.h:58:1: */
	DT_EXITING  = 0
	DT_JOINABLE = 1
	DT_DETACHED = 2
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

type uint16_t = uint16 /* alltypes.h:118:25 */

type uint32_t = uint32 /* alltypes.h:123:25 */

type uint64_t = uint64 /* alltypes.h:128:25 */

func __bswap32(tls *TLS, __x uint32_t) uint32_t { /* endian.h:24:26: */
	return __x>>24 | __x>>8&uint32_t(0xff00) | __x<<8&uint32_t(0xff0000) | __x<<24
}

var table = [384]uint16{
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0),
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0),
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0),
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0),
	uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536),
	uint16((0x200/256 | 0x200*256) % 65536), uint16((0x320/256 | 0x320*256) % 65536), uint16((0x220/256 | 0x220*256) % 65536), uint16((0x220/256 | 0x220*256) % 65536), uint16((0x220/256 | 0x220*256) % 65536), uint16((0x220/256 | 0x220*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536),
	uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536),
	uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536),
	uint16((0x160/256 | 0x160*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536),
	uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536),
	uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x8d8/256 | 0x8d8*256) % 65536),
	uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x8d8/256 | 0x8d8*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536),
	uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x8d5/256 | 0x8d5*256) % 65536), uint16((0x8d5/256 | 0x8d5*256) % 65536), uint16((0x8d5/256 | 0x8d5*256) % 65536), uint16((0x8d5/256 | 0x8d5*256) % 65536), uint16((0x8d5/256 | 0x8d5*256) % 65536), uint16((0x8d5/256 | 0x8d5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536),
	uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536),
	uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536),
	uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x8c5/256 | 0x8c5*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536),
	uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x8d6/256 | 0x8d6*256) % 65536), uint16((0x8d6/256 | 0x8d6*256) % 65536), uint16((0x8d6/256 | 0x8d6*256) % 65536), uint16((0x8d6/256 | 0x8d6*256) % 65536), uint16((0x8d6/256 | 0x8d6*256) % 65536), uint16((0x8d6/256 | 0x8d6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536),
	uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536),
	uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536),
	uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x8c6/256 | 0x8c6*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x4c0/256 | 0x4c0*256) % 65536), uint16((0x200/256 | 0x200*256) % 65536),
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0),
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0),
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0),
	uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0),
} /* __ctype_b_loc.c:9:29 */

var ptable uintptr = 0 /* __ctype_b_loc.c:36:29 */

func X__ctype_b_loc(tls *TLS) uintptr { /* __ctype_b_loc.c:38:22: */
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	return uintptr(unsafe.Pointer(&ptable))
}

func __isspace(tls *TLS, _c int32) int32 { /* ctype.h:26:21: */
	return Bool32(_c == ' ' || uint32(_c)-uint32('\t') < uint32(5))
}

type __locale_struct = struct{ cat [6]uintptr } /* alltypes.h:335:9 */

type locale_t = uintptr /* alltypes.h:335:32 */

func Xisalnum(tls *TLS, c int32) int32 { /* isalnum.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
	}
	return Bool32(func() int32 {
		if 0 != 0 {
			return Xisalpha(tls, c)
		}
		return Bool32(uint32(c)|uint32(32)-uint32('a') < uint32(26))
	}() != 0 || func() int32 {
		if 0 != 0 {
			return Xisdigit(tls, c)
		}
		return Bool32(uint32(c)-uint32('0') < uint32(10))
	}() != 0)
}

func X__isalnum_l(tls *TLS, c int32, l locale_t) int32 { /* isalnum.c:8:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
	}
	return Xisalnum(tls, c)
}

func Xisalpha(tls *TLS, c int32) int32 { /* isalpha.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
	}
	return Bool32(uint32(c)|uint32(32)-uint32('a') < uint32(26))
}

func X__isalpha_l(tls *TLS, c int32, l locale_t) int32 { /* isalpha.c:9:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
	}
	return Xisalpha(tls, c)
}

func Xisdigit(tls *TLS, c int32) int32 { /* isdigit.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
	}
	return Bool32(uint32(c)-uint32('0') < uint32(10))
}

func X__isdigit_l(tls *TLS, c int32, l locale_t) int32 { /* isdigit.c:9:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
	}
	return Xisdigit(tls, c)
}

func Xislower(tls *TLS, c int32) int32 { /* islower.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
	}
	return Bool32(uint32(c)-uint32('a') < uint32(26))
}

func X__islower_l(tls *TLS, c int32, l locale_t) int32 { /* islower.c:9:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
	}
	return Xislower(tls, c)
}

func Xisprint(tls *TLS, c int32) int32 { /* isprint.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
	}
	return Bool32(uint32(c)-uint32(0x20) < uint32(0x5f))
}

func X__isprint_l(tls *TLS, c int32, l locale_t) int32 { /* isprint.c:9:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
	}
	return Xisprint(tls, c)
}

func Xisupper(tls *TLS, c int32) int32 { /* isupper.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
	}
	return Bool32(uint32(c)-uint32('A') < uint32(26))
}

func X__isupper_l(tls *TLS, c int32, l locale_t) int32 { /* isupper.c:9:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
	}
	return Xisupper(tls, c)
}

func Xisxdigit(tls *TLS, c int32) int32 { /* isxdigit.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
	}
	return Bool32(func() int32 {
		if 0 != 0 {
			return Xisdigit(tls, c)
		}
		return Bool32(uint32(c)-uint32('0') < uint32(10))
	}() != 0 || uint32(c)|uint32(32)-uint32('a') < uint32(6))
}

func X__isxdigit_l(tls *TLS, c int32, l locale_t) int32 { /* isxdigit.c:8:5: */
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
	}
	return Xisxdigit(tls, c)
}

type off_t = int64 /* alltypes.h:154:16 */

type ino_t = uint64 /* alltypes.h:159:25 */

type dirent = struct {
	d_ino    ino_t
	d_off    off_t
	d_reclen uint16
	d_type   uint8
	d_name   [256]uint8
	_        [5]byte
} /* dirent.h:5:1 */

type __dirstream = struct {
	tell    off_t
	fd      int32
	buf_pos int32
	buf_end int32
	lock    [1]int32
	buf     [2048]uint8
} /* dirent.h:20:9 */

type DIR = __dirstream /* dirent.h:20:28 */

type ssize_t = int64 /* alltypes.h:57:15 */

type intptr_t = int64 /* alltypes.h:62:15 */

type pid_t = int32 /* alltypes.h:227:13 */

type uid_t = uint32 /* alltypes.h:237:18 */

type gid_t = uint32 /* alltypes.h:242:18 */

type useconds_t = uint32 /* alltypes.h:252:18 */

type div_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:62:35 */
type ldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:63:36 */
type lldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:64:41 */

func Xclosedir(tls *TLS, dir uintptr) int32 { /* closedir.c:6:5: */
	if __ccgo_strace {
		trc("tls=%v dir=%v, (%v:)", tls, dir, origin(2))
	}
	var ret int32 = Xclose(tls, (*DIR)(unsafe.Pointer(dir)).fd)
	Xfree(tls, dir)
	return ret
}

type mode_t = uint32 /* alltypes.h:144:18 */

type iovec = struct {
	iov_base uintptr
	iov_len  size_t
} /* alltypes.h:347:1 */

type flock = struct {
	l_type   int16
	l_whence int16
	_        [4]byte
	l_start  off_t
	l_len    off_t
	l_pid    pid_t
	_        [4]byte
} /* fcntl.h:24:1 */

type file_handle = struct {
	_            [0]uint32
	handle_bytes uint32
	handle_type  int32
} /* fcntl.h:167:1 */

type f_owner_ex = struct {
	__type int32
	pid    pid_t
} /* fcntl.h:172:1 */

type syscall_arg_t = int64 /* syscall.h:22:14 */

func Xopendir(tls *TLS, name uintptr) uintptr { /* opendir.c:8:5: */
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
	}
	var fd int32
	var dir uintptr

	if AssignInt32(&fd, Xopen(tls, name, 00|040000|02000000, 0)) < 0 {
		return uintptr(0)
	}
	if !(int32(AssignUintptr(&dir, Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(DIR{}))))) != 0) {
		__syscall1(tls, int64(6), int64(fd))
		return uintptr(0)
	}
	(*DIR)(unsafe.Pointer(dir)).fd = fd
	return dir
}

type max_align_t = struct {
	__ll int64
	__ld float64
} /* alltypes.h:33:54 */

type dirstream_buf_alignment_check = [1]uint8 /* readdir.c:7:14 */

func Xreaddir(tls *TLS, dir uintptr) uintptr { /* readdir.c:10:15: */
	if __ccgo_strace {
		trc("tls=%v dir=%v, (%v:)", tls, dir, origin(2))
	}
	var de uintptr

	if (*DIR)(unsafe.Pointer(dir)).buf_pos >= (*DIR)(unsafe.Pointer(dir)).buf_end {
		var len int32 = int32(__syscall3(tls, int64(202), int64((*DIR)(unsafe.Pointer(dir)).fd), int64(dir+24), int64(unsafe.Sizeof([2048]uint8{}))))
		if len <= 0 {
			if len < 0 && len != -2 {
				*(*int32)(unsafe.Pointer(X___errno_location(tls))) = -len
			}
			return uintptr(0)
		}
		(*DIR)(unsafe.Pointer(dir)).buf_end = len
		(*DIR)(unsafe.Pointer(dir)).buf_pos = 0
	}
	de = dir + 24 + uintptr((*DIR)(unsafe.Pointer(dir)).buf_pos)
	*(*int32)(unsafe.Pointer(dir + 12)) += int32((*dirent)(unsafe.Pointer(de)).d_reclen)
	(*DIR)(unsafe.Pointer(dir)).tell = (*dirent)(unsafe.Pointer(de)).d_off
	return de
}

type uintptr_t = uint64 /* alltypes.h:47:24 */

type int8_t = int8 /* alltypes.h:88:25 */

type int16_t = int16 /* alltypes.h:93:25 */

type int32_t = int32 /* alltypes.h:98:25 */

type int64_t = int64 /* alltypes.h:103:25 */

type intmax_t = int64 /* alltypes.h:108:25 */

type uint8_t = uint8 /* alltypes.h:113:25 */

type uintmax_t = uint64 /* alltypes.h:138:25 */

type int_fast8_t = int8_t   /* stdint.h:22:16 */
type int_fast64_t = int64_t /* stdint.h:23:17 */

type int_least8_t = int8_t   /* stdint.h:25:17 */
type int_least16_t = int16_t /* stdint.h:26:17 */
type int_least32_t = int32_t /* stdint.h:27:17 */
type int_least64_t = int64_t /* stdint.h:28:17 */

type uint_fast8_t = uint8_t   /* stdint.h:30:17 */
type uint_fast64_t = uint64_t /* stdint.h:31:18 */

type uint_least8_t = uint8_t   /* stdint.h:33:18 */
type uint_least16_t = uint16_t /* stdint.h:34:18 */
type uint_least32_t = uint32_t /* stdint.h:35:18 */
type uint_least64_t = uint64_t /* stdint.h:36:18 */

type int_fast16_t = int32_t   /* stdint.h:1:17 */
type int_fast32_t = int32_t   /* stdint.h:2:17 */
type uint_fast16_t = uint32_t /* stdint.h:3:18 */
type uint_fast32_t = uint32_t /* stdint.h:4:18 */

type _IO_FILE = struct {
	flags        uint32
	_            [4]byte
	rpos         uintptr
	rend         uintptr
	close        uintptr
	wend         uintptr
	wpos         uintptr
	mustbezero_1 uintptr
	wbase        uintptr
	read         uintptr
	write        uintptr
	seek         uintptr
	buf          uintptr
	buf_size     size_t
	prev         uintptr
	next         uintptr
	fd           int32
	pipe_pid     int32
	lockcount    int64
	mode         int32
	lock         int32
	lbf          int32
	_            [4]byte
	cookie       uintptr
	off          off_t
	getln_buf    uintptr
	mustbezero_2 uintptr
	shend        uintptr
	shlim        off_t
	shcnt        off_t
	prev_locked  uintptr
	next_locked  uintptr
	locale       uintptr
} /* alltypes.h:312:9 */

type FILE = _IO_FILE /* alltypes.h:312:25 */

type va_list = uintptr /* alltypes.h:318:27 */

type _G_fpos64_t = struct {
	_        [0]uint64
	__opaque [16]uint8
} /* stdio.h:54:9 */

type fpos_t = _G_fpos64_t /* stdio.h:58:3 */

type float_t = float32 /* alltypes.h:22:15 */

type double_t = float64 /* alltypes.h:27:16 */

func __FLOAT_BITS(tls *TLS, __f float32) uint32 { /* math.h:55:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var __u struct {__f float32;} at bp, 4

	*(*float32)(unsafe.Pointer(bp)) = __f
	return *(*uint32)(unsafe.Pointer(bp))
}

func __DOUBLE_BITS(tls *TLS, __f float64) uint64 { /* math.h:61:36: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var __u struct {__f float64;} at bp, 8

	*(*float64)(unsafe.Pointer(bp)) = __f
	return *(*uint64)(unsafe.Pointer(bp))
}

type __pthread = struct {
	self          uintptr
	dtv           uintptr
	prev          uintptr
	next          uintptr
	sysinfo       uintptr_t
	canary        uintptr_t
	canary2       uintptr_t
	tid           int32
	errno_val     int32
	detach_state  int32
	cancel        int32
	canceldisable uint8
	cancelasync   uint8
	tsd_used      uint8 /* unsigned char tsd_used: 1, unsigned char dlerror_flag: 1 */
	_             [5]byte
	map_base      uintptr
	map_size      size_t
	stack         uintptr
	stack_size    size_t
	guard_size    size_t
	result        uintptr
	cancelbuf     uintptr
	tsd           uintptr
	robust_list   struct {
		head    uintptr
		off     int64
		pending uintptr
	}
	timer_id      int32
	_             [4]byte
	locale        locale_t
	killlock      [1]int32
	_             [4]byte
	dlerror_buf   uintptr
	stdio_locks   uintptr
	canary_at_end uintptr_t
	dtv_copy      uintptr
} /* alltypes.h:265:9 */

func scanexp(tls *TLS, f uintptr, pok int32) int64 { /* floatscan.c:37:18: */
	var c int32
	var x int32
	var y int64
	var neg int32 = 0

	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	if c == '+' || c == '-' {
		neg = Bool32(c == '-')
		c = func() int32 {
			if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
		if uint32(c-'0') >= 10 && pok != 0 {
			if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
		}
	}
	if uint32(c-'0') >= 10 {
		if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
		return -0x7fffffffffffffff - int64(1)
	}
	for x = 0; uint32(c-'0') < 10 && x < 0x7fffffff/10; c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		x = 10*x + c - '0'
	}
	for y = int64(x); uint32(c-'0') < 10 && y < 0x7fffffffffffffff/int64(100); c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		y = int64(10)*y + int64(c) - int64('0')
	}
	for ; uint32(c-'0') < 10; c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
	}
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if neg != 0 {
		return -y
	}
	return y
}

func decfloat(tls *TLS, f uintptr, c int32, bits int32, emin int32, sign int32, pok int32) float64 { /* floatscan.c:64:20: */
	bp := tls.Alloc(512)
	defer tls.Free(512)

	// var x [128]uint32_t at bp, 512

	var i int32
	var j int32
	var k int32
	var a int32
	var z int32
	var lrp int64 = int64(0)
	var dc int64 = int64(0)
	var e10 int64 = int64(0)
	var lnz int32 = 0
	var gotdig int32 = 0
	var gotrad int32 = 0
	var rp int32
	var e2 int32
	var emax int32 = -emin - bits + 3
	var denormal int32 = 0
	var y float64
	var frac float64 = float64(0)
	var bias float64 = float64(0)

	j = 0
	k = 0

	// Don't let leading zeros consume buffer space
	for ; c == '0'; c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		gotdig = 1
	}
	if c == '.' {
		gotrad = 1
		for c = func() int32 {
			if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}(); c == '0'; c = func() int32 {
			if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}() {
			gotdig = 1
			lrp--
		}
	}

	*(*uint32_t)(unsafe.Pointer(bp)) = uint32_t(0)
	for ; uint32(c-'0') < 10 || c == '.'; c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		if c == '.' {
			if gotrad != 0 {
				break
			}
			gotrad = 1
			lrp = dc
		} else if k < 128-3 {
			dc++
			if c != '0' {
				lnz = int32(dc)
			}
			if j != 0 {
				*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) = *(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4))*uint32_t(10) + uint32_t(c) - uint32_t('0')
			} else {
				*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) = uint32_t(c - '0')
			}
			if PreIncInt32(&j, 1) == 9 {
				k++
				j = 0
			}
			gotdig = 1
		} else {
			dc++
			if c != '0' {
				lnz = (128 - 4) * 9
				*(*uint32_t)(unsafe.Pointer(bp + 124*4)) |= uint32_t(1)
			}
		}
	}
	if !(gotrad != 0) {
		lrp = dc
	}

	if gotdig != 0 && c|32 == 'e' {
		e10 = scanexp(tls, f, pok)
		if e10 == -0x7fffffffffffffff-int64(1) {
			if pok != 0 {
				if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
					(*FILE)(unsafe.Pointer(f)).rpos--
				} else {
				}
			} else {
				X__shlim(tls, f, int64(0))
				return float64(0)
			}
			e10 = int64(0)
		}
		lrp = lrp + e10
	} else if c >= 0 {
		if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
	}
	if !(gotdig != 0) {
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 22
		X__shlim(tls, f, int64(0))
		return float64(0)
	}

	// Handle zero specially to avoid nasty special cases later
	if !(int32(*(*uint32_t)(unsafe.Pointer(bp))) != 0) {
		return float64(sign) * 0.0
	}

	// Optimize small integers (w/no exponent) and over/under-flow
	if lrp == dc && dc < int64(10) && (bits > 30 || *(*uint32_t)(unsafe.Pointer(bp))>>bits == uint32_t(0)) {
		return float64(sign) * float64(*(*uint32_t)(unsafe.Pointer(bp)))
	}
	if lrp > int64(-emin/2) {
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
		return float64(sign) * 1.79769313486231570815e+308 * 1.79769313486231570815e+308
	}
	if lrp < int64(emin-2*53) {
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
		return float64(sign) * 2.22507385850720138309e-308 * 2.22507385850720138309e-308
	}

	// Align incomplete final B1B digit
	if j != 0 {
		for ; j < 9; j++ {
			*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) *= uint32_t(10)
		}
		k++
		j = 0
	}

	a = 0
	z = k
	e2 = 0
	rp = int32(lrp)

	// Optimize small to mid-size integers (even in exp. notation)
	if lnz < 9 && lnz <= rp && rp < 18 {
		if rp == 9 {
			return float64(sign) * float64(*(*uint32_t)(unsafe.Pointer(bp)))
		}
		if rp < 9 {
			return float64(sign) * float64(*(*uint32_t)(unsafe.Pointer(bp))) / float64(_sp10s[8-rp])
		}
		var bitlim int32 = bits - 3*(rp-9)
		if bitlim > 30 || *(*uint32_t)(unsafe.Pointer(bp))>>bitlim == uint32_t(0) {
			return float64(sign) * float64(*(*uint32_t)(unsafe.Pointer(bp))) * float64(_sp10s[rp-10])
		}
	}

	// Drop trailing zeros
	for ; !(int32(*(*uint32_t)(unsafe.Pointer(bp + uintptr(z-1)*4))) != 0); z-- {
	}

	// Align radix point to B1B digit boundary
	if rp%9 != 0 {
		var rpm9 int32
		if rp >= 0 {
			rpm9 = rp % 9
		} else {
			rpm9 = rp%9 + 9
		}
		var p10 int32 = _sp10s[8-rpm9]
		var carry uint32_t = uint32_t(0)
		for k = a; k != z; k++ {
			var tmp uint32_t = *(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) % uint32_t(p10)
			*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) = *(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4))/uint32_t(p10) + carry
			carry = uint32_t(1000000000/p10) * tmp
			if k == a && !(int32(*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4))) != 0) {
				a = (a + 1) & (128 - 1)
				rp = rp - 9
			}
		}
		if carry != 0 {
			*(*uint32_t)(unsafe.Pointer(bp + uintptr(PostIncInt32(&z, 1))*4)) = carry
		}
		rp = rp + (9 - rpm9)
	}

	// Upscale until desired number of bits are left of radix point
	for rp < 9*2 || rp == 9*2 && *(*uint32_t)(unsafe.Pointer(bp + uintptr(a)*4)) < _sth[0] {
		var carry uint32_t = uint32_t(0)
		e2 = e2 - 29
		for k = (z - 1) & (128 - 1); ; k = (k - 1) & (128 - 1) {
			var tmp uint64_t = uint64_t(*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)))<<29 + uint64_t(carry)
			if tmp > uint64(1000000000) {
				carry = uint32_t(tmp / uint64(1000000000))
				*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) = uint32_t(tmp % uint64(1000000000))
			} else {
				carry = uint32_t(0)
				*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) = uint32_t(tmp)
			}
			if k == (z-1)&(128-1) && k != a && !(int32(*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4))) != 0) {
				z = k
			}
			if k == a {
				break
			}
		}
		if carry != 0 {
			rp = rp + 9
			a = (a - 1) & (128 - 1)
			if a == z {
				z = (z - 1) & (128 - 1)
				*(*uint32_t)(unsafe.Pointer(bp + uintptr((z-1)&(128-1))*4)) |= *(*uint32_t)(unsafe.Pointer(bp + uintptr(z)*4))
			}
			*(*uint32_t)(unsafe.Pointer(bp + uintptr(a)*4)) = carry
		}
	}

	// Downscale until exactly number of bits are left of radix point
	for {
		var carry uint32_t = uint32_t(0)
		var sh int32 = 1
		for i = 0; i < 2; i++ {
			k = (a + i) & (128 - 1)
			if k == z || *(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) < _sth[i] {
				i = 2
				break
			}
			if *(*uint32_t)(unsafe.Pointer(bp + uintptr((a+i)&(128-1))*4)) > _sth[i] {
				break
			}
		}
		if i == 2 && rp == 9*2 {
			break
		}
		// FIXME: find a way to compute optimal sh
		if rp > 9+9*2 {
			sh = 9
		}
		e2 = e2 + sh
		for k = a; k != z; k = (k + 1) & (128 - 1) {
			var tmp uint32_t = *(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) & uint32_t(int32(1)<<sh-1)
			*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) = *(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4))>>sh + carry
			carry = uint32_t(int32(1000000000)>>sh) * tmp
			if k == a && !(int32(*(*uint32_t)(unsafe.Pointer(bp + uintptr(k)*4))) != 0) {
				a = (a + 1) & (128 - 1)
				i--
				rp = rp - 9
			}
		}
		if carry != 0 {
			if (z+1)&(128-1) != a {
				*(*uint32_t)(unsafe.Pointer(bp + uintptr(z)*4)) = carry
				z = (z + 1) & (128 - 1)
			} else {
				*(*uint32_t)(unsafe.Pointer(bp + uintptr((z-1)&(128-1))*4)) |= uint32_t(1)
			}
		}
	}

	// Assemble desired bits into floating point variable
	for y = float64(AssignInt32(&i, 0)); i < 2; i++ {
		if (a+i)&(128-1) == z {
			*(*uint32_t)(unsafe.Pointer(bp + uintptr(AssignInt32(&z, (z+1)&(128-1))-1)*4)) = uint32_t(0)
		}
		y = 1000000000.0*y + float64(*(*uint32_t)(unsafe.Pointer(bp + uintptr((a+i)&(128-1))*4)))
	}

	y = y * float64(sign)

	// Limit precision for denormal results
	if bits > 53+e2-emin {
		bits = 53 + e2 - emin
		if bits < 0 {
			bits = 0
		}
		denormal = 1
	}

	// Calculate bias term to force rounding, move out lower bits
	if bits < 53 {
		bias = Xcopysignl(tls, Xscalbn(tls, float64(1), 2*53-bits-1), y)
		frac = Xfmodl(tls, y, Xscalbn(tls, float64(1), 53-bits))
		y = y - frac
		y = y + bias
	}

	// Process tail of decimal input so it can affect rounding
	if (a+i)&(128-1) != z {
		var t uint32_t = *(*uint32_t)(unsafe.Pointer(bp + uintptr((a+i)&(128-1))*4))
		if t < uint32_t(500000000) && (t != 0 || (a+i+1)&(128-1) != z) {
			frac = frac + 0.25*float64(sign)
		} else if t > uint32_t(500000000) {
			frac = frac + 0.75*float64(sign)
		} else if t == uint32_t(500000000) {
			if (a+i+1)&(128-1) == z {
				frac = frac + 0.5*float64(sign)
			} else {
				frac = frac + 0.75*float64(sign)
			}
		}
		if 53-bits >= 2 && !(Xfmodl(tls, frac, float64(1)) != 0) {
			frac += 1
		}
	}

	y = y + frac
	y = y - bias

	if (e2+53)&0x7fffffff > emax-5 {
		if Xfabsl(tls, y) >= float64(float64(2))/2.22044604925031308085e-16 {
			if denormal != 0 && bits == 53+e2-emin {
				denormal = 0
			}
			y = y * 0.5
			e2++
		}
		if e2+53 > emax || denormal != 0 && frac != 0 {
			*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
		}
	}

	return Xscalbnl(tls, y, e2)
}

var _sth = [2]uint32_t{uint32_t(9007199), uint32_t(254740991)} /* floatscan.c:67:24 */
var _sp10s = [8]int32{10, 100, 1000, 10000,
	100000, 1000000, 10000000, 100000000} /* floatscan.c:80:19 */

func hexfloat(tls *TLS, f uintptr, bits int32, emin int32, sign int32, pok int32) float64 { /* floatscan.c:315:20: */
	var x uint32_t = uint32_t(0)
	var y float64 = float64(0)
	var scale float64 = float64(1)
	var bias float64 = float64(0)
	var gottail int32 = 0
	var gotrad int32 = 0
	var gotdig int32 = 0
	var rp int64 = int64(0)
	var dc int64 = int64(0)
	var e2 int64 = int64(0)
	var d int32
	var c int32

	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()

	// Skip leading zeros
	for ; c == '0'; c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		gotdig = 1
	}

	if c == '.' {
		gotrad = 1
		c = func() int32 {
			if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
		// Count zeros after the radix point before significand
		rp = int64(0)
	__1:
		if !(c == '0') {
			goto __3
		}
		gotdig = 1
		goto __2
	__2:
		c = func() int32 {
			if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
		rp--
		goto __1
		goto __3
	__3:
	}

	for ; uint32(c-'0') < 10 || uint32(c|32-'a') < 6 || c == '.'; c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() {
		if c == '.' {
			if gotrad != 0 {
				break
			}
			rp = dc
			gotrad = 1
		} else {
			gotdig = 1
			if c > '9' {
				d = c | 32 + 10 - 'a'
			} else {
				d = c - '0'
			}
			if dc < int64(8) {
				x = x*uint32_t(16) + uint32_t(d)
			} else if dc < int64(53/4+1) {
				y = y + float64(d)*AssignDivFloat64(&scale, float64(16))
			} else if d != 0 && !(gottail != 0) {
				y = y + 0.5*scale
				gottail = 1
			}
			dc++
		}
	}
	if !(gotdig != 0) {
		if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
		if pok != 0 {
			if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
			if gotrad != 0 {
				if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
					(*FILE)(unsafe.Pointer(f)).rpos--
				} else {
				}
			}
		} else {
			X__shlim(tls, f, int64(0))
		}
		return float64(sign) * 0.0
	}
	if !(gotrad != 0) {
		rp = dc
	}
	for dc < int64(8) {
		x = x * uint32_t(16)
		dc++
	}
	if c|32 == 'p' {
		e2 = scanexp(tls, f, pok)
		if e2 == -0x7fffffffffffffff-int64(1) {
			if pok != 0 {
				if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
					(*FILE)(unsafe.Pointer(f)).rpos--
				} else {
				}
			} else {
				X__shlim(tls, f, int64(0))
				return float64(0)
			}
			e2 = int64(0)
		}
	} else {
		if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
	}
	e2 = e2 + (int64(4)*rp - int64(32))

	if !(x != 0) {
		return float64(sign) * 0.0
	}
	if e2 > int64(-emin) {
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
		return float64(sign) * 1.79769313486231570815e+308 * 1.79769313486231570815e+308
	}
	if e2 < int64(emin-2*53) {
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
		return float64(sign) * 2.22507385850720138309e-308 * 2.22507385850720138309e-308
	}

	for x < 0x80000000 {
		if y >= 0.5 {
			x = x + (x + uint32_t(1))
			y = y + (y - float64(1))
		} else {
			x = x + x
			y = y + y
		}
		e2--
	}

	if int64(bits) > int64(32)+e2-int64(emin) {
		bits = int32(int64(32) + e2 - int64(emin))
		if bits < 0 {
			bits = 0
		}
	}

	if bits < 53 {
		bias = Xcopysignl(tls, Xscalbn(tls, float64(1), 32+53-bits-1), float64(sign))
	}

	if bits < 32 && y != 0 && !(x&uint32_t(1) != 0) {
		x++
		y = float64(0)
	}

	y = bias + float64(sign)*float64(x) + float64(sign)*y
	y = y - bias

	if !(y != 0) {
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
	}

	return Xscalbnl(tls, y, int32(e2))
}

func X__floatscan(tls *TLS, f uintptr, prec int32, pok int32) float64 { /* floatscan.c:427:13: */
	if __ccgo_strace {
		trc("tls=%v f=%v prec=%v pok=%v, (%v:)", tls, f, prec, pok, origin(2))
	}
	var sign int32 = 1
	var i size_t
	var bits int32
	var emin int32
	var c int32

	switch prec {
	case 0:
		bits = 24
		emin = -125 - bits
		break
	case 1:
		bits = 53
		emin = -1021 - bits
		break
	case 2:
		bits = 53
		emin = -1021 - bits
		break
	default:
		return float64(0)
	}

	for __isspace(tls, AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())) != 0 {
	}

	if c == '+' || c == '-' {
		sign = sign - 2*Bool32(c == '-')
		c = func() int32 {
			if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
	}

	for i = uint64(0); i < uint64(8) && c|32 == int32(*(*uint8)(unsafe.Pointer(ts /* "infinity" */ + uintptr(i)))); i++ {
		if i < uint64(7) {
			c = func() int32 {
				if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
					return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
				}
				return X__shgetc(tls, f)
			}()
		}
	}
	if i == uint64(3) || i == uint64(8) || i > uint64(3) && pok != 0 {
		if i != uint64(8) {
			if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
			if pok != 0 {
				for ; i > uint64(3); i-- {
					if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
						(*FILE)(unsafe.Pointer(f)).rpos--
					} else {
					}
				}
			}
		}
		return float64(float32(sign) * X__builtin_inff(tls))
	}
	if !(i != 0) {
		for i = uint64(0); i < uint64(3) && c|32 == int32(*(*uint8)(unsafe.Pointer(ts + 9 /* "nan" */ + uintptr(i)))); i++ {
			if i < uint64(2) {
				c = func() int32 {
					if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
						return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
					}
					return X__shgetc(tls, f)
				}()
			}
		}
	}
	if i == uint64(3) {
		if func() int32 {
			if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}() != '(' {
			if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
			return float64(X__builtin_nanf(tls, ts+13))
		}
		for i = uint64(1); ; i++ {
			c = func() int32 {
				if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
					return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
				}
				return X__shgetc(tls, f)
			}()
			if uint32(c-'0') < 10 || uint32(c-'A') < 26 || uint32(c-'a') < 26 || c == '_' {
				continue
			}
			if c == ')' {
				return float64(X__builtin_nanf(tls, ts+13))
			}
			if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
				(*FILE)(unsafe.Pointer(f)).rpos--
			} else {
			}
			if !(pok != 0) {
				*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 22
				X__shlim(tls, f, int64(0))
				return float64(0)
			}
			for PostDecUint64(&i, 1) != 0 {
				if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
					(*FILE)(unsafe.Pointer(f)).rpos--
				} else {
				}
			}
			return float64(X__builtin_nanf(tls, ts+13))
		}
		return float64(X__builtin_nanf(tls, ts+13))
	}

	if i != 0 {
		if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 22
		X__shlim(tls, f, int64(0))
		return float64(0)
	}

	if c == '0' {
		c = func() int32 {
			if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
				return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
			}
			return X__shgetc(tls, f)
		}()
		if c|32 == 'x' {
			return hexfloat(tls, f, bits, emin, sign, pok)
		}
		if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
			(*FILE)(unsafe.Pointer(f)).rpos--
		} else {
		}
		c = '0'
	}

	return decfloat(tls, f, c, bits, emin, sign, pok)
}

// Lookup table for digit values. -1==255>=36 -> invalid
var table1 = [257]uint8{Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24),
	uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24),
	uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
	Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1), Uint8FromInt32(-1),
} /* intscan.c:7:28 */

func X__intscan(tls *TLS, f uintptr, base uint32, pok int32, lim uint64) uint64 { /* intscan.c:26:20: */
	if __ccgo_strace {
		trc("tls=%v f=%v base=%v pok=%v lim=%v, (%v:)", tls, f, base, pok, lim, origin(2))
	}
	var val uintptr
	var c int32
	var neg int32
	var x uint32
	var y uint64
	var bs int32
	val = uintptr(unsafe.Pointer(&table1)) + uintptr(1)
	neg = 0
	if !(base > uint32(36) || base == uint32(1)) {
		goto __1
	}
	*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 22
	return uint64(0)
__1:
	;
__2:
	if !(__isspace(tls, AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())) != 0) {
		goto __3
	}
	goto __2
__3:
	;
	if !(c == '+' || c == '-') {
		goto __4
	}
	neg = -Bool32(c == '-')
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
__4:
	;
	if !((base == uint32(0) || base == uint32(16)) && c == '0') {
		goto __5
	}
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	if !(c|32 == 'x') {
		goto __7
	}
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	if !(int32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= 16) {
		goto __9
	}
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if !(pok != 0) {
		goto __10
	}
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	goto __11
__10:
	X__shlim(tls, f, int64(0))
__11:
	;
	return uint64(0)
__9:
	;
	base = uint32(16)
	goto __8
__7:
	if !(base == uint32(0)) {
		goto __12
	}
	base = uint32(8)
__12:
	;
__8:
	;
	goto __6
__5:
	if !(base == uint32(0)) {
		goto __13
	}
	base = uint32(10)
__13:
	;
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= base) {
		goto __14
	}
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	X__shlim(tls, f, int64(0))
	*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 22
	return uint64(0)
__14:
	;
__6:
	;
	if !(base == uint32(10)) {
		goto __15
	}
	x = uint32(0)
__17:
	if !(uint32(c-'0') < 10 && x <= 0xffffffff/uint32(10)-uint32(1)) {
		goto __19
	}
	x = x*uint32(10) + uint32(c-'0')
	goto __18
__18:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __17
	goto __19
__19:
	;
	y = uint64(x)
__20:
	if !(uint32(c-'0') < 10 && y <= (2*uint64(0x7fffffffffffffff)+uint64(1))/uint64(10) && uint64(10)*y <= 2*uint64(0x7fffffffffffffff)+uint64(1)-uint64(c-'0')) {
		goto __22
	}
	y = y*uint64(10) + uint64(c-'0')
	goto __21
__21:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __20
	goto __22
__22:
	;
	if !(uint32(c-'0') >= 10) {
		goto __23
	}
	goto done
__23:
	;
	goto __16
__15:
	if !!(base&(base-uint32(1)) != 0) {
		goto __24
	}
	bs = int32(*(*uint8)(unsafe.Pointer(ts + 14 + uintptr(uint32(0x17)*base>>5&uint32(7)))))
	x = uint32(0)
__26:
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && x <= 0xffffffff/uint32(32)) {
		goto __28
	}
	x = x<<bs | uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
	goto __27
__27:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __26
	goto __28
__28:
	;
	y = uint64(x)
__29:
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && y <= uint64(2*uint64(0x7fffffffffffffff)+uint64(1))>>bs) {
		goto __31
	}
	y = y<<bs | uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
	goto __30
__30:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __29
	goto __31
__31:
	;
	goto __25
__24:
	x = uint32(0)
__32:
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && x <= 0xffffffff/uint32(36)-uint32(1)) {
		goto __34
	}
	x = x*base + uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
	goto __33
__33:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __32
	goto __34
__34:
	;
	y = uint64(x)
__35:
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && y <= (2*uint64(0x7fffffffffffffff)+uint64(1))/uint64(base) && uint64(base)*y <= 2*uint64(0x7fffffffffffffff)+uint64(1)-uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))) {
		goto __37
	}
	y = y*uint64(base) + uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
	goto __36
__36:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __35
	goto __37
__37:
	;
__25:
	;
__16:
	;
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) {
		goto __38
	}
__39:
	if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) {
		goto __41
	}
	goto __40
__40:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
	goto __39
	goto __41
__41:
	;
	*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
	y = lim
	if !(lim&uint64(1) != 0) {
		goto __42
	}
	neg = 0
__42:
	;
__38:
	;
done:
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if !(y >= lim) {
		goto __43
	}
	if !(!(lim&uint64(1) != 0) && !(neg != 0)) {
		goto __44
	}
	*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
	return lim - uint64(1)
	goto __45
__44:
	if !(y > lim) {
		goto __46
	}
	*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 34
	return lim
__46:
	;
__45:
	;
__43:
	;
	return y ^ uint64(neg) - uint64(neg)
}

// The shcnt field stores the number of bytes read so far, offset by
// the value of buf-rpos at the last function call (__shlim or __shgetc),
// so that between calls the inline shcnt macro can add rpos-buf to get
// the actual count.

func X__shlim(tls *TLS, f uintptr, lim off_t) { /* shgetc.c:8:6: */
	if __ccgo_strace {
		trc("tls=%v f=%v lim=%v, (%v:)", tls, f, lim, origin(2))
	}
	(*FILE)(unsafe.Pointer(f)).shlim = lim
	(*FILE)(unsafe.Pointer(f)).shcnt = (int64((*FILE)(unsafe.Pointer(f)).buf) - int64((*FILE)(unsafe.Pointer(f)).rpos)) / 1
	// If lim is nonzero, rend must be a valid pointer.
	if lim != 0 && (int64((*FILE)(unsafe.Pointer(f)).rend)-int64((*FILE)(unsafe.Pointer(f)).rpos))/1 > lim {
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rpos + uintptr(lim)
	} else {
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rend
	}
}

func X__shgetc(tls *TLS, f uintptr) int32 { /* shgetc.c:19:5: */
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	var c int32
	var cnt off_t = (*FILE)(unsafe.Pointer(f)).shcnt + (int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1
	if (*FILE)(unsafe.Pointer(f)).shlim != 0 && cnt >= (*FILE)(unsafe.Pointer(f)).shlim || AssignInt32(&c, X__uflow(tls, f)) < 0 {
		(*FILE)(unsafe.Pointer(f)).shcnt = (int64((*FILE)(unsafe.Pointer(f)).buf)-int64((*FILE)(unsafe.Pointer(f)).rpos))/1 + cnt
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rpos
		(*FILE)(unsafe.Pointer(f)).shlim = int64(-1)
		return -1
	}
	cnt++
	if (*FILE)(unsafe.Pointer(f)).shlim != 0 && (int64((*FILE)(unsafe.Pointer(f)).rend)-int64((*FILE)(unsafe.Pointer(f)).rpos))/1 > (*FILE)(unsafe.Pointer(f)).shlim-cnt {
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rpos + uintptr((*FILE)(unsafe.Pointer(f)).shlim-cnt)
	} else {
		(*FILE)(unsafe.Pointer(f)).shend = (*FILE)(unsafe.Pointer(f)).rend
	}
	(*FILE)(unsafe.Pointer(f)).shcnt = (int64((*FILE)(unsafe.Pointer(f)).buf)-int64((*FILE)(unsafe.Pointer(f)).rpos))/1 + cnt
	if (*FILE)(unsafe.Pointer(f)).rpos <= (*FILE)(unsafe.Pointer(f)).buf {
		*(*uint8)(unsafe.Pointer((*FILE)(unsafe.Pointer(f)).rpos + UintptrFromInt32(-1))) = uint8(c)
	}
	return c
}

type lconv = struct {
	decimal_point      uintptr
	thousands_sep      uintptr
	grouping           uintptr
	int_curr_symbol    uintptr
	currency_symbol    uintptr
	mon_decimal_point  uintptr
	mon_thousands_sep  uintptr
	mon_grouping       uintptr
	positive_sign      uintptr
	negative_sign      uintptr
	int_frac_digits    uint8
	frac_digits        uint8
	p_cs_precedes      uint8
	p_sep_by_space     uint8
	n_cs_precedes      uint8
	n_sep_by_space     uint8
	p_sign_posn        uint8
	n_sign_posn        uint8
	int_p_cs_precedes  uint8
	int_p_sep_by_space uint8
	int_n_cs_precedes  uint8
	int_n_sep_by_space uint8
	int_p_sign_posn    uint8
	int_n_sign_posn    uint8
	_                  [2]byte
} /* locale.h:24:1 */

// Support signed or unsigned plain-char

// Implementation choices...

// Arbitrary numbers...

// POSIX/SUS requirements follow. These numbers come directly
// from SUS and have nothing to do with the host system.

var posix_lconv = lconv{decimal_point: ts + 23, thousands_sep: ts + 13, grouping: ts + 13, int_curr_symbol: ts + 13, currency_symbol: ts + 13, mon_decimal_point: ts + 13, mon_thousands_sep: ts + 13, mon_grouping: ts + 13, positive_sign: ts + 13, negative_sign: ts + 13, int_frac_digits: uint8(255), frac_digits: uint8(255), p_cs_precedes: uint8(255), p_sep_by_space: uint8(255), n_cs_precedes: uint8(255), n_sep_by_space: uint8(255), p_sign_posn: uint8(255), n_sign_posn: uint8(255), int_p_cs_precedes: uint8(255), int_p_sep_by_space: uint8(255), int_n_cs_precedes: uint8(255), int_n_sep_by_space: uint8(255), int_p_sign_posn: uint8(255), int_n_sign_posn: uint8(255)} /* localeconv.c:4:27 */

func Xlocaleconv(tls *TLS) uintptr { /* localeconv.c:31:14: */
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	return uintptr(unsafe.Pointer(&posix_lconv))
}

func X__fpclassify(tls *TLS, x float64) int32 { /* __fpclassify.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
	}
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*struct{ f float64 })(unsafe.Pointer(bp)) = func() (r struct{ f float64 }) {
		*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = x
		return r
	}()
	var e int32 = int32(*(*uint64_t)(unsafe.Pointer(bp)) >> 52 & uint64(0x7ff))
	if !(e != 0) {
		if *(*uint64_t)(unsafe.Pointer(bp))<<1 != 0 {
			return 3
		}
		return 2
	}
	if e == 0x7ff {
		if *(*uint64_t)(unsafe.Pointer(bp))<<12 != 0 {
			return 0
		}
		return 1
	}
	return 4
}

func X__fpclassifyf(tls *TLS, x float32) int32 { /* __fpclassifyf.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
	}
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*struct{ f float32 })(unsafe.Pointer(bp)) = func() (r struct{ f float32 }) {
		*(*float32)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = x
		return r
	}()
	var e int32 = int32(*(*uint32_t)(unsafe.Pointer(bp)) >> 23 & uint32_t(0xff))
	if !(e != 0) {
		if *(*uint32_t)(unsafe.Pointer(bp))<<1 != 0 {
			return 3
		}
		return 2
	}
	if e == 0xff {
		if *(*uint32_t)(unsafe.Pointer(bp))<<9 != 0 {
			return 0
		}
		return 1
	}
	return 4
}

func X__fpclassifyl(tls *TLS, x float64) int32 { /* __fpclassifyl.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
	}
	return X__fpclassify(tls, x)
}

func Xcopysignl(tls *TLS, x float64, y float64) float64 { /* copysignl.c:4:13: */
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
	}
	return Xcopysign(tls, x, y)
}

func Xfabsl(tls *TLS, x float64) float64 { /* fabsl.c:3:13: */
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
	}
	return Xfabs(tls, x)
}

func Xfmodl(tls *TLS, x float64, y float64) float64 { /* fmodl.c:4:13: */
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
	}
	return Xfmod(tls, x, y)
}

func Xnanf(tls *TLS, s uintptr) float32 { /* nanf.c:3:7: */
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
	}
	return X__builtin_nanf(tls, ts+13)
}

var toint double_t = float64(float64(1)) / 2.22044604925031308085e-16 /* rint.c:10:23 */

func Xrint(tls *TLS, x float64) float64 { /* rint.c:12:8: */
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
	}
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*struct{ f float64 })(unsafe.Pointer(bp)) = func() (r struct{ f float64 }) {
		*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = x
		return r
	}()
	var e int32 = int32(*(*uint64_t)(unsafe.Pointer(bp)) >> 52 & uint64(0x7ff))
	var s int32 = int32(*(*uint64_t)(unsafe.Pointer(bp)) >> 63)
	var y double_t

	if e >= 0x3ff+52 {
		return x
	}
	if s != 0 {
		y = x - toint + toint
	} else {
		y = x + toint - toint
	}
	if y == float64(0) {
		if s != 0 {
			return -Float64FromFloat64(0.0)
		}
		return float64(0)
	}
	return y
}

func Xscalbn(tls *TLS, x float64, n int32) float64 { /* scalbn.c:4:8: */
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
	}
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var u struct {f float64;} at bp, 8

	var y double_t = x

	if n > 1023 {
		y = y * 0x1p1023
		n = n - 1023
		if n > 1023 {
			y = y * 0x1p1023
			n = n - 1023
			if n > 1023 {
				n = 1023
			}
		}
	} else if n < -1022 {
		// make sure final n < -53 to avoid double
		// 		   rounding in the subnormal range
		y = y * (float64(0x1p-1022) * 0x1p53)
		n = n + (1022 - 53)
		if n < -1022 {
			y = y * (float64(0x1p-1022) * 0x1p53)
			n = n + (1022 - 53)
			if n < -1022 {
				n = -1022
			}
		}
	}
	*(*uint64_t)(unsafe.Pointer(bp)) = uint64_t(0x3ff+n) << 52
	x = y * *(*float64)(unsafe.Pointer(bp))
	return x
}

func Xscalbnl(tls *TLS, x float64, n int32) float64 { /* scalbnl.c:4:13: */
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
	}
	return Xscalbn(tls, x, n)
}

// Support signed or unsigned plain-char

// Implementation choices...

// Arbitrary numbers...

// POSIX/SUS requirements follow. These numbers come directly
// from SUS and have nothing to do with the host system.

type __locale_map = struct {
	__map    uintptr
	map_size size_t
	name     [24]uint8
	next     uintptr
} /* alltypes.h:335:9 */

type tls_module = struct {
	next   uintptr
	image  uintptr
	len    size_t
	size   size_t
	align  size_t
	offset size_t
} /* libc.h:14:1 */

type __libc = struct {
	can_do_threads  uint8
	threaded        uint8
	secure          uint8
	need_locks      int8
	threads_minus_1 int32
	auxv            uintptr
	tls_head        uintptr
	tls_size        size_t
	tls_align       size_t
	tls_cnt         size_t
	page_size       size_t
	global_locale   struct{ cat [6]uintptr }
} /* libc.h:20:1 */

type time_t = int64 /* alltypes.h:77:16 */

type clockid_t = int32 /* alltypes.h:206:13 */

type timespec = struct {
	tv_sec  time_t
	tv_nsec int64
} /* alltypes.h:221:1 */

type pthread_t = uintptr /* alltypes.h:265:26 */

type pthread_once_t = int32 /* alltypes.h:271:13 */

type pthread_key_t = uint32 /* alltypes.h:276:18 */

type pthread_spinlock_t = int32 /* alltypes.h:281:13 */

type pthread_mutexattr_t = struct{ __attr uint32 } /* alltypes.h:286:37 */

type pthread_condattr_t = struct{ __attr uint32 } /* alltypes.h:291:37 */

type pthread_barrierattr_t = struct{ __attr uint32 } /* alltypes.h:296:37 */

type pthread_rwlockattr_t = struct{ __attr [2]uint32 } /* alltypes.h:301:40 */

type __sigset_t = struct{ __bits [16]uint64 } /* alltypes.h:341:9 */

type sigset_t = __sigset_t /* alltypes.h:341:71 */

type pthread_attr_t = struct {
	__u struct {
		_   [0]uint64
		__i [14]int32
	}
} /* alltypes.h:364:147 */

type pthread_mutex_t = struct {
	__u struct {
		_   [0]uint64
		__i [10]int32
	}
} /* alltypes.h:369:157 */

type pthread_cond_t = struct {
	__u struct {
		_   [0]uint64
		__i [12]int32
	}
} /* alltypes.h:379:112 */

type pthread_rwlock_t = struct {
	__u struct {
		_   [0]uint64
		__i [14]int32
	}
} /* alltypes.h:389:139 */

type pthread_barrier_t = struct {
	__u struct {
		_   [0]uint64
		__i [8]int32
	}
} /* alltypes.h:394:137 */

type sched_param = struct {
	sched_priority int32
	__reserved1    int32
	__reserved2    [2]struct {
		__reserved1 time_t
		__reserved2 int64
	}
	__reserved3 int32
	_           [4]byte
} /* sched.h:19:1 */

type timer_t = uintptr /* alltypes.h:201:14 */

type clock_t = int64 /* alltypes.h:211:14 */

type tm = struct {
	tm_sec    int32
	tm_min    int32
	tm_hour   int32
	tm_mday   int32
	tm_mon    int32
	tm_year   int32
	tm_wday   int32
	tm_yday   int32
	tm_isdst  int32
	_         [4]byte
	tm_gmtoff int64
	tm_zone   uintptr
} /* time.h:38:1 */

type itimerspec = struct {
	it_interval struct {
		tv_sec  time_t
		tv_nsec int64
	}
	it_value struct {
		tv_sec  time_t
		tv_nsec int64
	}
} /* time.h:80:1 */

type sigevent = struct {
	sigev_value struct {
		_         [0]uint64
		sival_int int32
		_         [4]byte
	}
	sigev_signo             int32
	sigev_notify            int32
	sigev_notify_function   uintptr
	sigev_notify_attributes uintptr
	__pad                   [32]uint8
} /* time.h:107:1 */

type __ptcb = struct {
	__f    uintptr
	__x    uintptr
	__next uintptr
} /* alltypes.h:265:9 */

type sigaltstack = struct {
	ss_sp    uintptr
	ss_flags int32
	_        [4]byte
	ss_size  size_t
} /* signal.h:44:9 */

type stack_t = sigaltstack /* signal.h:44:28 */

type greg_t = uint64          /* signal.h:11:23 */
type gregset_t = [48]uint64   /* signal.h:11:31 */
type fpregset_t = [33]float64 /* signal.h:12:16 */

type vrregset_t = struct {
	vrregs [32][4]uint32
	vscr   struct {
		vscr_word uint32
		_pad      [3]uint32
	}
	vrsave uint32
	_pad   [3]uint32
} /* signal.h:27:3 */

type sigcontext = struct {
	_unused     [4]uint64
	signal      int32
	_pad0       int32
	handler     uint64
	oldmask     uint64
	regs        uintptr
	gp_regs     gregset_t
	fp_regs     fpregset_t
	v_regs      uintptr
	vmx_reserve [101]int64
} /* signal.h:29:9 */

type mcontext_t = sigcontext /* signal.h:40:3 */

type __ucontext = struct {
	uc_flags    uint64
	uc_link     uintptr
	uc_stack    stack_t
	uc_sigmask  sigset_t
	uc_mcontext mcontext_t
} /* signal.h:56:9 */

type ucontext_t = __ucontext /* signal.h:62:3 */

type sigval = struct {
	_         [0]uint64
	sival_int int32
	_         [4]byte
} /* time.h:107:1 */

type siginfo_t = struct {
	si_signo    int32
	si_errno    int32
	si_code     int32
	_           [4]byte
	__si_fields struct {
		_     [0]uint64
		__pad [112]uint8
	}
} /* signal.h:145:3 */

type sigaction = struct {
	__sa_handler struct{ sa_handler uintptr }
	sa_mask      sigset_t
	sa_flags     int32
	_            [4]byte
	sa_restorer  uintptr
} /* signal.h:167:1 */

type sig_t = uintptr /* signal.h:251:14 */

type sig_atomic_t = int32 /* signal.h:269:13 */

func a_ll(tls *TLS, p uintptr) int32 { /* atomic_arch.h:2:19: */
	var v int32
	panic(`arch/powerpc64/atomic_arch.h:5:2: assembler statements not supported`)
	return v
}

func a_sc(tls *TLS, p uintptr, v int32) int32 { /* atomic_arch.h:10:19: */
	var r int32
	panic(`arch/powerpc64/atomic_arch.h:13:2: assembler statements not supported`)
	return r & 0x20000000 // "bit 2" of "cr0" (backwards bit order)
}

func a_ll_p(tls *TLS, p uintptr) uintptr { /* atomic_arch.h:20:20: */
	var v uintptr
	panic(`arch/powerpc64/atomic_arch.h:23:2: assembler statements not supported`)
	return v
}

func a_sc_p(tls *TLS, p uintptr, v uintptr) int32 { /* atomic_arch.h:28:19: */
	var r int32
	panic(`arch/powerpc64/atomic_arch.h:31:2: assembler statements not supported`)
	return r & 0x20000000 // "bit 2" of "cr0" (backwards bit order)
}

func a_barrier(tls *TLS) { /* atomic_arch.h:38:20: */
	panic(`arch/powerpc64/atomic_arch.h:40:2: assembler statements not supported`)
}

func a_post_llsc(tls *TLS) { /* atomic_arch.h:46:20: */
	panic(`arch/powerpc64/atomic_arch.h:48:2: assembler statements not supported`)
}

func a_cas(tls *TLS, p uintptr, t int32, s int32) int32 { /* atomic.h:20:19: */
	var old int32
	a_barrier(tls)
	for __ccgo := true; __ccgo; __ccgo = old == t && !(a_sc(tls, p, s) != 0) {
		old = a_ll(tls, p)
	}
	a_post_llsc(tls)
	return old
}

func a_swap(tls *TLS, p uintptr, v int32) int32 { /* atomic.h:33:19: */
	var old int32
	a_barrier(tls)
	for __ccgo := true; __ccgo; __ccgo = !(a_sc(tls, p, v) != 0) {
		old = a_ll(tls, p)
	}
	a_post_llsc(tls)
	return old
}

func a_fetch_add(tls *TLS, p uintptr, v int32) int32 { /* atomic.h:46:19: */
	var old int32
	a_barrier(tls)
	for __ccgo := true; __ccgo; __ccgo = !(a_sc(tls, p, int32(uint32(old)+uint32(v))) != 0) {
		old = a_ll(tls, p)
	}
	a_post_llsc(tls)
	return old
}

func a_fetch_and(tls *TLS, p uintptr, v int32) int32 { /* atomic.h:59:19: */
	var old int32
	a_barrier(tls)
	for __ccgo := true; __ccgo; __ccgo = !(a_sc(tls, p, old&v) != 0) {
		old = a_ll(tls, p)
	}
	a_post_llsc(tls)
	return old
}

func a_fetch_or(tls *TLS, p uintptr, v int32) int32 { /* atomic.h:72:19: */
	var old int32
	a_barrier(tls)
	for __ccgo := true; __ccgo; __ccgo = !(a_sc(tls, p, old|v) != 0) {
		old = a_ll(tls, p)
	}
	a_post_llsc(tls)
	return old
}

func a_and(tls *TLS, p uintptr, v int32) { /* atomic.h:151:20: */
	a_fetch_and(tls, p, v)
}

func a_or(tls *TLS, p uintptr, v int32) { /* atomic.h:159:20: */
	a_fetch_or(tls, p, v)
}

func a_or_64(tls *TLS, p uintptr, v uint64_t) { /* atomic.h:220:20: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*struct{ v uint64_t })(unsafe.Pointer(bp)) = func() (r struct{ v uint64_t }) {
		*(*uint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&r)) + 0)) = v
		return r
	}()
	if *(*uint32_t)(unsafe.Pointer(bp)) != 0 {
		a_or(tls, p, int32(*(*uint32_t)(unsafe.Pointer(bp))))
	}
	if *(*uint32_t)(unsafe.Pointer(bp + 1*4)) != 0 {
		a_or(tls, p+uintptr(1)*4, int32(*(*uint32_t)(unsafe.Pointer(bp + 1*4))))
	}
}

func a_ctz_32(tls *TLS, x uint32_t) int32 { /* atomic.h:256:19: */
	return int32(_sdebruijn328[x&-x*uint32_t(0x076be629)>>27])
}

var _sdebruijn328 = [32]uint8{
	uint8(0), uint8(1), uint8(23), uint8(2), uint8(29), uint8(24), uint8(19), uint8(3), uint8(30), uint8(27), uint8(25), uint8(11), uint8(20), uint8(8), uint8(4), uint8(13),
	uint8(31), uint8(22), uint8(28), uint8(18), uint8(26), uint8(10), uint8(7), uint8(12), uint8(21), uint8(17), uint8(9), uint8(6), uint8(16), uint8(5), uint8(15), uint8(14),
} /* atomic.h:261:20 */

func a_ctz_64(tls *TLS, x uint64_t) int32 { /* atomic.h:272:19: */
	if uint64(unsafe.Sizeof(int64(0))) < uint64(8) {
		var y uint32_t = uint32_t(x)
		if !(y != 0) {
			y = uint32_t(x >> 32)
			return 32 + a_ctz_32(tls, y)
		}
		return a_ctz_32(tls, y)
	}
	return int32(_sdebruijn648[uint64(x&-x)*0x022fdd63cc95386d>>58])
}

var _sdebruijn648 = [64]uint8{
	uint8(0), uint8(1), uint8(2), uint8(53), uint8(3), uint8(7), uint8(54), uint8(27), uint8(4), uint8(38), uint8(41), uint8(8), uint8(34), uint8(55), uint8(48), uint8(28),
	uint8(62), uint8(5), uint8(39), uint8(46), uint8(44), uint8(42), uint8(22), uint8(9), uint8(24), uint8(35), uint8(59), uint8(56), uint8(49), uint8(18), uint8(29), uint8(11),
	uint8(63), uint8(52), uint8(6), uint8(26), uint8(37), uint8(40), uint8(33), uint8(47), uint8(61), uint8(45), uint8(43), uint8(21), uint8(23), uint8(58), uint8(17), uint8(10),
	uint8(51), uint8(25), uint8(36), uint8(32), uint8(60), uint8(20), uint8(57), uint8(16), uint8(50), uint8(31), uint8(19), uint8(15), uint8(30), uint8(14), uint8(13), uint8(12),
} /* atomic.h:274:20 */

type __timer = struct {
	timerid int32
	_       [4]byte
	thread  pthread_t
} /* pthread_impl.h:64:1 */

func __pthread_self(tls *TLS) uintptr { /* pthread_arch.h:1:30: */
	var tp uintptr
	panic(`arch/powerpc64/pthread_arch.h:4:2: assembler statements not supported`)
	return tp - uintptr(0x7000) - uintptr(uint64(unsafe.Sizeof(__pthread{})))
}

func __wake(tls *TLS, addr uintptr, cnt int32, priv int32) { /* pthread_impl.h:155:20: */
	if priv != 0 {
		priv = 128
	}
	if cnt < 0 {
		cnt = 0x7fffffff
	}
	_ = Bool32(__syscall3(tls, int64(221), int64(addr), int64(1|priv), int64(cnt)) != int64(-38) || __syscall3(tls, int64(221), int64(addr), int64(1), int64(cnt)) != 0)
}

func __futexwait(tls *TLS, addr uintptr, val int32, priv int32) { /* pthread_impl.h:162:20: */
	if priv != 0 {
		priv = 128
	}
	_ = Bool32(__syscall4(tls, int64(221), int64(addr), int64(0|priv), int64(val), int64(0)) != int64(-38) || __syscall4(tls, int64(221), int64(addr), int64(0), int64(val), int64(0)) != 0)
}

var X__fsmu8 = [51]uint32_t{
	func() uint32 {
		if 0x2 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x2)
	}(), func() uint32 {
		if 0x3 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x3)
	}(), func() uint32 {
		if 0x4 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x4)
	}(), func() uint32 {
		if 0x5 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x5)
	}(), func() uint32 {
		if 0x6 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x6)
	}(), func() uint32 {
		if 0x7 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x7)
	}(),
	func() uint32 {
		if 0x8 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x8)
	}(), func() uint32 {
		if 0x9 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x9)
	}(), func() uint32 {
		if 0xa < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xa)
	}(), func() uint32 {
		if 0xb < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xb)
	}(), func() uint32 {
		if 0xc < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xc)
	}(), func() uint32 {
		if 0xd < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xd)
	}(), func() uint32 {
		if 0xe < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xe)
	}(), func() uint32 {
		if 0xf < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xf)
	}(),
	func() uint32 {
		if 0x0+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x0+16)
	}(), func() uint32 {
		if 0x1+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x1+16)
	}(), func() uint32 {
		if 0x2+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x2+16)
	}(), func() uint32 {
		if 0x3+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x3+16)
	}(), func() uint32 {
		if 0x4+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x4+16)
	}(), func() uint32 {
		if 0x5+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x5+16)
	}(), func() uint32 {
		if 0x6+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x6+16)
	}(), func() uint32 {
		if 0x7+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x7+16)
	}(),
	func() uint32 {
		if 0x8+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x8+16)
	}(), func() uint32 {
		if 0x9+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0x9+16)
	}(), func() uint32 {
		if 0xa+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xa+16)
	}(), func() uint32 {
		if 0xb+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xb+16)
	}(), func() uint32 {
		if 0xc+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xc+16)
	}(), func() uint32 {
		if 0xd+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xd+16)
	}(), func() uint32 {
		if 0xe+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xe+16)
	}(), func() uint32 {
		if 0xf+16 < 2 {
			return Uint32FromInt32(-1)
		}
		return func() uint32 {
			if Int32(0x80) == Int32(0x80) {
				return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
			}
			return Uint32(Uint32(0) - Uint32FromInt32(0x80))
		}()<<23 | uint32_t(0xf+16)
	}(),
	func() uint32 {
		if 0x0 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x0 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x0), func() uint32 {
		if 0x1 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x1 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x1), func() uint32 {
		if 0x2 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x2 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x2), func() uint32 {
		if 0x3 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x3 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x3), func() uint32 {
		if 0x4 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x4 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x4), func() uint32 {
		if 0x5 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x5 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x5), func() uint32 {
		if 0x6 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x6 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x6), func() uint32 {
		if 0x7 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x7 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x7),
	func() uint32 {
		if 0x8 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x8 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x8), func() uint32 {
		if 0x9 == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0x9 == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0x9), func() uint32 {
		if 0xa == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0xa == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0xa), func() uint32 {
		if 0xb == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0xb == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0xb), func() uint32 {
		if 0xc == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0xc == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0xc), func() uint32 {
		if 0xd == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0xd == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0xd), func() uint32 {
		if 0xe == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0xe == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0xe), func() uint32 {
		if 0xf == 0 {
			return func() uint32 {
				if Int32(0xa0) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0xa0))
			}() << 23
		}
		return func() uint32 {
			if 0xf == 0xd {
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xa0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}
			return func() uint32 {
				if Int32(0x80) == Int32(0x80) {
					return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
				}
				return Uint32(Uint32(0) - Uint32FromInt32(0x80))
			}() << 23
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(0xf),
	func() uint32 {
		if 0x0 >= 5 {
			return uint32(0)
		}
		return func() uint32 {
			if 0x0 == 0 {
				return func() uint32 {
					if Int32(0x90) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x90))
				}() << 23
			}
			return func() uint32 {
				if 0x0 == 4 {
					return func() uint32 {
						if Int32(0x80) == Int32(0x80) {
							return Uint32(Uint32(0x40) - Uint32FromInt32(0x90))
						}
						return Uint32(Uint32(0) - Uint32FromInt32(0x80))
					}() << 23
				}
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}()
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>12 | uint32_t(0x0), func() uint32 {
		if 0x1 >= 5 {
			return uint32(0)
		}
		return func() uint32 {
			if 0x1 == 0 {
				return func() uint32 {
					if Int32(0x90) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x90))
				}() << 23
			}
			return func() uint32 {
				if 0x1 == 4 {
					return func() uint32 {
						if Int32(0x80) == Int32(0x80) {
							return Uint32(Uint32(0x40) - Uint32FromInt32(0x90))
						}
						return Uint32(Uint32(0) - Uint32FromInt32(0x80))
					}() << 23
				}
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}()
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>12 | uint32_t(0x1), func() uint32 {
		if 0x2 >= 5 {
			return uint32(0)
		}
		return func() uint32 {
			if 0x2 == 0 {
				return func() uint32 {
					if Int32(0x90) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x90))
				}() << 23
			}
			return func() uint32 {
				if 0x2 == 4 {
					return func() uint32 {
						if Int32(0x80) == Int32(0x80) {
							return Uint32(Uint32(0x40) - Uint32FromInt32(0x90))
						}
						return Uint32(Uint32(0) - Uint32FromInt32(0x80))
					}() << 23
				}
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}()
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>12 | uint32_t(0x2), func() uint32 {
		if 0x3 >= 5 {
			return uint32(0)
		}
		return func() uint32 {
			if 0x3 == 0 {
				return func() uint32 {
					if Int32(0x90) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x90))
				}() << 23
			}
			return func() uint32 {
				if 0x3 == 4 {
					return func() uint32 {
						if Int32(0x80) == Int32(0x80) {
							return Uint32(Uint32(0x40) - Uint32FromInt32(0x90))
						}
						return Uint32(Uint32(0) - Uint32FromInt32(0x80))
					}() << 23
				}
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}()
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>12 | uint32_t(0x3), func() uint32 {
		if 0x4 >= 5 {
			return uint32(0)
		}
		return func() uint32 {
			if 0x4 == 0 {
				return func() uint32 {
					if Int32(0x90) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x90))
				}() << 23
			}
			return func() uint32 {
				if 0x4 == 4 {
					return func() uint32 {
						if Int32(0x80) == Int32(0x80) {
							return Uint32(Uint32(0x40) - Uint32FromInt32(0x90))
						}
						return Uint32(Uint32(0) - Uint32FromInt32(0x80))
					}() << 23
				}
				return func() uint32 {
					if Int32(0x80) == Int32(0x80) {
						return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
					}
					return Uint32(Uint32(0) - Uint32FromInt32(0x80))
				}() << 23
			}()
		}()
	}() | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>6 | uint32_t(func() uint32 {
		if Int32(0x80) == Int32(0x80) {
			return Uint32(Uint32(0x40) - Uint32FromInt32(0xc0))
		}
		return Uint32(Uint32(0) - Uint32FromInt32(0x80))
	}()<<23)>>12 | uint32_t(0x4),
} /* internal.c:18:16 */

type wint_t = uint32 /* alltypes.h:190:18 */

type wctype_t = uint64 /* alltypes.h:195:23 */

type __mbstate_t = struct {
	__opaque1 uint32
	__opaque2 uint32
} /* alltypes.h:329:9 */

type mbstate_t = __mbstate_t /* alltypes.h:329:63 */

func Xmbrtowc(tls *TLS, wc uintptr, src uintptr, n size_t, st uintptr) size_t { /* mbrtowc.c:6:8: */
	if __ccgo_strace {
		trc("tls=%v wc=%v src=%v n=%v st=%v, (%v:)", tls, wc, src, n, st, origin(2))
	}
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var c uint32
	var s uintptr
	var N uint32
	// var dummy wchar_t at bp, 4
	s = src
	N = uint32(n)

	if !!(st != 0) {
		goto __1
	}
	st = uintptr(unsafe.Pointer(&_sinternal_state))
__1:
	;
	c = *(*uint32)(unsafe.Pointer(st))

	if !!(s != 0) {
		goto __2
	}
	if !(c != 0) {
		goto __4
	}
	goto ilseq
__4:
	;
	return uint64(0)
	goto __3
__2:
	if !!(wc != 0) {
		goto __5
	}
	wc = bp /* &dummy */
__5:
	;
__3:
	;

	if !!(n != 0) {
		goto __6
	}
	return Uint64FromInt32(-2)
__6:
	;
	if !!(c != 0) {
		goto __7
	}
	if !(int32(*(*uint8)(unsafe.Pointer(s))) < 0x80) {
		goto __8
	}
	return BoolUint64(!!(AssignPtrInt32(wc, wchar_t(*(*uint8)(unsafe.Pointer(s)))) != 0))
__8:
	;
	if !(func() int32 {
		if !!(int32(*(*uintptr)(unsafe.Pointer((*__pthread)(unsafe.Pointer(__pthread_self(tls))).locale))) != 0) {
			return 4
		}
		return 1
	}() == 1) {
		goto __9
	}
	*(*wchar_t)(unsafe.Pointer(wc)) = 0xdfff & int32(int8(*(*uint8)(unsafe.Pointer(s))))
	return 1
__9:
	;
	if !(uint32(*(*uint8)(unsafe.Pointer(s)))-0xc2 > 0xf4-0xc2) {
		goto __10
	}
	goto ilseq
__10:
	;
	c = X__fsmu8[uint32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&s, 1))))-0xc2]
	n--
__7:
	;

	if !(n != 0) {
		goto __11
	}
	if !((int32(*(*uint8)(unsafe.Pointer(s)))>>3-0x10|(int32(*(*uint8)(unsafe.Pointer(s)))>>3+int32_t(c)>>26))&CplInt32(7) != 0) {
		goto __12
	}
	goto ilseq
__12:
	;
loop:
	c = c<<6 | uint32(int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&s, 1))))-0x80)
	n--
	if !!(c&(uint32(1)<<31) != 0) {
		goto __13
	}
	*(*uint32)(unsafe.Pointer(st)) = uint32(0)
	*(*wchar_t)(unsafe.Pointer(wc)) = wchar_t(c)
	return size_t(N) - n
__13:
	;
	if !(n != 0) {
		goto __14
	}
	if !(uint32(*(*uint8)(unsafe.Pointer(s)))-0x80 >= uint32(0x40)) {
		goto __15
	}
	goto ilseq
__15:
	;
	goto loop
__14:
	;
__11:
	;

	*(*uint32)(unsafe.Pointer(st)) = c
	return Uint64FromInt32(-2)
ilseq:
	*(*uint32)(unsafe.Pointer(st)) = uint32(0)
	*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 84
	return Uint64FromInt32(-1)
}

var _sinternal_state uint32 /* mbrtowc.c:8:18: */

func Xmbsinit(tls *TLS, st uintptr) int32 { /* mbsinit.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v st=%v, (%v:)", tls, st, origin(2))
	}
	return Bool32(!(st != 0) || !(int32(*(*uint32)(unsafe.Pointer(st))) != 0))
}

type imaxdiv_t = struct {
	quot intmax_t
	rem  intmax_t
} /* inttypes.h:14:40 */

type socklen_t = uint32 /* alltypes.h:353:18 */

type sa_family_t = uint16 /* alltypes.h:358:24 */

type msghdr = struct {
	msg_name       uintptr
	msg_namelen    socklen_t
	_              [4]byte
	msg_iov        uintptr
	msg_iovlen     int32
	__pad1         int32
	msg_control    uintptr
	msg_controllen socklen_t
	__pad2         int32
	msg_flags      int32
	_              [4]byte
} /* socket.h:22:1 */

type cmsghdr = struct {
	cmsg_len   socklen_t
	__pad1     int32
	cmsg_level int32
	cmsg_type  int32
} /* socket.h:44:1 */

type linger = struct {
	l_onoff  int32
	l_linger int32
} /* socket.h:74:1 */

type sockaddr = struct {
	sa_family sa_family_t
	sa_data   [14]uint8
} /* socket.h:367:1 */

type sockaddr_storage = struct {
	ss_family    sa_family_t
	__ss_padding [118]uint8
	__ss_align   uint64
} /* socket.h:372:1 */

type in_port_t = uint16_t                 /* in.h:12:18 */
type in_addr_t = uint32_t                 /* in.h:13:18 */
type in_addr = struct{ s_addr in_addr_t } /* in.h:14:1 */

type sockaddr_in = struct {
	sin_family sa_family_t
	sin_port   in_port_t
	sin_addr   struct{ s_addr in_addr_t }
	sin_zero   [8]uint8_t
} /* in.h:16:1 */

type in6_addr = struct {
	__in6_union struct {
		_         [0]uint32
		__s6_addr [16]uint8_t
	}
} /* in.h:23:1 */

type sockaddr_in6 = struct {
	sin6_family   sa_family_t
	sin6_port     in_port_t
	sin6_flowinfo uint32_t
	sin6_addr     struct {
		__in6_union struct {
			_         [0]uint32
			__s6_addr [16]uint8_t
		}
	}
	sin6_scope_id uint32_t
} /* in.h:34:1 */

type ipv6_mreq = struct {
	ipv6mr_multiaddr struct {
		__in6_union struct {
			_         [0]uint32
			__s6_addr [16]uint8_t
		}
	}
	ipv6mr_interface uint32
} /* in.h:42:1 */

type ip_opts = struct {
	ip_dst  struct{ s_addr in_addr_t }
	ip_opts [40]uint8
} /* in.h:229:1 */

type ip_mreq = struct {
	imr_multiaddr struct{ s_addr in_addr_t }
	imr_interface struct{ s_addr in_addr_t }
} /* in.h:247:1 */

type ip_mreqn = struct {
	imr_multiaddr struct{ s_addr in_addr_t }
	imr_address   struct{ s_addr in_addr_t }
	imr_ifindex   int32
} /* in.h:252:1 */

type ip_mreq_source = struct {
	imr_multiaddr  struct{ s_addr in_addr_t }
	imr_interface  struct{ s_addr in_addr_t }
	imr_sourceaddr struct{ s_addr in_addr_t }
} /* in.h:258:1 */

type ip_msfilter = struct {
	imsf_multiaddr struct{ s_addr in_addr_t }
	imsf_interface struct{ s_addr in_addr_t }
	imsf_fmode     uint32_t
	imsf_numsrc    uint32_t
	imsf_slist     [1]struct{ s_addr in_addr_t }
} /* in.h:264:1 */

type group_req = struct {
	gr_interface uint32_t
	_            [4]byte
	gr_group     struct {
		ss_family    sa_family_t
		__ss_padding [118]uint8
		__ss_align   uint64
	}
} /* in.h:275:1 */

type group_source_req = struct {
	gsr_interface uint32_t
	_             [4]byte
	gsr_group     struct {
		ss_family    sa_family_t
		__ss_padding [118]uint8
		__ss_align   uint64
	}
	gsr_source struct {
		ss_family    sa_family_t
		__ss_padding [118]uint8
		__ss_align   uint64
	}
} /* in.h:280:1 */

type group_filter = struct {
	gf_interface uint32_t
	_            [4]byte
	gf_group     struct {
		ss_family    sa_family_t
		__ss_padding [118]uint8
		__ss_align   uint64
	}
	gf_fmode  uint32_t
	gf_numsrc uint32_t
	gf_slist  [1]struct {
		ss_family    sa_family_t
		__ss_padding [118]uint8
		__ss_align   uint64
	}
} /* in.h:286:1 */

type in_pktinfo = struct {
	ipi_ifindex  int32
	ipi_spec_dst struct{ s_addr in_addr_t }
	ipi_addr     struct{ s_addr in_addr_t }
} /* in.h:297:1 */

type in6_pktinfo = struct {
	ipi6_addr struct {
		__in6_union struct {
			_         [0]uint32
			__s6_addr [16]uint8_t
		}
	}
	ipi6_ifindex uint32
} /* in.h:303:1 */

type ip6_mtuinfo = struct {
	ip6m_addr struct {
		sin6_family   sa_family_t
		sin6_port     in_port_t
		sin6_flowinfo uint32_t
		sin6_addr     struct {
			__in6_union struct {
				_         [0]uint32
				__s6_addr [16]uint8_t
			}
		}
		sin6_scope_id uint32_t
	}
	ip6m_mtu uint32_t
} /* in.h:308:1 */

type addrinfo = struct {
	ai_flags     int32
	ai_family    int32
	ai_socktype  int32
	ai_protocol  int32
	ai_addrlen   socklen_t
	_            [4]byte
	ai_addr      uintptr
	ai_canonname uintptr
	ai_next      uintptr
} /* netdb.h:16:1 */

// Legacy functions follow (marked OBsolete in SUS)

type netent = struct {
	n_name     uintptr
	n_aliases  uintptr
	n_addrtype int32
	n_net      uint32_t
} /* netdb.h:62:1 */

type hostent = struct {
	h_name      uintptr
	h_aliases   uintptr
	h_addrtype  int32
	h_length    int32
	h_addr_list uintptr
} /* netdb.h:69:1 */

type servent = struct {
	s_name    uintptr
	s_aliases uintptr
	s_port    int32
	_         [4]byte
	s_proto   uintptr
} /* netdb.h:78:1 */

type protoent = struct {
	p_name    uintptr
	p_aliases uintptr
	p_proto   int32
	_         [4]byte
} /* netdb.h:85:1 */

type aibuf = struct {
	ai struct {
		ai_flags     int32
		ai_family    int32
		ai_socktype  int32
		ai_protocol  int32
		ai_addrlen   socklen_t
		_            [4]byte
		ai_addr      uintptr
		ai_canonname uintptr
		ai_next      uintptr
	}
	sa struct {
		sin struct {
			sin_family sa_family_t
			sin_port   in_port_t
			sin_addr   struct{ s_addr in_addr_t }
			sin_zero   [8]uint8_t
		}
		_ [12]byte
	}
	lock [1]int32
	slot int16
	ref  int16
	_    [4]byte
} /* lookup.h:10:1 */

type sa = struct {
	sin struct {
		sin_family sa_family_t
		sin_port   in_port_t
		sin_addr   struct{ s_addr in_addr_t }
		sin_zero   [8]uint8_t
	}
	_ [12]byte
} /* lookup.h:10:1 */

type address = struct {
	family  int32
	scopeid uint32
	addr    [16]uint8_t
	sortkey int32
} /* lookup.h:20:1 */

type service = struct {
	port     uint16_t
	proto    uint8
	socktype uint8
} /* lookup.h:27:1 */

type resolvconf = struct {
	ns [3]struct {
		family  int32
		scopeid uint32
		addr    [16]uint8_t
		sortkey int32
	}
	nns      uint32
	attempts uint32
	ndots    uint32
	timeout  uint32
} /* lookup.h:34:1 */

func Xfreeaddrinfo(tls *TLS, p uintptr) { /* freeaddrinfo.c:7:6: */
	if __ccgo_strace {
		trc("tls=%v p=%v, (%v:)", tls, p, origin(2))
	}
	var cnt size_t
	cnt = uint64(1)
__1:
	if !((*addrinfo)(unsafe.Pointer(p)).ai_next != 0) {
		goto __3
	}
	goto __2
__2:
	cnt++
	p = (*addrinfo)(unsafe.Pointer(p)).ai_next
	goto __1
	goto __3
__3:
	;
	var b uintptr = p - uintptr(uint64(uintptr(0)))
	b -= 88 * uintptr((*aibuf)(unsafe.Pointer(b)).slot)
	//TODO LOCK(b->lock);
	if !(int32(AssignSubPtrInt16(b+82, int16(cnt))) != 0) {
		Xfree(tls, b)
	}
	//TODO else UNLOCK(b->lock);
}

func Xgetaddrinfo(tls *TLS, host uintptr, serv uintptr, hint uintptr, res uintptr) int32 { /* getaddrinfo.c:12:5: */
	if __ccgo_strace {
		trc("tls=%v host=%v serv=%v hint=%v res=%v, (%v:)", tls, host, serv, hint, res, origin(2))
	}
	bp := tls.Alloc(1608)
	defer tls.Free(1608)

	// var ports [2]service at bp, 8

	// var addrs [48]address at bp+8, 1344

	// var canon [256]uint8 at bp+1352, 256

	var outcanon uintptr
	var nservs int32
	var naddrs int32
	var nais int32
	var canon_len int32
	var i int32
	var j int32
	var k int32
	var family int32 = 0
	var flags int32 = 0
	var proto int32 = 0
	var socktype int32 = 0
	var out uintptr

	if !(host != 0) && !(serv != 0) {
		return -2
	}

	if hint != 0 {
		family = (*addrinfo)(unsafe.Pointer(hint)).ai_family
		flags = (*addrinfo)(unsafe.Pointer(hint)).ai_flags
		proto = (*addrinfo)(unsafe.Pointer(hint)).ai_protocol
		socktype = (*addrinfo)(unsafe.Pointer(hint)).ai_socktype

		var mask int32 = 0x01 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x400
		if flags&mask != flags {
			return -1
		}

		switch family {
		case 2:
			fallthrough
		case 10:
			fallthrough
		case 0:
			break
			fallthrough
		default:
			return -6
		}
	}

	if flags&0x20 != 0 {
		Xabort(tls) //TODO-
		// 	/* Define the "an address is configured" condition for address
		// 	 * families via ability to create a socket for the family plus
		// 	 * routability of the loopback address for the family. */
		// 	static const struct sockaddr_in lo4 = {
		// 		.sin_family = AF_INET, .sin_port = 65535,
		// 		.sin_addr.s_addr = __BYTE_ORDER == __BIG_ENDIAN
		// 			? 0x7f000001 : 0x0100007f
		// 	};
		// 	static const struct sockaddr_in6 lo6 = {
		// 		.sin6_family = AF_INET6, .sin6_port = 65535,
		// 		.sin6_addr = IN6ADDR_LOOPBACK_INIT
		// 	};
		// 	int tf[2] = { AF_INET, AF_INET6 };
		// 	const void *ta[2] = { &lo4, &lo6 };
		// 	socklen_t tl[2] = { sizeof lo4, sizeof lo6 };
		// 	for (i=0; i<2; i++) {
		// 		if (family==tf[1-i]) continue;
		// 		int s = socket(tf[i], SOCK_CLOEXEC|SOCK_DGRAM,
		// 			IPPROTO_UDP);
		// 		if (s>=0) {
		// 			int cs;
		// 			pthread_setcancelstate(
		// 				PTHREAD_CANCEL_DISABLE, &cs);
		// 			int r = connect(s, ta[i], tl[i]);
		// 			pthread_setcancelstate(cs, 0);
		// 			close(s);
		// 			if (!r) continue;
		// 		}
		// 		switch (errno) {
		// 		case EADDRNOTAVAIL:
		// 		case EAFNOSUPPORT:
		// 		case EHOSTUNREACH:
		// 		case ENETDOWN:
		// 		case ENETUNREACH:
		// 			break;
		// 		default:
		// 			return EAI_SYSTEM;
		// 		}
		// 		if (family == tf[i]) return EAI_NONAME;
		// 		family = tf[1-i];
		// 	}
	}

	nservs = X__lookup_serv(tls, bp, serv, proto, socktype, flags)
	if nservs < 0 {
		return nservs
	}

	naddrs = X__lookup_name(tls, bp+8, bp+1352, host, family, flags)
	if naddrs < 0 {
		return naddrs
	}

	nais = nservs * naddrs
	canon_len = int32(Xstrlen(tls, bp+1352))
	out = Xcalloc(tls, uint64(1), uint64(nais)*uint64(unsafe.Sizeof(aibuf{}))+uint64(canon_len)+uint64(1))
	if !(out != 0) {
		return -10
	}

	if canon_len != 0 {
		outcanon = out + uintptr(nais)*88
		Xmemcpy(tls, outcanon, bp+1352, uint64(canon_len+1))
	} else {
		outcanon = uintptr(0)
	}

	for k = AssignInt32(&i, 0); i < naddrs; i++ {
		j = 0
	__1:
		if !(j < nservs) {
			goto __3
		}
		{
			(*aibuf)(unsafe.Pointer(out + uintptr(k)*88)).slot = int16(k)
			//TODO out[k].ai = (struct addrinfo){
			//TODO 	.ai_family = addrs[i].family,
			//TODO 	.ai_socktype = ports[j].socktype,
			//TODO 	.ai_protocol = ports[j].proto,
			//TODO 	.ai_addrlen = addrs[i].family == AF_INET
			//TODO 		? sizeof(struct sockaddr_in)
			//TODO 		: sizeof(struct sockaddr_in6),
			//TODO 	.ai_addr = (void *)&out[k].sa,
			//TODO 	.ai_canonname = outcanon };
			(*aibuf)(unsafe.Pointer(out + uintptr(k)*88)).ai.ai_family = (*address)(unsafe.Pointer(bp + 8 + uintptr(i)*28)).family
			(*aibuf)(unsafe.Pointer(out + uintptr(k)*88)).ai.ai_socktype = int32((*service)(unsafe.Pointer(bp + uintptr(j)*4)).socktype)
			(*aibuf)(unsafe.Pointer(out + uintptr(k)*88)).ai.ai_protocol = int32((*service)(unsafe.Pointer(bp + uintptr(j)*4)).proto)
			(*aibuf)(unsafe.Pointer(out + uintptr(k)*88)).ai.ai_addrlen = func() uint32 {
				if (*address)(unsafe.Pointer(bp+8+uintptr(i)*28)).family == 2 {
					return uint32(unsafe.Sizeof(sockaddr_in{}))
				}
				return uint32(unsafe.Sizeof(sockaddr_in6{}))
			}()
			(*aibuf)(unsafe.Pointer(out + uintptr(k)*88)).ai.ai_addr = out + uintptr(k)*88 + 48
			(*aibuf)(unsafe.Pointer(out + uintptr(k)*88)).ai.ai_canonname = outcanon
			if k != 0 {
				(*aibuf)(unsafe.Pointer(out + uintptr(k-1)*88)).ai.ai_next = out + uintptr(k)*88
			}
			switch (*address)(unsafe.Pointer(bp + 8 + uintptr(i)*28)).family {
			case 2:
				(*sockaddr_in)(unsafe.Pointer(out + uintptr(k)*88 + 48)).sin_family = sa_family_t(2)
				(*sockaddr_in)(unsafe.Pointer(out + uintptr(k)*88 + 48)).sin_port = Xhtons(tls, (*service)(unsafe.Pointer(bp+uintptr(j)*4)).port)
				Xmemcpy(tls, out+uintptr(k)*88+48+4, bp+8+uintptr(i)*28+8, uint64(4))
				break
			case 10:
				(*sockaddr_in6)(unsafe.Pointer(out + uintptr(k)*88 + 48)).sin6_family = sa_family_t(10)
				(*sockaddr_in6)(unsafe.Pointer(out + uintptr(k)*88 + 48)).sin6_port = Xhtons(tls, (*service)(unsafe.Pointer(bp+uintptr(j)*4)).port)
				(*sockaddr_in6)(unsafe.Pointer(out + uintptr(k)*88 + 48)).sin6_scope_id = (*address)(unsafe.Pointer(bp + 8 + uintptr(i)*28)).scopeid
				Xmemcpy(tls, out+uintptr(k)*88+48+8, bp+8+uintptr(i)*28+8, uint64(16))
				break
			}

		}
		goto __2
	__2:
		j++
		k++
		goto __1
		goto __3
	__3:
	}
	(*aibuf)(unsafe.Pointer(out)).ref = int16(nais)
	*(*uintptr)(unsafe.Pointer(res)) = out
	return 0
}

type ucred = struct {
	pid pid_t
	uid uid_t
	gid gid_t
} /* socket.h:57:1 */

type mmsghdr = struct {
	msg_hdr struct {
		msg_name       uintptr
		msg_namelen    socklen_t
		_              [4]byte
		msg_iov        uintptr
		msg_iovlen     int32
		__pad1         int32
		msg_control    uintptr
		msg_controllen socklen_t
		__pad2         int32
		msg_flags      int32
		_              [4]byte
	}
	msg_len uint32
	_       [4]byte
} /* socket.h:63:1 */

func Xgethostbyaddr(tls *TLS, a uintptr, l socklen_t, af int32) uintptr { /* gethostbyaddr.c:7:16: */
	if __ccgo_strace {
		trc("tls=%v a=%v l=%v af=%v, (%v:)", tls, a, l, af, origin(2))
	}
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var size size_t = uint64(63)
	// var res uintptr at bp, 8

	var err int32
	for __ccgo := true; __ccgo; __ccgo = err == 34 {
		Xfree(tls, _sh)
		_sh = Xmalloc(tls, AssignAddUint64(&size, size+uint64(1)))
		if !(_sh != 0) {
			*(*int32)(unsafe.Pointer(X__h_errno_location(tls))) = 3
			return uintptr(0)
		}
		err = Xgethostbyaddr_r(tls, a, l, af, _sh,
			_sh+uintptr(1)*32, size-size_t(unsafe.Sizeof(hostent{})), bp, X__h_errno_location(tls))
	}
	if err != 0 {
		return uintptr(0)
	}
	return _sh
}

var _sh uintptr /* gethostbyaddr.c:9:24: */

func Xgethostbyaddr_r(tls *TLS, a uintptr, l socklen_t, af int32, h uintptr, buf uintptr, buflen size_t, res uintptr, err uintptr) int32 { /* gethostbyaddr_r.c:10:5: */
	if __ccgo_strace {
		trc("tls=%v a=%v l=%v af=%v h=%v buf=%v buflen=%v res=%v err=%v, (%v:)", tls, a, l, af, h, buf, buflen, res, err, origin(2))
	}
	bp := tls.Alloc(28)
	defer tls.Free(28)

	//TODO union {
	//TODO 	struct sockaddr_in sin;
	//TODO 	struct sockaddr_in6 sin6;
	//TODO } sa = { .sin.sin_family = af };
	*(*struct {
		sin sockaddr_in
		_   [12]byte
	})(unsafe.Pointer(bp)) = struct {
		sin sockaddr_in
		_   [12]byte
	}{} //TODO-
	(*sockaddr_in)(unsafe.Pointer(bp)).sin_family = sa_family_t(af) //TODO-
	var sl socklen_t
	if af == 10 {
		sl = uint32(unsafe.Sizeof(sockaddr_in6{}))
	} else {
		sl = uint32(unsafe.Sizeof(sockaddr_in{}))
	}
	var i int32

	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)

	// Load address argument into sockaddr structure
	if af == 10 && l == socklen_t(16) {
		Xmemcpy(tls, bp+8, a, uint64(16))
	} else if af == 2 && l == socklen_t(4) {
		Xmemcpy(tls, bp+4, a, uint64(4))
	} else {
		*(*int32)(unsafe.Pointer(err)) = 3
		return 22
	}

	// Align buffer and check for space for pointers and ip address
	i = int32(uintptr_t(buf) & (uint64(unsafe.Sizeof(uintptr(0))) - uint64(1)))
	if !(i != 0) {
		i = int32(unsafe.Sizeof(uintptr(0)))
	}
	if buflen <= uint64(5)*uint64(unsafe.Sizeof(uintptr(0)))-uint64(i)+uint64(l) {
		return 34
	}
	buf += uintptr(uint64(unsafe.Sizeof(uintptr(0))) - uint64(i))
	buflen = buflen - (uint64(5)*uint64(unsafe.Sizeof(uintptr(0))) - uint64(i) + uint64(l))

	(*hostent)(unsafe.Pointer(h)).h_addr_list = buf
	buf += uintptr(uint64(2) * uint64(unsafe.Sizeof(uintptr(0))))
	(*hostent)(unsafe.Pointer(h)).h_aliases = buf
	buf += uintptr(uint64(2) * uint64(unsafe.Sizeof(uintptr(0))))

	*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_addr_list)) = buf
	Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_addr_list)), a, uint64(l))
	buf += uintptr(l)
	*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_addr_list + 1*8)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_aliases)) = buf
	*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_aliases + 1*8)) = uintptr(0)

	switch Xgetnameinfo(tls, bp, sl, buf, uint32(buflen), uintptr(0), uint32(0), 0) {
	case -3:
		*(*int32)(unsafe.Pointer(err)) = 2
		return 11
	case -12:
		return 34
	default:
		fallthrough
	case -10:
		fallthrough
	case -11:
		fallthrough
	case -4:
		*(*int32)(unsafe.Pointer(err)) = 3
		return *(*int32)(unsafe.Pointer(X___errno_location(tls)))
	case 0:
		break
	}

	(*hostent)(unsafe.Pointer(h)).h_addrtype = af
	(*hostent)(unsafe.Pointer(h)).h_length = int32(l)
	(*hostent)(unsafe.Pointer(h)).h_name = *(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_aliases))
	*(*uintptr)(unsafe.Pointer(res)) = h
	return 0
}

func Xgethostbyname(tls *TLS, name uintptr) uintptr { /* gethostbyname.c:8:16: */
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
	}
	return Xgethostbyname2(tls, name, 2)
}

func Xgethostbyname2(tls *TLS, name uintptr, af int32) uintptr { /* gethostbyname2.c:8:16: */
	if __ccgo_strace {
		trc("tls=%v name=%v af=%v, (%v:)", tls, name, af, origin(2))
	}
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var size size_t = uint64(63)
	// var res uintptr at bp, 8

	var err int32
	for __ccgo := true; __ccgo; __ccgo = err == 34 {
		Xfree(tls, _sh1)
		_sh1 = Xmalloc(tls, AssignAddUint64(&size, size+uint64(1)))
		if !(_sh1 != 0) {
			*(*int32)(unsafe.Pointer(X__h_errno_location(tls))) = 3
			return uintptr(0)
		}
		err = Xgethostbyname2_r(tls, name, af, _sh1,
			_sh1+uintptr(1)*32, size-size_t(unsafe.Sizeof(hostent{})), bp, X__h_errno_location(tls))
	}
	if err != 0 {
		return uintptr(0)
	}
	return _sh1
}

var _sh1 uintptr /* gethostbyname2.c:10:24: */

func Xgethostbyname2_r(tls *TLS, name uintptr, af int32, h uintptr, buf uintptr, buflen size_t, res uintptr, err uintptr) int32 { /* gethostbyname2_r.c:11:5: */
	if __ccgo_strace {
		trc("tls=%v name=%v af=%v h=%v buf=%v buflen=%v res=%v err=%v, (%v:)", tls, name, af, h, buf, buflen, res, err, origin(2))
	}
	bp := tls.Alloc(1600)
	defer tls.Free(1600)

	// var addrs [48]address at bp, 1344

	// var canon [256]uint8 at bp+1344, 256

	var i int32
	var cnt int32
	var align size_t
	var need size_t

	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	cnt = X__lookup_name(tls, bp, bp+1344, name, af, 0x02)
	if cnt < 0 {
		switch cnt {
		case -2:
			*(*int32)(unsafe.Pointer(err)) = 1
			return 2
			fallthrough
		case -3:
			*(*int32)(unsafe.Pointer(err)) = 2
			return 11
			fallthrough
		default:
			fallthrough
		case -4:
			*(*int32)(unsafe.Pointer(err)) = 3
			return 74
			fallthrough
		case -10:
			fallthrough
		case -11:
			*(*int32)(unsafe.Pointer(err)) = 3
			return *(*int32)(unsafe.Pointer(X___errno_location(tls)))
		}
	}

	(*hostent)(unsafe.Pointer(h)).h_addrtype = af
	(*hostent)(unsafe.Pointer(h)).h_length = func() int32 {
		if af == 10 {
			return 16
		}
		return 4
	}()

	// Align buffer
	align = -uintptr_t(buf) & (uint64(unsafe.Sizeof(uintptr(0))) - uint64(1))

	need = uint64(4) * uint64(unsafe.Sizeof(uintptr(0)))
	need = need + uint64(cnt+1)*(uint64(unsafe.Sizeof(uintptr(0)))+uint64((*hostent)(unsafe.Pointer(h)).h_length))
	need = need + (Xstrlen(tls, name) + uint64(1))
	need = need + (Xstrlen(tls, bp+1344) + uint64(1))
	need = need + align

	if need > buflen {
		return 34
	}

	buf += uintptr(align)
	(*hostent)(unsafe.Pointer(h)).h_aliases = buf
	buf += uintptr(uint64(3) * uint64(unsafe.Sizeof(uintptr(0))))
	(*hostent)(unsafe.Pointer(h)).h_addr_list = buf
	buf += uintptr(uint64(cnt+1) * uint64(unsafe.Sizeof(uintptr(0))))

	for i = 0; i < cnt; i++ {
		*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_addr_list + uintptr(i)*8)) = buf
		buf += uintptr((*hostent)(unsafe.Pointer(h)).h_length)
		Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_addr_list + uintptr(i)*8)), bp+uintptr(i)*28+8, uint64((*hostent)(unsafe.Pointer(h)).h_length))
	}
	*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_addr_list + uintptr(i)*8)) = uintptr(0)

	(*hostent)(unsafe.Pointer(h)).h_name = AssignPtrUintptr((*hostent)(unsafe.Pointer(h)).h_aliases, buf)
	Xstrcpy(tls, (*hostent)(unsafe.Pointer(h)).h_name, bp+1344)
	buf += uintptr(Xstrlen(tls, (*hostent)(unsafe.Pointer(h)).h_name) + uint64(1))

	if Xstrcmp(tls, (*hostent)(unsafe.Pointer(h)).h_name, name) != 0 {
		*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_aliases + 1*8)) = buf
		Xstrcpy(tls, *(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_aliases + 1*8)), name)
		buf += uintptr(Xstrlen(tls, *(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_aliases + 1*8))) + uint64(1))
	} else {
		*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_aliases + 1*8)) = uintptr(0)
	}

	*(*uintptr)(unsafe.Pointer((*hostent)(unsafe.Pointer(h)).h_aliases + 2*8)) = uintptr(0)

	*(*uintptr)(unsafe.Pointer(res)) = h
	return 0
}

func Xgethostbyname_r(tls *TLS, name uintptr, h uintptr, buf uintptr, buflen size_t, res uintptr, err uintptr) int32 { /* gethostbyname_r.c:6:5: */
	if __ccgo_strace {
		trc("tls=%v name=%v h=%v buf=%v buflen=%v res=%v err=%v, (%v:)", tls, name, h, buf, buflen, res, err, origin(2))
	}
	return Xgethostbyname2_r(tls, name, 2, h, buf, buflen, res, err)
}

type if_nameindex = struct {
	if_index uint32
	_        [4]byte
	if_name  uintptr
} /* if.h:12:1 */

type ifaddr = struct {
	ifa_addr struct {
		sa_family sa_family_t
		sa_data   [14]uint8
	}
	ifa_ifu struct {
		ifu_broadaddr struct {
			sa_family sa_family_t
			sa_data   [14]uint8
		}
	}
	ifa_ifp  uintptr
	ifa_next uintptr
} /* if.h:51:1 */

type ifmap = struct {
	mem_start uint64
	mem_end   uint64
	base_addr uint16
	irq       uint8
	dma       uint8
	port      uint8
	_         [3]byte
} /* if.h:64:1 */

type ifreq = struct {
	ifr_ifrn struct{ ifrn_name [16]uint8 }
	ifr_ifru struct {
		_         [0]uint64
		ifru_addr struct {
			sa_family sa_family_t
			sa_data   [14]uint8
		}
		_ [8]byte
	}
} /* if.h:76:1 */

type ifconf = struct {
	ifc_len  int32
	_        [4]byte
	ifc_ifcu struct{ ifcu_buf uintptr }
} /* if.h:116:1 */

type ns_sect = uint32 /* nameser.h:37:3 */

type __ns_msg = struct {
	_msg      uintptr
	_eom      uintptr
	_id       uint16_t
	_flags    uint16_t
	_counts   [4]uint16_t
	_         [4]byte
	_sections [4]uintptr
	_sect     ns_sect
	_rrnum    int32
	_msg_ptr  uintptr
} /* nameser.h:39:9 */

type ns_msg = __ns_msg /* nameser.h:46:3 */

type _ns_flagdata = struct {
	mask  int32
	shift int32
} /* nameser.h:48:1 */

type __ns_rr = struct {
	name     [1025]uint8
	_        [1]byte
	__type   uint16_t
	rr_class uint16_t
	_        [2]byte
	ttl      uint32_t
	rdlength uint16_t
	_        [2]byte
	rdata    uintptr
} /* nameser.h:59:9 */

type ns_rr = __ns_rr /* nameser.h:66:3 */

type ns_flag = uint32 /* nameser.h:87:3 */

type ns_opcode = uint32 /* nameser.h:96:3 */

type ns_rcode = uint32 /* nameser.h:115:3 */

type ns_update_operation = uint32 /* nameser.h:121:3 */

type ns_tsig_key1 = struct {
	name [1025]uint8
	alg  [1025]uint8
	_    [6]byte
	data uintptr
	len  int32
	_    [4]byte
} /* nameser.h:123:1 */

type ns_tsig_key = ns_tsig_key1 /* nameser.h:128:28 */

type ns_tcp_tsig_state1 = struct {
	counter int32
	_       [4]byte
	key     uintptr
	ctx     uintptr
	sig     [512]uint8
	siglen  int32
	_       [4]byte
} /* nameser.h:130:1 */

type ns_tcp_tsig_state = ns_tcp_tsig_state1 /* nameser.h:137:34 */

type ns_type = uint32 /* nameser.h:200:3 */

type ns_class = uint32 /* nameser.h:219:3 */

type ns_key_types = uint32 /* nameser.h:226:3 */

type ns_cert_types = uint32 /* nameser.h:234:3 */

type HEADER = struct {
	_       [0]uint32
	id      uint32 /* unsigned id: 16, unsigned rd: 1, unsigned tc: 1, unsigned aa: 1, unsigned opcode: 4, unsigned qr: 1, unsigned rcode: 4, unsigned cd: 1, unsigned ad: 1, unsigned unused: 1, unsigned ra: 1 */
	qdcount uint32 /* unsigned qdcount: 16, unsigned ancount: 16 */
	nscount uint32 /* unsigned nscount: 16, unsigned arcount: 16 */
} /* nameser.h:353:3 */

// unused; purely for broken apps
type __res_state = struct {
	retrans     int32
	retry       int32
	options     uint64
	nscount     int32
	nsaddr_list [3]struct {
		sin_family sa_family_t
		sin_port   in_port_t
		sin_addr   struct{ s_addr in_addr_t }
		sin_zero   [8]uint8_t
	}
	id        uint16
	_         [2]byte
	dnsrch    [7]uintptr
	defdname  [256]uint8
	pfcode    uint64
	ndots     uint32 /* unsigned ndots: 4, unsigned nsort: 4, unsigned ipv6_unavail: 1, unsigned unused: 23 */
	_         [4]byte
	sort_list [10]struct {
		addr struct{ s_addr in_addr_t }
		mask uint32_t
	}
	qhook       uintptr
	rhook       uintptr
	res_h_errno int32
	_vcsock     int32
	_flags      uint32
	_           [4]byte
	_u          struct {
		_   [0]uint64
		pad [52]uint8
		_   [4]byte
	}
} /* resolv.h:26:9 */

// unused; purely for broken apps
type res_state = uintptr /* resolv.h:62:3 */

type res_sym = struct {
	number    int32
	_         [4]byte
	name      uintptr
	humanname uintptr
} /* resolv.h:70:1 */

func itoa(tls *TLS, p uintptr, x uint32) uintptr { /* getnameinfo.c:18:13: */
	p += uintptr(uint64(3) * uint64(unsafe.Sizeof(int32(0))))
	*(*uint8)(unsafe.Pointer(PreDecUintptr(&p, 1))) = uint8(0)
	for __ccgo := true; __ccgo; __ccgo = x != 0 {
		*(*uint8)(unsafe.Pointer(PreDecUintptr(&p, 1))) = uint8(uint32('0') + x%uint32(10))
		x = x / uint32(10)
	}
	return p
}

func mkptr4(tls *TLS, s uintptr, ip uintptr) { /* getnameinfo.c:28:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	Xsprintf(tls, s, ts+25,
		VaList(bp, int32(*(*uint8)(unsafe.Pointer(ip + 3))), int32(*(*uint8)(unsafe.Pointer(ip + 2))), int32(*(*uint8)(unsafe.Pointer(ip + 1))), int32(*(*uint8)(unsafe.Pointer(ip)))))
}

func mkptr6(tls *TLS, s uintptr, ip uintptr) { /* getnameinfo.c:34:13: */
	var i int32
	for i = 15; i >= 0; i-- {
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&s, 1))) = _sxdigits[int32(*(*uint8)(unsafe.Pointer(ip + uintptr(i))))&15]
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&s, 1))) = uint8('.')
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&s, 1))) = _sxdigits[int32(*(*uint8)(unsafe.Pointer(ip + uintptr(i))))>>4]
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&s, 1))) = uint8('.')
	}
	Xstrcpy(tls, s, ts+50)
}

var _sxdigits = *(*[17]uint8)(unsafe.Pointer(ts + 59)) /* getnameinfo.c:36:20 */

func reverse_hosts(tls *TLS, buf uintptr, a uintptr, scopeid uint32, family int32) { /* getnameinfo.c:45:13: */
	bp := tls.Alloc(556)
	defer tls.Free(556)

	// var line [512]uint8 at bp+16, 512

	var p uintptr
	var z uintptr
	var _buf [1032]uint8
	_ = _buf
	// var atmp [16]uint8 at bp, 16

	// var iplit address at bp+528, 28

	//TODO FILE _f, *f = __fopen_rb_ca("/etc/hosts", &_f, _buf, sizeof _buf);
	var f uintptr = Xfopen(tls, ts+76, ts+87)
	if !(f != 0) {
		return
	}
	if family == 2 {
		Xmemcpy(tls, bp+uintptr(12), a, uint64(4))
		Xmemcpy(tls, bp, ts+90, uint64(12))
		a = bp /* &atmp[0] */
	}
	for Xfgets(tls, bp+16, int32(unsafe.Sizeof([512]uint8{})), f) != 0 {
		if AssignUintptr(&p, Xstrchr(tls, bp+16, '#')) != 0 {
			*(*uint8)(unsafe.Pointer(PostIncUintptr(&p, 1))) = uint8('\n')
			*(*uint8)(unsafe.Pointer(p)) = uint8(0)
		}

		for p = bp + 16; /* &line[0] */ *(*uint8)(unsafe.Pointer(p)) != 0 && !(__isspace(tls, int32(*(*uint8)(unsafe.Pointer(p)))) != 0); p++ {
		}
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&p, 1))) = uint8(0)
		if X__lookup_ipliteral(tls, bp+528, bp+16, 0) <= 0 {
			continue
		}

		if (*address)(unsafe.Pointer(bp+528)).family == 2 {
			Xmemcpy(tls, bp+528+8+uintptr(12), bp+528+8, uint64(4))
			Xmemcpy(tls, bp+528+8, ts+90, uint64(12))
			(*address)(unsafe.Pointer(bp + 528 /* &iplit */)).scopeid = uint32(0)
		}

		if Xmemcmp(tls, a, bp+528+8, uint64(16)) != 0 || (*address)(unsafe.Pointer(bp+528)).scopeid != scopeid {
			continue
		}

		for ; *(*uint8)(unsafe.Pointer(p)) != 0 && __isspace(tls, int32(*(*uint8)(unsafe.Pointer(p)))) != 0; p++ {
		}
		for z = p; *(*uint8)(unsafe.Pointer(z)) != 0 && !(__isspace(tls, int32(*(*uint8)(unsafe.Pointer(z)))) != 0); z++ {
		}
		*(*uint8)(unsafe.Pointer(z)) = uint8(0)
		if (int64(z)-int64(p))/1 < int64(256) {
			Xmemcpy(tls, buf, p, uint64((int64(z)-int64(p))/1+int64(1)))
			break
		}
	}
	//TODO __fclose_ca(f);
	Xfclose(tls, f)
}

func reverse_services(tls *TLS, buf uintptr, port int32, dgram int32) { /* getnameinfo.c:87:13: */
	Xabort(tls) //TODO-
	// unsigned long svport;
	// char line[128], *p, *z;
	// unsigned char _buf[1032];
	// FILE _f, *f = __fopen_rb_ca("/etc/services", &_f, _buf, sizeof _buf);
	// if (!f) return;
	// while (fgets(line, sizeof line, f)) {
	// 	if ((p=strchr(line, '#'))) *p++='\n', *p=0;

	// 	for (p=line; *p && !isspace(*p); p++);
	// 	if (!*p) continue;
	// 	*p++ = 0;
	// 	svport = strtoul(p, &z, 10);

	// 	if (svport != port || z==p) continue;
	// 	if (dgram && strncmp(z, "/udp", 4)) continue;
	// 	if (!dgram && strncmp(z, "/tcp", 4)) continue;
	// 	if (p-line > 32) continue;

	// 	memcpy(buf, line, p-line);
	// 	break;
	// }
	// __fclose_ca(f);
}

func Xgetnameinfo(tls *TLS, sa1 uintptr, sl socklen_t, node uintptr, nodelen socklen_t, serv uintptr, servlen socklen_t, flags int32) int32 { /* getnameinfo.c:125:5: */
	if __ccgo_strace {
		trc("tls=%v sa1=%v sl=%v node=%v nodelen=%v serv=%v servlen=%v flags=%v, (%v:)", tls, sa1, sl, node, nodelen, serv, servlen, flags, origin(2))
	}
	bp := tls.Alloc(347)
	defer tls.Free(347)

	// var ptr [78]uint8 at bp, 78

	// var buf [256]uint8 at bp+78, 256

	// var num [13]uint8 at bp+334, 13

	var af int32 = int32((*sockaddr)(unsafe.Pointer(sa1)).sa_family)
	var a uintptr
	var scopeid uint32

	switch af {
	case 2:
		a = sa1 + 4
		if uint64(sl) < uint64(unsafe.Sizeof(sockaddr_in{})) {
			return -6
		}
		mkptr4(tls, bp, a)
		scopeid = uint32(0)
		break
	case 10:
		a = sa1 + 8
		if uint64(sl) < uint64(unsafe.Sizeof(sockaddr_in6{})) {
			return -6
		}
		if Xmemcmp(tls, a, ts+90, uint64(12)) != 0 {
			mkptr6(tls, bp, a)
		} else {
			mkptr4(tls, bp, a+uintptr(12))
		}
		scopeid = (*sockaddr_in6)(unsafe.Pointer(sa1)).sin6_scope_id
		break
	default:
		return -6
	}

	if node != 0 && nodelen != 0 {
		*(*uint8)(unsafe.Pointer(bp + 78)) = uint8(0)
		if !(flags&0x01 != 0) {
			reverse_hosts(tls, bp+78, a, scopeid, af)
		}
		if !(int32(*(*uint8)(unsafe.Pointer(bp + 78))) != 0) && !(flags&0x01 != 0) {
			Xabort(tls) //TODO-
			// unsigned char query[18+PTR_MAX], reply[512];
			// int qlen = __res_mkquery(0, ptr, 1, RR_PTR,
			// 	0, 0, 0, query, sizeof query);
			// query[3] = 0; /* don't need AD flag */
			// int rlen = __res_send(query, qlen, reply, sizeof reply);
			// buf[0] = 0;
			// if (rlen > 0)
			// 	__dns_parse(reply, rlen, dns_parse_callback, buf);
		}
		if !(int32(*(*uint8)(unsafe.Pointer(bp + 78))) != 0) {
			if flags&0x08 != 0 {
				return -2
			}
			Xinet_ntop(tls, af, a, bp+78, uint32(unsafe.Sizeof([256]uint8{})))
			if scopeid != 0 {
				Xabort(tls) //TODO-
				// char *p = 0, tmp[IF_NAMESIZE+1];
				// if (!(flags & NI_NUMERICSCOPE) &&
				//     (IN6_IS_ADDR_LINKLOCAL(a) ||
				//      IN6_IS_ADDR_MC_LINKLOCAL(a)))
				// 	p = if_indextoname(scopeid, tmp+1);
				// if (!p)
				// 	p = itoa(num, scopeid);
				// *--p = '%';
				// strcat(buf, p);
			}
		}
		if Xstrlen(tls, bp+78) >= size_t(nodelen) {
			return -12
		}
		Xstrcpy(tls, node, bp+78)
	}

	if serv != 0 && servlen != 0 {
		var p uintptr = bp + 78 /* buf */
		var port int32 = int32(Xntohs(tls, (*sockaddr_in)(unsafe.Pointer(sa1)).sin_port))
		*(*uint8)(unsafe.Pointer(bp + 78)) = uint8(0)
		if !(flags&0x02 != 0) {
			reverse_services(tls, bp+78, port, flags&0x10)
		}
		if !(int32(*(*uint8)(unsafe.Pointer(p))) != 0) {
			p = itoa(tls, bp+334, uint32(port))
		}
		if Xstrlen(tls, p) >= size_t(servlen) {
			return -12
		}
		Xstrcpy(tls, serv, p)
	}

	return 0
}

var Xh_errno int32 /* h_errno.c:4:5: */

func X__h_errno_location(tls *TLS) uintptr { /* h_errno.c:6:5: */
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	return uintptr(unsafe.Pointer(&Xh_errno))
}

func X__inet_aton(tls *TLS, s0 uintptr, dest uintptr) int32 { /* inet_aton.c:7:5: */
	if __ccgo_strace {
		trc("tls=%v s0=%v dest=%v, (%v:)", tls, s0, dest, origin(2))
	}
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var s uintptr = s0
	var d uintptr = dest
	*(*[4]uint64)(unsafe.Pointer(bp /* a */)) = [4]uint64{0: uint64(0)}
	// var z uintptr at bp+32, 8

	var i int32

	for i = 0; i < 4; i++ {
		*(*uint64)(unsafe.Pointer(bp + uintptr(i)*8)) = Xstrtoul(tls, s, bp+32, 0)
		if *(*uintptr)(unsafe.Pointer(bp + 32)) == s || *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) != '.' || !(func() int32 {
			if 0 != 0 {
				return Xisdigit(tls, int32(*(*uint8)(unsafe.Pointer(s))))
			}
			return Bool32(uint32(*(*uint8)(unsafe.Pointer(s)))-uint32('0') < uint32(10))
		}() != 0) {
			return 0
		}
		if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) != 0) {
			break
		}
		s = *(*uintptr)(unsafe.Pointer(bp + 32)) + uintptr(1)
	}
	if i == 4 {
		return 0
	}
	switch i {
	case 0:
		*(*uint64)(unsafe.Pointer(bp + 1*8)) = *(*uint64)(unsafe.Pointer(bp)) & uint64(0xffffff)
		AssignShrPtrUint64(bp, int(24))
		fallthrough
	case 1:
		*(*uint64)(unsafe.Pointer(bp + 2*8)) = *(*uint64)(unsafe.Pointer(bp + 1*8)) & uint64(0xffff)
		AssignShrPtrUint64(bp+1*8, int(16))
		fallthrough
	case 2:
		*(*uint64)(unsafe.Pointer(bp + 3*8)) = *(*uint64)(unsafe.Pointer(bp + 2*8)) & uint64(0xff)
		AssignShrPtrUint64(bp+2*8, int(8))
	}
	for i = 0; i < 4; i++ {
		if *(*uint64)(unsafe.Pointer(bp + uintptr(i)*8)) > uint64(255) {
			return 0
		}
		*(*uint8)(unsafe.Pointer(d + uintptr(i))) = uint8(*(*uint64)(unsafe.Pointer(bp + uintptr(i)*8)))
	}
	return 1
}

func Xinet_ntop(tls *TLS, af int32, a0 uintptr, s uintptr, l socklen_t) uintptr { /* inet_ntop.c:7:12: */
	if __ccgo_strace {
		trc("tls=%v af=%v a0=%v s=%v l=%v, (%v:)", tls, af, a0, s, l, origin(2))
	}
	bp := tls.Alloc(276)
	defer tls.Free(276)

	var a uintptr = a0
	var i int32
	var j int32
	var max int32
	var best int32
	// var buf [100]uint8 at bp+176, 100

	switch af {
	case 2:
		if socklen_t(Xsnprintf(tls, s, uint64(l), ts+103, VaList(bp, int32(*(*uint8)(unsafe.Pointer(a))), int32(*(*uint8)(unsafe.Pointer(a + 1))), int32(*(*uint8)(unsafe.Pointer(a + 2))), int32(*(*uint8)(unsafe.Pointer(a + 3)))))) < l {
			return s
		}
		break
	case 10:
		if Xmemcmp(tls, a, ts+90, uint64(12)) != 0 {
			Xsnprintf(tls, bp+176, uint64(unsafe.Sizeof([100]uint8{})),
				ts+115,
				VaList(bp+32, 256*int32(*(*uint8)(unsafe.Pointer(a)))+int32(*(*uint8)(unsafe.Pointer(a + 1))), 256*int32(*(*uint8)(unsafe.Pointer(a + 2)))+int32(*(*uint8)(unsafe.Pointer(a + 3))),
					256*int32(*(*uint8)(unsafe.Pointer(a + 4)))+int32(*(*uint8)(unsafe.Pointer(a + 5))), 256*int32(*(*uint8)(unsafe.Pointer(a + 6)))+int32(*(*uint8)(unsafe.Pointer(a + 7))),
					256*int32(*(*uint8)(unsafe.Pointer(a + 8)))+int32(*(*uint8)(unsafe.Pointer(a + 9))), 256*int32(*(*uint8)(unsafe.Pointer(a + 10)))+int32(*(*uint8)(unsafe.Pointer(a + 11))),
					256*int32(*(*uint8)(unsafe.Pointer(a + 12)))+int32(*(*uint8)(unsafe.Pointer(a + 13))), 256*int32(*(*uint8)(unsafe.Pointer(a + 14)))+int32(*(*uint8)(unsafe.Pointer(a + 15)))))
		} else {
			Xsnprintf(tls, bp+176, uint64(unsafe.Sizeof([100]uint8{})),
				ts+139,
				VaList(bp+96, 256*int32(*(*uint8)(unsafe.Pointer(a)))+int32(*(*uint8)(unsafe.Pointer(a + 1))), 256*int32(*(*uint8)(unsafe.Pointer(a + 2)))+int32(*(*uint8)(unsafe.Pointer(a + 3))),
					256*int32(*(*uint8)(unsafe.Pointer(a + 4)))+int32(*(*uint8)(unsafe.Pointer(a + 5))), 256*int32(*(*uint8)(unsafe.Pointer(a + 6)))+int32(*(*uint8)(unsafe.Pointer(a + 7))),
					256*int32(*(*uint8)(unsafe.Pointer(a + 8)))+int32(*(*uint8)(unsafe.Pointer(a + 9))), 256*int32(*(*uint8)(unsafe.Pointer(a + 10)))+int32(*(*uint8)(unsafe.Pointer(a + 11))),
					int32(*(*uint8)(unsafe.Pointer(a + 12))), int32(*(*uint8)(unsafe.Pointer(a + 13))), int32(*(*uint8)(unsafe.Pointer(a + 14))), int32(*(*uint8)(unsafe.Pointer(a + 15)))))
		}
		// Replace longest /(^0|:)[:0]{2,}/ with "::"
		i = AssignInt32(&best, 0)
		max = 2
		for ; *(*uint8)(unsafe.Pointer(bp + 176 + uintptr(i))) != 0; i++ {
			if i != 0 && int32(*(*uint8)(unsafe.Pointer(bp + 176 + uintptr(i)))) != ':' {
				continue
			}
			j = int32(Xstrspn(tls, bp+176+uintptr(i), ts+169))
			if j > max {
				best = i
				max = j
			}
		}
		if max > 3 {
			*(*uint8)(unsafe.Pointer(bp + 176 + uintptr(best))) = AssignPtrUint8(bp+176+uintptr(best+1), uint8(':'))
			Xmemmove(tls, bp+176+uintptr(best)+uintptr(2), bp+176+uintptr(best)+uintptr(max), uint64(i-best-max+1))
		}
		if Xstrlen(tls, bp+176) < size_t(l) {
			Xstrcpy(tls, s, bp+176)
			return s
		}
		break
	default:
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 97
		return uintptr(0)
	}
	*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 28
	return uintptr(0)
}

func hexval(tls *TLS, c uint32) int32 { /* inet_pton.c:7:12: */
	if c-uint32('0') < uint32(10) {
		return int32(c - uint32('0'))
	}
	c = c | uint32(32)
	if c-uint32('a') < uint32(6) {
		return int32(c - uint32('a') + uint32(10))
	}
	return -1
}

func Xinet_pton(tls *TLS, af int32, s uintptr, a0 uintptr) int32 { /* inet_pton.c:15:5: */
	if __ccgo_strace {
		trc("tls=%v af=%v s=%v a0=%v, (%v:)", tls, af, s, a0, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var ip [8]uint16_t at bp, 16

	var a uintptr = a0
	var i int32
	var j int32
	var v int32
	var d int32
	var brk int32 = -1
	var need_v4 int32 = 0

	if af == 2 {
		for i = 0; i < 4; i++ {
			for v = AssignInt32(&j, 0); j < 3 && func() int32 {
				if 0 != 0 {
					return Xisdigit(tls, int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))))
				}
				return Bool32(uint32(*(*uint8)(unsafe.Pointer(s + uintptr(j))))-uint32('0') < uint32(10))
			}() != 0; j++ {
				v = 10*v + int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) - '0'
			}
			if j == 0 || j > 1 && int32(*(*uint8)(unsafe.Pointer(s))) == '0' || v > 255 {
				return 0
			}
			*(*uint8)(unsafe.Pointer(a + uintptr(i))) = uint8(v)
			if int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) == 0 && i == 3 {
				return 1
			}
			if int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) != '.' {
				return 0
			}
			s += uintptr(j + 1)
		}
		return 0
	} else if af != 10 {
		*(*int32)(unsafe.Pointer(X___errno_location(tls))) = 97
		return -1
	}

	if int32(*(*uint8)(unsafe.Pointer(s))) == ':' && int32(*(*uint8)(unsafe.Pointer(PreIncUintptr(&s, 1)))) != ':' {
		return 0
	}

	for i = 0; ; i++ {
		if int32(*(*uint8)(unsafe.Pointer(s))) == ':' && brk < 0 {
			brk = i
			*(*uint16_t)(unsafe.Pointer(bp + uintptr(i&7)*2)) = uint16_t(0)
			if !(int32(*(*uint8)(unsafe.Pointer(PreIncUintptr(&s, 1)))) != 0) {
				break
			}
			if i == 7 {
				return 0
			}
			continue
		}
		for v = AssignInt32(&j, 0); j < 4 && AssignInt32(&d, hexval(tls, uint32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))))) >= 0; j++ {
			v = 16*v + d
		}
		if j == 0 {
			return 0
		}
		*(*uint16_t)(unsafe.Pointer(bp + uintptr(i&7)*2)) = uint16_t(v)
		if !(int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) != 0) && (brk >= 0 || i == 7) {
			break
		}
		if i == 7 {
			return 0
		}
		if int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) != ':' {
			if int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) != '.' || i < 6 && brk < 0 {
				return 0
			}
			need_v4 = 1
			i++
			break
		}
		s += uintptr(j + 1)
	}
	if brk >= 0 {
		Xmemmove(tls, bp+uintptr(brk)*2+uintptr(7)*2-uintptr(i)*2, bp+uintptr(brk)*2, uint64(2*(i+1-brk)))
		for j = 0; j < 7-i; j++ {
			*(*uint16_t)(unsafe.Pointer(bp + uintptr(brk+j)*2)) = uint16_t(0)
		}
	}
	for j = 0; j < 8; j++ {
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&a, 1))) = uint8(int32(*(*uint16_t)(unsafe.Pointer(bp + uintptr(j)*2))) >> 8)
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&a, 1))) = uint8(*(*uint16_t)(unsafe.Pointer(bp + uintptr(j)*2)))
	}
	if need_v4 != 0 && Xinet_pton(tls, 2, s, a-uintptr(4)) <= 0 {
		return 0
	}
	return 1
}

func X__lookup_ipliteral(tls *TLS, buf uintptr, name uintptr, family int32) int32 { /* lookup_ipliteral.c:12:5: */
	if __ccgo_strace {
		trc("tls=%v buf=%v name=%v family=%v, (%v:)", tls, buf, name, family, origin(2))
	}
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// var a4 in_addr at bp, 4

	// var a6 in6_addr at bp+68, 16

	if X__inet_aton(tls, name, bp) > 0 {
		if family == 10 { // wrong family
			return -2
		}
		Xmemcpy(tls, buf+8, bp, uint64(unsafe.Sizeof(in_addr{})))
		(*address)(unsafe.Pointer(buf)).family = 2
		(*address)(unsafe.Pointer(buf)).scopeid = uint32(0)
		return 1
	}
	// var tmp [64]uint8 at bp+4, 64

	var p uintptr = Xstrchr(tls, name, '%')
	// var z uintptr at bp+88, 8

	var scopeid uint64 = uint64(0)
	if p != 0 && (int64(p)-int64(name))/1 < int64(64) {
		Xmemcpy(tls, bp+4, name, uint64((int64(p)-int64(name))/1))
		*(*uint8)(unsafe.Pointer(bp + 4 + uintptr((int64(p)-int64(name))/1))) = uint8(0)
		name = bp + 4 /* &tmp[0] */
	}

	if Xinet_pton(tls, 10, name, bp+68) <= 0 {
		return 0
	}
	if family == 2 { // wrong family
		return -2
	}

	Xmemcpy(tls, buf+8, bp+68, uint64(unsafe.Sizeof(in6_addr{})))
	(*address)(unsafe.Pointer(buf)).family = 10
	if p != 0 {
		if func() int32 {
			if 0 != 0 {
				return Xisdigit(tls, int32(*(*uint8)(unsafe.Pointer(PreIncUintptr(&p, 1)))))
			}
			return Bool32(uint32(*(*uint8)(unsafe.Pointer(PreIncUintptr(&p, 1))))-uint32('0') < uint32(10))
		}() != 0 {
			scopeid = Xstrtoull(tls, p, bp+88, 10)
		} else {
			*(*uintptr)(unsafe.Pointer(bp + 88 /* z */)) = p - uintptr(1)
		}
		if *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)))) != 0 {
			Xabort(tls) //TODO-
			// if (!IN6_IS_ADDR_LINKLOCAL(&a6) &&
			//     !IN6_IS_ADDR_MC_LINKLOCAL(&a6))
			// 	return EAI_NONAME;
			// scopeid = if_nametoindex(p);
			// if (!scopeid) return EAI_NONAME;
		}
		if scopeid > uint64(0xffffffff) {
			return -2
		}
	}
	(*address)(unsafe.Pointer(buf)).scopeid = uint32(scopeid)
	return 1
}

func is_valid_hostname(tls *TLS, host uintptr) int32 { /* lookup_name.c:18:12: */
	var s uintptr
	//TODO if (strnlen(host, 255)-1 >= 254 || mbstowcs(0, host, 0) == -1) return 0;
	if Xstrnlen(tls, host, uint64(255))-uint64(1) >= uint64(254) {
		return 0
	}
	for s = host; int32(*(*uint8)(unsafe.Pointer(s))) >= 0x80 || int32(*(*uint8)(unsafe.Pointer(s))) == '.' || int32(*(*uint8)(unsafe.Pointer(s))) == '-' || Xisalnum(tls, int32(*(*uint8)(unsafe.Pointer(s)))) != 0; s++ {
	}
	return BoolInt32(!(*(*uint8)(unsafe.Pointer(s)) != 0))
}

var Xzero_struct_address address /* lookup_name.c:27:16: */

func name_from_null(tls *TLS, buf uintptr, name uintptr, family int32, flags int32) int32 { /* lookup_name.c:29:12: */
	var cnt int32 = 0
	if name != 0 {
		return 0
	}
	if flags&0x01 != 0 {
		//TODO if (family != AF_INET6)
		//TODO 	buf[cnt++] = (struct address){ .family = AF_INET };
		if family != 10 {
			var x = Xzero_struct_address
			x.family = 2
			*(*address)(unsafe.Pointer(buf + uintptr(PostIncInt32(&cnt, 1))*28)) = x
		}
		//TODO if (family != AF_INET)
		//TODO 	buf[cnt++] = (struct address){ .family = AF_INET6 };
		if family != 2 {
			var x = Xzero_struct_address
			x.family = 10
			*(*address)(unsafe.Pointer(buf + uintptr(PostIncInt32(&cnt, 1))*28)) = x
		}
	} else {
		Xabort(tls) //TODO-
		// 	if (family != AF_INET6)
		// 		buf[cnt++] = (struct address){ .family = AF_INET, .addr = { 127,0,0,1 } };
		// 	if (family != AF_INET)
		// 		buf[cnt++] = (struct address){ .family = AF_INET6, .addr = { [15] = 1 } };
	}
	return cnt
}

func name_from_numeric(tls *TLS, buf uintptr, name uintptr, family int32) int32 { /* lookup_name.c:58:12: */
	return X__lookup_ipliteral(tls, buf, name, family)
}

func name_from_hosts(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32) int32 { /* lookup_name.c:63:12: */
	bp := tls.Alloc(512)
	defer tls.Free(512)

	// var line [512]uint8 at bp, 512

	var l size_t = Xstrlen(tls, name)
	var cnt int32 = 0
	var badfam int32 = 0
	var _buf [1032]uint8
	_ = _buf
	//TODO FILE _f, *f = __fopen_rb_ca("/etc/hosts", &_f, _buf, sizeof _buf);
	var _f FILE
	_ = _f
	var f uintptr = Xfopen(tls, ts+76, ts+87)
	if !(f != 0) {
		switch *(*int32)(unsafe.Pointer(X___errno_location(tls))) {
		case 2:
			fallthrough
		case 20:
			fallthrough
		case 13:
			return 0
			fallthrough
		default:
			return -11
		}
	}
	for Xfgets(tls, bp, int32(unsafe.Sizeof([512]uint8{})), f) != 0 && cnt < 48 {
		var p uintptr
		var z uintptr

		if AssignUintptr(&p, Xstrchr(tls, bp, '#')) != 0 {
			*(*uint8)(unsafe.Pointer(PostIncUintptr(&p, 1))) = uint8('\n')
			*(*uint8)(unsafe.Pointer(p)) = uint8(0)
		}
		for p = bp + uintptr(1); AssignUintptr(&p, Xstrstr(tls, p, name)) != 0 && (!(__isspace(tls, int32(*(*uint8)(unsafe.Pointer(p + UintptrFromInt32(-1))))) != 0) || !(__isspace(tls, int32(*(*uint8)(unsafe.Pointer(p + uintptr(l))))) != 0)); p++ {
		}
		if !(p != 0) {
			continue
		}

		// Isolate IP address to parse
		for p = bp; /* &line[0] */ *(*uint8)(unsafe.Pointer(p)) != 0 && !(__isspace(tls, int32(*(*uint8)(unsafe.Pointer(p)))) != 0); p++ {
		}
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&p, 1))) = uint8(0)
		switch name_from_numeric(tls, buf+uintptr(cnt)*28, bp, family) {
		case 1:
			cnt++
			break
		case 0:
			continue
		default:
			badfam = -2
			continue
		}

		// Extract first name as canonical name
		for ; *(*uint8)(unsafe.Pointer(p)) != 0 && __isspace(tls, int32(*(*uint8)(unsafe.Pointer(p)))) != 0; p++ {
		}
		for z = p; *(*uint8)(unsafe.Pointer(z)) != 0 && !(__isspace(tls, int32(*(*uint8)(unsafe.Pointer(z)))) != 0); z++ {
		}
		*(*uint8)(unsafe.Pointer(z)) = uint8(0)
		if is_valid_hostname(tls, p) != 0 {
			Xmemcpy(tls, canon, p, uint64((int64(z)-int64(p))/1+int64(1)))
		}
	}
	//TODO __fclose_ca(f);
	Xfclose(tls, f)
	if cnt != 0 {
		return cnt
	}
	return badfam
}

type dpc_ctx = struct {
	addrs uintptr
	canon uintptr
	cnt   int32
	_     [4]byte
} /* lookup_name.c:112:1 */

func name_from_dns_search(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32) int32 { /* lookup_name.c:191:12: */
	return -1 //TODO-
	Xabort(tls)
	return int32(0) //TODO-
	// char search[256];
	// struct resolvconf conf;
	// size_t l, dots;
	// char *p, *z;

	// if (__get_resolv_conf(&conf, search, sizeof search) < 0) return -1;

	// /* Count dots, suppress search when >=ndots or name ends in
	//  * a dot, which is an explicit request for global scope. */
	// for (dots=l=0; name[l]; l++) if (name[l]=='.') dots++;
	// if (dots >= conf.ndots || name[l-1]=='.') *search = 0;

	// /* Strip final dot for canon, fail if multiple trailing dots. */
	// if (name[l-1]=='.') l--;
	// if (!l || name[l-1]=='.') return EAI_NONAME;

	// /* This can never happen; the caller already checked length. */
	// if (l >= 256) return EAI_NONAME;

	// /* Name with search domain appended is setup in canon[]. This both
	//  * provides the desired default canonical name (if the requested
	//  * name is not a CNAME record) and serves as a buffer for passing
	//  * the full requested name to name_from_dns. */
	// memcpy(canon, name, l);
	// canon[l] = '.';

	// for (p=search; *p; p=z) {
	// 	for (; isspace(*p); p++);
	// 	for (z=p; *z && !isspace(*z); z++);
	// 	if (z==p) break;
	// 	if (z-p < 256 - l - 1) {
	// 		memcpy(canon+l+1, p, z-p);
	// 		canon[z-p+1+l] = 0;
	// 		int cnt = name_from_dns(buf, canon, canon, family, &conf);
	// 		if (cnt) return cnt;
	// 	}
	// }

	// canon[l] = 0;
	// return name_from_dns(buf, canon, name, family, &conf);
}

type policy = struct {
	addr  [16]uint8
	len   uint8
	mask  uint8
	prec  uint8
	label uint8
} /* lookup_name.c:237:14 */

var defpolicy = [6]policy{
	{addr: *(*[16]uint8)(unsafe.Pointer(ts + 172)), len: uint8(15), mask: uint8(0xff), prec: uint8(50)},
	{addr: *(*[16]uint8)(unsafe.Pointer(ts + 189)), len: uint8(11), mask: uint8(0xff), prec: uint8(35), label: uint8(4)},
	{addr: *(*[16]uint8)(unsafe.Pointer(ts + 205)), len: uint8(1), mask: uint8(0xff), prec: uint8(30), label: uint8(2)},
	{addr: *(*[16]uint8)(unsafe.Pointer(ts + 221)), len: uint8(3), mask: uint8(0xff), prec: uint8(5), label: uint8(5)},
	{addr: *(*[16]uint8)(unsafe.Pointer(ts + 237)), mask: uint8(0xfe), prec: uint8(3), label: uint8(13)},
	// Last rule must match all addresses to stop loop.
	{addr: *(*[16]uint8)(unsafe.Pointer(ts + 253)), prec: uint8(40), label: uint8(1)},
} /* lookup_name.c:241:3 */

func policyof(tls *TLS, a uintptr) uintptr { /* lookup_name.c:259:28: */
	var i int32
	for i = 0; ; i++ {
		if Xmemcmp(tls, a, uintptr(unsafe.Pointer(&defpolicy))+uintptr(i)*20, uint64(defpolicy[i].len)) != 0 {
			continue
		}
		if int32(*(*uint8_t)(unsafe.Pointer(a + uintptr(defpolicy[i].len))))&int32(defpolicy[i].mask) !=
			int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&defpolicy)) + uintptr(i)*20 + uintptr(defpolicy[i].len)))) {
			continue
		}
		return uintptr(unsafe.Pointer(&defpolicy)) + uintptr(i)*20
	}
	return uintptr(0)
}

func labelof(tls *TLS, a uintptr) int32 { /* lookup_name.c:272:12: */
	return int32((*policy)(unsafe.Pointer(policyof(tls, a))).label)
}

func scopeof(tls *TLS, a uintptr) int32 { /* lookup_name.c:277:12: */
	if int32(*(*uint8_t)(unsafe.Pointer(a))) == 0xff {
		return int32(*(*uint8_t)(unsafe.Pointer(a + 1))) & 15
	}
	if int32(*(*uint8_t)(unsafe.Pointer(a))) == 0xfe && int32(*(*uint8_t)(unsafe.Pointer(a + 1)))&0xc0 == 0x80 {
		return 2
	}
	if *(*uint32_t)(unsafe.Pointer(a)) == uint32_t(0) && *(*uint32_t)(unsafe.Pointer(a + 1*4)) == uint32_t(0) && *(*uint32_t)(unsafe.Pointer(a + 2*4)) == uint32_t(0) && int32(*(*uint8_t)(unsafe.Pointer(a + 12))) == 0 && int32(*(*uint8_t)(unsafe.Pointer(a + 13))) == 0 && int32(*(*uint8_t)(unsafe.Pointer(a + 14))) == 0 && int32(*(*uint8_t)(unsafe.Pointer(a + 15))) == 1 {
		return 2
	}
	if int32(*(*uint8_t)(unsafe.Pointer(a))) == 0xfe && int32(*(*uint8_t)(unsafe.Pointer(a + 1)))&0xc0 == 0xc0 {
		return 5
	}
	return 14
}

func prefixmatch(tls *TLS, s uintptr, d uintptr) int32 { /* lookup_name.c:286:12: */
	// FIXME: The common prefix length should be limited to no greater
	// than the nominal length of the prefix portion of the source
	// address. However the definition of the source prefix length is
	// not clear and thus this limiting is not yet implemented.
	var i uint32
	for i = uint32(0); i < uint32(128) && !((int32(*(*uint8_t)(unsafe.Pointer(s /* &.__in6_union */ /* &.__s6_addr */ + uintptr(i/uint32(8)))))^int32(*(*uint8_t)(unsafe.Pointer(d /* &.__in6_union */ /* &.__s6_addr */ + uintptr(i/uint32(8))))))&(int32(128)>>(i%uint32(8))) != 0); i++ {
	}
	return int32(i)
}

func addrcmp(tls *TLS, _a uintptr, _b uintptr) int32 { /* lookup_name.c:305:12: */
	var a uintptr = _a
	var b uintptr = _b
	return (*address)(unsafe.Pointer(b)).sortkey - (*address)(unsafe.Pointer(a)).sortkey
}

func X__lookup_name(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32, flags int32) int32 { /* lookup_name.c:311:5: */
	if __ccgo_strace {
		trc("tls=%v buf=%v canon=%v name=%v family=%v flags=%v, (%v:)", tls, buf, canon, name, family, flags, origin(2))
	}
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var cnt int32 = 0
	var i int32
	var j int32
	_ = j

	*(*uint8)(unsafe.Pointer(canon)) = uint8(0)
	if name != 0 {
		// reject empty name and check len so it fits into temp bufs
		var l size_t = Xstrnlen(tls, name, uint64(255))
		if l-uint64(1) >= uint64(254) {
			return -2
		}
		Xmemcpy(tls, canon, name, l+uint64(1))
	}

	// Procedurally, a request for v6 addresses with the v4-mapped
	// flag set is like a request for unspecified family, followed
	// by filtering of the results.
	if flags&0x08 != 0 {
		if family == 10 {
			family = 0
		} else {
			flags = flags - 0x08
		}
	}

	// Try each backend until there's at least one result.
	cnt = name_from_null(tls, buf, name, family, flags)
	if !(cnt != 0) {
		cnt = name_from_numeric(tls, buf, name, family)
	}
	if !(cnt != 0) && !(flags&0x04 != 0) {
		cnt = name_from_hosts(tls, buf, canon, name, family)
		if !(cnt != 0) {
			cnt = name_from_dns_search(tls, buf, canon, name, family)
		}
	}
	if cnt <= 0 {
		if cnt != 0 {
			return cnt
		}
		return -2
	}

	// Filter/transform results for v4-mapped lookup, if requested.
	if flags&0x08 != 0 {
		Xabort(tls) //TODO-
		// 	if (!(flags & AI_ALL)) {
		// 		/* If any v6 results exist, remove v4 results. */
		// 		for (i=0; i<cnt && buf[i].family != AF_INET6; i++);
		// 		if (i<cnt) {
		// 			for (j=0; i<cnt; i++) {
		// 				if (buf[i].family == AF_INET6)
		// 					buf[j++] = buf[i];
		// 			}
		// 			cnt = i = j;
		// 		}
		// 	}
		// 	/* Translate any remaining v4 results to v6 */
		// 	for (i=0; i<cnt; i++) {
		// 		if (buf[i].family != AF_INET) continue;
		// 		memcpy(buf[i].addr+12, buf[i].addr, 4);
		// 		memcpy(buf[i].addr, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
		// 		buf[i].family = AF_INET6;
		// 	}
	}

	// No further processing is needed if there are fewer than 2
	// results or if there are only IPv4 results.
	if cnt < 2 || family == 2 {
		return cnt
	}
	for i = 0; i < cnt; i++ {
		if (*address)(unsafe.Pointer(buf+uintptr(i)*28)).family != 2 {
			break
		}
	}
	if i == cnt {
		return cnt
	}
	var cs int32
	_ = cs
	//TODO pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);

	// The following implements a subset of RFC 3484/6724 destination
	// address selection by generating a single 31-bit sort key for
	// each address. Rules 3, 4, and 7 are omitted for having
	// excessive runtime and code size cost and dubious benefit.
	// So far the label/precedence table cannot be customized.
	for i = 0; i < cnt; i++ {
		var family int32 = (*address)(unsafe.Pointer(buf + uintptr(i)*28)).family
		var key int32 = 0
		*(*sockaddr_in6)(unsafe.Pointer(bp + 28 /* sa6 */)) = sockaddr_in6{}
		*(*sockaddr_in6)(unsafe.Pointer(bp /* da6 */)) = sockaddr_in6{sin6_family: sa_family_t(10), sin6_port: in_port_t(65535), sin6_scope_id: (*address)(unsafe.Pointer(buf + uintptr(i)*28)).scopeid}
		*(*sockaddr_in)(unsafe.Pointer(bp + 72 /* sa4 */)) = sockaddr_in{}
		*(*sockaddr_in)(unsafe.Pointer(bp + 56 /* da4 */)) = sockaddr_in{sin_family: sa_family_t(2), sin_port: in_port_t(65535)}
		var sa1 uintptr
		var da uintptr
		// var salen socklen_t at bp+88, 4

		var dalen socklen_t
		if family == 10 {
			Xmemcpy(tls, bp+8, buf+uintptr(i)*28+8, uint64(16))
			da = bp /* &da6 */
			dalen = socklen_t(unsafe.Sizeof(sockaddr_in6{}))
			sa1 = bp + 28 /* &sa6 */
			*(*socklen_t)(unsafe.Pointer(bp + 88 /* salen */)) = socklen_t(unsafe.Sizeof(sockaddr_in6{}))
		} else {
			Xmemcpy(tls, bp+28+8,
				ts+90, uint64(12))
			Xmemcpy(tls, bp+8+uintptr(12), buf+uintptr(i)*28+8, uint64(4))
			Xmemcpy(tls, bp+8,
				ts+90, uint64(12))
			Xmemcpy(tls, bp+8+uintptr(12), buf+uintptr(i)*28+8, uint64(4))
			Xmemcpy(tls, bp+56+4, buf+uintptr(i)*28+8, uint64(4))
			da = bp + 56 /* &da4 */
			dalen = socklen_t(unsafe.Sizeof(sockaddr_in{}))
			sa1 = bp + 72 /* &sa4 */
			*(*socklen_t)(unsafe.Pointer(bp + 88 /* salen */)) = socklen_t(unsafe.Sizeof(sockaddr_in{}))
		}
		var dpolicy uintptr = policyof(tls, bp+8)
		var dscope int32 = scopeof(tls, bp+8)
		var dlabel int32 = int32((*policy)(unsafe.Pointer(dpolicy)).label)
		var dprec int32 = int32((*policy)(unsafe.Pointer(dpolicy)).prec)
		var prefixlen int32 = 0
		var fd int32 = Xsocket(tls, family, 2|02000000, 17)
		if fd >= 0 {
			if !(Xconnect(tls, fd, da, dalen) != 0) {
				key = key | 0x40000000
				if !(Xgetsockname(tls, fd, sa1, bp+88) != 0) {
					if family == 2 {
						Xmemcpy(tls,
							bp+28+8+uintptr(12),
							bp+72+4, uint64(4))
					}
					if dscope == scopeof(tls, bp+28+8) {
						key = key | 0x20000000
					}
					if dlabel == labelof(tls, bp+28+8) {
						key = key | 0x10000000
					}
					prefixlen = prefixmatch(tls, bp+28+8,
						bp+8)
				}
			}
			Xclose(tls, fd)
		}
		key = key | dprec<<20
		key = key | (15-dscope)<<16
		key = key | prefixlen<<8
		key = key | (48-i)<<0
		(*address)(unsafe.Pointer(buf + uintptr(i)*28)).sortkey = key
	}
	Xqsort(tls, buf, uint64(cnt), uint64(unsafe.Sizeof(address{})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*TLS, uintptr, uintptr) int32
	}{addrcmp})))

	//TODO pthread_setcancelstate(cs, 0);

	return cnt
}

func X__lookup_serv(tls *TLS, buf uintptr, name uintptr, proto int32, socktype int32, flags int32) int32 { /* lookup_serv.c:12:5: */
	if __ccgo_strace {
		trc("tls=%v buf=%v name=%v proto=%v socktype=%v flags=%v, (%v:)", tls, buf, name, proto, socktype, flags, origin(2))
	}
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var line [128]uint8
	_ = line
	var cnt int32 = 0
	var p uintptr
	_ = p
	*(*uintptr)(unsafe.Pointer(bp /* z */)) = ts + 13 /* "" */
	var port uint64 = uint64(0)

	switch socktype {
	case 1:
		switch proto {
		case 0:
			proto = 6
			fallthrough
		case 6:
			break
		default:
			return -8
		}
		break
	case 2:
		switch proto {
		case 0:
			proto = 17
			fallthrough
		case 17:
			break
		default:
			return -8
		}
		fallthrough
	case 0:
		break
	default:
		if name != 0 {
			return -8
		}
		(*service)(unsafe.Pointer(buf)).port = uint16_t(0)
		(*service)(unsafe.Pointer(buf)).proto = uint8(proto)
		(*service)(unsafe.Pointer(buf)).socktype = uint8(socktype)
		return 1
	}

	if name != 0 {
		if !(int32(*(*uint8)(unsafe.Pointer(name))) != 0) {
			return -8
		}
		port = Xstrtoul(tls, name, bp, 10)
	}
	if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		if port > uint64(65535) {
			return -8
		}
		if proto != 17 {
			(*service)(unsafe.Pointer(buf + uintptr(cnt)*4)).port = uint16_t(port)
			(*service)(unsafe.Pointer(buf + uintptr(cnt)*4)).socktype = uint8(1)
			(*service)(unsafe.Pointer(buf + uintptr(PostIncInt32(&cnt, 1))*4)).proto = uint8(6)
		}
		if proto != 6 {
			(*service)(unsafe.Pointer(buf + uintptr(cnt)*4)).port = uint16_t(port)
			(*service)(unsafe.Pointer(buf + uintptr(cnt)*4)).socktype = uint8(2)
			(*service)(unsafe.Pointer(buf + uintptr(PostIncInt32(&cnt, 1))*4)).proto = uint8(17)
		}
		return cnt
	}

	if flags&0x400 != 0 {
		return -2
	}

	var l size_t = Xstrlen(tls, name)
	_ = l

	Xabort(tls) //TODO-
	// unsigned char _buf[1032];
	// FILE _f, *f = __fopen_rb_ca("/etc/services", &_f, _buf, sizeof _buf);
	// if (!f) switch (errno) {
	// case ENOENT:
	// case ENOTDIR:
	// case EACCES:
	// 	return EAI_SERVICE;
	// default:
	// 	return EAI_SYSTEM;
	// }

	Xabort(tls) //TODO-
	// while (fgets(line, sizeof line, f) && cnt < MAXSERVS) {
	// 	if ((p=strchr(line, '#'))) *p++='\n', *p=0;

	// 	/* Find service name */
	// 	for(p=line; (p=strstr(p, name)); p++) {
	// 		if (p>line && !isspace(p[-1])) continue;
	// 		if (p[l] && !isspace(p[l])) continue;
	// 		break;
	// 	}
	// 	if (!p) continue;

	// 	/* Skip past canonical name at beginning of line */
	// 	for (p=line; *p && !isspace(*p); p++);

	// 	port = strtoul(p, &z, 10);
	// 	if (port > 65535 || z==p) continue;
	// 	if (!strncmp(z, "/udp", 4)) {
	// 		if (proto == IPPROTO_TCP) continue;
	// 		buf[cnt].port = port;
	// 		buf[cnt].socktype = SOCK_DGRAM;
	// 		buf[cnt++].proto = IPPROTO_UDP;
	// 	}
	// 	if (!strncmp(z, "/tcp", 4)) {
	// 		if (proto == IPPROTO_UDP) continue;
	// 		buf[cnt].port = port;
	// 		buf[cnt].socktype = SOCK_STREAM;
	// 		buf[cnt++].proto = IPPROTO_TCP;
	// 	}
	// }
	// __fclose_ca(f);
	// return cnt > 0 ? cnt : EAI_SERVICE;
	Xabort(tls)
	return int32(0) //TODO-
}

func temper(tls *TLS, x uint32) uint32 { /* rand_r.c:3:17: */
	x = x ^ x>>11
	x = x ^ x<<7&0x9D2C5680
	x = x ^ x<<15&0xEFC60000
	x = x ^ x>>18
	return x
}

func Xrand_r(tls *TLS, seed uintptr) int32 { /* rand_r.c:12:5: */
	if __ccgo_strace {
		trc("tls=%v seed=%v, (%v:)", tls, seed, origin(2))
	}
	return int32(temper(tls, AssignPtrUint32(seed, *(*uint32)(unsafe.Pointer(seed))*uint32(1103515245)+uint32(12345))) / uint32(2))
}

func X__lockfile(tls *TLS, f uintptr) int32 { /* __lockfile.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	var owner int32 = (*FILE)(unsafe.Pointer(f)).lock
	var tid int32 = (*__pthread)(unsafe.Pointer(__pthread_self(tls))).tid
	if owner&CplInt32(0x40000000) == tid {
		return 0
	}
	owner = a_cas(tls, f+140, 0, tid)
	if !(owner != 0) {
		return 1
	}
	for AssignInt32(&owner, a_cas(tls, f+140, 0, tid|0x40000000)) != 0 {
		if owner&0x40000000 != 0 || a_cas(tls, f+140, owner, owner|0x40000000) == owner {
			__futexwait(tls, f+140, owner|0x40000000, 1)
		}
	}
	return 1
}

func X__unlockfile(tls *TLS, f uintptr) { /* __lockfile.c:19:6: */
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	if a_swap(tls, f+140, 0)&0x40000000 != 0 {
		__wake(tls, f+140, 1, 1)
	}
}

func X__toread(tls *TLS, f uintptr) int32 { /* __toread.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	*(*int32)(unsafe.Pointer(f + 136)) |= (*FILE)(unsafe.Pointer(f)).mode - 1
	if (*FILE)(unsafe.Pointer(f)).wpos != (*FILE)(unsafe.Pointer(f)).wbase {
		(*struct {
			f func(*TLS, uintptr, uintptr, size_t) size_t
		})(unsafe.Pointer(&struct{ uintptr }{(*FILE)(unsafe.Pointer(f)).write})).f(tls, f, uintptr(0), uint64(0))
	}
	(*FILE)(unsafe.Pointer(f)).wpos = AssignPtrUintptr(f+56, AssignPtrUintptr(f+32, uintptr(0)))
	if (*FILE)(unsafe.Pointer(f)).flags&uint32(4) != 0 {
		*(*uint32)(unsafe.Pointer(f)) |= uint32(32)
		return -1
	}
	(*FILE)(unsafe.Pointer(f)).rpos = AssignPtrUintptr(f+16, (*FILE)(unsafe.Pointer(f)).buf+uintptr((*FILE)(unsafe.Pointer(f)).buf_size))
	if (*FILE)(unsafe.Pointer(f)).flags&uint32(16) != 0 {
		return -1
	}
	return 0
}

func X__toread_needs_stdio_exit(tls *TLS) { /* __toread.c:16:13: */
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	X__builtin_abort(tls) //TODO-
	// __stdio_exit_needed();
}

// This function assumes it will never be called if there is already
// data buffered for reading.

func X__uflow(tls *TLS, f uintptr) int32 { /* __uflow.c:6:5: */
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	bp := tls.Alloc(1)
	defer tls.Free(1)

	// var c uint8 at bp, 1

	if !(X__toread(tls, f) != 0) && (*struct {
		f func(*TLS, uintptr, uintptr, size_t) size_t
	})(unsafe.Pointer(&struct{ uintptr }{(*FILE)(unsafe.Pointer(f)).read})).f(tls, f, bp, uint64(1)) == uint64(1) {
		return int32(*(*uint8)(unsafe.Pointer(bp)))
	}
	return -1
}

func Xsscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) int32 { /* sscanf.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v va=%v, (%v:)", tls, s, fmt, va, origin(2))
	}
	var ret int32
	var ap va_list
	_ = ap
	ap = va
	ret = Xvsscanf(tls, s, fmt, ap)
	_ = ap
	return ret
}

type wctrans_t = uintptr /* wctype.h:20:19 */

func store_int(tls *TLS, dest uintptr, size int32, i uint64) { /* vfscanf.c:22:13: */
	if !(dest != 0) {
		return
	}
	switch size {
	case -2:
		*(*uint8)(unsafe.Pointer(dest)) = uint8(i)
		break
	case -1:
		*(*int16)(unsafe.Pointer(dest)) = int16(i)
		break
	case 0:
		*(*int32)(unsafe.Pointer(dest)) = int32(i)
		break
	case 1:
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
		break
	case 3:
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
		break
	}
}

func arg_n(tls *TLS, ap va_list, n uint32) uintptr { /* vfscanf.c:44:13: */
	var p uintptr
	var i uint32
	var ap2 va_list
	_ = ap2
	ap2 = ap
	for i = n; i > uint32(1); i-- {
		VaUintptr(&ap2)
	}
	p = VaUintptr(&ap2)
	_ = ap2
	return p
}

func Xvfscanf(tls *TLS, f uintptr, fmt uintptr, ap va_list) int32 { /* vfscanf.c:56:5: */
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v ap=%v, (%v:)", tls, f, fmt, ap, origin(2))
	}
	bp := tls.Alloc(276)
	defer tls.Free(276)

	var width int32
	var size int32
	var alloc int32
	var base int32
	var p uintptr
	var c int32
	var t int32
	var s uintptr
	var wcs uintptr
	// var st mbstate_t at bp+268, 8

	var dest uintptr
	var invert int32
	var matches int32
	var x uint64
	var y float64
	var pos off_t
	// var scanset [257]uint8 at bp, 257

	var i size_t
	var k size_t
	// var wc wchar_t at bp+260, 4

	var __need_unlock int32
	var tmp uintptr
	var tmp1 uintptr
	alloc = 0
	dest = uintptr(0)
	matches = 0
	pos = int64(0)
	__need_unlock = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).lock >= 0 {
			return X__lockfile(tls, f)
		}
		return 0
	}()

	if !!(int32((*FILE)(unsafe.Pointer(f)).rpos) != 0) {
		goto __1
	}
	X__toread(tls, f)
__1:
	;
	if !!(int32((*FILE)(unsafe.Pointer(f)).rpos) != 0) {
		goto __2
	}
	goto input_fail
__2:
	;

	p = fmt
__3:
	if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
		goto __5
	}

	alloc = 0

	if !(__isspace(tls, int32(*(*uint8)(unsafe.Pointer(p)))) != 0) {
		goto __6
	}
__7:
	if !(__isspace(tls, int32(*(*uint8)(unsafe.Pointer(p + 1)))) != 0) {
		goto __8
	}
	p++
	goto __7
__8:
	;
	X__shlim(tls, f, int64(0))
__9:
	if !(__isspace(tls, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()) != 0) {
		goto __10
	}
	goto __9
__10:
	;
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	pos = pos + ((*FILE)(unsafe.Pointer(f)).shcnt + (int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1)
	goto __4
__6:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(p))) != '%' || int32(*(*uint8)(unsafe.Pointer(p + 1))) == '%') {
		goto __11
	}
	X__shlim(tls, f, int64(0))
	if !(int32(*(*uint8)(unsafe.Pointer(p))) == '%') {
		goto __12
	}
	p++
__14:
	if !(__isspace(tls, AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())) != 0) {
		goto __15
	}
	goto __14
__15:
	;
	goto __13
__12:
	c = func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()
__13:
	;
	if !(c != int32(*(*uint8)(unsafe.Pointer(p)))) {
		goto __16
	}
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if !(c < 0) {
		goto __17
	}
	goto input_fail
__17:
	;
	goto match_fail
__16:
	;
	pos = pos + ((*FILE)(unsafe.Pointer(f)).shcnt + (int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1)
	goto __4
__11:
	;

	p++
	if !(int32(*(*uint8)(unsafe.Pointer(p))) == '*') {
		goto __18
	}
	dest = uintptr(0)
	p++
	goto __19
__18:
	if !(func() int32 {
		if 0 != 0 {
			return Xisdigit(tls, int32(*(*uint8)(unsafe.Pointer(p))))
		}
		return Bool32(uint32(*(*uint8)(unsafe.Pointer(p)))-uint32('0') < uint32(10))
	}() != 0 && int32(*(*uint8)(unsafe.Pointer(p + 1))) == '$') {
		goto __20
	}
	dest = arg_n(tls, ap, uint32(int32(*(*uint8)(unsafe.Pointer(p)))-'0'))
	p += uintptr(2)
	goto __21
__20:
	dest = VaUintptr(&ap)
__21:
	;
__19:
	;

	width = 0
__22:
	if !(func() int32 {
		if 0 != 0 {
			return Xisdigit(tls, int32(*(*uint8)(unsafe.Pointer(p))))
		}
		return Bool32(uint32(*(*uint8)(unsafe.Pointer(p)))-uint32('0') < uint32(10))
	}() != 0) {
		goto __24
	}
	width = 10*width + int32(*(*uint8)(unsafe.Pointer(p))) - '0'
	goto __23
__23:
	p++
	goto __22
	goto __24
__24:
	;

	if !(int32(*(*uint8)(unsafe.Pointer(p))) == 'm') {
		goto __25
	}
	wcs = uintptr(0)
	s = uintptr(0)
	alloc = BoolInt32(!!(dest != 0))
	p++
	goto __26
__25:
	alloc = 0
__26:
	;

	size = 0
	switch int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&p, 1)))) {
	case 'h':
		goto __28
	case 'l':
		goto __29
	case 'j':
		goto __30
	case 'z':
		goto __31
	case 't':
		goto __32
	case 'L':
		goto __33
	case 'd':
		goto __34
	case 'i':
		goto __35
	case 'o':
		goto __36
	case 'u':
		goto __37
	case 'x':
		goto __38
	case 'a':
		goto __39
	case 'e':
		goto __40
	case 'f':
		goto __41
	case 'g':
		goto __42
	case 'A':
		goto __43
	case 'E':
		goto __44
	case 'F':
		goto __45
	case 'G':
		goto __46
	case 'X':
		goto __47
	case 's':
		goto __48
	case 'c':
		goto __49
	case '[':
		goto __50
	case 'S':
		goto __51
	case 'C':
		goto __52
	case 'p':
		goto __53
	case 'n':
		goto __54
	default:
		goto __55
	}
	goto __27
__28:
	if !(int32(*(*uint8)(unsafe.Pointer(p))) == 'h') {
		goto __56
	}
	p++
	size = -2
	goto __57
__56:
	size = -1
__57:
	;
	goto __27
__29:
	if !(int32(*(*uint8)(unsafe.Pointer(p))) == 'l') {
		goto __58
	}
	p++
	size = 3
	goto __59
__58:
	size = 1
__59:
	;
	goto __27
__30:
	size = 3
	goto __27
__31:
__32:
	size = 1
	goto __27
__33:
	size = 2
	goto __27
__34:
__35:
__36:
__37:
__38:
__39:
__40:
__41:
__42:
__43:
__44:
__45:
__46:
__47:
__48:
__49:
__50:
__51:
__52:
__53:
__54:
	p--
	goto __27
__55:
	goto fmt_fail
__27:
	;

	t = int32(*(*uint8)(unsafe.Pointer(p)))

	// C or S
	if !(t&0x2f == 3) {
		goto __60
	}
	t = t | 32
	size = 1
__60:
	;

	switch t {
	case 'c':
		goto __62
	case '[':
		goto __63
	case 'n':
		goto __64
	default:
		goto __65
	}
	goto __61
__62:
	if !(width < 1) {
		goto __66
	}
	width = 1
__66:
	;
__63:
	goto __61
__64:
	store_int(tls, dest, size, uint64(pos))
	// do not increment match count, etc!
	goto __4
__65:
	X__shlim(tls, f, int64(0))
__67:
	if !(__isspace(tls, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}()) != 0) {
		goto __68
	}
	goto __67
__68:
	;
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	pos = pos + ((*FILE)(unsafe.Pointer(f)).shcnt + (int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1)
__61:
	;

	X__shlim(tls, f, int64(width))
	if !(func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}() < 0) {
		goto __69
	}
	goto input_fail
__69:
	;
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}

	switch t {
	case 's':
		goto __71
	case 'c':
		goto __72
	case '[':
		goto __73
	case 'p':
		goto __74
	case 'X':
		goto __75
	case 'x':
		goto __76
	case 'o':
		goto __77
	case 'd':
		goto __78
	case 'u':
		goto __79
	case 'i':
		goto __80
	case 'a':
		goto __81
	case 'A':
		goto __82
	case 'e':
		goto __83
	case 'E':
		goto __84
	case 'f':
		goto __85
	case 'F':
		goto __86
	case 'g':
		goto __87
	case 'G':
		goto __88
	}
	goto __70
__71:
__72:
__73:
	if !(t == 'c' || t == 's') {
		goto __89
	}
	Xmemset(tls, bp, -1, uint64(unsafe.Sizeof([257]uint8{})))
	*(*uint8)(unsafe.Pointer(bp)) = uint8(0)
	if !(t == 's') {
		goto __91
	}
	*(*uint8)(unsafe.Pointer(bp + 10)) = uint8(0)
	*(*uint8)(unsafe.Pointer(bp + 11)) = uint8(0)
	*(*uint8)(unsafe.Pointer(bp + 12)) = uint8(0)
	*(*uint8)(unsafe.Pointer(bp + 13)) = uint8(0)
	*(*uint8)(unsafe.Pointer(bp + 14)) = uint8(0)
	*(*uint8)(unsafe.Pointer(bp + 33)) = uint8(0)
__91:
	;
	goto __90
__89:
	if !(int32(*(*uint8)(unsafe.Pointer(PreIncUintptr(&p, 1)))) == '^') {
		goto __92
	}
	p++
	invert = 1
	goto __93
__92:
	invert = 0
__93:
	;
	Xmemset(tls, bp, invert, uint64(unsafe.Sizeof([257]uint8{})))
	*(*uint8)(unsafe.Pointer(bp)) = uint8(0)
	if !(int32(*(*uint8)(unsafe.Pointer(p))) == '-') {
		goto __94
	}
	p++
	*(*uint8)(unsafe.Pointer(bp + 46)) = uint8(1 - invert)
	goto __95
__94:
	if !(int32(*(*uint8)(unsafe.Pointer(p))) == ']') {
		goto __96
	}
	p++
	*(*uint8)(unsafe.Pointer(bp + 94)) = uint8(1 - invert)
__96:
	;
__95:
	;
__97:
	if !(int32(*(*uint8)(unsafe.Pointer(p))) != ']') {
		goto __99
	}
	if !!(int32(*(*uint8)(unsafe.Pointer(p))) != 0) {
		goto __100
	}
	goto fmt_fail
__100:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(p))) == '-' && *(*uint8)(unsafe.Pointer(p + 1)) != 0 && int32(*(*uint8)(unsafe.Pointer(p + 1))) != ']') {
		goto __101
	}
	c = int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&p, 1) + UintptrFromInt32(-1))))
__102:
	if !(c < int32(*(*uint8)(unsafe.Pointer(p)))) {
		goto __104
	}
	*(*uint8)(unsafe.Pointer(bp + uintptr(1+c))) = uint8(1 - invert)
	goto __103
__103:
	c++
	goto __102
	goto __104
__104:
	;
__101:
	;
	*(*uint8)(unsafe.Pointer(bp + uintptr(1+int32(*(*uint8)(unsafe.Pointer(p)))))) = uint8(1 - invert)
	goto __98
__98:
	p++
	goto __97
	goto __99
__99:
	;
__90:
	;
	wcs = uintptr(0)
	s = uintptr(0)
	i = uint64(0)
	if t == 'c' {
		k = uint64(uint32(width) + 1)
	} else {
		k = uint64(31)
	}
	if !(size == 1) {
		goto __105
	}
	if !(alloc != 0) {
		goto __107
	}
	wcs = Xmalloc(tls, k*size_t(unsafe.Sizeof(wchar_t(0))))
	if !!(wcs != 0) {
		goto __109
	}
	goto alloc_fail
__109:
	;
	goto __108
__107:
	wcs = dest
__108:
	;
	*(*mbstate_t)(unsafe.Pointer(bp + 268 /* st */)) = mbstate_t{}
__110:
	if !(*(*uint8)(unsafe.Pointer(bp + uintptr(AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())+1))) != 0) {
		goto __111
	}
	switch Xmbrtowc(tls, bp+260, func() uintptr { *(*uint8)(unsafe.Pointer(bp + 264)) = uint8(c); return bp + 264 }(), uint64(1), bp+268 /* &st */) {
	case Uint64FromInt32(-1):
		goto __113
	case Uint64FromInt32(-2):
		goto __114
	}
	goto __112
__113:
	goto input_fail
__114:
	goto __110
__112:
	;
	if !(wcs != 0) {
		goto __115
	}
	*(*wchar_t)(unsafe.Pointer(wcs + uintptr(PostIncUint64(&i, 1))*4)) = *(*wchar_t)(unsafe.Pointer(bp + 260 /* wc */))
__115:
	;
	if !(alloc != 0 && i == k) {
		goto __116
	}
	k = k + (k + uint64(1))
	tmp = Xrealloc(tls, wcs, k*size_t(unsafe.Sizeof(wchar_t(0))))
	if !!(tmp != 0) {
		goto __117
	}
	goto alloc_fail
__117:
	;
	wcs = tmp
__116:
	;
	goto __110
__111:
	;
	if !!(Xmbsinit(tls, bp+268) != 0) {
		goto __118
	}
	goto input_fail
__118:
	;
	goto __106
__105:
	if !(alloc != 0) {
		goto __119
	}
	s = Xmalloc(tls, k)
	if !!(s != 0) {
		goto __121
	}
	goto alloc_fail
__121:
	;
__122:
	if !(*(*uint8)(unsafe.Pointer(bp + uintptr(AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())+1))) != 0) {
		goto __123
	}
	*(*uint8)(unsafe.Pointer(s + uintptr(PostIncUint64(&i, 1)))) = uint8(c)
	if !(i == k) {
		goto __124
	}
	k = k + (k + uint64(1))
	tmp1 = Xrealloc(tls, s, k)
	if !!(tmp1 != 0) {
		goto __125
	}
	goto alloc_fail
__125:
	;
	s = tmp1
__124:
	;
	goto __122
__123:
	;
	goto __120
__119:
	if !(AssignUintptr(&s, dest) != 0) {
		goto __126
	}
__128:
	if !(*(*uint8)(unsafe.Pointer(bp + uintptr(AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())+1))) != 0) {
		goto __129
	}
	*(*uint8)(unsafe.Pointer(s + uintptr(PostIncUint64(&i, 1)))) = uint8(c)
	goto __128
__129:
	;
	goto __127
__126:
__130:
	if !(*(*uint8)(unsafe.Pointer(bp + uintptr(AssignInt32(&c, func() int32 {
		if (*FILE)(unsafe.Pointer(f)).rpos != (*FILE)(unsafe.Pointer(f)).shend {
			return int32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&(*FILE)(unsafe.Pointer(f)).rpos, 1))))
		}
		return X__shgetc(tls, f)
	}())+1))) != 0) {
		goto __131
	}
	goto __130
__131:
	;
__127:
	;
__120:
	;
__106:
	;
	if (*FILE)(unsafe.Pointer(f)).shlim >= int64(0) {
		(*FILE)(unsafe.Pointer(f)).rpos--
	} else {
	}
	if !!((*FILE)(unsafe.Pointer(f)).shcnt+(int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1 != 0) {
		goto __132
	}
	goto match_fail
__132:
	;
	if !(t == 'c' && (*FILE)(unsafe.Pointer(f)).shcnt+(int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1 != off_t(width)) {
		goto __133
	}
	goto match_fail
__133:
	;
	if !(alloc != 0) {
		goto __134
	}
	if !(size == 1) {
		goto __135
	}
	*(*uintptr)(unsafe.Pointer(dest)) = wcs
	goto __136
__135:
	*(*uintptr)(unsafe.Pointer(dest)) = s
__136:
	;
__134:
	;
	if !(t != 'c') {
		goto __137
	}
	if !(wcs != 0) {
		goto __138
	}
	*(*wchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) = 0
__138:
	;
	if !(s != 0) {
		goto __139
	}
	*(*uint8)(unsafe.Pointer(s + uintptr(i))) = uint8(0)
__139:
	;
__137:
	;
	goto __70
__74:
__75:
__76:
	base = 16
	goto int_common
__77:
	base = 8
	goto int_common
__78:
__79:
	base = 10
	goto int_common
__80:
	base = 0
int_common:
	x = X__intscan(tls, f, uint32(base), 0, 2*uint64(0x7fffffffffffffff)+uint64(1))
	if !!((*FILE)(unsafe.Pointer(f)).shcnt+(int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1 != 0) {
		goto __140
	}
	goto match_fail
__140:
	;
	if !(t == 'p' && dest != 0) {
		goto __141
	}
	*(*uintptr)(unsafe.Pointer(dest)) = uintptr(uintptr_t(x))
	goto __142
__141:
	store_int(tls, dest, size, x)
__142:
	;
	goto __70
__81:
__82:
__83:
__84:
__85:
__86:
__87:
__88:
	y = X__floatscan(tls, f, size, 0)
	if !!((*FILE)(unsafe.Pointer(f)).shcnt+(int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1 != 0) {
		goto __143
	}
	goto match_fail
__143:
	;
	if !(dest != 0) {
		goto __144
	}
	switch size {
	case 0:
		goto __146
	case 1:
		goto __147
	case 2:
		goto __148
	}
	goto __145
__146:
	*(*float32)(unsafe.Pointer(dest)) = float32(y)
	goto __145
__147:
	*(*float64)(unsafe.Pointer(dest)) = y
	goto __145
__148:
	*(*float64)(unsafe.Pointer(dest)) = y
	goto __145
__145:
	;
__144:
	;
	goto __70
__70:
	;

	pos = pos + ((*FILE)(unsafe.Pointer(f)).shcnt + (int64((*FILE)(unsafe.Pointer(f)).rpos)-int64((*FILE)(unsafe.Pointer(f)).buf))/1)
	if !(dest != 0) {
		goto __149
	}
	matches++
__149:
	;
	goto __4
__4:
	p++
	goto __3
	goto __5
__5:
	;
	if !(0 != 0) {
		goto __150
	}
fmt_fail:
alloc_fail:
input_fail:
	if !!(matches != 0) {
		goto __151
	}
	matches--
__151:
	;
match_fail:
	if !(alloc != 0) {
		goto __152
	}
	Xfree(tls, s)
	Xfree(tls, wcs)
__152:
	;
__150:
	;
__153:
	if !(__need_unlock != 0) {
		goto __156
	}
	X__unlockfile(tls, f)
__156:
	;
	goto __154
__154:
	if 0 != 0 {
		goto __153
	}
	goto __155
__155:
	;
	return matches
}

func string_read(tls *TLS, f uintptr, buf uintptr, len size_t) size_t { /* vsscanf.c:4:15: */
	var src uintptr = (*FILE)(unsafe.Pointer(f)).cookie
	var k size_t = len + uint64(256)
	var end uintptr = Xmemchr(tls, src, 0, k)
	if end != 0 {
		k = size_t((int64(end) - int64(src)) / 1)
	}
	if k < len {
		len = k
	}
	Xmemcpy(tls, buf, src, len)
	(*FILE)(unsafe.Pointer(f)).rpos = src + uintptr(len)
	(*FILE)(unsafe.Pointer(f)).rend = src + uintptr(k)
	(*FILE)(unsafe.Pointer(f)).cookie = src + uintptr(k)
	return len
}

func Xvsscanf(tls *TLS, s uintptr, fmt uintptr, ap va_list) int32 { /* vsscanf.c:18:5: */
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v ap=%v, (%v:)", tls, s, fmt, ap, origin(2))
	}
	bp := tls.Alloc(232)
	defer tls.Free(232)

	*(*FILE)(unsafe.Pointer(bp /* f */)) = FILE{read: *(*uintptr)(unsafe.Pointer(&struct {
		f func(*TLS, uintptr, uintptr, size_t) size_t
	}{string_read})), buf: s, lock: -1, cookie: s}
	return Xvfscanf(tls, bp, fmt, ap)
}

func Xbsearch(tls *TLS, key uintptr, base uintptr, nel size_t, width size_t, cmp uintptr) uintptr { /* bsearch.c:3:6: */
	if __ccgo_strace {
		trc("tls=%v key=%v base=%v nel=%v width=%v cmp=%v, (%v:)", tls, key, base, nel, width, cmp, origin(2))
	}
	var try uintptr
	var sign int32
	for nel > uint64(0) {
		try = base + uintptr(width*(nel/uint64(2)))
		sign = (*struct {
			f func(*TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{cmp})).f(tls, key, try)
		if sign < 0 {
			nel = nel / uint64(2)
		} else if sign > 0 {
			base = try + uintptr(width)
			nel = nel - (nel/uint64(2) + uint64(1))
		} else {
			return try
		}
	}
	return uintptr(0)
}

func strtox(tls *TLS, s uintptr, p uintptr, prec int32) float64 { /* strtod.c:6:20: */
	bp := tls.Alloc(232)
	defer tls.Free(232)

	// var f FILE at bp, 232

	(*FILE)(unsafe.Pointer(bp)).buf = AssignPtrUintptr(bp+8, s)
	(*FILE)(unsafe.Pointer(bp)).rend = UintptrFromInt32(-1)
	X__shlim(tls, bp, int64(0))
	var y float64 = X__floatscan(tls, bp, prec, 1)
	var cnt off_t = (*FILE)(unsafe.Pointer(bp)).shcnt + (int64((*FILE)(unsafe.Pointer(bp)).rpos)-int64((*FILE)(unsafe.Pointer(bp)).buf))/1
	if p != 0 {
		*(*uintptr)(unsafe.Pointer(p)) = func() uintptr {
			if cnt != 0 {
				return s + uintptr(cnt)
			}
			return s
		}()
	}
	return y
}

func Xstrtof(tls *TLS, s uintptr, p uintptr) float32 { /* strtod.c:17:7: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
	}
	return float32(strtox(tls, s, p, 0))
}

func Xstrtod(tls *TLS, s uintptr, p uintptr) float64 { /* strtod.c:22:8: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
	}
	return strtox(tls, s, p, 1)
}

func Xstrtold(tls *TLS, s uintptr, p uintptr) float64 { /* strtod.c:27:13: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
	}
	return strtox(tls, s, p, 2)
}

func strtox1(tls *TLS, s uintptr, p uintptr, base int32, lim uint64) uint64 { /* strtol.c:8:27: */
	bp := tls.Alloc(232)
	defer tls.Free(232)

	// var f FILE at bp, 232

	(*FILE)(unsafe.Pointer(bp)).buf = AssignPtrUintptr(bp+8, s)
	(*FILE)(unsafe.Pointer(bp)).rend = UintptrFromInt32(-1)
	X__shlim(tls, bp, int64(0))
	var y uint64 = X__intscan(tls, bp, uint32(base), 1, lim)
	if p != 0 {
		var cnt size_t = size_t((*FILE)(unsafe.Pointer(bp)).shcnt + (int64((*FILE)(unsafe.Pointer(bp)).rpos)-int64((*FILE)(unsafe.Pointer(bp)).buf))/1)
		*(*uintptr)(unsafe.Pointer(p)) = s + uintptr(cnt)
	}
	return y
}

func Xstrtoull(tls *TLS, s uintptr, p uintptr, base int32) uint64 { /* strtol.c:21:20: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
	}
	return strtox1(tls, s, p, base, 2*uint64(0x7fffffffffffffff)+uint64(1))
}

func Xstrtoll(tls *TLS, s uintptr, p uintptr, base int32) int64 { /* strtol.c:26:11: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
	}
	return int64(strtox1(tls, s, p, base, Uint64FromInt64(-0x7fffffffffffffff-int64(1))))
}

func Xstrtoul(tls *TLS, s uintptr, p uintptr, base int32) uint64 { /* strtol.c:31:15: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
	}
	return uint64(strtox1(tls, s, p, base, 2*uint64(0x7fffffffffffffff)+uint64(1)))
}

func Xstrtol(tls *TLS, s uintptr, p uintptr, base int32) int64 { /* strtol.c:36:6: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
	}
	return int64(strtox1(tls, s, p, base, 0+Uint64FromInt64(Int64(-Int64(0x7fffffffffffffff))-Int64FromInt32(1))))
}

func Xstrtoimax(tls *TLS, s uintptr, p uintptr, base int32) intmax_t { /* strtol.c:41:10: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
	}
	return intmax_t(Xstrtoll(tls, s, p, base))
}

func Xstrtoumax(tls *TLS, s uintptr, p uintptr, base int32) uintmax_t { /* strtol.c:46:11: */
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
	}
	return uintmax_t(Xstrtoull(tls, s, p, base))
}

func Xstrdup(tls *TLS, s uintptr) uintptr { /* strdup.c:4:6: */
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
	}
	var l size_t = Xstrlen(tls, s)
	var d uintptr = Xmalloc(tls, l+uint64(1))
	if !(d != 0) {
		return uintptr(0)
	}
	return Xmemcpy(tls, d, s, l+uint64(1))
}

func Xstrlcat(tls *TLS, d uintptr, s uintptr, n size_t) size_t { /* strlcat.c:4:8: */
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
	}
	var l size_t = Xstrnlen(tls, d, n)
	if l == n {
		return l + Xstrlen(tls, s)
	}
	return l + Xstrlcpy(tls, d+uintptr(l), s, n-l)
}

// Support signed or unsigned plain-char

// Implementation choices...

// Arbitrary numbers...

// POSIX/SUS requirements follow. These numbers come directly
// from SUS and have nothing to do with the host system.

func Xstrlcpy(tls *TLS, d uintptr, s uintptr, n size_t) size_t { /* strlcpy.c:11:8: */
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
	}
	var d0 uintptr
	var wd uintptr
	var ws uintptr
	d0 = d

	if !!(int32(PostDecUint64(&n, 1)) != 0) {
		goto __1
	}
	goto finish
__1:
	;
	if !(uintptr_t(s)&(uint64(unsafe.Sizeof(size_t(0)))-uint64(1)) == uintptr_t(d)&(uint64(unsafe.Sizeof(size_t(0)))-uint64(1))) {
		goto __2
	}
__3:
	if !(uintptr_t(s)&(uint64(unsafe.Sizeof(size_t(0)))-uint64(1)) != 0 && n != 0 && AssignPtrUint8(d, *(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __5
	}
	goto __4
__4:
	n--
	s++
	d++
	goto __3
	goto __5
__5:
	;
	if !(n != 0 && *(*uint8)(unsafe.Pointer(s)) != 0) {
		goto __6
	}
	wd = d
	ws = s
__7:
	if !(n >= size_t(unsafe.Sizeof(size_t(0))) && !((*(*uint64)(unsafe.Pointer(ws))-Uint64(Uint64FromInt32(-1))/uint64(255)) & ^*(*uint64)(unsafe.Pointer(ws)) & (Uint64(Uint64FromInt32(-1))/uint64(255)*uint64(255/2+1)) != 0)) {
		goto __9
	}
	*(*size_t)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
	goto __8
__8:
	n = n - size_t(unsafe.Sizeof(size_t(0)))
	ws += 8
	wd += 8
	goto __7
	goto __9
__9:
	;
	d = wd
	s = ws
__6:
	;
__2:
	;
__10:
	if !(n != 0 && AssignPtrUint8(d, *(*uint8)(unsafe.Pointer(s))) != 0) {
		goto __12
	}
	goto __11
__11:
	n--
	s++
	d++
	goto __10
	goto __12
__12:
	;
	*(*uint8)(unsafe.Pointer(d)) = uint8(0)
finish:
	return size_t((int64(d)-int64(d0))/1) + Xstrlen(tls, s)
}

func Xstrncasecmp(tls *TLS, _l uintptr, _r uintptr, n size_t) int32 { /* strncasecmp.c:4:5: */
	if __ccgo_strace {
		trc("tls=%v _l=%v _r=%v n=%v, (%v:)", tls, _l, _r, n, origin(2))
	}
	var l uintptr = _l
	var r uintptr = _r
	if !(int32(PostDecUint64(&n, 1)) != 0) {
		return 0
	}
__1:
	if !(*(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && n != 0 && (int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) || Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) == Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(r)))))) {
		goto __3
	}
	goto __2
__2:
	l++
	r++
	n--
	goto __1
	goto __3
__3:
	;
	return Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) - Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))
}

func X__strncasecmp_l(tls *TLS, l uintptr, r uintptr, n size_t, loc locale_t) int32 { /* strncasecmp.c:12:5: */
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v n=%v loc=%v, (%v:)", tls, l, r, n, loc, origin(2))
	}
	return Xstrncasecmp(tls, l, r, n)
}

func Xstrncat(tls *TLS, d uintptr, s uintptr, n size_t) uintptr { /* strncat.c:3:6: */
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
	}
	var a uintptr = d
	d += uintptr(Xstrlen(tls, d))
	for n != 0 && *(*uint8)(unsafe.Pointer(s)) != 0 {
		n--
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&d, 1))) = *(*uint8)(unsafe.Pointer(PostIncUintptr(&s, 1)))
	}
	*(*uint8)(unsafe.Pointer(PostIncUintptr(&d, 1))) = uint8(0)
	return a
}

func Xstrnlen(tls *TLS, s uintptr, n size_t) size_t { /* strnlen.c:3:8: */
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v, (%v:)", tls, s, n, origin(2))
	}
	var p uintptr = Xmemchr(tls, s, 0, n)
	if p != 0 {
		return uint64((int64(p) - int64(s)) / 1)
	}
	return n
}

func Xstrspn(tls *TLS, s uintptr, c uintptr) size_t { /* strspn.c:6:8: */
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var a uintptr = s
	*(*[4]size_t)(unsafe.Pointer(bp /* byteset */)) = [4]size_t{0: uint64(0)}

	if !(int32(*(*uint8)(unsafe.Pointer(c))) != 0) {
		return uint64(0)
	}
	if !(int32(*(*uint8)(unsafe.Pointer(c + 1))) != 0) {
		for ; int32(*(*uint8)(unsafe.Pointer(s))) == int32(*(*uint8)(unsafe.Pointer(c))); s++ {
		}
		return size_t((int64(s) - int64(a)) / 1)
	}

	for ; *(*uint8)(unsafe.Pointer(c)) != 0 && AssignOrPtrUint64(bp+uintptr(size_t(*(*uint8)(unsafe.Pointer(c)))/(uint64(8)*uint64(unsafe.Sizeof(size_t(0)))))*8, size_t(uint64(1))<<(size_t(*(*uint8)(unsafe.Pointer(c)))%(uint64(8)*uint64(unsafe.Sizeof(size_t(0)))))) != 0; c++ {
	}
	for ; *(*uint8)(unsafe.Pointer(s)) != 0 && *(*size_t)(unsafe.Pointer(bp + uintptr(size_t(*(*uint8)(unsafe.Pointer(s)))/(uint64(8)*uint64(unsafe.Sizeof(size_t(0)))))*8))&(size_t(uint64(1))<<(size_t(*(*uint8)(unsafe.Pointer(s)))%(uint64(8)*uint64(unsafe.Sizeof(size_t(0)))))) != 0; s++ {
	}
	return size_t((int64(s) - int64(a)) / 1)
}

func Xstrtok(tls *TLS, s uintptr, sep uintptr) uintptr { /* strtok.c:3:6: */
	if __ccgo_strace {
		trc("tls=%v s=%v sep=%v, (%v:)", tls, s, sep, origin(2))
	}
	if !(s != 0) && !(int32(AssignUintptr(&s, _sp)) != 0) {
		return uintptr(0)
	}
	s += uintptr(Xstrspn(tls, s, sep))
	if !(int32(*(*uint8)(unsafe.Pointer(s))) != 0) {
		return AssignPtrUintptr(uintptr(unsafe.Pointer(&_sp)), uintptr(0))
	}
	_sp = s + uintptr(Xstrcspn(tls, s, sep))
	if *(*uint8)(unsafe.Pointer(_sp)) != 0 {
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&_sp, 1))) = uint8(0)
	} else {
		_sp = uintptr(0)
	}
	return s
}

var _sp uintptr /* strtok.c:5:14: */

func X__ccgo_pthreadAttrGetDetachState(tls *TLS, a uintptr) int32 { /* pthread_attr_get.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v a=%v, (%v:)", tls, a, origin(2))
	}
	return *(*int32)(unsafe.Pointer(a + 6*4))
}

func Xpthread_attr_getdetachstate(tls *TLS, a uintptr, state uintptr) int32 { /* pthread_attr_get.c:7:5: */
	if __ccgo_strace {
		trc("tls=%v a=%v state=%v, (%v:)", tls, a, state, origin(2))
	}
	*(*int32)(unsafe.Pointer(state)) = *(*int32)(unsafe.Pointer(a + 6*4))
	return 0
}

//
// int pthread_attr_getguardsize(const pthread_attr_t *restrict a, size_t *restrict size)
// {
// 	*size = a->_a_guardsize;
// 	return 0;
// }
//
// int pthread_attr_getinheritsched(const pthread_attr_t *restrict a, int *restrict inherit)
// {
// 	*inherit = a->_a_sched;
// 	return 0;
// }
//
// int pthread_attr_getschedparam(const pthread_attr_t *restrict a, struct sched_param *restrict param)
// {
// 	param->sched_priority = a->_a_prio;
// 	return 0;
// }
//
// int pthread_attr_getschedpolicy(const pthread_attr_t *restrict a, int *restrict policy)
// {
// 	*policy = a->_a_policy;
// 	return 0;
// }
//
// int pthread_attr_getscope(const pthread_attr_t *restrict a, int *restrict scope)
// {
// 	*scope = PTHREAD_SCOPE_SYSTEM;
// 	return 0;
// }
//
// int pthread_attr_getstack(const pthread_attr_t *restrict a, void **restrict addr, size_t *restrict size)
// {
// 	if (!a->_a_stackaddr)
// 		return EINVAL;
// 	*size = a->_a_stacksize;
// 	*addr = (void *)(a->_a_stackaddr - *size);
// 	return 0;
// }
//
// int pthread_attr_getstacksize(const pthread_attr_t *restrict a, size_t *restrict size)
// {
// 	*size = a->_a_stacksize;
// 	return 0;
// }
//
// int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict a, int *restrict pshared)
// {
// 	*pshared = !!a->__attr;
// 	return 0;
// }
//
// int pthread_condattr_getclock(const pthread_condattr_t *restrict a, clockid_t *restrict clk)
// {
// 	*clk = a->__attr & 0x7fffffff;
// 	return 0;
// }
//
// int pthread_condattr_getpshared(const pthread_condattr_t *restrict a, int *restrict pshared)
// {
// 	*pshared = a->__attr>>31;
// 	return 0;
// }
//
// int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict a, int *restrict protocol)
// {
// 	*protocol = PTHREAD_PRIO_NONE;
// 	return 0;
// }
// int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict a, int *restrict pshared)
// {
// 	*pshared = a->__attr / 128U % 2;
// 	return 0;
// }
//
// int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict a, int *restrict robust)
// {
// 	*robust = a->__attr / 4U % 2;
// 	return 0;
// }

func X__ccgo_pthreadMutexattrGettype(tls *TLS, a uintptr) int32 { /* pthread_attr_get.c:93:5: */
	if __ccgo_strace {
		trc("tls=%v a=%v, (%v:)", tls, a, origin(2))
	}
	return int32((*pthread_mutexattr_t)(unsafe.Pointer(a)).__attr & uint32(3))
}

// int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict a, int *restrict type)
// {
// 	*type = a->__attr & 3;
// 	return 0;
// }
//
// int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict a, int *restrict pshared)
// {
// 	*pshared = a->__attr[0];
// 	return 0;
// }

func Xpthread_attr_setdetachstate(tls *TLS, a uintptr, state int32) int32 { /* pthread_attr_setdetachstate.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v a=%v state=%v, (%v:)", tls, a, state, origin(2))
	}
	if uint32(state) > 1 {
		return 22
	}
	*(*int32)(unsafe.Pointer(a + 6*4)) = state
	return 0
}

func X__ccgo_getMutexType(tls *TLS, m uintptr) int32 { /* pthread_mutex_lock.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v m=%v, (%v:)", tls, m, origin(2))
	}
	return *(*int32)(unsafe.Pointer(m)) & 15
}

// int __pthread_mutex_lock(pthread_mutex_t *m)
// {
// 	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
// 	    && !a_cas(&m->_m_lock, 0, EBUSY))
// 		return 0;
//
// 	return __pthread_mutex_timedlock(m, 0);
// }
//
// weak_alias(__pthread_mutex_lock, pthread_mutex_lock);

func Xpthread_mutexattr_destroy(tls *TLS, a uintptr) int32 { /* pthread_mutexattr_destroy.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v a=%v, (%v:)", tls, a, origin(2))
	}
	return 0
}

func Xpthread_mutexattr_init(tls *TLS, a uintptr) int32 { /* pthread_mutexattr_init.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v a=%v, (%v:)", tls, a, origin(2))
	}
	*(*pthread_mutexattr_t)(unsafe.Pointer(a)) = pthread_mutexattr_t{}
	return 0
}

func Xpthread_mutexattr_settype(tls *TLS, a uintptr, type1 int32) int32 { /* pthread_mutexattr_settype.c:3:5: */
	if __ccgo_strace {
		trc("tls=%v a=%v type1=%v, (%v:)", tls, a, type1, origin(2))
	}
	if uint32(type1) > uint32(2) {
		return 22
	}
	(*pthread_mutexattr_t)(unsafe.Pointer(a)).__attr = (*pthread_mutexattr_t)(unsafe.Pointer(a)).__attr&Uint32FromInt32(CplInt32(3)) | uint32(type1)
	return 0
}

func init() {
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&ptable)) + 0)) = uintptr(unsafe.Pointer(&table)) + uintptr(128)*2 // __ctype_b_loc.c:36:45:
}

var ts1 = "infinity\x00nan\x00\x00\x00\x01\x02\x04\a\x03\x06\x05\x00.\x00%d.%d.%d.%d.in-addr.arpa\x00ip6.arpa\x000123456789abcdef\x00/etc/hosts\x00rb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x00%d.%d.%d.%d\x00%x:%x:%x:%x:%x:%x:%x:%x\x00%x:%x:%x:%x:%x:%x:%d.%d.%d.%d\x00:0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x00\x00\x00\x00 \x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
