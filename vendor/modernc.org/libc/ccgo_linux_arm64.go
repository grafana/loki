// Code generated for linux/arm64 by 'gcc --package-name=libc --prefix-enumerator=_ --prefix-external=x_ --prefix-field=F --prefix-static-internal=_ --prefix-static-none=_ --prefix-tagged-enum=_ --prefix-tagged-struct=T --prefix-tagged-union=T --prefix-typename=T --prefix-undefined=_ -emit-func-aliases -eval-all-macros -extended-errors -ignore-asm-errors -isystem  -std=c99 -nostdinc -ffreestanding -D_XOPEN_SOURCE=700 -I./arch/aarch64 -I./arch/generic -Iobj/src/internal -I./src/include -I./src/internal -Iobj/include -I./include -DNDEBUG -nostdlib -shared -o lib/libc.so.go obj/src/complex/__cexp.lo.go obj/src/complex/__cexpf.lo.go obj/src/complex/cabs.lo.go obj/src/complex/cabsf.lo.go obj/src/complex/cabsl.lo.go obj/src/complex/cacos.lo.go obj/src/complex/cacosf.lo.go obj/src/complex/cacosh.lo.go obj/src/complex/cacoshf.lo.go obj/src/complex/cacoshl.lo.go obj/src/complex/cacosl.lo.go obj/src/complex/carg.lo.go obj/src/complex/cargf.lo.go obj/src/complex/cargl.lo.go obj/src/complex/casin.lo.go obj/src/complex/casinf.lo.go obj/src/complex/casinh.lo.go obj/src/complex/casinhf.lo.go obj/src/complex/casinhl.lo.go obj/src/complex/casinl.lo.go obj/src/complex/catan.lo.go obj/src/complex/catanf.lo.go obj/src/complex/catanh.lo.go obj/src/complex/catanhf.lo.go obj/src/complex/catanhl.lo.go obj/src/complex/catanl.lo.go obj/src/complex/ccos.lo.go obj/src/complex/ccosf.lo.go obj/src/complex/ccosh.lo.go obj/src/complex/ccoshf.lo.go obj/src/complex/ccoshl.lo.go obj/src/complex/ccosl.lo.go obj/src/complex/cexp.lo.go obj/src/complex/cexpf.lo.go obj/src/complex/cexpl.lo.go obj/src/complex/cimag.lo.go obj/src/complex/cimagf.lo.go obj/src/complex/cimagl.lo.go obj/src/complex/clog.lo.go obj/src/complex/clogf.lo.go obj/src/complex/clogl.lo.go obj/src/complex/conj.lo.go obj/src/complex/conjf.lo.go obj/src/complex/conjl.lo.go obj/src/complex/cpow.lo.go obj/src/complex/cpowf.lo.go obj/src/complex/cpowl.lo.go obj/src/complex/cproj.lo.go obj/src/complex/cprojf.lo.go obj/src/complex/cprojl.lo.go obj/src/complex/creal.lo.go obj/src/complex/crealf.lo.go obj/src/complex/creall.lo.go obj/src/complex/csin.lo.go obj/src/complex/csinf.lo.go obj/src/complex/csinh.lo.go obj/src/complex/csinhf.lo.go obj/src/complex/csinhl.lo.go obj/src/complex/csinl.lo.go obj/src/complex/csqrt.lo.go obj/src/complex/csqrtf.lo.go obj/src/complex/csqrtl.lo.go obj/src/complex/ctan.lo.go obj/src/complex/ctanf.lo.go obj/src/complex/ctanh.lo.go obj/src/complex/ctanhf.lo.go obj/src/complex/ctanhl.lo.go obj/src/complex/ctanl.lo.go obj/src/conf/confstr.lo.go obj/src/conf/fpathconf.lo.go obj/src/conf/legacy.lo.go obj/src/conf/pathconf.lo.go obj/src/conf/sysconf.lo.go obj/src/crypt/crypt.lo.go obj/src/crypt/crypt_blowfish.lo.go obj/src/crypt/crypt_des.lo.go obj/src/crypt/crypt_md5.lo.go obj/src/crypt/crypt_r.lo.go obj/src/crypt/crypt_sha256.lo.go obj/src/crypt/crypt_sha512.lo.go obj/src/crypt/encrypt.lo.go obj/src/ctype/__ctype_b_loc.lo.go obj/src/ctype/__ctype_get_mb_cur_max.lo.go obj/src/ctype/__ctype_tolower_loc.lo.go obj/src/ctype/__ctype_toupper_loc.lo.go obj/src/ctype/isalnum.lo.go obj/src/ctype/isalpha.lo.go obj/src/ctype/isascii.lo.go obj/src/ctype/isblank.lo.go obj/src/ctype/iscntrl.lo.go obj/src/ctype/isdigit.lo.go obj/src/ctype/isgraph.lo.go obj/src/ctype/islower.lo.go obj/src/ctype/isprint.lo.go obj/src/ctype/ispunct.lo.go obj/src/ctype/isspace.lo.go obj/src/ctype/isupper.lo.go obj/src/ctype/iswalnum.lo.go obj/src/ctype/iswalpha.lo.go obj/src/ctype/iswblank.lo.go obj/src/ctype/iswcntrl.lo.go obj/src/ctype/iswctype.lo.go obj/src/ctype/iswdigit.lo.go obj/src/ctype/iswgraph.lo.go obj/src/ctype/iswlower.lo.go obj/src/ctype/iswprint.lo.go obj/src/ctype/iswpunct.lo.go obj/src/ctype/iswspace.lo.go obj/src/ctype/iswupper.lo.go obj/src/ctype/iswxdigit.lo.go obj/src/ctype/isxdigit.lo.go obj/src/ctype/toascii.lo.go obj/src/ctype/tolower.lo.go obj/src/ctype/toupper.lo.go obj/src/ctype/towctrans.lo.go obj/src/ctype/wcswidth.lo.go obj/src/ctype/wctrans.lo.go obj/src/ctype/wcwidth.lo.go obj/src/dirent/alphasort.lo.go obj/src/dirent/closedir.lo.go obj/src/dirent/dirfd.lo.go obj/src/dirent/fdopendir.lo.go obj/src/dirent/opendir.lo.go obj/src/dirent/readdir.lo.go obj/src/dirent/readdir_r.lo.go obj/src/dirent/rewinddir.lo.go obj/src/dirent/scandir.lo.go obj/src/dirent/seekdir.lo.go obj/src/dirent/telldir.lo.go obj/src/dirent/versionsort.lo.go obj/src/env/__environ.lo.go obj/src/env/__reset_tls.lo.go obj/src/env/__stack_chk_fail.lo.go obj/src/env/clearenv.lo.go obj/src/env/getenv.lo.go obj/src/env/putenv.lo.go obj/src/env/secure_getenv.lo.go obj/src/env/setenv.lo.go obj/src/env/unsetenv.lo.go obj/src/errno/strerror.lo.go obj/src/exit/_Exit.lo.go obj/src/exit/abort_lock.lo.go obj/src/exit/assert.lo.go obj/src/exit/at_quick_exit.lo.go obj/src/exit/quick_exit.lo.go obj/src/fcntl/creat.lo.go obj/src/fcntl/fcntl.lo.go obj/src/fcntl/open.lo.go obj/src/fcntl/openat.lo.go obj/src/fcntl/posix_fadvise.lo.go obj/src/fcntl/posix_fallocate.lo.go obj/src/fenv/fenv.lo.go obj/src/internal/defsysinfo.lo.go obj/src/internal/emulate_wait4.lo.go obj/src/internal/floatscan.lo.go obj/src/internal/intscan.lo.go obj/src/internal/libc.lo.go obj/src/internal/procfdname.lo.go obj/src/internal/shgetc.lo.go obj/src/internal/syscall_ret.lo.go obj/src/internal/vdso.lo.go obj/src/internal/version.lo.go obj/src/ipc/ftok.lo.go obj/src/ipc/msgctl.lo.go obj/src/ipc/msgget.lo.go obj/src/ipc/msgrcv.lo.go obj/src/ipc/msgsnd.lo.go obj/src/ipc/semctl.lo.go obj/src/ipc/semget.lo.go obj/src/ipc/semop.lo.go obj/src/ipc/semtimedop.lo.go obj/src/ipc/shmat.lo.go obj/src/ipc/shmctl.lo.go obj/src/ipc/shmdt.lo.go obj/src/ipc/shmget.lo.go obj/src/legacy/cuserid.lo.go obj/src/legacy/err.lo.go obj/src/legacy/euidaccess.lo.go obj/src/legacy/ftw.lo.go obj/src/legacy/futimes.lo.go obj/src/legacy/getdtablesize.lo.go obj/src/legacy/getloadavg.lo.go obj/src/legacy/getpagesize.lo.go obj/src/legacy/getpass.lo.go obj/src/legacy/getusershell.lo.go obj/src/legacy/isastream.lo.go obj/src/legacy/lutimes.lo.go obj/src/legacy/ulimit.lo.go obj/src/legacy/utmpx.lo.go obj/src/linux/adjtime.lo.go obj/src/linux/adjtimex.lo.go obj/src/linux/arch_prctl.lo.go obj/src/linux/brk.lo.go obj/src/linux/cache.lo.go obj/src/linux/cap.lo.go obj/src/linux/chroot.lo.go obj/src/linux/clock_adjtime.lo.go obj/src/linux/copy_file_range.lo.go obj/src/linux/epoll.lo.go obj/src/linux/eventfd.lo.go obj/src/linux/fallocate.lo.go obj/src/linux/fanotify.lo.go obj/src/linux/flock.lo.go obj/src/linux/getdents.lo.go obj/src/linux/getrandom.lo.go obj/src/linux/inotify.lo.go obj/src/linux/ioperm.lo.go obj/src/linux/iopl.lo.go obj/src/linux/klogctl.lo.go obj/src/linux/memfd_create.lo.go obj/src/linux/mlock2.lo.go obj/src/linux/module.lo.go obj/src/linux/mount.lo.go obj/src/linux/name_to_handle_at.lo.go obj/src/linux/open_by_handle_at.lo.go obj/src/linux/personality.lo.go obj/src/linux/pivot_root.lo.go obj/src/linux/prctl.lo.go obj/src/linux/preadv2.lo.go obj/src/linux/prlimit.lo.go obj/src/linux/process_vm.lo.go obj/src/linux/ptrace.lo.go obj/src/linux/pwritev2.lo.go obj/src/linux/quotactl.lo.go obj/src/linux/readahead.lo.go obj/src/linux/reboot.lo.go obj/src/linux/remap_file_pages.lo.go obj/src/linux/sbrk.lo.go obj/src/linux/sendfile.lo.go obj/src/linux/setfsgid.lo.go obj/src/linux/setfsuid.lo.go obj/src/linux/sethostname.lo.go obj/src/linux/setns.lo.go obj/src/linux/settimeofday.lo.go obj/src/linux/signalfd.lo.go obj/src/linux/splice.lo.go obj/src/linux/statx.lo.go obj/src/linux/stime.lo.go obj/src/linux/swap.lo.go obj/src/linux/sync_file_range.lo.go obj/src/linux/syncfs.lo.go obj/src/linux/sysinfo.lo.go obj/src/linux/tee.lo.go obj/src/linux/timerfd.lo.go obj/src/linux/unshare.lo.go obj/src/linux/utimes.lo.go obj/src/linux/vhangup.lo.go obj/src/linux/vmsplice.lo.go obj/src/linux/wait3.lo.go obj/src/linux/wait4.lo.go obj/src/linux/xattr.lo.go obj/src/locale/__lctrans.lo.go obj/src/locale/__mo_lookup.lo.go obj/src/locale/bind_textdomain_codeset.lo.go obj/src/locale/c_locale.lo.go obj/src/locale/catclose.lo.go obj/src/locale/catgets.lo.go obj/src/locale/catopen.lo.go obj/src/locale/dcngettext.lo.go obj/src/locale/duplocale.lo.go obj/src/locale/freelocale.lo.go obj/src/locale/iconv.lo.go obj/src/locale/iconv_close.lo.go obj/src/locale/langinfo.lo.go obj/src/locale/locale_map.lo.go obj/src/locale/localeconv.lo.go obj/src/locale/newlocale.lo.go obj/src/locale/pleval.lo.go obj/src/locale/setlocale.lo.go obj/src/locale/strcoll.lo.go obj/src/locale/strfmon.lo.go obj/src/locale/strtod_l.lo.go obj/src/locale/strxfrm.lo.go obj/src/locale/textdomain.lo.go obj/src/locale/uselocale.lo.go obj/src/locale/wcscoll.lo.go obj/src/locale/wcsxfrm.lo.go obj/src/malloc/reallocarray.lo.go obj/src/math/__cos.lo.go obj/src/math/__cosdf.lo.go obj/src/math/__cosl.lo.go obj/src/math/__expo2.lo.go obj/src/math/__expo2f.lo.go obj/src/math/__fpclassify.lo.go obj/src/math/__fpclassifyf.lo.go obj/src/math/__fpclassifyl.lo.go obj/src/math/__invtrigl.lo.go obj/src/math/__math_divzero.lo.go obj/src/math/__math_divzerof.lo.go obj/src/math/__math_invalid.lo.go obj/src/math/__math_invalidf.lo.go obj/src/math/__math_invalidl.lo.go obj/src/math/__math_oflow.lo.go obj/src/math/__math_oflowf.lo.go obj/src/math/__math_uflow.lo.go obj/src/math/__math_uflowf.lo.go obj/src/math/__math_xflow.lo.go obj/src/math/__math_xflowf.lo.go obj/src/math/__polevll.lo.go obj/src/math/__rem_pio2.lo.go obj/src/math/__rem_pio2_large.lo.go obj/src/math/__rem_pio2f.lo.go obj/src/math/__rem_pio2l.lo.go obj/src/math/__signbit.lo.go obj/src/math/__signbitf.lo.go obj/src/math/__signbitl.lo.go obj/src/math/__sin.lo.go obj/src/math/__sindf.lo.go obj/src/math/__sinl.lo.go obj/src/math/__tan.lo.go obj/src/math/__tandf.lo.go obj/src/math/__tanl.lo.go obj/src/math/acos.lo.go obj/src/math/acosf.lo.go obj/src/math/acosh.lo.go obj/src/math/acoshf.lo.go obj/src/math/acoshl.lo.go obj/src/math/acosl.lo.go obj/src/math/asin.lo.go obj/src/math/asinf.lo.go obj/src/math/asinh.lo.go obj/src/math/asinhf.lo.go obj/src/math/asinhl.lo.go obj/src/math/asinl.lo.go obj/src/math/atan.lo.go obj/src/math/atan2.lo.go obj/src/math/atan2f.lo.go obj/src/math/atan2l.lo.go obj/src/math/atanf.lo.go obj/src/math/atanh.lo.go obj/src/math/atanhf.lo.go obj/src/math/atanhl.lo.go obj/src/math/atanl.lo.go obj/src/math/cbrt.lo.go obj/src/math/cbrtf.lo.go obj/src/math/cbrtl.lo.go obj/src/math/ceil.lo.go obj/src/math/ceilf.lo.go obj/src/math/ceill.lo.go obj/src/math/copysign.lo.go obj/src/math/copysignf.lo.go obj/src/math/copysignl.lo.go obj/src/math/cos.lo.go obj/src/math/cosf.lo.go obj/src/math/cosh.lo.go obj/src/math/coshf.lo.go obj/src/math/coshl.lo.go obj/src/math/cosl.lo.go obj/src/math/erf.lo.go obj/src/math/erff.lo.go obj/src/math/erfl.lo.go obj/src/math/exp.lo.go obj/src/math/exp10.lo.go obj/src/math/exp10f.lo.go obj/src/math/exp10l.lo.go obj/src/math/exp2.lo.go obj/src/math/exp2f.lo.go obj/src/math/exp2f_data.lo.go obj/src/math/exp2l.lo.go obj/src/math/exp_data.lo.go obj/src/math/expf.lo.go obj/src/math/expl.lo.go obj/src/math/expm1.lo.go obj/src/math/expm1f.lo.go obj/src/math/expm1l.lo.go obj/src/math/fabs.lo.go obj/src/math/fabsf.lo.go obj/src/math/fabsl.lo.go obj/src/math/fdim.lo.go obj/src/math/fdimf.lo.go obj/src/math/fdiml.lo.go obj/src/math/finite.lo.go obj/src/math/finitef.lo.go obj/src/math/floor.lo.go obj/src/math/floorf.lo.go obj/src/math/floorl.lo.go obj/src/math/fma.lo.go obj/src/math/fmal.lo.go obj/src/math/fmax.lo.go obj/src/math/fmaxf.lo.go obj/src/math/fmaxl.lo.go obj/src/math/fmin.lo.go obj/src/math/fminf.lo.go obj/src/math/fminl.lo.go obj/src/math/fmod.lo.go obj/src/math/fmodf.lo.go obj/src/math/fmodl.lo.go obj/src/math/frexp.lo.go obj/src/math/frexpf.lo.go obj/src/math/frexpl.lo.go obj/src/math/hypot.lo.go obj/src/math/hypotf.lo.go obj/src/math/hypotl.lo.go obj/src/math/ilogb.lo.go obj/src/math/ilogbf.lo.go obj/src/math/ilogbl.lo.go obj/src/math/j0.lo.go obj/src/math/j0f.lo.go obj/src/math/j1.lo.go obj/src/math/j1f.lo.go obj/src/math/jn.lo.go obj/src/math/jnf.lo.go obj/src/math/ldexp.lo.go obj/src/math/ldexpf.lo.go obj/src/math/ldexpl.lo.go obj/src/math/lgamma.lo.go obj/src/math/lgamma_r.lo.go obj/src/math/lgammaf.lo.go obj/src/math/lgammaf_r.lo.go obj/src/math/lgammal.lo.go obj/src/math/llrint.lo.go obj/src/math/llrintf.lo.go obj/src/math/llrintl.lo.go obj/src/math/llround.lo.go obj/src/math/llroundf.lo.go obj/src/math/llroundl.lo.go obj/src/math/log.lo.go obj/src/math/log10.lo.go obj/src/math/log10f.lo.go obj/src/math/log10l.lo.go obj/src/math/log1p.lo.go obj/src/math/log1pf.lo.go obj/src/math/log1pl.lo.go obj/src/math/log2.lo.go obj/src/math/log2_data.lo.go obj/src/math/log2f.lo.go obj/src/math/log2f_data.lo.go obj/src/math/log2l.lo.go obj/src/math/log_data.lo.go obj/src/math/logb.lo.go obj/src/math/logbf.lo.go obj/src/math/logbl.lo.go obj/src/math/logf.lo.go obj/src/math/logf_data.lo.go obj/src/math/logl.lo.go obj/src/math/lrint.lo.go obj/src/math/lrintf.lo.go obj/src/math/lrintl.lo.go obj/src/math/lround.lo.go obj/src/math/lroundf.lo.go obj/src/math/lroundl.lo.go obj/src/math/modf.lo.go obj/src/math/modff.lo.go obj/src/math/modfl.lo.go obj/src/math/nan.lo.go obj/src/math/nanf.lo.go obj/src/math/nanl.lo.go obj/src/math/nextafter.lo.go obj/src/math/nextafterf.lo.go obj/src/math/nextafterl.lo.go obj/src/math/nexttoward.lo.go obj/src/math/nexttowardf.lo.go obj/src/math/nexttowardl.lo.go obj/src/math/pow.lo.go obj/src/math/pow_data.lo.go obj/src/math/powf.lo.go obj/src/math/powf_data.lo.go obj/src/math/powl.lo.go obj/src/math/remainder.lo.go obj/src/math/remainderf.lo.go obj/src/math/remainderl.lo.go obj/src/math/remquo.lo.go obj/src/math/remquof.lo.go obj/src/math/remquol.lo.go obj/src/math/rint.lo.go obj/src/math/rintf.lo.go obj/src/math/rintl.lo.go obj/src/math/round.lo.go obj/src/math/roundf.lo.go obj/src/math/roundl.lo.go obj/src/math/scalb.lo.go obj/src/math/scalbf.lo.go obj/src/math/scalbln.lo.go obj/src/math/scalblnf.lo.go obj/src/math/scalblnl.lo.go obj/src/math/scalbn.lo.go obj/src/math/scalbnf.lo.go obj/src/math/scalbnl.lo.go obj/src/math/signgam.lo.go obj/src/math/significand.lo.go obj/src/math/significandf.lo.go obj/src/math/sin.lo.go obj/src/math/sincos.lo.go obj/src/math/sincosf.lo.go obj/src/math/sincosl.lo.go obj/src/math/sinf.lo.go obj/src/math/sinh.lo.go obj/src/math/sinhf.lo.go obj/src/math/sinhl.lo.go obj/src/math/sinl.lo.go obj/src/math/sqrt.lo.go obj/src/math/sqrt_data.lo.go obj/src/math/sqrtf.lo.go obj/src/math/sqrtl.lo.go obj/src/math/tan.lo.go obj/src/math/tanf.lo.go obj/src/math/tanh.lo.go obj/src/math/tanhf.lo.go obj/src/math/tanhl.lo.go obj/src/math/tanl.lo.go obj/src/math/tgamma.lo.go obj/src/math/tgammaf.lo.go obj/src/math/tgammal.lo.go obj/src/math/trunc.lo.go obj/src/math/truncf.lo.go obj/src/math/truncl.lo.go obj/src/misc/a64l.lo.go obj/src/misc/basename.lo.go obj/src/misc/dirname.lo.go obj/src/misc/ffs.lo.go obj/src/misc/ffsl.lo.go obj/src/misc/ffsll.lo.go obj/src/misc/fmtmsg.lo.go obj/src/misc/get_current_dir_name.lo.go obj/src/misc/getauxval.lo.go obj/src/misc/getdomainname.lo.go obj/src/misc/getentropy.lo.go obj/src/misc/gethostid.lo.go obj/src/misc/getopt.lo.go obj/src/misc/getopt_long.lo.go obj/src/misc/getpriority.lo.go obj/src/misc/getresgid.lo.go obj/src/misc/getresuid.lo.go obj/src/misc/getrlimit.lo.go obj/src/misc/getrusage.lo.go obj/src/misc/getsubopt.lo.go obj/src/misc/ioctl.lo.go obj/src/misc/issetugid.lo.go obj/src/misc/lockf.lo.go obj/src/misc/login_tty.lo.go obj/src/misc/mntent.lo.go obj/src/misc/nftw.lo.go obj/src/misc/openpty.lo.go obj/src/misc/ptsname.lo.go obj/src/misc/pty.lo.go obj/src/misc/realpath.lo.go obj/src/misc/setdomainname.lo.go obj/src/misc/setpriority.lo.go obj/src/misc/setrlimit.lo.go obj/src/misc/syscall.lo.go obj/src/misc/syslog.lo.go obj/src/misc/uname.lo.go obj/src/mman/madvise.lo.go obj/src/mman/mincore.lo.go obj/src/mman/mlock.lo.go obj/src/mman/mlockall.lo.go obj/src/mman/mmap.lo.go obj/src/mman/mprotect.lo.go obj/src/mman/mremap.lo.go obj/src/mman/msync.lo.go obj/src/mman/munlock.lo.go obj/src/mman/munlockall.lo.go obj/src/mman/munmap.lo.go obj/src/mman/posix_madvise.lo.go obj/src/mman/shm_open.lo.go obj/src/multibyte/btowc.lo.go obj/src/multibyte/c16rtomb.lo.go obj/src/multibyte/c32rtomb.lo.go obj/src/multibyte/internal.lo.go obj/src/multibyte/mblen.lo.go obj/src/multibyte/mbrlen.lo.go obj/src/multibyte/mbrtoc16.lo.go obj/src/multibyte/mbrtoc32.lo.go obj/src/multibyte/mbrtowc.lo.go obj/src/multibyte/mbsinit.lo.go obj/src/multibyte/mbsnrtowcs.lo.go obj/src/multibyte/mbsrtowcs.lo.go obj/src/multibyte/mbstowcs.lo.go obj/src/multibyte/mbtowc.lo.go obj/src/multibyte/wcrtomb.lo.go obj/src/multibyte/wcsnrtombs.lo.go obj/src/multibyte/wcsrtombs.lo.go obj/src/multibyte/wcstombs.lo.go obj/src/multibyte/wctob.lo.go obj/src/multibyte/wctomb.lo.go obj/src/network/accept.lo.go obj/src/network/accept4.lo.go obj/src/network/bind.lo.go obj/src/network/connect.lo.go obj/src/network/dn_comp.lo.go obj/src/network/dn_expand.lo.go obj/src/network/dn_skipname.lo.go obj/src/network/dns_parse.lo.go obj/src/network/ent.lo.go obj/src/network/ether.lo.go obj/src/network/freeaddrinfo.lo.go obj/src/network/gai_strerror.lo.go obj/src/network/getaddrinfo.lo.go obj/src/network/gethostbyaddr.lo.go obj/src/network/gethostbyaddr_r.lo.go obj/src/network/gethostbyname.lo.go obj/src/network/gethostbyname2.lo.go obj/src/network/gethostbyname2_r.lo.go obj/src/network/gethostbyname_r.lo.go obj/src/network/getifaddrs.lo.go obj/src/network/getnameinfo.lo.go obj/src/network/getpeername.lo.go obj/src/network/getservbyname.lo.go obj/src/network/getservbyname_r.lo.go obj/src/network/getsockname.lo.go obj/src/network/getsockopt.lo.go obj/src/network/h_errno.lo.go obj/src/network/herror.lo.go obj/src/network/hstrerror.lo.go obj/src/network/htonl.lo.go obj/src/network/htons.lo.go obj/src/network/if_freenameindex.lo.go obj/src/network/if_indextoname.lo.go obj/src/network/if_nameindex.lo.go obj/src/network/if_nametoindex.lo.go obj/src/network/in6addr_any.lo.go obj/src/network/in6addr_loopback.lo.go obj/src/network/inet_addr.lo.go obj/src/network/inet_aton.lo.go obj/src/network/inet_legacy.lo.go obj/src/network/inet_ntoa.lo.go obj/src/network/inet_ntop.lo.go obj/src/network/inet_pton.lo.go obj/src/network/listen.lo.go obj/src/network/lookup_ipliteral.lo.go obj/src/network/lookup_name.lo.go obj/src/network/lookup_serv.lo.go obj/src/network/netlink.lo.go obj/src/network/netname.lo.go obj/src/network/ns_parse.lo.go obj/src/network/ntohl.lo.go obj/src/network/ntohs.lo.go obj/src/network/proto.lo.go obj/src/network/recv.lo.go obj/src/network/recvfrom.lo.go obj/src/network/recvmmsg.lo.go obj/src/network/recvmsg.lo.go obj/src/network/res_init.lo.go obj/src/network/res_mkquery.lo.go obj/src/network/res_msend.lo.go obj/src/network/res_send.lo.go obj/src/network/res_state.lo.go obj/src/network/resolvconf.lo.go obj/src/network/send.lo.go obj/src/network/sendmmsg.lo.go obj/src/network/sendmsg.lo.go obj/src/network/sendto.lo.go obj/src/network/serv.lo.go obj/src/network/setsockopt.lo.go obj/src/network/shutdown.lo.go obj/src/network/sockatmark.lo.go obj/src/network/socket.lo.go obj/src/network/socketpair.lo.go obj/src/passwd/fgetgrent.lo.go obj/src/passwd/fgetpwent.lo.go obj/src/passwd/getgr_a.lo.go obj/src/passwd/getgr_r.lo.go obj/src/passwd/getgrent.lo.go obj/src/passwd/getgrent_a.lo.go obj/src/passwd/getgrouplist.lo.go obj/src/passwd/getpw_a.lo.go obj/src/passwd/getpw_r.lo.go obj/src/passwd/getpwent.lo.go obj/src/passwd/getpwent_a.lo.go obj/src/passwd/getspent.lo.go obj/src/passwd/lckpwdf.lo.go obj/src/passwd/nscd_query.lo.go obj/src/passwd/putgrent.lo.go obj/src/passwd/putpwent.lo.go obj/src/passwd/putspent.lo.go obj/src/prng/__rand48_step.lo.go obj/src/prng/__seed48.lo.go obj/src/prng/drand48.lo.go obj/src/prng/lcong48.lo.go obj/src/prng/lrand48.lo.go obj/src/prng/mrand48.lo.go obj/src/prng/rand.lo.go obj/src/prng/rand_r.lo.go obj/src/prng/random.lo.go obj/src/prng/seed48.lo.go obj/src/prng/srand48.lo.go obj/src/process/execl.lo.go obj/src/process/execle.lo.go obj/src/process/execlp.lo.go obj/src/process/execv.lo.go obj/src/process/execve.lo.go obj/src/process/execvp.lo.go obj/src/process/fexecve.lo.go obj/src/process/fork.lo.go obj/src/process/posix_spawn_file_actions_addchdir.lo.go obj/src/process/posix_spawn_file_actions_addclose.lo.go obj/src/process/posix_spawn_file_actions_adddup2.lo.go obj/src/process/posix_spawn_file_actions_addfchdir.lo.go obj/src/process/posix_spawn_file_actions_addopen.lo.go obj/src/process/posix_spawn_file_actions_destroy.lo.go obj/src/process/posix_spawn_file_actions_init.lo.go obj/src/process/posix_spawnattr_destroy.lo.go obj/src/process/posix_spawnattr_getflags.lo.go obj/src/process/posix_spawnattr_getpgroup.lo.go obj/src/process/posix_spawnattr_getsigdefault.lo.go obj/src/process/posix_spawnattr_getsigmask.lo.go obj/src/process/posix_spawnattr_init.lo.go obj/src/process/posix_spawnattr_sched.lo.go obj/src/process/posix_spawnattr_setflags.lo.go obj/src/process/posix_spawnattr_setpgroup.lo.go obj/src/process/posix_spawnattr_setsigdefault.lo.go obj/src/process/posix_spawnattr_setsigmask.lo.go obj/src/process/vfork.lo.go obj/src/process/wait.lo.go obj/src/process/waitid.lo.go obj/src/process/waitpid.lo.go obj/src/regex/fnmatch.lo.go obj/src/regex/glob.lo.go obj/src/regex/regcomp.lo.go obj/src/regex/regerror.lo.go obj/src/regex/regexec.lo.go obj/src/regex/tre-mem.lo.go obj/src/search/hsearch.lo.go obj/src/search/insque.lo.go obj/src/search/lsearch.lo.go obj/src/search/tdelete.lo.go obj/src/search/tdestroy.lo.go obj/src/search/tfind.lo.go obj/src/search/tsearch.lo.go obj/src/search/twalk.lo.go obj/src/select/poll.lo.go obj/src/select/ppoll.lo.go obj/src/select/pselect.lo.go obj/src/select/select.lo.go obj/src/setjmp/longjmp.lo.go obj/src/setjmp/setjmp.lo.go obj/src/signal/block.lo.go obj/src/signal/getitimer.lo.go obj/src/signal/kill.lo.go obj/src/signal/killpg.lo.go obj/src/signal/psiginfo.lo.go obj/src/signal/psignal.lo.go obj/src/signal/raise.lo.go obj/src/signal/restore.lo.go obj/src/signal/setitimer.lo.go obj/src/signal/sigaction.lo.go obj/src/signal/sigaddset.lo.go obj/src/signal/sigaltstack.lo.go obj/src/signal/sigandset.lo.go obj/src/signal/sigdelset.lo.go obj/src/signal/sigemptyset.lo.go obj/src/signal/sigfillset.lo.go obj/src/signal/sigisemptyset.lo.go obj/src/signal/sigismember.lo.go obj/src/signal/sigorset.lo.go obj/src/signal/sigpending.lo.go obj/src/signal/sigprocmask.lo.go obj/src/signal/sigqueue.lo.go obj/src/signal/sigrtmax.lo.go obj/src/signal/sigrtmin.lo.go obj/src/signal/sigsetjmp.lo.go obj/src/signal/sigsetjmp_tail.lo.go obj/src/signal/sigsuspend.lo.go obj/src/signal/sigtimedwait.lo.go obj/src/signal/sigwait.lo.go obj/src/signal/sigwaitinfo.lo.go obj/src/stat/__xstat.lo.go obj/src/stat/chmod.lo.go obj/src/stat/fchmod.lo.go obj/src/stat/fchmodat.lo.go obj/src/stat/fstat.lo.go obj/src/stat/fstatat.lo.go obj/src/stat/futimens.lo.go obj/src/stat/futimesat.lo.go obj/src/stat/lchmod.lo.go obj/src/stat/lstat.lo.go obj/src/stat/mkdir.lo.go obj/src/stat/mkdirat.lo.go obj/src/stat/mkfifo.lo.go obj/src/stat/mkfifoat.lo.go obj/src/stat/mknod.lo.go obj/src/stat/mknodat.lo.go obj/src/stat/stat.lo.go obj/src/stat/statvfs.lo.go obj/src/stat/umask.lo.go obj/src/stat/utimensat.lo.go obj/src/stdio/__fclose_ca.lo.go obj/src/stdio/__fdopen.lo.go obj/src/stdio/__fmodeflags.lo.go obj/src/stdio/__fopen_rb_ca.lo.go obj/src/stdio/__overflow.lo.go obj/src/stdio/__stdio_close.lo.go obj/src/stdio/__stdio_exit.lo.go obj/src/stdio/__stdio_read.lo.go obj/src/stdio/__stdio_seek.lo.go obj/src/stdio/__stdio_write.lo.go obj/src/stdio/__stdout_write.lo.go obj/src/stdio/__toread.lo.go obj/src/stdio/__towrite.lo.go obj/src/stdio/__uflow.lo.go obj/src/stdio/asprintf.lo.go obj/src/stdio/clearerr.lo.go obj/src/stdio/dprintf.lo.go obj/src/stdio/ext.lo.go obj/src/stdio/ext2.lo.go obj/src/stdio/fclose.lo.go obj/src/stdio/feof.lo.go obj/src/stdio/ferror.lo.go obj/src/stdio/fflush.lo.go obj/src/stdio/fgetc.lo.go obj/src/stdio/fgetln.lo.go obj/src/stdio/fgetpos.lo.go obj/src/stdio/fgets.lo.go obj/src/stdio/fgetwc.lo.go obj/src/stdio/fgetws.lo.go obj/src/stdio/fileno.lo.go obj/src/stdio/flockfile.lo.go obj/src/stdio/fmemopen.lo.go obj/src/stdio/fopen.lo.go obj/src/stdio/fopencookie.lo.go obj/src/stdio/fprintf.lo.go obj/src/stdio/fputc.lo.go obj/src/stdio/fputs.lo.go obj/src/stdio/fputwc.lo.go obj/src/stdio/fputws.lo.go obj/src/stdio/fread.lo.go obj/src/stdio/freopen.lo.go obj/src/stdio/fscanf.lo.go obj/src/stdio/fseek.lo.go obj/src/stdio/fsetpos.lo.go obj/src/stdio/ftell.lo.go obj/src/stdio/ftrylockfile.lo.go obj/src/stdio/funlockfile.lo.go obj/src/stdio/fwide.lo.go obj/src/stdio/fwprintf.lo.go obj/src/stdio/fwrite.lo.go obj/src/stdio/fwscanf.lo.go obj/src/stdio/getc.lo.go obj/src/stdio/getc_unlocked.lo.go obj/src/stdio/getchar.lo.go obj/src/stdio/getchar_unlocked.lo.go obj/src/stdio/getdelim.lo.go obj/src/stdio/getline.lo.go obj/src/stdio/gets.lo.go obj/src/stdio/getw.lo.go obj/src/stdio/getwc.lo.go obj/src/stdio/getwchar.lo.go obj/src/stdio/ofl.lo.go obj/src/stdio/ofl_add.lo.go obj/src/stdio/open_memstream.lo.go obj/src/stdio/open_wmemstream.lo.go obj/src/stdio/pclose.lo.go obj/src/stdio/perror.lo.go obj/src/stdio/printf.lo.go obj/src/stdio/putc.lo.go obj/src/stdio/putc_unlocked.lo.go obj/src/stdio/putchar.lo.go obj/src/stdio/putchar_unlocked.lo.go obj/src/stdio/puts.lo.go obj/src/stdio/putw.lo.go obj/src/stdio/putwc.lo.go obj/src/stdio/putwchar.lo.go obj/src/stdio/remove.lo.go obj/src/stdio/rename.lo.go obj/src/stdio/rewind.lo.go obj/src/stdio/scanf.lo.go obj/src/stdio/setbuf.lo.go obj/src/stdio/setbuffer.lo.go obj/src/stdio/setlinebuf.lo.go obj/src/stdio/setvbuf.lo.go obj/src/stdio/snprintf.lo.go obj/src/stdio/sprintf.lo.go obj/src/stdio/sscanf.lo.go obj/src/stdio/stderr.lo.go obj/src/stdio/stdin.lo.go obj/src/stdio/stdout.lo.go obj/src/stdio/swprintf.lo.go obj/src/stdio/swscanf.lo.go obj/src/stdio/tempnam.lo.go obj/src/stdio/tmpfile.lo.go obj/src/stdio/tmpnam.lo.go obj/src/stdio/ungetc.lo.go obj/src/stdio/ungetwc.lo.go obj/src/stdio/vasprintf.lo.go obj/src/stdio/vdprintf.lo.go obj/src/stdio/vfprintf.lo.go obj/src/stdio/vfscanf.lo.go obj/src/stdio/vfwprintf.lo.go obj/src/stdio/vfwscanf.lo.go obj/src/stdio/vprintf.lo.go obj/src/stdio/vscanf.lo.go obj/src/stdio/vsnprintf.lo.go obj/src/stdio/vsprintf.lo.go obj/src/stdio/vsscanf.lo.go obj/src/stdio/vswprintf.lo.go obj/src/stdio/vswscanf.lo.go obj/src/stdio/vwprintf.lo.go obj/src/stdio/vwscanf.lo.go obj/src/stdio/wprintf.lo.go obj/src/stdio/wscanf.lo.go obj/src/stdlib/abs.lo.go obj/src/stdlib/atof.lo.go obj/src/stdlib/atoi.lo.go obj/src/stdlib/atol.lo.go obj/src/stdlib/atoll.lo.go obj/src/stdlib/bsearch.lo.go obj/src/stdlib/div.lo.go obj/src/stdlib/ecvt.lo.go obj/src/stdlib/fcvt.lo.go obj/src/stdlib/gcvt.lo.go obj/src/stdlib/imaxabs.lo.go obj/src/stdlib/imaxdiv.lo.go obj/src/stdlib/labs.lo.go obj/src/stdlib/ldiv.lo.go obj/src/stdlib/llabs.lo.go obj/src/stdlib/lldiv.lo.go obj/src/stdlib/qsort.lo.go obj/src/stdlib/qsort_nr.lo.go obj/src/stdlib/strtod.lo.go obj/src/stdlib/strtol.lo.go obj/src/stdlib/wcstod.lo.go obj/src/stdlib/wcstol.lo.go obj/src/string/bcmp.lo.go obj/src/string/bcopy.lo.go obj/src/string/bzero.lo.go obj/src/string/explicit_bzero.lo.go obj/src/string/index.lo.go obj/src/string/memccpy.lo.go obj/src/string/memchr.lo.go obj/src/string/memcmp.lo.go obj/src/string/memcpy.lo.go obj/src/string/memmem.lo.go obj/src/string/memmove.lo.go obj/src/string/mempcpy.lo.go obj/src/string/memrchr.lo.go obj/src/string/memset.lo.go obj/src/string/rindex.lo.go obj/src/string/stpcpy.lo.go obj/src/string/stpncpy.lo.go obj/src/string/strcasecmp.lo.go obj/src/string/strcasestr.lo.go obj/src/string/strcat.lo.go obj/src/string/strchr.lo.go obj/src/string/strchrnul.lo.go obj/src/string/strcmp.lo.go obj/src/string/strcpy.lo.go obj/src/string/strcspn.lo.go obj/src/string/strdup.lo.go obj/src/string/strerror_r.lo.go obj/src/string/strlcat.lo.go obj/src/string/strlcpy.lo.go obj/src/string/strlen.lo.go obj/src/string/strncasecmp.lo.go obj/src/string/strncat.lo.go obj/src/string/strncmp.lo.go obj/src/string/strncpy.lo.go obj/src/string/strndup.lo.go obj/src/string/strnlen.lo.go obj/src/string/strpbrk.lo.go obj/src/string/strrchr.lo.go obj/src/string/strsep.lo.go obj/src/string/strsignal.lo.go obj/src/string/strspn.lo.go obj/src/string/strstr.lo.go obj/src/string/strtok.lo.go obj/src/string/strtok_r.lo.go obj/src/string/strverscmp.lo.go obj/src/string/swab.lo.go obj/src/string/wcpcpy.lo.go obj/src/string/wcpncpy.lo.go obj/src/string/wcscasecmp.lo.go obj/src/string/wcscasecmp_l.lo.go obj/src/string/wcscat.lo.go obj/src/string/wcschr.lo.go obj/src/string/wcscmp.lo.go obj/src/string/wcscpy.lo.go obj/src/string/wcscspn.lo.go obj/src/string/wcsdup.lo.go obj/src/string/wcslen.lo.go obj/src/string/wcsncasecmp.lo.go obj/src/string/wcsncasecmp_l.lo.go obj/src/string/wcsncat.lo.go obj/src/string/wcsncmp.lo.go obj/src/string/wcsncpy.lo.go obj/src/string/wcsnlen.lo.go obj/src/string/wcspbrk.lo.go obj/src/string/wcsrchr.lo.go obj/src/string/wcsspn.lo.go obj/src/string/wcsstr.lo.go obj/src/string/wcstok.lo.go obj/src/string/wcswcs.lo.go obj/src/string/wmemchr.lo.go obj/src/string/wmemcmp.lo.go obj/src/string/wmemcpy.lo.go obj/src/string/wmemmove.lo.go obj/src/string/wmemset.lo.go obj/src/temp/mkdtemp.lo.go obj/src/temp/mkostemp.lo.go obj/src/temp/mkostemps.lo.go obj/src/temp/mkstemp.lo.go obj/src/temp/mkstemps.lo.go obj/src/temp/mktemp.lo.go obj/src/termios/cfgetospeed.lo.go obj/src/termios/cfmakeraw.lo.go obj/src/termios/cfsetospeed.lo.go obj/src/termios/tcdrain.lo.go obj/src/termios/tcflow.lo.go obj/src/termios/tcflush.lo.go obj/src/termios/tcgetattr.lo.go obj/src/termios/tcgetsid.lo.go obj/src/termios/tcgetwinsize.lo.go obj/src/termios/tcsendbreak.lo.go obj/src/termios/tcsetattr.lo.go obj/src/termios/tcsetwinsize.lo.go obj/src/time/__map_file.lo.go obj/src/time/__month_to_secs.lo.go obj/src/time/__secs_to_tm.lo.go obj/src/time/__tm_to_secs.lo.go obj/src/time/__tz.lo.go obj/src/time/__year_to_secs.lo.go obj/src/time/asctime.lo.go obj/src/time/asctime_r.lo.go obj/src/time/clock.lo.go obj/src/time/clock_getcpuclockid.lo.go obj/src/time/clock_getres.lo.go obj/src/time/clock_gettime.lo.go obj/src/time/clock_nanosleep.lo.go obj/src/time/clock_settime.lo.go obj/src/time/ctime.lo.go obj/src/time/ctime_r.lo.go obj/src/time/difftime.lo.go obj/src/time/ftime.lo.go obj/src/time/getdate.lo.go obj/src/time/gettimeofday.lo.go obj/src/time/gmtime.lo.go obj/src/time/gmtime_r.lo.go obj/src/time/localtime.lo.go obj/src/time/localtime_r.lo.go obj/src/time/mktime.lo.go obj/src/time/nanosleep.lo.go obj/src/time/strftime.lo.go obj/src/time/strptime.lo.go obj/src/time/time.lo.go obj/src/time/timegm.lo.go obj/src/time/timer_delete.lo.go obj/src/time/timer_getoverrun.lo.go obj/src/time/timer_gettime.lo.go obj/src/time/timer_settime.lo.go obj/src/time/times.lo.go obj/src/time/timespec_get.lo.go obj/src/time/utime.lo.go obj/src/time/wcsftime.lo.go obj/src/unistd/_exit.lo.go obj/src/unistd/access.lo.go obj/src/unistd/acct.lo.go obj/src/unistd/alarm.lo.go obj/src/unistd/chdir.lo.go obj/src/unistd/chown.lo.go obj/src/unistd/close.lo.go obj/src/unistd/ctermid.lo.go obj/src/unistd/dup.lo.go obj/src/unistd/dup2.lo.go obj/src/unistd/dup3.lo.go obj/src/unistd/faccessat.lo.go obj/src/unistd/fchdir.lo.go obj/src/unistd/fchown.lo.go obj/src/unistd/fchownat.lo.go obj/src/unistd/fdatasync.lo.go obj/src/unistd/fsync.lo.go obj/src/unistd/ftruncate.lo.go obj/src/unistd/getcwd.lo.go obj/src/unistd/getegid.lo.go obj/src/unistd/geteuid.lo.go obj/src/unistd/getgid.lo.go obj/src/unistd/getgroups.lo.go obj/src/unistd/gethostname.lo.go obj/src/unistd/getlogin.lo.go obj/src/unistd/getlogin_r.lo.go obj/src/unistd/getpgid.lo.go obj/src/unistd/getpgrp.lo.go obj/src/unistd/getpid.lo.go obj/src/unistd/getppid.lo.go obj/src/unistd/getsid.lo.go obj/src/unistd/getuid.lo.go obj/src/unistd/isatty.lo.go obj/src/unistd/lchown.lo.go obj/src/unistd/link.lo.go obj/src/unistd/linkat.lo.go obj/src/unistd/lseek.lo.go obj/src/unistd/nice.lo.go obj/src/unistd/pause.lo.go obj/src/unistd/pipe.lo.go obj/src/unistd/pipe2.lo.go obj/src/unistd/posix_close.lo.go obj/src/unistd/pread.lo.go obj/src/unistd/preadv.lo.go obj/src/unistd/pwrite.lo.go obj/src/unistd/pwritev.lo.go obj/src/unistd/read.lo.go obj/src/unistd/readlink.lo.go obj/src/unistd/readlinkat.lo.go obj/src/unistd/readv.lo.go obj/src/unistd/renameat.lo.go obj/src/unistd/rmdir.lo.go obj/src/unistd/setgid.lo.go obj/src/unistd/setpgid.lo.go obj/src/unistd/setpgrp.lo.go obj/src/unistd/setsid.lo.go obj/src/unistd/setuid.lo.go obj/src/unistd/setxid.lo.go obj/src/unistd/sleep.lo.go obj/src/unistd/symlink.lo.go obj/src/unistd/symlinkat.lo.go obj/src/unistd/sync.lo.go obj/src/unistd/tcgetpgrp.lo.go obj/src/unistd/tcsetpgrp.lo.go obj/src/unistd/truncate.lo.go obj/src/unistd/ttyname.lo.go obj/src/unistd/ttyname_r.lo.go obj/src/unistd/ualarm.lo.go obj/src/unistd/unlink.lo.go obj/src/unistd/unlinkat.lo.go obj/src/unistd/usleep.lo.go obj/src/unistd/write.lo.go obj/src/unistd/writev.lo.go -lgcc -lgcc_eh', DO NOT EDIT.

//go:build linux && arm64

package libc

import (
	"reflect"
	"unsafe"
)

var (
	_ reflect.Type
	_ unsafe.Pointer
)

const BIG_ENDIAN = 4321
const BYTE_ORDER = 1234
const DBL_DECIMAL_DIG = 17
const DBL_DIG = 15
const DBL_EPSILON = 0
const DBL_HAS_SUBNORM = 1
const DBL_MANT_DIG = 53
const DBL_MAX = 0
const DBL_MAX_10_EXP = 308
const DBL_MAX_EXP = 1024
const DBL_MIN = 0
const DBL_MIN_10_EXP = -307
const DBL_MIN_EXP = -1021
const DBL_TRUE_MIN = 0
const DECIMAL_DIG = 17
const FLT_DECIMAL_DIG = 9
const FLT_DIG = 6
const FLT_EPSILON = 0
const FLT_EVAL_METHOD = 0
const FLT_HAS_SUBNORM = 1
const FLT_MANT_DIG = 24
const FLT_MAX = 0
const FLT_MAX_10_EXP = 38
const FLT_MAX_EXP = 128
const FLT_MIN = 0
const FLT_MIN_10_EXP = -37
const FLT_MIN_EXP = -125
const FLT_RADIX = 2
const FLT_ROUNDS = 0
const FLT_TRUE_MIN = 0
const FP_FAST_FMA = 1
const FP_FAST_FMAF = 1
const FP_ILOGB0 = -2147483648
const FP_ILOGBNAN = -2147483648
const FP_INFINITE = 1
const FP_NAN = 0
const FP_NORMAL = 4
const FP_SUBNORMAL = 3
const FP_ZERO = 2
const HUGE_VALF = 0
const I = 0
const INFINITY = 0
const INT16_MAX = 32767
const INT16_MIN = -32768
const INT32_MAX = 2147483647
const INT32_MIN = -2147483648
const INT64_MAX = 9223372036854775807
const INT64_MIN = -9223372036854775808
const INT8_MAX = 127
const INT8_MIN = -128
const INTMAX_MAX = 9223372036854775807
const INTMAX_MIN = -9223372036854775808
const INTPTR_MAX = 9223372036854775807
const INTPTR_MIN = -9223372036854775808
const INT_FAST16_MAX = 2147483647
const INT_FAST16_MIN = -2147483648
const INT_FAST32_MAX = 2147483647
const INT_FAST32_MIN = -2147483648
const INT_FAST64_MAX = 9223372036854775807
const INT_FAST64_MIN = -9223372036854775808
const INT_FAST8_MAX = 127
const INT_FAST8_MIN = -128
const INT_LEAST16_MAX = 32767
const INT_LEAST16_MIN = -32768
const INT_LEAST32_MAX = 2147483647
const INT_LEAST32_MIN = -2147483648
const INT_LEAST64_MAX = 9223372036854775807
const INT_LEAST64_MIN = -9223372036854775808
const INT_LEAST8_MAX = 127
const INT_LEAST8_MIN = -128
const LDBL_DECIMAL_DIG = 17
const LDBL_DIG = 15
const LDBL_EPSILON = 0
const LDBL_HAS_SUBNORM = 1
const LDBL_MANT_DIG = 53
const LDBL_MAX = 0
const LDBL_MAX_10_EXP = 308
const LDBL_MAX_EXP = 1024
const LDBL_MIN = 0
const LDBL_MIN_10_EXP = -307
const LDBL_MIN_EXP = -1021
const LDBL_TRUE_MIN = 0
const LITTLE_ENDIAN = 1234
const MATH_ERREXCEPT = 2
const MATH_ERRNO = 1
const M_1_PI = 0
const M_2_PI = 0
const M_2_SQRTPI = 0
const M_E = 0
const M_LN10 = 0
const M_LN2 = 0
const M_LOG10E = 0
const M_LOG2E = 0
const M_PI = 0
const M_PI_2 = 0
const M_PI_4 = 0
const M_SQRT1_2 = 0
const M_SQRT2 = 0
const NAN = 0
const NDEBUG = 1
const PDP_ENDIAN = 3412
const PTRDIFF_MAX = 9223372036854775807
const PTRDIFF_MIN = -9223372036854775808
const SIG_ATOMIC_MAX = 2147483647
const SIG_ATOMIC_MIN = -2147483648
const SIZE_MAX = 18446744073709551615
const TOINT_INTRINSICS = 0
const UINT16_MAX = 65535
const UINT32_MAX = 4294967295
const UINT64_MAX = 18446744073709551615
const UINT8_MAX = 255
const UINTMAX_MAX = 18446744073709551615
const UINTPTR_MAX = 18446744073709551615
const UINT_FAST16_MAX = 4294967295
const UINT_FAST32_MAX = 4294967295
const UINT_FAST64_MAX = 18446744073709551615
const UINT_FAST8_MAX = 255
const UINT_LEAST16_MAX = 65535
const UINT_LEAST32_MAX = 4294967295
const UINT_LEAST64_MAX = 18446744073709551615
const UINT_LEAST8_MAX = 255
const WANT_ROUNDING = 1
const WANT_SNAN = 0
const WCHAR_MAX = 2147483647
const WCHAR_MIN = -2147483648
const WINT_MAX = 4294967295
const WINT_MIN = 0
const _Complex_I = 0
const _LP64 = 1
const _XOPEN_SOURCE = 700
const __AARCH64EL__ = 1
const __AARCH64_CMODEL_SMALL__ = 1
const __ARM_64BIT_STATE = 1
const __ARM_ALIGN_MAX_PWR = 28
const __ARM_ALIGN_MAX_STACK_PWR = 16
const __ARM_ARCH = 8
const __ARM_ARCH_8A = 1
const __ARM_ARCH_ISA_A64 = 1
const __ARM_ARCH_PROFILE = 65
const __ARM_FEATURE_CLZ = 1
const __ARM_FEATURE_FMA = 1
const __ARM_FEATURE_IDIV = 1
const __ARM_FEATURE_NUMERIC_MAXMIN = 1
const __ARM_FEATURE_UNALIGNED = 1
const __ARM_FP = 14
const __ARM_FP16_ARGS = 1
const __ARM_FP16_FORMAT_IEEE = 1
const __ARM_NEON = 1
const __ARM_PCS_AAPCS64 = 1
const __ARM_SIZEOF_MINIMAL_ENUM = 4
const __ARM_SIZEOF_WCHAR_T = 4
const __ATOMIC_ACQUIRE = 2
const __ATOMIC_ACQ_REL = 4
const __ATOMIC_CONSUME = 1
const __ATOMIC_RELAXED = 0
const __ATOMIC_RELEASE = 3
const __ATOMIC_SEQ_CST = 5
const __BIGGEST_ALIGNMENT__ = 16
const __BIG_ENDIAN = 4321
const __BYTE_ORDER = 1234
const __BYTE_ORDER__ = 1234
const __CCGO__ = 1
const __CHAR_BIT__ = 8
const __CHAR_UNSIGNED__ = 1
const __DBL_DECIMAL_DIG__ = 17
const __DBL_DIG__ = 15
const __DBL_HAS_DENORM__ = 1
const __DBL_HAS_INFINITY__ = 1
const __DBL_HAS_QUIET_NAN__ = 1
const __DBL_IS_IEC_60559__ = 2
const __DBL_MANT_DIG__ = 53
const __DBL_MAX_10_EXP__ = 308
const __DBL_MAX_EXP__ = 1024
const __DBL_MIN_10_EXP__ = -307
const __DBL_MIN_EXP__ = -1021
const __DECIMAL_DIG__ = 36
const __DEC_EVAL_METHOD__ = 2
const __ELF__ = 1
const __FINITE_MATH_ONLY__ = 0
const __FLOAT_WORD_ORDER__ = 1234
const __FLT128_DECIMAL_DIG__ = 36
const __FLT128_DENORM_MIN__ = 0
const __FLT128_DIG__ = 33
const __FLT128_EPSILON__ = 0
const __FLT128_HAS_DENORM__ = 1
const __FLT128_HAS_INFINITY__ = 1
const __FLT128_HAS_QUIET_NAN__ = 1
const __FLT128_IS_IEC_60559__ = 2
const __FLT128_MANT_DIG__ = 113
const __FLT128_MAX_10_EXP__ = 4932
const __FLT128_MAX_EXP__ = 16384
const __FLT128_MAX__ = 0
const __FLT128_MIN_10_EXP__ = -4931
const __FLT128_MIN_EXP__ = -16381
const __FLT128_MIN__ = 0
const __FLT128_NORM_MAX__ = 0
const __FLT16_DECIMAL_DIG__ = 5
const __FLT16_DENORM_MIN__ = 0
const __FLT16_DIG__ = 3
const __FLT16_EPSILON__ = 0
const __FLT16_HAS_DENORM__ = 1
const __FLT16_HAS_INFINITY__ = 1
const __FLT16_HAS_QUIET_NAN__ = 1
const __FLT16_IS_IEC_60559__ = 2
const __FLT16_MANT_DIG__ = 11
const __FLT16_MAX_10_EXP__ = 4
const __FLT16_MAX_EXP__ = 16
const __FLT16_MAX__ = 0
const __FLT16_MIN_10_EXP__ = -4
const __FLT16_MIN_EXP__ = -13
const __FLT16_MIN__ = 0
const __FLT16_NORM_MAX__ = 0
const __FLT32X_DECIMAL_DIG__ = 17
const __FLT32X_DENORM_MIN__ = 0
const __FLT32X_DIG__ = 15
const __FLT32X_EPSILON__ = 0
const __FLT32X_HAS_DENORM__ = 1
const __FLT32X_HAS_INFINITY__ = 1
const __FLT32X_HAS_QUIET_NAN__ = 1
const __FLT32X_IS_IEC_60559__ = 2
const __FLT32X_MANT_DIG__ = 53
const __FLT32X_MAX_10_EXP__ = 308
const __FLT32X_MAX_EXP__ = 1024
const __FLT32X_MAX__ = 0
const __FLT32X_MIN_10_EXP__ = -307
const __FLT32X_MIN_EXP__ = -1021
const __FLT32X_MIN__ = 0
const __FLT32X_NORM_MAX__ = 0
const __FLT32_DECIMAL_DIG__ = 9
const __FLT32_DENORM_MIN__ = 0
const __FLT32_DIG__ = 6
const __FLT32_EPSILON__ = 0
const __FLT32_HAS_DENORM__ = 1
const __FLT32_HAS_INFINITY__ = 1
const __FLT32_HAS_QUIET_NAN__ = 1
const __FLT32_IS_IEC_60559__ = 2
const __FLT32_MANT_DIG__ = 24
const __FLT32_MAX_10_EXP__ = 38
const __FLT32_MAX_EXP__ = 128
const __FLT32_MAX__ = 0
const __FLT32_MIN_10_EXP__ = -37
const __FLT32_MIN_EXP__ = -125
const __FLT32_MIN__ = 0
const __FLT32_NORM_MAX__ = 0
const __FLT64X_DECIMAL_DIG__ = 36
const __FLT64X_DENORM_MIN__ = 0
const __FLT64X_DIG__ = 33
const __FLT64X_EPSILON__ = 0
const __FLT64X_HAS_DENORM__ = 1
const __FLT64X_HAS_INFINITY__ = 1
const __FLT64X_HAS_QUIET_NAN__ = 1
const __FLT64X_IS_IEC_60559__ = 2
const __FLT64X_MANT_DIG__ = 113
const __FLT64X_MAX_10_EXP__ = 4932
const __FLT64X_MAX_EXP__ = 16384
const __FLT64X_MAX__ = 0
const __FLT64X_MIN_10_EXP__ = -4931
const __FLT64X_MIN_EXP__ = -16381
const __FLT64X_MIN__ = 0
const __FLT64X_NORM_MAX__ = 0
const __FLT64_DECIMAL_DIG__ = 17
const __FLT64_DENORM_MIN__ = 0
const __FLT64_DIG__ = 15
const __FLT64_EPSILON__ = 0
const __FLT64_HAS_DENORM__ = 1
const __FLT64_HAS_INFINITY__ = 1
const __FLT64_HAS_QUIET_NAN__ = 1
const __FLT64_IS_IEC_60559__ = 2
const __FLT64_MANT_DIG__ = 53
const __FLT64_MAX_10_EXP__ = 308
const __FLT64_MAX_EXP__ = 1024
const __FLT64_MAX__ = 0
const __FLT64_MIN_10_EXP__ = -307
const __FLT64_MIN_EXP__ = -1021
const __FLT64_MIN__ = 0
const __FLT64_NORM_MAX__ = 0
const __FLT_DECIMAL_DIG__ = 9
const __FLT_DENORM_MIN__ = 0
const __FLT_DIG__ = 6
const __FLT_EPSILON__ = 0
const __FLT_EVAL_METHOD_C99__ = 0
const __FLT_EVAL_METHOD_TS_18661_3__ = 0
const __FLT_EVAL_METHOD__ = 0
const __FLT_HAS_DENORM__ = 1
const __FLT_HAS_INFINITY__ = 1
const __FLT_HAS_QUIET_NAN__ = 1
const __FLT_IS_IEC_60559__ = 2
const __FLT_MANT_DIG__ = 24
const __FLT_MAX_10_EXP__ = 38
const __FLT_MAX_EXP__ = 128
const __FLT_MAX__ = 0
const __FLT_MIN_10_EXP__ = -37
const __FLT_MIN_EXP__ = -125
const __FLT_MIN__ = 0
const __FLT_NORM_MAX__ = 0
const __FLT_RADIX__ = 2
const __FP_FAST_FMA = 1
const __FP_FAST_FMAF = 1
const __FP_FAST_FMAF32 = 1
const __FP_FAST_FMAF32x = 1
const __FP_FAST_FMAF64 = 1
const __FUNCTION__ = 0
const __GCC_ASM_FLAG_OUTPUTS__ = 1
const __GCC_ATOMIC_BOOL_LOCK_FREE = 2
const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = 2
const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = 2
const __GCC_ATOMIC_CHAR_LOCK_FREE = 2
const __GCC_ATOMIC_INT_LOCK_FREE = 2
const __GCC_ATOMIC_LLONG_LOCK_FREE = 2
const __GCC_ATOMIC_LONG_LOCK_FREE = 2
const __GCC_ATOMIC_POINTER_LOCK_FREE = 2
const __GCC_ATOMIC_SHORT_LOCK_FREE = 2
const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = 1
const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = 2
const __GCC_CONSTRUCTIVE_SIZE = 64
const __GCC_DESTRUCTIVE_SIZE = 256
const __GCC_HAVE_DWARF2_CFI_ASM = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = 1
const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = 1
const __GCC_IEC_559 = 2
const __GCC_IEC_559_COMPLEX = 2
const __GNUC_EXECUTION_CHARSET_NAME = "UTF-8"
const __GNUC_MINOR__ = 2
const __GNUC_PATCHLEVEL__ = 0
const __GNUC_STDC_INLINE__ = 1
const __GNUC_WIDE_EXECUTION_CHARSET_NAME = "UTF-32LE"
const __GNUC__ = 12
const __GXX_ABI_VERSION = 1017
const __HAVE_SPECULATION_SAFE_VALUE = 1
const __INT16_MAX__ = 32767
const __INT32_MAX__ = 2147483647
const __INT32_TYPE__ = 0
const __INT64_MAX__ = 9223372036854775807
const __INT8_MAX__ = 127
const __INTMAX_MAX__ = 9223372036854775807
const __INTMAX_WIDTH__ = 64
const __INTPTR_MAX__ = 9223372036854775807
const __INTPTR_WIDTH__ = 64
const __INT_FAST16_MAX__ = 9223372036854775807
const __INT_FAST16_WIDTH__ = 64
const __INT_FAST32_MAX__ = 9223372036854775807
const __INT_FAST32_WIDTH__ = 64
const __INT_FAST64_MAX__ = 9223372036854775807
const __INT_FAST64_WIDTH__ = 64
const __INT_FAST8_MAX__ = 127
const __INT_FAST8_WIDTH__ = 8
const __INT_LEAST16_MAX__ = 32767
const __INT_LEAST16_WIDTH__ = 16
const __INT_LEAST32_MAX__ = 2147483647
const __INT_LEAST32_TYPE__ = 0
const __INT_LEAST32_WIDTH__ = 32
const __INT_LEAST64_MAX__ = 9223372036854775807
const __INT_LEAST64_WIDTH__ = 64
const __INT_LEAST8_MAX__ = 127
const __INT_LEAST8_WIDTH__ = 8
const __INT_MAX__ = 2147483647
const __INT_WIDTH__ = 32
const __LDBL_DECIMAL_DIG__ = 36
const __LDBL_DENORM_MIN__ = 0
const __LDBL_DIG__ = 33
const __LDBL_EPSILON__ = 0
const __LDBL_HAS_DENORM__ = 1
const __LDBL_HAS_INFINITY__ = 1
const __LDBL_HAS_QUIET_NAN__ = 1
const __LDBL_IS_IEC_60559__ = 2
const __LDBL_MANT_DIG__ = 113
const __LDBL_MAX_10_EXP__ = 4932
const __LDBL_MAX_EXP__ = 16384
const __LDBL_MAX__ = 0
const __LDBL_MIN_10_EXP__ = -4931
const __LDBL_MIN_EXP__ = -16381
const __LDBL_MIN__ = 0
const __LDBL_NORM_MAX__ = 0
const __LITTLE_ENDIAN = 1234
const __LONG_LONG_MAX__ = 9223372036854775807
const __LONG_LONG_WIDTH__ = 64
const __LONG_MAX = 9223372036854775807
const __LONG_MAX__ = 9223372036854775807
const __LONG_WIDTH__ = 64
const __LP64__ = 1
const __NO_INLINE__ = 1
const __ORDER_BIG_ENDIAN__ = 4321
const __ORDER_LITTLE_ENDIAN__ = 1234
const __ORDER_PDP_ENDIAN__ = 3412
const __PDP_ENDIAN = 3412
const __PIC__ = 2
const __PIE__ = 2
const __PRAGMA_REDEFINE_EXTNAME = 1
const __PRETTY_FUNCTION__ = 0
const __PTRDIFF_MAX__ = 9223372036854775807
const __PTRDIFF_WIDTH__ = 64
const __SCHAR_MAX__ = 127
const __SCHAR_WIDTH__ = 8
const __SHRT_MAX__ = 32767
const __SHRT_WIDTH__ = 16
const __SIG_ATOMIC_MAX__ = 2147483647
const __SIG_ATOMIC_MIN__ = -2147483648
const __SIG_ATOMIC_TYPE__ = 0
const __SIG_ATOMIC_WIDTH__ = 32
const __SIZEOF_DOUBLE__ = 8
const __SIZEOF_FLOAT__ = 4
const __SIZEOF_INT128__ = 16
const __SIZEOF_INT__ = 4
const __SIZEOF_LONG_DOUBLE__ = 8
const __SIZEOF_LONG_LONG__ = 8
const __SIZEOF_LONG__ = 8
const __SIZEOF_POINTER__ = 8
const __SIZEOF_PTRDIFF_T__ = 8
const __SIZEOF_SHORT__ = 2
const __SIZEOF_SIZE_T__ = 8
const __SIZEOF_WCHAR_T__ = 4
const __SIZEOF_WINT_T__ = 4
const __SIZE_MAX__ = 18446744073709551615
const __SIZE_WIDTH__ = 64
const __STDC_HOSTED__ = 0
const __STDC_VERSION__ = 199901
const __STDC__ = 1
const __STRICT_ANSI__ = 1
const __UINT16_MAX__ = 65535
const __UINT32_MAX__ = 4294967295
const __UINT64_MAX__ = 18446744073709551615
const __UINT8_MAX__ = 255
const __UINTMAX_MAX__ = 18446744073709551615
const __UINTPTR_MAX__ = 18446744073709551615
const __UINT_FAST16_MAX__ = 18446744073709551615
const __UINT_FAST32_MAX__ = 18446744073709551615
const __UINT_FAST64_MAX__ = 18446744073709551615
const __UINT_FAST8_MAX__ = 255
const __UINT_LEAST16_MAX__ = 65535
const __UINT_LEAST32_MAX__ = 4294967295
const __UINT_LEAST64_MAX__ = 18446744073709551615
const __UINT_LEAST8_MAX__ = 255
const __USE_TIME_BITS64 = 1
const __VERSION__ = "12.2.0"
const __WCHAR_MAX__ = 4294967295
const __WCHAR_MIN__ = 0
const __WCHAR_WIDTH__ = 32
const __WINT_MAX__ = 4294967295
const __WINT_MIN__ = 0
const __WINT_WIDTH__ = 32
const __aarch64__ = 1
const __gnu_linux__ = 1
const __inline = 0
const __linux = 1
const __linux__ = 1
const __pic__ = 2
const __pie__ = 2
const __restrict = 0
const __restrict_arr = 0
const __unix = 1
const __unix__ = 1
const complex1 = 0
const math_errhandling = 2

type t__builtin_va_list = uintptr

type t__predefined_size_t = uint64

type t__predefined_wchar_t = uint32

type t__predefined_ptrdiff_t = int64

type Tuintptr_t = uint64

type Tintptr_t = int64

type Tint8_t = int8

type Tint16_t = int16

type Tint32_t = int32

type Tint64_t = int64

type Tintmax_t = int64

type Tuint8_t = uint8

type Tuint16_t = uint16

type Tuint32_t = uint32

type Tuint64_t = uint64

type Tuintmax_t = uint64

type Tint_fast8_t = int8

type Tint_fast64_t = int64

type Tint_least8_t = int8

type Tint_least16_t = int16

type Tint_least32_t = int32

type Tint_least64_t = int64

type Tuint_fast8_t = uint8

type Tuint_fast64_t = uint64

type Tuint_least8_t = uint8

type Tuint_least16_t = uint16

type Tuint_least32_t = uint32

type Tuint_least64_t = uint64

type Tint_fast16_t = int32

type Tint_fast32_t = int32

type Tuint_fast16_t = uint32

type Tuint_fast32_t = uint32

type Tfloat_t = float32

type Tdouble_t = float64

var _k = uint32(1799)                   /* constant for reduction */
var _kln2 = float64(1246.9717778273416) /* k * ln2 */

// C documentation
//
//	/*
//	 * Compute exp(x), scaled to avoid spurious overflow.  An exponent is
//	 * returned separately in 'expt'.
//	 *
//	 * Input:  ln(DBL_MAX) <= x < ln(2 * DBL_MAX / DBL_MIN_DENORM) ~= 1454.91
//	 * Output: 2**1023 <= y < 2**1024
//	 */
func ___frexp_exp(tls *TLS, x float64, expt uintptr) (r float64) {
	var exp_x float64
	var hx Tuint32_t
	var v1 Tuint64_t
	_, _, _ = exp_x, hx, v1
	/*
	 * We use exp(x) = exp(x - kln2) * 2**k, carefully chosen to
	 * minimize |exp(kln2) - 2**k|.  We also scale the exponent of
	 * exp_x to MAX_EXP so that the result can be multiplied by
	 * a tiny number without losing accuracy due to denormalization.
	 */
	exp_x = Xexp(tls, x-_kln2)
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(&exp_x)) >> int32(32))
	*(*int32)(unsafe.Pointer(expt)) = int32(hx>>Int32FromInt32(20) - uint32(Int32FromInt32(0x3ff)+Int32FromInt32(1023)) + _k)
	v1 = uint64(hx&Uint32FromInt32(0xfffff)|uint32((Int32FromInt32(0x3ff)+Int32FromInt32(1023))<<Int32FromInt32(20)))<<Int32FromInt32(32) | uint64(uint32(*(*Tuint64_t)(unsafe.Pointer(&exp_x))))
	exp_x = *(*float64)(unsafe.Pointer(&v1))
	return exp_x
}

// C documentation
//
//	/*
//	 * __ldexp_cexp(x, expt) compute exp(x) * 2**expt.
//	 * It is intended for large arguments (real part >= ln(DBL_MAX))
//	 * where care is needed to avoid overflow.
//	 *
//	 * The present implementation is narrowly tailored for our hyperbolic and
//	 * exponential functions.  We assume expt is small (0 or -1), and the caller
//	 * has filtered out very large x, for which overflow would be inevitable.
//	 */
func X__ldexp_cexp(tls *TLS, z complex128, expt int32) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v expt=%v, (%v:)", tls, z, expt, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var exp_x, scale1, scale2, x, y float64
	var half_expt int32
	var v1, v2 Tuint64_t
	var v3 [2]float64
	var _ /* ex_expt at bp+0 */ int32
	_, _, _, _, _, _, _, _, _ = exp_x, half_expt, scale1, scale2, x, y, v1, v2, v3
	x = Float64FromComplex128(z)
	y = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	exp_x = ___frexp_exp(tls, x, bp)
	expt += *(*int32)(unsafe.Pointer(bp))
	/*
	 * Arrange so that scale1 * scale2 == 2**expt.  We use this to
	 * compensate for scalbn being horrendously slow.
	 */
	half_expt = expt / int32(2)
	v1 = uint64((Int32FromInt32(0x3ff)+half_expt)<<Int32FromInt32(20))<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))
	scale1 = *(*float64)(unsafe.Pointer(&v1))
	half_expt = expt - half_expt
	v2 = uint64((Int32FromInt32(0x3ff)+half_expt)<<Int32FromInt32(20))<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))
	scale2 = *(*float64)(unsafe.Pointer(&v2))
	v3 = [2]float64{
		0: Xcos(tls, y) * exp_x * scale1 * scale2,
		1: Xsin(tls, y) * exp_x * scale1 * scale2,
	}
	return *(*complex128)(unsafe.Pointer(&v3))
}

var _k1 = uint32(235)                        /* constant for reduction */
var _kln21 = Float32FromFloat32(162.8895874) /* k * ln2 */

// C documentation
//
//	/*
//	 * See __cexp.c for details.
//	 *
//	 * Input:  ln(FLT_MAX) <= x < ln(2 * FLT_MAX / FLT_MIN_DENORM) ~= 192.7
//	 * Output: 2**127 <= y < 2**128
//	 */
func ___frexp_expf(tls *TLS, x float32, expt uintptr) (r float32) {
	var exp_x float32
	var hx, v1 Tuint32_t
	_, _, _ = exp_x, hx, v1
	exp_x = Xexpf(tls, x-_kln21)
	hx = *(*Tuint32_t)(unsafe.Pointer(&exp_x))
	*(*int32)(unsafe.Pointer(expt)) = int32(hx>>Int32FromInt32(23) - uint32(Int32FromInt32(0x7f)+Int32FromInt32(127)) + _k1)
	v1 = hx&uint32(0x7fffff) | uint32((Int32FromInt32(0x7f)+Int32FromInt32(127))<<Int32FromInt32(23))
	exp_x = *(*float32)(unsafe.Pointer(&v1))
	return exp_x
}

func X__ldexp_cexpf(tls *TLS, z complex64, expt int32) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v expt=%v, (%v:)", tls, z, expt, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var exp_x, scale1, scale2, x, y float32
	var half_expt int32
	var v1, v2 Tuint32_t
	var v3 [2]float32
	var _ /* ex_expt at bp+0 */ int32
	_, _, _, _, _, _, _, _, _ = exp_x, half_expt, scale1, scale2, x, y, v1, v2, v3
	x = Float32FromComplex64(z)
	y = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	exp_x = ___frexp_expf(tls, x, bp)
	expt += *(*int32)(unsafe.Pointer(bp))
	half_expt = expt / int32(2)
	v1 = uint32((int32(0x7f) + half_expt) << int32(23))
	scale1 = *(*float32)(unsafe.Pointer(&v1))
	half_expt = expt - half_expt
	v2 = uint32((int32(0x7f) + half_expt) << int32(23))
	scale2 = *(*float32)(unsafe.Pointer(&v2))
	v3 = [2]float32{
		0: Xcosf(tls, y) * exp_x * scale1 * scale2,
		1: Xsinf(tls, y) * exp_x * scale1 * scale2,
	}
	return *(*complex64)(unsafe.Pointer(&v3))
}

func Xcabs(tls *TLS, z complex128) (r float64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xhypot(tls, Float64FromComplex128(z), +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)])
}

func Xcabsf(tls *TLS, z complex64) (r float32) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xhypotf(tls, Float32FromComplex64(z), +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)])
}

func Xcabsl(tls *TLS, z complex128) (r float64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcabs(tls, Complex128FromComplex128(z))
}

const M_PI_21 = 1.5707963267948966

// FIXME: Hull et al. "Implementing the complex arcsine and arccosine functions using exception handling" 1997

/* acos(z) = pi/2 - asin(z) */

func Xcacos(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 [2]float64
	_ = v1
	z = Xcasin(tls, z)
	v1 = [2]float64{
		0: float64(1.5707963267948966) - Float64FromComplex128(z),
		1: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
	}
	return *(*complex128)(unsafe.Pointer(&v1))
}

// FIXME

var _float_pi_2 = float32(1.5707963267948966)

func Xcacosf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 [2]float32
	_ = v1
	z = Xcasinf(tls, z)
	v1 = [2]float32{
		0: _float_pi_2 - Float32FromComplex64(z),
		1: -+(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
	}
	return *(*complex64)(unsafe.Pointer(&v1))
}

const M_PI_22 = 0

/* acosh(z) = i acos(z) */

func Xcacosh(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var zineg int32
	var v1 uint64
	var v3, v4 [2]float64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _ = zineg, v1, v3, v4
	*(*float64)(unsafe.Pointer(bp)) = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	zineg = int32(v1 >> Int32FromInt32(63))
	z = Xcacos(tls, z)
	if zineg != 0 {
		v3 = [2]float64{
			0: +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
			1: -Float64FromComplex128(z),
		}
		return *(*complex128)(unsafe.Pointer(&v3))
	} else {
		v4 = [2]float64{
			0: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
			1: Float64FromComplex128(z),
		}
		return *(*complex128)(unsafe.Pointer(&v4))
	}
	return r
}

func Xcacoshf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var zineg int32
	var v1 uint32
	var v3, v4 [2]float32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _ = zineg, v1, v3, v4
	*(*float32)(unsafe.Pointer(bp)) = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	zineg = int32(v1 >> Int32FromInt32(31))
	z = Xcacosf(tls, z)
	if zineg != 0 {
		v3 = [2]float32{
			0: +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
			1: -Float32FromComplex64(z),
		}
		return *(*complex64)(unsafe.Pointer(&v3))
	} else {
		v4 = [2]float32{
			0: -+(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
			1: Float32FromComplex64(z),
		}
		return *(*complex64)(unsafe.Pointer(&v4))
	}
	return r
}

func Xcacoshl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcacosh(tls, Complex128FromComplex128(z)))
}

func Xcacosl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcacos(tls, Complex128FromComplex128(z)))
}

func Xcarg(tls *TLS, z complex128) (r float64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xatan2(tls, +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)], Float64FromComplex128(z))
}

func Xcargf(tls *TLS, z complex64) (r float32) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xatan2f(tls, +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)], Float32FromComplex64(z))
}

func Xcargl(tls *TLS, z complex128) (r float64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcarg(tls, Complex128FromComplex128(z))
}

// FIXME

/* asin(z) = -i log(i z + sqrt(1 - z*z)) */

func Xcasin(tls *TLS, z complex128) (r1 complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, w complex128
	var x, y float64
	var v1, v2, v3 [2]float64
	_, _, _, _, _, _, _ = r, w, x, y, v1, v2, v3
	x = Float64FromComplex128(z)
	y = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	v1 = [2]float64{
		0: float64(1) - (x-y)*(x+y),
		1: -Float64FromFloat64(2) * x * y,
	}
	w = *(*complex128)(unsafe.Pointer(&v1))
	v2 = [2]float64{
		0: -y,
		1: x,
	}
	r = Xclog(tls, *(*complex128)(unsafe.Pointer(&v2))+Xcsqrt(tls, w))
	v3 = [2]float64{
		0: +(*(*[2]float64)(unsafe.Pointer(&r)))[int32(1)],
		1: -Float64FromComplex128(r),
	}
	return *(*complex128)(unsafe.Pointer(&v3))
}

// FIXME

func Xcasinf(tls *TLS, z complex64) (r1 complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, w complex64
	var x, y float32
	var v1, v2, v3 [2]float32
	_, _, _, _, _, _, _ = r, w, x, y, v1, v2, v3
	x = Float32FromComplex64(z)
	y = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	v1 = [2]float32{
		0: float32(Float64FromFloat64(1) - float64((x-y)*(x+y))),
		1: float32(-Float64FromFloat64(2) * float64(x) * float64(y)),
	}
	w = *(*complex64)(unsafe.Pointer(&v1))
	v2 = [2]float32{
		0: -y,
		1: x,
	}
	r = Xclogf(tls, *(*complex64)(unsafe.Pointer(&v2))+Xcsqrtf(tls, w))
	v3 = [2]float32{
		0: +(*(*[2]float32)(unsafe.Pointer(&r)))[int32(1)],
		1: -Float32FromComplex64(r),
	}
	return *(*complex64)(unsafe.Pointer(&v3))
}

/* asinh(z) = -i asin(i z) */

func Xcasinh(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 [2]float64
	_, _ = v1, v2
	v1 = [2]float64{
		0: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: Float64FromComplex128(z),
	}
	z = Xcasin(tls, *(*complex128)(unsafe.Pointer(&v1)))
	v2 = [2]float64{
		0: +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: -Float64FromComplex128(z),
	}
	return *(*complex128)(unsafe.Pointer(&v2))
}

func Xcasinhf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 [2]float32
	_, _ = v1, v2
	v1 = [2]float32{
		0: -+(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: Float32FromComplex64(z),
	}
	z = Xcasinf(tls, *(*complex64)(unsafe.Pointer(&v1)))
	v2 = [2]float32{
		0: +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: -Float32FromComplex64(z),
	}
	return *(*complex64)(unsafe.Pointer(&v2))
}

func Xcasinhl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcasinh(tls, Complex128FromComplex128(z)))
}

func Xcasinl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcasin(tls, Complex128FromComplex128(z)))
}

const MAXNUM = 0
const M_PI1 = 3.141592653589793

var _DP1 = float64(3.141592651605606)
var _DP2 = float64(1.9841871479187034e-09)
var _DP3 = float64(1.1442377452219664e-17)

func __redupi(tls *TLS, x float64) (r float64) {
	var i int64
	var t float64
	_, _ = i, t
	t = x / float64(3.141592653589793)
	if t >= float64(0) {
		t += float64(0.5)
	} else {
		t -= float64(0.5)
	}
	i = int64(t) /* the multiple */
	t = float64(i)
	t = x - t*_DP1 - t*_DP2 - t*_DP3
	return t
}

func Xcatan(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, t, x, x2, y float64
	var w complex128
	var v1 [2]float64
	_, _, _, _, _, _, _ = a, t, w, x, x2, y, v1
	x = Float64FromComplex128(z)
	y = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	x2 = x * x
	a = float64(1) - x2 - y*y
	t = float64(0.5) * Xatan2(tls, float64(2)*x, a)
	w = Complex128FromFloat64(__redupi(tls, t))
	t = y - float64(1)
	a = x2 + t*t
	t = y + float64(1)
	a = (x2 + t*t) / a
	v1 = [2]float64{
		0: Float64FromComplex128(w),
		1: float64(0.25) * Xlog(tls, a),
	}
	w = *(*complex128)(unsafe.Pointer(&v1))
	return w
}

const MAXNUMF = 0

var _DP11 = float64(3.140625)
var _DP21 = float64(0.0009675025939941406)
var _DP31 = float64(1.5099579909783765e-07)

var _float_pi = float32(3.141592653589793)

func __redupif(tls *TLS, xx float32) (r float32) {
	var i int64
	var t, x float32
	_, _, _ = i, t, x
	x = xx
	t = x / _float_pi
	if t >= Float32FromFloat32(0) {
		t += Float32FromFloat32(0.5)
	} else {
		t -= Float32FromFloat32(0.5)
	}
	i = int64(t) /* the multiple */
	t = float32(i)
	t = float32(float64(x) - float64(t)*_DP11 - float64(t)*_DP21 - float64(t)*_DP31)
	return t
}

func Xcatanf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, t, x, x2, y float32
	var w complex64
	var v1 [2]float32
	_, _, _, _, _, _, _ = a, t, w, x, x2, y, v1
	x = Float32FromComplex64(z)
	y = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	x2 = x * x
	a = Float32FromFloat32(1) - x2 - y*y
	t = Float32FromFloat32(0.5) * Xatan2f(tls, Float32FromFloat32(2)*x, a)
	w = Complex64FromFloat32(__redupif(tls, t))
	t = y - Float32FromFloat32(1)
	a = x2 + t*t
	t = y + Float32FromFloat32(1)
	a = (x2 + t*t) / a
	v1 = [2]float32{
		0: Float32FromComplex64(w),
		1: Float32FromFloat32(0.25) * Xlogf(tls, a),
	}
	w = *(*complex64)(unsafe.Pointer(&v1))
	return w
}

const M_PI2 = 0

/* atanh = -i atan(i z) */

func Xcatanh(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 [2]float64
	_, _ = v1, v2
	v1 = [2]float64{
		0: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: Float64FromComplex128(z),
	}
	z = Xcatan(tls, *(*complex128)(unsafe.Pointer(&v1)))
	v2 = [2]float64{
		0: +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: -Float64FromComplex128(z),
	}
	return *(*complex128)(unsafe.Pointer(&v2))
}

func Xcatanhf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 [2]float32
	_, _ = v1, v2
	v1 = [2]float32{
		0: -+(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: Float32FromComplex64(z),
	}
	z = Xcatanf(tls, *(*complex64)(unsafe.Pointer(&v1)))
	v2 = [2]float32{
		0: +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: -Float32FromComplex64(z),
	}
	return *(*complex64)(unsafe.Pointer(&v2))
}

func Xcatanhl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcatanh(tls, Complex128FromComplex128(z)))
}

func Xcatanl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcatan(tls, Complex128FromComplex128(z)))
}

/* cos(z) = cosh(i z) */

func Xccos(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 [2]float64
	_ = v1
	v1 = [2]float64{
		0: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: Float64FromComplex128(z),
	}
	return Xccosh(tls, *(*complex128)(unsafe.Pointer(&v1)))
}

func Xccosf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 [2]float32
	_ = v1
	v1 = [2]float32{
		0: -+(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: Float32FromComplex64(z),
	}
	return Xccoshf(tls, *(*complex64)(unsafe.Pointer(&v1)))
}

var _huge = float64(8.98846567431158e+307)

func Xccosh(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __u, __u1 Tuint64_t
	var h, x, y float64
	var hx, hy, ix, iy, lx, ly Tint32_t
	var v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v7, v8, v9 [2]float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __u, __u1, h, hx, hy, ix, iy, lx, ly, x, y, v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v7, v8, v9
	x = Float64FromComplex128(z)
	y = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	__u = *(*Tuint64_t)(unsafe.Pointer(&x))
	hx = int32(__u >> int32(32))
	lx = int32(uint32(__u))
	__u1 = *(*Tuint64_t)(unsafe.Pointer(&y))
	hy = int32(__u1 >> int32(32))
	ly = int32(uint32(__u1))
	ix = int32(0x7fffffff) & hx
	iy = int32(0x7fffffff) & hy
	/* Handle the nearly-non-exceptional cases where x and y are finite. */
	if ix < int32(0x7ff00000) && iy < int32(0x7ff00000) {
		if iy|ly == 0 {
			v1 = [2]float64{
				0: Xcosh(tls, x),
				1: x * y,
			}
			return *(*complex128)(unsafe.Pointer(&v1))
		}
		if ix < int32(0x40360000) { /* small x: normal case */
			v2 = [2]float64{
				0: Xcosh(tls, x) * Xcos(tls, y),
				1: Xsinh(tls, x) * Xsin(tls, y),
			}
			return *(*complex128)(unsafe.Pointer(&v2))
		}
		/* |x| >= 22, so cosh(x) ~= exp(|x|) */
		if ix < int32(0x40862e42) {
			/* x < 710: exp(|x|) won't overflow */
			h = Xexp(tls, Xfabs(tls, x)) * float64(0.5)
			v3 = [2]float64{
				0: h * Xcos(tls, y),
				1: Xcopysign(tls, h, x) * Xsin(tls, y),
			}
			return *(*complex128)(unsafe.Pointer(&v3))
		} else {
			if ix < int32(0x4096bbaa) {
				/* x < 1455: scale to avoid overflow */
				v4 = [2]float64{
					0: Xfabs(tls, x),
					1: y,
				}
				z = X__ldexp_cexp(tls, *(*complex128)(unsafe.Pointer(&v4)), -int32(1))
				v5 = [2]float64{
					0: Float64FromComplex128(z),
					1: +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)] * Xcopysign(tls, Float64FromInt32(1), x),
				}
				return *(*complex128)(unsafe.Pointer(&v5))
			} else {
				/* x >= 1455: the result always overflows */
				h = _huge * x
				v6 = [2]float64{
					0: h * h * Xcos(tls, y),
					1: h * Xsin(tls, y),
				}
				return *(*complex128)(unsafe.Pointer(&v6))
			}
		}
	}
	/*
	 * cosh(+-0 +- I Inf) = dNaN + I sign(d(+-0, dNaN))0.
	 * The sign of 0 in the result is unspecified.  Choice = normally
	 * the same as dNaN.  Raise the invalid floating-point exception.
	 *
	 * cosh(+-0 +- I NaN) = d(NaN) + I sign(d(+-0, NaN))0.
	 * The sign of 0 in the result is unspecified.  Choice = normally
	 * the same as d(NaN).
	 */
	if ix|lx == 0 && iy >= int32(0x7ff00000) {
		v7 = [2]float64{
			0: y - y,
			1: Xcopysign(tls, Float64FromInt32(0), x*(y-y)),
		}
		return *(*complex128)(unsafe.Pointer(&v7))
	}
	/*
	 * cosh(+-Inf +- I 0) = +Inf + I (+-)(+-)0.
	 *
	 * cosh(NaN +- I 0)   = d(NaN) + I sign(d(NaN, +-0))0.
	 * The sign of 0 in the result is unspecified.
	 */
	if iy|ly == 0 && ix >= int32(0x7ff00000) {
		if hx&int32(0xfffff)|lx == 0 {
			v8 = [2]float64{
				0: x * x,
				1: Xcopysign(tls, Float64FromInt32(0), x) * y,
			}
			return *(*complex128)(unsafe.Pointer(&v8))
		}
		v9 = [2]float64{
			0: x * x,
			1: Xcopysign(tls, Float64FromInt32(0), (x+x)*y),
		}
		return *(*complex128)(unsafe.Pointer(&v9))
	}
	/*
	 * cosh(x +- I Inf) = dNaN + I dNaN.
	 * Raise the invalid floating-point exception for finite nonzero x.
	 *
	 * cosh(x + I NaN) = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception for finite
	 * nonzero x.  Choice = don't raise (except for signaling NaNs).
	 */
	if ix < int32(0x7ff00000) && iy >= int32(0x7ff00000) {
		v10 = [2]float64{
			0: y - y,
			1: x * (y - y),
		}
		return *(*complex128)(unsafe.Pointer(&v10))
	}
	/*
	 * cosh(+-Inf + I NaN)  = +Inf + I d(NaN).
	 *
	 * cosh(+-Inf +- I Inf) = +Inf + I dNaN.
	 * The sign of Inf in the result is unspecified.  Choice = always +.
	 * Raise the invalid floating-point exception.
	 *
	 * cosh(+-Inf + I y)   = +Inf cos(y) +- I Inf sin(y)
	 */
	if ix >= int32(0x7ff00000) && hx&int32(0xfffff)|lx == 0 {
		if iy >= int32(0x7ff00000) {
			v11 = [2]float64{
				0: x * x,
				1: x * (y - y),
			}
			return *(*complex128)(unsafe.Pointer(&v11))
		}
		v12 = [2]float64{
			0: x * x * Xcos(tls, y),
			1: x * Xsin(tls, y),
		}
		return *(*complex128)(unsafe.Pointer(&v12))
	}
	/*
	 * cosh(NaN + I NaN)  = d(NaN) + I d(NaN).
	 *
	 * cosh(NaN +- I Inf) = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception.
	 * Choice = raise.
	 *
	 * cosh(NaN + I y)    = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception for finite
	 * nonzero y.  Choice = don't raise (except for signaling NaNs).
	 */
	v13 = [2]float64{
		0: x * x * (y - y),
		1: (x + x) * (y - y),
	}
	return *(*complex128)(unsafe.Pointer(&v13))
}

var _huge1 = float32(1.7014118346046923e+38)

func Xccoshf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var h, x, y float32
	var hx, hy, ix, iy Tint32_t
	var v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v7, v8, v9 [2]float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = h, hx, hy, ix, iy, x, y, v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v7, v8, v9
	x = Float32FromComplex64(z)
	y = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	hx = int32(*(*Tuint32_t)(unsafe.Pointer(&x)))
	hy = int32(*(*Tuint32_t)(unsafe.Pointer(&y)))
	ix = int32(0x7fffffff) & hx
	iy = int32(0x7fffffff) & hy
	if ix < int32(0x7f800000) && iy < int32(0x7f800000) {
		if iy == 0 {
			v1 = [2]float32{
				0: Xcoshf(tls, x),
				1: x * y,
			}
			return *(*complex64)(unsafe.Pointer(&v1))
		}
		if ix < int32(0x41100000) { /* small x: normal case */
			v2 = [2]float32{
				0: Xcoshf(tls, x) * Xcosf(tls, y),
				1: Xsinhf(tls, x) * Xsinf(tls, y),
			}
			return *(*complex64)(unsafe.Pointer(&v2))
		}
		/* |x| >= 9, so cosh(x) ~= exp(|x|) */
		if ix < int32(0x42b17218) {
			/* x < 88.7: expf(|x|) won't overflow */
			h = Xexpf(tls, Xfabsf(tls, x)) * Float32FromFloat32(0.5)
			v3 = [2]float32{
				0: h * Xcosf(tls, y),
				1: Xcopysignf(tls, h, x) * Xsinf(tls, y),
			}
			return *(*complex64)(unsafe.Pointer(&v3))
		} else {
			if ix < int32(0x4340b1e7) {
				/* x < 192.7: scale to avoid overflow */
				v4 = [2]float32{
					0: Xfabsf(tls, x),
					1: y,
				}
				z = X__ldexp_cexpf(tls, *(*complex64)(unsafe.Pointer(&v4)), -int32(1))
				v5 = [2]float32{
					0: Float32FromComplex64(z),
					1: +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)] * Xcopysignf(tls, Float32FromInt32(1), x),
				}
				return *(*complex64)(unsafe.Pointer(&v5))
			} else {
				/* x >= 192.7: the result always overflows */
				h = _huge1 * x
				v6 = [2]float32{
					0: h * h * Xcosf(tls, y),
					1: h * Xsinf(tls, y),
				}
				return *(*complex64)(unsafe.Pointer(&v6))
			}
		}
	}
	if ix == 0 && iy >= int32(0x7f800000) {
		v7 = [2]float32{
			0: y - y,
			1: Xcopysignf(tls, Float32FromInt32(0), x*(y-y)),
		}
		return *(*complex64)(unsafe.Pointer(&v7))
	}
	if iy == 0 && ix >= int32(0x7f800000) {
		if hx&int32(0x7fffff) == 0 {
			v8 = [2]float32{
				0: x * x,
				1: Xcopysignf(tls, Float32FromInt32(0), x) * y,
			}
			return *(*complex64)(unsafe.Pointer(&v8))
		}
		v9 = [2]float32{
			0: x * x,
			1: Xcopysignf(tls, Float32FromInt32(0), (x+x)*y),
		}
		return *(*complex64)(unsafe.Pointer(&v9))
	}
	if ix < int32(0x7f800000) && iy >= int32(0x7f800000) {
		v10 = [2]float32{
			0: y - y,
			1: x * (y - y),
		}
		return *(*complex64)(unsafe.Pointer(&v10))
	}
	if ix >= int32(0x7f800000) && hx&int32(0x7fffff) == 0 {
		if iy >= int32(0x7f800000) {
			v11 = [2]float32{
				0: x * x,
				1: x * (y - y),
			}
			return *(*complex64)(unsafe.Pointer(&v11))
		}
		v12 = [2]float32{
			0: x * x * Xcosf(tls, y),
			1: x * Xsinf(tls, y),
		}
		return *(*complex64)(unsafe.Pointer(&v12))
	}
	v13 = [2]float32{
		0: x * x * (y - y),
		1: (x + x) * (y - y),
	}
	return *(*complex64)(unsafe.Pointer(&v13))
}

// C documentation
//
//	//FIXME
func Xccoshl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xccosh(tls, Complex128FromComplex128(z)))
}

func Xccosl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xccos(tls, Complex128FromComplex128(z)))
}

var _exp_ovfl = uint32(0x40862e42)  /* high bits of MAX_EXP * ln2 ~= 710 */
var _cexp_ovfl = uint32(0x4096b8e4) /* (MAX_EXP - MIN_DENORM_EXP) * ln2 */

func Xcexp(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __u, __u1 Tuint64_t
	var exp_x, x, y float64
	var hx, hy, lx, ly Tuint32_t
	var v1, v2, v3, v4, v5, v6 [2]float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __u, __u1, exp_x, hx, hy, lx, ly, x, y, v1, v2, v3, v4, v5, v6
	x = Float64FromComplex128(z)
	y = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	__u = *(*Tuint64_t)(unsafe.Pointer(&y))
	hy = uint32(__u >> int32(32))
	ly = uint32(__u)
	hy &= uint32(0x7fffffff)
	/* cexp(x + I 0) = exp(x) + I 0 */
	if hy|ly == uint32(0) {
		v1 = [2]float64{
			0: Xexp(tls, x),
			1: y,
		}
		return *(*complex128)(unsafe.Pointer(&v1))
	}
	__u1 = *(*Tuint64_t)(unsafe.Pointer(&x))
	hx = uint32(__u1 >> int32(32))
	lx = uint32(__u1)
	/* cexp(0 + I y) = cos(y) + I sin(y) */
	if hx&uint32(0x7fffffff)|lx == uint32(0) {
		v2 = [2]float64{
			0: Xcos(tls, y),
			1: Xsin(tls, y),
		}
		return *(*complex128)(unsafe.Pointer(&v2))
	}
	if hy >= uint32(0x7ff00000) {
		if lx != uint32(0) || hx&uint32(0x7fffffff) != uint32(0x7ff00000) {
			/* cexp(finite|NaN +- I Inf|NaN) = NaN + I NaN */
			v3 = [2]float64{
				0: y - y,
				1: y - y,
			}
			return *(*complex128)(unsafe.Pointer(&v3))
		} else {
			if hx&uint32(0x80000000) != 0 {
				/* cexp(-Inf +- I Inf|NaN) = 0 + I 0 */
				v4 = [2]float64{}
				return *(*complex128)(unsafe.Pointer(&v4))
			} else {
				/* cexp(+Inf +- I Inf|NaN) = Inf + I NaN */
				v5 = [2]float64{
					0: x,
					1: y - y,
				}
				return *(*complex128)(unsafe.Pointer(&v5))
			}
		}
	}
	if hx >= _exp_ovfl && hx <= _cexp_ovfl {
		/*
		 * x is between 709.7 and 1454.3, so we must scale to avoid
		 * overflow in exp(x).
		 */
		return X__ldexp_cexp(tls, z, 0)
	} else {
		/*
		 * Cases covered here:
		 *  -  x < exp_ovfl and exp(x) won't overflow (common case)
		 *  -  x > cexp_ovfl, so exp(x) * s overflows for all s > 0
		 *  -  x = +-Inf (generated by exp())
		 *  -  x = NaN (spurious inexact exception from y)
		 */
		exp_x = Xexp(tls, x)
		v6 = [2]float64{
			0: exp_x * Xcos(tls, y),
			1: exp_x * Xsin(tls, y),
		}
		return *(*complex128)(unsafe.Pointer(&v6))
	}
	return r
}

var _exp_ovfl1 = uint32(0x42b17218)  /* MAX_EXP * ln2 ~= 88.722839355 */
var _cexp_ovfl1 = uint32(0x43400074) /* (MAX_EXP - MIN_DENORM_EXP) * ln2 */

func Xcexpf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var exp_x, x, y float32
	var hx, hy Tuint32_t
	var v1, v2, v3, v4, v5, v6 [2]float32
	_, _, _, _, _, _, _, _, _, _, _ = exp_x, hx, hy, x, y, v1, v2, v3, v4, v5, v6
	x = Float32FromComplex64(z)
	y = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	hy = *(*Tuint32_t)(unsafe.Pointer(&y))
	hy &= uint32(0x7fffffff)
	/* cexp(x + I 0) = exp(x) + I 0 */
	if hy == uint32(0) {
		v1 = [2]float32{
			0: Xexpf(tls, x),
			1: y,
		}
		return *(*complex64)(unsafe.Pointer(&v1))
	}
	hx = *(*Tuint32_t)(unsafe.Pointer(&x))
	/* cexp(0 + I y) = cos(y) + I sin(y) */
	if hx&uint32(0x7fffffff) == uint32(0) {
		v2 = [2]float32{
			0: Xcosf(tls, y),
			1: Xsinf(tls, y),
		}
		return *(*complex64)(unsafe.Pointer(&v2))
	}
	if hy >= uint32(0x7f800000) {
		if hx&uint32(0x7fffffff) != uint32(0x7f800000) {
			/* cexp(finite|NaN +- I Inf|NaN) = NaN + I NaN */
			v3 = [2]float32{
				0: y - y,
				1: y - y,
			}
			return *(*complex64)(unsafe.Pointer(&v3))
		} else {
			if hx&uint32(0x80000000) != 0 {
				/* cexp(-Inf +- I Inf|NaN) = 0 + I 0 */
				v4 = [2]float32{}
				return *(*complex64)(unsafe.Pointer(&v4))
			} else {
				/* cexp(+Inf +- I Inf|NaN) = Inf + I NaN */
				v5 = [2]float32{
					0: x,
					1: y - y,
				}
				return *(*complex64)(unsafe.Pointer(&v5))
			}
		}
	}
	if hx >= _exp_ovfl1 && hx <= _cexp_ovfl1 {
		/*
		 * x is between 88.7 and 192, so we must scale to avoid
		 * overflow in expf(x).
		 */
		return X__ldexp_cexpf(tls, z, 0)
	} else {
		/*
		 * Cases covered here:
		 *  -  x < exp_ovfl and exp(x) won't overflow (common case)
		 *  -  x > cexp_ovfl, so exp(x) * s overflows for all s > 0
		 *  -  x = +-Inf (generated by exp())
		 *  -  x = NaN (spurious inexact exception from y)
		 */
		exp_x = Xexpf(tls, x)
		v6 = [2]float32{
			0: exp_x * Xcosf(tls, y),
			1: exp_x * Xsinf(tls, y),
		}
		return *(*complex64)(unsafe.Pointer(&v6))
	}
	return r
}

// C documentation
//
//	//FIXME
func Xcexpl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcexp(tls, Complex128FromComplex128(z)))
}

func Xcimag(tls *TLS, z complex128) (r float64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
}

func Xcimagf(tls *TLS, z complex64) (r float32) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
}

func Xcimagl(tls *TLS, z complex128) (r float64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
}

// FIXME

/* log(z) = log(|z|) + i arg(z) */

func Xclog(tls *TLS, z complex128) (r1 complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var phi, r float64
	var v1 [2]float64
	_, _, _ = phi, r, v1
	r = Xcabs(tls, z)
	phi = Xcarg(tls, z)
	v1 = [2]float64{
		0: Xlog(tls, r),
		1: phi,
	}
	return *(*complex128)(unsafe.Pointer(&v1))
}

// FIXME

func Xclogf(tls *TLS, z complex64) (r1 complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var phi, r float32
	var v1 [2]float32
	_, _, _ = phi, r, v1
	r = Xcabsf(tls, z)
	phi = Xcargf(tls, z)
	v1 = [2]float32{
		0: Xlogf(tls, r),
		1: phi,
	}
	return *(*complex64)(unsafe.Pointer(&v1))
}

func Xclogl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xclog(tls, Complex128FromComplex128(z)))
}

func Xconj(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 [2]float64
	_ = v1
	v1 = [2]float64{
		0: Float64FromComplex128(z),
		1: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
	}
	return *(*complex128)(unsafe.Pointer(&v1))
}

func Xconjf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 [2]float32
	_ = v1
	v1 = [2]float32{
		0: Float32FromComplex64(z),
		1: -+(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
	}
	return *(*complex64)(unsafe.Pointer(&v1))
}

func Xconjl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 [2]float64
	_ = v1
	v1 = [2]float64{
		0: Float64FromComplex128(z),
		1: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
	}
	return *(*complex128)(unsafe.Pointer(&v1))
}

/* pow(z, c) = exp(c log(z)), See C99 G.6.4.1 */

func Xcpow(tls *TLS, z complex128, c complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v c=%v, (%v:)", tls, z, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcexp(tls, c*Xclog(tls, z))
}

func Xcpowf(tls *TLS, z complex64, c complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v c=%v, (%v:)", tls, z, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcexpf(tls, c*Xclogf(tls, z))
}

func Xcpowl(tls *TLS, z complex128, c complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v c=%v, (%v:)", tls, z, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcpow(tls, Complex128FromComplex128(z), Complex128FromComplex128(c)))
}

func Xcproj(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v3 uint64
	var v5 bool
	var v6 [2]float64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _ = v1, v3, v5, v6
	*(*float64)(unsafe.Pointer(bp)) = Float64FromComplex128(z)
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0; !v5 {
		*(*float64)(unsafe.Pointer(bp)) = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
		v3 = *(*uint64)(unsafe.Pointer(bp))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		v6 = [2]float64{
			0: float64(X__builtin_inff(tls)),
			1: Xcopysign(tls, float64(0), +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]),
		}
		return *(*complex128)(unsafe.Pointer(&v6))
	}
	return z
}

func Xcprojf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v3 uint32
	var v5 bool
	var v6 [2]float32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _ = v1, v3, v5, v6
	*(*float32)(unsafe.Pointer(bp)) = Float32FromComplex64(z)
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&uint32(0x7fffffff) == uint32(0x7f800000)) != 0; !v5 {
		*(*float32)(unsafe.Pointer(bp)) = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
		v3 = *(*uint32)(unsafe.Pointer(bp))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 {
		v6 = [2]float32{
			0: X__builtin_inff(tls),
			1: Xcopysignf(tls, float32(0), +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]),
		}
		return *(*complex64)(unsafe.Pointer(&v6))
	}
	return z
}

func Xcprojl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcproj(tls, Complex128FromComplex128(z)))
}

func Xcreal(tls *TLS, z complex128) (r float64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Float64FromComplex128(z)
}

func Xcrealf(tls *TLS, z complex64) (r float32) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Float32FromComplex64(z)
}

func Xcreall(tls *TLS, z complex128) (r float64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Float64FromComplex128(z)
}

/* sin(z) = -i sinh(i z) */

func Xcsin(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 [2]float64
	_, _ = v1, v2
	v1 = [2]float64{
		0: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: Float64FromComplex128(z),
	}
	z = Xcsinh(tls, *(*complex128)(unsafe.Pointer(&v1)))
	v2 = [2]float64{
		0: +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: -Float64FromComplex128(z),
	}
	return *(*complex128)(unsafe.Pointer(&v2))
}

func Xcsinf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 [2]float32
	_, _ = v1, v2
	v1 = [2]float32{
		0: -+(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: Float32FromComplex64(z),
	}
	z = Xcsinhf(tls, *(*complex64)(unsafe.Pointer(&v1)))
	v2 = [2]float32{
		0: +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: -Float32FromComplex64(z),
	}
	return *(*complex64)(unsafe.Pointer(&v2))
}

var _huge2 = float64(8.98846567431158e+307)

func Xcsinh(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __u, __u1 Tuint64_t
	var h, x, y float64
	var hx, hy, ix, iy, lx, ly Tint32_t
	var v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v7, v8, v9 [2]float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __u, __u1, h, hx, hy, ix, iy, lx, ly, x, y, v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v7, v8, v9
	x = Float64FromComplex128(z)
	y = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	__u = *(*Tuint64_t)(unsafe.Pointer(&x))
	hx = int32(__u >> int32(32))
	lx = int32(uint32(__u))
	__u1 = *(*Tuint64_t)(unsafe.Pointer(&y))
	hy = int32(__u1 >> int32(32))
	ly = int32(uint32(__u1))
	ix = int32(0x7fffffff) & hx
	iy = int32(0x7fffffff) & hy
	/* Handle the nearly-non-exceptional cases where x and y are finite. */
	if ix < int32(0x7ff00000) && iy < int32(0x7ff00000) {
		if iy|ly == 0 {
			v1 = [2]float64{
				0: Xsinh(tls, x),
				1: y,
			}
			return *(*complex128)(unsafe.Pointer(&v1))
		}
		if ix < int32(0x40360000) { /* small x: normal case */
			v2 = [2]float64{
				0: Xsinh(tls, x) * Xcos(tls, y),
				1: Xcosh(tls, x) * Xsin(tls, y),
			}
			return *(*complex128)(unsafe.Pointer(&v2))
		}
		/* |x| >= 22, so cosh(x) ~= exp(|x|) */
		if ix < int32(0x40862e42) {
			/* x < 710: exp(|x|) won't overflow */
			h = Xexp(tls, Xfabs(tls, x)) * float64(0.5)
			v3 = [2]float64{
				0: Xcopysign(tls, h, x) * Xcos(tls, y),
				1: h * Xsin(tls, y),
			}
			return *(*complex128)(unsafe.Pointer(&v3))
		} else {
			if ix < int32(0x4096bbaa) {
				/* x < 1455: scale to avoid overflow */
				v4 = [2]float64{
					0: Xfabs(tls, x),
					1: y,
				}
				z = X__ldexp_cexp(tls, *(*complex128)(unsafe.Pointer(&v4)), -int32(1))
				v5 = [2]float64{
					0: Float64FromComplex128(z) * Xcopysign(tls, Float64FromInt32(1), x),
					1: +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
				}
				return *(*complex128)(unsafe.Pointer(&v5))
			} else {
				/* x >= 1455: the result always overflows */
				h = _huge2 * x
				v6 = [2]float64{
					0: h * Xcos(tls, y),
					1: h * h * Xsin(tls, y),
				}
				return *(*complex128)(unsafe.Pointer(&v6))
			}
		}
	}
	/*
	 * sinh(+-0 +- I Inf) = sign(d(+-0, dNaN))0 + I dNaN.
	 * The sign of 0 in the result is unspecified.  Choice = normally
	 * the same as dNaN.  Raise the invalid floating-point exception.
	 *
	 * sinh(+-0 +- I NaN) = sign(d(+-0, NaN))0 + I d(NaN).
	 * The sign of 0 in the result is unspecified.  Choice = normally
	 * the same as d(NaN).
	 */
	if ix|lx == 0 && iy >= int32(0x7ff00000) {
		v7 = [2]float64{
			0: Xcopysign(tls, Float64FromInt32(0), x*(y-y)),
			1: y - y,
		}
		return *(*complex128)(unsafe.Pointer(&v7))
	}
	/*
	 * sinh(+-Inf +- I 0) = +-Inf + I +-0.
	 *
	 * sinh(NaN +- I 0)   = d(NaN) + I +-0.
	 */
	if iy|ly == 0 && ix >= int32(0x7ff00000) {
		if hx&int32(0xfffff)|lx == 0 {
			v8 = [2]float64{
				0: x,
				1: y,
			}
			return *(*complex128)(unsafe.Pointer(&v8))
		}
		v9 = [2]float64{
			0: x,
			1: Xcopysign(tls, Float64FromInt32(0), y),
		}
		return *(*complex128)(unsafe.Pointer(&v9))
	}
	/*
	 * sinh(x +- I Inf) = dNaN + I dNaN.
	 * Raise the invalid floating-point exception for finite nonzero x.
	 *
	 * sinh(x + I NaN) = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception for finite
	 * nonzero x.  Choice = don't raise (except for signaling NaNs).
	 */
	if ix < int32(0x7ff00000) && iy >= int32(0x7ff00000) {
		v10 = [2]float64{
			0: y - y,
			1: x * (y - y),
		}
		return *(*complex128)(unsafe.Pointer(&v10))
	}
	/*
	 * sinh(+-Inf + I NaN)  = +-Inf + I d(NaN).
	 * The sign of Inf in the result is unspecified.  Choice = normally
	 * the same as d(NaN).
	 *
	 * sinh(+-Inf +- I Inf) = +Inf + I dNaN.
	 * The sign of Inf in the result is unspecified.  Choice = always +.
	 * Raise the invalid floating-point exception.
	 *
	 * sinh(+-Inf + I y)   = +-Inf cos(y) + I Inf sin(y)
	 */
	if ix >= int32(0x7ff00000) && hx&int32(0xfffff)|lx == 0 {
		if iy >= int32(0x7ff00000) {
			v11 = [2]float64{
				0: x * x,
				1: x * (y - y),
			}
			return *(*complex128)(unsafe.Pointer(&v11))
		}
		v12 = [2]float64{
			0: x * Xcos(tls, y),
			1: float64(X__builtin_inff(tls)) * Xsin(tls, y),
		}
		return *(*complex128)(unsafe.Pointer(&v12))
	}
	/*
	 * sinh(NaN + I NaN)  = d(NaN) + I d(NaN).
	 *
	 * sinh(NaN +- I Inf) = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception.
	 * Choice = raise.
	 *
	 * sinh(NaN + I y)    = d(NaN) + I d(NaN).
	 * Optionally raises the invalid floating-point exception for finite
	 * nonzero y.  Choice = don't raise (except for signaling NaNs).
	 */
	v13 = [2]float64{
		0: x * x * (y - y),
		1: (x + x) * (y - y),
	}
	return *(*complex128)(unsafe.Pointer(&v13))
}

var _huge3 = float32(1.7014118346046923e+38)

func Xcsinhf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var h, x, y float32
	var hx, hy, ix, iy Tint32_t
	var v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v7, v8, v9 [2]float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = h, hx, hy, ix, iy, x, y, v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v7, v8, v9
	x = Float32FromComplex64(z)
	y = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	hx = int32(*(*Tuint32_t)(unsafe.Pointer(&x)))
	hy = int32(*(*Tuint32_t)(unsafe.Pointer(&y)))
	ix = int32(0x7fffffff) & hx
	iy = int32(0x7fffffff) & hy
	if ix < int32(0x7f800000) && iy < int32(0x7f800000) {
		if iy == 0 {
			v1 = [2]float32{
				0: Xsinhf(tls, x),
				1: y,
			}
			return *(*complex64)(unsafe.Pointer(&v1))
		}
		if ix < int32(0x41100000) { /* small x: normal case */
			v2 = [2]float32{
				0: Xsinhf(tls, x) * Xcosf(tls, y),
				1: Xcoshf(tls, x) * Xsinf(tls, y),
			}
			return *(*complex64)(unsafe.Pointer(&v2))
		}
		/* |x| >= 9, so cosh(x) ~= exp(|x|) */
		if ix < int32(0x42b17218) {
			/* x < 88.7: expf(|x|) won't overflow */
			h = Xexpf(tls, Xfabsf(tls, x)) * Float32FromFloat32(0.5)
			v3 = [2]float32{
				0: Xcopysignf(tls, h, x) * Xcosf(tls, y),
				1: h * Xsinf(tls, y),
			}
			return *(*complex64)(unsafe.Pointer(&v3))
		} else {
			if ix < int32(0x4340b1e7) {
				/* x < 192.7: scale to avoid overflow */
				v4 = [2]float32{
					0: Xfabsf(tls, x),
					1: y,
				}
				z = X__ldexp_cexpf(tls, *(*complex64)(unsafe.Pointer(&v4)), -int32(1))
				v5 = [2]float32{
					0: Float32FromComplex64(z) * Xcopysignf(tls, Float32FromInt32(1), x),
					1: +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
				}
				return *(*complex64)(unsafe.Pointer(&v5))
			} else {
				/* x >= 192.7: the result always overflows */
				h = _huge3 * x
				v6 = [2]float32{
					0: h * Xcosf(tls, y),
					1: h * h * Xsinf(tls, y),
				}
				return *(*complex64)(unsafe.Pointer(&v6))
			}
		}
	}
	if ix == 0 && iy >= int32(0x7f800000) {
		v7 = [2]float32{
			0: Xcopysignf(tls, Float32FromInt32(0), x*(y-y)),
			1: y - y,
		}
		return *(*complex64)(unsafe.Pointer(&v7))
	}
	if iy == 0 && ix >= int32(0x7f800000) {
		if hx&int32(0x7fffff) == 0 {
			v8 = [2]float32{
				0: x,
				1: y,
			}
			return *(*complex64)(unsafe.Pointer(&v8))
		}
		v9 = [2]float32{
			0: x,
			1: Xcopysignf(tls, Float32FromInt32(0), y),
		}
		return *(*complex64)(unsafe.Pointer(&v9))
	}
	if ix < int32(0x7f800000) && iy >= int32(0x7f800000) {
		v10 = [2]float32{
			0: y - y,
			1: x * (y - y),
		}
		return *(*complex64)(unsafe.Pointer(&v10))
	}
	if ix >= int32(0x7f800000) && hx&int32(0x7fffff) == 0 {
		if iy >= int32(0x7f800000) {
			v11 = [2]float32{
				0: x * x,
				1: x * (y - y),
			}
			return *(*complex64)(unsafe.Pointer(&v11))
		}
		v12 = [2]float32{
			0: x * Xcosf(tls, y),
			1: X__builtin_inff(tls) * Xsinf(tls, y),
		}
		return *(*complex64)(unsafe.Pointer(&v12))
	}
	v13 = [2]float32{
		0: x * x * (y - y),
		1: (x + x) * (y - y),
	}
	return *(*complex64)(unsafe.Pointer(&v13))
}

// C documentation
//
//	//FIXME
func Xcsinhl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcsinh(tls, Complex128FromComplex128(z)))
}

func Xcsinl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcsin(tls, Complex128FromComplex128(z)))
}

const THRESH = 7.446288774449766e+307

/*
 * gcc doesn't implement complex multiplication or division correctly,
 * so we need to handle infinities specially. We turn on this pragma to
 * notify conforming c99 compilers that the fast-but-incorrect code that
 * gcc generates is acceptable, since the special cases have already been
 * handled.
 */

/* We risk spurious overflow for components >= DBL_MAX / (1 + sqrt(2)). */

func Xcsqrt(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var a, b, t float64
	var result complex128
	var scale int32
	var v1, v12, v13, v14, v15, v4, v7 [2]float64
	var v10, v2, v5, v8 uint64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, b, result, scale, t, v1, v10, v12, v13, v14, v15, v2, v4, v5, v7, v8
	a = Float64FromComplex128(z)
	b = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	/* Handle special cases. */
	if z == Complex128FromInt32(0) {
		v1 = [2]float64{
			1: b,
		}
		return *(*complex128)(unsafe.Pointer(&v1))
	}
	*(*float64)(unsafe.Pointer(bp)) = b
	v2 = *(*uint64)(unsafe.Pointer(bp))
	goto _3
_3:
	if BoolInt32(v2&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		v4 = [2]float64{
			0: float64(X__builtin_inff(tls)),
			1: b,
		}
		return *(*complex128)(unsafe.Pointer(&v4))
	}
	*(*float64)(unsafe.Pointer(bp)) = a
	v5 = *(*uint64)(unsafe.Pointer(bp))
	goto _6
_6:
	if BoolInt32(v5&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		t = (b - b) / (b - b) /* raise invalid if b is not a NaN */
		v7 = [2]float64{
			0: a,
			1: t,
		}
		return *(*complex128)(unsafe.Pointer(&v7)) /* return NaN + NaN i */
	}
	*(*float64)(unsafe.Pointer(bp)) = a
	v8 = *(*uint64)(unsafe.Pointer(bp))
	goto _9
_9:
	if BoolInt32(v8&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		/*
		 * csqrt(inf + NaN i)  = inf +  NaN i
		 * csqrt(inf + y i)    = inf +  0 i
		 * csqrt(-inf + NaN i) = NaN +- inf i
		 * csqrt(-inf + y i)   = 0   +  inf i
		 */
		*(*float64)(unsafe.Pointer(bp)) = a
		v10 = *(*uint64)(unsafe.Pointer(bp))
		goto _11
	_11:
		if int32(v10>>Int32FromInt32(63)) != 0 {
			v12 = [2]float64{
				0: Xfabs(tls, b-b),
				1: Xcopysign(tls, a, b),
			}
			return *(*complex128)(unsafe.Pointer(&v12))
		} else {
			v13 = [2]float64{
				0: a,
				1: Xcopysign(tls, b-b, b),
			}
			return *(*complex128)(unsafe.Pointer(&v13))
		}
	}
	/*
	 * The remaining special case (b is NaN) is handled just fine by
	 * the normal code path below.
	 */
	/* Scale to avoid overflow. */
	if Xfabs(tls, a) >= float64(7.446288774449766e+307) || Xfabs(tls, b) >= float64(7.446288774449766e+307) {
		a *= float64(0.25)
		b *= float64(0.25)
		scale = int32(1)
	} else {
		scale = 0
	}
	/* Algorithm 312, CACM vol 10, Oct 1967. */
	if a >= Float64FromInt32(0) {
		t = Xsqrt(tls, (a+Xhypot(tls, a, b))*float64(0.5))
		v14 = [2]float64{
			0: t,
			1: b / (Float64FromInt32(2) * t),
		}
		result = *(*complex128)(unsafe.Pointer(&v14))
	} else {
		t = Xsqrt(tls, (-a+Xhypot(tls, a, b))*float64(0.5))
		v15 = [2]float64{
			0: Xfabs(tls, b) / (Float64FromInt32(2) * t),
			1: Xcopysign(tls, t, b),
		}
		result = *(*complex128)(unsafe.Pointer(&v15))
	}
	/* Rescale. */
	if scale != 0 {
		result *= Complex128FromInt32(2)
	}
	return result
}

/*
 * gcc doesn't implement complex multiplication or division correctly,
 * so we need to handle infinities specially. We turn on this pragma to
 * notify conforming c99 compilers that the fast-but-incorrect code that
 * gcc generates is acceptable, since the special cases have already been
 * handled.
 */

func Xcsqrtf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var a, b float32
	var t float64
	var v1, v12, v13, v14, v15, v4, v7 [2]float32
	var v10, v2, v5, v8 uint32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, b, t, v1, v10, v12, v13, v14, v15, v2, v4, v5, v7, v8
	a = Float32FromComplex64(z)
	b = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	/* Handle special cases. */
	if z == Complex64FromInt32(0) {
		v1 = [2]float32{
			1: b,
		}
		return *(*complex64)(unsafe.Pointer(&v1))
	}
	*(*float32)(unsafe.Pointer(bp)) = b
	v2 = *(*uint32)(unsafe.Pointer(bp))
	goto _3
_3:
	if BoolInt32(v2&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 {
		v4 = [2]float32{
			0: X__builtin_inff(tls),
			1: b,
		}
		return *(*complex64)(unsafe.Pointer(&v4))
	}
	*(*float32)(unsafe.Pointer(bp)) = a
	v5 = *(*uint32)(unsafe.Pointer(bp))
	goto _6
_6:
	if BoolInt32(v5&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		t = float64((b - b) / (b - b)) /* raise invalid if b is not a NaN */
		v7 = [2]float32{
			0: a,
			1: float32(t),
		}
		return *(*complex64)(unsafe.Pointer(&v7)) /* return NaN + NaN i */
	}
	*(*float32)(unsafe.Pointer(bp)) = a
	v8 = *(*uint32)(unsafe.Pointer(bp))
	goto _9
_9:
	if BoolInt32(v8&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 {
		/*
		 * csqrtf(inf + NaN i)  = inf +  NaN i
		 * csqrtf(inf + y i)    = inf +  0 i
		 * csqrtf(-inf + NaN i) = NaN +- inf i
		 * csqrtf(-inf + y i)   = 0   +  inf i
		 */
		*(*float32)(unsafe.Pointer(bp)) = a
		v10 = *(*uint32)(unsafe.Pointer(bp))
		goto _11
	_11:
		if int32(v10>>Int32FromInt32(31)) != 0 {
			v12 = [2]float32{
				0: Xfabsf(tls, b-b),
				1: Xcopysignf(tls, a, b),
			}
			return *(*complex64)(unsafe.Pointer(&v12))
		} else {
			v13 = [2]float32{
				0: a,
				1: Xcopysignf(tls, b-b, b),
			}
			return *(*complex64)(unsafe.Pointer(&v13))
		}
	}
	/*
	 * The remaining special case (b is NaN) is handled just fine by
	 * the normal code path below.
	 */
	/*
	 * We compute t in double precision to avoid overflow and to
	 * provide correct rounding in nearly all cases.
	 * This is Algorithm 312, CACM vol 10, Oct 1967.
	 */
	if a >= Float32FromInt32(0) {
		t = Xsqrt(tls, (float64(a)+Xhypot(tls, float64(a), float64(b)))*float64(0.5))
		v14 = [2]float32{
			0: float32(t),
			1: float32(float64(b) / (Float64FromFloat64(2) * t)),
		}
		return *(*complex64)(unsafe.Pointer(&v14))
	} else {
		t = Xsqrt(tls, (float64(-a)+Xhypot(tls, float64(a), float64(b)))*float64(0.5))
		v15 = [2]float32{
			0: float32(float64(Xfabsf(tls, b)) / (Float64FromFloat64(2) * t)),
			1: Xcopysignf(tls, float32(t), b),
		}
		return *(*complex64)(unsafe.Pointer(&v15))
	}
	return r
}

// C documentation
//
//	//FIXME
func Xcsqrtl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xcsqrt(tls, Complex128FromComplex128(z)))
}

/* tan(z) = -i tanh(i z) */

func Xctan(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 [2]float64
	_, _ = v1, v2
	v1 = [2]float64{
		0: -+(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: Float64FromComplex128(z),
	}
	z = Xctanh(tls, *(*complex128)(unsafe.Pointer(&v1)))
	v2 = [2]float64{
		0: +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)],
		1: -Float64FromComplex128(z),
	}
	return *(*complex128)(unsafe.Pointer(&v2))
}

func Xctanf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 [2]float32
	_, _ = v1, v2
	v1 = [2]float32{
		0: -+(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: Float32FromComplex64(z),
	}
	z = Xctanhf(tls, *(*complex64)(unsafe.Pointer(&v1)))
	v2 = [2]float32{
		0: +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)],
		1: -Float32FromComplex64(z),
	}
	return *(*complex64)(unsafe.Pointer(&v2))
}

func Xctanh(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var __u1, v3 Tuint64_t
	var beta, denom, exp_mx, rho, s, t, x, y, v11, v2, v5 float64
	var hx, ix, lx Tuint32_t
	var v1, v10, v12, v13, v4 [2]float64
	var v6, v8 uint64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __u1, beta, denom, exp_mx, hx, ix, lx, rho, s, t, x, y, v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v8
	x = Float64FromComplex128(z)
	y = +(*(*[2]float64)(unsafe.Pointer(&z)))[int32(1)]
	__u1 = *(*Tuint64_t)(unsafe.Pointer(&x))
	hx = uint32(__u1 >> int32(32))
	lx = uint32(__u1)
	ix = hx & uint32(0x7fffffff)
	/*
	 * ctanh(NaN + i 0) = NaN + i 0
	 *
	 * ctanh(NaN + i y) = NaN + i NaN               for y != 0
	 *
	 * The imaginary part has the sign of x*sin(2*y), but there's no
	 * special effort to get this right.
	 *
	 * ctanh(+-Inf +- i Inf) = +-1 +- 0
	 *
	 * ctanh(+-Inf + i y) = +-1 + 0 sin(2y)         for y finite
	 *
	 * The imaginary part of the sign is unspecified.  This special
	 * case is only needed to avoid a spurious invalid exception when
	 * y is infinite.
	 */
	if ix >= uint32(0x7ff00000) {
		if ix&uint32(0xfffff)|lx != 0 { /* x is NaN */
			if y == Float64FromInt32(0) {
				v2 = y
			} else {
				v2 = x * y
			}
			v1 = [2]float64{
				0: x,
				1: v2,
			}
			return *(*complex128)(unsafe.Pointer(&v1))
		}
		v3 = uint64(hx-Uint32FromInt32(0x40000000))<<Int32FromInt32(32) | uint64(uint32(*(*Tuint64_t)(unsafe.Pointer(&x))))
		x = *(*float64)(unsafe.Pointer(&v3)) /* x = copysign(1, x) */
		*(*float64)(unsafe.Pointer(bp)) = y
		v6 = *(*uint64)(unsafe.Pointer(bp))
		goto _7
	_7:
		if BoolInt32(v6&(-Uint64FromUint64(1)>>Int32FromInt32(1)) == Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
			v5 = y
		} else {
			v5 = Xsin(tls, y) * Xcos(tls, y)
		}
		v4 = [2]float64{
			0: x,
			1: Xcopysign(tls, Float64FromInt32(0), v5),
		}
		return *(*complex128)(unsafe.Pointer(&v4))
	}
	/*
	 * ctanh(+-0 + i NAN) = +-0 + i NaN
	 * ctanh(+-0 +- i Inf) = +-0 + i NaN
	 * ctanh(x + i NAN) = NaN + i NaN
	 * ctanh(x +- i Inf) = NaN + i NaN
	 */
	*(*float64)(unsafe.Pointer(bp)) = y
	v8 = *(*uint64)(unsafe.Pointer(bp))
	goto _9
_9:
	if !(BoolInt32(v8&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		if x != 0 {
			v11 = y - y
		} else {
			v11 = x
		}
		v10 = [2]float64{
			0: v11,
			1: y - y,
		}
		return *(*complex128)(unsafe.Pointer(&v10))
	}
	/*
	 * ctanh(+-huge + i +-y) ~= +-1 +- i 2sin(2y)/exp(2x), using the
	 * approximation sinh^2(huge) ~= exp(2*huge) / 4.
	 * We use a modified formula to avoid spurious overflow.
	 */
	if ix >= uint32(0x40360000) { /* x >= 22 */
		exp_mx = Xexp(tls, -Xfabs(tls, x))
		v12 = [2]float64{
			0: Xcopysign(tls, Float64FromInt32(1), x),
			1: Float64FromInt32(4) * Xsin(tls, y) * Xcos(tls, y) * exp_mx * exp_mx,
		}
		return *(*complex128)(unsafe.Pointer(&v12))
	}
	/* Kahan's algorithm */
	t = Xtan(tls, y)
	beta = float64(1) + t*t /* = 1 / cos^2(y) */
	s = Xsinh(tls, x)
	rho = Xsqrt(tls, Float64FromInt32(1)+s*s) /* = cosh(x) */
	denom = Float64FromInt32(1) + beta*s*s
	v13 = [2]float64{
		0: beta * rho * s / denom,
		1: t / denom,
	}
	return *(*complex128)(unsafe.Pointer(&v13))
}

func Xctanhf(tls *TLS, z complex64) (r complex64) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var beta, denom, exp_mx, rho, s, t, x, y, v11, v2, v5 float32
	var hx, ix, v3 Tuint32_t
	var v1, v10, v12, v13, v4 [2]float32
	var v6, v8 uint32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = beta, denom, exp_mx, hx, ix, rho, s, t, x, y, v1, v10, v11, v12, v13, v2, v3, v4, v5, v6, v8
	x = Float32FromComplex64(z)
	y = +(*(*[2]float32)(unsafe.Pointer(&z)))[int32(1)]
	hx = *(*Tuint32_t)(unsafe.Pointer(&x))
	ix = hx & uint32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		if ix&uint32(0x7fffff) != 0 {
			if y == Float32FromInt32(0) {
				v2 = y
			} else {
				v2 = x * y
			}
			v1 = [2]float32{
				0: x,
				1: v2,
			}
			return *(*complex64)(unsafe.Pointer(&v1))
		}
		v3 = hx - uint32(0x40000000)
		x = *(*float32)(unsafe.Pointer(&v3))
		*(*float32)(unsafe.Pointer(bp)) = y
		v6 = *(*uint32)(unsafe.Pointer(bp))
		goto _7
	_7:
		if BoolInt32(v6&uint32(0x7fffffff) == uint32(0x7f800000)) != 0 {
			v5 = y
		} else {
			v5 = Xsinf(tls, y) * Xcosf(tls, y)
		}
		v4 = [2]float32{
			0: x,
			1: Xcopysignf(tls, Float32FromInt32(0), v5),
		}
		return *(*complex64)(unsafe.Pointer(&v4))
	}
	*(*float32)(unsafe.Pointer(bp)) = y
	v8 = *(*uint32)(unsafe.Pointer(bp))
	goto _9
_9:
	if !(BoolInt32(v8&Uint32FromInt32(0x7fffffff) < Uint32FromInt32(0x7f800000)) != 0) {
		if ix != 0 {
			v11 = y - y
		} else {
			v11 = x
		}
		v10 = [2]float32{
			0: v11,
			1: y - y,
		}
		return *(*complex64)(unsafe.Pointer(&v10))
	}
	if ix >= uint32(0x41300000) { /* x >= 11 */
		exp_mx = Xexpf(tls, -Xfabsf(tls, x))
		v12 = [2]float32{
			0: Xcopysignf(tls, Float32FromInt32(1), x),
			1: Float32FromInt32(4) * Xsinf(tls, y) * Xcosf(tls, y) * exp_mx * exp_mx,
		}
		return *(*complex64)(unsafe.Pointer(&v12))
	}
	t = Xtanf(tls, y)
	beta = float32(float64(1) + float64(t*t))
	s = Xsinhf(tls, x)
	rho = Xsqrtf(tls, Float32FromInt32(1)+s*s)
	denom = Float32FromInt32(1) + beta*s*s
	v13 = [2]float32{
		0: beta * rho * s / denom,
		1: t / denom,
	}
	return *(*complex64)(unsafe.Pointer(&v13))
}

// C documentation
//
//	//FIXME
func Xctanhl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xctanh(tls, Complex128FromComplex128(z)))
}

func Xctanl(tls *TLS, z complex128) (r complex128) {
	if __ccgo_strace {
		trc("tls=%v z=%v, (%v:)", tls, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Complex128FromComplex128(Xctan(tls, Complex128FromComplex128(z)))
}

const BUFSIZ = 1024
const E2BIG = 7
const EACCES = 13
const EADDRINUSE = 98
const EADDRNOTAVAIL = 99
const EADV = 68
const EAFNOSUPPORT = 97
const EAGAIN = 11
const EALREADY = 114
const EBADE = 52
const EBADF = 9
const EBADFD = 77
const EBADMSG = 74
const EBADR = 53
const EBADRQC = 56
const EBADSLT = 57
const EBFONT = 59
const EBUSY = 16
const ECANCELED = 125
const ECHILD = 10
const ECHRNG = 44
const ECOMM = 70
const ECONNABORTED = 103
const ECONNREFUSED = 111
const ECONNRESET = 104
const EDEADLK = 35
const EDEADLOCK = 35
const EDESTADDRREQ = 89
const EDOM = 33
const EDOTDOT = 73
const EDQUOT = 122
const EEXIST = 17
const EFAULT = 14
const EFBIG = 27
const EHOSTDOWN = 112
const EHOSTUNREACH = 113
const EHWPOISON = 133
const EIDRM = 43
const EILSEQ = 84
const EINPROGRESS = 115
const EINTR = 4
const EINVAL = 22
const EIO = 5
const EISCONN = 106
const EISDIR = 21
const EISNAM = 120
const EKEYEXPIRED = 127
const EKEYREJECTED = 129
const EKEYREVOKED = 128
const EL2HLT = 51
const EL2NSYNC = 45
const EL3HLT = 46
const EL3RST = 47
const ELIBACC = 79
const ELIBBAD = 80
const ELIBEXEC = 83
const ELIBMAX = 82
const ELIBSCN = 81
const ELNRNG = 48
const ELOOP = 40
const EMEDIUMTYPE = 124
const EMFILE = 24
const EMLINK = 31
const EMSGSIZE = 90
const EMULTIHOP = 72
const ENAMETOOLONG = 36
const ENAVAIL = 119
const ENETDOWN = 100
const ENETRESET = 102
const ENETUNREACH = 101
const ENFILE = 23
const ENOANO = 55
const ENOBUFS = 105
const ENOCSI = 50
const ENODATA = 61
const ENODEV = 19
const ENOENT = 2
const ENOEXEC = 8
const ENOKEY = 126
const ENOLCK = 37
const ENOLINK = 67
const ENOMEDIUM = 123
const ENOMEM = 12
const ENOMSG = 42
const ENONET = 64
const ENOPKG = 65
const ENOPROTOOPT = 92
const ENOSPC = 28
const ENOSR = 63
const ENOSTR = 60
const ENOSYS = 38
const ENOTBLK = 15
const ENOTCONN = 107
const ENOTDIR = 20
const ENOTEMPTY = 39
const ENOTNAM = 118
const ENOTRECOVERABLE = 131
const ENOTSOCK = 88
const ENOTSUP = 95
const ENOTTY = 25
const ENOTUNIQ = 76
const ENXIO = 6
const EOPNOTSUPP = 95
const EOVERFLOW = 75
const EOWNERDEAD = 130
const EPERM = 1
const EPFNOSUPPORT = 96
const EPIPE = 32
const EPROTO = 71
const EPROTONOSUPPORT = 93
const EPROTOTYPE = 91
const ERANGE = 34
const EREMCHG = 78
const EREMOTE = 66
const EREMOTEIO = 121
const ERESTART = 85
const ERFKILL = 132
const EROFS = 30
const ESHUTDOWN = 108
const ESOCKTNOSUPPORT = 94
const ESPIPE = 29
const ESRCH = 3
const ESRMNT = 69
const ESTALE = 116
const ESTRPIPE = 86
const ETIME = 62
const ETIMEDOUT = 110
const ETOOMANYREFS = 109
const ETXTBSY = 26
const EUCLEAN = 117
const EUNATCH = 49
const EUSERS = 87
const EWOULDBLOCK = 11
const EXDEV = 18
const EXFULL = 54
const FILENAME_MAX = 4096
const FOPEN_MAX = 1000
const F_LOCK = 1
const F_OK = 0
const F_TEST = 3
const F_TLOCK = 2
const F_ULOCK = 0
const L_ctermid = 20
const L_tmpnam = 20
const POSIX_CLOSE_RESTART = 0
const P_tmpdir = "/tmp"
const R_OK = 4
const SEEK_DATA = 3
const SEEK_HOLE = 4
const STDERR_FILENO = 2
const STDIN_FILENO = 0
const STDOUT_FILENO = 1
const TMP_MAX = 10000
const W_OK = 2
const X_OK = 1
const _CS_GNU_LIBC_VERSION = 2
const _CS_GNU_LIBPTHREAD_VERSION = 3
const _CS_PATH = 0
const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS = 4
const _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116
const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117
const _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118
const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119
const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120
const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121
const _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122
const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123
const _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124
const _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125
const _CS_POSIX_V6_LP64_OFF64_LIBS = 1126
const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127
const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128
const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129
const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130
const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131
const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = 1
const _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132
const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133
const _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134
const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135
const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136
const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137
const _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138
const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139
const _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140
const _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141
const _CS_POSIX_V7_LP64_OFF64_LIBS = 1142
const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143
const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144
const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145
const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146
const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147
const _CS_POSIX_V7_THREADS_CFLAGS = 1150
const _CS_POSIX_V7_THREADS_LDFLAGS = 1151
const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS = 5
const _CS_V6_ENV = 1148
const _CS_V7_ENV = 1149
const _IOFBF = 0
const _IOLBF = 1
const _IONBF = 2
const _PC_2_SYMLINKS = 20
const _PC_ALLOC_SIZE_MIN = 18
const _PC_ASYNC_IO = 10
const _PC_CHOWN_RESTRICTED = 6
const _PC_FILESIZEBITS = 13
const _PC_LINK_MAX = 0
const _PC_MAX_CANON = 1
const _PC_MAX_INPUT = 2
const _PC_NAME_MAX = 3
const _PC_NO_TRUNC = 7
const _PC_PATH_MAX = 4
const _PC_PIPE_BUF = 5
const _PC_PRIO_IO = 11
const _PC_REC_INCR_XFER_SIZE = 14
const _PC_REC_MAX_XFER_SIZE = 15
const _PC_REC_MIN_XFER_SIZE = 16
const _PC_REC_XFER_ALIGN = 17
const _PC_SOCK_MAXBUF = 12
const _PC_SYMLINK_MAX = 19
const _PC_SYNC_IO = 9
const _PC_VDISABLE = 8
const _POSIX2_C_BIND = 200809
const _POSIX2_VERSION = 200809
const _POSIX_ADVISORY_INFO = 200809
const _POSIX_ASYNCHRONOUS_IO = 200809
const _POSIX_BARRIERS = 200809
const _POSIX_CHOWN_RESTRICTED = 1
const _POSIX_CLOCK_SELECTION = 200809
const _POSIX_CPUTIME = 200809
const _POSIX_FSYNC = 200809
const _POSIX_IPV6 = 200809
const _POSIX_JOB_CONTROL = 1
const _POSIX_MAPPED_FILES = 200809
const _POSIX_MEMLOCK = 200809
const _POSIX_MEMLOCK_RANGE = 200809
const _POSIX_MEMORY_PROTECTION = 200809
const _POSIX_MESSAGE_PASSING = 200809
const _POSIX_MONOTONIC_CLOCK = 200809
const _POSIX_NO_TRUNC = 1
const _POSIX_RAW_SOCKETS = 200809
const _POSIX_READER_WRITER_LOCKS = 200809
const _POSIX_REALTIME_SIGNALS = 200809
const _POSIX_REGEXP = 1
const _POSIX_SAVED_IDS = 1
const _POSIX_SEMAPHORES = 200809
const _POSIX_SHARED_MEMORY_OBJECTS = 200809
const _POSIX_SHELL = 1
const _POSIX_SPAWN = 200809
const _POSIX_SPIN_LOCKS = 200809
const _POSIX_THREADS = 200809
const _POSIX_THREAD_ATTR_STACKADDR = 200809
const _POSIX_THREAD_ATTR_STACKSIZE = 200809
const _POSIX_THREAD_CPUTIME = 200809
const _POSIX_THREAD_PRIORITY_SCHEDULING = 200809
const _POSIX_THREAD_PROCESS_SHARED = 200809
const _POSIX_THREAD_SAFE_FUNCTIONS = 200809
const _POSIX_TIMEOUTS = 200809
const _POSIX_TIMERS = 200809
const _POSIX_V6_LP64_OFF64 = 1
const _POSIX_V7_LP64_OFF64 = 1
const _POSIX_VDISABLE = 0
const _POSIX_VERSION = 200809
const _SC_2_CHAR_TERM = 95
const _SC_2_C_BIND = 47
const _SC_2_C_DEV = 48
const _SC_2_FORT_DEV = 49
const _SC_2_FORT_RUN = 50
const _SC_2_LOCALEDEF = 52
const _SC_2_PBS = 168
const _SC_2_PBS_ACCOUNTING = 169
const _SC_2_PBS_CHECKPOINT = 175
const _SC_2_PBS_LOCATE = 170
const _SC_2_PBS_MESSAGE = 171
const _SC_2_PBS_TRACK = 172
const _SC_2_SW_DEV = 51
const _SC_2_UPE = 97
const _SC_2_VERSION = 46
const _SC_ADVISORY_INFO = 132
const _SC_AIO_LISTIO_MAX = 23
const _SC_AIO_MAX = 24
const _SC_AIO_PRIO_DELTA_MAX = 25
const _SC_ARG_MAX = 0
const _SC_ASYNCHRONOUS_IO = 12
const _SC_ATEXIT_MAX = 87
const _SC_AVPHYS_PAGES = 86
const _SC_BARRIERS = 133
const _SC_BC_BASE_MAX = 36
const _SC_BC_DIM_MAX = 37
const _SC_BC_SCALE_MAX = 38
const _SC_BC_STRING_MAX = 39
const _SC_CHILD_MAX = 1
const _SC_CLK_TCK = 2
const _SC_CLOCK_SELECTION = 137
const _SC_COLL_WEIGHTS_MAX = 40
const _SC_CPUTIME = 138
const _SC_DELAYTIMER_MAX = 26
const _SC_EXPR_NEST_MAX = 42
const _SC_FSYNC = 15
const _SC_GETGR_R_SIZE_MAX = 69
const _SC_GETPW_R_SIZE_MAX = 70
const _SC_HOST_NAME_MAX = 180
const _SC_IOV_MAX = 60
const _SC_IPV6 = 235
const _SC_JOB_CONTROL = 7
const _SC_LINE_MAX = 43
const _SC_LOGIN_NAME_MAX = 71
const _SC_MAPPED_FILES = 16
const _SC_MEMLOCK = 17
const _SC_MEMLOCK_RANGE = 18
const _SC_MEMORY_PROTECTION = 19
const _SC_MESSAGE_PASSING = 20
const _SC_MINSIGSTKSZ = 249
const _SC_MONOTONIC_CLOCK = 149
const _SC_MQ_OPEN_MAX = 27
const _SC_MQ_PRIO_MAX = 28
const _SC_NGROUPS_MAX = 3
const _SC_NPROCESSORS_CONF = 83
const _SC_NPROCESSORS_ONLN = 84
const _SC_NZERO = 109
const _SC_OPEN_MAX = 4
const _SC_PAGESIZE = 30
const _SC_PAGE_SIZE = 30
const _SC_PASS_MAX = 88
const _SC_PHYS_PAGES = 85
const _SC_PRIORITIZED_IO = 13
const _SC_PRIORITY_SCHEDULING = 10
const _SC_RAW_SOCKETS = 236
const _SC_READER_WRITER_LOCKS = 153
const _SC_REALTIME_SIGNALS = 9
const _SC_REGEXP = 155
const _SC_RE_DUP_MAX = 44
const _SC_RTSIG_MAX = 31
const _SC_SAVED_IDS = 8
const _SC_SEMAPHORES = 21
const _SC_SEM_NSEMS_MAX = 32
const _SC_SEM_VALUE_MAX = 33
const _SC_SHARED_MEMORY_OBJECTS = 22
const _SC_SHELL = 157
const _SC_SIGQUEUE_MAX = 34
const _SC_SIGSTKSZ = 250
const _SC_SPAWN = 159
const _SC_SPIN_LOCKS = 154
const _SC_SPORADIC_SERVER = 160
const _SC_SS_REPL_MAX = 241
const _SC_STREAMS = 174
const _SC_STREAM_MAX = 5
const _SC_SYMLOOP_MAX = 173
const _SC_SYNCHRONIZED_IO = 14
const _SC_THREADS = 67
const _SC_THREAD_ATTR_STACKADDR = 77
const _SC_THREAD_ATTR_STACKSIZE = 78
const _SC_THREAD_CPUTIME = 139
const _SC_THREAD_DESTRUCTOR_ITERATIONS = 73
const _SC_THREAD_KEYS_MAX = 74
const _SC_THREAD_PRIORITY_SCHEDULING = 79
const _SC_THREAD_PRIO_INHERIT = 80
const _SC_THREAD_PRIO_PROTECT = 81
const _SC_THREAD_PROCESS_SHARED = 82
const _SC_THREAD_ROBUST_PRIO_INHERIT = 247
const _SC_THREAD_ROBUST_PRIO_PROTECT = 248
const _SC_THREAD_SAFE_FUNCTIONS = 68
const _SC_THREAD_SPORADIC_SERVER = 161
const _SC_THREAD_STACK_MIN = 75
const _SC_THREAD_THREADS_MAX = 76
const _SC_TIMEOUTS = 164
const _SC_TIMERS = 11
const _SC_TIMER_MAX = 35
const _SC_TRACE = 181
const _SC_TRACE_EVENT_FILTER = 182
const _SC_TRACE_EVENT_NAME_MAX = 242
const _SC_TRACE_INHERIT = 183
const _SC_TRACE_LOG = 184
const _SC_TRACE_NAME_MAX = 243
const _SC_TRACE_SYS_MAX = 244
const _SC_TRACE_USER_EVENT_MAX = 245
const _SC_TTY_NAME_MAX = 72
const _SC_TYPED_MEMORY_OBJECTS = 165
const _SC_TZNAME_MAX = 6
const _SC_UIO_MAXIOV = 60
const _SC_V6_ILP32_OFF32 = 176
const _SC_V6_ILP32_OFFBIG = 177
const _SC_V6_LP64_OFF64 = 178
const _SC_V6_LPBIG_OFFBIG = 179
const _SC_V7_ILP32_OFF32 = 237
const _SC_V7_ILP32_OFFBIG = 238
const _SC_V7_LP64_OFF64 = 239
const _SC_V7_LPBIG_OFFBIG = 240
const _SC_VERSION = 29
const _SC_XBS5_ILP32_OFF32 = 125
const _SC_XBS5_ILP32_OFFBIG = 126
const _SC_XBS5_LP64_OFF64 = 127
const _SC_XBS5_LPBIG_OFFBIG = 128
const _SC_XOPEN_CRYPT = 92
const _SC_XOPEN_ENH_I18N = 93
const _SC_XOPEN_LEGACY = 129
const _SC_XOPEN_REALTIME = 130
const _SC_XOPEN_REALTIME_THREADS = 131
const _SC_XOPEN_SHM = 94
const _SC_XOPEN_STREAMS = 246
const _SC_XOPEN_UNIX = 91
const _SC_XOPEN_VERSION = 89
const _SC_XOPEN_XCU_VERSION = 90
const _SC_XOPEN_XPG2 = 98
const _SC_XOPEN_XPG3 = 99
const _SC_XOPEN_XPG4 = 100
const _XOPEN_ENH_I18N = 1
const _XOPEN_UNIX = 1
const _XOPEN_VERSION = 700

type Tsize_t = uint64

type Tssize_t = int64

type Toff_t = int64

type Tpid_t = int32

type Tuid_t = uint32

type Tgid_t = uint32

type Tuseconds_t = uint32

type Tva_list = uintptr

type t__isoc_va_list = uintptr

type Tfpos_t = struct {
	F__lldata [0]int64
	F__align  [0]float64
	F__opaque [16]uint8
}

type T_G_fpos64_t = Tfpos_t

func Xconfstr(tls *TLS, name int32, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v name=%v buf=%v len1=%v, (%v:)", tls, name, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var s uintptr
	_ = s
	s = __ccgo_ts
	if !(name != 0) {
		s = __ccgo_ts + 1
	} else {
		if uint32(name) & ^Uint32FromUint32(4) != uint32(1) && uint32(name-int32(_CS_POSIX_V6_ILP32_OFF32_CFLAGS)) > uint32(35) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
			return uint64(0)
		}
	}
	// snprintf is overkill but avoid wasting code size to implement
	// this completely useless function and its truncation semantics
	return uint64(Xsnprintf(tls, buf, len1, __ccgo_ts+15, VaList(bp+8, s)) + int32(1))
}

const ARG_MAX = 131072
const BC_BASE_MAX = 99
const BC_DIM_MAX = 2048
const BC_SCALE_MAX = 99
const BC_STRING_MAX = 1000
const CHARCLASS_NAME_MAX = 14
const CHAR_BIT = 8
const CHAR_MAX = 255
const CHAR_MIN = 0
const COLL_WEIGHTS_MAX = 2
const DELAYTIMER_MAX = 2147483647
const EXPR_NEST_MAX = 32
const FILESIZEBITS = 64
const HOST_NAME_MAX = 255
const INT_MAX = 2147483647
const INT_MIN = -2147483648
const IOV_MAX = 1024
const LINE_MAX = 4096
const LLONG_MAX = 9223372036854775807
const LLONG_MIN = -9223372036854775808
const LOGIN_NAME_MAX = 256
const LONG_BIT = 64
const LONG_MAX = 9223372036854775807
const LONG_MIN = -9223372036854775808
const MB_LEN_MAX = 4
const MQ_PRIO_MAX = 32768
const NAME_MAX = 255
const NGROUPS_MAX = 32
const NL_ARGMAX = 9
const NL_LANGMAX = 32
const NL_MSGMAX = 32767
const NL_SETMAX = 255
const NL_TEXTMAX = 2048
const NZERO = 20
const PATH_MAX = 4096
const PIPE_BUF = 4096
const PTHREAD_DESTRUCTOR_ITERATIONS = 4
const PTHREAD_KEYS_MAX = 128
const PTHREAD_STACK_MIN = 2048
const RE_DUP_MAX = 255
const SCHAR_MAX = 127
const SCHAR_MIN = -128
const SEEK_CUR = 1
const SEEK_END = 2
const SEEK_SET = 0
const SEM_NSEMS_MAX = 256
const SEM_VALUE_MAX = 2147483647
const SHRT_MAX = 32767
const SHRT_MIN = -32768
const SSIZE_MAX = 9223372036854775807
const SYMLOOP_MAX = 40
const TTY_NAME_MAX = 32
const TZNAME_MAX = 6
const UCHAR_MAX = 255
const UINT_MAX = 4294967295
const ULLONG_MAX = 18446744073709551615
const ULONG_MAX = 18446744073709551615
const USHRT_MAX = 65535
const WORD_BIT = 32
const _POSIX2_BC_BASE_MAX = 99
const _POSIX2_BC_DIM_MAX = 2048
const _POSIX2_BC_SCALE_MAX = 99
const _POSIX2_BC_STRING_MAX = 1000
const _POSIX2_CHARCLASS_NAME_MAX = 14
const _POSIX2_COLL_WEIGHTS_MAX = 2
const _POSIX2_EXPR_NEST_MAX = 32
const _POSIX2_LINE_MAX = 2048
const _POSIX2_RE_DUP_MAX = 255
const _POSIX_AIO_LISTIO_MAX = 2
const _POSIX_AIO_MAX = 1
const _POSIX_ARG_MAX = 4096
const _POSIX_CHILD_MAX = 25
const _POSIX_CLOCKRES_MIN = 20000000
const _POSIX_DELAYTIMER_MAX = 32
const _POSIX_HOST_NAME_MAX = 255
const _POSIX_LINK_MAX = 8
const _POSIX_LOGIN_NAME_MAX = 9
const _POSIX_MAX_CANON = 255
const _POSIX_MAX_INPUT = 255
const _POSIX_MQ_OPEN_MAX = 8
const _POSIX_MQ_PRIO_MAX = 32
const _POSIX_NAME_MAX = 14
const _POSIX_NGROUPS_MAX = 8
const _POSIX_OPEN_MAX = 20
const _POSIX_PATH_MAX = 256
const _POSIX_PIPE_BUF = 512
const _POSIX_RE_DUP_MAX = 255
const _POSIX_RTSIG_MAX = 8
const _POSIX_SEM_NSEMS_MAX = 256
const _POSIX_SEM_VALUE_MAX = 32767
const _POSIX_SIGQUEUE_MAX = 32
const _POSIX_SSIZE_MAX = 32767
const _POSIX_SS_REPL_MAX = 4
const _POSIX_STREAM_MAX = 8
const _POSIX_SYMLINK_MAX = 255
const _POSIX_SYMLOOP_MAX = 8
const _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4
const _POSIX_THREAD_KEYS_MAX = 128
const _POSIX_THREAD_THREADS_MAX = 64
const _POSIX_TIMER_MAX = 32
const _POSIX_TRACE_EVENT_NAME_MAX = 30
const _POSIX_TRACE_NAME_MAX = 8
const _POSIX_TRACE_SYS_MAX = 8
const _POSIX_TRACE_USER_EVENT_MAX = 32
const _POSIX_TTY_NAME_MAX = 9
const _POSIX_TZNAME_MAX = 6
const _XOPEN_IOV_MAX = 16
const _XOPEN_NAME_MAX = 255
const _XOPEN_PATH_MAX = 1024

func Xfpathconf(tls *TLS, fd int32, name int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v fd=%v name=%v, (%v:)", tls, fd, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if uint64(name) >= Uint64FromInt64(42)/Uint64FromInt64(2) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return int64(-int32(1))
	}
	return int64(_values[name])
}

var _values = [21]int16{
	0:  int16(_POSIX_LINK_MAX),
	1:  int16(_POSIX_MAX_CANON),
	2:  int16(_POSIX_MAX_INPUT),
	3:  int16(NAME_MAX),
	4:  int16(PATH_MAX),
	5:  int16(PIPE_BUF),
	6:  int16(1),
	7:  int16(1),
	9:  int16(1),
	10: int16(-int32(1)),
	11: int16(-int32(1)),
	12: int16(-int32(1)),
	13: int16(FILESIZEBITS),
	14: int16(4096),
	15: int16(4096),
	16: int16(4096),
	17: int16(4096),
	18: int16(4096),
	19: int16(-int32(1)),
	20: int16(1),
}

const SI_LOAD_SHIFT = 16

type Tsysinfo = struct {
	Fuptime     uint64
	Floads      [3]uint64
	Ftotalram   uint64
	Ffreeram    uint64
	Fsharedram  uint64
	Fbufferram  uint64
	Ftotalswap  uint64
	Ffreeswap   uint64
	Fprocs      uint16
	Fpad        uint16
	Ftotalhigh  uint64
	Ffreehigh   uint64
	Fmem_unit   uint32
	F__reserved [256]uint8
}

func Xget_nprocs_conf(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(Xsysconf(tls, int32(_SC_NPROCESSORS_CONF)))
}

func Xget_nprocs(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(Xsysconf(tls, int32(_SC_NPROCESSORS_ONLN)))
}

func Xget_phys_pages(tls *TLS) (r int64) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsysconf(tls, int32(_SC_PHYS_PAGES))
}

func Xget_avphys_pages(tls *TLS) (r int64) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsysconf(tls, int32(_SC_AVPHYS_PAGES))
}

func Xpathconf(tls *TLS, path uintptr, name int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v path=%v name=%v, (%v:)", tls, path, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfpathconf(tls, -int32(1), name)
}

const AT_BASE = 7
const AT_BASE_PLATFORM = 24
const AT_CLKTCK = 17
const AT_DCACHEBSIZE = 19
const AT_EGID = 14
const AT_ENTRY = 9
const AT_EUID = 12
const AT_EXECFD = 2
const AT_EXECFN = 31
const AT_FLAGS = 8
const AT_FPUCW = 18
const AT_GID = 13
const AT_HWCAP = 16
const AT_HWCAP2 = 26
const AT_ICACHEBSIZE = 20
const AT_IGNORE = 1
const AT_IGNOREPPC = 22
const AT_L1D_CACHEGEOMETRY = 43
const AT_L1D_CACHESHAPE = 35
const AT_L1D_CACHESIZE = 42
const AT_L1I_CACHEGEOMETRY = 41
const AT_L1I_CACHESHAPE = 34
const AT_L1I_CACHESIZE = 40
const AT_L2_CACHEGEOMETRY = 45
const AT_L2_CACHESHAPE = 36
const AT_L2_CACHESIZE = 44
const AT_L3_CACHEGEOMETRY = 47
const AT_L3_CACHESHAPE = 37
const AT_L3_CACHESIZE = 46
const AT_MINSIGSTKSZ = 51
const AT_NOTELF = 10
const AT_NULL = 0
const AT_PAGESZ = 6
const AT_PHDR = 3
const AT_PHENT = 4
const AT_PHNUM = 5
const AT_PLATFORM = 15
const AT_RANDOM = 25
const AT_SECURE = 23
const AT_SYSINFO = 32
const AT_SYSINFO_EHDR = 33
const AT_UCACHEBSIZE = 21
const AT_UID = 11
const BUS_ADRALN = 1
const BUS_ADRERR = 2
const BUS_MCEERR_AO = 5
const BUS_MCEERR_AR = 4
const BUS_OBJERR = 3
const CLD_CONTINUED = 6
const CLD_DUMPED = 3
const CLD_EXITED = 1
const CLD_KILLED = 2
const CLD_STOPPED = 5
const CLD_TRAPPED = 4
const DF_1_CONFALT = 8192
const DF_1_DIRECT = 256
const DF_1_DISPRELDNE = 32768
const DF_1_DISPRELPND = 65536
const DF_1_EDITED = 2097152
const DF_1_ENDFILTEE = 16384
const DF_1_GLOBAL = 2
const DF_1_GLOBAUDIT = 16777216
const DF_1_GROUP = 4
const DF_1_IGNMULDEF = 262144
const DF_1_INITFIRST = 32
const DF_1_INTERPOSE = 1024
const DF_1_LOADFLTR = 16
const DF_1_NODEFLIB = 2048
const DF_1_NODELETE = 8
const DF_1_NODIRECT = 131072
const DF_1_NODUMP = 4096
const DF_1_NOHDR = 1048576
const DF_1_NOKSYMS = 524288
const DF_1_NOOPEN = 64
const DF_1_NORELOC = 4194304
const DF_1_NOW = 1
const DF_1_ORIGIN = 128
const DF_1_PIE = 134217728
const DF_1_SINGLETON = 33554432
const DF_1_STUB = 67108864
const DF_1_SYMINTPOSE = 8388608
const DF_1_TRANS = 512
const DF_BIND_NOW = 8
const DF_ORIGIN = 1
const DF_P1_GROUPPERM = 2
const DF_P1_LAZYLOAD = 1
const DF_STATIC_TLS = 16
const DF_SYMBOLIC = 2
const DF_TEXTREL = 4
const DTF_1_CONFEXP = 2
const DTF_1_PARINIT = 1
const DT_ADDRNUM = 11
const DT_ADDRRNGHI = 1879047935
const DT_ADDRRNGLO = 1879047680
const DT_ALPHA_NUM = 1
const DT_ALPHA_PLTRO = 1879048192
const DT_AUDIT = 1879047932
const DT_AUXILIARY = 2147483645
const DT_BIND_NOW = 24
const DT_CHECKSUM = 1879047672
const DT_CONFIG = 1879047930
const DT_DEBUG = 21
const DT_DEPAUDIT = 1879047931
const DT_ENCODING = 32
const DT_EXTRANUM = 3
const DT_FEATURE_1 = 1879047676
const DT_FILTER = 2147483647
const DT_FINI = 13
const DT_FINI_ARRAY = 26
const DT_FINI_ARRAYSZ = 28
const DT_FLAGS = 30
const DT_FLAGS_1 = 1879048187
const DT_GNU_CONFLICT = 1879047928
const DT_GNU_CONFLICTSZ = 1879047670
const DT_GNU_HASH = 1879047925
const DT_GNU_LIBLIST = 1879047929
const DT_GNU_LIBLISTSZ = 1879047671
const DT_GNU_PRELINKED = 1879047669
const DT_HASH = 4
const DT_HIOS = 1879044096
const DT_HIPROC = 2147483647
const DT_IA_64_NUM = 1
const DT_IA_64_PLT_RESERVE = 1879048192
const DT_INIT = 12
const DT_INIT_ARRAY = 25
const DT_INIT_ARRAYSZ = 27
const DT_JMPREL = 23
const DT_LOOS = 1610612749
const DT_LOPROC = 1879048192
const DT_MIPS_AUX_DYNAMIC = 1879048241
const DT_MIPS_BASE_ADDRESS = 1879048198
const DT_MIPS_COMPACT_SIZE = 1879048239
const DT_MIPS_CONFLICT = 1879048200
const DT_MIPS_CONFLICTNO = 1879048203
const DT_MIPS_CXX_FLAGS = 1879048226
const DT_MIPS_DELTA_CLASS = 1879048215
const DT_MIPS_DELTA_CLASSSYM = 1879048224
const DT_MIPS_DELTA_CLASSSYM_NO = 1879048225
const DT_MIPS_DELTA_CLASS_NO = 1879048216
const DT_MIPS_DELTA_INSTANCE = 1879048217
const DT_MIPS_DELTA_INSTANCE_NO = 1879048218
const DT_MIPS_DELTA_RELOC = 1879048219
const DT_MIPS_DELTA_RELOC_NO = 1879048220
const DT_MIPS_DELTA_SYM = 1879048221
const DT_MIPS_DELTA_SYM_NO = 1879048222
const DT_MIPS_DYNSTR_ALIGN = 1879048235
const DT_MIPS_FLAGS = 1879048197
const DT_MIPS_GOTSYM = 1879048211
const DT_MIPS_GP_VALUE = 1879048240
const DT_MIPS_HIDDEN_GOTIDX = 1879048231
const DT_MIPS_HIPAGENO = 1879048212
const DT_MIPS_ICHECKSUM = 1879048195
const DT_MIPS_INTERFACE = 1879048234
const DT_MIPS_INTERFACE_SIZE = 1879048236
const DT_MIPS_IVERSION = 1879048196
const DT_MIPS_LIBLIST = 1879048201
const DT_MIPS_LIBLISTNO = 1879048208
const DT_MIPS_LOCALPAGE_GOTIDX = 1879048229
const DT_MIPS_LOCAL_GOTIDX = 1879048230
const DT_MIPS_LOCAL_GOTNO = 1879048202
const DT_MIPS_MSYM = 1879048199
const DT_MIPS_NUM = 54
const DT_MIPS_OPTIONS = 1879048233
const DT_MIPS_PERF_SUFFIX = 1879048238
const DT_MIPS_PIXIE_INIT = 1879048227
const DT_MIPS_PLTGOT = 1879048242
const DT_MIPS_PROTECTED_GOTIDX = 1879048232
const DT_MIPS_RLD_MAP = 1879048214
const DT_MIPS_RLD_MAP_REL = 1879048245
const DT_MIPS_RLD_TEXT_RESOLVE_ADDR = 1879048237
const DT_MIPS_RLD_VERSION = 1879048193
const DT_MIPS_RWPLT = 1879048244
const DT_MIPS_SYMBOL_LIB = 1879048228
const DT_MIPS_SYMTABNO = 1879048209
const DT_MIPS_TIME_STAMP = 1879048194
const DT_MIPS_UNREFEXTNO = 1879048210
const DT_MOVEENT = 1879047674
const DT_MOVESZ = 1879047675
const DT_MOVETAB = 1879047934
const DT_NEEDED = 1
const DT_NIOS2_GP = 1879048194
const DT_NULL = 0
const DT_NUM = 38
const DT_PLTGOT = 3
const DT_PLTPAD = 1879047933
const DT_PLTPADSZ = 1879047673
const DT_PLTREL = 20
const DT_PLTRELSZ = 2
const DT_POSFLAG_1 = 1879047677
const DT_PPC64_GLINK = 1879048192
const DT_PPC64_NUM = 4
const DT_PPC64_OPD = 1879048193
const DT_PPC64_OPDSZ = 1879048194
const DT_PPC64_OPT = 1879048195
const DT_PPC_GOT = 1879048192
const DT_PPC_NUM = 2
const DT_PPC_OPT = 1879048193
const DT_PREINIT_ARRAY = 32
const DT_PREINIT_ARRAYSZ = 33
const DT_PROCNUM = 54
const DT_REL = 17
const DT_RELA = 7
const DT_RELACOUNT = 1879048185
const DT_RELAENT = 9
const DT_RELASZ = 8
const DT_RELCOUNT = 1879048186
const DT_RELENT = 19
const DT_RELR = 36
const DT_RELRENT = 37
const DT_RELRSZ = 35
const DT_RELSZ = 18
const DT_RPATH = 15
const DT_RUNPATH = 29
const DT_SONAME = 14
const DT_SPARC_NUM = 2
const DT_SPARC_REGISTER = 1879048193
const DT_STRSZ = 10
const DT_STRTAB = 5
const DT_SYMBOLIC = 16
const DT_SYMENT = 11
const DT_SYMINENT = 1879047679
const DT_SYMINFO = 1879047935
const DT_SYMINSZ = 1879047678
const DT_SYMTAB = 6
const DT_SYMTAB_SHNDX = 34
const DT_TEXTREL = 22
const DT_TLSDESC_GOT = 1879047927
const DT_TLSDESC_PLT = 1879047926
const DT_VALNUM = 12
const DT_VALRNGHI = 1879047679
const DT_VALRNGLO = 1879047424
const DT_VERDEF = 1879048188
const DT_VERDEFNUM = 1879048189
const DT_VERNEED = 1879048190
const DT_VERNEEDNUM = 1879048191
const DT_VERSIONTAGNUM = 16
const DT_VERSYM = 1879048176
const EFA_PARISC_1_0 = 523
const EFA_PARISC_1_1 = 528
const EFA_PARISC_2_0 = 532
const EF_ALPHA_32BIT = 1
const EF_ALPHA_CANRELAX = 2
const EF_ARM_ABI_FLOAT_HARD = 1024
const EF_ARM_ABI_FLOAT_SOFT = 512
const EF_ARM_ALIGN8 = 64
const EF_ARM_APCS_26 = 8
const EF_ARM_APCS_FLOAT = 16
const EF_ARM_BE8 = 8388608
const EF_ARM_DYNSYMSUSESEGIDX = 8
const EF_ARM_EABIMASK = 4278190080
const EF_ARM_EABI_UNKNOWN = 0
const EF_ARM_EABI_VER1 = 16777216
const EF_ARM_EABI_VER2 = 33554432
const EF_ARM_EABI_VER3 = 50331648
const EF_ARM_EABI_VER4 = 67108864
const EF_ARM_EABI_VER5 = 83886080
const EF_ARM_HASENTRY = 2
const EF_ARM_INTERWORK = 4
const EF_ARM_LE8 = 4194304
const EF_ARM_MAPSYMSFIRST = 16
const EF_ARM_MAVERICK_FLOAT = 2048
const EF_ARM_NEW_ABI = 128
const EF_ARM_OLD_ABI = 256
const EF_ARM_PIC = 32
const EF_ARM_RELEXEC = 1
const EF_ARM_SOFT_FLOAT = 512
const EF_ARM_SYMSARESORTED = 4
const EF_ARM_VFP_FLOAT = 1024
const EF_CPU32 = 8454144
const EF_IA_64_ABI64 = 16
const EF_IA_64_ARCH = 4278190080
const EF_IA_64_MASKOS = 15
const EF_LARCH_ABI_DOUBLE_FLOAT = 3
const EF_LARCH_ABI_MODIFIER_MASK = 7
const EF_LARCH_ABI_SINGLE_FLOAT = 2
const EF_LARCH_ABI_SOFT_FLOAT = 1
const EF_LARCH_OBJABI_V1 = 64
const EF_MIPS_64BIT_WHIRL = 16
const EF_MIPS_ABI2 = 32
const EF_MIPS_ABI_ON32 = 64
const EF_MIPS_ARCH = 4026531840
const EF_MIPS_ARCH_1 = 0
const EF_MIPS_ARCH_2 = 268435456
const EF_MIPS_ARCH_3 = 536870912
const EF_MIPS_ARCH_32 = 1342177280
const EF_MIPS_ARCH_32R2 = 1879048192
const EF_MIPS_ARCH_4 = 805306368
const EF_MIPS_ARCH_5 = 1073741824
const EF_MIPS_ARCH_64 = 1610612736
const EF_MIPS_ARCH_64R2 = 2147483648
const EF_MIPS_CPIC = 4
const EF_MIPS_FP64 = 512
const EF_MIPS_NAN2008 = 1024
const EF_MIPS_NOREORDER = 1
const EF_MIPS_PIC = 2
const EF_MIPS_XGOT = 8
const EF_PARISC_ARCH = 65535
const EF_PARISC_EXT = 131072
const EF_PARISC_LAZYSWAP = 4194304
const EF_PARISC_LSB = 262144
const EF_PARISC_NO_KABP = 1048576
const EF_PARISC_TRAPNIL = 65536
const EF_PARISC_WIDE = 524288
const EF_PPC64_ABI = 3
const EF_PPC_EMB = 2147483648
const EF_PPC_RELOCATABLE = 65536
const EF_PPC_RELOCATABLE_LIB = 32768
const EF_SH1 = 1
const EF_SH2 = 2
const EF_SH2A = 13
const EF_SH2A_NOFPU = 19
const EF_SH2A_SH3E = 24
const EF_SH2A_SH3_NOFPU = 22
const EF_SH2A_SH4 = 23
const EF_SH2A_SH4_NOFPU = 21
const EF_SH2E = 11
const EF_SH3 = 3
const EF_SH3E = 8
const EF_SH3_DSP = 5
const EF_SH3_NOMMU = 20
const EF_SH4 = 9
const EF_SH4A = 12
const EF_SH4AL_DSP = 6
const EF_SH4A_NOFPU = 17
const EF_SH4_NOFPU = 16
const EF_SH4_NOMMU_NOFPU = 18
const EF_SH_DSP = 4
const EF_SH_MACH_MASK = 31
const EF_SH_UNKNOWN = 0
const EF_SPARCV9_MM = 3
const EF_SPARCV9_PSO = 1
const EF_SPARCV9_RMO = 2
const EF_SPARCV9_TSO = 0
const EF_SPARC_32PLUS = 256
const EF_SPARC_EXT_MASK = 16776960
const EF_SPARC_HAL_R1 = 1024
const EF_SPARC_LEDATA = 8388608
const EF_SPARC_SUN_US1 = 512
const EF_SPARC_SUN_US3 = 2048
const EI_ABIVERSION = 8
const EI_CLASS = 4
const EI_DATA = 5
const EI_MAG0 = 0
const EI_MAG1 = 1
const EI_MAG2 = 2
const EI_MAG3 = 3
const EI_NIDENT = 16
const EI_OSABI = 7
const EI_PAD = 9
const EI_VERSION = 6
const ELFCLASS32 = 1
const ELFCLASS64 = 2
const ELFCLASSNONE = 0
const ELFCLASSNUM = 3
const ELFCOMPRESS_HIOS = 1879048191
const ELFCOMPRESS_HIPROC = 2147483647
const ELFCOMPRESS_LOOS = 1610612736
const ELFCOMPRESS_LOPROC = 1879048192
const ELFCOMPRESS_ZLIB = 1
const ELFCOMPRESS_ZSTD = 2
const ELFDATA2LSB = 1
const ELFDATA2MSB = 2
const ELFDATANONE = 0
const ELFDATANUM = 3
const ELFMAG = "\\177ELF"
const ELFMAG0 = 127
const ELFMAG1 = 69
const ELFMAG2 = 76
const ELFMAG3 = 70
const ELFOSABI_AIX = 7
const ELFOSABI_ARM = 97
const ELFOSABI_FREEBSD = 9
const ELFOSABI_GNU = 3
const ELFOSABI_HPUX = 1
const ELFOSABI_IRIX = 8
const ELFOSABI_LINUX = 3
const ELFOSABI_MODESTO = 11
const ELFOSABI_NETBSD = 2
const ELFOSABI_NONE = 0
const ELFOSABI_OPENBSD = 12
const ELFOSABI_SOLARIS = 6
const ELFOSABI_STANDALONE = 255
const ELFOSABI_SYSV = 0
const ELFOSABI_TRU64 = 10
const ELF_NOTE_ABI = 1
const ELF_NOTE_GNU = "GNU"
const ELF_NOTE_OS_FREEBSD = 3
const ELF_NOTE_OS_GNU = 1
const ELF_NOTE_OS_LINUX = 0
const ELF_NOTE_OS_SOLARIS2 = 2
const ELF_NOTE_PAGESIZE_HINT = 1
const ELF_NOTE_SOLARIS = "SUNW Solaris"
const EM_386 = 3
const EM_56800EX = 200
const EM_68HC05 = 72
const EM_68HC08 = 71
const EM_68HC11 = 70
const EM_68HC12 = 53
const EM_68HC16 = 69
const EM_68K = 4
const EM_78KOR = 199
const EM_8051 = 165
const EM_860 = 7
const EM_88K = 5
const EM_960 = 19
const EM_AARCH64 = 183
const EM_ALPHA = 36902
const EM_ALTERA_NIOS2 = 113
const EM_AMDGPU = 224
const EM_ARC = 45
const EM_ARCA = 109
const EM_ARC_A5 = 93
const EM_ARC_COMPACT = 93
const EM_ARC_COMPACT2 = 195
const EM_ARM = 40
const EM_AVR = 83
const EM_AVR32 = 185
const EM_BA1 = 201
const EM_BA2 = 202
const EM_BLACKFIN = 106
const EM_BPF = 247
const EM_C166 = 116
const EM_CDP = 215
const EM_CE = 119
const EM_CLOUDSHIELD = 192
const EM_COGE = 216
const EM_COLDFIRE = 52
const EM_COOL = 217
const EM_COREA_1ST = 193
const EM_COREA_2ND = 194
const EM_CR = 103
const EM_CR16 = 177
const EM_CRAYNV2 = 172
const EM_CRIS = 76
const EM_CRX = 114
const EM_CSKY = 252
const EM_CSR_KALIMBA = 219
const EM_CUDA = 190
const EM_CYPRESS_M8C = 161
const EM_D10V = 85
const EM_D30V = 86
const EM_DSP24 = 136
const EM_DSPIC30F = 118
const EM_DXP = 112
const EM_ECOG16 = 176
const EM_ECOG1X = 168
const EM_ECOG2 = 134
const EM_EMX16 = 212
const EM_EMX8 = 213
const EM_ETPU = 178
const EM_EXCESS = 111
const EM_F2MC16 = 104
const EM_FAKE_ALPHA = 41
const EM_FIREPATH = 78
const EM_FR20 = 37
const EM_FR30 = 84
const EM_FT32 = 222
const EM_FX66 = 66
const EM_H8S = 48
const EM_H8_300 = 46
const EM_H8_300H = 47
const EM_H8_500 = 49
const EM_HUANY = 81
const EM_IA_64 = 50
const EM_IP2K = 101
const EM_JAVELIN = 77
const EM_K10M = 181
const EM_KM32 = 210
const EM_KMX32 = 211
const EM_KVARC = 214
const EM_L10M = 180
const EM_LATTICEMICO32 = 138
const EM_LOONGARCH = 258
const EM_M16C = 117
const EM_M32 = 1
const EM_M32C = 120
const EM_M32R = 88
const EM_MANIK = 171
const EM_MAX = 102
const EM_MAXQ30 = 169
const EM_MCHP_PIC = 204
const EM_MCST_ELBRUS = 175
const EM_ME16 = 59
const EM_METAG = 174
const EM_MICROBLAZE = 189
const EM_MIPS = 8
const EM_MIPS_RS3_LE = 10
const EM_MIPS_X = 51
const EM_MMA = 54
const EM_MMDSP_PLUS = 160
const EM_MMIX = 80
const EM_MN10200 = 90
const EM_MN10300 = 89
const EM_MOXIE = 223
const EM_MSP430 = 105
const EM_NCPU = 56
const EM_NDR1 = 57
const EM_NDS32 = 167
const EM_NONE = 0
const EM_NORC = 218
const EM_NS32K = 97
const EM_NUM = 259
const EM_OPEN8 = 196
const EM_OPENRISC = 92
const EM_OR1K = 92
const EM_PARISC = 15
const EM_PCP = 55
const EM_PDSP = 63
const EM_PJ = 91
const EM_PPC = 20
const EM_PPC64 = 21
const EM_PRISM = 82
const EM_QDSP6 = 164
const EM_R32C = 162
const EM_RCE = 39
const EM_RH32 = 38
const EM_RISCV = 243
const EM_RL78 = 197
const EM_RS08 = 132
const EM_RX = 173
const EM_S370 = 9
const EM_S390 = 22
const EM_SCORE7 = 135
const EM_SEP = 108
const EM_SE_C17 = 139
const EM_SE_C33 = 107
const EM_SH = 42
const EM_SHARC = 133
const EM_SLE9X = 179
const EM_SNP1K = 99
const EM_SPARC = 2
const EM_SPARC32PLUS = 18
const EM_SPARCV9 = 43
const EM_ST100 = 60
const EM_ST19 = 74
const EM_ST200 = 100
const EM_ST7 = 68
const EM_ST9PLUS = 67
const EM_STARCORE = 58
const EM_STM8 = 186
const EM_STXP7X = 166
const EM_SVX = 73
const EM_TILE64 = 187
const EM_TILEGX = 191
const EM_TILEPRO = 188
const EM_TINYJ = 61
const EM_TI_ARP32 = 143
const EM_TI_C2000 = 141
const EM_TI_C5500 = 142
const EM_TI_C6000 = 140
const EM_TI_PRU = 144
const EM_TMM_GPP = 96
const EM_TPC = 98
const EM_TRICORE = 44
const EM_TRIMEDIA = 163
const EM_TSK3000 = 131
const EM_UNICORE = 110
const EM_V800 = 36
const EM_V850 = 87
const EM_VAX = 75
const EM_VIDEOCORE = 95
const EM_VIDEOCORE3 = 137
const EM_VIDEOCORE5 = 198
const EM_VISIUM = 221
const EM_VPP500 = 17
const EM_X86_64 = 62
const EM_XCORE = 203
const EM_XGATE = 115
const EM_XIMO16 = 170
const EM_XTENSA = 94
const EM_Z80 = 220
const EM_ZSP = 79
const ET_CORE = 4
const ET_DYN = 3
const ET_EXEC = 2
const ET_HIOS = 65279
const ET_HIPROC = 65535
const ET_LOOS = 65024
const ET_LOPROC = 65280
const ET_NONE = 0
const ET_NUM = 5
const ET_REL = 1
const EV_CURRENT = 1
const EV_NONE = 0
const EV_NUM = 2
const EXIT_FAILURE = 1
const EXIT_SUCCESS = 0
const E_MIPS_ARCH_1 = 0
const E_MIPS_ARCH_2 = 268435456
const E_MIPS_ARCH_3 = 536870912
const E_MIPS_ARCH_32 = 1342177280
const E_MIPS_ARCH_4 = 805306368
const E_MIPS_ARCH_5 = 1073741824
const E_MIPS_ARCH_64 = 1610612736
const FD_SETSIZE = 1024
const FPE_FLTDIV = 3
const FPE_FLTINV = 7
const FPE_FLTOVF = 4
const FPE_FLTRES = 6
const FPE_FLTSUB = 8
const FPE_FLTUND = 5
const FPE_INTDIV = 1
const FPE_INTOVF = 2
const GRP_COMDAT = 1
const HWCAP2_BF16 = 16384
const HWCAP2_BTI = 131072
const HWCAP2_DCPODP = 1
const HWCAP2_DGH = 32768
const HWCAP2_FLAGM2 = 128
const HWCAP2_FRINT = 256
const HWCAP2_I8MM = 8192
const HWCAP2_MTE = 262144
const HWCAP2_RNG = 65536
const HWCAP2_SVE2 = 2
const HWCAP2_SVEAES = 4
const HWCAP2_SVEBF16 = 4096
const HWCAP2_SVEBITPERM = 16
const HWCAP2_SVEF32MM = 1024
const HWCAP2_SVEF64MM = 2048
const HWCAP2_SVEI8MM = 512
const HWCAP2_SVEPMULL = 8
const HWCAP2_SVESHA3 = 32
const HWCAP2_SVESM4 = 64
const HWCAP_AES = 8
const HWCAP_ASIMD = 2
const HWCAP_ASIMDDP = 1048576
const HWCAP_ASIMDFHM = 8388608
const HWCAP_ASIMDHP = 1024
const HWCAP_ASIMDRDM = 4096
const HWCAP_ATOMICS = 256
const HWCAP_CPUID = 2048
const HWCAP_CRC32 = 128
const HWCAP_DCPOP = 65536
const HWCAP_DIT = 16777216
const HWCAP_EVTSTRM = 4
const HWCAP_FCMA = 16384
const HWCAP_FLAGM = 134217728
const HWCAP_FP = 1
const HWCAP_FPHP = 512
const HWCAP_ILRCPC = 67108864
const HWCAP_JSCVT = 8192
const HWCAP_LRCPC = 32768
const HWCAP_PACA = 1073741824
const HWCAP_PACG = 2147483648
const HWCAP_PMULL = 16
const HWCAP_SB = 536870912
const HWCAP_SHA1 = 32
const HWCAP_SHA2 = 64
const HWCAP_SHA3 = 131072
const HWCAP_SHA512 = 2097152
const HWCAP_SM3 = 262144
const HWCAP_SM4 = 524288
const HWCAP_SSBS = 268435456
const HWCAP_SVE = 4194304
const HWCAP_USCAT = 33554432
const ILL_BADSTK = 8
const ILL_COPROC = 7
const ILL_ILLADR = 3
const ILL_ILLOPC = 1
const ILL_ILLOPN = 2
const ILL_ILLTRP = 4
const ILL_PRVOPC = 5
const ILL_PRVREG = 6
const IPC_64 = 0
const ITIMER_PROF = 2
const ITIMER_REAL = 0
const ITIMER_VIRTUAL = 1
const JT_ARG_MAX = -254
const JT_AVPHYS_PAGES = -247
const JT_DELAYTIMER_MAX = -245
const JT_MINSIGSTKSZ = -244
const JT_MQ_PRIO_MAX = -253
const JT_NPROCESSORS_CONF = -250
const JT_NPROCESSORS_ONLN = -249
const JT_PAGE_SIZE = -252
const JT_PHYS_PAGES = -248
const JT_SEM_VALUE_MAX = -251
const JT_SIGSTKSZ = -243
const JT_ZERO = -246
const LITUSE_ALPHA_ADDR = 0
const LITUSE_ALPHA_BASE = 1
const LITUSE_ALPHA_BYTOFF = 2
const LITUSE_ALPHA_JSR = 3
const LITUSE_ALPHA_TLS_GD = 4
const LITUSE_ALPHA_TLS_LDM = 5
const LL_DELAY_LOAD = 16
const LL_DELTA = 32
const LL_EXACT_MATCH = 1
const LL_EXPORTS = 8
const LL_IGNORE_INT_VER = 2
const LL_NONE = 0
const LL_REQUIRE_MINOR = 4
const MB_CUR_MAX = 0
const MINSIGSTKSZ = 6144
const MIPS_AFL_ASE_DSP = 1
const MIPS_AFL_ASE_DSPR2 = 2
const MIPS_AFL_ASE_EVA = 4
const MIPS_AFL_ASE_MASK = 8191
const MIPS_AFL_ASE_MCU = 8
const MIPS_AFL_ASE_MDMX = 16
const MIPS_AFL_ASE_MICROMIPS = 2048
const MIPS_AFL_ASE_MIPS16 = 1024
const MIPS_AFL_ASE_MIPS3D = 32
const MIPS_AFL_ASE_MSA = 512
const MIPS_AFL_ASE_MT = 64
const MIPS_AFL_ASE_SMARTMIPS = 128
const MIPS_AFL_ASE_VIRT = 256
const MIPS_AFL_ASE_XPA = 4096
const MIPS_AFL_EXT_10000 = 11
const MIPS_AFL_EXT_3900 = 10
const MIPS_AFL_EXT_4010 = 8
const MIPS_AFL_EXT_4100 = 9
const MIPS_AFL_EXT_4111 = 13
const MIPS_AFL_EXT_4120 = 14
const MIPS_AFL_EXT_4650 = 7
const MIPS_AFL_EXT_5400 = 15
const MIPS_AFL_EXT_5500 = 16
const MIPS_AFL_EXT_5900 = 6
const MIPS_AFL_EXT_LOONGSON_2E = 17
const MIPS_AFL_EXT_LOONGSON_2F = 18
const MIPS_AFL_EXT_LOONGSON_3A = 4
const MIPS_AFL_EXT_OCTEON = 5
const MIPS_AFL_EXT_OCTEON2 = 2
const MIPS_AFL_EXT_OCTEONP = 3
const MIPS_AFL_EXT_SB1 = 12
const MIPS_AFL_EXT_XLR = 1
const MIPS_AFL_FLAGS1_ODDSPREG = 1
const MIPS_AFL_REG_128 = 3
const MIPS_AFL_REG_32 = 1
const MIPS_AFL_REG_64 = 2
const MIPS_AFL_REG_NONE = 0
const NT_386_IOPERM = 513
const NT_386_TLS = 512
const NT_ARC_V2 = 1536
const NT_ARM_HW_BREAK = 1026
const NT_ARM_HW_WATCH = 1027
const NT_ARM_PACA_KEYS = 1031
const NT_ARM_PACG_KEYS = 1032
const NT_ARM_PAC_ENABLED_KEYS = 1034
const NT_ARM_PAC_MASK = 1030
const NT_ARM_SVE = 1029
const NT_ARM_SYSTEM_CALL = 1028
const NT_ARM_TAGGED_ADDR_CTRL = 1033
const NT_ARM_TLS = 1025
const NT_ARM_VFP = 1024
const NT_ASRS = 8
const NT_AUXV = 6
const NT_FILE = 1179208773
const NT_FPREGSET = 2
const NT_GNU_ABI_TAG = 1
const NT_GNU_BUILD_ID = 3
const NT_GNU_GOLD_VERSION = 4
const NT_GNU_PROPERTY_TYPE_0 = 5
const NT_GWINDOWS = 7
const NT_LOONGARCH_CPUCFG = 2560
const NT_LOONGARCH_CSR = 2561
const NT_LOONGARCH_LASX = 2563
const NT_LOONGARCH_LBT = 2564
const NT_LOONGARCH_LSX = 2562
const NT_LWPSINFO = 17
const NT_LWPSTATUS = 16
const NT_METAG_CBUF = 1280
const NT_METAG_RPIPE = 1281
const NT_METAG_TLS = 1282
const NT_MIPS_DSP = 2048
const NT_MIPS_FP_MODE = 2049
const NT_MIPS_MSA = 2050
const NT_PLATFORM = 5
const NT_PPC_DSCR = 261
const NT_PPC_EBB = 262
const NT_PPC_PMU = 263
const NT_PPC_PPR = 260
const NT_PPC_SPE = 257
const NT_PPC_TAR = 259
const NT_PPC_TM_CDSCR = 271
const NT_PPC_TM_CFPR = 265
const NT_PPC_TM_CGPR = 264
const NT_PPC_TM_CPPR = 270
const NT_PPC_TM_CTAR = 269
const NT_PPC_TM_CVMX = 266
const NT_PPC_TM_CVSX = 267
const NT_PPC_TM_SPR = 268
const NT_PPC_VMX = 256
const NT_PPC_VSX = 258
const NT_PRCRED = 14
const NT_PRFPREG = 2
const NT_PRFPXREG = 20
const NT_PRPSINFO = 3
const NT_PRSTATUS = 1
const NT_PRXFPREG = 1189489535
const NT_PRXREG = 4
const NT_PSINFO = 13
const NT_PSTATUS = 10
const NT_RISCV_CSR = 2304
const NT_RISCV_VECTOR = 2305
const NT_S390_CTRS = 772
const NT_S390_GS_BC = 780
const NT_S390_GS_CB = 779
const NT_S390_HIGH_GPRS = 768
const NT_S390_LAST_BREAK = 774
const NT_S390_PREFIX = 773
const NT_S390_RI_CB = 781
const NT_S390_SYSTEM_CALL = 775
const NT_S390_TDB = 776
const NT_S390_TIMER = 769
const NT_S390_TODCMP = 770
const NT_S390_TODPREG = 771
const NT_S390_VXRS_HIGH = 778
const NT_S390_VXRS_LOW = 777
const NT_SIGINFO = 1397311305
const NT_TASKSTRUCT = 4
const NT_UTSNAME = 15
const NT_VERSION = 1
const NT_VMCOREDD = 1792
const NT_X86_XSTATE = 514
const ODK_EXCEPTIONS = 2
const ODK_FILL = 5
const ODK_HWAND = 7
const ODK_HWOR = 8
const ODK_HWPATCH = 4
const ODK_NULL = 0
const ODK_PAD = 3
const ODK_REGINFO = 1
const ODK_TAGS = 6
const OEX_DISMISS = 524288
const OEX_FPDBUG = 262144
const OEX_FPU_DIV0 = 8
const OEX_FPU_INEX = 1
const OEX_FPU_INVAL = 16
const OEX_FPU_MAX = 7936
const OEX_FPU_MIN = 31
const OEX_FPU_OFLO = 4
const OEX_FPU_UFLO = 2
const OEX_PAGE0 = 65536
const OEX_PRECISEFP = 262144
const OEX_SMM = 131072
const OHWA0_R4KEOP_CHECKED = 1
const OHWA1_R4KEOP_CLEAN = 2
const OHW_R4KEOP = 1
const OHW_R5KCVTL = 8
const OHW_R5KEOP = 4
const OHW_R8KPFETCH = 2
const OPAD_POSTFIX = 2
const OPAD_PREFIX = 1
const OPAD_SYMBOL = 4
const PF_ARM_ABS = 1073741824
const PF_ARM_PI = 536870912
const PF_ARM_SB = 268435456
const PF_HP_CODE = 16777216
const PF_HP_FAR_SHARED = 2097152
const PF_HP_LAZYSWAP = 67108864
const PF_HP_MODIFY = 33554432
const PF_HP_NEAR_SHARED = 4194304
const PF_HP_PAGE_SIZE = 1048576
const PF_HP_SBP = 134217728
const PF_IA_64_NORECOV = 2147483648
const PF_MASKOS = 267386880
const PF_MASKPROC = 4026531840
const PF_MIPS_LOCAL = 268435456
const PF_PARISC_SBP = 134217728
const PF_R = 4
const PF_W = 2
const PF_X = 1
const PN_XNUM = 65535
const POLL_ERR = 4
const POLL_HUP = 6
const POLL_IN = 1
const POLL_MSG = 3
const POLL_OUT = 2
const POLL_PRI = 5
const PPC64_OPT_LOCALENTRY = 4
const PPC64_OPT_MULTI_TOC = 2
const PPC64_OPT_TLS = 1
const PPC_OPT_TLS = 1
const PRIO_MAX = 20
const PRIO_MIN = -20
const PRIO_PGRP = 1
const PRIO_PROCESS = 0
const PRIO_USER = 2
const PT_ARM_EXIDX = 1879048193
const PT_DYNAMIC = 2
const PT_GNU_EH_FRAME = 1685382480
const PT_GNU_PROPERTY = 1685382483
const PT_GNU_RELRO = 1685382482
const PT_GNU_STACK = 1685382481
const PT_HIOS = 1879048191
const PT_HIPROC = 2147483647
const PT_HISUNW = 1879048191
const PT_HP_CORE_COMM = 1610612740
const PT_HP_CORE_KERNEL = 1610612739
const PT_HP_CORE_LOADABLE = 1610612742
const PT_HP_CORE_MMF = 1610612745
const PT_HP_CORE_NONE = 1610612737
const PT_HP_CORE_PROC = 1610612741
const PT_HP_CORE_SHM = 1610612744
const PT_HP_CORE_STACK = 1610612743
const PT_HP_CORE_VERSION = 1610612738
const PT_HP_FASTBIND = 1610612753
const PT_HP_HSL_ANNOT = 1610612755
const PT_HP_OPT_ANNOT = 1610612754
const PT_HP_PARALLEL = 1610612752
const PT_HP_STACK = 1610612756
const PT_HP_TLS = 1610612736
const PT_IA_64_ARCHEXT = 1879048192
const PT_IA_64_HP_HSL_ANOT = 1610612755
const PT_IA_64_HP_OPT_ANOT = 1610612754
const PT_IA_64_HP_STACK = 1610612756
const PT_IA_64_UNWIND = 1879048193
const PT_INTERP = 3
const PT_LOAD = 1
const PT_LOOS = 1610612736
const PT_LOPROC = 1879048192
const PT_LOSUNW = 1879048186
const PT_MIPS_ABIFLAGS = 1879048195
const PT_MIPS_OPTIONS = 1879048194
const PT_MIPS_REGINFO = 1879048192
const PT_MIPS_RTPROC = 1879048193
const PT_NOTE = 4
const PT_NULL = 0
const PT_NUM = 8
const PT_PARISC_ARCHEXT = 1879048192
const PT_PARISC_UNWIND = 1879048193
const PT_PHDR = 6
const PT_SHLIB = 5
const PT_SUNWBSS = 1879048186
const PT_SUNWSTACK = 1879048187
const PT_TLS = 7
const RAND_MAX = 2147483647
const RHF_CORD = 4096
const RHF_DEFAULT_DELAY_LOAD = 512
const RHF_DELTA_C_PLUS_PLUS = 64
const RHF_GUARANTEE_INIT = 32
const RHF_GUARANTEE_START_INIT = 128
const RHF_NONE = 0
const RHF_NOTPOT = 2
const RHF_NO_LIBRARY_REPLACEMENT = 4
const RHF_NO_MOVE = 8
const RHF_NO_UNRES_UNDEF = 8192
const RHF_PIXIE = 256
const RHF_QUICKSTART = 1
const RHF_REQUICKSTART = 1024
const RHF_REQUICKSTARTED = 2048
const RHF_RLD_ORDER_SAFE = 16384
const RHF_SGI_ONLY = 16
const RLIMIT_AS = 9
const RLIMIT_CORE = 4
const RLIMIT_CPU = 0
const RLIMIT_DATA = 2
const RLIMIT_FSIZE = 1
const RLIMIT_LOCKS = 10
const RLIMIT_MEMLOCK = 8
const RLIMIT_MSGQUEUE = 12
const RLIMIT_NICE = 13
const RLIMIT_NLIMITS = 16
const RLIMIT_NOFILE = 7
const RLIMIT_NPROC = 6
const RLIMIT_RSS = 5
const RLIMIT_RTPRIO = 14
const RLIMIT_RTTIME = 15
const RLIMIT_SIGPENDING = 11
const RLIMIT_STACK = 3
const RLIM_INFINITY = 18446744073709551615
const RLIM_NLIMITS = 16
const RLIM_SAVED_CUR = 18446744073709551615
const RLIM_SAVED_MAX = 18446744073709551615
const RUSAGE_CHILDREN = -1
const RUSAGE_SELF = 0
const RUSAGE_THREAD = 1
const R_386_16 = 20
const R_386_32 = 1
const R_386_32PLT = 11
const R_386_8 = 22
const R_386_COPY = 5
const R_386_GLOB_DAT = 6
const R_386_GOT32 = 3
const R_386_GOT32X = 43
const R_386_GOTOFF = 9
const R_386_GOTPC = 10
const R_386_IRELATIVE = 42
const R_386_JMP_SLOT = 7
const R_386_NONE = 0
const R_386_NUM = 44
const R_386_PC16 = 21
const R_386_PC32 = 2
const R_386_PC8 = 23
const R_386_PLT32 = 4
const R_386_RELATIVE = 8
const R_386_SIZE32 = 38
const R_386_TLS_DESC = 41
const R_386_TLS_DESC_CALL = 40
const R_386_TLS_DTPMOD32 = 35
const R_386_TLS_DTPOFF32 = 36
const R_386_TLS_GD = 18
const R_386_TLS_GD_32 = 24
const R_386_TLS_GD_CALL = 26
const R_386_TLS_GD_POP = 27
const R_386_TLS_GD_PUSH = 25
const R_386_TLS_GOTDESC = 39
const R_386_TLS_GOTIE = 16
const R_386_TLS_IE = 15
const R_386_TLS_IE_32 = 33
const R_386_TLS_LDM = 19
const R_386_TLS_LDM_32 = 28
const R_386_TLS_LDM_CALL = 30
const R_386_TLS_LDM_POP = 31
const R_386_TLS_LDM_PUSH = 29
const R_386_TLS_LDO_32 = 32
const R_386_TLS_LE = 17
const R_386_TLS_LE_32 = 34
const R_386_TLS_TPOFF = 14
const R_386_TLS_TPOFF32 = 37
const R_390_12 = 2
const R_390_16 = 3
const R_390_20 = 57
const R_390_32 = 4
const R_390_64 = 22
const R_390_8 = 1
const R_390_COPY = 9
const R_390_GLOB_DAT = 10
const R_390_GOT12 = 6
const R_390_GOT16 = 15
const R_390_GOT20 = 58
const R_390_GOT32 = 7
const R_390_GOT64 = 24
const R_390_GOTENT = 26
const R_390_GOTOFF16 = 27
const R_390_GOTOFF32 = 13
const R_390_GOTOFF64 = 28
const R_390_GOTPC = 14
const R_390_GOTPCDBL = 21
const R_390_GOTPLT12 = 29
const R_390_GOTPLT16 = 30
const R_390_GOTPLT20 = 59
const R_390_GOTPLT32 = 31
const R_390_GOTPLT64 = 32
const R_390_GOTPLTENT = 33
const R_390_JMP_SLOT = 11
const R_390_NONE = 0
const R_390_NUM = 61
const R_390_PC16 = 16
const R_390_PC16DBL = 17
const R_390_PC32 = 5
const R_390_PC32DBL = 19
const R_390_PC64 = 23
const R_390_PLT16DBL = 18
const R_390_PLT32 = 8
const R_390_PLT32DBL = 20
const R_390_PLT64 = 25
const R_390_PLTOFF16 = 34
const R_390_PLTOFF32 = 35
const R_390_PLTOFF64 = 36
const R_390_RELATIVE = 12
const R_390_TLS_DTPMOD = 54
const R_390_TLS_DTPOFF = 55
const R_390_TLS_GD32 = 40
const R_390_TLS_GD64 = 41
const R_390_TLS_GDCALL = 38
const R_390_TLS_GOTIE12 = 42
const R_390_TLS_GOTIE20 = 60
const R_390_TLS_GOTIE32 = 43
const R_390_TLS_GOTIE64 = 44
const R_390_TLS_IE32 = 47
const R_390_TLS_IE64 = 48
const R_390_TLS_IEENT = 49
const R_390_TLS_LDCALL = 39
const R_390_TLS_LDM32 = 45
const R_390_TLS_LDM64 = 46
const R_390_TLS_LDO32 = 52
const R_390_TLS_LDO64 = 53
const R_390_TLS_LE32 = 50
const R_390_TLS_LE64 = 51
const R_390_TLS_LOAD = 37
const R_390_TLS_TPOFF = 56
const R_68K_16 = 2
const R_68K_32 = 1
const R_68K_8 = 3
const R_68K_COPY = 19
const R_68K_GLOB_DAT = 20
const R_68K_GOT16 = 8
const R_68K_GOT16O = 11
const R_68K_GOT32 = 7
const R_68K_GOT32O = 10
const R_68K_GOT8 = 9
const R_68K_GOT8O = 12
const R_68K_JMP_SLOT = 21
const R_68K_NONE = 0
const R_68K_NUM = 43
const R_68K_PC16 = 5
const R_68K_PC32 = 4
const R_68K_PC8 = 6
const R_68K_PLT16 = 14
const R_68K_PLT16O = 17
const R_68K_PLT32 = 13
const R_68K_PLT32O = 16
const R_68K_PLT8 = 15
const R_68K_PLT8O = 18
const R_68K_RELATIVE = 22
const R_68K_TLS_DTPMOD32 = 40
const R_68K_TLS_DTPREL32 = 41
const R_68K_TLS_GD16 = 26
const R_68K_TLS_GD32 = 25
const R_68K_TLS_GD8 = 27
const R_68K_TLS_IE16 = 35
const R_68K_TLS_IE32 = 34
const R_68K_TLS_IE8 = 36
const R_68K_TLS_LDM16 = 29
const R_68K_TLS_LDM32 = 28
const R_68K_TLS_LDM8 = 30
const R_68K_TLS_LDO16 = 32
const R_68K_TLS_LDO32 = 31
const R_68K_TLS_LDO8 = 33
const R_68K_TLS_LE16 = 38
const R_68K_TLS_LE32 = 37
const R_68K_TLS_LE8 = 39
const R_68K_TLS_TPREL32 = 42
const R_AARCH64_ABS16 = 259
const R_AARCH64_ABS32 = 258
const R_AARCH64_ABS64 = 257
const R_AARCH64_ADD_ABS_LO12_NC = 277
const R_AARCH64_ADR_GOT_PAGE = 311
const R_AARCH64_ADR_PREL_LO21 = 274
const R_AARCH64_ADR_PREL_PG_HI21 = 275
const R_AARCH64_ADR_PREL_PG_HI21_NC = 276
const R_AARCH64_CALL26 = 283
const R_AARCH64_CONDBR19 = 280
const R_AARCH64_COPY = 1024
const R_AARCH64_GLOB_DAT = 1025
const R_AARCH64_GOTREL32 = 308
const R_AARCH64_GOTREL64 = 307
const R_AARCH64_GOT_LD_PREL19 = 309
const R_AARCH64_JUMP26 = 282
const R_AARCH64_JUMP_SLOT = 1026
const R_AARCH64_LD64_GOTOFF_LO15 = 310
const R_AARCH64_LD64_GOTPAGE_LO15 = 313
const R_AARCH64_LD64_GOT_LO12_NC = 312
const R_AARCH64_LDST128_ABS_LO12_NC = 299
const R_AARCH64_LDST16_ABS_LO12_NC = 284
const R_AARCH64_LDST32_ABS_LO12_NC = 285
const R_AARCH64_LDST64_ABS_LO12_NC = 286
const R_AARCH64_LDST8_ABS_LO12_NC = 278
const R_AARCH64_LD_PREL_LO19 = 273
const R_AARCH64_MOVW_GOTOFF_G0 = 300
const R_AARCH64_MOVW_GOTOFF_G0_NC = 301
const R_AARCH64_MOVW_GOTOFF_G1 = 302
const R_AARCH64_MOVW_GOTOFF_G1_NC = 303
const R_AARCH64_MOVW_GOTOFF_G2 = 304
const R_AARCH64_MOVW_GOTOFF_G2_NC = 305
const R_AARCH64_MOVW_GOTOFF_G3 = 306
const R_AARCH64_MOVW_PREL_G0 = 287
const R_AARCH64_MOVW_PREL_G0_NC = 288
const R_AARCH64_MOVW_PREL_G1 = 289
const R_AARCH64_MOVW_PREL_G1_NC = 290
const R_AARCH64_MOVW_PREL_G2 = 291
const R_AARCH64_MOVW_PREL_G2_NC = 292
const R_AARCH64_MOVW_PREL_G3 = 293
const R_AARCH64_MOVW_SABS_G0 = 270
const R_AARCH64_MOVW_SABS_G1 = 271
const R_AARCH64_MOVW_SABS_G2 = 272
const R_AARCH64_MOVW_UABS_G0 = 263
const R_AARCH64_MOVW_UABS_G0_NC = 264
const R_AARCH64_MOVW_UABS_G1 = 265
const R_AARCH64_MOVW_UABS_G1_NC = 266
const R_AARCH64_MOVW_UABS_G2 = 267
const R_AARCH64_MOVW_UABS_G2_NC = 268
const R_AARCH64_MOVW_UABS_G3 = 269
const R_AARCH64_NONE = 0
const R_AARCH64_P32_ABS32 = 1
const R_AARCH64_P32_COPY = 180
const R_AARCH64_P32_GLOB_DAT = 181
const R_AARCH64_P32_IRELATIVE = 188
const R_AARCH64_P32_JUMP_SLOT = 182
const R_AARCH64_P32_RELATIVE = 183
const R_AARCH64_P32_TLSDESC = 187
const R_AARCH64_P32_TLS_DTPMOD = 184
const R_AARCH64_P32_TLS_DTPREL = 185
const R_AARCH64_P32_TLS_TPREL = 186
const R_AARCH64_PREL16 = 262
const R_AARCH64_PREL32 = 261
const R_AARCH64_PREL64 = 260
const R_AARCH64_RELATIVE = 1027
const R_AARCH64_TLSDESC = 1031
const R_AARCH64_TLSDESC_ADD = 568
const R_AARCH64_TLSDESC_ADD_LO12 = 564
const R_AARCH64_TLSDESC_ADR_PAGE21 = 562
const R_AARCH64_TLSDESC_ADR_PREL21 = 561
const R_AARCH64_TLSDESC_CALL = 569
const R_AARCH64_TLSDESC_LD64_LO12 = 563
const R_AARCH64_TLSDESC_LDR = 567
const R_AARCH64_TLSDESC_LD_PREL19 = 560
const R_AARCH64_TLSDESC_OFF_G0_NC = 566
const R_AARCH64_TLSDESC_OFF_G1 = 565
const R_AARCH64_TLSGD_ADD_LO12_NC = 514
const R_AARCH64_TLSGD_ADR_PAGE21 = 513
const R_AARCH64_TLSGD_ADR_PREL21 = 512
const R_AARCH64_TLSGD_MOVW_G0_NC = 516
const R_AARCH64_TLSGD_MOVW_G1 = 515
const R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 = 541
const R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC = 542
const R_AARCH64_TLSIE_LD_GOTTPREL_PREL19 = 543
const R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC = 540
const R_AARCH64_TLSIE_MOVW_GOTTPREL_G1 = 539
const R_AARCH64_TLSLD_ADD_DTPREL_HI12 = 528
const R_AARCH64_TLSLD_ADD_DTPREL_LO12 = 529
const R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC = 530
const R_AARCH64_TLSLD_ADD_LO12_NC = 519
const R_AARCH64_TLSLD_ADR_PAGE21 = 518
const R_AARCH64_TLSLD_ADR_PREL21 = 517
const R_AARCH64_TLSLD_LDST128_DTPREL_LO12 = 572
const R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC = 573
const R_AARCH64_TLSLD_LDST16_DTPREL_LO12 = 533
const R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC = 534
const R_AARCH64_TLSLD_LDST32_DTPREL_LO12 = 535
const R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC = 536
const R_AARCH64_TLSLD_LDST64_DTPREL_LO12 = 537
const R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC = 538
const R_AARCH64_TLSLD_LDST8_DTPREL_LO12 = 531
const R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC = 532
const R_AARCH64_TLSLD_LD_PREL19 = 522
const R_AARCH64_TLSLD_MOVW_DTPREL_G0 = 526
const R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC = 527
const R_AARCH64_TLSLD_MOVW_DTPREL_G1 = 524
const R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC = 525
const R_AARCH64_TLSLD_MOVW_DTPREL_G2 = 523
const R_AARCH64_TLSLD_MOVW_G0_NC = 521
const R_AARCH64_TLSLD_MOVW_G1 = 520
const R_AARCH64_TLSLE_ADD_TPREL_HI12 = 549
const R_AARCH64_TLSLE_ADD_TPREL_LO12 = 550
const R_AARCH64_TLSLE_ADD_TPREL_LO12_NC = 551
const R_AARCH64_TLSLE_LDST128_TPREL_LO12 = 570
const R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC = 571
const R_AARCH64_TLSLE_LDST16_TPREL_LO12 = 554
const R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC = 555
const R_AARCH64_TLSLE_LDST32_TPREL_LO12 = 556
const R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC = 557
const R_AARCH64_TLSLE_LDST64_TPREL_LO12 = 558
const R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC = 559
const R_AARCH64_TLSLE_LDST8_TPREL_LO12 = 552
const R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC = 553
const R_AARCH64_TLSLE_MOVW_TPREL_G0 = 547
const R_AARCH64_TLSLE_MOVW_TPREL_G0_NC = 548
const R_AARCH64_TLSLE_MOVW_TPREL_G1 = 545
const R_AARCH64_TLSLE_MOVW_TPREL_G1_NC = 546
const R_AARCH64_TLSLE_MOVW_TPREL_G2 = 544
const R_AARCH64_TLS_DTPMOD = 1028
const R_AARCH64_TLS_DTPMOD64 = 1028
const R_AARCH64_TLS_DTPREL = 1029
const R_AARCH64_TLS_DTPREL64 = 1029
const R_AARCH64_TLS_TPREL = 1030
const R_AARCH64_TLS_TPREL64 = 1030
const R_AARCH64_TSTBR14 = 279
const R_ALPHA_BRADDR = 7
const R_ALPHA_COPY = 24
const R_ALPHA_DTPMOD64 = 31
const R_ALPHA_DTPREL16 = 36
const R_ALPHA_DTPREL64 = 33
const R_ALPHA_DTPRELHI = 34
const R_ALPHA_DTPRELLO = 35
const R_ALPHA_GLOB_DAT = 25
const R_ALPHA_GOTDTPREL = 32
const R_ALPHA_GOTTPREL = 37
const R_ALPHA_GPDISP = 6
const R_ALPHA_GPREL16 = 19
const R_ALPHA_GPREL32 = 3
const R_ALPHA_GPRELHIGH = 17
const R_ALPHA_GPRELLOW = 18
const R_ALPHA_HINT = 8
const R_ALPHA_JMP_SLOT = 26
const R_ALPHA_LITERAL = 4
const R_ALPHA_LITUSE = 5
const R_ALPHA_NONE = 0
const R_ALPHA_NUM = 46
const R_ALPHA_REFLONG = 1
const R_ALPHA_REFQUAD = 2
const R_ALPHA_RELATIVE = 27
const R_ALPHA_SREL16 = 9
const R_ALPHA_SREL32 = 10
const R_ALPHA_SREL64 = 11
const R_ALPHA_TLSGD = 29
const R_ALPHA_TLS_GD_HI = 28
const R_ALPHA_TLS_LDM = 30
const R_ALPHA_TPREL16 = 41
const R_ALPHA_TPREL64 = 38
const R_ALPHA_TPRELHI = 39
const R_ALPHA_TPRELLO = 40
const R_ARM_ABS12 = 6
const R_ARM_ABS16 = 5
const R_ARM_ABS32 = 2
const R_ARM_ABS32_NOI = 55
const R_ARM_ABS8 = 8
const R_ARM_ALU_PCREL_15_8 = 33
const R_ARM_ALU_PCREL_23_15 = 34
const R_ARM_ALU_PCREL_7_0 = 32
const R_ARM_ALU_PC_G0 = 58
const R_ARM_ALU_PC_G0_NC = 57
const R_ARM_ALU_PC_G1 = 60
const R_ARM_ALU_PC_G1_NC = 59
const R_ARM_ALU_PC_G2 = 61
const R_ARM_ALU_SBREL_19_12 = 36
const R_ARM_ALU_SBREL_27_20 = 37
const R_ARM_ALU_SB_G0 = 71
const R_ARM_ALU_SB_G0_NC = 70
const R_ARM_ALU_SB_G1 = 73
const R_ARM_ALU_SB_G1_NC = 72
const R_ARM_ALU_SB_G2 = 74
const R_ARM_AMP_VCALL9 = 12
const R_ARM_BASE_ABS = 31
const R_ARM_CALL = 28
const R_ARM_COPY = 20
const R_ARM_GLOB_DAT = 21
const R_ARM_GNU_VTENTRY = 100
const R_ARM_GNU_VTINHERIT = 101
const R_ARM_GOT32 = 26
const R_ARM_GOTOFF = 24
const R_ARM_GOTOFF12 = 98
const R_ARM_GOTPC = 25
const R_ARM_GOTRELAX = 99
const R_ARM_GOT_ABS = 95
const R_ARM_GOT_BREL12 = 97
const R_ARM_GOT_PREL = 96
const R_ARM_IRELATIVE = 160
const R_ARM_JUMP24 = 29
const R_ARM_JUMP_SLOT = 22
const R_ARM_LDC_PC_G0 = 67
const R_ARM_LDC_PC_G1 = 68
const R_ARM_LDC_PC_G2 = 69
const R_ARM_LDC_SB_G0 = 81
const R_ARM_LDC_SB_G1 = 82
const R_ARM_LDC_SB_G2 = 83
const R_ARM_LDRS_PC_G0 = 64
const R_ARM_LDRS_PC_G1 = 65
const R_ARM_LDRS_PC_G2 = 66
const R_ARM_LDRS_SB_G0 = 78
const R_ARM_LDRS_SB_G1 = 79
const R_ARM_LDRS_SB_G2 = 80
const R_ARM_LDR_PC_G1 = 62
const R_ARM_LDR_PC_G2 = 63
const R_ARM_LDR_SBREL_11_0 = 35
const R_ARM_LDR_SB_G0 = 75
const R_ARM_LDR_SB_G1 = 76
const R_ARM_LDR_SB_G2 = 77
const R_ARM_ME_TOO = 128
const R_ARM_MOVT_ABS = 44
const R_ARM_MOVT_BREL = 85
const R_ARM_MOVT_PREL = 46
const R_ARM_MOVW_ABS_NC = 43
const R_ARM_MOVW_BREL = 86
const R_ARM_MOVW_BREL_NC = 84
const R_ARM_MOVW_PREL_NC = 45
const R_ARM_NONE = 0
const R_ARM_NUM = 256
const R_ARM_PC13 = 4
const R_ARM_PC24 = 1
const R_ARM_PLT32 = 27
const R_ARM_PLT32_ABS = 94
const R_ARM_PREL31 = 42
const R_ARM_RABS22 = 253
const R_ARM_RBASE = 255
const R_ARM_REL32 = 3
const R_ARM_REL32_NOI = 56
const R_ARM_RELATIVE = 23
const R_ARM_RPC24 = 254
const R_ARM_RREL32 = 252
const R_ARM_RSBREL32 = 250
const R_ARM_RXPC25 = 249
const R_ARM_SBREL31 = 39
const R_ARM_SBREL32 = 9
const R_ARM_TARGET1 = 38
const R_ARM_TARGET2 = 41
const R_ARM_THM_ABS5 = 7
const R_ARM_THM_ALU_PREL_11_0 = 53
const R_ARM_THM_GOT_BREL12 = 131
const R_ARM_THM_JUMP19 = 51
const R_ARM_THM_JUMP24 = 30
const R_ARM_THM_JUMP6 = 52
const R_ARM_THM_MOVT_ABS = 48
const R_ARM_THM_MOVT_BREL = 88
const R_ARM_THM_MOVT_PREL = 50
const R_ARM_THM_MOVW_ABS_NC = 47
const R_ARM_THM_MOVW_BREL = 89
const R_ARM_THM_MOVW_BREL_NC = 87
const R_ARM_THM_MOVW_PREL_NC = 49
const R_ARM_THM_PC11 = 102
const R_ARM_THM_PC12 = 54
const R_ARM_THM_PC22 = 10
const R_ARM_THM_PC8 = 11
const R_ARM_THM_PC9 = 103
const R_ARM_THM_RPC22 = 251
const R_ARM_THM_SWI8 = 14
const R_ARM_THM_TLS_CALL = 93
const R_ARM_THM_TLS_DESCSEQ = 129
const R_ARM_THM_TLS_DESCSEQ16 = 129
const R_ARM_THM_TLS_DESCSEQ32 = 130
const R_ARM_THM_XPC22 = 16
const R_ARM_TLS_CALL = 91
const R_ARM_TLS_DESC = 13
const R_ARM_TLS_DESCSEQ = 92
const R_ARM_TLS_DTPMOD32 = 17
const R_ARM_TLS_DTPOFF32 = 18
const R_ARM_TLS_GD32 = 104
const R_ARM_TLS_GOTDESC = 90
const R_ARM_TLS_IE12GP = 111
const R_ARM_TLS_IE32 = 107
const R_ARM_TLS_LDM32 = 105
const R_ARM_TLS_LDO12 = 109
const R_ARM_TLS_LDO32 = 106
const R_ARM_TLS_LE12 = 110
const R_ARM_TLS_LE32 = 108
const R_ARM_TLS_TPOFF32 = 19
const R_ARM_V4BX = 40
const R_ARM_XPC25 = 15
const R_BPF_MAP_FD = 1
const R_BPF_NONE = 0
const R_CKCORE_ADDR32 = 1
const R_CKCORE_ADDRGOT = 17
const R_CKCORE_ADDRGOT_HI16 = 36
const R_CKCORE_ADDRGOT_LO16 = 37
const R_CKCORE_ADDRPLT = 18
const R_CKCORE_ADDRPLT_HI16 = 38
const R_CKCORE_ADDRPLT_LO16 = 39
const R_CKCORE_ADDR_HI16 = 24
const R_CKCORE_ADDR_LO16 = 25
const R_CKCORE_COPY = 10
const R_CKCORE_DOFFSET_IMM18 = 44
const R_CKCORE_DOFFSET_IMM18BY2 = 45
const R_CKCORE_DOFFSET_IMM18BY4 = 46
const R_CKCORE_DOFFSET_LO16 = 42
const R_CKCORE_GLOB_DAT = 11
const R_CKCORE_GOT12 = 30
const R_CKCORE_GOT32 = 15
const R_CKCORE_GOTOFF = 13
const R_CKCORE_GOTOFF_HI16 = 28
const R_CKCORE_GOTOFF_LO16 = 29
const R_CKCORE_GOTPC = 14
const R_CKCORE_GOTPC_HI16 = 26
const R_CKCORE_GOTPC_LO16 = 27
const R_CKCORE_GOT_HI16 = 31
const R_CKCORE_GOT_IMM18BY4 = 48
const R_CKCORE_GOT_LO16 = 32
const R_CKCORE_JUMP_SLOT = 12
const R_CKCORE_NONE = 0
const R_CKCORE_PCREL32 = 5
const R_CKCORE_PCRELIMM11BY2 = 3
const R_CKCORE_PCRELIMM8BY4 = 2
const R_CKCORE_PCRELJSR_IMM11BY2 = 6
const R_CKCORE_PCREL_IMM10BY2 = 22
const R_CKCORE_PCREL_IMM10BY4 = 23
const R_CKCORE_PCREL_IMM16BY2 = 20
const R_CKCORE_PCREL_IMM16BY4 = 21
const R_CKCORE_PCREL_IMM18BY2 = 43
const R_CKCORE_PCREL_IMM26BY2 = 19
const R_CKCORE_PCREL_IMM7BY4 = 50
const R_CKCORE_PCREL_JSR_IMM26BY2 = 40
const R_CKCORE_PLT12 = 33
const R_CKCORE_PLT32 = 16
const R_CKCORE_PLT_HI16 = 34
const R_CKCORE_PLT_IMM18BY4 = 49
const R_CKCORE_PLT_LO16 = 35
const R_CKCORE_RELATIVE = 9
const R_CKCORE_TLS_DTPMOD32 = 56
const R_CKCORE_TLS_DTPOFF32 = 57
const R_CKCORE_TLS_GD32 = 53
const R_CKCORE_TLS_IE32 = 52
const R_CKCORE_TLS_LDM32 = 54
const R_CKCORE_TLS_LDO32 = 55
const R_CKCORE_TLS_LE32 = 51
const R_CKCORE_TLS_TPOFF32 = 58
const R_CKCORE_TOFFSET_LO16 = 41
const R_CRIS_16 = 2
const R_CRIS_16_GOT = 13
const R_CRIS_16_GOTPLT = 15
const R_CRIS_16_PCREL = 5
const R_CRIS_32 = 3
const R_CRIS_32_GOT = 14
const R_CRIS_32_GOTPLT = 16
const R_CRIS_32_GOTREL = 17
const R_CRIS_32_PCREL = 6
const R_CRIS_32_PLT_GOTREL = 18
const R_CRIS_32_PLT_PCREL = 19
const R_CRIS_8 = 1
const R_CRIS_8_PCREL = 4
const R_CRIS_COPY = 9
const R_CRIS_GLOB_DAT = 10
const R_CRIS_GNU_VTENTRY = 8
const R_CRIS_GNU_VTINHERIT = 7
const R_CRIS_JUMP_SLOT = 11
const R_CRIS_NONE = 0
const R_CRIS_NUM = 20
const R_CRIS_RELATIVE = 12
const R_IA64_COPY = 132
const R_IA64_DIR32LSB = 37
const R_IA64_DIR32MSB = 36
const R_IA64_DIR64LSB = 39
const R_IA64_DIR64MSB = 38
const R_IA64_DTPMOD64LSB = 167
const R_IA64_DTPMOD64MSB = 166
const R_IA64_DTPREL14 = 177
const R_IA64_DTPREL22 = 178
const R_IA64_DTPREL32LSB = 181
const R_IA64_DTPREL32MSB = 180
const R_IA64_DTPREL64I = 179
const R_IA64_DTPREL64LSB = 183
const R_IA64_DTPREL64MSB = 182
const R_IA64_FPTR32LSB = 69
const R_IA64_FPTR32MSB = 68
const R_IA64_FPTR64I = 67
const R_IA64_FPTR64LSB = 71
const R_IA64_FPTR64MSB = 70
const R_IA64_GPREL22 = 42
const R_IA64_GPREL32LSB = 45
const R_IA64_GPREL32MSB = 44
const R_IA64_GPREL64I = 43
const R_IA64_GPREL64LSB = 47
const R_IA64_GPREL64MSB = 46
const R_IA64_IMM14 = 33
const R_IA64_IMM22 = 34
const R_IA64_IMM64 = 35
const R_IA64_IPLTLSB = 129
const R_IA64_IPLTMSB = 128
const R_IA64_LDXMOV = 135
const R_IA64_LTOFF22 = 50
const R_IA64_LTOFF22X = 134
const R_IA64_LTOFF64I = 51
const R_IA64_LTOFF_DTPMOD22 = 170
const R_IA64_LTOFF_DTPREL22 = 186
const R_IA64_LTOFF_FPTR22 = 82
const R_IA64_LTOFF_FPTR32LSB = 85
const R_IA64_LTOFF_FPTR32MSB = 84
const R_IA64_LTOFF_FPTR64I = 83
const R_IA64_LTOFF_FPTR64LSB = 87
const R_IA64_LTOFF_FPTR64MSB = 86
const R_IA64_LTOFF_TPREL22 = 154
const R_IA64_LTV32LSB = 117
const R_IA64_LTV32MSB = 116
const R_IA64_LTV64LSB = 119
const R_IA64_LTV64MSB = 118
const R_IA64_NONE = 0
const R_IA64_PCREL21B = 73
const R_IA64_PCREL21BI = 121
const R_IA64_PCREL21F = 75
const R_IA64_PCREL21M = 74
const R_IA64_PCREL22 = 122
const R_IA64_PCREL32LSB = 77
const R_IA64_PCREL32MSB = 76
const R_IA64_PCREL60B = 72
const R_IA64_PCREL64I = 123
const R_IA64_PCREL64LSB = 79
const R_IA64_PCREL64MSB = 78
const R_IA64_PLTOFF22 = 58
const R_IA64_PLTOFF64I = 59
const R_IA64_PLTOFF64LSB = 63
const R_IA64_PLTOFF64MSB = 62
const R_IA64_REL32LSB = 109
const R_IA64_REL32MSB = 108
const R_IA64_REL64LSB = 111
const R_IA64_REL64MSB = 110
const R_IA64_SECREL32LSB = 101
const R_IA64_SECREL32MSB = 100
const R_IA64_SECREL64LSB = 103
const R_IA64_SECREL64MSB = 102
const R_IA64_SEGREL32LSB = 93
const R_IA64_SEGREL32MSB = 92
const R_IA64_SEGREL64LSB = 95
const R_IA64_SEGREL64MSB = 94
const R_IA64_SUB = 133
const R_IA64_TPREL14 = 145
const R_IA64_TPREL22 = 146
const R_IA64_TPREL64I = 147
const R_IA64_TPREL64LSB = 151
const R_IA64_TPREL64MSB = 150
const R_LARCH_32 = 1
const R_LARCH_32_PCREL = 99
const R_LARCH_64 = 2
const R_LARCH_ABS64_HI12 = 70
const R_LARCH_ABS64_LO20 = 69
const R_LARCH_ABS_HI20 = 67
const R_LARCH_ABS_LO12 = 68
const R_LARCH_ADD16 = 48
const R_LARCH_ADD24 = 49
const R_LARCH_ADD32 = 50
const R_LARCH_ADD64 = 51
const R_LARCH_ADD8 = 47
const R_LARCH_B16 = 64
const R_LARCH_B21 = 65
const R_LARCH_B26 = 66
const R_LARCH_COPY = 4
const R_LARCH_GNU_VTENTRY = 58
const R_LARCH_GNU_VTINHERIT = 57
const R_LARCH_GOT64_HI12 = 82
const R_LARCH_GOT64_LO20 = 81
const R_LARCH_GOT64_PC_HI12 = 78
const R_LARCH_GOT64_PC_LO20 = 77
const R_LARCH_GOT_HI20 = 79
const R_LARCH_GOT_LO12 = 80
const R_LARCH_GOT_PC_HI20 = 75
const R_LARCH_GOT_PC_LO12 = 76
const R_LARCH_IRELATIVE = 12
const R_LARCH_JUMP_SLOT = 5
const R_LARCH_MARK_LA = 20
const R_LARCH_MARK_PCREL = 21
const R_LARCH_NONE = 0
const R_LARCH_PCALA64_HI12 = 74
const R_LARCH_PCALA64_LO20 = 73
const R_LARCH_PCALA_HI20 = 71
const R_LARCH_PCALA_LO12 = 72
const R_LARCH_RELATIVE = 3
const R_LARCH_RELAX = 100
const R_LARCH_SOP_ADD = 35
const R_LARCH_SOP_AND = 36
const R_LARCH_SOP_ASSERT = 30
const R_LARCH_SOP_IF_ELSE = 37
const R_LARCH_SOP_NOT = 31
const R_LARCH_SOP_POP_32_S_0_10_10_16_S2 = 45
const R_LARCH_SOP_POP_32_S_0_5_10_16_S2 = 44
const R_LARCH_SOP_POP_32_S_10_12 = 40
const R_LARCH_SOP_POP_32_S_10_16 = 41
const R_LARCH_SOP_POP_32_S_10_16_S2 = 42
const R_LARCH_SOP_POP_32_S_10_5 = 38
const R_LARCH_SOP_POP_32_S_5_20 = 43
const R_LARCH_SOP_POP_32_U = 46
const R_LARCH_SOP_POP_32_U_10_12 = 39
const R_LARCH_SOP_PUSH_ABSOLUTE = 23
const R_LARCH_SOP_PUSH_DUP = 24
const R_LARCH_SOP_PUSH_GPREL = 25
const R_LARCH_SOP_PUSH_PCREL = 22
const R_LARCH_SOP_PUSH_PLT_PCREL = 29
const R_LARCH_SOP_PUSH_TLS_GD = 28
const R_LARCH_SOP_PUSH_TLS_GOT = 27
const R_LARCH_SOP_PUSH_TLS_TPREL = 26
const R_LARCH_SOP_SL = 33
const R_LARCH_SOP_SR = 34
const R_LARCH_SOP_SUB = 32
const R_LARCH_SUB16 = 53
const R_LARCH_SUB24 = 54
const R_LARCH_SUB32 = 55
const R_LARCH_SUB64 = 56
const R_LARCH_SUB8 = 52
const R_LARCH_TLS_DTPMOD32 = 6
const R_LARCH_TLS_DTPMOD64 = 7
const R_LARCH_TLS_DTPREL32 = 8
const R_LARCH_TLS_DTPREL64 = 9
const R_LARCH_TLS_GD_HI20 = 98
const R_LARCH_TLS_GD_PC_HI20 = 97
const R_LARCH_TLS_IE64_HI12 = 94
const R_LARCH_TLS_IE64_LO20 = 93
const R_LARCH_TLS_IE64_PC_HI12 = 90
const R_LARCH_TLS_IE64_PC_LO20 = 89
const R_LARCH_TLS_IE_HI20 = 91
const R_LARCH_TLS_IE_LO12 = 92
const R_LARCH_TLS_IE_PC_HI20 = 87
const R_LARCH_TLS_IE_PC_LO12 = 88
const R_LARCH_TLS_LD_HI20 = 96
const R_LARCH_TLS_LD_PC_HI20 = 95
const R_LARCH_TLS_LE64_HI12 = 86
const R_LARCH_TLS_LE64_LO20 = 85
const R_LARCH_TLS_LE_HI20 = 83
const R_LARCH_TLS_LE_LO12 = 84
const R_LARCH_TLS_TPREL32 = 10
const R_LARCH_TLS_TPREL64 = 11
const R_M32R_10_PCREL = 4
const R_M32R_10_PCREL_RELA = 36
const R_M32R_16 = 1
const R_M32R_16_RELA = 33
const R_M32R_18_PCREL = 5
const R_M32R_18_PCREL_RELA = 37
const R_M32R_24 = 3
const R_M32R_24_RELA = 35
const R_M32R_26_PCREL = 6
const R_M32R_26_PCREL_RELA = 38
const R_M32R_26_PLTREL = 49
const R_M32R_32 = 2
const R_M32R_32_RELA = 34
const R_M32R_COPY = 50
const R_M32R_GLOB_DAT = 51
const R_M32R_GNU_VTENTRY = 12
const R_M32R_GNU_VTINHERIT = 11
const R_M32R_GOT16_HI_SLO = 57
const R_M32R_GOT16_HI_ULO = 56
const R_M32R_GOT16_LO = 58
const R_M32R_GOT24 = 48
const R_M32R_GOTOFF = 54
const R_M32R_GOTOFF_HI_SLO = 63
const R_M32R_GOTOFF_HI_ULO = 62
const R_M32R_GOTOFF_LO = 64
const R_M32R_GOTPC24 = 55
const R_M32R_GOTPC_HI_SLO = 60
const R_M32R_GOTPC_HI_ULO = 59
const R_M32R_GOTPC_LO = 61
const R_M32R_HI16_SLO = 8
const R_M32R_HI16_SLO_RELA = 40
const R_M32R_HI16_ULO = 7
const R_M32R_HI16_ULO_RELA = 39
const R_M32R_JMP_SLOT = 52
const R_M32R_LO16 = 9
const R_M32R_LO16_RELA = 41
const R_M32R_NONE = 0
const R_M32R_NUM = 256
const R_M32R_REL32 = 45
const R_M32R_RELATIVE = 53
const R_M32R_RELA_GNU_VTENTRY = 44
const R_M32R_RELA_GNU_VTINHERIT = 43
const R_M32R_SDA16 = 10
const R_M32R_SDA16_RELA = 42
const R_MICROBLAZE_32 = 1
const R_MICROBLAZE_32_LO = 6
const R_MICROBLAZE_32_PCREL = 2
const R_MICROBLAZE_32_PCREL_LO = 4
const R_MICROBLAZE_32_SYM_OP_SYM = 10
const R_MICROBLAZE_64 = 5
const R_MICROBLAZE_64_NONE = 9
const R_MICROBLAZE_64_PCREL = 3
const R_MICROBLAZE_COPY = 21
const R_MICROBLAZE_GLOB_DAT = 18
const R_MICROBLAZE_GNU_VTENTRY = 12
const R_MICROBLAZE_GNU_VTINHERIT = 11
const R_MICROBLAZE_GOTOFF_32 = 20
const R_MICROBLAZE_GOTOFF_64 = 19
const R_MICROBLAZE_GOTPC_64 = 13
const R_MICROBLAZE_GOT_64 = 14
const R_MICROBLAZE_JUMP_SLOT = 17
const R_MICROBLAZE_NONE = 0
const R_MICROBLAZE_PLT_64 = 15
const R_MICROBLAZE_REL = 16
const R_MICROBLAZE_SRO32 = 7
const R_MICROBLAZE_SRW32 = 8
const R_MICROBLAZE_TLS = 22
const R_MICROBLAZE_TLSDTPMOD32 = 25
const R_MICROBLAZE_TLSDTPREL32 = 26
const R_MICROBLAZE_TLSDTPREL64 = 27
const R_MICROBLAZE_TLSGD = 23
const R_MICROBLAZE_TLSGOTTPREL32 = 28
const R_MICROBLAZE_TLSLD = 24
const R_MICROBLAZE_TLSTPREL32 = 29
const R_MIPS_16 = 1
const R_MIPS_26 = 4
const R_MIPS_32 = 2
const R_MIPS_64 = 18
const R_MIPS_ADD_IMMEDIATE = 34
const R_MIPS_CALL16 = 11
const R_MIPS_CALL_HI16 = 30
const R_MIPS_CALL_LO16 = 31
const R_MIPS_COPY = 126
const R_MIPS_DELETE = 27
const R_MIPS_GLOB_DAT = 51
const R_MIPS_GOT16 = 9
const R_MIPS_GOT_DISP = 19
const R_MIPS_GOT_HI16 = 22
const R_MIPS_GOT_LO16 = 23
const R_MIPS_GOT_OFST = 21
const R_MIPS_GOT_PAGE = 20
const R_MIPS_GPREL16 = 7
const R_MIPS_GPREL32 = 12
const R_MIPS_HI16 = 5
const R_MIPS_HIGHER = 28
const R_MIPS_HIGHEST = 29
const R_MIPS_INSERT_A = 25
const R_MIPS_INSERT_B = 26
const R_MIPS_JALR = 37
const R_MIPS_JUMP_SLOT = 127
const R_MIPS_LITERAL = 8
const R_MIPS_LO16 = 6
const R_MIPS_NONE = 0
const R_MIPS_NUM = 128
const R_MIPS_PC16 = 10
const R_MIPS_PJUMP = 35
const R_MIPS_REL16 = 33
const R_MIPS_REL32 = 3
const R_MIPS_RELGOT = 36
const R_MIPS_SCN_DISP = 32
const R_MIPS_SHIFT5 = 16
const R_MIPS_SHIFT6 = 17
const R_MIPS_SUB = 24
const R_MIPS_TLS_DTPMOD32 = 38
const R_MIPS_TLS_DTPMOD64 = 40
const R_MIPS_TLS_DTPREL32 = 39
const R_MIPS_TLS_DTPREL64 = 41
const R_MIPS_TLS_DTPREL_HI16 = 44
const R_MIPS_TLS_DTPREL_LO16 = 45
const R_MIPS_TLS_GD = 42
const R_MIPS_TLS_GOTTPREL = 46
const R_MIPS_TLS_LDM = 43
const R_MIPS_TLS_TPREL32 = 47
const R_MIPS_TLS_TPREL64 = 48
const R_MIPS_TLS_TPREL_HI16 = 49
const R_MIPS_TLS_TPREL_LO16 = 50
const R_MN10300_16 = 2
const R_MN10300_24 = 9
const R_MN10300_32 = 1
const R_MN10300_8 = 3
const R_MN10300_COPY = 20
const R_MN10300_GLOB_DAT = 21
const R_MN10300_GNU_VTENTRY = 8
const R_MN10300_GNU_VTINHERIT = 7
const R_MN10300_GOT16 = 19
const R_MN10300_GOT24 = 18
const R_MN10300_GOT32 = 17
const R_MN10300_GOTOFF16 = 14
const R_MN10300_GOTOFF24 = 13
const R_MN10300_GOTOFF32 = 12
const R_MN10300_GOTPC16 = 11
const R_MN10300_GOTPC32 = 10
const R_MN10300_JMP_SLOT = 22
const R_MN10300_NONE = 0
const R_MN10300_NUM = 24
const R_MN10300_PCREL16 = 5
const R_MN10300_PCREL32 = 4
const R_MN10300_PCREL8 = 6
const R_MN10300_PLT16 = 16
const R_MN10300_PLT32 = 15
const R_MN10300_RELATIVE = 23
const R_NIOS2_ALIGN = 21
const R_NIOS2_BFD_RELOC_16 = 13
const R_NIOS2_BFD_RELOC_32 = 12
const R_NIOS2_BFD_RELOC_8 = 14
const R_NIOS2_CACHE_OPX = 6
const R_NIOS2_CALL16 = 23
const R_NIOS2_CALL26 = 4
const R_NIOS2_CALL26_NOAT = 41
const R_NIOS2_CALLR = 20
const R_NIOS2_CALL_HA = 45
const R_NIOS2_CALL_LO = 44
const R_NIOS2_CJMP = 19
const R_NIOS2_COPY = 36
const R_NIOS2_GLOB_DAT = 37
const R_NIOS2_GNU_VTENTRY = 17
const R_NIOS2_GNU_VTINHERIT = 16
const R_NIOS2_GOT16 = 22
const R_NIOS2_GOTOFF = 40
const R_NIOS2_GOTOFF_HA = 25
const R_NIOS2_GOTOFF_LO = 24
const R_NIOS2_GOT_HA = 43
const R_NIOS2_GOT_LO = 42
const R_NIOS2_GPREL = 15
const R_NIOS2_HI16 = 9
const R_NIOS2_HIADJ16 = 11
const R_NIOS2_IMM5 = 5
const R_NIOS2_IMM6 = 7
const R_NIOS2_IMM8 = 8
const R_NIOS2_JUMP_SLOT = 38
const R_NIOS2_LO16 = 10
const R_NIOS2_NONE = 0
const R_NIOS2_PCREL16 = 3
const R_NIOS2_PCREL_HA = 27
const R_NIOS2_PCREL_LO = 26
const R_NIOS2_RELATIVE = 39
const R_NIOS2_S16 = 1
const R_NIOS2_TLS_DTPMOD = 33
const R_NIOS2_TLS_DTPREL = 34
const R_NIOS2_TLS_GD16 = 28
const R_NIOS2_TLS_IE16 = 31
const R_NIOS2_TLS_LDM16 = 29
const R_NIOS2_TLS_LDO16 = 30
const R_NIOS2_TLS_LE16 = 32
const R_NIOS2_TLS_TPREL = 35
const R_NIOS2_U16 = 2
const R_NIOS2_UJMP = 18
const R_OR1K_16 = 2
const R_OR1K_16_PCREL = 10
const R_OR1K_32 = 1
const R_OR1K_32_PCREL = 9
const R_OR1K_8 = 3
const R_OR1K_8_PCREL = 11
const R_OR1K_COPY = 18
const R_OR1K_GLOB_DAT = 19
const R_OR1K_GNU_VTENTRY = 7
const R_OR1K_GNU_VTINHERIT = 8
const R_OR1K_GOT16 = 14
const R_OR1K_GOTOFF_HI16 = 16
const R_OR1K_GOTOFF_LO16 = 17
const R_OR1K_GOTPC_HI16 = 12
const R_OR1K_GOTPC_LO16 = 13
const R_OR1K_HI_16_IN_INSN = 5
const R_OR1K_INSN_REL_26 = 6
const R_OR1K_JMP_SLOT = 20
const R_OR1K_LO_16_IN_INSN = 4
const R_OR1K_NONE = 0
const R_OR1K_PLT26 = 15
const R_OR1K_RELATIVE = 21
const R_OR1K_TLS_DTPMOD = 34
const R_OR1K_TLS_DTPOFF = 33
const R_OR1K_TLS_GD_HI16 = 22
const R_OR1K_TLS_GD_LO16 = 23
const R_OR1K_TLS_IE_HI16 = 28
const R_OR1K_TLS_IE_LO16 = 29
const R_OR1K_TLS_LDM_HI16 = 24
const R_OR1K_TLS_LDM_LO16 = 25
const R_OR1K_TLS_LDO_HI16 = 26
const R_OR1K_TLS_LDO_LO16 = 27
const R_OR1K_TLS_LE_HI16 = 30
const R_OR1K_TLS_LE_LO16 = 31
const R_OR1K_TLS_TPOFF = 32
const R_PARISC_COPY = 128
const R_PARISC_DIR14DR = 84
const R_PARISC_DIR14R = 6
const R_PARISC_DIR14WR = 83
const R_PARISC_DIR16DF = 87
const R_PARISC_DIR16F = 85
const R_PARISC_DIR16WF = 86
const R_PARISC_DIR17F = 4
const R_PARISC_DIR17R = 3
const R_PARISC_DIR21L = 2
const R_PARISC_DIR32 = 1
const R_PARISC_DIR64 = 80
const R_PARISC_DPREL14R = 22
const R_PARISC_DPREL21L = 18
const R_PARISC_EPLT = 130
const R_PARISC_FPTR64 = 64
const R_PARISC_GNU_VTENTRY = 232
const R_PARISC_GNU_VTINHERIT = 233
const R_PARISC_GPREL14DR = 92
const R_PARISC_GPREL14R = 30
const R_PARISC_GPREL14WR = 91
const R_PARISC_GPREL16DF = 95
const R_PARISC_GPREL16F = 93
const R_PARISC_GPREL16WF = 94
const R_PARISC_GPREL21L = 26
const R_PARISC_GPREL64 = 88
const R_PARISC_HIRESERVE = 255
const R_PARISC_IPLT = 129
const R_PARISC_LORESERVE = 128
const R_PARISC_LTOFF14DR = 100
const R_PARISC_LTOFF14R = 38
const R_PARISC_LTOFF14WR = 99
const R_PARISC_LTOFF16DF = 103
const R_PARISC_LTOFF16F = 101
const R_PARISC_LTOFF16WF = 102
const R_PARISC_LTOFF21L = 34
const R_PARISC_LTOFF64 = 96
const R_PARISC_LTOFF_FPTR14DR = 124
const R_PARISC_LTOFF_FPTR14R = 62
const R_PARISC_LTOFF_FPTR14WR = 123
const R_PARISC_LTOFF_FPTR16DF = 127
const R_PARISC_LTOFF_FPTR16F = 125
const R_PARISC_LTOFF_FPTR16WF = 126
const R_PARISC_LTOFF_FPTR21L = 58
const R_PARISC_LTOFF_FPTR32 = 57
const R_PARISC_LTOFF_FPTR64 = 120
const R_PARISC_LTOFF_TP14DR = 228
const R_PARISC_LTOFF_TP14F = 167
const R_PARISC_LTOFF_TP14R = 166
const R_PARISC_LTOFF_TP14WR = 227
const R_PARISC_LTOFF_TP16DF = 231
const R_PARISC_LTOFF_TP16F = 229
const R_PARISC_LTOFF_TP16WF = 230
const R_PARISC_LTOFF_TP21L = 162
const R_PARISC_LTOFF_TP64 = 224
const R_PARISC_NONE = 0
const R_PARISC_PCREL14DR = 76
const R_PARISC_PCREL14R = 14
const R_PARISC_PCREL14WR = 75
const R_PARISC_PCREL16DF = 79
const R_PARISC_PCREL16F = 77
const R_PARISC_PCREL16WF = 78
const R_PARISC_PCREL17F = 12
const R_PARISC_PCREL17R = 11
const R_PARISC_PCREL21L = 10
const R_PARISC_PCREL22F = 74
const R_PARISC_PCREL32 = 9
const R_PARISC_PCREL64 = 72
const R_PARISC_PLABEL14R = 70
const R_PARISC_PLABEL21L = 66
const R_PARISC_PLABEL32 = 65
const R_PARISC_PLTOFF14DR = 116
const R_PARISC_PLTOFF14R = 54
const R_PARISC_PLTOFF14WR = 115
const R_PARISC_PLTOFF16DF = 119
const R_PARISC_PLTOFF16F = 117
const R_PARISC_PLTOFF16WF = 118
const R_PARISC_PLTOFF21L = 50
const R_PARISC_SECREL32 = 41
const R_PARISC_SECREL64 = 104
const R_PARISC_SEGBASE = 48
const R_PARISC_SEGREL32 = 49
const R_PARISC_SEGREL64 = 112
const R_PARISC_TLS_DTPMOD32 = 242
const R_PARISC_TLS_DTPMOD64 = 243
const R_PARISC_TLS_DTPOFF32 = 244
const R_PARISC_TLS_DTPOFF64 = 245
const R_PARISC_TLS_GD14R = 235
const R_PARISC_TLS_GD21L = 234
const R_PARISC_TLS_GDCALL = 236
const R_PARISC_TLS_IE14R = 166
const R_PARISC_TLS_IE21L = 162
const R_PARISC_TLS_LDM14R = 238
const R_PARISC_TLS_LDM21L = 237
const R_PARISC_TLS_LDMCALL = 239
const R_PARISC_TLS_LDO14R = 241
const R_PARISC_TLS_LDO21L = 240
const R_PARISC_TLS_LE14R = 158
const R_PARISC_TLS_LE21L = 154
const R_PARISC_TLS_TPREL32 = 153
const R_PARISC_TLS_TPREL64 = 216
const R_PARISC_TPREL14DR = 220
const R_PARISC_TPREL14R = 158
const R_PARISC_TPREL14WR = 219
const R_PARISC_TPREL16DF = 223
const R_PARISC_TPREL16F = 221
const R_PARISC_TPREL16WF = 222
const R_PARISC_TPREL21L = 154
const R_PARISC_TPREL32 = 153
const R_PARISC_TPREL64 = 216
const R_PPC64_ADDR14 = 7
const R_PPC64_ADDR14_BRNTAKEN = 9
const R_PPC64_ADDR14_BRTAKEN = 8
const R_PPC64_ADDR16 = 3
const R_PPC64_ADDR16_DS = 56
const R_PPC64_ADDR16_HA = 6
const R_PPC64_ADDR16_HI = 5
const R_PPC64_ADDR16_HIGH = 110
const R_PPC64_ADDR16_HIGHA = 111
const R_PPC64_ADDR16_HIGHER = 39
const R_PPC64_ADDR16_HIGHERA = 40
const R_PPC64_ADDR16_HIGHEST = 41
const R_PPC64_ADDR16_HIGHESTA = 42
const R_PPC64_ADDR16_LO = 4
const R_PPC64_ADDR16_LO_DS = 57
const R_PPC64_ADDR24 = 2
const R_PPC64_ADDR30 = 37
const R_PPC64_ADDR32 = 1
const R_PPC64_ADDR64 = 38
const R_PPC64_COPY = 19
const R_PPC64_DTPMOD64 = 68
const R_PPC64_DTPREL16 = 74
const R_PPC64_DTPREL16_DS = 101
const R_PPC64_DTPREL16_HA = 77
const R_PPC64_DTPREL16_HI = 76
const R_PPC64_DTPREL16_HIGH = 114
const R_PPC64_DTPREL16_HIGHA = 115
const R_PPC64_DTPREL16_HIGHER = 103
const R_PPC64_DTPREL16_HIGHERA = 104
const R_PPC64_DTPREL16_HIGHEST = 105
const R_PPC64_DTPREL16_HIGHESTA = 106
const R_PPC64_DTPREL16_LO = 75
const R_PPC64_DTPREL16_LO_DS = 102
const R_PPC64_DTPREL64 = 78
const R_PPC64_GLOB_DAT = 20
const R_PPC64_GOT16 = 14
const R_PPC64_GOT16_DS = 58
const R_PPC64_GOT16_HA = 17
const R_PPC64_GOT16_HI = 16
const R_PPC64_GOT16_LO = 15
const R_PPC64_GOT16_LO_DS = 59
const R_PPC64_GOT_DTPREL16_DS = 91
const R_PPC64_GOT_DTPREL16_HA = 94
const R_PPC64_GOT_DTPREL16_HI = 93
const R_PPC64_GOT_DTPREL16_LO_DS = 92
const R_PPC64_GOT_TLSGD16 = 79
const R_PPC64_GOT_TLSGD16_HA = 82
const R_PPC64_GOT_TLSGD16_HI = 81
const R_PPC64_GOT_TLSGD16_LO = 80
const R_PPC64_GOT_TLSLD16 = 83
const R_PPC64_GOT_TLSLD16_HA = 86
const R_PPC64_GOT_TLSLD16_HI = 85
const R_PPC64_GOT_TLSLD16_LO = 84
const R_PPC64_GOT_TPREL16_DS = 87
const R_PPC64_GOT_TPREL16_HA = 90
const R_PPC64_GOT_TPREL16_HI = 89
const R_PPC64_GOT_TPREL16_LO_DS = 88
const R_PPC64_IRELATIVE = 248
const R_PPC64_JMP_IREL = 247
const R_PPC64_JMP_SLOT = 21
const R_PPC64_NONE = 0
const R_PPC64_PLT16_HA = 31
const R_PPC64_PLT16_HI = 30
const R_PPC64_PLT16_LO = 29
const R_PPC64_PLT16_LO_DS = 60
const R_PPC64_PLT32 = 27
const R_PPC64_PLT64 = 45
const R_PPC64_PLTGOT16 = 52
const R_PPC64_PLTGOT16_DS = 65
const R_PPC64_PLTGOT16_HA = 55
const R_PPC64_PLTGOT16_HI = 54
const R_PPC64_PLTGOT16_LO = 53
const R_PPC64_PLTGOT16_LO_DS = 66
const R_PPC64_PLTREL32 = 28
const R_PPC64_PLTREL64 = 46
const R_PPC64_REL14 = 11
const R_PPC64_REL14_BRNTAKEN = 13
const R_PPC64_REL14_BRTAKEN = 12
const R_PPC64_REL16 = 249
const R_PPC64_REL16_HA = 252
const R_PPC64_REL16_HI = 251
const R_PPC64_REL16_LO = 250
const R_PPC64_REL24 = 10
const R_PPC64_REL32 = 26
const R_PPC64_REL64 = 44
const R_PPC64_RELATIVE = 22
const R_PPC64_SECTOFF = 33
const R_PPC64_SECTOFF_DS = 61
const R_PPC64_SECTOFF_HA = 36
const R_PPC64_SECTOFF_HI = 35
const R_PPC64_SECTOFF_LO = 34
const R_PPC64_SECTOFF_LO_DS = 62
const R_PPC64_TLS = 67
const R_PPC64_TLSGD = 107
const R_PPC64_TLSLD = 108
const R_PPC64_TOC = 51
const R_PPC64_TOC16 = 47
const R_PPC64_TOC16_DS = 63
const R_PPC64_TOC16_HA = 50
const R_PPC64_TOC16_HI = 49
const R_PPC64_TOC16_LO = 48
const R_PPC64_TOC16_LO_DS = 64
const R_PPC64_TOCSAVE = 109
const R_PPC64_TPREL16 = 69
const R_PPC64_TPREL16_DS = 95
const R_PPC64_TPREL16_HA = 72
const R_PPC64_TPREL16_HI = 71
const R_PPC64_TPREL16_HIGH = 112
const R_PPC64_TPREL16_HIGHA = 113
const R_PPC64_TPREL16_HIGHER = 97
const R_PPC64_TPREL16_HIGHERA = 98
const R_PPC64_TPREL16_HIGHEST = 99
const R_PPC64_TPREL16_HIGHESTA = 100
const R_PPC64_TPREL16_LO = 70
const R_PPC64_TPREL16_LO_DS = 96
const R_PPC64_TPREL64 = 73
const R_PPC64_UADDR16 = 25
const R_PPC64_UADDR32 = 24
const R_PPC64_UADDR64 = 43
const R_PPC_ADDR14 = 7
const R_PPC_ADDR14_BRNTAKEN = 9
const R_PPC_ADDR14_BRTAKEN = 8
const R_PPC_ADDR16 = 3
const R_PPC_ADDR16_HA = 6
const R_PPC_ADDR16_HI = 5
const R_PPC_ADDR16_LO = 4
const R_PPC_ADDR24 = 2
const R_PPC_ADDR32 = 1
const R_PPC_COPY = 19
const R_PPC_DIAB_RELSDA_HA = 185
const R_PPC_DIAB_RELSDA_HI = 184
const R_PPC_DIAB_RELSDA_LO = 183
const R_PPC_DIAB_SDA21_HA = 182
const R_PPC_DIAB_SDA21_HI = 181
const R_PPC_DIAB_SDA21_LO = 180
const R_PPC_DTPMOD32 = 68
const R_PPC_DTPREL16 = 74
const R_PPC_DTPREL16_HA = 77
const R_PPC_DTPREL16_HI = 76
const R_PPC_DTPREL16_LO = 75
const R_PPC_DTPREL32 = 78
const R_PPC_EMB_BIT_FLD = 115
const R_PPC_EMB_MRKREF = 110
const R_PPC_EMB_NADDR16 = 102
const R_PPC_EMB_NADDR16_HA = 105
const R_PPC_EMB_NADDR16_HI = 104
const R_PPC_EMB_NADDR16_LO = 103
const R_PPC_EMB_NADDR32 = 101
const R_PPC_EMB_RELSDA = 116
const R_PPC_EMB_RELSEC16 = 111
const R_PPC_EMB_RELST_HA = 114
const R_PPC_EMB_RELST_HI = 113
const R_PPC_EMB_RELST_LO = 112
const R_PPC_EMB_SDA21 = 109
const R_PPC_EMB_SDA2I16 = 107
const R_PPC_EMB_SDA2REL = 108
const R_PPC_EMB_SDAI16 = 106
const R_PPC_GLOB_DAT = 20
const R_PPC_GOT16 = 14
const R_PPC_GOT16_HA = 17
const R_PPC_GOT16_HI = 16
const R_PPC_GOT16_LO = 15
const R_PPC_GOT_DTPREL16 = 91
const R_PPC_GOT_DTPREL16_HA = 94
const R_PPC_GOT_DTPREL16_HI = 93
const R_PPC_GOT_DTPREL16_LO = 92
const R_PPC_GOT_TLSGD16 = 79
const R_PPC_GOT_TLSGD16_HA = 82
const R_PPC_GOT_TLSGD16_HI = 81
const R_PPC_GOT_TLSGD16_LO = 80
const R_PPC_GOT_TLSLD16 = 83
const R_PPC_GOT_TLSLD16_HA = 86
const R_PPC_GOT_TLSLD16_HI = 85
const R_PPC_GOT_TLSLD16_LO = 84
const R_PPC_GOT_TPREL16 = 87
const R_PPC_GOT_TPREL16_HA = 90
const R_PPC_GOT_TPREL16_HI = 89
const R_PPC_GOT_TPREL16_LO = 88
const R_PPC_IRELATIVE = 248
const R_PPC_JMP_SLOT = 21
const R_PPC_LOCAL24PC = 23
const R_PPC_NONE = 0
const R_PPC_PLT16_HA = 31
const R_PPC_PLT16_HI = 30
const R_PPC_PLT16_LO = 29
const R_PPC_PLT32 = 27
const R_PPC_PLTREL24 = 18
const R_PPC_PLTREL32 = 28
const R_PPC_REL14 = 11
const R_PPC_REL14_BRNTAKEN = 13
const R_PPC_REL14_BRTAKEN = 12
const R_PPC_REL16 = 249
const R_PPC_REL16_HA = 252
const R_PPC_REL16_HI = 251
const R_PPC_REL16_LO = 250
const R_PPC_REL24 = 10
const R_PPC_REL32 = 26
const R_PPC_RELATIVE = 22
const R_PPC_SDAREL16 = 32
const R_PPC_SECTOFF = 33
const R_PPC_SECTOFF_HA = 36
const R_PPC_SECTOFF_HI = 35
const R_PPC_SECTOFF_LO = 34
const R_PPC_TLS = 67
const R_PPC_TLSGD = 95
const R_PPC_TLSLD = 96
const R_PPC_TOC16 = 255
const R_PPC_TPREL16 = 69
const R_PPC_TPREL16_HA = 72
const R_PPC_TPREL16_HI = 71
const R_PPC_TPREL16_LO = 70
const R_PPC_TPREL32 = 73
const R_PPC_UADDR16 = 25
const R_PPC_UADDR32 = 24
const R_RISCV_32 = 1
const R_RISCV_32_PCREL = 57
const R_RISCV_64 = 2
const R_RISCV_ADD16 = 34
const R_RISCV_ADD32 = 35
const R_RISCV_ADD64 = 36
const R_RISCV_ADD8 = 33
const R_RISCV_ALIGN = 43
const R_RISCV_BRANCH = 16
const R_RISCV_CALL = 18
const R_RISCV_CALL_PLT = 19
const R_RISCV_COPY = 4
const R_RISCV_GOT32_PCREL = 41
const R_RISCV_GOT_HI20 = 20
const R_RISCV_HI20 = 26
const R_RISCV_IRELATIVE = 58
const R_RISCV_JAL = 17
const R_RISCV_JUMP_SLOT = 5
const R_RISCV_LO12_I = 27
const R_RISCV_LO12_S = 28
const R_RISCV_NONE = 0
const R_RISCV_PCREL_HI20 = 23
const R_RISCV_PCREL_LO12_I = 24
const R_RISCV_PCREL_LO12_S = 25
const R_RISCV_PLT32 = 59
const R_RISCV_RELATIVE = 3
const R_RISCV_RELAX = 51
const R_RISCV_RVC_BRANCH = 44
const R_RISCV_RVC_JUMP = 45
const R_RISCV_RVC_LUI = 46
const R_RISCV_SET16 = 55
const R_RISCV_SET32 = 56
const R_RISCV_SET6 = 53
const R_RISCV_SET8 = 54
const R_RISCV_SET_ULEB128 = 60
const R_RISCV_SUB16 = 38
const R_RISCV_SUB32 = 39
const R_RISCV_SUB6 = 52
const R_RISCV_SUB64 = 40
const R_RISCV_SUB8 = 37
const R_RISCV_SUB_ULEB128 = 61
const R_RISCV_TLSDESC = 12
const R_RISCV_TLSDESC_ADD_LO12 = 64
const R_RISCV_TLSDESC_CALL = 65
const R_RISCV_TLSDESC_HI20 = 62
const R_RISCV_TLSDESC_LOAD_LO12 = 63
const R_RISCV_TLS_DTPMOD32 = 6
const R_RISCV_TLS_DTPMOD64 = 7
const R_RISCV_TLS_DTPREL32 = 8
const R_RISCV_TLS_DTPREL64 = 9
const R_RISCV_TLS_GD_HI20 = 22
const R_RISCV_TLS_GOT_HI20 = 21
const R_RISCV_TLS_TPREL32 = 10
const R_RISCV_TLS_TPREL64 = 11
const R_RISCV_TPREL_ADD = 32
const R_RISCV_TPREL_HI20 = 29
const R_RISCV_TPREL_LO12_I = 30
const R_RISCV_TPREL_LO12_S = 31
const R_SH_ALIGN = 29
const R_SH_CODE = 30
const R_SH_COPY = 162
const R_SH_COUNT = 28
const R_SH_DATA = 31
const R_SH_DIR32 = 1
const R_SH_DIR8BP = 7
const R_SH_DIR8L = 9
const R_SH_DIR8W = 8
const R_SH_DIR8WPL = 5
const R_SH_DIR8WPN = 3
const R_SH_DIR8WPZ = 6
const R_SH_FUNCDESC = 207
const R_SH_FUNCDESC_VALUE = 208
const R_SH_GLOB_DAT = 163
const R_SH_GNU_VTENTRY = 35
const R_SH_GNU_VTINHERIT = 34
const R_SH_GOT20 = 201
const R_SH_GOT32 = 160
const R_SH_GOTFUNCDESC = 203
const R_SH_GOTFUNCDEST20 = 204
const R_SH_GOTOFF = 166
const R_SH_GOTOFF20 = 202
const R_SH_GOTOFFFUNCDESC = 205
const R_SH_GOTOFFFUNCDEST20 = 206
const R_SH_GOTPC = 167
const R_SH_IND12W = 4
const R_SH_JMP_SLOT = 164
const R_SH_LABEL = 32
const R_SH_NONE = 0
const R_SH_NUM = 256
const R_SH_PLT32 = 161
const R_SH_REL32 = 2
const R_SH_RELATIVE = 165
const R_SH_SWITCH16 = 25
const R_SH_SWITCH32 = 26
const R_SH_SWITCH8 = 33
const R_SH_TLS_DTPMOD32 = 149
const R_SH_TLS_DTPOFF32 = 150
const R_SH_TLS_GD_32 = 144
const R_SH_TLS_IE_32 = 147
const R_SH_TLS_LDO_32 = 146
const R_SH_TLS_LD_32 = 145
const R_SH_TLS_LE_32 = 148
const R_SH_TLS_TPOFF32 = 151
const R_SH_USES = 27
const R_SPARC_10 = 30
const R_SPARC_11 = 31
const R_SPARC_13 = 11
const R_SPARC_16 = 2
const R_SPARC_22 = 10
const R_SPARC_32 = 3
const R_SPARC_5 = 44
const R_SPARC_6 = 45
const R_SPARC_64 = 32
const R_SPARC_7 = 43
const R_SPARC_8 = 1
const R_SPARC_COPY = 19
const R_SPARC_DISP16 = 5
const R_SPARC_DISP32 = 6
const R_SPARC_DISP64 = 46
const R_SPARC_DISP8 = 4
const R_SPARC_GLOB_DAT = 20
const R_SPARC_GLOB_JMP = 42
const R_SPARC_GNU_VTENTRY = 251
const R_SPARC_GNU_VTINHERIT = 250
const R_SPARC_GOT10 = 13
const R_SPARC_GOT13 = 14
const R_SPARC_GOT22 = 15
const R_SPARC_GOTDATA_HIX22 = 80
const R_SPARC_GOTDATA_LOX10 = 81
const R_SPARC_GOTDATA_OP = 84
const R_SPARC_GOTDATA_OP_HIX22 = 82
const R_SPARC_GOTDATA_OP_LOX10 = 83
const R_SPARC_H34 = 85
const R_SPARC_H44 = 50
const R_SPARC_HH22 = 34
const R_SPARC_HI22 = 9
const R_SPARC_HIPLT22 = 25
const R_SPARC_HIX22 = 48
const R_SPARC_HM10 = 35
const R_SPARC_JMP_SLOT = 21
const R_SPARC_L44 = 52
const R_SPARC_LM22 = 36
const R_SPARC_LO10 = 12
const R_SPARC_LOPLT10 = 26
const R_SPARC_LOX10 = 49
const R_SPARC_M44 = 51
const R_SPARC_NONE = 0
const R_SPARC_NUM = 253
const R_SPARC_OLO10 = 33
const R_SPARC_PC10 = 16
const R_SPARC_PC22 = 17
const R_SPARC_PCPLT10 = 29
const R_SPARC_PCPLT22 = 28
const R_SPARC_PCPLT32 = 27
const R_SPARC_PC_HH22 = 37
const R_SPARC_PC_HM10 = 38
const R_SPARC_PC_LM22 = 39
const R_SPARC_PLT32 = 24
const R_SPARC_PLT64 = 47
const R_SPARC_REGISTER = 53
const R_SPARC_RELATIVE = 22
const R_SPARC_REV32 = 252
const R_SPARC_SIZE32 = 86
const R_SPARC_SIZE64 = 87
const R_SPARC_TLS_DTPMOD32 = 74
const R_SPARC_TLS_DTPMOD64 = 75
const R_SPARC_TLS_DTPOFF32 = 76
const R_SPARC_TLS_DTPOFF64 = 77
const R_SPARC_TLS_GD_ADD = 58
const R_SPARC_TLS_GD_CALL = 59
const R_SPARC_TLS_GD_HI22 = 56
const R_SPARC_TLS_GD_LO10 = 57
const R_SPARC_TLS_IE_ADD = 71
const R_SPARC_TLS_IE_HI22 = 67
const R_SPARC_TLS_IE_LD = 69
const R_SPARC_TLS_IE_LDX = 70
const R_SPARC_TLS_IE_LO10 = 68
const R_SPARC_TLS_LDM_ADD = 62
const R_SPARC_TLS_LDM_CALL = 63
const R_SPARC_TLS_LDM_HI22 = 60
const R_SPARC_TLS_LDM_LO10 = 61
const R_SPARC_TLS_LDO_ADD = 66
const R_SPARC_TLS_LDO_HIX22 = 64
const R_SPARC_TLS_LDO_LOX10 = 65
const R_SPARC_TLS_LE_HIX22 = 72
const R_SPARC_TLS_LE_LOX10 = 73
const R_SPARC_TLS_TPOFF32 = 78
const R_SPARC_TLS_TPOFF64 = 79
const R_SPARC_UA16 = 55
const R_SPARC_UA32 = 23
const R_SPARC_UA64 = 54
const R_SPARC_WDISP16 = 40
const R_SPARC_WDISP19 = 41
const R_SPARC_WDISP22 = 8
const R_SPARC_WDISP30 = 7
const R_SPARC_WPLT30 = 18
const R_X86_64_16 = 12
const R_X86_64_32 = 10
const R_X86_64_32S = 11
const R_X86_64_64 = 1
const R_X86_64_8 = 14
const R_X86_64_COPY = 5
const R_X86_64_DTPMOD64 = 16
const R_X86_64_DTPOFF32 = 21
const R_X86_64_DTPOFF64 = 17
const R_X86_64_GLOB_DAT = 6
const R_X86_64_GOT32 = 3
const R_X86_64_GOT64 = 27
const R_X86_64_GOTOFF64 = 25
const R_X86_64_GOTPC32 = 26
const R_X86_64_GOTPC32_TLSDESC = 34
const R_X86_64_GOTPC64 = 29
const R_X86_64_GOTPCREL = 9
const R_X86_64_GOTPCREL64 = 28
const R_X86_64_GOTPCRELX = 41
const R_X86_64_GOTPLT64 = 30
const R_X86_64_GOTTPOFF = 22
const R_X86_64_IRELATIVE = 37
const R_X86_64_JUMP_SLOT = 7
const R_X86_64_NONE = 0
const R_X86_64_NUM = 43
const R_X86_64_PC16 = 13
const R_X86_64_PC32 = 2
const R_X86_64_PC64 = 24
const R_X86_64_PC8 = 15
const R_X86_64_PLT32 = 4
const R_X86_64_PLTOFF64 = 31
const R_X86_64_RELATIVE = 8
const R_X86_64_RELATIVE64 = 38
const R_X86_64_REX_GOTPCRELX = 42
const R_X86_64_SIZE32 = 32
const R_X86_64_SIZE64 = 33
const R_X86_64_TLSDESC = 36
const R_X86_64_TLSDESC_CALL = 35
const R_X86_64_TLSGD = 19
const R_X86_64_TLSLD = 20
const R_X86_64_TPOFF32 = 23
const R_X86_64_TPOFF64 = 18
const SA_EXPOSE_TAGBITS = 2048
const SA_NOCLDSTOP = 1
const SA_NOCLDWAIT = 2
const SA_NODEFER = 1073741824
const SA_ONSTACK = 134217728
const SA_RESETHAND = 2147483648
const SA_RESTART = 268435456
const SA_RESTORER = 67108864
const SA_SIGINFO = 4
const SA_UNSUPPORTED = 1024
const SCM_TIMESTAMPING_OLD = 37
const SCM_TIMESTAMPNS_OLD = 35
const SCM_TIMESTAMP_OLD = 29
const SEGV_ACCERR = 2
const SEGV_BNDERR = 3
const SEGV_MAPERR = 1
const SEGV_MTEAERR = 8
const SEGV_MTESERR = 9
const SEGV_PKUERR = 4
const SELFMAG = 4
const SHF_ALLOC = 2
const SHF_ALPHA_GPREL = 268435456
const SHF_ARM_COMDEF = 2147483648
const SHF_ARM_ENTRYSECT = 268435456
const SHF_COMPRESSED = 2048
const SHF_EXCLUDE = 2147483648
const SHF_EXECINSTR = 4
const SHF_GROUP = 512
const SHF_IA_64_NORECOV = 536870912
const SHF_IA_64_SHORT = 268435456
const SHF_INFO_LINK = 64
const SHF_LINK_ORDER = 128
const SHF_MASKOS = 267386880
const SHF_MASKPROC = 4026531840
const SHF_MERGE = 16
const SHF_MIPS_ADDR = 1073741824
const SHF_MIPS_GPREL = 268435456
const SHF_MIPS_LOCAL = 67108864
const SHF_MIPS_MERGE = 536870912
const SHF_MIPS_NAMES = 33554432
const SHF_MIPS_NODUPE = 16777216
const SHF_MIPS_NOSTRIP = 134217728
const SHF_MIPS_STRINGS = 2147483648
const SHF_ORDERED = 1073741824
const SHF_OS_NONCONFORMING = 256
const SHF_PARISC_HUGE = 1073741824
const SHF_PARISC_SBP = 2147483648
const SHF_PARISC_SHORT = 536870912
const SHF_STRINGS = 32
const SHF_TLS = 1024
const SHF_WRITE = 1
const SHN_ABS = 65521
const SHN_AFTER = 65281
const SHN_BEFORE = 65280
const SHN_COMMON = 65522
const SHN_HIOS = 65343
const SHN_HIPROC = 65311
const SHN_HIRESERVE = 65535
const SHN_LOOS = 65312
const SHN_LOPROC = 65280
const SHN_LORESERVE = 65280
const SHN_MIPS_ACOMMON = 65280
const SHN_MIPS_DATA = 65282
const SHN_MIPS_SCOMMON = 65283
const SHN_MIPS_SUNDEFINED = 65284
const SHN_MIPS_TEXT = 65281
const SHN_PARISC_ANSI_COMMON = 65280
const SHN_PARISC_HUGE_COMMON = 65281
const SHN_UNDEF = 0
const SHN_XINDEX = 65535
const SHT_ALPHA_DEBUG = 1879048193
const SHT_ALPHA_REGINFO = 1879048194
const SHT_ARM_ATTRIBUTES = 1879048195
const SHT_ARM_EXIDX = 1879048193
const SHT_ARM_PREEMPTMAP = 1879048194
const SHT_CHECKSUM = 1879048184
const SHT_DYNAMIC = 6
const SHT_DYNSYM = 11
const SHT_FINI_ARRAY = 15
const SHT_GNU_ATTRIBUTES = 1879048181
const SHT_GNU_HASH = 1879048182
const SHT_GNU_LIBLIST = 1879048183
const SHT_GNU_verdef = 1879048189
const SHT_GNU_verneed = 1879048190
const SHT_GNU_versym = 1879048191
const SHT_GROUP = 17
const SHT_HASH = 5
const SHT_HIOS = 1879048191
const SHT_HIPROC = 2147483647
const SHT_HISUNW = 1879048191
const SHT_HIUSER = 2415919103
const SHT_IA_64_EXT = 1879048192
const SHT_IA_64_UNWIND = 1879048193
const SHT_INIT_ARRAY = 14
const SHT_LOOS = 1610612736
const SHT_LOPROC = 1879048192
const SHT_LOSUNW = 1879048186
const SHT_LOUSER = 2147483648
const SHT_MIPS_AUXSYM = 1879048214
const SHT_MIPS_CONFLICT = 1879048194
const SHT_MIPS_CONTENT = 1879048204
const SHT_MIPS_DEBUG = 1879048197
const SHT_MIPS_DELTACLASS = 1879048221
const SHT_MIPS_DELTADECL = 1879048223
const SHT_MIPS_DELTAINST = 1879048220
const SHT_MIPS_DELTASYM = 1879048219
const SHT_MIPS_DENSE = 1879048211
const SHT_MIPS_DWARF = 1879048222
const SHT_MIPS_EH_REGION = 1879048231
const SHT_MIPS_EVENTS = 1879048225
const SHT_MIPS_EXTSYM = 1879048210
const SHT_MIPS_FDESC = 1879048209
const SHT_MIPS_GPTAB = 1879048195
const SHT_MIPS_IFACE = 1879048203
const SHT_MIPS_LIBLIST = 1879048192
const SHT_MIPS_LINE = 1879048217
const SHT_MIPS_LOCSTR = 1879048216
const SHT_MIPS_LOCSYM = 1879048213
const SHT_MIPS_MSYM = 1879048193
const SHT_MIPS_OPTIONS = 1879048205
const SHT_MIPS_OPTSYM = 1879048215
const SHT_MIPS_PACKAGE = 1879048199
const SHT_MIPS_PACKSYM = 1879048200
const SHT_MIPS_PDESC = 1879048212
const SHT_MIPS_PDR_EXCEPTION = 1879048233
const SHT_MIPS_PIXIE = 1879048227
const SHT_MIPS_REGINFO = 1879048198
const SHT_MIPS_RELD = 1879048201
const SHT_MIPS_RFDESC = 1879048218
const SHT_MIPS_SHDR = 1879048208
const SHT_MIPS_SYMBOL_LIB = 1879048224
const SHT_MIPS_TRANSLATE = 1879048226
const SHT_MIPS_UCODE = 1879048196
const SHT_MIPS_WHIRL = 1879048230
const SHT_MIPS_XLATE = 1879048228
const SHT_MIPS_XLATE_DEBUG = 1879048229
const SHT_MIPS_XLATE_OLD = 1879048232
const SHT_NOBITS = 8
const SHT_NOTE = 7
const SHT_NULL = 0
const SHT_NUM = 20
const SHT_PARISC_DOC = 1879048194
const SHT_PARISC_EXT = 1879048192
const SHT_PARISC_UNWIND = 1879048193
const SHT_PREINIT_ARRAY = 16
const SHT_PROGBITS = 1
const SHT_REL = 9
const SHT_RELA = 4
const SHT_RELR = 19
const SHT_SHLIB = 10
const SHT_STRTAB = 3
const SHT_SUNW_COMDAT = 1879048187
const SHT_SUNW_move = 1879048186
const SHT_SUNW_syminfo = 1879048188
const SHT_SYMTAB = 2
const SHT_SYMTAB_SHNDX = 18
const SIGABRT = 6
const SIGALRM = 14
const SIGBUS = 7
const SIGCHLD = 17
const SIGCONT = 18
const SIGEV_NONE = 1
const SIGEV_SIGNAL = 0
const SIGEV_THREAD = 2
const SIGEV_THREAD_ID = 4
const SIGFPE = 8
const SIGHUP = 1
const SIGILL = 4
const SIGINT = 2
const SIGIO = 29
const SIGIOT = 6
const SIGKILL = 9
const SIGPIPE = 13
const SIGPOLL = 29
const SIGPROF = 27
const SIGPWR = 30
const SIGQUIT = 3
const SIGRTMAX = 0
const SIGRTMIN = 0
const SIGSEGV = 11
const SIGSTKFLT = 16
const SIGSTKSZ = 12288
const SIGSTOP = 19
const SIGSYS = 31
const SIGTERM = 15
const SIGTRAP = 5
const SIGTSTP = 20
const SIGTTIN = 21
const SIGTTOU = 22
const SIGUNUSED = 31
const SIGURG = 23
const SIGUSR1 = 10
const SIGUSR2 = 12
const SIGVTALRM = 26
const SIGWINCH = 28
const SIGXCPU = 24
const SIGXFSZ = 25
const SIG_BLOCK = 0
const SIG_SETMASK = 2
const SIG_UNBLOCK = 1
const SIOCGSTAMPNS_OLD = 35079
const SIOCGSTAMP_OLD = 35078
const SI_ASYNCIO = -4
const SI_ASYNCNL = -60
const SI_KERNEL = 128
const SI_MESGQ = -3
const SI_QUEUE = -1
const SI_SIGIO = -5
const SI_TIMER = -2
const SI_TKILL = -6
const SI_USER = 0
const SO_RCVTIMEO_OLD = 20
const SO_SNDTIMEO_OLD = 21
const SO_TIMESTAMPING_OLD = 37
const SO_TIMESTAMPNS_OLD = 35
const SO_TIMESTAMP_OLD = 29
const SS_AUTODISARM = 2147483648
const SS_DISABLE = 2
const SS_FLAG_BITS = 2147483648
const SS_ONSTACK = 1
const STB_GLOBAL = 1
const STB_GNU_UNIQUE = 10
const STB_HIOS = 12
const STB_HIPROC = 15
const STB_LOCAL = 0
const STB_LOOS = 10
const STB_LOPROC = 13
const STB_MIPS_SPLIT_COMMON = 13
const STB_NUM = 3
const STB_WEAK = 2
const STN_UNDEF = 0
const STO_ALPHA_NOPV = 128
const STO_ALPHA_STD_GPLOAD = 136
const STO_MIPS_DEFAULT = 0
const STO_MIPS_HIDDEN = 2
const STO_MIPS_INTERNAL = 1
const STO_MIPS_PLT = 8
const STO_MIPS_PROTECTED = 3
const STO_MIPS_SC_ALIGN_UNUSED = 255
const STO_PPC64_LOCAL_BIT = 5
const STO_PPC64_LOCAL_MASK = 224
const STT_ARM_16BIT = 15
const STT_ARM_TFUNC = 13
const STT_COMMON = 5
const STT_FILE = 4
const STT_FUNC = 2
const STT_GNU_IFUNC = 10
const STT_HIOS = 12
const STT_HIPROC = 15
const STT_HP_OPAQUE = 11
const STT_HP_STUB = 12
const STT_LOOS = 10
const STT_LOPROC = 13
const STT_NOTYPE = 0
const STT_NUM = 7
const STT_OBJECT = 1
const STT_PARISC_MILLICODE = 13
const STT_SECTION = 3
const STT_SPARC_REGISTER = 13
const STT_TLS = 6
const STV_DEFAULT = 0
const STV_HIDDEN = 2
const STV_INTERNAL = 1
const STV_PROTECTED = 3
const SYMINFO_BT_LOWRESERVE = 65280
const SYMINFO_BT_PARENT = 65534
const SYMINFO_BT_SELF = 65535
const SYMINFO_CURRENT = 1
const SYMINFO_FLG_COPY = 4
const SYMINFO_FLG_DIRECT = 1
const SYMINFO_FLG_LAZYLOAD = 8
const SYMINFO_FLG_PASSTHRU = 2
const SYMINFO_NONE = 0
const SYMINFO_NUM = 2
const SYSCALL_MMAP2_UNIT = 4096
const SYSCALL_RLIM_INFINITY = 18446744073709551615
const SYS_accept = 202
const SYS_accept4 = 242
const SYS_acct = 89
const SYS_add_key = 217
const SYS_adjtimex = 171
const SYS_bind = 200
const SYS_bpf = 280
const SYS_brk = 214
const SYS_cachestat = 451
const SYS_capget = 90
const SYS_capset = 91
const SYS_chdir = 49
const SYS_chroot = 51
const SYS_clock_adjtime = 266
const SYS_clock_getres = 114
const SYS_clock_gettime = 113
const SYS_clock_nanosleep = 115
const SYS_clock_settime = 112
const SYS_clone = 220
const SYS_clone3 = 435
const SYS_close = 57
const SYS_close_range = 436
const SYS_connect = 203
const SYS_copy_file_range = 285
const SYS_delete_module = 106
const SYS_dup = 23
const SYS_dup3 = 24
const SYS_epoll_create1 = 20
const SYS_epoll_ctl = 21
const SYS_epoll_pwait = 22
const SYS_epoll_pwait2 = 441
const SYS_eventfd2 = 19
const SYS_execve = 221
const SYS_execveat = 281
const SYS_exit = 93
const SYS_exit_group = 94
const SYS_faccessat = 48
const SYS_faccessat2 = 439
const SYS_fadvise64 = 223
const SYS_fallocate = 47
const SYS_fanotify_init = 262
const SYS_fanotify_mark = 263
const SYS_fchdir = 50
const SYS_fchmod = 52
const SYS_fchmodat = 53
const SYS_fchmodat2 = 452
const SYS_fchown = 55
const SYS_fchownat = 54
const SYS_fcntl = 25
const SYS_fdatasync = 83
const SYS_fgetxattr = 10
const SYS_finit_module = 273
const SYS_flistxattr = 13
const SYS_flock = 32
const SYS_fremovexattr = 16
const SYS_fsconfig = 431
const SYS_fsetxattr = 7
const SYS_fsmount = 432
const SYS_fsopen = 430
const SYS_fspick = 433
const SYS_fstat = 80
const SYS_fstatfs = 44
const SYS_fsync = 82
const SYS_ftruncate = 46
const SYS_futex = 98
const SYS_futex_waitv = 449
const SYS_get_mempolicy = 236
const SYS_get_robust_list = 100
const SYS_getcpu = 168
const SYS_getcwd = 17
const SYS_getdents64 = 61
const SYS_getegid = 177
const SYS_geteuid = 175
const SYS_getgid = 176
const SYS_getgroups = 158
const SYS_getitimer = 102
const SYS_getpeername = 205
const SYS_getpgid = 155
const SYS_getpid = 172
const SYS_getppid = 173
const SYS_getpriority = 141
const SYS_getrandom = 278
const SYS_getresgid = 150
const SYS_getresuid = 148
const SYS_getrlimit = 163
const SYS_getrusage = 165
const SYS_getsid = 156
const SYS_getsockname = 204
const SYS_getsockopt = 209
const SYS_gettid = 178
const SYS_gettimeofday = 169
const SYS_getuid = 174
const SYS_getxattr = 8
const SYS_init_module = 105
const SYS_inotify_add_watch = 27
const SYS_inotify_init1 = 26
const SYS_inotify_rm_watch = 28
const SYS_io_cancel = 3
const SYS_io_destroy = 1
const SYS_io_getevents = 4
const SYS_io_pgetevents = 292
const SYS_io_setup = 0
const SYS_io_submit = 2
const SYS_io_uring_enter = 426
const SYS_io_uring_register = 427
const SYS_io_uring_setup = 425
const SYS_ioctl = 29
const SYS_ioprio_get = 31
const SYS_ioprio_set = 30
const SYS_kcmp = 272
const SYS_kexec_file_load = 294
const SYS_kexec_load = 104
const SYS_keyctl = 219
const SYS_kill = 129
const SYS_landlock_add_rule = 445
const SYS_landlock_create_ruleset = 444
const SYS_landlock_restrict_self = 446
const SYS_lgetxattr = 9
const SYS_linkat = 37
const SYS_listen = 201
const SYS_listxattr = 11
const SYS_llistxattr = 12
const SYS_lookup_dcookie = 18
const SYS_lremovexattr = 15
const SYS_lseek = 62
const SYS_lsetxattr = 6
const SYS_madvise = 233
const SYS_mbind = 235
const SYS_membarrier = 283
const SYS_memfd_create = 279
const SYS_migrate_pages = 238
const SYS_mincore = 232
const SYS_mkdirat = 34
const SYS_mknodat = 33
const SYS_mlock = 228
const SYS_mlock2 = 284
const SYS_mlockall = 230
const SYS_mmap = 222
const SYS_mount = 40
const SYS_mount_setattr = 442
const SYS_move_mount = 429
const SYS_move_pages = 239
const SYS_mprotect = 226
const SYS_mq_getsetattr = 185
const SYS_mq_notify = 184
const SYS_mq_open = 180
const SYS_mq_timedreceive = 183
const SYS_mq_timedsend = 182
const SYS_mq_unlink = 181
const SYS_mremap = 216
const SYS_msgctl = 187
const SYS_msgget = 186
const SYS_msgrcv = 188
const SYS_msgsnd = 189
const SYS_msync = 227
const SYS_munlock = 229
const SYS_munlockall = 231
const SYS_munmap = 215
const SYS_name_to_handle_at = 264
const SYS_nanosleep = 101
const SYS_newfstatat = 79
const SYS_nfsservctl = 42
const SYS_open_by_handle_at = 265
const SYS_open_tree = 428
const SYS_openat = 56
const SYS_openat2 = 437
const SYS_perf_event_open = 241
const SYS_personality = 92
const SYS_pidfd_getfd = 438
const SYS_pidfd_open = 434
const SYS_pidfd_send_signal = 424
const SYS_pipe2 = 59
const SYS_pivot_root = 41
const SYS_pkey_alloc = 289
const SYS_pkey_free = 290
const SYS_pkey_mprotect = 288
const SYS_ppoll = 73
const SYS_prctl = 167
const SYS_pread64 = 67
const SYS_preadv = 69
const SYS_preadv2 = 286
const SYS_prlimit64 = 261
const SYS_process_madvise = 440
const SYS_process_mrelease = 448
const SYS_process_vm_readv = 270
const SYS_process_vm_writev = 271
const SYS_pselect6 = 72
const SYS_ptrace = 117
const SYS_pwrite64 = 68
const SYS_pwritev = 70
const SYS_pwritev2 = 287
const SYS_quotactl = 60
const SYS_read = 63
const SYS_readahead = 213
const SYS_readlinkat = 78
const SYS_readv = 65
const SYS_reboot = 142
const SYS_recvfrom = 207
const SYS_recvmmsg = 243
const SYS_recvmsg = 212
const SYS_remap_file_pages = 234
const SYS_removexattr = 14
const SYS_renameat = 38
const SYS_renameat2 = 276
const SYS_request_key = 218
const SYS_restart_syscall = 128
const SYS_rseq = 293
const SYS_rt_sigaction = 134
const SYS_rt_sigpending = 136
const SYS_rt_sigprocmask = 135
const SYS_rt_sigqueueinfo = 138
const SYS_rt_sigreturn = 139
const SYS_rt_sigsuspend = 133
const SYS_rt_sigtimedwait = 137
const SYS_rt_tgsigqueueinfo = 240
const SYS_sched_get_priority_max = 125
const SYS_sched_get_priority_min = 126
const SYS_sched_getaffinity = 123
const SYS_sched_getattr = 275
const SYS_sched_getparam = 121
const SYS_sched_getscheduler = 120
const SYS_sched_rr_get_interval = 127
const SYS_sched_setaffinity = 122
const SYS_sched_setattr = 274
const SYS_sched_setparam = 118
const SYS_sched_setscheduler = 119
const SYS_sched_yield = 124
const SYS_seccomp = 277
const SYS_semctl = 191
const SYS_semget = 190
const SYS_semop = 193
const SYS_semtimedop = 192
const SYS_sendfile = 71
const SYS_sendmmsg = 269
const SYS_sendmsg = 211
const SYS_sendto = 206
const SYS_set_mempolicy = 237
const SYS_set_mempolicy_home_node = 450
const SYS_set_robust_list = 99
const SYS_set_tid_address = 96
const SYS_setdomainname = 162
const SYS_setfsgid = 152
const SYS_setfsuid = 151
const SYS_setgid = 144
const SYS_setgroups = 159
const SYS_sethostname = 161
const SYS_setitimer = 103
const SYS_setns = 268
const SYS_setpgid = 154
const SYS_setpriority = 140
const SYS_setregid = 143
const SYS_setresgid = 149
const SYS_setresuid = 147
const SYS_setreuid = 145
const SYS_setrlimit = 164
const SYS_setsid = 157
const SYS_setsockopt = 208
const SYS_settimeofday = 170
const SYS_setuid = 146
const SYS_setxattr = 5
const SYS_shmat = 196
const SYS_shmctl = 195
const SYS_shmdt = 197
const SYS_shmget = 194
const SYS_shutdown = 210
const SYS_sigaltstack = 132
const SYS_signalfd4 = 74
const SYS_socket = 198
const SYS_socketpair = 199
const SYS_splice = 76
const SYS_statfs = 43
const SYS_statx = 291
const SYS_swapoff = 225
const SYS_swapon = 224
const SYS_symlinkat = 36
const SYS_sync = 81
const SYS_sync_file_range = 84
const SYS_syncfs = 267
const SYS_sysinfo = 179
const SYS_syslog = 116
const SYS_tee = 77
const SYS_tgkill = 131
const SYS_timer_create = 107
const SYS_timer_delete = 111
const SYS_timer_getoverrun = 109
const SYS_timer_gettime = 108
const SYS_timer_settime = 110
const SYS_timerfd_create = 85
const SYS_timerfd_gettime = 87
const SYS_timerfd_settime = 86
const SYS_times = 153
const SYS_tkill = 130
const SYS_truncate = 45
const SYS_umask = 166
const SYS_umount2 = 39
const SYS_uname = 160
const SYS_unlinkat = 35
const SYS_unshare = 97
const SYS_userfaultfd = 282
const SYS_utimensat = 88
const SYS_vhangup = 58
const SYS_vmsplice = 75
const SYS_wait4 = 260
const SYS_waitid = 95
const SYS_write = 64
const SYS_writev = 66
const TRAP_BRANCH = 3
const TRAP_BRKPT = 1
const TRAP_HWBKPT = 4
const TRAP_TRACE = 2
const TRAP_UNK = 5
const VER = -255
const VER_DEF_CURRENT = 1
const VER_DEF_NONE = 0
const VER_DEF_NUM = 2
const VER_FLG_BASE = 1
const VER_FLG_WEAK = 2
const VER_NDX_ELIMINATE = 65281
const VER_NDX_GLOBAL = 1
const VER_NDX_LOCAL = 0
const VER_NDX_LORESERVE = 65280
const VER_NEED_CURRENT = 1
const VER_NEED_NONE = 0
const VER_NEED_NUM = 2
const WNOHANG = 1
const WUNTRACED = 2
const _NSIG = 65
const __NR_accept = 202
const __NR_accept4 = 242
const __NR_acct = 89
const __NR_add_key = 217
const __NR_adjtimex = 171
const __NR_bind = 200
const __NR_bpf = 280
const __NR_brk = 214
const __NR_cachestat = 451
const __NR_capget = 90
const __NR_capset = 91
const __NR_chdir = 49
const __NR_chroot = 51
const __NR_clock_adjtime = 266
const __NR_clock_getres = 114
const __NR_clock_gettime = 113
const __NR_clock_nanosleep = 115
const __NR_clock_settime = 112
const __NR_clone = 220
const __NR_clone3 = 435
const __NR_close = 57
const __NR_close_range = 436
const __NR_connect = 203
const __NR_copy_file_range = 285
const __NR_delete_module = 106
const __NR_dup = 23
const __NR_dup3 = 24
const __NR_epoll_create1 = 20
const __NR_epoll_ctl = 21
const __NR_epoll_pwait = 22
const __NR_epoll_pwait2 = 441
const __NR_eventfd2 = 19
const __NR_execve = 221
const __NR_execveat = 281
const __NR_exit = 93
const __NR_exit_group = 94
const __NR_faccessat = 48
const __NR_faccessat2 = 439
const __NR_fadvise64 = 223
const __NR_fallocate = 47
const __NR_fanotify_init = 262
const __NR_fanotify_mark = 263
const __NR_fchdir = 50
const __NR_fchmod = 52
const __NR_fchmodat = 53
const __NR_fchmodat2 = 452
const __NR_fchown = 55
const __NR_fchownat = 54
const __NR_fcntl = 25
const __NR_fdatasync = 83
const __NR_fgetxattr = 10
const __NR_finit_module = 273
const __NR_flistxattr = 13
const __NR_flock = 32
const __NR_fremovexattr = 16
const __NR_fsconfig = 431
const __NR_fsetxattr = 7
const __NR_fsmount = 432
const __NR_fsopen = 430
const __NR_fspick = 433
const __NR_fstat = 80
const __NR_fstatfs = 44
const __NR_fsync = 82
const __NR_ftruncate = 46
const __NR_futex = 98
const __NR_futex_waitv = 449
const __NR_get_mempolicy = 236
const __NR_get_robust_list = 100
const __NR_getcpu = 168
const __NR_getcwd = 17
const __NR_getdents64 = 61
const __NR_getegid = 177
const __NR_geteuid = 175
const __NR_getgid = 176
const __NR_getgroups = 158
const __NR_getitimer = 102
const __NR_getpeername = 205
const __NR_getpgid = 155
const __NR_getpid = 172
const __NR_getppid = 173
const __NR_getpriority = 141
const __NR_getrandom = 278
const __NR_getresgid = 150
const __NR_getresuid = 148
const __NR_getrlimit = 163
const __NR_getrusage = 165
const __NR_getsid = 156
const __NR_getsockname = 204
const __NR_getsockopt = 209
const __NR_gettid = 178
const __NR_gettimeofday = 169
const __NR_getuid = 174
const __NR_getxattr = 8
const __NR_init_module = 105
const __NR_inotify_add_watch = 27
const __NR_inotify_init1 = 26
const __NR_inotify_rm_watch = 28
const __NR_io_cancel = 3
const __NR_io_destroy = 1
const __NR_io_getevents = 4
const __NR_io_pgetevents = 292
const __NR_io_setup = 0
const __NR_io_submit = 2
const __NR_io_uring_enter = 426
const __NR_io_uring_register = 427
const __NR_io_uring_setup = 425
const __NR_ioctl = 29
const __NR_ioprio_get = 31
const __NR_ioprio_set = 30
const __NR_kcmp = 272
const __NR_kexec_file_load = 294
const __NR_kexec_load = 104
const __NR_keyctl = 219
const __NR_kill = 129
const __NR_landlock_add_rule = 445
const __NR_landlock_create_ruleset = 444
const __NR_landlock_restrict_self = 446
const __NR_lgetxattr = 9
const __NR_linkat = 37
const __NR_listen = 201
const __NR_listxattr = 11
const __NR_llistxattr = 12
const __NR_lookup_dcookie = 18
const __NR_lremovexattr = 15
const __NR_lseek = 62
const __NR_lsetxattr = 6
const __NR_madvise = 233
const __NR_mbind = 235
const __NR_membarrier = 283
const __NR_memfd_create = 279
const __NR_migrate_pages = 238
const __NR_mincore = 232
const __NR_mkdirat = 34
const __NR_mknodat = 33
const __NR_mlock = 228
const __NR_mlock2 = 284
const __NR_mlockall = 230
const __NR_mmap = 222
const __NR_mount = 40
const __NR_mount_setattr = 442
const __NR_move_mount = 429
const __NR_move_pages = 239
const __NR_mprotect = 226
const __NR_mq_getsetattr = 185
const __NR_mq_notify = 184
const __NR_mq_open = 180
const __NR_mq_timedreceive = 183
const __NR_mq_timedsend = 182
const __NR_mq_unlink = 181
const __NR_mremap = 216
const __NR_msgctl = 187
const __NR_msgget = 186
const __NR_msgrcv = 188
const __NR_msgsnd = 189
const __NR_msync = 227
const __NR_munlock = 229
const __NR_munlockall = 231
const __NR_munmap = 215
const __NR_name_to_handle_at = 264
const __NR_nanosleep = 101
const __NR_newfstatat = 79
const __NR_nfsservctl = 42
const __NR_open_by_handle_at = 265
const __NR_open_tree = 428
const __NR_openat = 56
const __NR_openat2 = 437
const __NR_perf_event_open = 241
const __NR_personality = 92
const __NR_pidfd_getfd = 438
const __NR_pidfd_open = 434
const __NR_pidfd_send_signal = 424
const __NR_pipe2 = 59
const __NR_pivot_root = 41
const __NR_pkey_alloc = 289
const __NR_pkey_free = 290
const __NR_pkey_mprotect = 288
const __NR_ppoll = 73
const __NR_prctl = 167
const __NR_pread64 = 67
const __NR_preadv = 69
const __NR_preadv2 = 286
const __NR_prlimit64 = 261
const __NR_process_madvise = 440
const __NR_process_mrelease = 448
const __NR_process_vm_readv = 270
const __NR_process_vm_writev = 271
const __NR_pselect6 = 72
const __NR_ptrace = 117
const __NR_pwrite64 = 68
const __NR_pwritev = 70
const __NR_pwritev2 = 287
const __NR_quotactl = 60
const __NR_read = 63
const __NR_readahead = 213
const __NR_readlinkat = 78
const __NR_readv = 65
const __NR_reboot = 142
const __NR_recvfrom = 207
const __NR_recvmmsg = 243
const __NR_recvmsg = 212
const __NR_remap_file_pages = 234
const __NR_removexattr = 14
const __NR_renameat = 38
const __NR_renameat2 = 276
const __NR_request_key = 218
const __NR_restart_syscall = 128
const __NR_rseq = 293
const __NR_rt_sigaction = 134
const __NR_rt_sigpending = 136
const __NR_rt_sigprocmask = 135
const __NR_rt_sigqueueinfo = 138
const __NR_rt_sigreturn = 139
const __NR_rt_sigsuspend = 133
const __NR_rt_sigtimedwait = 137
const __NR_rt_tgsigqueueinfo = 240
const __NR_sched_get_priority_max = 125
const __NR_sched_get_priority_min = 126
const __NR_sched_getaffinity = 123
const __NR_sched_getattr = 275
const __NR_sched_getparam = 121
const __NR_sched_getscheduler = 120
const __NR_sched_rr_get_interval = 127
const __NR_sched_setaffinity = 122
const __NR_sched_setattr = 274
const __NR_sched_setparam = 118
const __NR_sched_setscheduler = 119
const __NR_sched_yield = 124
const __NR_seccomp = 277
const __NR_semctl = 191
const __NR_semget = 190
const __NR_semop = 193
const __NR_semtimedop = 192
const __NR_sendfile = 71
const __NR_sendmmsg = 269
const __NR_sendmsg = 211
const __NR_sendto = 206
const __NR_set_mempolicy = 237
const __NR_set_mempolicy_home_node = 450
const __NR_set_robust_list = 99
const __NR_set_tid_address = 96
const __NR_setdomainname = 162
const __NR_setfsgid = 152
const __NR_setfsuid = 151
const __NR_setgid = 144
const __NR_setgroups = 159
const __NR_sethostname = 161
const __NR_setitimer = 103
const __NR_setns = 268
const __NR_setpgid = 154
const __NR_setpriority = 140
const __NR_setregid = 143
const __NR_setresgid = 149
const __NR_setresuid = 147
const __NR_setreuid = 145
const __NR_setrlimit = 164
const __NR_setsid = 157
const __NR_setsockopt = 208
const __NR_settimeofday = 170
const __NR_setuid = 146
const __NR_setxattr = 5
const __NR_shmat = 196
const __NR_shmctl = 195
const __NR_shmdt = 197
const __NR_shmget = 194
const __NR_shutdown = 210
const __NR_sigaltstack = 132
const __NR_signalfd4 = 74
const __NR_socket = 198
const __NR_socketpair = 199
const __NR_splice = 76
const __NR_statfs = 43
const __NR_statx = 291
const __NR_swapoff = 225
const __NR_swapon = 224
const __NR_symlinkat = 36
const __NR_sync = 81
const __NR_sync_file_range = 84
const __NR_syncfs = 267
const __NR_sysinfo = 179
const __NR_syslog = 116
const __NR_tee = 77
const __NR_tgkill = 131
const __NR_timer_create = 107
const __NR_timer_delete = 111
const __NR_timer_getoverrun = 109
const __NR_timer_gettime = 108
const __NR_timer_settime = 110
const __NR_timerfd_create = 85
const __NR_timerfd_gettime = 87
const __NR_timerfd_settime = 86
const __NR_times = 153
const __NR_tkill = 130
const __NR_truncate = 45
const __NR_umask = 166
const __NR_umount2 = 39
const __NR_uname = 160
const __NR_unlinkat = 35
const __NR_unshare = 97
const __NR_userfaultfd = 282
const __NR_utimensat = 88
const __NR_vhangup = 58
const __NR_vmsplice = 75
const __NR_wait4 = 260
const __NR_waitid = 95
const __NR_write = 64
const __NR_writev = 66
const __SC_accept = 5
const __SC_accept4 = 18
const __SC_bind = 2
const __SC_connect = 3
const __SC_getpeername = 7
const __SC_getsockname = 6
const __SC_getsockopt = 15
const __SC_listen = 4
const __SC_recv = 10
const __SC_recvfrom = 12
const __SC_recvmmsg = 19
const __SC_recvmsg = 17
const __SC_send = 9
const __SC_sendmmsg = 20
const __SC_sendmsg = 16
const __SC_sendto = 11
const __SC_setsockopt = 14
const __SC_shutdown = 13
const __SC_socket = 1
const __SC_socketpair = 8
const libc = 0

type Ttime_t = int64

type Tsuseconds_t = int64

type Ttimeval = struct {
	Ftv_sec  Ttime_t
	Ftv_usec Tsuseconds_t
}

type Ttimespec = struct {
	Ftv_sec  Ttime_t
	Ftv_nsec int64
}

type Tsigset_t = struct {
	F__bits [16]uint64
}

type t__sigset_t = Tsigset_t

type Tfd_mask = uint64

type Tfd_set = struct {
	Ffds_bits [16]uint64
}

type Titimerval = struct {
	Fit_interval Ttimeval
	Fit_value    Ttimeval
}

type Tid_t = uint32

type Trlim_t = uint64

type Trlimit = struct {
	Frlim_cur Trlim_t
	Frlim_max Trlim_t
}

type Trusage = struct {
	Fru_utime    Ttimeval
	Fru_stime    Ttimeval
	Fru_maxrss   int64
	Fru_ixrss    int64
	Fru_idrss    int64
	Fru_isrss    int64
	Fru_minflt   int64
	Fru_majflt   int64
	Fru_nswap    int64
	Fru_inblock  int64
	Fru_oublock  int64
	Fru_msgsnd   int64
	Fru_msgrcv   int64
	Fru_nsignals int64
	Fru_nvcsw    int64
	Fru_nivcsw   int64
	F__reserved  [16]int64
}

type Tclock_t = int64

type Tpthread_t = uintptr

type Tpthread_attr_t = struct {
	F__u struct {
		F__vi [0][14]int32
		F__s  [0][7]uint64
		F__i  [14]int32
	}
}

type Tstack_t = struct {
	Fss_sp    uintptr
	Fss_flags int32
	Fss_size  Tsize_t
}

type Tsigaltstack = Tstack_t

type Tmcontext_t = struct {
	F__regs [274]float64
}

type Tucontext_t = struct {
	Fuc_flags    uint64
	Fuc_link     uintptr
	Fuc_stack    Tstack_t
	Fuc_sigmask  Tsigset_t
	Fuc_mcontext Tmcontext_t
}

type t__ucontext = Tucontext_t

type Tsigval = struct {
	Fsival_ptr   [0]uintptr
	Fsival_int   int32
	F__ccgo_pad2 [4]byte
}

type Tsiginfo_t = struct {
	Fsi_signo    int32
	Fsi_errno    int32
	Fsi_code     int32
	F__si_fields struct {
		F__si_common [0]struct {
			F__first struct {
				F__timer [0]struct {
					Fsi_timerid int32
					Fsi_overrun int32
				}
				F__piduid struct {
					Fsi_pid Tpid_t
					Fsi_uid Tuid_t
				}
			}
			F__second struct {
				F__sigchld [0]struct {
					Fsi_status int32
					Fsi_utime  Tclock_t
					Fsi_stime  Tclock_t
				}
				Fsi_value    Tsigval
				F__ccgo_pad2 [16]byte
			}
		}
		F__sigfault [0]struct {
			Fsi_addr     uintptr
			Fsi_addr_lsb int16
			F__first     struct {
				Fsi_pkey    [0]uint32
				F__addr_bnd struct {
					Fsi_lower uintptr
					Fsi_upper uintptr
				}
			}
		}
		F__sigpoll [0]struct {
			Fsi_band int64
			Fsi_fd   int32
		}
		F__sigsys [0]struct {
			Fsi_call_addr uintptr
			Fsi_syscall   int32
			Fsi_arch      uint32
		}
		F__pad [112]uint8
	}
}

type Tsigaction = struct {
	F__sa_handler struct {
		Fsa_sigaction [0]uintptr
		Fsa_handler   uintptr
	}
	Fsa_mask     Tsigset_t
	Fsa_flags    int32
	Fsa_restorer uintptr
}

type Tsigevent = struct {
	Fsigev_value  Tsigval
	Fsigev_signo  int32
	Fsigev_notify int32
	F__sev_fields struct {
		Fsigev_notify_thread_id [0]Tpid_t
		F__sev_thread           [0]struct {
			Fsigev_notify_function   uintptr
			Fsigev_notify_attributes uintptr
		}
		F__pad [48]uint8
	}
}

type Tsig_atomic_t = int32

type TElf32_Half = uint16

type TElf64_Half = uint16

type TElf32_Word = uint32

type TElf32_Sword = int32

type TElf64_Word = uint32

type TElf64_Sword = int32

type TElf32_Xword = uint64

type TElf32_Sxword = int64

type TElf64_Xword = uint64

type TElf64_Sxword = int64

type TElf32_Addr = uint32

type TElf64_Addr = uint64

type TElf32_Off = uint32

type TElf64_Off = uint64

type TElf32_Section = uint16

type TElf64_Section = uint16

type TElf32_Versym = uint16

type TElf64_Versym = uint16

type TElf32_Ehdr = struct {
	Fe_ident     [16]uint8
	Fe_type      TElf32_Half
	Fe_machine   TElf32_Half
	Fe_version   TElf32_Word
	Fe_entry     TElf32_Addr
	Fe_phoff     TElf32_Off
	Fe_shoff     TElf32_Off
	Fe_flags     TElf32_Word
	Fe_ehsize    TElf32_Half
	Fe_phentsize TElf32_Half
	Fe_phnum     TElf32_Half
	Fe_shentsize TElf32_Half
	Fe_shnum     TElf32_Half
	Fe_shstrndx  TElf32_Half
}

type TElf64_Ehdr = struct {
	Fe_ident     [16]uint8
	Fe_type      TElf64_Half
	Fe_machine   TElf64_Half
	Fe_version   TElf64_Word
	Fe_entry     TElf64_Addr
	Fe_phoff     TElf64_Off
	Fe_shoff     TElf64_Off
	Fe_flags     TElf64_Word
	Fe_ehsize    TElf64_Half
	Fe_phentsize TElf64_Half
	Fe_phnum     TElf64_Half
	Fe_shentsize TElf64_Half
	Fe_shnum     TElf64_Half
	Fe_shstrndx  TElf64_Half
}

type TElf32_Shdr = struct {
	Fsh_name      TElf32_Word
	Fsh_type      TElf32_Word
	Fsh_flags     TElf32_Word
	Fsh_addr      TElf32_Addr
	Fsh_offset    TElf32_Off
	Fsh_size      TElf32_Word
	Fsh_link      TElf32_Word
	Fsh_info      TElf32_Word
	Fsh_addralign TElf32_Word
	Fsh_entsize   TElf32_Word
}

type TElf64_Shdr = struct {
	Fsh_name      TElf64_Word
	Fsh_type      TElf64_Word
	Fsh_flags     TElf64_Xword
	Fsh_addr      TElf64_Addr
	Fsh_offset    TElf64_Off
	Fsh_size      TElf64_Xword
	Fsh_link      TElf64_Word
	Fsh_info      TElf64_Word
	Fsh_addralign TElf64_Xword
	Fsh_entsize   TElf64_Xword
}

type TElf32_Chdr = struct {
	Fch_type      TElf32_Word
	Fch_size      TElf32_Word
	Fch_addralign TElf32_Word
}

type TElf64_Chdr = struct {
	Fch_type      TElf64_Word
	Fch_reserved  TElf64_Word
	Fch_size      TElf64_Xword
	Fch_addralign TElf64_Xword
}

type TElf32_Sym = struct {
	Fst_name  TElf32_Word
	Fst_value TElf32_Addr
	Fst_size  TElf32_Word
	Fst_info  uint8
	Fst_other uint8
	Fst_shndx TElf32_Section
}

type TElf64_Sym = struct {
	Fst_name  TElf64_Word
	Fst_info  uint8
	Fst_other uint8
	Fst_shndx TElf64_Section
	Fst_value TElf64_Addr
	Fst_size  TElf64_Xword
}

type TElf32_Syminfo = struct {
	Fsi_boundto TElf32_Half
	Fsi_flags   TElf32_Half
}

type TElf64_Syminfo = struct {
	Fsi_boundto TElf64_Half
	Fsi_flags   TElf64_Half
}

type TElf32_Rel = struct {
	Fr_offset TElf32_Addr
	Fr_info   TElf32_Word
}

type TElf64_Rel = struct {
	Fr_offset TElf64_Addr
	Fr_info   TElf64_Xword
}

type TElf32_Rela = struct {
	Fr_offset TElf32_Addr
	Fr_info   TElf32_Word
	Fr_addend TElf32_Sword
}

type TElf64_Rela = struct {
	Fr_offset TElf64_Addr
	Fr_info   TElf64_Xword
	Fr_addend TElf64_Sxword
}

type TElf32_Relr = uint32

type TElf64_Relr = uint64

type TElf32_Phdr = struct {
	Fp_type   TElf32_Word
	Fp_offset TElf32_Off
	Fp_vaddr  TElf32_Addr
	Fp_paddr  TElf32_Addr
	Fp_filesz TElf32_Word
	Fp_memsz  TElf32_Word
	Fp_flags  TElf32_Word
	Fp_align  TElf32_Word
}

type TElf64_Phdr = struct {
	Fp_type   TElf64_Word
	Fp_flags  TElf64_Word
	Fp_offset TElf64_Off
	Fp_vaddr  TElf64_Addr
	Fp_paddr  TElf64_Addr
	Fp_filesz TElf64_Xword
	Fp_memsz  TElf64_Xword
	Fp_align  TElf64_Xword
}

type TElf32_Dyn = struct {
	Fd_tag TElf32_Sword
	Fd_un  struct {
		Fd_ptr [0]TElf32_Addr
		Fd_val TElf32_Word
	}
}

type TElf64_Dyn = struct {
	Fd_tag TElf64_Sxword
	Fd_un  struct {
		Fd_ptr [0]TElf64_Addr
		Fd_val TElf64_Xword
	}
}

type TElf32_Verdef = struct {
	Fvd_version TElf32_Half
	Fvd_flags   TElf32_Half
	Fvd_ndx     TElf32_Half
	Fvd_cnt     TElf32_Half
	Fvd_hash    TElf32_Word
	Fvd_aux     TElf32_Word
	Fvd_next    TElf32_Word
}

type TElf64_Verdef = struct {
	Fvd_version TElf64_Half
	Fvd_flags   TElf64_Half
	Fvd_ndx     TElf64_Half
	Fvd_cnt     TElf64_Half
	Fvd_hash    TElf64_Word
	Fvd_aux     TElf64_Word
	Fvd_next    TElf64_Word
}

type TElf32_Verdaux = struct {
	Fvda_name TElf32_Word
	Fvda_next TElf32_Word
}

type TElf64_Verdaux = struct {
	Fvda_name TElf64_Word
	Fvda_next TElf64_Word
}

type TElf32_Verneed = struct {
	Fvn_version TElf32_Half
	Fvn_cnt     TElf32_Half
	Fvn_file    TElf32_Word
	Fvn_aux     TElf32_Word
	Fvn_next    TElf32_Word
}

type TElf64_Verneed = struct {
	Fvn_version TElf64_Half
	Fvn_cnt     TElf64_Half
	Fvn_file    TElf64_Word
	Fvn_aux     TElf64_Word
	Fvn_next    TElf64_Word
}

type TElf32_Vernaux = struct {
	Fvna_hash  TElf32_Word
	Fvna_flags TElf32_Half
	Fvna_other TElf32_Half
	Fvna_name  TElf32_Word
	Fvna_next  TElf32_Word
}

type TElf64_Vernaux = struct {
	Fvna_hash  TElf64_Word
	Fvna_flags TElf64_Half
	Fvna_other TElf64_Half
	Fvna_name  TElf64_Word
	Fvna_next  TElf64_Word
}

type TElf32_auxv_t = struct {
	Fa_type Tuint32_t
	Fa_un   struct {
		Fa_val Tuint32_t
	}
}

type TElf64_auxv_t = struct {
	Fa_type Tuint64_t
	Fa_un   struct {
		Fa_val Tuint64_t
	}
}

type TElf32_Nhdr = struct {
	Fn_namesz TElf32_Word
	Fn_descsz TElf32_Word
	Fn_type   TElf32_Word
}

type TElf64_Nhdr = struct {
	Fn_namesz TElf64_Word
	Fn_descsz TElf64_Word
	Fn_type   TElf64_Word
}

type TElf32_Move = struct {
	Fm_value   TElf32_Xword
	Fm_info    TElf32_Word
	Fm_poffset TElf32_Word
	Fm_repeat  TElf32_Half
	Fm_stride  TElf32_Half
}

type TElf64_Move = struct {
	Fm_value   TElf64_Xword
	Fm_info    TElf64_Xword
	Fm_poffset TElf64_Xword
	Fm_repeat  TElf64_Half
	Fm_stride  TElf64_Half
}

type TElf32_gptab = struct {
	Fgt_entry [0]struct {
		Fgt_g_value TElf32_Word
		Fgt_bytes   TElf32_Word
	}
	Fgt_header struct {
		Fgt_current_g_value TElf32_Word
		Fgt_unused          TElf32_Word
	}
}

type TElf32_RegInfo = struct {
	Fri_gprmask  TElf32_Word
	Fri_cprmask  [4]TElf32_Word
	Fri_gp_value TElf32_Sword
}

type TElf_Options = struct {
	Fkind    uint8
	Fsize    uint8
	Fsection TElf32_Section
	Finfo    TElf32_Word
}

type TElf_Options_Hw = struct {
	Fhwp_flags1 TElf32_Word
	Fhwp_flags2 TElf32_Word
}

type TElf32_Lib = struct {
	Fl_name       TElf32_Word
	Fl_time_stamp TElf32_Word
	Fl_checksum   TElf32_Word
	Fl_version    TElf32_Word
	Fl_flags      TElf32_Word
}

type TElf64_Lib = struct {
	Fl_name       TElf64_Word
	Fl_time_stamp TElf64_Word
	Fl_checksum   TElf64_Word
	Fl_version    TElf64_Word
	Fl_flags      TElf64_Word
}

type TElf32_Conflict = uint32

type TElf_MIPS_ABIFlags_v0 = struct {
	Fversion   TElf32_Half
	Fisa_level uint8
	Fisa_rev   uint8
	Fgpr_size  uint8
	Fcpr1_size uint8
	Fcpr2_size uint8
	Ffp_abi    uint8
	Fisa_ext   TElf32_Word
	Fases      TElf32_Word
	Fflags1    TElf32_Word
	Fflags2    TElf32_Word
}

const _Val_GNU_MIPS_ABI_FP_ANY = 0
const _Val_GNU_MIPS_ABI_FP_DOUBLE = 1
const _Val_GNU_MIPS_ABI_FP_SINGLE = 2
const _Val_GNU_MIPS_ABI_FP_SOFT = 3
const _Val_GNU_MIPS_ABI_FP_OLD_64 = 4
const _Val_GNU_MIPS_ABI_FP_XX = 5
const _Val_GNU_MIPS_ABI_FP_64 = 6
const _Val_GNU_MIPS_ABI_FP_64A = 7
const _Val_GNU_MIPS_ABI_FP_MAX = 7

type Tsyscall_arg_t = int64

type Twchar_t = uint32

type Tdiv_t = struct {
	Fquot int32
	Frem  int32
}

type Tldiv_t = struct {
	Fquot int64
	Frem  int64
}

type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
}

type t__locale_struct = struct {
	Fcat [6]uintptr
}

type Ttls_module = struct {
	Fnext   uintptr
	Fimage  uintptr
	Flen1   Tsize_t
	Fsize   Tsize_t
	Falign  Tsize_t
	Foffset Tsize_t
}

type t__libc = struct {
	Fcan_do_threads  uint8
	Fthreaded        uint8
	Fsecure          uint8
	Fneed_locks      int8
	Fthreads_minus_1 int32
	Fauxv            uintptr
	Ftls_head        uintptr
	Ftls_size        Tsize_t
	Ftls_align       Tsize_t
	Ftls_cnt         Tsize_t
	Fpage_size       Tsize_t
	Fglobal_locale   t__locale_struct
}

func Xsysconf(tls *TLS, name int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(512)
	defer tls.Free(512)
	var cnt, i, v3 int32
	var mem, v1, v6 uint64
	var val int64
	var p5 uintptr
	var _ /* lim at bp+0 */ Trlimit
	var _ /* set at bp+16 */ [128]uint8
	var _ /* si at bp+144 */ Tsysinfo
	_, _, _, _, _, _, _, _ = cnt, i, mem, val, v1, v3, v6, p5
	if uint64(name) >= Uint64FromInt64(502)/Uint64FromInt64(2) || !(_values1[name] != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return int64(-int32(1))
	} else {
		if int32(_values1[name]) >= -int32(1) {
			return int64(_values1[name])
		} else {
			if int32(_values1[name]) < -int32(256) {
				Xgetrlimit(tls, int32(_values1[name])&int32(16383), bp)
				if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur == ^Uint64FromUint64(0) {
					return int64(-int32(1))
				}
				if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur > uint64(0x7fffffffffffffff) {
					v1 = uint64(0x7fffffffffffffff)
				} else {
					v1 = (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur
				}
				return int64(v1)
			}
		}
	}
	switch int32(uint8(_values1[name])) {
	case (-Int32FromInt32(256) | Int32FromInt32(1)) & Int32FromInt32(255):
		return int64(200809)
	case (-Int32FromInt32(256) | Int32FromInt32(2)) & Int32FromInt32(255):
		return int64(ARG_MAX)
	case (-Int32FromInt32(256) | Int32FromInt32(3)) & Int32FromInt32(255):
		return int64(MQ_PRIO_MAX)
	case (-Int32FromInt32(256) | Int32FromInt32(4)) & Int32FromInt32(255):
		return int64(X__libc.Fpage_size)
	case (-Int32FromInt32(256) | Int32FromInt32(5)) & Int32FromInt32(255):
		return int64(SEM_VALUE_MAX)
	case (-Int32FromInt32(256) | Int32FromInt32(11)) & Int32FromInt32(255):
		return int64(DELAYTIMER_MAX)
	case (-Int32FromInt32(256) | Int32FromInt32(6)) & Int32FromInt32(255):
		fallthrough
	case (-Int32FromInt32(256) | Int32FromInt32(7)) & Int32FromInt32(255):
		*(*[128]uint8)(unsafe.Pointer(bp + 16)) = [128]uint8{
			0: uint8(1),
		}
		X__syscall3(tls, int64(SYS_sched_getaffinity), int64(Int32FromInt32(0)), int64(Uint64FromInt64(128)), int64(bp+16))
		v3 = Int32FromInt32(0)
		cnt = v3
		i = v3
		for {
			if !(uint64(i) < uint64(128)) {
				break
			}
			for {
				if !((*(*[128]uint8)(unsafe.Pointer(bp + 16)))[i] != 0) {
					break
				}
				goto _4
			_4:
				;
				p5 = bp + 16 + uintptr(i)
				*(*uint8)(unsafe.Pointer(p5)) = uint8(int32(*(*uint8)(unsafe.Pointer(p5))) & (int32((*(*[128]uint8)(unsafe.Pointer(bp + 16)))[i]) - Int32FromInt32(1)))
				cnt++
			}
			goto _2
		_2:
			;
			i++
		}
		return int64(cnt)
	case (-Int32FromInt32(256) | Int32FromInt32(8)) & Int32FromInt32(255):
		fallthrough
	case (-Int32FromInt32(256) | Int32FromInt32(9)) & Int32FromInt32(255):
		X__lsysinfo(tls, bp+144)
		if !((*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Fmem_unit != 0) {
			(*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Fmem_unit = uint32(1)
		}
		if name == int32(_SC_PHYS_PAGES) {
			mem = (*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Ftotalram
		} else {
			mem = (*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Ffreeram + (*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Fbufferram
		}
		mem *= uint64((*(*Tsysinfo)(unsafe.Pointer(bp + 144))).Fmem_unit)
		mem /= X__libc.Fpage_size
		if mem > uint64(0x7fffffffffffffff) {
			v6 = uint64(0x7fffffffffffffff)
		} else {
			v6 = mem
		}
		return int64(v6)
	case (-Int32FromInt32(256) | Int32FromInt32(12)) & Int32FromInt32(255):
		fallthrough
	case (-Int32FromInt32(256) | Int32FromInt32(13)) & Int32FromInt32(255):
		val = int64(X__getauxval(tls, uint64(AT_MINSIGSTKSZ)))
		if val < int64(MINSIGSTKSZ) {
			val = int64(MINSIGSTKSZ)
		}
		if int32(_values1[name]) == -Int32FromInt32(256)|Int32FromInt32(13) {
			val += int64(Int32FromInt32(SIGSTKSZ) - Int32FromInt32(MINSIGSTKSZ))
		}
		return val
	case (-Int32FromInt32(256) | Int32FromInt32(10)) & Int32FromInt32(255):
		return 0
	}
	return int64(_values1[name])
}

var _values1 = [251]int16{
	0:   int16(-Int32FromInt32(256) | Int32FromInt32(2)),
	1:   int16(-Int32FromInt32(32768) | Int32FromInt32(RLIMIT_NPROC)),
	2:   int16(100),
	3:   int16(32),
	4:   int16(-Int32FromInt32(32768) | Int32FromInt32(RLIMIT_NOFILE)),
	5:   int16(-int32(1)),
	6:   int16(TZNAME_MAX),
	7:   int16(1),
	8:   int16(1),
	9:   int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	10:  int16(-int32(1)),
	11:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	12:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	13:  int16(-int32(1)),
	14:  int16(-int32(1)),
	15:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	16:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	17:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	18:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	19:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	20:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	21:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	22:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	23:  int16(-int32(1)),
	24:  int16(-int32(1)),
	25:  int16(-Int32FromInt32(256) | Int32FromInt32(10)),
	26:  int16(-Int32FromInt32(256) | Int32FromInt32(11)),
	27:  int16(-int32(1)),
	28:  int16(-Int32FromInt32(256) | Int32FromInt32(3)),
	29:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	30:  int16(-Int32FromInt32(256) | Int32FromInt32(4)),
	31:  int16(Int32FromInt32(_NSIG) - Int32FromInt32(1) - Int32FromInt32(31) - Int32FromInt32(3)),
	32:  int16(SEM_NSEMS_MAX),
	33:  int16(-Int32FromInt32(256) | Int32FromInt32(5)),
	34:  int16(-int32(1)),
	35:  int16(-int32(1)),
	36:  int16(_POSIX2_BC_BASE_MAX),
	37:  int16(_POSIX2_BC_DIM_MAX),
	38:  int16(_POSIX2_BC_SCALE_MAX),
	39:  int16(_POSIX2_BC_STRING_MAX),
	40:  int16(COLL_WEIGHTS_MAX),
	42:  int16(-int32(1)),
	43:  int16(-int32(1)),
	44:  int16(RE_DUP_MAX),
	46:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	47:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	48:  int16(-int32(1)),
	49:  int16(-int32(1)),
	50:  int16(-int32(1)),
	51:  int16(-int32(1)),
	52:  int16(-int32(1)),
	60:  int16(IOV_MAX),
	67:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	68:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	69:  int16(-int32(1)),
	70:  int16(-int32(1)),
	71:  int16(256),
	72:  int16(TTY_NAME_MAX),
	73:  int16(PTHREAD_DESTRUCTOR_ITERATIONS),
	74:  int16(PTHREAD_KEYS_MAX),
	75:  int16(PTHREAD_STACK_MIN),
	76:  int16(-int32(1)),
	77:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	78:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	79:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	80:  int16(-int32(1)),
	81:  int16(-int32(1)),
	82:  int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	83:  int16(-Int32FromInt32(256) | Int32FromInt32(6)),
	84:  int16(-Int32FromInt32(256) | Int32FromInt32(7)),
	85:  int16(-Int32FromInt32(256) | Int32FromInt32(8)),
	86:  int16(-Int32FromInt32(256) | Int32FromInt32(9)),
	87:  int16(-int32(1)),
	88:  int16(-int32(1)),
	89:  int16(_XOPEN_VERSION),
	90:  int16(_XOPEN_VERSION),
	91:  int16(1),
	92:  int16(-int32(1)),
	93:  int16(1),
	94:  int16(1),
	95:  int16(-int32(1)),
	97:  int16(-int32(1)),
	98:  int16(-int32(1)),
	99:  int16(-int32(1)),
	100: int16(-int32(1)),
	109: int16(NZERO),
	125: int16(-int32(1)),
	126: int16(-int32(1)),
	127: int16(1),
	128: int16(-int32(1)),
	129: int16(-int32(1)),
	130: int16(-int32(1)),
	131: int16(-int32(1)),
	132: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	133: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	137: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	138: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	139: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	149: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	153: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	154: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	155: int16(1),
	157: int16(1),
	159: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	160: int16(-int32(1)),
	161: int16(-int32(1)),
	164: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	165: int16(-int32(1)),
	168: int16(-int32(1)),
	169: int16(-int32(1)),
	170: int16(-int32(1)),
	171: int16(-int32(1)),
	172: int16(-int32(1)),
	173: int16(SYMLOOP_MAX),
	174: int16(-Int32FromInt32(256) | Int32FromInt32(10)),
	175: int16(-int32(1)),
	176: int16(-int32(1)),
	177: int16(-int32(1)),
	178: int16(1),
	179: int16(-int32(1)),
	180: int16(HOST_NAME_MAX),
	181: int16(-int32(1)),
	182: int16(-int32(1)),
	183: int16(-int32(1)),
	184: int16(-int32(1)),
	235: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	236: int16(-Int32FromInt32(256) | Int32FromInt32(1)),
	237: int16(-int32(1)),
	238: int16(-int32(1)),
	239: int16(1),
	240: int16(-int32(1)),
	241: int16(-int32(1)),
	242: int16(-int32(1)),
	243: int16(-int32(1)),
	244: int16(-int32(1)),
	245: int16(-int32(1)),
	246: int16(-Int32FromInt32(256) | Int32FromInt32(10)),
	247: int16(-int32(1)),
	248: int16(-int32(1)),
	249: int16(-Int32FromInt32(256) | Int32FromInt32(12)),
	250: int16(-Int32FromInt32(256) | Int32FromInt32(13)),
}

type Tcrypt_data = struct {
	Finitialized int32
	F__buf       [256]uint8
}

func Xcrypt(tls *TLS, key uintptr, salt uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v salt=%v, (%v:)", tls, key, salt, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__crypt_r(tls, key, salt, uintptr(unsafe.Pointer(&_buf)))
}

/* This buffer is sufficiently large for all
 * currently-supported hash types. It needs to be updated if
 * longer hashes are added. The cast to struct crypt_data * is
 * purely to meet the public API requirements of the crypt_r
 * function; the implementation of crypt_r uses the object
 * purely as a char buffer. */
var _buf [128]uint8

const BF_N = 16

type Tlocale_t = uintptr

type TBF_word = uint32

type TBF_word_signed = int32

/* Number of Blowfish rounds, this is also hardcoded into a few places */

type TBF_key = [18]TBF_word

type TBF_ctx = struct {
	FPS [0][1042]TBF_word
	Fs  struct {
		FP TBF_key
		FS [4][256]TBF_word
	}
}

// C documentation
//
//	/*
//	 * Magic IV for 64 Blowfish encryptions that we do at the end.
//	 * The string is "OrpheanBeholderScryDoubt" on big-endian.
//	 */
var _BF_magic_w = [6]TBF_word{
	0: uint32(0x4F727068),
	1: uint32(0x65616E42),
	2: uint32(0x65686F6C),
	3: uint32(0x64657253),
	4: uint32(0x63727944),
	5: uint32(0x6F756274),
}

// C documentation
//
//	/*
//	 * P-box and S-box tables initialized with digits of Pi.
//	 */
var _BF_init_state = *(*TBF_ctx)(unsafe.Pointer(&struct {
	FP TBF_key
	FS [4][256]TBF_word
}{
	FP: TBF_key{
		0:  uint32(0x243f6a88),
		1:  uint32(0x85a308d3),
		2:  uint32(0x13198a2e),
		3:  uint32(0x03707344),
		4:  uint32(0xa4093822),
		5:  uint32(0x299f31d0),
		6:  uint32(0x082efa98),
		7:  uint32(0xec4e6c89),
		8:  uint32(0x452821e6),
		9:  uint32(0x38d01377),
		10: uint32(0xbe5466cf),
		11: uint32(0x34e90c6c),
		12: uint32(0xc0ac29b7),
		13: uint32(0xc97c50dd),
		14: uint32(0x3f84d5b5),
		15: uint32(0xb5470917),
		16: uint32(0x9216d5d9),
		17: uint32(0x8979fb1b),
	},
	FS: [4][256]TBF_word{
		0: {
			0:   uint32(0xd1310ba6),
			1:   uint32(0x98dfb5ac),
			2:   uint32(0x2ffd72db),
			3:   uint32(0xd01adfb7),
			4:   uint32(0xb8e1afed),
			5:   uint32(0x6a267e96),
			6:   uint32(0xba7c9045),
			7:   uint32(0xf12c7f99),
			8:   uint32(0x24a19947),
			9:   uint32(0xb3916cf7),
			10:  uint32(0x0801f2e2),
			11:  uint32(0x858efc16),
			12:  uint32(0x636920d8),
			13:  uint32(0x71574e69),
			14:  uint32(0xa458fea3),
			15:  uint32(0xf4933d7e),
			16:  uint32(0x0d95748f),
			17:  uint32(0x728eb658),
			18:  uint32(0x718bcd58),
			19:  uint32(0x82154aee),
			20:  uint32(0x7b54a41d),
			21:  uint32(0xc25a59b5),
			22:  uint32(0x9c30d539),
			23:  uint32(0x2af26013),
			24:  uint32(0xc5d1b023),
			25:  uint32(0x286085f0),
			26:  uint32(0xca417918),
			27:  uint32(0xb8db38ef),
			28:  uint32(0x8e79dcb0),
			29:  uint32(0x603a180e),
			30:  uint32(0x6c9e0e8b),
			31:  uint32(0xb01e8a3e),
			32:  uint32(0xd71577c1),
			33:  uint32(0xbd314b27),
			34:  uint32(0x78af2fda),
			35:  uint32(0x55605c60),
			36:  uint32(0xe65525f3),
			37:  uint32(0xaa55ab94),
			38:  uint32(0x57489862),
			39:  uint32(0x63e81440),
			40:  uint32(0x55ca396a),
			41:  uint32(0x2aab10b6),
			42:  uint32(0xb4cc5c34),
			43:  uint32(0x1141e8ce),
			44:  uint32(0xa15486af),
			45:  uint32(0x7c72e993),
			46:  uint32(0xb3ee1411),
			47:  uint32(0x636fbc2a),
			48:  uint32(0x2ba9c55d),
			49:  uint32(0x741831f6),
			50:  uint32(0xce5c3e16),
			51:  uint32(0x9b87931e),
			52:  uint32(0xafd6ba33),
			53:  uint32(0x6c24cf5c),
			54:  uint32(0x7a325381),
			55:  uint32(0x28958677),
			56:  uint32(0x3b8f4898),
			57:  uint32(0x6b4bb9af),
			58:  uint32(0xc4bfe81b),
			59:  uint32(0x66282193),
			60:  uint32(0x61d809cc),
			61:  uint32(0xfb21a991),
			62:  uint32(0x487cac60),
			63:  uint32(0x5dec8032),
			64:  uint32(0xef845d5d),
			65:  uint32(0xe98575b1),
			66:  uint32(0xdc262302),
			67:  uint32(0xeb651b88),
			68:  uint32(0x23893e81),
			69:  uint32(0xd396acc5),
			70:  uint32(0x0f6d6ff3),
			71:  uint32(0x83f44239),
			72:  uint32(0x2e0b4482),
			73:  uint32(0xa4842004),
			74:  uint32(0x69c8f04a),
			75:  uint32(0x9e1f9b5e),
			76:  uint32(0x21c66842),
			77:  uint32(0xf6e96c9a),
			78:  uint32(0x670c9c61),
			79:  uint32(0xabd388f0),
			80:  uint32(0x6a51a0d2),
			81:  uint32(0xd8542f68),
			82:  uint32(0x960fa728),
			83:  uint32(0xab5133a3),
			84:  uint32(0x6eef0b6c),
			85:  uint32(0x137a3be4),
			86:  uint32(0xba3bf050),
			87:  uint32(0x7efb2a98),
			88:  uint32(0xa1f1651d),
			89:  uint32(0x39af0176),
			90:  uint32(0x66ca593e),
			91:  uint32(0x82430e88),
			92:  uint32(0x8cee8619),
			93:  uint32(0x456f9fb4),
			94:  uint32(0x7d84a5c3),
			95:  uint32(0x3b8b5ebe),
			96:  uint32(0xe06f75d8),
			97:  uint32(0x85c12073),
			98:  uint32(0x401a449f),
			99:  uint32(0x56c16aa6),
			100: uint32(0x4ed3aa62),
			101: uint32(0x363f7706),
			102: uint32(0x1bfedf72),
			103: uint32(0x429b023d),
			104: uint32(0x37d0d724),
			105: uint32(0xd00a1248),
			106: uint32(0xdb0fead3),
			107: uint32(0x49f1c09b),
			108: uint32(0x075372c9),
			109: uint32(0x80991b7b),
			110: uint32(0x25d479d8),
			111: uint32(0xf6e8def7),
			112: uint32(0xe3fe501a),
			113: uint32(0xb6794c3b),
			114: uint32(0x976ce0bd),
			115: uint32(0x04c006ba),
			116: uint32(0xc1a94fb6),
			117: uint32(0x409f60c4),
			118: uint32(0x5e5c9ec2),
			119: uint32(0x196a2463),
			120: uint32(0x68fb6faf),
			121: uint32(0x3e6c53b5),
			122: uint32(0x1339b2eb),
			123: uint32(0x3b52ec6f),
			124: uint32(0x6dfc511f),
			125: uint32(0x9b30952c),
			126: uint32(0xcc814544),
			127: uint32(0xaf5ebd09),
			128: uint32(0xbee3d004),
			129: uint32(0xde334afd),
			130: uint32(0x660f2807),
			131: uint32(0x192e4bb3),
			132: uint32(0xc0cba857),
			133: uint32(0x45c8740f),
			134: uint32(0xd20b5f39),
			135: uint32(0xb9d3fbdb),
			136: uint32(0x5579c0bd),
			137: uint32(0x1a60320a),
			138: uint32(0xd6a100c6),
			139: uint32(0x402c7279),
			140: uint32(0x679f25fe),
			141: uint32(0xfb1fa3cc),
			142: uint32(0x8ea5e9f8),
			143: uint32(0xdb3222f8),
			144: uint32(0x3c7516df),
			145: uint32(0xfd616b15),
			146: uint32(0x2f501ec8),
			147: uint32(0xad0552ab),
			148: uint32(0x323db5fa),
			149: uint32(0xfd238760),
			150: uint32(0x53317b48),
			151: uint32(0x3e00df82),
			152: uint32(0x9e5c57bb),
			153: uint32(0xca6f8ca0),
			154: uint32(0x1a87562e),
			155: uint32(0xdf1769db),
			156: uint32(0xd542a8f6),
			157: uint32(0x287effc3),
			158: uint32(0xac6732c6),
			159: uint32(0x8c4f5573),
			160: uint32(0x695b27b0),
			161: uint32(0xbbca58c8),
			162: uint32(0xe1ffa35d),
			163: uint32(0xb8f011a0),
			164: uint32(0x10fa3d98),
			165: uint32(0xfd2183b8),
			166: uint32(0x4afcb56c),
			167: uint32(0x2dd1d35b),
			168: uint32(0x9a53e479),
			169: uint32(0xb6f84565),
			170: uint32(0xd28e49bc),
			171: uint32(0x4bfb9790),
			172: uint32(0xe1ddf2da),
			173: uint32(0xa4cb7e33),
			174: uint32(0x62fb1341),
			175: uint32(0xcee4c6e8),
			176: uint32(0xef20cada),
			177: uint32(0x36774c01),
			178: uint32(0xd07e9efe),
			179: uint32(0x2bf11fb4),
			180: uint32(0x95dbda4d),
			181: uint32(0xae909198),
			182: uint32(0xeaad8e71),
			183: uint32(0x6b93d5a0),
			184: uint32(0xd08ed1d0),
			185: uint32(0xafc725e0),
			186: uint32(0x8e3c5b2f),
			187: uint32(0x8e7594b7),
			188: uint32(0x8ff6e2fb),
			189: uint32(0xf2122b64),
			190: uint32(0x8888b812),
			191: uint32(0x900df01c),
			192: uint32(0x4fad5ea0),
			193: uint32(0x688fc31c),
			194: uint32(0xd1cff191),
			195: uint32(0xb3a8c1ad),
			196: uint32(0x2f2f2218),
			197: uint32(0xbe0e1777),
			198: uint32(0xea752dfe),
			199: uint32(0x8b021fa1),
			200: uint32(0xe5a0cc0f),
			201: uint32(0xb56f74e8),
			202: uint32(0x18acf3d6),
			203: uint32(0xce89e299),
			204: uint32(0xb4a84fe0),
			205: uint32(0xfd13e0b7),
			206: uint32(0x7cc43b81),
			207: uint32(0xd2ada8d9),
			208: uint32(0x165fa266),
			209: uint32(0x80957705),
			210: uint32(0x93cc7314),
			211: uint32(0x211a1477),
			212: uint32(0xe6ad2065),
			213: uint32(0x77b5fa86),
			214: uint32(0xc75442f5),
			215: uint32(0xfb9d35cf),
			216: uint32(0xebcdaf0c),
			217: uint32(0x7b3e89a0),
			218: uint32(0xd6411bd3),
			219: uint32(0xae1e7e49),
			220: uint32(0x00250e2d),
			221: uint32(0x2071b35e),
			222: uint32(0x226800bb),
			223: uint32(0x57b8e0af),
			224: uint32(0x2464369b),
			225: uint32(0xf009b91e),
			226: uint32(0x5563911d),
			227: uint32(0x59dfa6aa),
			228: uint32(0x78c14389),
			229: uint32(0xd95a537f),
			230: uint32(0x207d5ba2),
			231: uint32(0x02e5b9c5),
			232: uint32(0x83260376),
			233: uint32(0x6295cfa9),
			234: uint32(0x11c81968),
			235: uint32(0x4e734a41),
			236: uint32(0xb3472dca),
			237: uint32(0x7b14a94a),
			238: uint32(0x1b510052),
			239: uint32(0x9a532915),
			240: uint32(0xd60f573f),
			241: uint32(0xbc9bc6e4),
			242: uint32(0x2b60a476),
			243: uint32(0x81e67400),
			244: uint32(0x08ba6fb5),
			245: uint32(0x571be91f),
			246: uint32(0xf296ec6b),
			247: uint32(0x2a0dd915),
			248: uint32(0xb6636521),
			249: uint32(0xe7b9f9b6),
			250: uint32(0xff34052e),
			251: uint32(0xc5855664),
			252: uint32(0x53b02d5d),
			253: uint32(0xa99f8fa1),
			254: uint32(0x08ba4799),
			255: uint32(0x6e85076a),
		},
		1: {
			0:   uint32(0x4b7a70e9),
			1:   uint32(0xb5b32944),
			2:   uint32(0xdb75092e),
			3:   uint32(0xc4192623),
			4:   uint32(0xad6ea6b0),
			5:   uint32(0x49a7df7d),
			6:   uint32(0x9cee60b8),
			7:   uint32(0x8fedb266),
			8:   uint32(0xecaa8c71),
			9:   uint32(0x699a17ff),
			10:  uint32(0x5664526c),
			11:  uint32(0xc2b19ee1),
			12:  uint32(0x193602a5),
			13:  uint32(0x75094c29),
			14:  uint32(0xa0591340),
			15:  uint32(0xe4183a3e),
			16:  uint32(0x3f54989a),
			17:  uint32(0x5b429d65),
			18:  uint32(0x6b8fe4d6),
			19:  uint32(0x99f73fd6),
			20:  uint32(0xa1d29c07),
			21:  uint32(0xefe830f5),
			22:  uint32(0x4d2d38e6),
			23:  uint32(0xf0255dc1),
			24:  uint32(0x4cdd2086),
			25:  uint32(0x8470eb26),
			26:  uint32(0x6382e9c6),
			27:  uint32(0x021ecc5e),
			28:  uint32(0x09686b3f),
			29:  uint32(0x3ebaefc9),
			30:  uint32(0x3c971814),
			31:  uint32(0x6b6a70a1),
			32:  uint32(0x687f3584),
			33:  uint32(0x52a0e286),
			34:  uint32(0xb79c5305),
			35:  uint32(0xaa500737),
			36:  uint32(0x3e07841c),
			37:  uint32(0x7fdeae5c),
			38:  uint32(0x8e7d44ec),
			39:  uint32(0x5716f2b8),
			40:  uint32(0xb03ada37),
			41:  uint32(0xf0500c0d),
			42:  uint32(0xf01c1f04),
			43:  uint32(0x0200b3ff),
			44:  uint32(0xae0cf51a),
			45:  uint32(0x3cb574b2),
			46:  uint32(0x25837a58),
			47:  uint32(0xdc0921bd),
			48:  uint32(0xd19113f9),
			49:  uint32(0x7ca92ff6),
			50:  uint32(0x94324773),
			51:  uint32(0x22f54701),
			52:  uint32(0x3ae5e581),
			53:  uint32(0x37c2dadc),
			54:  uint32(0xc8b57634),
			55:  uint32(0x9af3dda7),
			56:  uint32(0xa9446146),
			57:  uint32(0x0fd0030e),
			58:  uint32(0xecc8c73e),
			59:  uint32(0xa4751e41),
			60:  uint32(0xe238cd99),
			61:  uint32(0x3bea0e2f),
			62:  uint32(0x3280bba1),
			63:  uint32(0x183eb331),
			64:  uint32(0x4e548b38),
			65:  uint32(0x4f6db908),
			66:  uint32(0x6f420d03),
			67:  uint32(0xf60a04bf),
			68:  uint32(0x2cb81290),
			69:  uint32(0x24977c79),
			70:  uint32(0x5679b072),
			71:  uint32(0xbcaf89af),
			72:  uint32(0xde9a771f),
			73:  uint32(0xd9930810),
			74:  uint32(0xb38bae12),
			75:  uint32(0xdccf3f2e),
			76:  uint32(0x5512721f),
			77:  uint32(0x2e6b7124),
			78:  uint32(0x501adde6),
			79:  uint32(0x9f84cd87),
			80:  uint32(0x7a584718),
			81:  uint32(0x7408da17),
			82:  uint32(0xbc9f9abc),
			83:  uint32(0xe94b7d8c),
			84:  uint32(0xec7aec3a),
			85:  uint32(0xdb851dfa),
			86:  uint32(0x63094366),
			87:  uint32(0xc464c3d2),
			88:  uint32(0xef1c1847),
			89:  uint32(0x3215d908),
			90:  uint32(0xdd433b37),
			91:  uint32(0x24c2ba16),
			92:  uint32(0x12a14d43),
			93:  uint32(0x2a65c451),
			94:  uint32(0x50940002),
			95:  uint32(0x133ae4dd),
			96:  uint32(0x71dff89e),
			97:  uint32(0x10314e55),
			98:  uint32(0x81ac77d6),
			99:  uint32(0x5f11199b),
			100: uint32(0x043556f1),
			101: uint32(0xd7a3c76b),
			102: uint32(0x3c11183b),
			103: uint32(0x5924a509),
			104: uint32(0xf28fe6ed),
			105: uint32(0x97f1fbfa),
			106: uint32(0x9ebabf2c),
			107: uint32(0x1e153c6e),
			108: uint32(0x86e34570),
			109: uint32(0xeae96fb1),
			110: uint32(0x860e5e0a),
			111: uint32(0x5a3e2ab3),
			112: uint32(0x771fe71c),
			113: uint32(0x4e3d06fa),
			114: uint32(0x2965dcb9),
			115: uint32(0x99e71d0f),
			116: uint32(0x803e89d6),
			117: uint32(0x5266c825),
			118: uint32(0x2e4cc978),
			119: uint32(0x9c10b36a),
			120: uint32(0xc6150eba),
			121: uint32(0x94e2ea78),
			122: uint32(0xa5fc3c53),
			123: uint32(0x1e0a2df4),
			124: uint32(0xf2f74ea7),
			125: uint32(0x361d2b3d),
			126: uint32(0x1939260f),
			127: uint32(0x19c27960),
			128: uint32(0x5223a708),
			129: uint32(0xf71312b6),
			130: uint32(0xebadfe6e),
			131: uint32(0xeac31f66),
			132: uint32(0xe3bc4595),
			133: uint32(0xa67bc883),
			134: uint32(0xb17f37d1),
			135: uint32(0x018cff28),
			136: uint32(0xc332ddef),
			137: uint32(0xbe6c5aa5),
			138: uint32(0x65582185),
			139: uint32(0x68ab9802),
			140: uint32(0xeecea50f),
			141: uint32(0xdb2f953b),
			142: uint32(0x2aef7dad),
			143: uint32(0x5b6e2f84),
			144: uint32(0x1521b628),
			145: uint32(0x29076170),
			146: uint32(0xecdd4775),
			147: uint32(0x619f1510),
			148: uint32(0x13cca830),
			149: uint32(0xeb61bd96),
			150: uint32(0x0334fe1e),
			151: uint32(0xaa0363cf),
			152: uint32(0xb5735c90),
			153: uint32(0x4c70a239),
			154: uint32(0xd59e9e0b),
			155: uint32(0xcbaade14),
			156: uint32(0xeecc86bc),
			157: uint32(0x60622ca7),
			158: uint32(0x9cab5cab),
			159: uint32(0xb2f3846e),
			160: uint32(0x648b1eaf),
			161: uint32(0x19bdf0ca),
			162: uint32(0xa02369b9),
			163: uint32(0x655abb50),
			164: uint32(0x40685a32),
			165: uint32(0x3c2ab4b3),
			166: uint32(0x319ee9d5),
			167: uint32(0xc021b8f7),
			168: uint32(0x9b540b19),
			169: uint32(0x875fa099),
			170: uint32(0x95f7997e),
			171: uint32(0x623d7da8),
			172: uint32(0xf837889a),
			173: uint32(0x97e32d77),
			174: uint32(0x11ed935f),
			175: uint32(0x16681281),
			176: uint32(0x0e358829),
			177: uint32(0xc7e61fd6),
			178: uint32(0x96dedfa1),
			179: uint32(0x7858ba99),
			180: uint32(0x57f584a5),
			181: uint32(0x1b227263),
			182: uint32(0x9b83c3ff),
			183: uint32(0x1ac24696),
			184: uint32(0xcdb30aeb),
			185: uint32(0x532e3054),
			186: uint32(0x8fd948e4),
			187: uint32(0x6dbc3128),
			188: uint32(0x58ebf2ef),
			189: uint32(0x34c6ffea),
			190: uint32(0xfe28ed61),
			191: uint32(0xee7c3c73),
			192: uint32(0x5d4a14d9),
			193: uint32(0xe864b7e3),
			194: uint32(0x42105d14),
			195: uint32(0x203e13e0),
			196: uint32(0x45eee2b6),
			197: uint32(0xa3aaabea),
			198: uint32(0xdb6c4f15),
			199: uint32(0xfacb4fd0),
			200: uint32(0xc742f442),
			201: uint32(0xef6abbb5),
			202: uint32(0x654f3b1d),
			203: uint32(0x41cd2105),
			204: uint32(0xd81e799e),
			205: uint32(0x86854dc7),
			206: uint32(0xe44b476a),
			207: uint32(0x3d816250),
			208: uint32(0xcf62a1f2),
			209: uint32(0x5b8d2646),
			210: uint32(0xfc8883a0),
			211: uint32(0xc1c7b6a3),
			212: uint32(0x7f1524c3),
			213: uint32(0x69cb7492),
			214: uint32(0x47848a0b),
			215: uint32(0x5692b285),
			216: uint32(0x095bbf00),
			217: uint32(0xad19489d),
			218: uint32(0x1462b174),
			219: uint32(0x23820e00),
			220: uint32(0x58428d2a),
			221: uint32(0x0c55f5ea),
			222: uint32(0x1dadf43e),
			223: uint32(0x233f7061),
			224: uint32(0x3372f092),
			225: uint32(0x8d937e41),
			226: uint32(0xd65fecf1),
			227: uint32(0x6c223bdb),
			228: uint32(0x7cde3759),
			229: uint32(0xcbee7460),
			230: uint32(0x4085f2a7),
			231: uint32(0xce77326e),
			232: uint32(0xa6078084),
			233: uint32(0x19f8509e),
			234: uint32(0xe8efd855),
			235: uint32(0x61d99735),
			236: uint32(0xa969a7aa),
			237: uint32(0xc50c06c2),
			238: uint32(0x5a04abfc),
			239: uint32(0x800bcadc),
			240: uint32(0x9e447a2e),
			241: uint32(0xc3453484),
			242: uint32(0xfdd56705),
			243: uint32(0x0e1e9ec9),
			244: uint32(0xdb73dbd3),
			245: uint32(0x105588cd),
			246: uint32(0x675fda79),
			247: uint32(0xe3674340),
			248: uint32(0xc5c43465),
			249: uint32(0x713e38d8),
			250: uint32(0x3d28f89e),
			251: uint32(0xf16dff20),
			252: uint32(0x153e21e7),
			253: uint32(0x8fb03d4a),
			254: uint32(0xe6e39f2b),
			255: uint32(0xdb83adf7),
		},
		2: {
			0:   uint32(0xe93d5a68),
			1:   uint32(0x948140f7),
			2:   uint32(0xf64c261c),
			3:   uint32(0x94692934),
			4:   uint32(0x411520f7),
			5:   uint32(0x7602d4f7),
			6:   uint32(0xbcf46b2e),
			7:   uint32(0xd4a20068),
			8:   uint32(0xd4082471),
			9:   uint32(0x3320f46a),
			10:  uint32(0x43b7d4b7),
			11:  uint32(0x500061af),
			12:  uint32(0x1e39f62e),
			13:  uint32(0x97244546),
			14:  uint32(0x14214f74),
			15:  uint32(0xbf8b8840),
			16:  uint32(0x4d95fc1d),
			17:  uint32(0x96b591af),
			18:  uint32(0x70f4ddd3),
			19:  uint32(0x66a02f45),
			20:  uint32(0xbfbc09ec),
			21:  uint32(0x03bd9785),
			22:  uint32(0x7fac6dd0),
			23:  uint32(0x31cb8504),
			24:  uint32(0x96eb27b3),
			25:  uint32(0x55fd3941),
			26:  uint32(0xda2547e6),
			27:  uint32(0xabca0a9a),
			28:  uint32(0x28507825),
			29:  uint32(0x530429f4),
			30:  uint32(0x0a2c86da),
			31:  uint32(0xe9b66dfb),
			32:  uint32(0x68dc1462),
			33:  uint32(0xd7486900),
			34:  uint32(0x680ec0a4),
			35:  uint32(0x27a18dee),
			36:  uint32(0x4f3ffea2),
			37:  uint32(0xe887ad8c),
			38:  uint32(0xb58ce006),
			39:  uint32(0x7af4d6b6),
			40:  uint32(0xaace1e7c),
			41:  uint32(0xd3375fec),
			42:  uint32(0xce78a399),
			43:  uint32(0x406b2a42),
			44:  uint32(0x20fe9e35),
			45:  uint32(0xd9f385b9),
			46:  uint32(0xee39d7ab),
			47:  uint32(0x3b124e8b),
			48:  uint32(0x1dc9faf7),
			49:  uint32(0x4b6d1856),
			50:  uint32(0x26a36631),
			51:  uint32(0xeae397b2),
			52:  uint32(0x3a6efa74),
			53:  uint32(0xdd5b4332),
			54:  uint32(0x6841e7f7),
			55:  uint32(0xca7820fb),
			56:  uint32(0xfb0af54e),
			57:  uint32(0xd8feb397),
			58:  uint32(0x454056ac),
			59:  uint32(0xba489527),
			60:  uint32(0x55533a3a),
			61:  uint32(0x20838d87),
			62:  uint32(0xfe6ba9b7),
			63:  uint32(0xd096954b),
			64:  uint32(0x55a867bc),
			65:  uint32(0xa1159a58),
			66:  uint32(0xcca92963),
			67:  uint32(0x99e1db33),
			68:  uint32(0xa62a4a56),
			69:  uint32(0x3f3125f9),
			70:  uint32(0x5ef47e1c),
			71:  uint32(0x9029317c),
			72:  uint32(0xfdf8e802),
			73:  uint32(0x04272f70),
			74:  uint32(0x80bb155c),
			75:  uint32(0x05282ce3),
			76:  uint32(0x95c11548),
			77:  uint32(0xe4c66d22),
			78:  uint32(0x48c1133f),
			79:  uint32(0xc70f86dc),
			80:  uint32(0x07f9c9ee),
			81:  uint32(0x41041f0f),
			82:  uint32(0x404779a4),
			83:  uint32(0x5d886e17),
			84:  uint32(0x325f51eb),
			85:  uint32(0xd59bc0d1),
			86:  uint32(0xf2bcc18f),
			87:  uint32(0x41113564),
			88:  uint32(0x257b7834),
			89:  uint32(0x602a9c60),
			90:  uint32(0xdff8e8a3),
			91:  uint32(0x1f636c1b),
			92:  uint32(0x0e12b4c2),
			93:  uint32(0x02e1329e),
			94:  uint32(0xaf664fd1),
			95:  uint32(0xcad18115),
			96:  uint32(0x6b2395e0),
			97:  uint32(0x333e92e1),
			98:  uint32(0x3b240b62),
			99:  uint32(0xeebeb922),
			100: uint32(0x85b2a20e),
			101: uint32(0xe6ba0d99),
			102: uint32(0xde720c8c),
			103: uint32(0x2da2f728),
			104: uint32(0xd0127845),
			105: uint32(0x95b794fd),
			106: uint32(0x647d0862),
			107: uint32(0xe7ccf5f0),
			108: uint32(0x5449a36f),
			109: uint32(0x877d48fa),
			110: uint32(0xc39dfd27),
			111: uint32(0xf33e8d1e),
			112: uint32(0x0a476341),
			113: uint32(0x992eff74),
			114: uint32(0x3a6f6eab),
			115: uint32(0xf4f8fd37),
			116: uint32(0xa812dc60),
			117: uint32(0xa1ebddf8),
			118: uint32(0x991be14c),
			119: uint32(0xdb6e6b0d),
			120: uint32(0xc67b5510),
			121: uint32(0x6d672c37),
			122: uint32(0x2765d43b),
			123: uint32(0xdcd0e804),
			124: uint32(0xf1290dc7),
			125: uint32(0xcc00ffa3),
			126: uint32(0xb5390f92),
			127: uint32(0x690fed0b),
			128: uint32(0x667b9ffb),
			129: uint32(0xcedb7d9c),
			130: uint32(0xa091cf0b),
			131: uint32(0xd9155ea3),
			132: uint32(0xbb132f88),
			133: uint32(0x515bad24),
			134: uint32(0x7b9479bf),
			135: uint32(0x763bd6eb),
			136: uint32(0x37392eb3),
			137: uint32(0xcc115979),
			138: uint32(0x8026e297),
			139: uint32(0xf42e312d),
			140: uint32(0x6842ada7),
			141: uint32(0xc66a2b3b),
			142: uint32(0x12754ccc),
			143: uint32(0x782ef11c),
			144: uint32(0x6a124237),
			145: uint32(0xb79251e7),
			146: uint32(0x06a1bbe6),
			147: uint32(0x4bfb6350),
			148: uint32(0x1a6b1018),
			149: uint32(0x11caedfa),
			150: uint32(0x3d25bdd8),
			151: uint32(0xe2e1c3c9),
			152: uint32(0x44421659),
			153: uint32(0x0a121386),
			154: uint32(0xd90cec6e),
			155: uint32(0xd5abea2a),
			156: uint32(0x64af674e),
			157: uint32(0xda86a85f),
			158: uint32(0xbebfe988),
			159: uint32(0x64e4c3fe),
			160: uint32(0x9dbc8057),
			161: uint32(0xf0f7c086),
			162: uint32(0x60787bf8),
			163: uint32(0x6003604d),
			164: uint32(0xd1fd8346),
			165: uint32(0xf6381fb0),
			166: uint32(0x7745ae04),
			167: uint32(0xd736fccc),
			168: uint32(0x83426b33),
			169: uint32(0xf01eab71),
			170: uint32(0xb0804187),
			171: uint32(0x3c005e5f),
			172: uint32(0x77a057be),
			173: uint32(0xbde8ae24),
			174: uint32(0x55464299),
			175: uint32(0xbf582e61),
			176: uint32(0x4e58f48f),
			177: uint32(0xf2ddfda2),
			178: uint32(0xf474ef38),
			179: uint32(0x8789bdc2),
			180: uint32(0x5366f9c3),
			181: uint32(0xc8b38e74),
			182: uint32(0xb475f255),
			183: uint32(0x46fcd9b9),
			184: uint32(0x7aeb2661),
			185: uint32(0x8b1ddf84),
			186: uint32(0x846a0e79),
			187: uint32(0x915f95e2),
			188: uint32(0x466e598e),
			189: uint32(0x20b45770),
			190: uint32(0x8cd55591),
			191: uint32(0xc902de4c),
			192: uint32(0xb90bace1),
			193: uint32(0xbb8205d0),
			194: uint32(0x11a86248),
			195: uint32(0x7574a99e),
			196: uint32(0xb77f19b6),
			197: uint32(0xe0a9dc09),
			198: uint32(0x662d09a1),
			199: uint32(0xc4324633),
			200: uint32(0xe85a1f02),
			201: uint32(0x09f0be8c),
			202: uint32(0x4a99a025),
			203: uint32(0x1d6efe10),
			204: uint32(0x1ab93d1d),
			205: uint32(0x0ba5a4df),
			206: uint32(0xa186f20f),
			207: uint32(0x2868f169),
			208: uint32(0xdcb7da83),
			209: uint32(0x573906fe),
			210: uint32(0xa1e2ce9b),
			211: uint32(0x4fcd7f52),
			212: uint32(0x50115e01),
			213: uint32(0xa70683fa),
			214: uint32(0xa002b5c4),
			215: uint32(0x0de6d027),
			216: uint32(0x9af88c27),
			217: uint32(0x773f8641),
			218: uint32(0xc3604c06),
			219: uint32(0x61a806b5),
			220: uint32(0xf0177a28),
			221: uint32(0xc0f586e0),
			222: uint32(0x006058aa),
			223: uint32(0x30dc7d62),
			224: uint32(0x11e69ed7),
			225: uint32(0x2338ea63),
			226: uint32(0x53c2dd94),
			227: uint32(0xc2c21634),
			228: uint32(0xbbcbee56),
			229: uint32(0x90bcb6de),
			230: uint32(0xebfc7da1),
			231: uint32(0xce591d76),
			232: uint32(0x6f05e409),
			233: uint32(0x4b7c0188),
			234: uint32(0x39720a3d),
			235: uint32(0x7c927c24),
			236: uint32(0x86e3725f),
			237: uint32(0x724d9db9),
			238: uint32(0x1ac15bb4),
			239: uint32(0xd39eb8fc),
			240: uint32(0xed545578),
			241: uint32(0x08fca5b5),
			242: uint32(0xd83d7cd3),
			243: uint32(0x4dad0fc4),
			244: uint32(0x1e50ef5e),
			245: uint32(0xb161e6f8),
			246: uint32(0xa28514d9),
			247: uint32(0x6c51133c),
			248: uint32(0x6fd5c7e7),
			249: uint32(0x56e14ec4),
			250: uint32(0x362abfce),
			251: uint32(0xddc6c837),
			252: uint32(0xd79a3234),
			253: uint32(0x92638212),
			254: uint32(0x670efa8e),
			255: uint32(0x406000e0),
		},
		3: {
			0:   uint32(0x3a39ce37),
			1:   uint32(0xd3faf5cf),
			2:   uint32(0xabc27737),
			3:   uint32(0x5ac52d1b),
			4:   uint32(0x5cb0679e),
			5:   uint32(0x4fa33742),
			6:   uint32(0xd3822740),
			7:   uint32(0x99bc9bbe),
			8:   uint32(0xd5118e9d),
			9:   uint32(0xbf0f7315),
			10:  uint32(0xd62d1c7e),
			11:  uint32(0xc700c47b),
			12:  uint32(0xb78c1b6b),
			13:  uint32(0x21a19045),
			14:  uint32(0xb26eb1be),
			15:  uint32(0x6a366eb4),
			16:  uint32(0x5748ab2f),
			17:  uint32(0xbc946e79),
			18:  uint32(0xc6a376d2),
			19:  uint32(0x6549c2c8),
			20:  uint32(0x530ff8ee),
			21:  uint32(0x468dde7d),
			22:  uint32(0xd5730a1d),
			23:  uint32(0x4cd04dc6),
			24:  uint32(0x2939bbdb),
			25:  uint32(0xa9ba4650),
			26:  uint32(0xac9526e8),
			27:  uint32(0xbe5ee304),
			28:  uint32(0xa1fad5f0),
			29:  uint32(0x6a2d519a),
			30:  uint32(0x63ef8ce2),
			31:  uint32(0x9a86ee22),
			32:  uint32(0xc089c2b8),
			33:  uint32(0x43242ef6),
			34:  uint32(0xa51e03aa),
			35:  uint32(0x9cf2d0a4),
			36:  uint32(0x83c061ba),
			37:  uint32(0x9be96a4d),
			38:  uint32(0x8fe51550),
			39:  uint32(0xba645bd6),
			40:  uint32(0x2826a2f9),
			41:  uint32(0xa73a3ae1),
			42:  uint32(0x4ba99586),
			43:  uint32(0xef5562e9),
			44:  uint32(0xc72fefd3),
			45:  uint32(0xf752f7da),
			46:  uint32(0x3f046f69),
			47:  uint32(0x77fa0a59),
			48:  uint32(0x80e4a915),
			49:  uint32(0x87b08601),
			50:  uint32(0x9b09e6ad),
			51:  uint32(0x3b3ee593),
			52:  uint32(0xe990fd5a),
			53:  uint32(0x9e34d797),
			54:  uint32(0x2cf0b7d9),
			55:  uint32(0x022b8b51),
			56:  uint32(0x96d5ac3a),
			57:  uint32(0x017da67d),
			58:  uint32(0xd1cf3ed6),
			59:  uint32(0x7c7d2d28),
			60:  uint32(0x1f9f25cf),
			61:  uint32(0xadf2b89b),
			62:  uint32(0x5ad6b472),
			63:  uint32(0x5a88f54c),
			64:  uint32(0xe029ac71),
			65:  uint32(0xe019a5e6),
			66:  uint32(0x47b0acfd),
			67:  uint32(0xed93fa9b),
			68:  uint32(0xe8d3c48d),
			69:  uint32(0x283b57cc),
			70:  uint32(0xf8d56629),
			71:  uint32(0x79132e28),
			72:  uint32(0x785f0191),
			73:  uint32(0xed756055),
			74:  uint32(0xf7960e44),
			75:  uint32(0xe3d35e8c),
			76:  uint32(0x15056dd4),
			77:  uint32(0x88f46dba),
			78:  uint32(0x03a16125),
			79:  uint32(0x0564f0bd),
			80:  uint32(0xc3eb9e15),
			81:  uint32(0x3c9057a2),
			82:  uint32(0x97271aec),
			83:  uint32(0xa93a072a),
			84:  uint32(0x1b3f6d9b),
			85:  uint32(0x1e6321f5),
			86:  uint32(0xf59c66fb),
			87:  uint32(0x26dcf319),
			88:  uint32(0x7533d928),
			89:  uint32(0xb155fdf5),
			90:  uint32(0x03563482),
			91:  uint32(0x8aba3cbb),
			92:  uint32(0x28517711),
			93:  uint32(0xc20ad9f8),
			94:  uint32(0xabcc5167),
			95:  uint32(0xccad925f),
			96:  uint32(0x4de81751),
			97:  uint32(0x3830dc8e),
			98:  uint32(0x379d5862),
			99:  uint32(0x9320f991),
			100: uint32(0xea7a90c2),
			101: uint32(0xfb3e7bce),
			102: uint32(0x5121ce64),
			103: uint32(0x774fbe32),
			104: uint32(0xa8b6e37e),
			105: uint32(0xc3293d46),
			106: uint32(0x48de5369),
			107: uint32(0x6413e680),
			108: uint32(0xa2ae0810),
			109: uint32(0xdd6db224),
			110: uint32(0x69852dfd),
			111: uint32(0x09072166),
			112: uint32(0xb39a460a),
			113: uint32(0x6445c0dd),
			114: uint32(0x586cdecf),
			115: uint32(0x1c20c8ae),
			116: uint32(0x5bbef7dd),
			117: uint32(0x1b588d40),
			118: uint32(0xccd2017f),
			119: uint32(0x6bb4e3bb),
			120: uint32(0xdda26a7e),
			121: uint32(0x3a59ff45),
			122: uint32(0x3e350a44),
			123: uint32(0xbcb4cdd5),
			124: uint32(0x72eacea8),
			125: uint32(0xfa6484bb),
			126: uint32(0x8d6612ae),
			127: uint32(0xbf3c6f47),
			128: uint32(0xd29be463),
			129: uint32(0x542f5d9e),
			130: uint32(0xaec2771b),
			131: uint32(0xf64e6370),
			132: uint32(0x740e0d8d),
			133: uint32(0xe75b1357),
			134: uint32(0xf8721671),
			135: uint32(0xaf537d5d),
			136: uint32(0x4040cb08),
			137: uint32(0x4eb4e2cc),
			138: uint32(0x34d2466a),
			139: uint32(0x0115af84),
			140: uint32(0xe1b00428),
			141: uint32(0x95983a1d),
			142: uint32(0x06b89fb4),
			143: uint32(0xce6ea048),
			144: uint32(0x6f3f3b82),
			145: uint32(0x3520ab82),
			146: uint32(0x011a1d4b),
			147: uint32(0x277227f8),
			148: uint32(0x611560b1),
			149: uint32(0xe7933fdc),
			150: uint32(0xbb3a792b),
			151: uint32(0x344525bd),
			152: uint32(0xa08839e1),
			153: uint32(0x51ce794b),
			154: uint32(0x2f32c9b7),
			155: uint32(0xa01fbac9),
			156: uint32(0xe01cc87e),
			157: uint32(0xbcc7d1f6),
			158: uint32(0xcf0111c3),
			159: uint32(0xa1e8aac7),
			160: uint32(0x1a908749),
			161: uint32(0xd44fbd9a),
			162: uint32(0xd0dadecb),
			163: uint32(0xd50ada38),
			164: uint32(0x0339c32a),
			165: uint32(0xc6913667),
			166: uint32(0x8df9317c),
			167: uint32(0xe0b12b4f),
			168: uint32(0xf79e59b7),
			169: uint32(0x43f5bb3a),
			170: uint32(0xf2d519ff),
			171: uint32(0x27d9459c),
			172: uint32(0xbf97222c),
			173: uint32(0x15e6fc2a),
			174: uint32(0x0f91fc71),
			175: uint32(0x9b941525),
			176: uint32(0xfae59361),
			177: uint32(0xceb69ceb),
			178: uint32(0xc2a86459),
			179: uint32(0x12baa8d1),
			180: uint32(0xb6c1075e),
			181: uint32(0xe3056a0c),
			182: uint32(0x10d25065),
			183: uint32(0xcb03a442),
			184: uint32(0xe0ec6e0e),
			185: uint32(0x1698db3b),
			186: uint32(0x4c98a0be),
			187: uint32(0x3278e964),
			188: uint32(0x9f1f9532),
			189: uint32(0xe0d392df),
			190: uint32(0xd3a0342b),
			191: uint32(0x8971f21e),
			192: uint32(0x1b0a7441),
			193: uint32(0x4ba3348c),
			194: uint32(0xc5be7120),
			195: uint32(0xc37632d8),
			196: uint32(0xdf359f8d),
			197: uint32(0x9b992f2e),
			198: uint32(0xe60b6f47),
			199: uint32(0x0fe3f11d),
			200: uint32(0xe54cda54),
			201: uint32(0x1edad891),
			202: uint32(0xce6279cf),
			203: uint32(0xcd3e7e6f),
			204: uint32(0x1618b166),
			205: uint32(0xfd2c1d05),
			206: uint32(0x848fd2c5),
			207: uint32(0xf6fb2299),
			208: uint32(0xf523f357),
			209: uint32(0xa6327623),
			210: uint32(0x93a83531),
			211: uint32(0x56cccd02),
			212: uint32(0xacf08162),
			213: uint32(0x5a75ebb5),
			214: uint32(0x6e163697),
			215: uint32(0x88d273cc),
			216: uint32(0xde966292),
			217: uint32(0x81b949d0),
			218: uint32(0x4c50901b),
			219: uint32(0x71c65614),
			220: uint32(0xe6c6c7bd),
			221: uint32(0x327a140a),
			222: uint32(0x45e1d006),
			223: uint32(0xc3f27b9a),
			224: uint32(0xc9aa53fd),
			225: uint32(0x62a80f00),
			226: uint32(0xbb25bfe2),
			227: uint32(0x35bdd2f6),
			228: uint32(0x71126905),
			229: uint32(0xb2040222),
			230: uint32(0xb6cbcf7c),
			231: uint32(0xcd769c2b),
			232: uint32(0x53113ec0),
			233: uint32(0x1640e3d3),
			234: uint32(0x38abbd60),
			235: uint32(0x2547adf0),
			236: uint32(0xba38209c),
			237: uint32(0xf746ce76),
			238: uint32(0x77afa1c5),
			239: uint32(0x20756060),
			240: uint32(0x85cbfe4e),
			241: uint32(0x8ae88dd8),
			242: uint32(0x7aaaf9b0),
			243: uint32(0x4cf9aa7e),
			244: uint32(0x1948c25c),
			245: uint32(0x02fb8a8c),
			246: uint32(0x01c36ae4),
			247: uint32(0xd6ebe1f9),
			248: uint32(0x90d4f869),
			249: uint32(0xa65cdea0),
			250: uint32(0x3f09252d),
			251: uint32(0xc208e69f),
			252: uint32(0xb74e6132),
			253: uint32(0xce77e25b),
			254: uint32(0x578fdfe3),
			255: uint32(0x3ac372e6),
		},
	},
}))

var _BF_itoa64 = [65]uint8{'.', '/', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}

var _BF_atoi64 = [96]uint8{
	0:  uint8(64),
	1:  uint8(64),
	2:  uint8(64),
	3:  uint8(64),
	4:  uint8(64),
	5:  uint8(64),
	6:  uint8(64),
	7:  uint8(64),
	8:  uint8(64),
	9:  uint8(64),
	10: uint8(64),
	11: uint8(64),
	12: uint8(64),
	13: uint8(64),
	15: uint8(1),
	16: uint8(54),
	17: uint8(55),
	18: uint8(56),
	19: uint8(57),
	20: uint8(58),
	21: uint8(59),
	22: uint8(60),
	23: uint8(61),
	24: uint8(62),
	25: uint8(63),
	26: uint8(64),
	27: uint8(64),
	28: uint8(64),
	29: uint8(64),
	30: uint8(64),
	31: uint8(64),
	32: uint8(64),
	33: uint8(2),
	34: uint8(3),
	35: uint8(4),
	36: uint8(5),
	37: uint8(6),
	38: uint8(7),
	39: uint8(8),
	40: uint8(9),
	41: uint8(10),
	42: uint8(11),
	43: uint8(12),
	44: uint8(13),
	45: uint8(14),
	46: uint8(15),
	47: uint8(16),
	48: uint8(17),
	49: uint8(18),
	50: uint8(19),
	51: uint8(20),
	52: uint8(21),
	53: uint8(22),
	54: uint8(23),
	55: uint8(24),
	56: uint8(25),
	57: uint8(26),
	58: uint8(27),
	59: uint8(64),
	60: uint8(64),
	61: uint8(64),
	62: uint8(64),
	63: uint8(64),
	64: uint8(64),
	65: uint8(28),
	66: uint8(29),
	67: uint8(30),
	68: uint8(31),
	69: uint8(32),
	70: uint8(33),
	71: uint8(34),
	72: uint8(35),
	73: uint8(36),
	74: uint8(37),
	75: uint8(38),
	76: uint8(39),
	77: uint8(40),
	78: uint8(41),
	79: uint8(42),
	80: uint8(43),
	81: uint8(44),
	82: uint8(45),
	83: uint8(46),
	84: uint8(47),
	85: uint8(48),
	86: uint8(49),
	87: uint8(50),
	88: uint8(51),
	89: uint8(52),
	90: uint8(53),
	91: uint8(64),
	92: uint8(64),
	93: uint8(64),
	94: uint8(64),
	95: uint8(64),
}

func _BF_decode(tls *TLS, dst uintptr, src uintptr, size int32) (r int32) {
	var c1, c2, c3, c4, tmp uint32
	var dptr, end, sptr, v1, v2, v3, v4, v5, v6, v7 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c1, c2, c3, c4, dptr, end, sptr, tmp, v1, v2, v3, v4, v5, v6, v7
	dptr = dst
	end = dptr + uintptr(size)
	sptr = src
	for cond := true; cond; cond = dptr < end {
		v1 = sptr
		sptr++
		tmp = uint32(*(*uint8)(unsafe.Pointer(v1)))
		tmp -= uint32(0x20)
		if tmp >= uint32(0x60) {
			return -int32(1)
		}
		tmp = uint32(_BF_atoi64[tmp])
		if tmp > uint32(63) {
			return -int32(1)
		}
		c1 = tmp
		v2 = sptr
		sptr++
		tmp = uint32(*(*uint8)(unsafe.Pointer(v2)))
		tmp -= uint32(0x20)
		if tmp >= uint32(0x60) {
			return -int32(1)
		}
		tmp = uint32(_BF_atoi64[tmp])
		if tmp > uint32(63) {
			return -int32(1)
		}
		c2 = tmp
		v3 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v3)) = uint8(c1<<int32(2) | c2&uint32(0x30)>>int32(4))
		if dptr >= end {
			break
		}
		v4 = sptr
		sptr++
		tmp = uint32(*(*uint8)(unsafe.Pointer(v4)))
		tmp -= uint32(0x20)
		if tmp >= uint32(0x60) {
			return -int32(1)
		}
		tmp = uint32(_BF_atoi64[tmp])
		if tmp > uint32(63) {
			return -int32(1)
		}
		c3 = tmp
		v5 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v5)) = uint8(c2&uint32(0x0F)<<int32(4) | c3&uint32(0x3C)>>int32(2))
		if dptr >= end {
			break
		}
		v6 = sptr
		sptr++
		tmp = uint32(*(*uint8)(unsafe.Pointer(v6)))
		tmp -= uint32(0x20)
		if tmp >= uint32(0x60) {
			return -int32(1)
		}
		tmp = uint32(_BF_atoi64[tmp])
		if tmp > uint32(63) {
			return -int32(1)
		}
		c4 = tmp
		v7 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v7)) = uint8(c3&uint32(0x03)<<int32(6) | c4)
	}
	return 0
}

func _BF_encode(tls *TLS, dst uintptr, src uintptr, size int32) {
	var c1, c2 uint32
	var dptr, end, sptr, v1, v2, v3, v4, v5, v6, v7, v8, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = c1, c2, dptr, end, sptr, v1, v2, v3, v4, v5, v6, v7, v8, v9
	sptr = src
	end = sptr + uintptr(size)
	dptr = dst
	for cond := true; cond; cond = sptr < end {
		v1 = sptr
		sptr++
		c1 = uint32(*(*uint8)(unsafe.Pointer(v1)))
		v2 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v2)) = _BF_itoa64[c1>>int32(2)]
		c1 = c1 & uint32(0x03) << int32(4)
		if sptr >= end {
			v3 = dptr
			dptr++
			*(*uint8)(unsafe.Pointer(v3)) = _BF_itoa64[c1]
			break
		}
		v4 = sptr
		sptr++
		c2 = uint32(*(*uint8)(unsafe.Pointer(v4)))
		c1 |= c2 >> int32(4)
		v5 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v5)) = _BF_itoa64[c1]
		c1 = c2 & uint32(0x0f) << int32(2)
		if sptr >= end {
			v6 = dptr
			dptr++
			*(*uint8)(unsafe.Pointer(v6)) = _BF_itoa64[c1]
			break
		}
		v7 = sptr
		sptr++
		c2 = uint32(*(*uint8)(unsafe.Pointer(v7)))
		c1 |= c2 >> int32(6)
		v8 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v8)) = _BF_itoa64[c1]
		v9 = dptr
		dptr++
		*(*uint8)(unsafe.Pointer(v9)) = _BF_itoa64[c2&uint32(0x3f)]
	}
}

func _BF_swap(tls *TLS, x uintptr, count int32) {
	var tmp TBF_word
	var v1, v2 int32
	var v4 uintptr
	_, _, _, _ = tmp, v1, v2, v4
	v1 = int32(1)
	if *(*uint8)(unsafe.Pointer(&v1)) != 0 {
		for {
			tmp = *(*TBF_word)(unsafe.Pointer(x))
			tmp = tmp<<Int32FromInt32(16) | tmp>>Int32FromInt32(16)
			v4 = x
			x += 4
			*(*TBF_word)(unsafe.Pointer(v4)) = tmp&uint32(0x00FF00FF)<<int32(8) | tmp>>Int32FromInt32(8)&uint32(0x00FF00FF)
			goto _3
		_3:
			;
			count--
			v2 = count
			if !(v2 != 0) {
				break
			}
		}
	}
}

func _BF_encrypt(tls *TLS, ctx uintptr, L TBF_word, R TBF_word, start uintptr, end uintptr) (r TBF_word) {
	var i int32
	var ptr, v2, v3 uintptr
	var tmp1, tmp2, tmp3, tmp4 TBF_word
	_, _, _, _, _, _, _, _ = i, ptr, tmp1, tmp2, tmp3, tmp4, v2, v3
	ptr = start
	for cond := true; cond; cond = ptr < end {
		L ^= *(*TBF_word)(unsafe.Pointer(ctx))
		i = 0
		for {
			if !(i < int32(16)) {
				break
			}
			tmp1 = L & uint32(0xFF)
			tmp2 = L >> int32(8)
			tmp2 &= uint32(0xFF)
			tmp3 = L >> int32(16)
			tmp3 &= uint32(0xFF)
			tmp4 = L >> int32(24)
			tmp1 = *(*TBF_word)(unsafe.Pointer(ctx + 72 + 3*1024 + uintptr(tmp1)*4))
			tmp2 = *(*TBF_word)(unsafe.Pointer(ctx + 72 + 2*1024 + uintptr(tmp2)*4))
			tmp3 = *(*TBF_word)(unsafe.Pointer(ctx + 72 + 1*1024 + uintptr(tmp3)*4))
			tmp3 += *(*TBF_word)(unsafe.Pointer(ctx + 72 + uintptr(tmp4)*4))
			tmp3 ^= tmp2
			R ^= *(*TBF_word)(unsafe.Pointer(ctx + uintptr(i+int32(1))*4))
			tmp3 += tmp1
			R ^= tmp3
			tmp1 = R & uint32(0xFF)
			tmp2 = R >> int32(8)
			tmp2 &= uint32(0xFF)
			tmp3 = R >> int32(16)
			tmp3 &= uint32(0xFF)
			tmp4 = R >> int32(24)
			tmp1 = *(*TBF_word)(unsafe.Pointer(ctx + 72 + 3*1024 + uintptr(tmp1)*4))
			tmp2 = *(*TBF_word)(unsafe.Pointer(ctx + 72 + 2*1024 + uintptr(tmp2)*4))
			tmp3 = *(*TBF_word)(unsafe.Pointer(ctx + 72 + 1*1024 + uintptr(tmp3)*4))
			tmp3 += *(*TBF_word)(unsafe.Pointer(ctx + 72 + uintptr(tmp4)*4))
			tmp3 ^= tmp2
			L ^= *(*TBF_word)(unsafe.Pointer(ctx + uintptr(i+int32(1)+int32(1))*4))
			tmp3 += tmp1
			L ^= tmp3
			goto _1
		_1:
			;
			i += int32(2)
		}
		tmp4 = R
		R = L
		L = tmp4 ^ *(*TBF_word)(unsafe.Pointer(ctx + uintptr(Int32FromInt32(BF_N)+Int32FromInt32(1))*4))
		v2 = ptr
		ptr += 4
		*(*TBF_word)(unsafe.Pointer(v2)) = L
		v3 = ptr
		ptr += 4
		*(*TBF_word)(unsafe.Pointer(v3)) = R
	}
	return L
}

func _BF_set_key(tls *TLS, key uintptr, expanded uintptr, initial uintptr, flags uint8) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var bug, i, j uint32
	var diff, safety, sign, v1, v3 TBF_word
	var ptr uintptr
	var _ /* tmp at bp+0 */ [2]TBF_word
	_, _, _, _, _, _, _, _, _ = bug, diff, i, j, ptr, safety, sign, v1, v3
	ptr = key
	/*
	 * There was a sign extension bug in older revisions of this function.  While
	 * we would have liked to simply fix the bug and move on, we have to provide
	 * a backwards compatibility feature (essentially the bug) for some systems and
	 * a safety measure for some others.  The latter is needed because for certain
	 * multiple inputs to the buggy algorithm there exist easily found inputs to
	 * the correct algorithm that produce the same hash.  Thus, we optionally
	 * deviate from the correct algorithm just enough to avoid such collisions.
	 * While the bug itself affected the majority of passwords containing
	 * characters with the 8th bit set (although only a percentage of those in a
	 * collision-producing way), the anti-collision safety measure affects
	 * only a subset of passwords containing the '\xff' character (not even all of
	 * those passwords, just some of them).  This character is not found in valid
	 * UTF-8 sequences and is rarely used in popular 8-bit character encodings.
	 * Thus, the safety measure is unlikely to cause much annoyance, and is a
	 * reasonable tradeoff to use when authenticating against existing hashes that
	 * are not reliably known to have been computed with the correct algorithm.
	 *
	 * We use an approach that tries to minimize side-channel leaks of password
	 * information - that is, we mostly use fixed-cost bitwise operations instead
	 * of branches or table lookups.  (One conditional branch based on password
	 * length remains.  It is not part of the bug aftermath, though, and is
	 * difficult and possibly unreasonable to avoid given the use of C strings by
	 * the caller, which results in similar timing leaks anyway.)
	 *
	 * For actual implementation, we set an array index in the variable "bug"
	 * (0 means no bug, 1 means sign extension bug emulation) and a flag in the
	 * variable "safety" (bit 16 is set when the safety measure is requested).
	 * Valid combinations of settings are:
	 *
	 * Prefix "$2a$": bug = 0, safety = 0x10000
	 * Prefix "$2b$": bug = 0, safety = 0
	 * Prefix "$2x$": bug = 1, safety = 0
	 * Prefix "$2y$": bug = 0, safety = 0
	 */
	bug = uint32(int32(flags) & int32(1))
	safety = uint32(flags) & uint32(2) << int32(15)
	v1 = Uint32FromInt32(0)
	diff = v1
	sign = v1
	i = uint32(0)
	for {
		if !(i < uint32(Int32FromInt32(BF_N)+Int32FromInt32(2))) {
			break
		}
		v3 = Uint32FromInt32(0)
		(*(*[2]TBF_word)(unsafe.Pointer(bp)))[int32(1)] = v3
		(*(*[2]TBF_word)(unsafe.Pointer(bp)))[0] = v3
		j = uint32(0)
		for {
			if !(j < uint32(4)) {
				break
			}
			*(*TBF_word)(unsafe.Pointer(bp)) <<= uint32(8)
			*(*TBF_word)(unsafe.Pointer(bp)) |= uint32(*(*uint8)(unsafe.Pointer(ptr))) /* correct */
			*(*TBF_word)(unsafe.Pointer(bp + 1*4)) <<= uint32(8)
			*(*TBF_word)(unsafe.Pointer(bp + 1*4)) |= uint32(int8(*(*uint8)(unsafe.Pointer(ptr)))) /* bug */
			/*
			 * Sign extension in the first char has no effect - nothing to overwrite yet,
			 * and those extra 24 bits will be fully shifted out of the 32-bit word.  For
			 * chars 2, 3, 4 in each four-char block, we set bit 7 of "sign" if sign
			 * extension in tmp[1] occurs.  Once this flag is set, it remains set.
			 */
			if j != 0 {
				sign |= (*(*[2]TBF_word)(unsafe.Pointer(bp)))[int32(1)] & uint32(0x80)
			}
			if !(*(*uint8)(unsafe.Pointer(ptr)) != 0) {
				ptr = key
			} else {
				ptr++
			}
			goto _4
		_4:
			;
			j++
		}
		diff |= (*(*[2]TBF_word)(unsafe.Pointer(bp)))[0] ^ (*(*[2]TBF_word)(unsafe.Pointer(bp)))[int32(1)] /* Non-zero on any differences */
		*(*TBF_word)(unsafe.Pointer(expanded + uintptr(i)*4)) = (*(*[2]TBF_word)(unsafe.Pointer(bp)))[bug]
		*(*TBF_word)(unsafe.Pointer(initial + uintptr(i)*4)) = *(*TBF_word)(unsafe.Pointer(uintptr(unsafe.Pointer(&_BF_init_state)) + uintptr(i)*4)) ^ (*(*[2]TBF_word)(unsafe.Pointer(bp)))[bug]
		goto _2
	_2:
		;
		i++
	}
	/*
	 * At this point, "diff" is zero iff the correct and buggy algorithms produced
	 * exactly the same result.  If so and if "sign" is non-zero, which indicates
	 * that there was a non-benign sign extension, this means that we have a
	 * collision between the correctly computed hash for this password and a set of
	 * passwords that could be supplied to the buggy algorithm.  Our safety measure
	 * is meant to protect from such many-buggy to one-correct collisions, by
	 * deviating from the correct algorithm in such cases.  Let's check for this.
	 */
	diff |= diff >> int32(16) /* still zero iff exact match */
	diff &= uint32(0xffff)    /* ditto */
	diff += uint32(0xffff)    /* bit 16 set iff "diff" was non-zero (on non-match) */
	sign <<= uint32(9)        /* move the non-benign sign extension flag to bit 16 */
	sign &= ^diff & safety    /* action needed? */
	/*
	 * If we have determined that we need to deviate from the correct algorithm,
	 * flip bit 16 in initial expanded key.  (The choice of 16 is arbitrary, but
	 * let's stick to it now.  It came out of the approach we used above, and it's
	 * not any worse than any other choice we could make.)
	 *
	 * It is crucial that we don't do the same to the expanded key used in the main
	 * Eksblowfish loop.  By doing it to only one of these two, we deviate from a
	 * state that could be directly specified by a password to the buggy algorithm
	 * (and to the fully correct one as well, but that's a side-effect).
	 */
	*(*TBF_word)(unsafe.Pointer(initial)) ^= sign
}

var _flags_by_subtype = [26]uint8{
	0:  uint8(2),
	1:  uint8(4),
	23: uint8(1),
	24: uint8(4),
}

func _BF_crypt(tls *TLS, key uintptr, setting uintptr, output uintptr, min TBF_word) (r uintptr) {
	bp := tls.Alloc(4272)
	defer tls.Free(4272)
	var L, L1, R, count, tmp1, tmp2, tmp3, tmp4, v1, v6 TBF_word
	var done, i int32
	var ptr uintptr
	var _ /* LR at bp+4264 */ [2]TBF_word
	var _ /* data at bp+0 */ struct {
		Fctx          TBF_ctx
		Fexpanded_key TBF_key
		Fbinary       struct {
			Foutput      [0][6]TBF_word
			Fsalt        [4]TBF_word
			F__ccgo_pad2 [8]byte
		}
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _ = L, L1, R, count, done, i, ptr, tmp1, tmp2, tmp3, tmp4, v1, v6
	if int32(*(*uint8)(unsafe.Pointer(setting))) != int32('$') || int32(*(*uint8)(unsafe.Pointer(setting + 1))) != int32('2') || uint32(int32(*(*uint8)(unsafe.Pointer(setting + 2)))-int32('a')) > uint32(25) || !(_flags_by_subtype[int32(*(*uint8)(unsafe.Pointer(setting + 2)))-int32('a')] != 0) || int32(*(*uint8)(unsafe.Pointer(setting + 3))) != int32('$') || uint32(int32(*(*uint8)(unsafe.Pointer(setting + 4)))-int32('0')) > uint32(1) || uint32(int32(*(*uint8)(unsafe.Pointer(setting + 5)))-int32('0')) > uint32(9) || int32(*(*uint8)(unsafe.Pointer(setting + 6))) != int32('$') {
		return UintptrFromInt32(0)
	}
	count = Uint32FromInt32(1) << ((int32(*(*uint8)(unsafe.Pointer(setting + 4)))-int32('0'))*int32(10) + (int32(*(*uint8)(unsafe.Pointer(setting + 5))) - int32('0')))
	if count < min || _BF_decode(tls, bp+4240, setting+7, int32(16)) != 0 {
		return UintptrFromInt32(0)
	}
	_BF_swap(tls, bp+4240, int32(4))
	_BF_set_key(tls, key, bp+4168, bp, _flags_by_subtype[int32(*(*uint8)(unsafe.Pointer(setting + 2)))-int32('a')])
	Xmemcpy(tls, bp+72, uintptr(unsafe.Pointer(&_BF_init_state))+72, uint64(4096))
	L = uint32(0)
	R = uint32(0)
	ptr = bp
	for cond := true; cond; cond = int32(1) != 0 {
		L = _BF_encrypt(tls, bp, L^*(*TBF_word)(unsafe.Pointer(bp + 4240)), R^*(*TBF_word)(unsafe.Pointer(bp + 4240 + 1*4)), ptr, ptr)
		R = *(*TBF_word)(unsafe.Pointer(ptr + UintptrFromInt32(1)*4))
		ptr += uintptr(2) * 4
		if ptr >= bp+uintptr(Int32FromInt32(BF_N)+Int32FromInt32(2)+Int32FromInt32(4)*Int32FromInt32(0x100))*4 {
			break
		}
		L = _BF_encrypt(tls, bp, L^*(*TBF_word)(unsafe.Pointer(bp + 4240 + 2*4)), R^*(*TBF_word)(unsafe.Pointer(bp + 4240 + 3*4)), ptr, ptr)
		R = *(*TBF_word)(unsafe.Pointer(ptr + UintptrFromInt32(1)*4))
		ptr += uintptr(2) * 4
	}
	for {
		i = 0
		for {
			if !(i < Int32FromInt32(BF_N)+Int32FromInt32(2)) {
				break
			}
			*(*TBF_word)(unsafe.Pointer(bp + uintptr(i)*4)) ^= *(*TBF_word)(unsafe.Pointer(bp + 4168 + uintptr(i)*4))
			*(*TBF_word)(unsafe.Pointer(bp + uintptr(i+int32(1))*4)) ^= *(*TBF_word)(unsafe.Pointer(bp + 4168 + uintptr(i+int32(1))*4))
			goto _3
		_3:
			;
			i += int32(2)
		}
		done = 0
		for cond := true; cond; cond = int32(1) != 0 {
			_BF_encrypt(tls, bp, uint32(0), uint32(0), bp, bp+uintptr(Int32FromInt32(BF_N)+Int32FromInt32(2)+Int32FromInt32(4)*Int32FromInt32(0x100))*4)
			if done != 0 {
				break
			}
			done = int32(1)
			tmp1 = *(*TBF_word)(unsafe.Pointer(bp + 4240))
			tmp2 = *(*TBF_word)(unsafe.Pointer(bp + 4240 + 1*4))
			tmp3 = *(*TBF_word)(unsafe.Pointer(bp + 4240 + 2*4))
			tmp4 = *(*TBF_word)(unsafe.Pointer(bp + 4240 + 3*4))
			i = 0
			for {
				if !(i < int32(BF_N)) {
					break
				}
				*(*TBF_word)(unsafe.Pointer(bp + uintptr(i)*4)) ^= tmp1
				*(*TBF_word)(unsafe.Pointer(bp + uintptr(i+int32(1))*4)) ^= tmp2
				*(*TBF_word)(unsafe.Pointer(bp + uintptr(i+int32(2))*4)) ^= tmp3
				*(*TBF_word)(unsafe.Pointer(bp + uintptr(i+int32(3))*4)) ^= tmp4
				goto _4
			_4:
				;
				i += int32(4)
			}
			*(*TBF_word)(unsafe.Pointer(bp + 16*4)) ^= tmp1
			*(*TBF_word)(unsafe.Pointer(bp + 17*4)) ^= tmp2
		}
		goto _2
	_2:
		;
		count--
		v1 = count
		if !(v1 != 0) {
			break
		}
	}
	i = 0
	for {
		if !(i < int32(6)) {
			break
		}
		L1 = _BF_magic_w[i]
		(*(*[2]TBF_word)(unsafe.Pointer(bp + 4264)))[int32(1)] = _BF_magic_w[i+int32(1)]
		count = uint32(64)
		for {
			L1 = _BF_encrypt(tls, bp, L1, (*(*[2]TBF_word)(unsafe.Pointer(bp + 4264)))[int32(1)], bp+4264, bp+4264)
			goto _7
		_7:
			;
			count--
			v6 = count
			if !(v6 != 0) {
				break
			}
		}
		*(*TBF_word)(unsafe.Pointer(bp + 4240 + uintptr(i)*4)) = L1
		*(*TBF_word)(unsafe.Pointer(bp + 4240 + uintptr(i+int32(1))*4)) = (*(*[2]TBF_word)(unsafe.Pointer(bp + 4264)))[int32(1)]
		goto _5
	_5:
		;
		i += int32(2)
	}
	Xmemcpy(tls, output, setting, uint64(Int32FromInt32(7)+Int32FromInt32(22)-Int32FromInt32(1)))
	*(*uint8)(unsafe.Pointer(output + uintptr(Int32FromInt32(7)+Int32FromInt32(22)-Int32FromInt32(1)))) = _BF_itoa64[int32(_BF_atoi64[int32(*(*uint8)(unsafe.Pointer(setting + uintptr(Int32FromInt32(7)+Int32FromInt32(22)-Int32FromInt32(1)))))-int32(0x20)])&int32(0x30)]
	/* This has to be bug-compatible with the original implementation, so
	 * only encode 23 of the 24 bytes. :-) */
	_BF_swap(tls, bp+4240, int32(6))
	_BF_encode(tls, output+uintptr(Int32FromInt32(7)+Int32FromInt32(22)), bp+4240, int32(23))
	*(*uint8)(unsafe.Pointer(output + uintptr(Int32FromInt32(7)+Int32FromInt32(22)+Int32FromInt32(31)))) = uint8('\000')
	return output
}

// C documentation
//
//	/*
//	 * Please preserve the runtime self-test.  It serves two purposes at once:
//	 *
//	 * 1. We really can't afford the risk of producing incompatible hashes e.g.
//	 * when there's something like gcc bug 26587 again, whereas an application or
//	 * library integrating this code might not also integrate our external tests or
//	 * it might not run them after every build.  Even if it does, the miscompile
//	 * might only occur on the production build, but not on a testing build (such
//	 * as because of different optimization settings).  It is painful to recover
//	 * from incorrectly-computed hashes - merely fixing whatever broke is not
//	 * enough.  Thus, a proactive measure like this self-test is needed.
//	 *
//	 * 2. We don't want to leave sensitive data from our actual password hash
//	 * computation on the stack or in registers.  Previous revisions of the code
//	 * would do explicit cleanups, but simply running the self-test after hash
//	 * computation is more reliable.
//	 *
//	 * The performance cost of this quick self-test is around 0.6% at the "$2a$08"
//	 * setting.
//	 */
func X__crypt_blowfish(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v setting=%v output=%v, (%v:)", tls, key, setting, output, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(384)
	defer tls.Free(384)
	var flags uint32
	var k, p, retval, test_hash, test_key, test_setting uintptr
	var ok int32
	var _ /* ae at bp+96 */ TBF_key
	var _ /* ai at bp+168 */ TBF_key
	var _ /* buf at bp+0 */ struct {
		Fs [30]uint8
		Fo [63]uint8
	}
	var _ /* ye at bp+240 */ TBF_key
	var _ /* yi at bp+312 */ TBF_key
	_, _, _, _, _, _, _, _ = flags, k, ok, p, retval, test_hash, test_key, test_setting
	test_key = __ccgo_ts + 18
	test_setting = __ccgo_ts + 28
	test_hash = uintptr(unsafe.Pointer(&_test_hashes))
	/* Hash the supplied password */
	retval = _BF_crypt(tls, key, setting, output, uint32(16))
	/*
	 * Do a quick self-test.  It is important that we make both calls to BF_crypt()
	 * from the same scope such that they likely use the same stack locations,
	 * which makes the second call overwrite the first call's sensitive data on the
	 * stack and makes it more likely that any alignment related issues would be
	 * detected by the self-test.
	 */
	Xmemcpy(tls, bp, test_setting, uint64(30))
	if retval != 0 {
		flags = uint32(_flags_by_subtype[int32(*(*uint8)(unsafe.Pointer(setting + 2)))-int32('a')])
		test_hash = uintptr(unsafe.Pointer(&_test_hashes)) + uintptr(flags&uint32(1))*34
		*(*uint8)(unsafe.Pointer(bp + 2)) = *(*uint8)(unsafe.Pointer(setting + 2))
	}
	Xmemset(tls, bp+30, int32(0x55), uint64(63))
	*(*uint8)(unsafe.Pointer(bp + 30 + uintptr(Uint64FromInt64(63)-Uint64FromInt32(1)))) = uint8(0)
	p = _BF_crypt(tls, test_key, bp, bp+30, uint32(1))
	ok = BoolInt32(p == bp+30 && !(Xmemcmp(tls, p, bp, uint64(Int32FromInt32(7)+Int32FromInt32(22))) != 0) && !(Xmemcmp(tls, p+uintptr(Int32FromInt32(7)+Int32FromInt32(22)), test_hash, uint64(Int32FromInt32(31)+Int32FromInt32(1)+Int32FromInt32(1)+Int32FromInt32(1))) != 0))
	k = __ccgo_ts + 58
	_BF_set_key(tls, k, bp+96, bp+168, uint8(2))              /* $2a$ */
	_BF_set_key(tls, k, bp+240, bp+312, uint8(4))             /* $2y$ */
	*(*TBF_word)(unsafe.Pointer(bp + 168)) ^= uint32(0x10000) /* undo the safety (for comparison) */
	ok = BoolInt32(ok != 0 && (*(*TBF_key)(unsafe.Pointer(bp + 168)))[0] == uint32(0xdb9c59bc) && (*(*TBF_key)(unsafe.Pointer(bp + 240)))[int32(17)] == uint32(0x33343500) && !(Xmemcmp(tls, bp+96, bp+240, uint64(72)) != 0) && !(Xmemcmp(tls, bp+168, bp+312, uint64(72)) != 0))
	if ok != 0 && retval != 0 {
		return retval
	}
	return __ccgo_ts + 70
}

var _test_hashes = [2][34]uint8{
	0: {'i', '1', 'D', '7', '0', '9', 'v', 'f', 'a', 'm', 'u', 'l', 'i', 'm', 'l', 'G', 'c', 'q', '0', 'q', 'q', '3', 'U', 'v', 'u', 'U', 'a', 's', 'v', 'E', 'a', 0, 'U'},
	1: {'V', 'U', 'r', 'P', 'm', 'X', 'D', '6', 'q', '/', 'n', 'V', 'S', 'S', 'p', '7', 'p', 'N', 'D', 'h', 'C', 'R', '9', '0', '7', '1', 'I', 'f', 'I', 'R', 'e', 0, 'U'},
}

const _PASSWORD_EFMT1 = 95

type Texpanded_key = struct {
	Fl [16]Tuint32_t
	Fr [16]Tuint32_t
}

var _key_shifts = [16]uint8{
	0:  uint8(1),
	1:  uint8(1),
	2:  uint8(2),
	3:  uint8(2),
	4:  uint8(2),
	5:  uint8(2),
	6:  uint8(2),
	7:  uint8(2),
	8:  uint8(1),
	9:  uint8(2),
	10: uint8(2),
	11: uint8(2),
	12: uint8(2),
	13: uint8(2),
	14: uint8(2),
	15: uint8(1),
}

var _psbox = [8][64]Tuint32_t{
	0: {
		0:  uint32(0x00808200),
		2:  uint32(0x00008000),
		3:  uint32(0x00808202),
		4:  uint32(0x00808002),
		5:  uint32(0x00008202),
		6:  uint32(0x00000002),
		7:  uint32(0x00008000),
		8:  uint32(0x00000200),
		9:  uint32(0x00808200),
		10: uint32(0x00808202),
		11: uint32(0x00000200),
		12: uint32(0x00800202),
		13: uint32(0x00808002),
		14: uint32(0x00800000),
		15: uint32(0x00000002),
		16: uint32(0x00000202),
		17: uint32(0x00800200),
		18: uint32(0x00800200),
		19: uint32(0x00008200),
		20: uint32(0x00008200),
		21: uint32(0x00808000),
		22: uint32(0x00808000),
		23: uint32(0x00800202),
		24: uint32(0x00008002),
		25: uint32(0x00800002),
		26: uint32(0x00800002),
		27: uint32(0x00008002),
		29: uint32(0x00000202),
		30: uint32(0x00008202),
		31: uint32(0x00800000),
		32: uint32(0x00008000),
		33: uint32(0x00808202),
		34: uint32(0x00000002),
		35: uint32(0x00808000),
		36: uint32(0x00808200),
		37: uint32(0x00800000),
		38: uint32(0x00800000),
		39: uint32(0x00000200),
		40: uint32(0x00808002),
		41: uint32(0x00008000),
		42: uint32(0x00008200),
		43: uint32(0x00800002),
		44: uint32(0x00000200),
		45: uint32(0x00000002),
		46: uint32(0x00800202),
		47: uint32(0x00008202),
		48: uint32(0x00808202),
		49: uint32(0x00008002),
		50: uint32(0x00808000),
		51: uint32(0x00800202),
		52: uint32(0x00800002),
		53: uint32(0x00000202),
		54: uint32(0x00008202),
		55: uint32(0x00808200),
		56: uint32(0x00000202),
		57: uint32(0x00800200),
		58: uint32(0x00800200),
		60: uint32(0x00008002),
		61: uint32(0x00008200),
		63: uint32(0x00808002),
	},
	1: {
		0:  uint32(0x40084010),
		1:  uint32(0x40004000),
		2:  uint32(0x00004000),
		3:  uint32(0x00084010),
		4:  uint32(0x00080000),
		5:  uint32(0x00000010),
		6:  uint32(0x40080010),
		7:  uint32(0x40004010),
		8:  uint32(0x40000010),
		9:  uint32(0x40084010),
		10: uint32(0x40084000),
		11: uint32(0x40000000),
		12: uint32(0x40004000),
		13: uint32(0x00080000),
		14: uint32(0x00000010),
		15: uint32(0x40080010),
		16: uint32(0x00084000),
		17: uint32(0x00080010),
		18: uint32(0x40004010),
		20: uint32(0x40000000),
		21: uint32(0x00004000),
		22: uint32(0x00084010),
		23: uint32(0x40080000),
		24: uint32(0x00080010),
		25: uint32(0x40000010),
		27: uint32(0x00084000),
		28: uint32(0x00004010),
		29: uint32(0x40084000),
		30: uint32(0x40080000),
		31: uint32(0x00004010),
		33: uint32(0x00084010),
		34: uint32(0x40080010),
		35: uint32(0x00080000),
		36: uint32(0x40004010),
		37: uint32(0x40080000),
		38: uint32(0x40084000),
		39: uint32(0x00004000),
		40: uint32(0x40080000),
		41: uint32(0x40004000),
		42: uint32(0x00000010),
		43: uint32(0x40084010),
		44: uint32(0x00084010),
		45: uint32(0x00000010),
		46: uint32(0x00004000),
		47: uint32(0x40000000),
		48: uint32(0x00004010),
		49: uint32(0x40084000),
		50: uint32(0x00080000),
		51: uint32(0x40000010),
		52: uint32(0x00080010),
		53: uint32(0x40004010),
		54: uint32(0x40000010),
		55: uint32(0x00080010),
		56: uint32(0x00084000),
		58: uint32(0x40004000),
		59: uint32(0x00004010),
		60: uint32(0x40000000),
		61: uint32(0x40080010),
		62: uint32(0x40084010),
		63: uint32(0x00084000),
	},
	2: {
		0:  uint32(0x00000104),
		1:  uint32(0x04010100),
		3:  uint32(0x04010004),
		4:  uint32(0x04000100),
		6:  uint32(0x00010104),
		7:  uint32(0x04000100),
		8:  uint32(0x00010004),
		9:  uint32(0x04000004),
		10: uint32(0x04000004),
		11: uint32(0x00010000),
		12: uint32(0x04010104),
		13: uint32(0x00010004),
		14: uint32(0x04010000),
		15: uint32(0x00000104),
		16: uint32(0x04000000),
		17: uint32(0x00000004),
		18: uint32(0x04010100),
		19: uint32(0x00000100),
		20: uint32(0x00010100),
		21: uint32(0x04010000),
		22: uint32(0x04010004),
		23: uint32(0x00010104),
		24: uint32(0x04000104),
		25: uint32(0x00010100),
		26: uint32(0x00010000),
		27: uint32(0x04000104),
		28: uint32(0x00000004),
		29: uint32(0x04010104),
		30: uint32(0x00000100),
		31: uint32(0x04000000),
		32: uint32(0x04010100),
		33: uint32(0x04000000),
		34: uint32(0x00010004),
		35: uint32(0x00000104),
		36: uint32(0x00010000),
		37: uint32(0x04010100),
		38: uint32(0x04000100),
		40: uint32(0x00000100),
		41: uint32(0x00010004),
		42: uint32(0x04010104),
		43: uint32(0x04000100),
		44: uint32(0x04000004),
		45: uint32(0x00000100),
		47: uint32(0x04010004),
		48: uint32(0x04000104),
		49: uint32(0x00010000),
		50: uint32(0x04000000),
		51: uint32(0x04010104),
		52: uint32(0x00000004),
		53: uint32(0x00010104),
		54: uint32(0x00010100),
		55: uint32(0x04000004),
		56: uint32(0x04010000),
		57: uint32(0x04000104),
		58: uint32(0x00000104),
		59: uint32(0x04010000),
		60: uint32(0x00010104),
		61: uint32(0x00000004),
		62: uint32(0x04010004),
		63: uint32(0x00010100),
	},
	3: {
		0:  uint32(0x80401000),
		1:  uint32(0x80001040),
		2:  uint32(0x80001040),
		3:  uint32(0x00000040),
		4:  uint32(0x00401040),
		5:  uint32(0x80400040),
		6:  uint32(0x80400000),
		7:  uint32(0x80001000),
		9:  uint32(0x00401000),
		10: uint32(0x00401000),
		11: uint32(0x80401040),
		12: uint32(0x80000040),
		14: uint32(0x00400040),
		15: uint32(0x80400000),
		16: uint32(0x80000000),
		17: uint32(0x00001000),
		18: uint32(0x00400000),
		19: uint32(0x80401000),
		20: uint32(0x00000040),
		21: uint32(0x00400000),
		22: uint32(0x80001000),
		23: uint32(0x00001040),
		24: uint32(0x80400040),
		25: uint32(0x80000000),
		26: uint32(0x00001040),
		27: uint32(0x00400040),
		28: uint32(0x00001000),
		29: uint32(0x00401040),
		30: uint32(0x80401040),
		31: uint32(0x80000040),
		32: uint32(0x00400040),
		33: uint32(0x80400000),
		34: uint32(0x00401000),
		35: uint32(0x80401040),
		36: uint32(0x80000040),
		39: uint32(0x00401000),
		40: uint32(0x00001040),
		41: uint32(0x00400040),
		42: uint32(0x80400040),
		43: uint32(0x80000000),
		44: uint32(0x80401000),
		45: uint32(0x80001040),
		46: uint32(0x80001040),
		47: uint32(0x00000040),
		48: uint32(0x80401040),
		49: uint32(0x80000040),
		50: uint32(0x80000000),
		51: uint32(0x00001000),
		52: uint32(0x80400000),
		53: uint32(0x80001000),
		54: uint32(0x00401040),
		55: uint32(0x80400040),
		56: uint32(0x80001000),
		57: uint32(0x00001040),
		58: uint32(0x00400000),
		59: uint32(0x80401000),
		60: uint32(0x00000040),
		61: uint32(0x00400000),
		62: uint32(0x00001000),
		63: uint32(0x00401040),
	},
	4: {
		0:  uint32(0x00000080),
		1:  uint32(0x01040080),
		2:  uint32(0x01040000),
		3:  uint32(0x21000080),
		4:  uint32(0x00040000),
		5:  uint32(0x00000080),
		6:  uint32(0x20000000),
		7:  uint32(0x01040000),
		8:  uint32(0x20040080),
		9:  uint32(0x00040000),
		10: uint32(0x01000080),
		11: uint32(0x20040080),
		12: uint32(0x21000080),
		13: uint32(0x21040000),
		14: uint32(0x00040080),
		15: uint32(0x20000000),
		16: uint32(0x01000000),
		17: uint32(0x20040000),
		18: uint32(0x20040000),
		20: uint32(0x20000080),
		21: uint32(0x21040080),
		22: uint32(0x21040080),
		23: uint32(0x01000080),
		24: uint32(0x21040000),
		25: uint32(0x20000080),
		27: uint32(0x21000000),
		28: uint32(0x01040080),
		29: uint32(0x01000000),
		30: uint32(0x21000000),
		31: uint32(0x00040080),
		32: uint32(0x00040000),
		33: uint32(0x21000080),
		34: uint32(0x00000080),
		35: uint32(0x01000000),
		36: uint32(0x20000000),
		37: uint32(0x01040000),
		38: uint32(0x21000080),
		39: uint32(0x20040080),
		40: uint32(0x01000080),
		41: uint32(0x20000000),
		42: uint32(0x21040000),
		43: uint32(0x01040080),
		44: uint32(0x20040080),
		45: uint32(0x00000080),
		46: uint32(0x01000000),
		47: uint32(0x21040000),
		48: uint32(0x21040080),
		49: uint32(0x00040080),
		50: uint32(0x21000000),
		51: uint32(0x21040080),
		52: uint32(0x01040000),
		54: uint32(0x20040000),
		55: uint32(0x21000000),
		56: uint32(0x00040080),
		57: uint32(0x01000080),
		58: uint32(0x20000080),
		59: uint32(0x00040000),
		61: uint32(0x20040000),
		62: uint32(0x01040080),
		63: uint32(0x20000080),
	},
	5: {
		0:  uint32(0x10000008),
		1:  uint32(0x10200000),
		2:  uint32(0x00002000),
		3:  uint32(0x10202008),
		4:  uint32(0x10200000),
		5:  uint32(0x00000008),
		6:  uint32(0x10202008),
		7:  uint32(0x00200000),
		8:  uint32(0x10002000),
		9:  uint32(0x00202008),
		10: uint32(0x00200000),
		11: uint32(0x10000008),
		12: uint32(0x00200008),
		13: uint32(0x10002000),
		14: uint32(0x10000000),
		15: uint32(0x00002008),
		17: uint32(0x00200008),
		18: uint32(0x10002008),
		19: uint32(0x00002000),
		20: uint32(0x00202000),
		21: uint32(0x10002008),
		22: uint32(0x00000008),
		23: uint32(0x10200008),
		24: uint32(0x10200008),
		26: uint32(0x00202008),
		27: uint32(0x10202000),
		28: uint32(0x00002008),
		29: uint32(0x00202000),
		30: uint32(0x10202000),
		31: uint32(0x10000000),
		32: uint32(0x10002000),
		33: uint32(0x00000008),
		34: uint32(0x10200008),
		35: uint32(0x00202000),
		36: uint32(0x10202008),
		37: uint32(0x00200000),
		38: uint32(0x00002008),
		39: uint32(0x10000008),
		40: uint32(0x00200000),
		41: uint32(0x10002000),
		42: uint32(0x10000000),
		43: uint32(0x00002008),
		44: uint32(0x10000008),
		45: uint32(0x10202008),
		46: uint32(0x00202000),
		47: uint32(0x10200000),
		48: uint32(0x00202008),
		49: uint32(0x10202000),
		51: uint32(0x10200008),
		52: uint32(0x00000008),
		53: uint32(0x00002000),
		54: uint32(0x10200000),
		55: uint32(0x00202008),
		56: uint32(0x00002000),
		57: uint32(0x00200008),
		58: uint32(0x10002008),
		60: uint32(0x10202000),
		61: uint32(0x10000000),
		62: uint32(0x00200008),
		63: uint32(0x10002008),
	},
	6: {
		0:  uint32(0x00100000),
		1:  uint32(0x02100001),
		2:  uint32(0x02000401),
		4:  uint32(0x00000400),
		5:  uint32(0x02000401),
		6:  uint32(0x00100401),
		7:  uint32(0x02100400),
		8:  uint32(0x02100401),
		9:  uint32(0x00100000),
		11: uint32(0x02000001),
		12: uint32(0x00000001),
		13: uint32(0x02000000),
		14: uint32(0x02100001),
		15: uint32(0x00000401),
		16: uint32(0x02000400),
		17: uint32(0x00100401),
		18: uint32(0x00100001),
		19: uint32(0x02000400),
		20: uint32(0x02000001),
		21: uint32(0x02100000),
		22: uint32(0x02100400),
		23: uint32(0x00100001),
		24: uint32(0x02100000),
		25: uint32(0x00000400),
		26: uint32(0x00000401),
		27: uint32(0x02100401),
		28: uint32(0x00100400),
		29: uint32(0x00000001),
		30: uint32(0x02000000),
		31: uint32(0x00100400),
		32: uint32(0x02000000),
		33: uint32(0x00100400),
		34: uint32(0x00100000),
		35: uint32(0x02000401),
		36: uint32(0x02000401),
		37: uint32(0x02100001),
		38: uint32(0x02100001),
		39: uint32(0x00000001),
		40: uint32(0x00100001),
		41: uint32(0x02000000),
		42: uint32(0x02000400),
		43: uint32(0x00100000),
		44: uint32(0x02100400),
		45: uint32(0x00000401),
		46: uint32(0x00100401),
		47: uint32(0x02100400),
		48: uint32(0x00000401),
		49: uint32(0x02000001),
		50: uint32(0x02100401),
		51: uint32(0x02100000),
		52: uint32(0x00100400),
		54: uint32(0x00000001),
		55: uint32(0x02100401),
		57: uint32(0x00100401),
		58: uint32(0x02100000),
		59: uint32(0x00000400),
		60: uint32(0x02000001),
		61: uint32(0x02000400),
		62: uint32(0x00000400),
		63: uint32(0x00100001),
	},
	7: {
		0:  uint32(0x08000820),
		1:  uint32(0x00000800),
		2:  uint32(0x00020000),
		3:  uint32(0x08020820),
		4:  uint32(0x08000000),
		5:  uint32(0x08000820),
		6:  uint32(0x00000020),
		7:  uint32(0x08000000),
		8:  uint32(0x00020020),
		9:  uint32(0x08020000),
		10: uint32(0x08020820),
		11: uint32(0x00020800),
		12: uint32(0x08020800),
		13: uint32(0x00020820),
		14: uint32(0x00000800),
		15: uint32(0x00000020),
		16: uint32(0x08020000),
		17: uint32(0x08000020),
		18: uint32(0x08000800),
		19: uint32(0x00000820),
		20: uint32(0x00020800),
		21: uint32(0x00020020),
		22: uint32(0x08020020),
		23: uint32(0x08020800),
		24: uint32(0x00000820),
		27: uint32(0x08020020),
		28: uint32(0x08000020),
		29: uint32(0x08000800),
		30: uint32(0x00020820),
		31: uint32(0x00020000),
		32: uint32(0x00020820),
		33: uint32(0x00020000),
		34: uint32(0x08020800),
		35: uint32(0x00000800),
		36: uint32(0x00000020),
		37: uint32(0x08020020),
		38: uint32(0x00000800),
		39: uint32(0x00020820),
		40: uint32(0x08000800),
		41: uint32(0x00000020),
		42: uint32(0x08000020),
		43: uint32(0x08020000),
		44: uint32(0x08020020),
		45: uint32(0x08000000),
		46: uint32(0x00020000),
		47: uint32(0x08000820),
		49: uint32(0x08020820),
		50: uint32(0x00020020),
		51: uint32(0x08000020),
		52: uint32(0x08020000),
		53: uint32(0x08000800),
		54: uint32(0x08000820),
		56: uint32(0x08020820),
		57: uint32(0x00020800),
		58: uint32(0x00020800),
		59: uint32(0x00000820),
		60: uint32(0x00000820),
		61: uint32(0x00020020),
		62: uint32(0x08000000),
		63: uint32(0x08020800),
	},
}
var _ip_maskl = [16][16]Tuint32_t{
	0: {
		1:  uint32(0x00010000),
		3:  uint32(0x00010000),
		4:  uint32(0x01000000),
		5:  uint32(0x01010000),
		6:  uint32(0x01000000),
		7:  uint32(0x01010000),
		9:  uint32(0x00010000),
		11: uint32(0x00010000),
		12: uint32(0x01000000),
		13: uint32(0x01010000),
		14: uint32(0x01000000),
		15: uint32(0x01010000),
	},
	1: {
		1:  uint32(0x00000001),
		3:  uint32(0x00000001),
		4:  uint32(0x00000100),
		5:  uint32(0x00000101),
		6:  uint32(0x00000100),
		7:  uint32(0x00000101),
		9:  uint32(0x00000001),
		11: uint32(0x00000001),
		12: uint32(0x00000100),
		13: uint32(0x00000101),
		14: uint32(0x00000100),
		15: uint32(0x00000101),
	},
	2: {
		1:  uint32(0x00020000),
		3:  uint32(0x00020000),
		4:  uint32(0x02000000),
		5:  uint32(0x02020000),
		6:  uint32(0x02000000),
		7:  uint32(0x02020000),
		9:  uint32(0x00020000),
		11: uint32(0x00020000),
		12: uint32(0x02000000),
		13: uint32(0x02020000),
		14: uint32(0x02000000),
		15: uint32(0x02020000),
	},
	3: {
		1:  uint32(0x00000002),
		3:  uint32(0x00000002),
		4:  uint32(0x00000200),
		5:  uint32(0x00000202),
		6:  uint32(0x00000200),
		7:  uint32(0x00000202),
		9:  uint32(0x00000002),
		11: uint32(0x00000002),
		12: uint32(0x00000200),
		13: uint32(0x00000202),
		14: uint32(0x00000200),
		15: uint32(0x00000202),
	},
	4: {
		1:  uint32(0x00040000),
		3:  uint32(0x00040000),
		4:  uint32(0x04000000),
		5:  uint32(0x04040000),
		6:  uint32(0x04000000),
		7:  uint32(0x04040000),
		9:  uint32(0x00040000),
		11: uint32(0x00040000),
		12: uint32(0x04000000),
		13: uint32(0x04040000),
		14: uint32(0x04000000),
		15: uint32(0x04040000),
	},
	5: {
		1:  uint32(0x00000004),
		3:  uint32(0x00000004),
		4:  uint32(0x00000400),
		5:  uint32(0x00000404),
		6:  uint32(0x00000400),
		7:  uint32(0x00000404),
		9:  uint32(0x00000004),
		11: uint32(0x00000004),
		12: uint32(0x00000400),
		13: uint32(0x00000404),
		14: uint32(0x00000400),
		15: uint32(0x00000404),
	},
	6: {
		1:  uint32(0x00080000),
		3:  uint32(0x00080000),
		4:  uint32(0x08000000),
		5:  uint32(0x08080000),
		6:  uint32(0x08000000),
		7:  uint32(0x08080000),
		9:  uint32(0x00080000),
		11: uint32(0x00080000),
		12: uint32(0x08000000),
		13: uint32(0x08080000),
		14: uint32(0x08000000),
		15: uint32(0x08080000),
	},
	7: {
		1:  uint32(0x00000008),
		3:  uint32(0x00000008),
		4:  uint32(0x00000800),
		5:  uint32(0x00000808),
		6:  uint32(0x00000800),
		7:  uint32(0x00000808),
		9:  uint32(0x00000008),
		11: uint32(0x00000008),
		12: uint32(0x00000800),
		13: uint32(0x00000808),
		14: uint32(0x00000800),
		15: uint32(0x00000808),
	},
	8: {
		1:  uint32(0x00100000),
		3:  uint32(0x00100000),
		4:  uint32(0x10000000),
		5:  uint32(0x10100000),
		6:  uint32(0x10000000),
		7:  uint32(0x10100000),
		9:  uint32(0x00100000),
		11: uint32(0x00100000),
		12: uint32(0x10000000),
		13: uint32(0x10100000),
		14: uint32(0x10000000),
		15: uint32(0x10100000),
	},
	9: {
		1:  uint32(0x00000010),
		3:  uint32(0x00000010),
		4:  uint32(0x00001000),
		5:  uint32(0x00001010),
		6:  uint32(0x00001000),
		7:  uint32(0x00001010),
		9:  uint32(0x00000010),
		11: uint32(0x00000010),
		12: uint32(0x00001000),
		13: uint32(0x00001010),
		14: uint32(0x00001000),
		15: uint32(0x00001010),
	},
	10: {
		1:  uint32(0x00200000),
		3:  uint32(0x00200000),
		4:  uint32(0x20000000),
		5:  uint32(0x20200000),
		6:  uint32(0x20000000),
		7:  uint32(0x20200000),
		9:  uint32(0x00200000),
		11: uint32(0x00200000),
		12: uint32(0x20000000),
		13: uint32(0x20200000),
		14: uint32(0x20000000),
		15: uint32(0x20200000),
	},
	11: {
		1:  uint32(0x00000020),
		3:  uint32(0x00000020),
		4:  uint32(0x00002000),
		5:  uint32(0x00002020),
		6:  uint32(0x00002000),
		7:  uint32(0x00002020),
		9:  uint32(0x00000020),
		11: uint32(0x00000020),
		12: uint32(0x00002000),
		13: uint32(0x00002020),
		14: uint32(0x00002000),
		15: uint32(0x00002020),
	},
	12: {
		1:  uint32(0x00400000),
		3:  uint32(0x00400000),
		4:  uint32(0x40000000),
		5:  uint32(0x40400000),
		6:  uint32(0x40000000),
		7:  uint32(0x40400000),
		9:  uint32(0x00400000),
		11: uint32(0x00400000),
		12: uint32(0x40000000),
		13: uint32(0x40400000),
		14: uint32(0x40000000),
		15: uint32(0x40400000),
	},
	13: {
		1:  uint32(0x00000040),
		3:  uint32(0x00000040),
		4:  uint32(0x00004000),
		5:  uint32(0x00004040),
		6:  uint32(0x00004000),
		7:  uint32(0x00004040),
		9:  uint32(0x00000040),
		11: uint32(0x00000040),
		12: uint32(0x00004000),
		13: uint32(0x00004040),
		14: uint32(0x00004000),
		15: uint32(0x00004040),
	},
	14: {
		1:  uint32(0x00800000),
		3:  uint32(0x00800000),
		4:  uint32(0x80000000),
		5:  uint32(0x80800000),
		6:  uint32(0x80000000),
		7:  uint32(0x80800000),
		9:  uint32(0x00800000),
		11: uint32(0x00800000),
		12: uint32(0x80000000),
		13: uint32(0x80800000),
		14: uint32(0x80000000),
		15: uint32(0x80800000),
	},
	15: {
		1:  uint32(0x00000080),
		3:  uint32(0x00000080),
		4:  uint32(0x00008000),
		5:  uint32(0x00008080),
		6:  uint32(0x00008000),
		7:  uint32(0x00008080),
		9:  uint32(0x00000080),
		11: uint32(0x00000080),
		12: uint32(0x00008000),
		13: uint32(0x00008080),
		14: uint32(0x00008000),
		15: uint32(0x00008080),
	},
}
var _ip_maskr = [16][16]Tuint32_t{
	0: {
		2:  uint32(0x00010000),
		3:  uint32(0x00010000),
		6:  uint32(0x00010000),
		7:  uint32(0x00010000),
		8:  uint32(0x01000000),
		9:  uint32(0x01000000),
		10: uint32(0x01010000),
		11: uint32(0x01010000),
		12: uint32(0x01000000),
		13: uint32(0x01000000),
		14: uint32(0x01010000),
		15: uint32(0x01010000),
	},
	1: {
		2:  uint32(0x00000001),
		3:  uint32(0x00000001),
		6:  uint32(0x00000001),
		7:  uint32(0x00000001),
		8:  uint32(0x00000100),
		9:  uint32(0x00000100),
		10: uint32(0x00000101),
		11: uint32(0x00000101),
		12: uint32(0x00000100),
		13: uint32(0x00000100),
		14: uint32(0x00000101),
		15: uint32(0x00000101),
	},
	2: {
		2:  uint32(0x00020000),
		3:  uint32(0x00020000),
		6:  uint32(0x00020000),
		7:  uint32(0x00020000),
		8:  uint32(0x02000000),
		9:  uint32(0x02000000),
		10: uint32(0x02020000),
		11: uint32(0x02020000),
		12: uint32(0x02000000),
		13: uint32(0x02000000),
		14: uint32(0x02020000),
		15: uint32(0x02020000),
	},
	3: {
		2:  uint32(0x00000002),
		3:  uint32(0x00000002),
		6:  uint32(0x00000002),
		7:  uint32(0x00000002),
		8:  uint32(0x00000200),
		9:  uint32(0x00000200),
		10: uint32(0x00000202),
		11: uint32(0x00000202),
		12: uint32(0x00000200),
		13: uint32(0x00000200),
		14: uint32(0x00000202),
		15: uint32(0x00000202),
	},
	4: {
		2:  uint32(0x00040000),
		3:  uint32(0x00040000),
		6:  uint32(0x00040000),
		7:  uint32(0x00040000),
		8:  uint32(0x04000000),
		9:  uint32(0x04000000),
		10: uint32(0x04040000),
		11: uint32(0x04040000),
		12: uint32(0x04000000),
		13: uint32(0x04000000),
		14: uint32(0x04040000),
		15: uint32(0x04040000),
	},
	5: {
		2:  uint32(0x00000004),
		3:  uint32(0x00000004),
		6:  uint32(0x00000004),
		7:  uint32(0x00000004),
		8:  uint32(0x00000400),
		9:  uint32(0x00000400),
		10: uint32(0x00000404),
		11: uint32(0x00000404),
		12: uint32(0x00000400),
		13: uint32(0x00000400),
		14: uint32(0x00000404),
		15: uint32(0x00000404),
	},
	6: {
		2:  uint32(0x00080000),
		3:  uint32(0x00080000),
		6:  uint32(0x00080000),
		7:  uint32(0x00080000),
		8:  uint32(0x08000000),
		9:  uint32(0x08000000),
		10: uint32(0x08080000),
		11: uint32(0x08080000),
		12: uint32(0x08000000),
		13: uint32(0x08000000),
		14: uint32(0x08080000),
		15: uint32(0x08080000),
	},
	7: {
		2:  uint32(0x00000008),
		3:  uint32(0x00000008),
		6:  uint32(0x00000008),
		7:  uint32(0x00000008),
		8:  uint32(0x00000800),
		9:  uint32(0x00000800),
		10: uint32(0x00000808),
		11: uint32(0x00000808),
		12: uint32(0x00000800),
		13: uint32(0x00000800),
		14: uint32(0x00000808),
		15: uint32(0x00000808),
	},
	8: {
		2:  uint32(0x00100000),
		3:  uint32(0x00100000),
		6:  uint32(0x00100000),
		7:  uint32(0x00100000),
		8:  uint32(0x10000000),
		9:  uint32(0x10000000),
		10: uint32(0x10100000),
		11: uint32(0x10100000),
		12: uint32(0x10000000),
		13: uint32(0x10000000),
		14: uint32(0x10100000),
		15: uint32(0x10100000),
	},
	9: {
		2:  uint32(0x00000010),
		3:  uint32(0x00000010),
		6:  uint32(0x00000010),
		7:  uint32(0x00000010),
		8:  uint32(0x00001000),
		9:  uint32(0x00001000),
		10: uint32(0x00001010),
		11: uint32(0x00001010),
		12: uint32(0x00001000),
		13: uint32(0x00001000),
		14: uint32(0x00001010),
		15: uint32(0x00001010),
	},
	10: {
		2:  uint32(0x00200000),
		3:  uint32(0x00200000),
		6:  uint32(0x00200000),
		7:  uint32(0x00200000),
		8:  uint32(0x20000000),
		9:  uint32(0x20000000),
		10: uint32(0x20200000),
		11: uint32(0x20200000),
		12: uint32(0x20000000),
		13: uint32(0x20000000),
		14: uint32(0x20200000),
		15: uint32(0x20200000),
	},
	11: {
		2:  uint32(0x00000020),
		3:  uint32(0x00000020),
		6:  uint32(0x00000020),
		7:  uint32(0x00000020),
		8:  uint32(0x00002000),
		9:  uint32(0x00002000),
		10: uint32(0x00002020),
		11: uint32(0x00002020),
		12: uint32(0x00002000),
		13: uint32(0x00002000),
		14: uint32(0x00002020),
		15: uint32(0x00002020),
	},
	12: {
		2:  uint32(0x00400000),
		3:  uint32(0x00400000),
		6:  uint32(0x00400000),
		7:  uint32(0x00400000),
		8:  uint32(0x40000000),
		9:  uint32(0x40000000),
		10: uint32(0x40400000),
		11: uint32(0x40400000),
		12: uint32(0x40000000),
		13: uint32(0x40000000),
		14: uint32(0x40400000),
		15: uint32(0x40400000),
	},
	13: {
		2:  uint32(0x00000040),
		3:  uint32(0x00000040),
		6:  uint32(0x00000040),
		7:  uint32(0x00000040),
		8:  uint32(0x00004000),
		9:  uint32(0x00004000),
		10: uint32(0x00004040),
		11: uint32(0x00004040),
		12: uint32(0x00004000),
		13: uint32(0x00004000),
		14: uint32(0x00004040),
		15: uint32(0x00004040),
	},
	14: {
		2:  uint32(0x00800000),
		3:  uint32(0x00800000),
		6:  uint32(0x00800000),
		7:  uint32(0x00800000),
		8:  uint32(0x80000000),
		9:  uint32(0x80000000),
		10: uint32(0x80800000),
		11: uint32(0x80800000),
		12: uint32(0x80000000),
		13: uint32(0x80000000),
		14: uint32(0x80800000),
		15: uint32(0x80800000),
	},
	15: {
		2:  uint32(0x00000080),
		3:  uint32(0x00000080),
		6:  uint32(0x00000080),
		7:  uint32(0x00000080),
		8:  uint32(0x00008000),
		9:  uint32(0x00008000),
		10: uint32(0x00008080),
		11: uint32(0x00008080),
		12: uint32(0x00008000),
		13: uint32(0x00008000),
		14: uint32(0x00008080),
		15: uint32(0x00008080),
	},
}
var _fp_maskl = [8][16]Tuint32_t{
	0: {
		1:  uint32(0x40000000),
		2:  uint32(0x00400000),
		3:  uint32(0x40400000),
		4:  uint32(0x00004000),
		5:  uint32(0x40004000),
		6:  uint32(0x00404000),
		7:  uint32(0x40404000),
		8:  uint32(0x00000040),
		9:  uint32(0x40000040),
		10: uint32(0x00400040),
		11: uint32(0x40400040),
		12: uint32(0x00004040),
		13: uint32(0x40004040),
		14: uint32(0x00404040),
		15: uint32(0x40404040),
	},
	1: {
		1:  uint32(0x10000000),
		2:  uint32(0x00100000),
		3:  uint32(0x10100000),
		4:  uint32(0x00001000),
		5:  uint32(0x10001000),
		6:  uint32(0x00101000),
		7:  uint32(0x10101000),
		8:  uint32(0x00000010),
		9:  uint32(0x10000010),
		10: uint32(0x00100010),
		11: uint32(0x10100010),
		12: uint32(0x00001010),
		13: uint32(0x10001010),
		14: uint32(0x00101010),
		15: uint32(0x10101010),
	},
	2: {
		1:  uint32(0x04000000),
		2:  uint32(0x00040000),
		3:  uint32(0x04040000),
		4:  uint32(0x00000400),
		5:  uint32(0x04000400),
		6:  uint32(0x00040400),
		7:  uint32(0x04040400),
		8:  uint32(0x00000004),
		9:  uint32(0x04000004),
		10: uint32(0x00040004),
		11: uint32(0x04040004),
		12: uint32(0x00000404),
		13: uint32(0x04000404),
		14: uint32(0x00040404),
		15: uint32(0x04040404),
	},
	3: {
		1:  uint32(0x01000000),
		2:  uint32(0x00010000),
		3:  uint32(0x01010000),
		4:  uint32(0x00000100),
		5:  uint32(0x01000100),
		6:  uint32(0x00010100),
		7:  uint32(0x01010100),
		8:  uint32(0x00000001),
		9:  uint32(0x01000001),
		10: uint32(0x00010001),
		11: uint32(0x01010001),
		12: uint32(0x00000101),
		13: uint32(0x01000101),
		14: uint32(0x00010101),
		15: uint32(0x01010101),
	},
	4: {
		1:  uint32(0x80000000),
		2:  uint32(0x00800000),
		3:  uint32(0x80800000),
		4:  uint32(0x00008000),
		5:  uint32(0x80008000),
		6:  uint32(0x00808000),
		7:  uint32(0x80808000),
		8:  uint32(0x00000080),
		9:  uint32(0x80000080),
		10: uint32(0x00800080),
		11: uint32(0x80800080),
		12: uint32(0x00008080),
		13: uint32(0x80008080),
		14: uint32(0x00808080),
		15: uint32(0x80808080),
	},
	5: {
		1:  uint32(0x20000000),
		2:  uint32(0x00200000),
		3:  uint32(0x20200000),
		4:  uint32(0x00002000),
		5:  uint32(0x20002000),
		6:  uint32(0x00202000),
		7:  uint32(0x20202000),
		8:  uint32(0x00000020),
		9:  uint32(0x20000020),
		10: uint32(0x00200020),
		11: uint32(0x20200020),
		12: uint32(0x00002020),
		13: uint32(0x20002020),
		14: uint32(0x00202020),
		15: uint32(0x20202020),
	},
	6: {
		1:  uint32(0x08000000),
		2:  uint32(0x00080000),
		3:  uint32(0x08080000),
		4:  uint32(0x00000800),
		5:  uint32(0x08000800),
		6:  uint32(0x00080800),
		7:  uint32(0x08080800),
		8:  uint32(0x00000008),
		9:  uint32(0x08000008),
		10: uint32(0x00080008),
		11: uint32(0x08080008),
		12: uint32(0x00000808),
		13: uint32(0x08000808),
		14: uint32(0x00080808),
		15: uint32(0x08080808),
	},
	7: {
		1:  uint32(0x02000000),
		2:  uint32(0x00020000),
		3:  uint32(0x02020000),
		4:  uint32(0x00000200),
		5:  uint32(0x02000200),
		6:  uint32(0x00020200),
		7:  uint32(0x02020200),
		8:  uint32(0x00000002),
		9:  uint32(0x02000002),
		10: uint32(0x00020002),
		11: uint32(0x02020002),
		12: uint32(0x00000202),
		13: uint32(0x02000202),
		14: uint32(0x00020202),
		15: uint32(0x02020202),
	},
}
var _fp_maskr = [8][16]Tuint32_t{
	0: {
		1:  uint32(0x40000000),
		2:  uint32(0x00400000),
		3:  uint32(0x40400000),
		4:  uint32(0x00004000),
		5:  uint32(0x40004000),
		6:  uint32(0x00404000),
		7:  uint32(0x40404000),
		8:  uint32(0x00000040),
		9:  uint32(0x40000040),
		10: uint32(0x00400040),
		11: uint32(0x40400040),
		12: uint32(0x00004040),
		13: uint32(0x40004040),
		14: uint32(0x00404040),
		15: uint32(0x40404040),
	},
	1: {
		1:  uint32(0x10000000),
		2:  uint32(0x00100000),
		3:  uint32(0x10100000),
		4:  uint32(0x00001000),
		5:  uint32(0x10001000),
		6:  uint32(0x00101000),
		7:  uint32(0x10101000),
		8:  uint32(0x00000010),
		9:  uint32(0x10000010),
		10: uint32(0x00100010),
		11: uint32(0x10100010),
		12: uint32(0x00001010),
		13: uint32(0x10001010),
		14: uint32(0x00101010),
		15: uint32(0x10101010),
	},
	2: {
		1:  uint32(0x04000000),
		2:  uint32(0x00040000),
		3:  uint32(0x04040000),
		4:  uint32(0x00000400),
		5:  uint32(0x04000400),
		6:  uint32(0x00040400),
		7:  uint32(0x04040400),
		8:  uint32(0x00000004),
		9:  uint32(0x04000004),
		10: uint32(0x00040004),
		11: uint32(0x04040004),
		12: uint32(0x00000404),
		13: uint32(0x04000404),
		14: uint32(0x00040404),
		15: uint32(0x04040404),
	},
	3: {
		1:  uint32(0x01000000),
		2:  uint32(0x00010000),
		3:  uint32(0x01010000),
		4:  uint32(0x00000100),
		5:  uint32(0x01000100),
		6:  uint32(0x00010100),
		7:  uint32(0x01010100),
		8:  uint32(0x00000001),
		9:  uint32(0x01000001),
		10: uint32(0x00010001),
		11: uint32(0x01010001),
		12: uint32(0x00000101),
		13: uint32(0x01000101),
		14: uint32(0x00010101),
		15: uint32(0x01010101),
	},
	4: {
		1:  uint32(0x80000000),
		2:  uint32(0x00800000),
		3:  uint32(0x80800000),
		4:  uint32(0x00008000),
		5:  uint32(0x80008000),
		6:  uint32(0x00808000),
		7:  uint32(0x80808000),
		8:  uint32(0x00000080),
		9:  uint32(0x80000080),
		10: uint32(0x00800080),
		11: uint32(0x80800080),
		12: uint32(0x00008080),
		13: uint32(0x80008080),
		14: uint32(0x00808080),
		15: uint32(0x80808080),
	},
	5: {
		1:  uint32(0x20000000),
		2:  uint32(0x00200000),
		3:  uint32(0x20200000),
		4:  uint32(0x00002000),
		5:  uint32(0x20002000),
		6:  uint32(0x00202000),
		7:  uint32(0x20202000),
		8:  uint32(0x00000020),
		9:  uint32(0x20000020),
		10: uint32(0x00200020),
		11: uint32(0x20200020),
		12: uint32(0x00002020),
		13: uint32(0x20002020),
		14: uint32(0x00202020),
		15: uint32(0x20202020),
	},
	6: {
		1:  uint32(0x08000000),
		2:  uint32(0x00080000),
		3:  uint32(0x08080000),
		4:  uint32(0x00000800),
		5:  uint32(0x08000800),
		6:  uint32(0x00080800),
		7:  uint32(0x08080800),
		8:  uint32(0x00000008),
		9:  uint32(0x08000008),
		10: uint32(0x00080008),
		11: uint32(0x08080008),
		12: uint32(0x00000808),
		13: uint32(0x08000808),
		14: uint32(0x00080808),
		15: uint32(0x08080808),
	},
	7: {
		1:  uint32(0x02000000),
		2:  uint32(0x00020000),
		3:  uint32(0x02020000),
		4:  uint32(0x00000200),
		5:  uint32(0x02000200),
		6:  uint32(0x00020200),
		7:  uint32(0x02020200),
		8:  uint32(0x00000002),
		9:  uint32(0x02000002),
		10: uint32(0x00020002),
		11: uint32(0x02020002),
		12: uint32(0x00000202),
		13: uint32(0x02000202),
		14: uint32(0x00020202),
		15: uint32(0x02020202),
	},
}
var _key_perm_maskl = [8][16]Tuint32_t{
	0: {
		2:  uint32(0x00000010),
		3:  uint32(0x00000010),
		4:  uint32(0x00001000),
		5:  uint32(0x00001000),
		6:  uint32(0x00001010),
		7:  uint32(0x00001010),
		8:  uint32(0x00100000),
		9:  uint32(0x00100000),
		10: uint32(0x00100010),
		11: uint32(0x00100010),
		12: uint32(0x00101000),
		13: uint32(0x00101000),
		14: uint32(0x00101010),
		15: uint32(0x00101010),
	},
	1: {
		2:  uint32(0x00000020),
		3:  uint32(0x00000020),
		4:  uint32(0x00002000),
		5:  uint32(0x00002000),
		6:  uint32(0x00002020),
		7:  uint32(0x00002020),
		8:  uint32(0x00200000),
		9:  uint32(0x00200000),
		10: uint32(0x00200020),
		11: uint32(0x00200020),
		12: uint32(0x00202000),
		13: uint32(0x00202000),
		14: uint32(0x00202020),
		15: uint32(0x00202020),
	},
	2: {
		2:  uint32(0x00000040),
		3:  uint32(0x00000040),
		4:  uint32(0x00004000),
		5:  uint32(0x00004000),
		6:  uint32(0x00004040),
		7:  uint32(0x00004040),
		8:  uint32(0x00400000),
		9:  uint32(0x00400000),
		10: uint32(0x00400040),
		11: uint32(0x00400040),
		12: uint32(0x00404000),
		13: uint32(0x00404000),
		14: uint32(0x00404040),
		15: uint32(0x00404040),
	},
	3: {
		2:  uint32(0x00000080),
		3:  uint32(0x00000080),
		4:  uint32(0x00008000),
		5:  uint32(0x00008000),
		6:  uint32(0x00008080),
		7:  uint32(0x00008080),
		8:  uint32(0x00800000),
		9:  uint32(0x00800000),
		10: uint32(0x00800080),
		11: uint32(0x00800080),
		12: uint32(0x00808000),
		13: uint32(0x00808000),
		14: uint32(0x00808080),
		15: uint32(0x00808080),
	},
	4: {
		1:  uint32(0x00000001),
		2:  uint32(0x00000100),
		3:  uint32(0x00000101),
		4:  uint32(0x00010000),
		5:  uint32(0x00010001),
		6:  uint32(0x00010100),
		7:  uint32(0x00010101),
		8:  uint32(0x01000000),
		9:  uint32(0x01000001),
		10: uint32(0x01000100),
		11: uint32(0x01000101),
		12: uint32(0x01010000),
		13: uint32(0x01010001),
		14: uint32(0x01010100),
		15: uint32(0x01010101),
	},
	5: {
		1:  uint32(0x00000002),
		2:  uint32(0x00000200),
		3:  uint32(0x00000202),
		4:  uint32(0x00020000),
		5:  uint32(0x00020002),
		6:  uint32(0x00020200),
		7:  uint32(0x00020202),
		8:  uint32(0x02000000),
		9:  uint32(0x02000002),
		10: uint32(0x02000200),
		11: uint32(0x02000202),
		12: uint32(0x02020000),
		13: uint32(0x02020002),
		14: uint32(0x02020200),
		15: uint32(0x02020202),
	},
	6: {
		1:  uint32(0x00000004),
		2:  uint32(0x00000400),
		3:  uint32(0x00000404),
		4:  uint32(0x00040000),
		5:  uint32(0x00040004),
		6:  uint32(0x00040400),
		7:  uint32(0x00040404),
		8:  uint32(0x04000000),
		9:  uint32(0x04000004),
		10: uint32(0x04000400),
		11: uint32(0x04000404),
		12: uint32(0x04040000),
		13: uint32(0x04040004),
		14: uint32(0x04040400),
		15: uint32(0x04040404),
	},
	7: {
		1:  uint32(0x00000008),
		2:  uint32(0x00000800),
		3:  uint32(0x00000808),
		4:  uint32(0x00080000),
		5:  uint32(0x00080008),
		6:  uint32(0x00080800),
		7:  uint32(0x00080808),
		8:  uint32(0x08000000),
		9:  uint32(0x08000008),
		10: uint32(0x08000800),
		11: uint32(0x08000808),
		12: uint32(0x08080000),
		13: uint32(0x08080008),
		14: uint32(0x08080800),
		15: uint32(0x08080808),
	},
}
var _key_perm_maskr = [12][16]Tuint32_t{
	0: {
		1:  uint32(0x00000001),
		3:  uint32(0x00000001),
		5:  uint32(0x00000001),
		7:  uint32(0x00000001),
		9:  uint32(0x00000001),
		11: uint32(0x00000001),
		13: uint32(0x00000001),
		15: uint32(0x00000001),
	},
	1: {
		2:  uint32(0x00100000),
		3:  uint32(0x00100000),
		4:  uint32(0x00001000),
		5:  uint32(0x00001000),
		6:  uint32(0x00101000),
		7:  uint32(0x00101000),
		8:  uint32(0x00000010),
		9:  uint32(0x00000010),
		10: uint32(0x00100010),
		11: uint32(0x00100010),
		12: uint32(0x00001010),
		13: uint32(0x00001010),
		14: uint32(0x00101010),
		15: uint32(0x00101010),
	},
	2: {
		1:  uint32(0x00000002),
		3:  uint32(0x00000002),
		5:  uint32(0x00000002),
		7:  uint32(0x00000002),
		9:  uint32(0x00000002),
		11: uint32(0x00000002),
		13: uint32(0x00000002),
		15: uint32(0x00000002),
	},
	3: {
		2:  uint32(0x00200000),
		3:  uint32(0x00200000),
		4:  uint32(0x00002000),
		5:  uint32(0x00002000),
		6:  uint32(0x00202000),
		7:  uint32(0x00202000),
		8:  uint32(0x00000020),
		9:  uint32(0x00000020),
		10: uint32(0x00200020),
		11: uint32(0x00200020),
		12: uint32(0x00002020),
		13: uint32(0x00002020),
		14: uint32(0x00202020),
		15: uint32(0x00202020),
	},
	4: {
		1:  uint32(0x00000004),
		3:  uint32(0x00000004),
		5:  uint32(0x00000004),
		7:  uint32(0x00000004),
		9:  uint32(0x00000004),
		11: uint32(0x00000004),
		13: uint32(0x00000004),
		15: uint32(0x00000004),
	},
	5: {
		2:  uint32(0x00400000),
		3:  uint32(0x00400000),
		4:  uint32(0x00004000),
		5:  uint32(0x00004000),
		6:  uint32(0x00404000),
		7:  uint32(0x00404000),
		8:  uint32(0x00000040),
		9:  uint32(0x00000040),
		10: uint32(0x00400040),
		11: uint32(0x00400040),
		12: uint32(0x00004040),
		13: uint32(0x00004040),
		14: uint32(0x00404040),
		15: uint32(0x00404040),
	},
	6: {
		1:  uint32(0x00000008),
		3:  uint32(0x00000008),
		5:  uint32(0x00000008),
		7:  uint32(0x00000008),
		9:  uint32(0x00000008),
		11: uint32(0x00000008),
		13: uint32(0x00000008),
		15: uint32(0x00000008),
	},
	7: {
		2:  uint32(0x00800000),
		3:  uint32(0x00800000),
		4:  uint32(0x00008000),
		5:  uint32(0x00008000),
		6:  uint32(0x00808000),
		7:  uint32(0x00808000),
		8:  uint32(0x00000080),
		9:  uint32(0x00000080),
		10: uint32(0x00800080),
		11: uint32(0x00800080),
		12: uint32(0x00008080),
		13: uint32(0x00008080),
		14: uint32(0x00808080),
		15: uint32(0x00808080),
	},
	8: {
		2:  uint32(0x01000000),
		3:  uint32(0x01000000),
		4:  uint32(0x00010000),
		5:  uint32(0x00010000),
		6:  uint32(0x01010000),
		7:  uint32(0x01010000),
		8:  uint32(0x00000100),
		9:  uint32(0x00000100),
		10: uint32(0x01000100),
		11: uint32(0x01000100),
		12: uint32(0x00010100),
		13: uint32(0x00010100),
		14: uint32(0x01010100),
		15: uint32(0x01010100),
	},
	9: {
		2:  uint32(0x02000000),
		3:  uint32(0x02000000),
		4:  uint32(0x00020000),
		5:  uint32(0x00020000),
		6:  uint32(0x02020000),
		7:  uint32(0x02020000),
		8:  uint32(0x00000200),
		9:  uint32(0x00000200),
		10: uint32(0x02000200),
		11: uint32(0x02000200),
		12: uint32(0x00020200),
		13: uint32(0x00020200),
		14: uint32(0x02020200),
		15: uint32(0x02020200),
	},
	10: {
		2:  uint32(0x04000000),
		3:  uint32(0x04000000),
		4:  uint32(0x00040000),
		5:  uint32(0x00040000),
		6:  uint32(0x04040000),
		7:  uint32(0x04040000),
		8:  uint32(0x00000400),
		9:  uint32(0x00000400),
		10: uint32(0x04000400),
		11: uint32(0x04000400),
		12: uint32(0x00040400),
		13: uint32(0x00040400),
		14: uint32(0x04040400),
		15: uint32(0x04040400),
	},
	11: {
		2:  uint32(0x08000000),
		3:  uint32(0x08000000),
		4:  uint32(0x00080000),
		5:  uint32(0x00080000),
		6:  uint32(0x08080000),
		7:  uint32(0x08080000),
		8:  uint32(0x00000800),
		9:  uint32(0x00000800),
		10: uint32(0x08000800),
		11: uint32(0x08000800),
		12: uint32(0x00080800),
		13: uint32(0x00080800),
		14: uint32(0x08080800),
		15: uint32(0x08080800),
	},
}
var _comp_maskl0 = [4][8]Tuint32_t{
	0: {
		1: uint32(0x00020000),
		2: uint32(0x00000001),
		3: uint32(0x00020001),
		4: uint32(0x00080000),
		5: uint32(0x000a0000),
		6: uint32(0x00080001),
		7: uint32(0x000a0001),
	},
	1: {
		1: uint32(0x00001000),
		3: uint32(0x00001000),
		4: uint32(0x00000040),
		5: uint32(0x00001040),
		6: uint32(0x00000040),
		7: uint32(0x00001040),
	},
	2: {
		1: uint32(0x00400000),
		2: uint32(0x00000020),
		3: uint32(0x00400020),
		4: uint32(0x00008000),
		5: uint32(0x00408000),
		6: uint32(0x00008020),
		7: uint32(0x00408020),
	},
	3: {
		1: uint32(0x00100000),
		2: uint32(0x00000800),
		3: uint32(0x00100800),
		5: uint32(0x00100000),
		6: uint32(0x00000800),
		7: uint32(0x00100800),
	},
}
var _comp_maskr0 = [4][8]Tuint32_t{
	0: {
		1: uint32(0x00200000),
		2: uint32(0x00020000),
		3: uint32(0x00220000),
		4: uint32(0x00000002),
		5: uint32(0x00200002),
		6: uint32(0x00020002),
		7: uint32(0x00220002),
	},
	1: {
		2: uint32(0x00100000),
		3: uint32(0x00100000),
		4: uint32(0x00000004),
		5: uint32(0x00000004),
		6: uint32(0x00100004),
		7: uint32(0x00100004),
	},
	2: {
		1: uint32(0x00004000),
		2: uint32(0x00000800),
		3: uint32(0x00004800),
		5: uint32(0x00004000),
		6: uint32(0x00000800),
		7: uint32(0x00004800),
	},
	3: {
		1: uint32(0x00400000),
		2: uint32(0x00008000),
		3: uint32(0x00408000),
		4: uint32(0x00000008),
		5: uint32(0x00400008),
		6: uint32(0x00008008),
		7: uint32(0x00408008),
	},
}
var _comp_maskl1 = [4][16]Tuint32_t{
	0: {
		1:  uint32(0x00000010),
		2:  uint32(0x00004000),
		3:  uint32(0x00004010),
		4:  uint32(0x00040000),
		5:  uint32(0x00040010),
		6:  uint32(0x00044000),
		7:  uint32(0x00044010),
		8:  uint32(0x00000100),
		9:  uint32(0x00000110),
		10: uint32(0x00004100),
		11: uint32(0x00004110),
		12: uint32(0x00040100),
		13: uint32(0x00040110),
		14: uint32(0x00044100),
		15: uint32(0x00044110),
	},
	1: {
		1:  uint32(0x00800000),
		2:  uint32(0x00000002),
		3:  uint32(0x00800002),
		4:  uint32(0x00000200),
		5:  uint32(0x00800200),
		6:  uint32(0x00000202),
		7:  uint32(0x00800202),
		8:  uint32(0x00200000),
		9:  uint32(0x00a00000),
		10: uint32(0x00200002),
		11: uint32(0x00a00002),
		12: uint32(0x00200200),
		13: uint32(0x00a00200),
		14: uint32(0x00200202),
		15: uint32(0x00a00202),
	},
	2: {
		1:  uint32(0x00002000),
		2:  uint32(0x00000004),
		3:  uint32(0x00002004),
		4:  uint32(0x00000400),
		5:  uint32(0x00002400),
		6:  uint32(0x00000404),
		7:  uint32(0x00002404),
		9:  uint32(0x00002000),
		10: uint32(0x00000004),
		11: uint32(0x00002004),
		12: uint32(0x00000400),
		13: uint32(0x00002400),
		14: uint32(0x00000404),
		15: uint32(0x00002404),
	},
	3: {
		1:  uint32(0x00010000),
		2:  uint32(0x00000008),
		3:  uint32(0x00010008),
		4:  uint32(0x00000080),
		5:  uint32(0x00010080),
		6:  uint32(0x00000088),
		7:  uint32(0x00010088),
		9:  uint32(0x00010000),
		10: uint32(0x00000008),
		11: uint32(0x00010008),
		12: uint32(0x00000080),
		13: uint32(0x00010080),
		14: uint32(0x00000088),
		15: uint32(0x00010088),
	},
}
var _comp_maskr1 = [4][16]Tuint32_t{
	0: {
		2:  uint32(0x00000080),
		3:  uint32(0x00000080),
		4:  uint32(0x00002000),
		5:  uint32(0x00002000),
		6:  uint32(0x00002080),
		7:  uint32(0x00002080),
		8:  uint32(0x00000001),
		9:  uint32(0x00000001),
		10: uint32(0x00000081),
		11: uint32(0x00000081),
		12: uint32(0x00002001),
		13: uint32(0x00002001),
		14: uint32(0x00002081),
		15: uint32(0x00002081),
	},
	1: {
		1:  uint32(0x00000010),
		2:  uint32(0x00800000),
		3:  uint32(0x00800010),
		4:  uint32(0x00010000),
		5:  uint32(0x00010010),
		6:  uint32(0x00810000),
		7:  uint32(0x00810010),
		8:  uint32(0x00000200),
		9:  uint32(0x00000210),
		10: uint32(0x00800200),
		11: uint32(0x00800210),
		12: uint32(0x00010200),
		13: uint32(0x00010210),
		14: uint32(0x00810200),
		15: uint32(0x00810210),
	},
	2: {
		1:  uint32(0x00000400),
		2:  uint32(0x00001000),
		3:  uint32(0x00001400),
		4:  uint32(0x00080000),
		5:  uint32(0x00080400),
		6:  uint32(0x00081000),
		7:  uint32(0x00081400),
		8:  uint32(0x00000020),
		9:  uint32(0x00000420),
		10: uint32(0x00001020),
		11: uint32(0x00001420),
		12: uint32(0x00080020),
		13: uint32(0x00080420),
		14: uint32(0x00081020),
		15: uint32(0x00081420),
	},
	3: {
		1:  uint32(0x00000100),
		2:  uint32(0x00040000),
		3:  uint32(0x00040100),
		5:  uint32(0x00000100),
		6:  uint32(0x00040000),
		7:  uint32(0x00040100),
		8:  uint32(0x00000040),
		9:  uint32(0x00000140),
		10: uint32(0x00040040),
		11: uint32(0x00040140),
		12: uint32(0x00000040),
		13: uint32(0x00000140),
		14: uint32(0x00040040),
		15: uint32(0x00040140),
	},
}

var _ascii64 = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

/*   0000000000111111111122222222223333333333444444444455555555556666 */
/*   0123456789012345678901234567890123456789012345678901234567890123 */

// C documentation
//
//	/*
//	 * We match the behavior of UFC-crypt on systems where "char" is signed by
//	 * default (the majority), regardless of char's signedness on our system.
//	 */
func _ascii_to_bin(tls *TLS, ch int32) (r Tuint32_t) {
	var retval, sch, v1 int32
	_, _, _ = retval, sch, v1
	if ch < int32(0x80) {
		v1 = ch
	} else {
		v1 = -(int32(0x100) - ch)
	}
	sch = v1
	retval = sch - int32('.')
	if sch >= int32('A') {
		retval = sch - (Int32FromUint8('A') - Int32FromInt32(12))
		if sch >= int32('a') {
			retval = sch - (Int32FromUint8('a') - Int32FromInt32(38))
		}
	}
	retval &= int32(0x3f)
	return uint32(retval)
}

// C documentation
//
//	/*
//	 * When we choose to "support" invalid salts, nevertheless disallow those
//	 * containing characters that would violate the passwd file format.
//	 */
func _ascii_is_unsafe(tls *TLS, ch uint8) (r int32) {
	return BoolInt32(!(ch != 0) || int32(ch) == int32('\n') || int32(ch) == int32(':'))
}

func _setup_salt(tls *TLS, salt Tuint32_t) (r Tuint32_t) {
	var i uint32
	var obit, saltbit, saltbits Tuint32_t
	_, _, _, _ = i, obit, saltbit, saltbits
	saltbits = uint32(0)
	saltbit = uint32(1)
	obit = uint32(0x800000)
	i = uint32(0)
	for {
		if !(i < uint32(24)) {
			break
		}
		if salt&saltbit != 0 {
			saltbits |= obit
		}
		saltbit <<= uint32(1)
		obit >>= uint32(1)
		goto _1
	_1:
		;
		i++
	}
	return saltbits
}

func X__des_setkey(tls *TLS, key uintptr, ekey uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v ekey=%v, (%v:)", tls, key, ekey, origin(2))
	}
	var i, ibit, j, round, shifts uint32
	var k0, k1, kl, kr, rawkey0, rawkey1, t0, t1, v1, v4 Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, ibit, j, k0, k1, kl, kr, rawkey0, rawkey1, round, shifts, t0, t1, v1, v4
	rawkey0 = uint32(*(*uint8)(unsafe.Pointer(key + 3))) | uint32(*(*uint8)(unsafe.Pointer(key + 2)))<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(key + 1)))<<Int32FromInt32(16) | uint32(*(*uint8)(unsafe.Pointer(key)))<<Int32FromInt32(24)
	rawkey1 = uint32(*(*uint8)(unsafe.Pointer(key + 7))) | uint32(*(*uint8)(unsafe.Pointer(key + 6)))<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(key + 5)))<<Int32FromInt32(16) | uint32(*(*uint8)(unsafe.Pointer(key + 4)))<<Int32FromInt32(24)
	/*
	 * Do key permutation and split into two 28-bit subkeys.
	 */
	v1 = Uint32FromInt32(0)
	k1 = v1
	k0 = v1
	i = uint32(0)
	ibit = Uint32FromInt32(28)
	for {
		if !(i < uint32(4)) {
			break
		}
		j = i << int32(1)
		k0 |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskl)) + uintptr(i)*64 + uintptr(rawkey0>>ibit&uint32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskl)) + uintptr(i+uint32(4))*64 + uintptr(rawkey1>>ibit&uint32(0xf))*4))
		k1 |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskr)) + uintptr(j)*64 + uintptr(rawkey0>>ibit&uint32(0xf))*4))
		ibit -= uint32(4)
		k1 |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskr)) + uintptr(j+uint32(1))*64 + uintptr(rawkey0>>ibit&uint32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_key_perm_maskr)) + uintptr(i+uint32(8))*64 + uintptr(rawkey1>>ibit&uint32(0xf))*4))
		goto _2
	_2:
		;
		i++
		ibit -= uint32(4)
	}
	/*
	 * Rotate subkeys and do compression permutation.
	 */
	shifts = uint32(0)
	round = uint32(0)
	for {
		if !(round < uint32(16)) {
			break
		}
		shifts += uint32(_key_shifts[round])
		t0 = k0<<shifts | k0>>(Uint32FromInt32(28)-shifts)
		t1 = k1<<shifts | k1>>(Uint32FromInt32(28)-shifts)
		v4 = Uint32FromInt32(0)
		kr = v4
		kl = v4
		ibit = uint32(25)
		i = uint32(0)
		for {
			if !(i < uint32(4)) {
				break
			}
			kl |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_comp_maskl0)) + uintptr(i)*32 + uintptr(t0>>ibit&uint32(7))*4))
			kr |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_comp_maskr0)) + uintptr(i)*32 + uintptr(t1>>ibit&uint32(7))*4))
			ibit -= uint32(4)
			kl |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_comp_maskl1)) + uintptr(i)*64 + uintptr(t0>>ibit&uint32(0xf))*4))
			kr |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_comp_maskr1)) + uintptr(i)*64 + uintptr(t1>>ibit&uint32(0xf))*4))
			ibit -= uint32(3)
			goto _5
		_5:
			;
			i++
		}
		*(*Tuint32_t)(unsafe.Pointer(ekey + uintptr(round)*4)) = kl
		*(*Tuint32_t)(unsafe.Pointer(ekey + 64 + uintptr(round)*4)) = kr
		goto _3
	_3:
		;
		round++
	}
}

// C documentation
//
//	/*
//	 * l_in, r_in, l_out, and r_out are in pseudo-"big-endian" format.
//	 */
func X__do_des(tls *TLS, l_in Tuint32_t, r_in Tuint32_t, l_out uintptr, r_out uintptr, count Tuint32_t, saltbits Tuint32_t, ekey uintptr) {
	if __ccgo_strace {
		trc("tls=%v l_in=%v r_in=%v l_out=%v r_out=%v count=%v saltbits=%v ekey=%v, (%v:)", tls, l_in, r_in, l_out, r_out, count, saltbits, ekey, origin(2))
	}
	var f, l, lo, r, r48l, r48r, ro, v1, v3, v7 Tuint32_t
	var i, i1, ibit, ibit1, round, v4 uint32
	var kl, kr, v5, v6 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = f, i, i1, ibit, ibit1, kl, kr, l, lo, r, r48l, r48r, ro, round, v1, v3, v4, v5, v6, v7
	/*
	 * Do initial permutation (IP).
	 */
	v1 = Uint32FromInt32(0)
	r = v1
	l = v1
	if l_in|r_in != 0 {
		i = uint32(0)
		ibit = Uint32FromInt32(28)
		for {
			if !(i < uint32(8)) {
				break
			}
			l |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ip_maskl)) + uintptr(i)*64 + uintptr(l_in>>ibit&uint32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ip_maskl)) + uintptr(i+uint32(8))*64 + uintptr(r_in>>ibit&uint32(0xf))*4))
			r |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ip_maskr)) + uintptr(i)*64 + uintptr(l_in>>ibit&uint32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ip_maskr)) + uintptr(i+uint32(8))*64 + uintptr(r_in>>ibit&uint32(0xf))*4))
			goto _2
		_2:
			;
			i++
			ibit -= uint32(4)
		}
	}
	for {
		v3 = count
		count--
		if !(v3 != 0) {
			break
		}
		/*
		 * Do each round.
		 */
		round = uint32(16)
		kl = ekey
		kr = ekey + 64
		for {
			v4 = round
			round--
			if !(v4 != 0) {
				break
			}
			/*
			 * Expand R to 48 bits (simulate the E-box).
			 */
			r48l = r&uint32(0x00000001)<<int32(23) | r&uint32(0xf8000000)>>int32(9) | r&uint32(0x1f800000)>>int32(11) | r&uint32(0x01f80000)>>int32(13) | r&uint32(0x001f8000)>>int32(15)
			r48r = r&uint32(0x0001f800)<<int32(7) | r&uint32(0x00001f80)<<int32(5) | r&uint32(0x000001f8)<<int32(3) | r&uint32(0x0000001f)<<int32(1) | r&uint32(0x80000000)>>int32(31)
			/*
			 * Do salting for crypt() and friends, and
			 * XOR with the permuted key.
			 */
			f = (r48l ^ r48r) & saltbits
			v5 = kl
			kl += 4
			r48l ^= f ^ *(*Tuint32_t)(unsafe.Pointer(v5))
			v6 = kr
			kr += 4
			r48r ^= f ^ *(*Tuint32_t)(unsafe.Pointer(v6))
			/*
			 * Do S-box lookups (which shrink it back to 32 bits)
			 * and do the P-box permutation at the same time.
			 */
			f = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + uintptr(r48l>>int32(18))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + 1*256 + uintptr(r48l>>Int32FromInt32(12)&uint32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + 2*256 + uintptr(r48l>>Int32FromInt32(6)&uint32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + 3*256 + uintptr(r48l&uint32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + 4*256 + uintptr(r48r>>int32(18))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + 5*256 + uintptr(r48r>>Int32FromInt32(12)&uint32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + 6*256 + uintptr(r48r>>Int32FromInt32(6)&uint32(0x3f))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_psbox)) + 7*256 + uintptr(r48r&uint32(0x3f))*4))
			/*
			 * Now that we've permuted things, complete f().
			 */
			f ^= l
			l = r
			r = f
		}
		r = l
		l = f
	}
	/*
	 * Do final permutation (inverse of IP).
	 */
	v7 = Uint32FromInt32(0)
	ro = v7
	lo = v7
	i1 = uint32(0)
	ibit1 = Uint32FromInt32(28)
	for {
		if !(i1 < uint32(4)) {
			break
		}
		ro |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fp_maskr)) + uintptr(i1)*64 + uintptr(l>>ibit1&uint32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fp_maskr)) + uintptr(i1+uint32(4))*64 + uintptr(r>>ibit1&uint32(0xf))*4))
		ibit1 -= uint32(4)
		lo |= *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fp_maskl)) + uintptr(i1)*64 + uintptr(l>>ibit1&uint32(0xf))*4)) | *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&_fp_maskl)) + uintptr(i1+uint32(4))*64 + uintptr(r>>ibit1&uint32(0xf))*4))
		goto _8
	_8:
		;
		i1++
		ibit1 -= uint32(4)
	}
	*(*Tuint32_t)(unsafe.Pointer(l_out)) = lo
	*(*Tuint32_t)(unsafe.Pointer(r_out)) = ro
}

func _des_cipher(tls *TLS, in uintptr, out uintptr, count Tuint32_t, saltbits Tuint32_t, ekey uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var rawl, rawr Tuint32_t
	var _ /* l_out at bp+0 */ Tuint32_t
	var _ /* r_out at bp+4 */ Tuint32_t
	_, _ = rawl, rawr
	rawl = uint32(*(*uint8)(unsafe.Pointer(in + 3))) | uint32(*(*uint8)(unsafe.Pointer(in + 2)))<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(in + 1)))<<Int32FromInt32(16) | uint32(*(*uint8)(unsafe.Pointer(in)))<<Int32FromInt32(24)
	rawr = uint32(*(*uint8)(unsafe.Pointer(in + 7))) | uint32(*(*uint8)(unsafe.Pointer(in + 6)))<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(in + 5)))<<Int32FromInt32(16) | uint32(*(*uint8)(unsafe.Pointer(in + 4)))<<Int32FromInt32(24)
	X__do_des(tls, rawl, rawr, bp, bp+4, count, saltbits, ekey)
	*(*uint8)(unsafe.Pointer(out)) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(24))
	*(*uint8)(unsafe.Pointer(out + 1)) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(16))
	*(*uint8)(unsafe.Pointer(out + 2)) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(8))
	*(*uint8)(unsafe.Pointer(out + 3)) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp)))
	*(*uint8)(unsafe.Pointer(out + 4)) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(24))
	*(*uint8)(unsafe.Pointer(out + 5)) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(16))
	*(*uint8)(unsafe.Pointer(out + 6)) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(8))
	*(*uint8)(unsafe.Pointer(out + 7)) = uint8(*(*Tuint32_t)(unsafe.Pointer(bp + 4)))
}

func __crypt_extended_r_uut(tls *TLS, _key uintptr, _setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var count, l, salt, value, value1 Tuint32_t
	var i uint32
	var key, p, q, setting, v1, v10, v11, v12, v13, v14, v15, v16, v17, v5, v6, v7, v8, v9, p4 uintptr
	var _ /* ekey at bp+0 */ Texpanded_key
	var _ /* keybuf at bp+128 */ [8]uint8
	var _ /* r0 at bp+136 */ Tuint32_t
	var _ /* r1 at bp+140 */ Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = count, i, key, l, p, q, salt, setting, value, value1, v1, v10, v11, v12, v13, v14, v15, v16, v17, v5, v6, v7, v8, v9, p4
	key = _key
	setting = _setting
	/*
	 * Copy the key, shifting each character left by one bit and padding
	 * with zeroes.
	 */
	q = bp + 128
	for q <= bp+128+uintptr(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		v1 = q
		q++
		*(*uint8)(unsafe.Pointer(v1)) = uint8(int32(*(*uint8)(unsafe.Pointer(key))) << int32(1))
		if *(*uint8)(unsafe.Pointer(key)) != 0 {
			key++
		}
	}
	X__des_setkey(tls, bp+128, bp)
	if int32(*(*uint8)(unsafe.Pointer(setting))) == int32('_') {
		/*
		 * "new"-style:
		 *	setting - underscore, 4 chars of count, 4 chars of salt
		 *	key - unlimited characters
		 */
		i = uint32(1)
		count = Uint32FromInt32(0)
		for {
			if !(i < uint32(5)) {
				break
			}
			value = _ascii_to_bin(tls, int32(*(*uint8)(unsafe.Pointer(setting + uintptr(i)))))
			if int32(_ascii64[value]) != int32(*(*uint8)(unsafe.Pointer(setting + uintptr(i)))) {
				return UintptrFromInt32(0)
			}
			count |= value << ((i - uint32(1)) * uint32(6))
			goto _2
		_2:
			;
			i++
		}
		if !(count != 0) {
			return UintptrFromInt32(0)
		}
		i = uint32(5)
		salt = Uint32FromInt32(0)
		for {
			if !(i < uint32(9)) {
				break
			}
			value1 = _ascii_to_bin(tls, int32(*(*uint8)(unsafe.Pointer(setting + uintptr(i)))))
			if int32(_ascii64[value1]) != int32(*(*uint8)(unsafe.Pointer(setting + uintptr(i)))) {
				return UintptrFromInt32(0)
			}
			salt |= value1 << ((i - uint32(5)) * uint32(6))
			goto _3
		_3:
			;
			i++
		}
		for *(*uint8)(unsafe.Pointer(key)) != 0 {
			/*
			 * Encrypt the key with itself.
			 */
			_des_cipher(tls, bp+128, bp+128, uint32(1), uint32(0), bp)
			/*
			 * And XOR with the next 8 characters of the key.
			 */
			q = bp + 128
			for q <= bp+128+uintptr(Uint64FromInt64(8)-Uint64FromInt32(1)) && *(*uint8)(unsafe.Pointer(key)) != 0 {
				v5 = q
				q++
				p4 = v5
				v6 = key
				key++
				*(*uint8)(unsafe.Pointer(p4)) = uint8(int32(*(*uint8)(unsafe.Pointer(p4))) ^ int32(*(*uint8)(unsafe.Pointer(v6)))<<Int32FromInt32(1))
			}
			X__des_setkey(tls, bp+128, bp)
		}
		Xmemcpy(tls, output, setting, uint64(9))
		*(*uint8)(unsafe.Pointer(output + 9)) = uint8('\000')
		p = output + uintptr(9)
	} else {
		/*
		 * "old"-style:
		 *	setting - 2 chars of salt
		 *	key - up to 8 characters
		 */
		count = uint32(25)
		if _ascii_is_unsafe(tls, *(*uint8)(unsafe.Pointer(setting))) != 0 || _ascii_is_unsafe(tls, *(*uint8)(unsafe.Pointer(setting + 1))) != 0 {
			return UintptrFromInt32(0)
		}
		salt = _ascii_to_bin(tls, int32(*(*uint8)(unsafe.Pointer(setting + 1))))<<Int32FromInt32(6) | _ascii_to_bin(tls, int32(*(*uint8)(unsafe.Pointer(setting))))
		*(*uint8)(unsafe.Pointer(output)) = *(*uint8)(unsafe.Pointer(setting))
		*(*uint8)(unsafe.Pointer(output + 1)) = *(*uint8)(unsafe.Pointer(setting + 1))
		p = output + uintptr(2)
	}
	/*
	 * Do it.
	 */
	X__do_des(tls, uint32(0), uint32(0), bp+136, bp+140, count, _setup_salt(tls, salt), bp)
	/*
	 * Now encode the result...
	 */
	l = *(*Tuint32_t)(unsafe.Pointer(bp + 136)) >> int32(8)
	v7 = p
	p++
	*(*uint8)(unsafe.Pointer(v7)) = _ascii64[l>>Int32FromInt32(18)&uint32(0x3f)]
	v8 = p
	p++
	*(*uint8)(unsafe.Pointer(v8)) = _ascii64[l>>Int32FromInt32(12)&uint32(0x3f)]
	v9 = p
	p++
	*(*uint8)(unsafe.Pointer(v9)) = _ascii64[l>>Int32FromInt32(6)&uint32(0x3f)]
	v10 = p
	p++
	*(*uint8)(unsafe.Pointer(v10)) = _ascii64[l&uint32(0x3f)]
	l = *(*Tuint32_t)(unsafe.Pointer(bp + 136))<<Int32FromInt32(16) | *(*Tuint32_t)(unsafe.Pointer(bp + 140))>>Int32FromInt32(16)&uint32(0xffff)
	v11 = p
	p++
	*(*uint8)(unsafe.Pointer(v11)) = _ascii64[l>>Int32FromInt32(18)&uint32(0x3f)]
	v12 = p
	p++
	*(*uint8)(unsafe.Pointer(v12)) = _ascii64[l>>Int32FromInt32(12)&uint32(0x3f)]
	v13 = p
	p++
	*(*uint8)(unsafe.Pointer(v13)) = _ascii64[l>>Int32FromInt32(6)&uint32(0x3f)]
	v14 = p
	p++
	*(*uint8)(unsafe.Pointer(v14)) = _ascii64[l&uint32(0x3f)]
	l = *(*Tuint32_t)(unsafe.Pointer(bp + 140)) << int32(2)
	v15 = p
	p++
	*(*uint8)(unsafe.Pointer(v15)) = _ascii64[l>>Int32FromInt32(12)&uint32(0x3f)]
	v16 = p
	p++
	*(*uint8)(unsafe.Pointer(v16)) = _ascii64[l>>Int32FromInt32(6)&uint32(0x3f)]
	v17 = p
	p++
	*(*uint8)(unsafe.Pointer(v17)) = _ascii64[l&uint32(0x3f)]
	*(*uint8)(unsafe.Pointer(p)) = uint8(0)
	return output
}

func X__crypt_des(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v setting=%v output=%v, (%v:)", tls, key, setting, output, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var p, retval, test_hash, test_key, test_setting, v1 uintptr
	var _ /* test_buf at bp+0 */ [21]uint8
	_, _, _, _, _, _ = p, retval, test_hash, test_key, test_setting, v1
	test_key = __ccgo_ts + 72
	test_setting = __ccgo_ts + 93
	test_hash = __ccgo_ts + 103
	if int32(*(*uint8)(unsafe.Pointer(setting))) != int32('_') {
		test_setting = __ccgo_ts + 124
		test_hash = __ccgo_ts + 127
	}
	/*
	 * Hash the supplied password.
	 */
	retval = __crypt_extended_r_uut(tls, key, setting, output)
	/*
	 * Perform a quick self-test.  It is important that we make both calls
	 * to _crypt_extended_r_uut() from the same scope such that they likely
	 * use the same stack locations, which makes the second call overwrite
	 * the first call's sensitive data on the stack and makes it more
	 * likely that any alignment related issues would be detected.
	 */
	p = __crypt_extended_r_uut(tls, test_key, test_setting, bp)
	if p != 0 && !(Xstrcmp(tls, p, test_hash) != 0) && retval != 0 {
		return retval
	}
	if int32(*(*uint8)(unsafe.Pointer(setting))) == int32('*') {
		v1 = __ccgo_ts + 141
	} else {
		v1 = __ccgo_ts + 70
	}
	return v1
}

const KEY_MAX = 30000
const SALT_MAX = 8

/* public domain md5 implementation based on rfc1321 and libtomcrypt */

type Tmd5 = struct {
	Flen1 Tuint64_t
	Fh    [4]Tuint32_t
	Fbuf  [64]Tuint8_t
}

func _rol(tls *TLS, n Tuint32_t, k int32) (r Tuint32_t) {
	return n<<k | n>>(Int32FromInt32(32)-k)
}

var _tab = [64]Tuint32_t{
	0:  uint32(0xd76aa478),
	1:  uint32(0xe8c7b756),
	2:  uint32(0x242070db),
	3:  uint32(0xc1bdceee),
	4:  uint32(0xf57c0faf),
	5:  uint32(0x4787c62a),
	6:  uint32(0xa8304613),
	7:  uint32(0xfd469501),
	8:  uint32(0x698098d8),
	9:  uint32(0x8b44f7af),
	10: uint32(0xffff5bb1),
	11: uint32(0x895cd7be),
	12: uint32(0x6b901122),
	13: uint32(0xfd987193),
	14: uint32(0xa679438e),
	15: uint32(0x49b40821),
	16: uint32(0xf61e2562),
	17: uint32(0xc040b340),
	18: uint32(0x265e5a51),
	19: uint32(0xe9b6c7aa),
	20: uint32(0xd62f105d),
	21: uint32(0x02441453),
	22: uint32(0xd8a1e681),
	23: uint32(0xe7d3fbc8),
	24: uint32(0x21e1cde6),
	25: uint32(0xc33707d6),
	26: uint32(0xf4d50d87),
	27: uint32(0x455a14ed),
	28: uint32(0xa9e3e905),
	29: uint32(0xfcefa3f8),
	30: uint32(0x676f02d9),
	31: uint32(0x8d2a4c8a),
	32: uint32(0xfffa3942),
	33: uint32(0x8771f681),
	34: uint32(0x6d9d6122),
	35: uint32(0xfde5380c),
	36: uint32(0xa4beea44),
	37: uint32(0x4bdecfa9),
	38: uint32(0xf6bb4b60),
	39: uint32(0xbebfbc70),
	40: uint32(0x289b7ec6),
	41: uint32(0xeaa127fa),
	42: uint32(0xd4ef3085),
	43: uint32(0x04881d05),
	44: uint32(0xd9d4d039),
	45: uint32(0xe6db99e5),
	46: uint32(0x1fa27cf8),
	47: uint32(0xc4ac5665),
	48: uint32(0xf4292244),
	49: uint32(0x432aff97),
	50: uint32(0xab9423a7),
	51: uint32(0xfc93a039),
	52: uint32(0x655b59c3),
	53: uint32(0x8f0ccc92),
	54: uint32(0xffeff47d),
	55: uint32(0x85845dd1),
	56: uint32(0x6fa87e4f),
	57: uint32(0xfe2ce6e0),
	58: uint32(0xa3014314),
	59: uint32(0x4e0811a1),
	60: uint32(0xf7537e82),
	61: uint32(0xbd3af235),
	62: uint32(0x2ad7d2bb),
	63: uint32(0xeb86d391),
}

func _processblock(tls *TLS, s uintptr, buf uintptr) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var a, b, c, d, i Tuint32_t
	var _ /* W at bp+0 */ [16]Tuint32_t
	_, _, _, _, _ = a, b, c, d, i
	i = uint32(0)
	for {
		if !(i < uint32(16)) {
			break
		}
		(*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] = uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(uint32(4)*i))))
		*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) |= uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(uint32(4)*i+uint32(1))))) << int32(8)
		*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) |= uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(uint32(4)*i+uint32(2))))) << int32(16)
		*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) |= uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(uint32(4)*i+uint32(3))))) << int32(24)
		goto _1
	_1:
		;
		i++
	}
	a = *(*Tuint32_t)(unsafe.Pointer(s + 8))
	b = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 1*4))
	c = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 2*4))
	d = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 3*4))
	i = uint32(0)
	for i < uint32(16) {
		a += d ^ b&(c^d) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] + _tab[i]
		a = _rol(tls, a, int32(7)) + b
		i++
		d += c ^ a&(b^c) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] + _tab[i]
		d = _rol(tls, d, int32(12)) + a
		i++
		c += b ^ d&(a^b) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] + _tab[i]
		c = _rol(tls, c, int32(17)) + d
		i++
		b += a ^ c&(d^a) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[i] + _tab[i]
		b = _rol(tls, b, int32(22)) + c
		i++
	}
	for i < uint32(32) {
		a += c ^ d&(c^b) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(5)*i+uint32(1))%uint32(16)] + _tab[i]
		a = _rol(tls, a, int32(5)) + b
		i++
		d += b ^ c&(b^a) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(5)*i+uint32(1))%uint32(16)] + _tab[i]
		d = _rol(tls, d, int32(9)) + a
		i++
		c += a ^ b&(a^d) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(5)*i+uint32(1))%uint32(16)] + _tab[i]
		c = _rol(tls, c, int32(14)) + d
		i++
		b += d ^ a&(d^c) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(5)*i+uint32(1))%uint32(16)] + _tab[i]
		b = _rol(tls, b, int32(20)) + c
		i++
	}
	for i < uint32(48) {
		a += b ^ c ^ d + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(3)*i+uint32(5))%uint32(16)] + _tab[i]
		a = _rol(tls, a, int32(4)) + b
		i++
		d += a ^ b ^ c + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(3)*i+uint32(5))%uint32(16)] + _tab[i]
		d = _rol(tls, d, int32(11)) + a
		i++
		c += d ^ a ^ b + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(3)*i+uint32(5))%uint32(16)] + _tab[i]
		c = _rol(tls, c, int32(16)) + d
		i++
		b += c ^ d ^ a + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[(uint32(3)*i+uint32(5))%uint32(16)] + _tab[i]
		b = _rol(tls, b, int32(23)) + c
		i++
	}
	for i < uint32(64) {
		a += c ^ (b | ^d) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[uint32(7)*i%uint32(16)] + _tab[i]
		a = _rol(tls, a, int32(6)) + b
		i++
		d += b ^ (a | ^c) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[uint32(7)*i%uint32(16)] + _tab[i]
		d = _rol(tls, d, int32(10)) + a
		i++
		c += a ^ (d | ^b) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[uint32(7)*i%uint32(16)] + _tab[i]
		c = _rol(tls, c, int32(15)) + d
		i++
		b += d ^ (c | ^a) + (*(*[16]Tuint32_t)(unsafe.Pointer(bp)))[uint32(7)*i%uint32(16)] + _tab[i]
		b = _rol(tls, b, int32(21)) + c
		i++
	}
	*(*Tuint32_t)(unsafe.Pointer(s + 8)) += a
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 1*4)) += b
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 2*4)) += c
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 3*4)) += d
}

func _pad(tls *TLS, s uintptr) {
	var r, v1 uint32
	_, _ = r, v1
	r = uint32((*Tmd5)(unsafe.Pointer(s)).Flen1 % uint64(64))
	v1 = r
	r++
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + uintptr(v1))) = uint8(0x80)
	if r > uint32(56) {
		Xmemset(tls, s+24+uintptr(r), 0, uint64(uint32(64)-r))
		r = uint32(0)
		_processblock(tls, s, s+24)
	}
	Xmemset(tls, s+24+uintptr(r), 0, uint64(uint32(56)-r))
	*(*Tuint64_t)(unsafe.Pointer(s)) *= uint64(8)
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + 56)) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1)
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + 57)) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(8))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + 58)) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(16))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + 59)) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(24))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + 60)) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(32))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + 61)) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(40))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + 62)) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(48))
	*(*Tuint8_t)(unsafe.Pointer(s + 24 + 63)) = uint8((*Tmd5)(unsafe.Pointer(s)).Flen1 >> int32(56))
	_processblock(tls, s, s+24)
}

func _md5_init(tls *TLS, s uintptr) {
	(*Tmd5)(unsafe.Pointer(s)).Flen1 = uint64(0)
	*(*Tuint32_t)(unsafe.Pointer(s + 8)) = uint32(0x67452301)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 1*4)) = uint32(0xefcdab89)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 2*4)) = uint32(0x98badcfe)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 3*4)) = uint32(0x10325476)
}

func _md5_sum(tls *TLS, s uintptr, md uintptr) {
	var i int32
	_ = i
	_pad(tls, s)
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(4)*i))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(4)*i+int32(1)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(8))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(4)*i+int32(2)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(16))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(4)*i+int32(3)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(24))
		goto _1
	_1:
		;
		i++
	}
}

func _md5_update(tls *TLS, s uintptr, m uintptr, len1 uint64) {
	var p uintptr
	var r uint32
	_, _ = p, r
	p = m
	r = uint32((*Tmd5)(unsafe.Pointer(s)).Flen1 % uint64(64))
	*(*Tuint64_t)(unsafe.Pointer(s)) += len1
	if r != 0 {
		if len1 < uint64(uint32(64)-r) {
			Xmemcpy(tls, s+24+uintptr(r), p, len1)
			return
		}
		Xmemcpy(tls, s+24+uintptr(r), p, uint64(uint32(64)-r))
		len1 -= uint64(uint32(64) - r)
		p += uintptr(uint32(64) - r)
		_processblock(tls, s, s+24)
	}
	for {
		if !(len1 >= uint64(64)) {
			break
		}
		_processblock(tls, s, p)
		goto _1
	_1:
		;
		len1 -= uint64(64)
		p += uintptr(64)
	}
	Xmemcpy(tls, s+24, p, len1)
}

/*-
 * Copyright (c) 2003 Poul-Henning Kamp
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* key limit is not part of the original design, added for DoS protection */

var _b64 = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

func _to64(tls *TLS, s uintptr, u uint32, n int32) (r uintptr) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	for {
		n--
		v1 = n
		if !(v1 >= 0) {
			break
		}
		v2 = s
		s++
		*(*uint8)(unsafe.Pointer(v2)) = _b64[u%uint32(64)]
		u /= uint32(64)
	}
	return s
}

func _md5crypt(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var i, klen, slen uint32
	var p, salt, v5 uintptr
	var _ /* ctx at bp+0 */ Tmd5
	var _ /* md at bp+88 */ [16]uint8
	_, _, _, _, _, _ = i, klen, p, salt, slen, v5
	/* reject large keys */
	klen = uint32(Xstrnlen(tls, key, uint64(Int32FromInt32(KEY_MAX)+Int32FromInt32(1))))
	if klen > uint32(KEY_MAX) {
		return uintptr(0)
	}
	/* setting: $1$salt$ (closing $ is optional) */
	if Xstrncmp(tls, setting, __ccgo_ts+143, uint64(3)) != 0 {
		return uintptr(0)
	}
	salt = setting + uintptr(3)
	i = uint32(0)
	for {
		if !(i < uint32(SALT_MAX) && *(*uint8)(unsafe.Pointer(salt + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(salt + uintptr(i)))) != int32('$')) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	slen = i
	/* md5(key salt key) */
	_md5_init(tls, bp)
	_md5_update(tls, bp, key, uint64(klen))
	_md5_update(tls, bp, salt, uint64(slen))
	_md5_update(tls, bp, key, uint64(klen))
	_md5_sum(tls, bp, bp+88)
	/* md5(key $1$ salt repeated-md weird-key[0]-0) */
	_md5_init(tls, bp)
	_md5_update(tls, bp, key, uint64(klen))
	_md5_update(tls, bp, setting, uint64(uint32(3)+slen))
	i = klen
	for {
		if !(uint64(i) > uint64(16)) {
			break
		}
		_md5_update(tls, bp, bp+88, uint64(16))
		goto _2
	_2:
		;
		i = uint32(uint64(i) - Uint64FromInt64(16))
	}
	_md5_update(tls, bp, bp+88, uint64(i))
	(*(*[16]uint8)(unsafe.Pointer(bp + 88)))[0] = uint8(0)
	i = klen
	for {
		if !(i != 0) {
			break
		}
		if i&uint32(1) != 0 {
			_md5_update(tls, bp, bp+88, uint64(1))
		} else {
			_md5_update(tls, bp, key, uint64(1))
		}
		goto _3
	_3:
		;
		i >>= uint32(1)
	}
	_md5_sum(tls, bp, bp+88)
	/* md = f(md, key, salt) iteration */
	i = uint32(0)
	for {
		if !(i < uint32(1000)) {
			break
		}
		_md5_init(tls, bp)
		if i%uint32(2) != 0 {
			_md5_update(tls, bp, key, uint64(klen))
		} else {
			_md5_update(tls, bp, bp+88, uint64(16))
		}
		if i%uint32(3) != 0 {
			_md5_update(tls, bp, salt, uint64(slen))
		}
		if i%uint32(7) != 0 {
			_md5_update(tls, bp, key, uint64(klen))
		}
		if i%uint32(2) != 0 {
			_md5_update(tls, bp, bp+88, uint64(16))
		} else {
			_md5_update(tls, bp, key, uint64(klen))
		}
		_md5_sum(tls, bp, bp+88)
		goto _4
	_4:
		;
		i++
	}
	/* output is $1$salt$hash */
	Xmemcpy(tls, output, setting, uint64(uint32(3)+slen))
	p = output + uintptr(3) + uintptr(slen)
	v5 = p
	p++
	*(*uint8)(unsafe.Pointer(v5)) = uint8('$')
	i = uint32(0)
	for {
		if !(i < uint32(5)) {
			break
		}
		p = _to64(tls, p, uint32(int32((*(*[16]uint8)(unsafe.Pointer(bp + 88)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm)) + uintptr(i)*3))])<<int32(16)|int32((*(*[16]uint8)(unsafe.Pointer(bp + 88)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm)) + uintptr(i)*3 + 1))])<<int32(8)|int32((*(*[16]uint8)(unsafe.Pointer(bp + 88)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm)) + uintptr(i)*3 + 2))])), int32(4))
		goto _6
	_6:
		;
		i++
	}
	p = _to64(tls, p, uint32((*(*[16]uint8)(unsafe.Pointer(bp + 88)))[int32(11)]), int32(2))
	*(*uint8)(unsafe.Pointer(p)) = uint8(0)
	return output
}

var _perm = [5][3]uint8{
	0: {
		1: uint8(6),
		2: uint8(12),
	},
	1: {
		0: uint8(1),
		1: uint8(7),
		2: uint8(13),
	},
	2: {
		0: uint8(2),
		1: uint8(8),
		2: uint8(14),
	},
	3: {
		0: uint8(3),
		1: uint8(9),
		2: uint8(15),
	},
	4: {
		0: uint8(4),
		1: uint8(10),
		2: uint8(5),
	},
}

func X__crypt_md5(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v setting=%v output=%v, (%v:)", tls, key, setting, output, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var p, q uintptr
	var _ /* testbuf at bp+0 */ [64]uint8
	_, _ = p, q
	p = _md5crypt(tls, key, setting, output)
	/* self test and stack cleanup */
	q = _md5crypt(tls, uintptr(unsafe.Pointer(&_testkey)), uintptr(unsafe.Pointer(&_testsetting)), bp)
	if !(p != 0) || q != bp || Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&_testhash)), uint64(35)) != 0 {
		return __ccgo_ts + 70
	}
	return p
}

var _testkey = [18]uint8{'X', 'y', '0', '1', '@', '#', 1, 2, 128, 127, 255, 13, 10, 129, 9, ' ', '!'}

var _testsetting = [13]uint8{'$', '1', '$', 'a', 'b', 'c', 'd', '0', '1', '2', '3', '$'}

var _testhash = [35]uint8{'$', '1', '$', 'a', 'b', 'c', 'd', '0', '1', '2', '3', '$', '9', 'Q', 'c', 'g', '8', 'D', 'y', 'v', 'i', 'e', 'k', 'V', '3', 't', 'D', 'G', 'M', 'Z', 'y', 'n', 'J', '1'}

func X__crypt_r(tls *TLS, key uintptr, salt uintptr, data uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v salt=%v data=%v, (%v:)", tls, key, salt, data, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var output uintptr
	_ = output
	/* Per the crypt_r API, the caller has provided a pointer to
	 * struct crypt_data; however, this implementation does not
	 * use the structure to store any internal state, and treats
	 * it purely as a char buffer for storing the result. */
	output = data
	if int32(*(*uint8)(unsafe.Pointer(salt))) == int32('$') && *(*uint8)(unsafe.Pointer(salt + 1)) != 0 && *(*uint8)(unsafe.Pointer(salt + 2)) != 0 {
		if int32(*(*uint8)(unsafe.Pointer(salt + 1))) == int32('1') && int32(*(*uint8)(unsafe.Pointer(salt + 2))) == int32('$') {
			return X__crypt_md5(tls, key, salt, output)
		}
		if int32(*(*uint8)(unsafe.Pointer(salt + 1))) == int32('2') && int32(*(*uint8)(unsafe.Pointer(salt + 3))) == int32('$') {
			return X__crypt_blowfish(tls, key, salt, output)
		}
		if int32(*(*uint8)(unsafe.Pointer(salt + 1))) == int32('5') && int32(*(*uint8)(unsafe.Pointer(salt + 2))) == int32('$') {
			return X__crypt_sha256(tls, key, salt, output)
		}
		if int32(*(*uint8)(unsafe.Pointer(salt + 1))) == int32('6') && int32(*(*uint8)(unsafe.Pointer(salt + 2))) == int32('$') {
			return X__crypt_sha512(tls, key, salt, output)
		}
	}
	return X__crypt_des(tls, key, salt, output)
}

func Xcrypt_r(tls *TLS, key uintptr, salt uintptr, data uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v salt=%v data=%v, (%v:)", tls, key, salt, data, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__crypt_r(tls, key, salt, data)
}

const KEY_MAX1 = 256
const ROUNDS_DEFAULT = 5000
const ROUNDS_MAX = 9999999
const ROUNDS_MIN = 1000
const SALT_MAX1 = 16

/* public domain sha256 implementation based on fips180-3 */

type Tsha256 = struct {
	Flen1 Tuint64_t
	Fh    [8]Tuint32_t
	Fbuf  [64]Tuint8_t
}

func _ror(tls *TLS, n Tuint32_t, k int32) (r Tuint32_t) {
	return n>>k | n<<(Int32FromInt32(32)-k)
}

var _K = [64]Tuint32_t{
	0:  uint32(0x428a2f98),
	1:  uint32(0x71374491),
	2:  uint32(0xb5c0fbcf),
	3:  uint32(0xe9b5dba5),
	4:  uint32(0x3956c25b),
	5:  uint32(0x59f111f1),
	6:  uint32(0x923f82a4),
	7:  uint32(0xab1c5ed5),
	8:  uint32(0xd807aa98),
	9:  uint32(0x12835b01),
	10: uint32(0x243185be),
	11: uint32(0x550c7dc3),
	12: uint32(0x72be5d74),
	13: uint32(0x80deb1fe),
	14: uint32(0x9bdc06a7),
	15: uint32(0xc19bf174),
	16: uint32(0xe49b69c1),
	17: uint32(0xefbe4786),
	18: uint32(0x0fc19dc6),
	19: uint32(0x240ca1cc),
	20: uint32(0x2de92c6f),
	21: uint32(0x4a7484aa),
	22: uint32(0x5cb0a9dc),
	23: uint32(0x76f988da),
	24: uint32(0x983e5152),
	25: uint32(0xa831c66d),
	26: uint32(0xb00327c8),
	27: uint32(0xbf597fc7),
	28: uint32(0xc6e00bf3),
	29: uint32(0xd5a79147),
	30: uint32(0x06ca6351),
	31: uint32(0x14292967),
	32: uint32(0x27b70a85),
	33: uint32(0x2e1b2138),
	34: uint32(0x4d2c6dfc),
	35: uint32(0x53380d13),
	36: uint32(0x650a7354),
	37: uint32(0x766a0abb),
	38: uint32(0x81c2c92e),
	39: uint32(0x92722c85),
	40: uint32(0xa2bfe8a1),
	41: uint32(0xa81a664b),
	42: uint32(0xc24b8b70),
	43: uint32(0xc76c51a3),
	44: uint32(0xd192e819),
	45: uint32(0xd6990624),
	46: uint32(0xf40e3585),
	47: uint32(0x106aa070),
	48: uint32(0x19a4c116),
	49: uint32(0x1e376c08),
	50: uint32(0x2748774c),
	51: uint32(0x34b0bcb5),
	52: uint32(0x391c0cb3),
	53: uint32(0x4ed8aa4a),
	54: uint32(0x5b9cca4f),
	55: uint32(0x682e6ff3),
	56: uint32(0x748f82ee),
	57: uint32(0x78a5636f),
	58: uint32(0x84c87814),
	59: uint32(0x8cc70208),
	60: uint32(0x90befffa),
	61: uint32(0xa4506ceb),
	62: uint32(0xbef9a3f7),
	63: uint32(0xc67178f2),
}

func _processblock1(tls *TLS, s uintptr, buf uintptr) {
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var a, b, c, d, e, f, g, h, t1, t2 Tuint32_t
	var i int32
	var _ /* W at bp+0 */ [64]Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _ = a, b, c, d, e, f, g, h, i, t1, t2
	i = 0
	for {
		if !(i < int32(16)) {
			break
		}
		(*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i] = uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(4)*i)))) << int32(24)
		*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) |= uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(4)*i+int32(1))))) << int32(16)
		*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) |= uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(4)*i+int32(2))))) << int32(8)
		*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) |= uint32(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(4)*i+int32(3)))))
		goto _1
	_1:
		;
		i++
	}
	for {
		if !(i < int32(64)) {
			break
		}
		(*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i] = _ror(tls, (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(2)], int32(17)) ^ _ror(tls, (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(2)], int32(19)) ^ (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(2)]>>Int32FromInt32(10) + (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(7)] + (_ror(tls, (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(15)], int32(7)) ^ _ror(tls, (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(15)], int32(18)) ^ (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(15)]>>Int32FromInt32(3)) + (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i-int32(16)]
		goto _2
	_2:
		;
		i++
	}
	a = *(*Tuint32_t)(unsafe.Pointer(s + 8))
	b = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 1*4))
	c = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 2*4))
	d = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 3*4))
	e = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 4*4))
	f = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 5*4))
	g = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 6*4))
	h = *(*Tuint32_t)(unsafe.Pointer(s + 8 + 7*4))
	i = 0
	for {
		if !(i < int32(64)) {
			break
		}
		t1 = h + (_ror(tls, e, int32(6)) ^ _ror(tls, e, int32(11)) ^ _ror(tls, e, int32(25))) + (g ^ e&(f^g)) + _K[i] + (*(*[64]Tuint32_t)(unsafe.Pointer(bp)))[i]
		t2 = _ror(tls, a, int32(2)) ^ _ror(tls, a, int32(13)) ^ _ror(tls, a, int32(22)) + (a&b | c&(a|b))
		h = g
		g = f
		f = e
		e = d + t1
		d = c
		c = b
		b = a
		a = t1 + t2
		goto _3
	_3:
		;
		i++
	}
	*(*Tuint32_t)(unsafe.Pointer(s + 8)) += a
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 1*4)) += b
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 2*4)) += c
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 3*4)) += d
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 4*4)) += e
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 5*4)) += f
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 6*4)) += g
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 7*4)) += h
}

func _pad1(tls *TLS, s uintptr) {
	var r, v1 uint32
	_, _ = r, v1
	r = uint32((*Tsha256)(unsafe.Pointer(s)).Flen1 % uint64(64))
	v1 = r
	r++
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + uintptr(v1))) = uint8(0x80)
	if r > uint32(56) {
		Xmemset(tls, s+40+uintptr(r), 0, uint64(uint32(64)-r))
		r = uint32(0)
		_processblock1(tls, s, s+40)
	}
	Xmemset(tls, s+40+uintptr(r), 0, uint64(uint32(56)-r))
	*(*Tuint64_t)(unsafe.Pointer(s)) *= uint64(8)
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + 56)) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(56))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + 57)) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(48))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + 58)) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(40))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + 59)) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(32))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + 60)) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(24))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + 61)) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(16))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + 62)) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1 >> int32(8))
	*(*Tuint8_t)(unsafe.Pointer(s + 40 + 63)) = uint8((*Tsha256)(unsafe.Pointer(s)).Flen1)
	_processblock1(tls, s, s+40)
}

func _sha256_init(tls *TLS, s uintptr) {
	(*Tsha256)(unsafe.Pointer(s)).Flen1 = uint64(0)
	*(*Tuint32_t)(unsafe.Pointer(s + 8)) = uint32(0x6a09e667)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 1*4)) = uint32(0xbb67ae85)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 2*4)) = uint32(0x3c6ef372)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 3*4)) = uint32(0xa54ff53a)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 4*4)) = uint32(0x510e527f)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 5*4)) = uint32(0x9b05688c)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 6*4)) = uint32(0x1f83d9ab)
	*(*Tuint32_t)(unsafe.Pointer(s + 8 + 7*4)) = uint32(0x5be0cd19)
}

func _sha256_sum(tls *TLS, s uintptr, md uintptr) {
	var i int32
	_ = i
	_pad1(tls, s)
	i = 0
	for {
		if !(i < int32(8)) {
			break
		}
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(4)*i))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(24))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(4)*i+int32(1)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(16))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(4)*i+int32(2)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)) >> int32(8))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(4)*i+int32(3)))) = uint8(*(*Tuint32_t)(unsafe.Pointer(s + 8 + uintptr(i)*4)))
		goto _1
	_1:
		;
		i++
	}
}

func _sha256_update(tls *TLS, s uintptr, m uintptr, len1 uint64) {
	var p uintptr
	var r uint32
	_, _ = p, r
	p = m
	r = uint32((*Tsha256)(unsafe.Pointer(s)).Flen1 % uint64(64))
	*(*Tuint64_t)(unsafe.Pointer(s)) += len1
	if r != 0 {
		if len1 < uint64(uint32(64)-r) {
			Xmemcpy(tls, s+40+uintptr(r), p, len1)
			return
		}
		Xmemcpy(tls, s+40+uintptr(r), p, uint64(uint32(64)-r))
		len1 -= uint64(uint32(64) - r)
		p += uintptr(uint32(64) - r)
		_processblock1(tls, s, s+40)
	}
	for {
		if !(len1 >= uint64(64)) {
			break
		}
		_processblock1(tls, s, p)
		goto _1
	_1:
		;
		len1 -= uint64(64)
		p += uintptr(64)
	}
	Xmemcpy(tls, s+40, p, len1)
}

var _b641 = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

func _to641(tls *TLS, s uintptr, u uint32, n int32) (r uintptr) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	for {
		n--
		v1 = n
		if !(v1 >= 0) {
			break
		}
		v2 = s
		s++
		*(*uint8)(unsafe.Pointer(v2)) = _b641[u%uint32(64)]
		u /= uint32(64)
	}
	return s
}

/* key limit is not part of the original design, added for DoS protection.
 * rounds limit has been lowered (versus the reference/spec), also for DoS
 * protection. runtime is O(klen^2 + klen*rounds) */

// C documentation
//
//	/* hash n bytes of the repeated md message digest */
func _hashmd(tls *TLS, s uintptr, n uint32, md uintptr) {
	var i uint32
	_ = i
	i = n
	for {
		if !(i > uint32(32)) {
			break
		}
		_sha256_update(tls, s, md, uint64(32))
		goto _1
	_1:
		;
		i -= uint32(32)
	}
	_sha256_update(tls, s, md, uint64(i))
}

func _sha256crypt(tls *TLS, key uintptr, setting uintptr, output uintptr) (r1 uintptr) {
	bp := tls.Alloc(272)
	defer tls.Free(272)
	var i, klen, r, slen uint32
	var p, salt uintptr
	var u uint64
	var _ /* ctx at bp+0 */ Tsha256
	var _ /* end at bp+224 */ uintptr
	var _ /* kmd at bp+136 */ [32]uint8
	var _ /* md at bp+104 */ [32]uint8
	var _ /* rounds at bp+200 */ [20]uint8
	var _ /* smd at bp+168 */ [32]uint8
	_, _, _, _, _, _, _ = i, klen, p, r, salt, slen, u
	*(*[20]uint8)(unsafe.Pointer(bp + 200)) = [20]uint8{}
	/* reject large keys */
	klen = uint32(Xstrnlen(tls, key, uint64(Int32FromInt32(KEY_MAX1)+Int32FromInt32(1))))
	if klen > uint32(KEY_MAX1) {
		return uintptr(0)
	}
	/* setting: $5$rounds=n$salt$ (rounds=n$ and closing $ are optional) */
	if Xstrncmp(tls, setting, __ccgo_ts+147, uint64(3)) != 0 {
		return uintptr(0)
	}
	salt = setting + uintptr(3)
	r = uint32(ROUNDS_DEFAULT)
	if Xstrncmp(tls, salt, __ccgo_ts+151, Uint64FromInt64(8)-Uint64FromInt32(1)) == 0 {
		/*
		 * this is a deviation from the reference:
		 * bad rounds setting is rejected if it is
		 * - empty
		 * - unterminated (missing '$')
		 * - begins with anything but a decimal digit
		 * the reference implementation treats these bad
		 * rounds as part of the salt or parse them with
		 * strtoul semantics which may cause problems
		 * including non-portable hashes that depend on
		 * the host's value of ULONG_MAX.
		 */
		salt += uintptr(Uint64FromInt64(8) - Uint64FromInt32(1))
		if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(salt)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			return uintptr(0)
		}
		u = Xstrtoul(tls, salt, bp+224, int32(10))
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 224))))) != int32('$') {
			return uintptr(0)
		}
		salt = *(*uintptr)(unsafe.Pointer(bp + 224)) + uintptr(1)
		if u < uint64(ROUNDS_MIN) {
			r = uint32(ROUNDS_MIN)
		} else {
			if u > uint64(ROUNDS_MAX) {
				return uintptr(0)
			} else {
				r = uint32(u)
			}
		}
		/* needed when rounds is zero prefixed or out of bounds */
		Xsprintf(tls, bp+200, __ccgo_ts+159, VaList(bp+240, r))
	}
	i = uint32(0)
	for {
		if !(i < uint32(SALT_MAX1) && *(*uint8)(unsafe.Pointer(salt + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(salt + uintptr(i)))) != int32('$')) {
			break
		}
		/* reject characters that interfere with /etc/shadow parsing */
		if int32(*(*uint8)(unsafe.Pointer(salt + uintptr(i)))) == int32('\n') || int32(*(*uint8)(unsafe.Pointer(salt + uintptr(i)))) == int32(':') {
			return uintptr(0)
		}
		goto _1
	_1:
		;
		i++
	}
	slen = i
	/* B = sha(key salt key) */
	_sha256_init(tls, bp)
	_sha256_update(tls, bp, key, uint64(klen))
	_sha256_update(tls, bp, salt, uint64(slen))
	_sha256_update(tls, bp, key, uint64(klen))
	_sha256_sum(tls, bp, bp+104)
	/* A = sha(key salt repeat-B alternate-B-key) */
	_sha256_init(tls, bp)
	_sha256_update(tls, bp, key, uint64(klen))
	_sha256_update(tls, bp, salt, uint64(slen))
	_hashmd(tls, bp, klen, bp+104)
	i = klen
	for {
		if !(i > uint32(0)) {
			break
		}
		if i&uint32(1) != 0 {
			_sha256_update(tls, bp, bp+104, uint64(32))
		} else {
			_sha256_update(tls, bp, key, uint64(klen))
		}
		goto _2
	_2:
		;
		i >>= uint32(1)
	}
	_sha256_sum(tls, bp, bp+104)
	/* DP = sha(repeat-key), this step takes O(klen^2) time */
	_sha256_init(tls, bp)
	i = uint32(0)
	for {
		if !(i < klen) {
			break
		}
		_sha256_update(tls, bp, key, uint64(klen))
		goto _3
	_3:
		;
		i++
	}
	_sha256_sum(tls, bp, bp+136)
	/* DS = sha(repeat-salt) */
	_sha256_init(tls, bp)
	i = uint32(0)
	for {
		if !(i < uint32(int32(16)+int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[0]))) {
			break
		}
		_sha256_update(tls, bp, salt, uint64(slen))
		goto _4
	_4:
		;
		i++
	}
	_sha256_sum(tls, bp, bp+168)
	/* iterate A = f(A,DP,DS), this step takes O(rounds*klen) time */
	i = uint32(0)
	for {
		if !(i < r) {
			break
		}
		_sha256_init(tls, bp)
		if i%uint32(2) != 0 {
			_hashmd(tls, bp, klen, bp+136)
		} else {
			_sha256_update(tls, bp, bp+104, uint64(32))
		}
		if i%uint32(3) != 0 {
			_sha256_update(tls, bp, bp+168, uint64(slen))
		}
		if i%uint32(7) != 0 {
			_hashmd(tls, bp, klen, bp+136)
		}
		if i%uint32(2) != 0 {
			_sha256_update(tls, bp, bp+104, uint64(32))
		} else {
			_hashmd(tls, bp, klen, bp+136)
		}
		_sha256_sum(tls, bp, bp+104)
		goto _5
	_5:
		;
		i++
	}
	/* output is $5$rounds=n$salt$hash */
	p = output
	p += uintptr(Xsprintf(tls, p, __ccgo_ts+170, VaList(bp+240, bp+200, slen, salt)))
	i = uint32(0)
	for {
		if !(i < uint32(10)) {
			break
		}
		p = _to641(tls, p, uint32(int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm1)) + uintptr(i)*3))])<<int32(16)|int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm1)) + uintptr(i)*3 + 1))])<<int32(8)|int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm1)) + uintptr(i)*3 + 2))])), int32(4))
		goto _6
	_6:
		;
		i++
	}
	p = _to641(tls, p, uint32(int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[int32(31)])<<int32(8)|int32((*(*[32]uint8)(unsafe.Pointer(bp + 104)))[int32(30)])), int32(3))
	*(*uint8)(unsafe.Pointer(p)) = uint8(0)
	return output
}

var _perm1 = [10][3]uint8{
	0: {
		1: uint8(10),
		2: uint8(20),
	},
	1: {
		0: uint8(21),
		1: uint8(1),
		2: uint8(11),
	},
	2: {
		0: uint8(12),
		1: uint8(22),
		2: uint8(2),
	},
	3: {
		0: uint8(3),
		1: uint8(13),
		2: uint8(23),
	},
	4: {
		0: uint8(24),
		1: uint8(4),
		2: uint8(14),
	},
	5: {
		0: uint8(15),
		1: uint8(25),
		2: uint8(5),
	},
	6: {
		0: uint8(6),
		1: uint8(16),
		2: uint8(26),
	},
	7: {
		0: uint8(27),
		1: uint8(7),
		2: uint8(17),
	},
	8: {
		0: uint8(18),
		1: uint8(28),
		2: uint8(8),
	},
	9: {
		0: uint8(9),
		1: uint8(19),
		2: uint8(29),
	},
}

func X__crypt_sha256(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v setting=%v output=%v, (%v:)", tls, key, setting, output, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var p, q uintptr
	var _ /* testbuf at bp+0 */ [128]uint8
	_, _ = p, q
	p = _sha256crypt(tls, key, setting, output)
	/* self test and stack cleanup */
	q = _sha256crypt(tls, uintptr(unsafe.Pointer(&_testkey1)), uintptr(unsafe.Pointer(&_testsetting1)), bp)
	if !(p != 0) || q != bp || Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&_testhash1)), uint64(73)) != 0 {
		return __ccgo_ts + 70
	}
	return p
}

var _testkey1 = [18]uint8{'X', 'y', '0', '1', '@', '#', 1, 2, 128, 127, 255, 13, 10, 129, 9, ' ', '!'}

var _testsetting1 = [30]uint8{'$', '5', '$', 'r', 'o', 'u', 'n', 'd', 's', '=', '1', '2', '3', '4', '$', 'a', 'b', 'c', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '$'}

var _testhash1 = [73]uint8{'$', '5', '$', 'r', 'o', 'u', 'n', 'd', 's', '=', '1', '2', '3', '4', '$', 'a', 'b', 'c', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '$', '3', 'V', 'f', 'D', 'j', 'P', 't', '0', '5', 'V', 'H', 'F', 'n', '4', '7', 'C', '/', 'o', 'j', 'F', 'Z', '6', 'K', 'R', 'P', 'Y', 'r', 'O', 'j', 'j', '1', 'l', 'L', 'b', 'H', '.', 'd', 'k', 'F', '3', 'b', 'Z', '6'}

/* public domain sha512 implementation based on fips180-3 */
/* >=2^64 bits messages are not supported (about 2000 peta bytes) */

type Tsha512 = struct {
	Flen1 Tuint64_t
	Fh    [8]Tuint64_t
	Fbuf  [128]Tuint8_t
}

func _ror1(tls *TLS, n Tuint64_t, k int32) (r Tuint64_t) {
	return n>>k | n<<(Int32FromInt32(64)-k)
}

var _K1 = [80]Tuint64_t{
	0:  uint64(0x428a2f98d728ae22),
	1:  uint64(0x7137449123ef65cd),
	2:  uint64(0xb5c0fbcfec4d3b2f),
	3:  uint64(0xe9b5dba58189dbbc),
	4:  uint64(0x3956c25bf348b538),
	5:  uint64(0x59f111f1b605d019),
	6:  uint64(0x923f82a4af194f9b),
	7:  uint64(0xab1c5ed5da6d8118),
	8:  uint64(0xd807aa98a3030242),
	9:  uint64(0x12835b0145706fbe),
	10: uint64(0x243185be4ee4b28c),
	11: uint64(0x550c7dc3d5ffb4e2),
	12: uint64(0x72be5d74f27b896f),
	13: uint64(0x80deb1fe3b1696b1),
	14: uint64(0x9bdc06a725c71235),
	15: uint64(0xc19bf174cf692694),
	16: uint64(0xe49b69c19ef14ad2),
	17: uint64(0xefbe4786384f25e3),
	18: uint64(0x0fc19dc68b8cd5b5),
	19: uint64(0x240ca1cc77ac9c65),
	20: uint64(0x2de92c6f592b0275),
	21: uint64(0x4a7484aa6ea6e483),
	22: uint64(0x5cb0a9dcbd41fbd4),
	23: uint64(0x76f988da831153b5),
	24: uint64(0x983e5152ee66dfab),
	25: uint64(0xa831c66d2db43210),
	26: uint64(0xb00327c898fb213f),
	27: uint64(0xbf597fc7beef0ee4),
	28: uint64(0xc6e00bf33da88fc2),
	29: uint64(0xd5a79147930aa725),
	30: uint64(0x06ca6351e003826f),
	31: uint64(0x142929670a0e6e70),
	32: uint64(0x27b70a8546d22ffc),
	33: uint64(0x2e1b21385c26c926),
	34: uint64(0x4d2c6dfc5ac42aed),
	35: uint64(0x53380d139d95b3df),
	36: uint64(0x650a73548baf63de),
	37: uint64(0x766a0abb3c77b2a8),
	38: uint64(0x81c2c92e47edaee6),
	39: uint64(0x92722c851482353b),
	40: uint64(0xa2bfe8a14cf10364),
	41: uint64(0xa81a664bbc423001),
	42: uint64(0xc24b8b70d0f89791),
	43: uint64(0xc76c51a30654be30),
	44: uint64(0xd192e819d6ef5218),
	45: uint64(0xd69906245565a910),
	46: uint64(0xf40e35855771202a),
	47: uint64(0x106aa07032bbd1b8),
	48: uint64(0x19a4c116b8d2d0c8),
	49: uint64(0x1e376c085141ab53),
	50: uint64(0x2748774cdf8eeb99),
	51: uint64(0x34b0bcb5e19b48a8),
	52: uint64(0x391c0cb3c5c95a63),
	53: uint64(0x4ed8aa4ae3418acb),
	54: uint64(0x5b9cca4f7763e373),
	55: uint64(0x682e6ff3d6b2b8a3),
	56: uint64(0x748f82ee5defb2fc),
	57: uint64(0x78a5636f43172f60),
	58: uint64(0x84c87814a1f0ab72),
	59: uint64(0x8cc702081a6439ec),
	60: uint64(0x90befffa23631e28),
	61: uint64(0xa4506cebde82bde9),
	62: uint64(0xbef9a3f7b2c67915),
	63: uint64(0xc67178f2e372532b),
	64: uint64(0xca273eceea26619c),
	65: uint64(0xd186b8c721c0c207),
	66: uint64(0xeada7dd6cde0eb1e),
	67: uint64(0xf57d4f7fee6ed178),
	68: uint64(0x06f067aa72176fba),
	69: uint64(0x0a637dc5a2c898a6),
	70: uint64(0x113f9804bef90dae),
	71: uint64(0x1b710b35131c471b),
	72: uint64(0x28db77f523047d84),
	73: uint64(0x32caab7b40c72493),
	74: uint64(0x3c9ebe0a15c9bebc),
	75: uint64(0x431d67c49c100d4c),
	76: uint64(0x4cc5d4becb3e42b6),
	77: uint64(0x597f299cfc657e2a),
	78: uint64(0x5fcb6fab3ad6faec),
	79: uint64(0x6c44198c4a475817),
}

func _processblock2(tls *TLS, s uintptr, buf uintptr) {
	bp := tls.Alloc(640)
	defer tls.Free(640)
	var a, b, c, d, e, f, g, h, t1, t2 Tuint64_t
	var i int32
	var _ /* W at bp+0 */ [80]Tuint64_t
	_, _, _, _, _, _, _, _, _, _, _ = a, b, c, d, e, f, g, h, i, t1, t2
	i = 0
	for {
		if !(i < int32(16)) {
			break
		}
		(*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i] = uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(8)*i)))) << int32(56)
		*(*Tuint64_t)(unsafe.Pointer(bp + uintptr(i)*8)) |= uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(8)*i+int32(1))))) << int32(48)
		*(*Tuint64_t)(unsafe.Pointer(bp + uintptr(i)*8)) |= uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(8)*i+int32(2))))) << int32(40)
		*(*Tuint64_t)(unsafe.Pointer(bp + uintptr(i)*8)) |= uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(8)*i+int32(3))))) << int32(32)
		*(*Tuint64_t)(unsafe.Pointer(bp + uintptr(i)*8)) |= uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(8)*i+int32(4))))) << int32(24)
		*(*Tuint64_t)(unsafe.Pointer(bp + uintptr(i)*8)) |= uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(8)*i+int32(5))))) << int32(16)
		*(*Tuint64_t)(unsafe.Pointer(bp + uintptr(i)*8)) |= uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(8)*i+int32(6))))) << int32(8)
		*(*Tuint64_t)(unsafe.Pointer(bp + uintptr(i)*8)) |= uint64(*(*Tuint8_t)(unsafe.Pointer(buf + uintptr(int32(8)*i+int32(7)))))
		goto _1
	_1:
		;
		i++
	}
	for {
		if !(i < int32(80)) {
			break
		}
		(*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i] = _ror1(tls, (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(2)], int32(19)) ^ _ror1(tls, (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(2)], int32(61)) ^ (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(2)]>>Int32FromInt32(6) + (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(7)] + (_ror1(tls, (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(15)], int32(1)) ^ _ror1(tls, (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(15)], int32(8)) ^ (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(15)]>>Int32FromInt32(7)) + (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i-int32(16)]
		goto _2
	_2:
		;
		i++
	}
	a = *(*Tuint64_t)(unsafe.Pointer(s + 8))
	b = *(*Tuint64_t)(unsafe.Pointer(s + 8 + 1*8))
	c = *(*Tuint64_t)(unsafe.Pointer(s + 8 + 2*8))
	d = *(*Tuint64_t)(unsafe.Pointer(s + 8 + 3*8))
	e = *(*Tuint64_t)(unsafe.Pointer(s + 8 + 4*8))
	f = *(*Tuint64_t)(unsafe.Pointer(s + 8 + 5*8))
	g = *(*Tuint64_t)(unsafe.Pointer(s + 8 + 6*8))
	h = *(*Tuint64_t)(unsafe.Pointer(s + 8 + 7*8))
	i = 0
	for {
		if !(i < int32(80)) {
			break
		}
		t1 = h + (_ror1(tls, e, int32(14)) ^ _ror1(tls, e, int32(18)) ^ _ror1(tls, e, int32(41))) + (g ^ e&(f^g)) + _K1[i] + (*(*[80]Tuint64_t)(unsafe.Pointer(bp)))[i]
		t2 = _ror1(tls, a, int32(28)) ^ _ror1(tls, a, int32(34)) ^ _ror1(tls, a, int32(39)) + (a&b | c&(a|b))
		h = g
		g = f
		f = e
		e = d + t1
		d = c
		c = b
		b = a
		a = t1 + t2
		goto _3
	_3:
		;
		i++
	}
	*(*Tuint64_t)(unsafe.Pointer(s + 8)) += a
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 1*8)) += b
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 2*8)) += c
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 3*8)) += d
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 4*8)) += e
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 5*8)) += f
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 6*8)) += g
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 7*8)) += h
}

func _pad2(tls *TLS, s uintptr) {
	var r, v1 uint32
	_, _ = r, v1
	r = uint32((*Tsha512)(unsafe.Pointer(s)).Flen1 % uint64(128))
	v1 = r
	r++
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + uintptr(v1))) = uint8(0x80)
	if r > uint32(112) {
		Xmemset(tls, s+72+uintptr(r), 0, uint64(uint32(128)-r))
		r = uint32(0)
		_processblock2(tls, s, s+72)
	}
	Xmemset(tls, s+72+uintptr(r), 0, uint64(uint32(120)-r))
	*(*Tuint64_t)(unsafe.Pointer(s)) *= uint64(8)
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + 120)) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(56))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + 121)) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(48))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + 122)) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(40))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + 123)) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(32))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + 124)) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(24))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + 125)) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(16))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + 126)) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1 >> int32(8))
	*(*Tuint8_t)(unsafe.Pointer(s + 72 + 127)) = uint8((*Tsha512)(unsafe.Pointer(s)).Flen1)
	_processblock2(tls, s, s+72)
}

func _sha512_init(tls *TLS, s uintptr) {
	(*Tsha512)(unsafe.Pointer(s)).Flen1 = uint64(0)
	*(*Tuint64_t)(unsafe.Pointer(s + 8)) = uint64(0x6a09e667f3bcc908)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 1*8)) = uint64(0xbb67ae8584caa73b)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 2*8)) = uint64(0x3c6ef372fe94f82b)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 3*8)) = uint64(0xa54ff53a5f1d36f1)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 4*8)) = uint64(0x510e527fade682d1)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 5*8)) = uint64(0x9b05688c2b3e6c1f)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 6*8)) = uint64(0x1f83d9abfb41bd6b)
	*(*Tuint64_t)(unsafe.Pointer(s + 8 + 7*8)) = uint64(0x5be0cd19137e2179)
}

func _sha512_sum(tls *TLS, s uintptr, md uintptr) {
	var i int32
	_ = i
	_pad2(tls, s)
	i = 0
	for {
		if !(i < int32(8)) {
			break
		}
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(8)*i))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(56))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(8)*i+int32(1)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(48))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(8)*i+int32(2)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(40))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(8)*i+int32(3)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(32))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(8)*i+int32(4)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(24))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(8)*i+int32(5)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(16))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(8)*i+int32(6)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)) >> int32(8))
		*(*Tuint8_t)(unsafe.Pointer(md + uintptr(int32(8)*i+int32(7)))) = uint8(*(*Tuint64_t)(unsafe.Pointer(s + 8 + uintptr(i)*8)))
		goto _1
	_1:
		;
		i++
	}
}

func _sha512_update(tls *TLS, s uintptr, m uintptr, len1 uint64) {
	var p uintptr
	var r uint32
	_, _ = p, r
	p = m
	r = uint32((*Tsha512)(unsafe.Pointer(s)).Flen1 % uint64(128))
	*(*Tuint64_t)(unsafe.Pointer(s)) += len1
	if r != 0 {
		if len1 < uint64(uint32(128)-r) {
			Xmemcpy(tls, s+72+uintptr(r), p, len1)
			return
		}
		Xmemcpy(tls, s+72+uintptr(r), p, uint64(uint32(128)-r))
		len1 -= uint64(uint32(128) - r)
		p += uintptr(uint32(128) - r)
		_processblock2(tls, s, s+72)
	}
	for {
		if !(len1 >= uint64(128)) {
			break
		}
		_processblock2(tls, s, p)
		goto _1
	_1:
		;
		len1 -= uint64(128)
		p += uintptr(128)
	}
	Xmemcpy(tls, s+72, p, len1)
}

var _b642 = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

func _to642(tls *TLS, s uintptr, u uint32, n int32) (r uintptr) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	for {
		n--
		v1 = n
		if !(v1 >= 0) {
			break
		}
		v2 = s
		s++
		*(*uint8)(unsafe.Pointer(v2)) = _b642[u%uint32(64)]
		u /= uint32(64)
	}
	return s
}

/* key limit is not part of the original design, added for DoS protection.
 * rounds limit has been lowered (versus the reference/spec), also for DoS
 * protection. runtime is O(klen^2 + klen*rounds) */

// C documentation
//
//	/* hash n bytes of the repeated md message digest */
func _hashmd1(tls *TLS, s uintptr, n uint32, md uintptr) {
	var i uint32
	_ = i
	i = n
	for {
		if !(i > uint32(64)) {
			break
		}
		_sha512_update(tls, s, md, uint64(64))
		goto _1
	_1:
		;
		i -= uint32(64)
	}
	_sha512_update(tls, s, md, uint64(i))
}

func _sha512crypt(tls *TLS, key uintptr, setting uintptr, output uintptr) (r1 uintptr) {
	bp := tls.Alloc(464)
	defer tls.Free(464)
	var i, klen, r, slen uint32
	var p, salt uintptr
	var u uint64
	var _ /* ctx at bp+0 */ Tsha512
	var _ /* end at bp+416 */ uintptr
	var _ /* kmd at bp+264 */ [64]uint8
	var _ /* md at bp+200 */ [64]uint8
	var _ /* rounds at bp+392 */ [20]uint8
	var _ /* smd at bp+328 */ [64]uint8
	_, _, _, _, _, _, _ = i, klen, p, r, salt, slen, u
	*(*[20]uint8)(unsafe.Pointer(bp + 392)) = [20]uint8{}
	/* reject large keys */
	i = uint32(0)
	for {
		if !(i <= uint32(KEY_MAX1) && *(*uint8)(unsafe.Pointer(key + uintptr(i))) != 0) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	if i > uint32(KEY_MAX1) {
		return uintptr(0)
	}
	klen = i
	/* setting: $6$rounds=n$salt$ (rounds=n$ and closing $ are optional) */
	if Xstrncmp(tls, setting, __ccgo_ts+181, uint64(3)) != 0 {
		return uintptr(0)
	}
	salt = setting + uintptr(3)
	r = uint32(ROUNDS_DEFAULT)
	if Xstrncmp(tls, salt, __ccgo_ts+151, Uint64FromInt64(8)-Uint64FromInt32(1)) == 0 {
		/*
		 * this is a deviation from the reference:
		 * bad rounds setting is rejected if it is
		 * - empty
		 * - unterminated (missing '$')
		 * - begins with anything but a decimal digit
		 * the reference implementation treats these bad
		 * rounds as part of the salt or parse them with
		 * strtoul semantics which may cause problems
		 * including non-portable hashes that depend on
		 * the host's value of ULONG_MAX.
		 */
		salt += uintptr(Uint64FromInt64(8) - Uint64FromInt32(1))
		if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(salt)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			return uintptr(0)
		}
		u = Xstrtoul(tls, salt, bp+416, int32(10))
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 416))))) != int32('$') {
			return uintptr(0)
		}
		salt = *(*uintptr)(unsafe.Pointer(bp + 416)) + uintptr(1)
		if u < uint64(ROUNDS_MIN) {
			r = uint32(ROUNDS_MIN)
		} else {
			if u > uint64(ROUNDS_MAX) {
				return uintptr(0)
			} else {
				r = uint32(u)
			}
		}
		/* needed when rounds is zero prefixed or out of bounds */
		Xsprintf(tls, bp+392, __ccgo_ts+159, VaList(bp+432, r))
	}
	i = uint32(0)
	for {
		if !(i < uint32(SALT_MAX1) && *(*uint8)(unsafe.Pointer(salt + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(salt + uintptr(i)))) != int32('$')) {
			break
		}
		/* reject characters that interfere with /etc/shadow parsing */
		if int32(*(*uint8)(unsafe.Pointer(salt + uintptr(i)))) == int32('\n') || int32(*(*uint8)(unsafe.Pointer(salt + uintptr(i)))) == int32(':') {
			return uintptr(0)
		}
		goto _2
	_2:
		;
		i++
	}
	slen = i
	/* B = sha(key salt key) */
	_sha512_init(tls, bp)
	_sha512_update(tls, bp, key, uint64(klen))
	_sha512_update(tls, bp, salt, uint64(slen))
	_sha512_update(tls, bp, key, uint64(klen))
	_sha512_sum(tls, bp, bp+200)
	/* A = sha(key salt repeat-B alternate-B-key) */
	_sha512_init(tls, bp)
	_sha512_update(tls, bp, key, uint64(klen))
	_sha512_update(tls, bp, salt, uint64(slen))
	_hashmd1(tls, bp, klen, bp+200)
	i = klen
	for {
		if !(i > uint32(0)) {
			break
		}
		if i&uint32(1) != 0 {
			_sha512_update(tls, bp, bp+200, uint64(64))
		} else {
			_sha512_update(tls, bp, key, uint64(klen))
		}
		goto _3
	_3:
		;
		i >>= uint32(1)
	}
	_sha512_sum(tls, bp, bp+200)
	/* DP = sha(repeat-key), this step takes O(klen^2) time */
	_sha512_init(tls, bp)
	i = uint32(0)
	for {
		if !(i < klen) {
			break
		}
		_sha512_update(tls, bp, key, uint64(klen))
		goto _4
	_4:
		;
		i++
	}
	_sha512_sum(tls, bp, bp+264)
	/* DS = sha(repeat-salt) */
	_sha512_init(tls, bp)
	i = uint32(0)
	for {
		if !(i < uint32(int32(16)+int32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[0]))) {
			break
		}
		_sha512_update(tls, bp, salt, uint64(slen))
		goto _5
	_5:
		;
		i++
	}
	_sha512_sum(tls, bp, bp+328)
	/* iterate A = f(A,DP,DS), this step takes O(rounds*klen) time */
	i = uint32(0)
	for {
		if !(i < r) {
			break
		}
		_sha512_init(tls, bp)
		if i%uint32(2) != 0 {
			_hashmd1(tls, bp, klen, bp+264)
		} else {
			_sha512_update(tls, bp, bp+200, uint64(64))
		}
		if i%uint32(3) != 0 {
			_sha512_update(tls, bp, bp+328, uint64(slen))
		}
		if i%uint32(7) != 0 {
			_hashmd1(tls, bp, klen, bp+264)
		}
		if i%uint32(2) != 0 {
			_sha512_update(tls, bp, bp+200, uint64(64))
		} else {
			_hashmd1(tls, bp, klen, bp+264)
		}
		_sha512_sum(tls, bp, bp+200)
		goto _6
	_6:
		;
		i++
	}
	/* output is $6$rounds=n$salt$hash */
	p = output
	p += uintptr(Xsprintf(tls, p, __ccgo_ts+185, VaList(bp+432, bp+392, slen, salt)))
	i = uint32(0)
	for {
		if !(i < uint32(21)) {
			break
		}
		p = _to642(tls, p, uint32(int32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm2)) + uintptr(i)*3))])<<int32(16)|int32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm2)) + uintptr(i)*3 + 1))])<<int32(8)|int32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_perm2)) + uintptr(i)*3 + 2))])), int32(4))
		goto _7
	_7:
		;
		i++
	}
	p = _to642(tls, p, uint32((*(*[64]uint8)(unsafe.Pointer(bp + 200)))[int32(63)]), int32(2))
	*(*uint8)(unsafe.Pointer(p)) = uint8(0)
	return output
}

var _perm2 = [21][3]uint8{
	0: {
		1: uint8(21),
		2: uint8(42),
	},
	1: {
		0: uint8(22),
		1: uint8(43),
		2: uint8(1),
	},
	2: {
		0: uint8(44),
		1: uint8(2),
		2: uint8(23),
	},
	3: {
		0: uint8(3),
		1: uint8(24),
		2: uint8(45),
	},
	4: {
		0: uint8(25),
		1: uint8(46),
		2: uint8(4),
	},
	5: {
		0: uint8(47),
		1: uint8(5),
		2: uint8(26),
	},
	6: {
		0: uint8(6),
		1: uint8(27),
		2: uint8(48),
	},
	7: {
		0: uint8(28),
		1: uint8(49),
		2: uint8(7),
	},
	8: {
		0: uint8(50),
		1: uint8(8),
		2: uint8(29),
	},
	9: {
		0: uint8(9),
		1: uint8(30),
		2: uint8(51),
	},
	10: {
		0: uint8(31),
		1: uint8(52),
		2: uint8(10),
	},
	11: {
		0: uint8(53),
		1: uint8(11),
		2: uint8(32),
	},
	12: {
		0: uint8(12),
		1: uint8(33),
		2: uint8(54),
	},
	13: {
		0: uint8(34),
		1: uint8(55),
		2: uint8(13),
	},
	14: {
		0: uint8(56),
		1: uint8(14),
		2: uint8(35),
	},
	15: {
		0: uint8(15),
		1: uint8(36),
		2: uint8(57),
	},
	16: {
		0: uint8(37),
		1: uint8(58),
		2: uint8(16),
	},
	17: {
		0: uint8(59),
		1: uint8(17),
		2: uint8(38),
	},
	18: {
		0: uint8(18),
		1: uint8(39),
		2: uint8(60),
	},
	19: {
		0: uint8(40),
		1: uint8(61),
		2: uint8(19),
	},
	20: {
		0: uint8(62),
		1: uint8(20),
		2: uint8(41),
	},
}

func X__crypt_sha512(tls *TLS, key uintptr, setting uintptr, output uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v setting=%v output=%v, (%v:)", tls, key, setting, output, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var p, q uintptr
	var _ /* testbuf at bp+0 */ [128]uint8
	_, _ = p, q
	p = _sha512crypt(tls, key, setting, output)
	/* self test and stack cleanup */
	q = _sha512crypt(tls, uintptr(unsafe.Pointer(&_testkey2)), uintptr(unsafe.Pointer(&_testsetting2)), bp)
	if !(p != 0) || q != bp || Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&_testhash2)), uint64(116)) != 0 {
		return __ccgo_ts + 70
	}
	return p
}

var _testkey2 = [18]uint8{'X', 'y', '0', '1', '@', '#', 1, 2, 128, 127, 255, 13, 10, 129, 9, ' ', '!'}

var _testsetting2 = [30]uint8{'$', '6', '$', 'r', 'o', 'u', 'n', 'd', 's', '=', '1', '2', '3', '4', '$', 'a', 'b', 'c', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '$'}

var _testhash2 = [116]uint8{'$', '6', '$', 'r', 'o', 'u', 'n', 'd', 's', '=', '1', '2', '3', '4', '$', 'a', 'b', 'c', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '$', 'B', 'C', 'p', 't', '8', 'z', 'L', 'r', 'c', '/', 'R', 'c', 'y', 'u', 'X', 'm', 'C', 'D', 'O', 'E', '1', 'A', 'L', 'q', 'M', 'X', 'B', '2', 'M', 'H', '6', 'n', '1', 'g', '8', '9', '1', 'H', 'h', 'F', 'j', '8', '.', 'w', '7', 'L', 'x', 'G', 'v', '.', 'F', 'T', 'k', 'q', 'q', '6', 'V', 'x', 'c', '/', 'k', 'm', '3', 'Y', '0', 'j', 'E', '0', 'j', '2', '4', 'j', 'Y', '5', 'P', 'I', 'v', '/', 'o', 'O', 'u', '6', 'r', 'e', 'g', '1'}

var ___encrypt_key Texpanded_key

func Xsetkey(tls *TLS, key uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v, (%v:)", tls, key, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, j int32
	var p3 uintptr
	var _ /* bkey at bp+0 */ [8]uint8
	_, _, _ = i, j, p3
	i = 0
	for {
		if !(i < int32(8)) {
			break
		}
		(*(*[8]uint8)(unsafe.Pointer(bp)))[i] = uint8(0)
		j = int32(7)
		for {
			if !(j >= 0) {
				break
			}
			p3 = bp + uintptr(i)
			*(*uint8)(unsafe.Pointer(p3)) = uint8(uint32(*(*uint8)(unsafe.Pointer(p3))) | uint32(int32(*(*uint8)(unsafe.Pointer(key)))&Int32FromInt32(1))<<j)
			goto _2
		_2:
			;
			j--
			key++
		}
		goto _1
	_1:
		;
		i++
	}
	X__des_setkey(tls, bp, uintptr(unsafe.Pointer(&___encrypt_key)))
}

func Xencrypt(tls *TLS, block uintptr, edflag int32) {
	if __ccgo_strace {
		trc("tls=%v block=%v edflag=%v, (%v:)", tls, block, edflag, origin(2))
	}
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var i, j int32
	var key, p, v6 uintptr
	var _ /* b at bp+128 */ [2]Tuint32_t
	var _ /* decrypt_key at bp+0 */ Texpanded_key
	_, _, _, _, _ = i, j, key, p, v6
	p = block
	i = 0
	for {
		if !(i < int32(2)) {
			break
		}
		(*(*[2]Tuint32_t)(unsafe.Pointer(bp + 128)))[i] = uint32(0)
		j = int32(31)
		for {
			if !(j >= 0) {
				break
			}
			*(*Tuint32_t)(unsafe.Pointer(bp + 128 + uintptr(i)*4)) |= uint32(int32(*(*uint8)(unsafe.Pointer(p)))&Int32FromInt32(1)) << j
			goto _2
		_2:
			;
			j--
			p++
		}
		goto _1
	_1:
		;
		i++
	}
	key = uintptr(unsafe.Pointer(&___encrypt_key))
	if edflag != 0 {
		key = bp
		i = 0
		for {
			if !(i < int32(16)) {
				break
			}
			*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(i)*4)) = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&___encrypt_key)) + uintptr(int32(15)-i)*4))
			*(*Tuint32_t)(unsafe.Pointer(bp + 64 + uintptr(i)*4)) = *(*Tuint32_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&___encrypt_key)) + 64 + uintptr(int32(15)-i)*4))
			goto _3
		_3:
			;
			i++
		}
	}
	X__do_des(tls, (*(*[2]Tuint32_t)(unsafe.Pointer(bp + 128)))[0], (*(*[2]Tuint32_t)(unsafe.Pointer(bp + 128)))[int32(1)], bp+128, bp+128+uintptr(1)*4, uint32(1), uint32(0), key)
	p = block
	i = 0
	for {
		if !(i < int32(2)) {
			break
		}
		j = int32(31)
		for {
			if !(j >= 0) {
				break
			}
			v6 = p
			p++
			*(*uint8)(unsafe.Pointer(v6)) = uint8((*(*[2]Tuint32_t)(unsafe.Pointer(bp + 128)))[i] >> j & uint32(1))
			goto _5
		_5:
			;
			j--
		}
		goto _4
	_4:
		;
		i++
	}
}

var _table = [384]uint16{
	128: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	129: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	130: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	131: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	132: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	133: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	134: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	135: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	136: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	137: uint16((Int32FromInt32(0x320)/Int32FromInt32(256) | Int32FromInt32(0x320)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	138: uint16((Int32FromInt32(0x220)/Int32FromInt32(256) | Int32FromInt32(0x220)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	139: uint16((Int32FromInt32(0x220)/Int32FromInt32(256) | Int32FromInt32(0x220)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	140: uint16((Int32FromInt32(0x220)/Int32FromInt32(256) | Int32FromInt32(0x220)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	141: uint16((Int32FromInt32(0x220)/Int32FromInt32(256) | Int32FromInt32(0x220)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	142: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	143: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	144: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	145: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	146: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	147: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	148: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	149: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	150: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	151: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	152: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	153: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	154: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	155: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	156: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	157: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	158: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	159: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	160: uint16((Int32FromInt32(0x160)/Int32FromInt32(256) | Int32FromInt32(0x160)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	161: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	162: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	163: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	164: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	165: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	166: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	167: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	168: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	169: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	170: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	171: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	172: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	173: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	174: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	175: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	176: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	177: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	178: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	179: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	180: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	181: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	182: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	183: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	184: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	185: uint16((Int32FromInt32(0x8d8)/Int32FromInt32(256) | Int32FromInt32(0x8d8)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	186: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	187: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	188: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	189: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	190: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	191: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	192: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	193: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	194: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	195: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	196: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	197: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	198: uint16((Int32FromInt32(0x8d5)/Int32FromInt32(256) | Int32FromInt32(0x8d5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	199: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	200: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	201: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	202: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	203: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	204: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	205: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	206: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	207: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	208: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	209: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	210: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	211: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	212: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	213: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	214: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	215: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	216: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	217: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	218: uint16((Int32FromInt32(0x8c5)/Int32FromInt32(256) | Int32FromInt32(0x8c5)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	219: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	220: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	221: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	222: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	223: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	224: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	225: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	226: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	227: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	228: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	229: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	230: uint16((Int32FromInt32(0x8d6)/Int32FromInt32(256) | Int32FromInt32(0x8d6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	231: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	232: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	233: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	234: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	235: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	236: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	237: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	238: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	239: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	240: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	241: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	242: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	243: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	244: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	245: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	246: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	247: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	248: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	249: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	250: uint16((Int32FromInt32(0x8c6)/Int32FromInt32(256) | Int32FromInt32(0x8c6)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	251: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	252: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	253: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	254: uint16((Int32FromInt32(0x4c0)/Int32FromInt32(256) | Int32FromInt32(0x4c0)*Int32FromInt32(256)) % Int32FromInt32(65536)),
	255: uint16((Int32FromInt32(0x200)/Int32FromInt32(256) | Int32FromInt32(0x200)*Int32FromInt32(256)) % Int32FromInt32(65536)),
}

var _ptable = uintptr(unsafe.Pointer(&_table)) + uintptr(128)*2

func X__ctype_b_loc(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(unsafe.Pointer(&_ptable))
}

const CLOCKS_PER_SEC = 1000000
const CLOCK_BOOTTIME = 7
const CLOCK_BOOTTIME_ALARM = 9
const CLOCK_MONOTONIC = 1
const CLOCK_MONOTONIC_COARSE = 6
const CLOCK_MONOTONIC_RAW = 4
const CLOCK_PROCESS_CPUTIME_ID = 2
const CLOCK_REALTIME = 0
const CLOCK_REALTIME_ALARM = 8
const CLOCK_REALTIME_COARSE = 5
const CLOCK_SGI_CYCLE = 10
const CLOCK_TAI = 11
const CLOCK_THREAD_CPUTIME_ID = 3
const C_LOCALE = 0
const DEFAULT_GUARD_MAX = 1048576
const DEFAULT_GUARD_SIZE = 8192
const DEFAULT_STACK_MAX = 8388608
const DEFAULT_STACK_SIZE = 131072
const DTP_OFFSET = 0
const FUTEX_CLOCK_REALTIME = 256
const FUTEX_CMP_REQUEUE = 4
const FUTEX_FD = 2
const FUTEX_LOCK_PI = 6
const FUTEX_PRIVATE = 128
const FUTEX_REQUEUE = 3
const FUTEX_TRYLOCK_PI = 8
const FUTEX_UNLOCK_PI = 7
const FUTEX_WAIT = 0
const FUTEX_WAIT_BITSET = 9
const FUTEX_WAKE = 1
const FUTEX_WAKE_OP = 5
const GAP_ABOVE_TP = 16
const LC_ALL = 6
const LC_ALL_MASK = 2147483647
const LC_COLLATE = 3
const LC_COLLATE_MASK = 8
const LC_CTYPE = 0
const LC_CTYPE_MASK = 1
const LC_GLOBAL_LOCALE = -1
const LC_MESSAGES = 5
const LC_MESSAGES_MASK = 32
const LC_MONETARY = 4
const LC_MONETARY_MASK = 16
const LC_NUMERIC = 1
const LC_NUMERIC_MASK = 2
const LC_TIME = 2
const LC_TIME_MASK = 4
const LOCALE_NAME_MAX = 23
const MAP_ANON = 32
const MAP_ANONYMOUS = 32
const MAP_DENYWRITE = 2048
const MAP_EXECUTABLE = 4096
const MAP_FAILED = -1
const MAP_FILE = 0
const MAP_FIXED = 16
const MAP_FIXED_NOREPLACE = 1048576
const MAP_GROWSDOWN = 256
const MAP_HUGETLB = 262144
const MAP_HUGE_16GB = 2281701376
const MAP_HUGE_16KB = 939524096
const MAP_HUGE_16MB = 1610612736
const MAP_HUGE_1GB = 2013265920
const MAP_HUGE_1MB = 1342177280
const MAP_HUGE_256MB = 1879048192
const MAP_HUGE_2GB = 2080374784
const MAP_HUGE_2MB = 1409286144
const MAP_HUGE_32MB = 1677721600
const MAP_HUGE_512KB = 1275068416
const MAP_HUGE_512MB = 1946157056
const MAP_HUGE_64KB = 1073741824
const MAP_HUGE_8MB = 1543503872
const MAP_HUGE_MASK = 63
const MAP_HUGE_SHIFT = 26
const MAP_LOCKED = 8192
const MAP_NONBLOCK = 65536
const MAP_NORESERVE = 16384
const MAP_POPULATE = 32768
const MAP_PRIVATE = 2
const MAP_SHARED = 1
const MAP_SHARED_VALIDATE = 3
const MAP_STACK = 131072
const MAP_SYNC = 524288
const MAP_TYPE = 15
const MCL_CURRENT = 1
const MCL_FUTURE = 2
const MCL_ONFAULT = 4
const MC_PC = 0
const MS_ASYNC = 1
const MS_INVALIDATE = 2
const MS_SYNC = 4
const POSIX_MADV_DONTNEED = 4
const POSIX_MADV_NORMAL = 0
const POSIX_MADV_RANDOM = 1
const POSIX_MADV_SEQUENTIAL = 2
const POSIX_MADV_WILLNEED = 3
const PROT_BTI = 16
const PROT_EXEC = 4
const PROT_GROWSDOWN = 16777216
const PROT_GROWSUP = 33554432
const PROT_MTE = 32
const PROT_NONE = 0
const PROT_READ = 1
const PROT_WRITE = 2
const PTHREAD_BARRIER_SERIAL_THREAD = -1
const PTHREAD_CANCELED = -1
const PTHREAD_CANCEL_ASYNCHRONOUS = 1
const PTHREAD_CANCEL_DEFERRED = 0
const PTHREAD_CANCEL_DISABLE = 1
const PTHREAD_CANCEL_ENABLE = 0
const PTHREAD_CANCEL_MASKED = 2
const PTHREAD_CREATE_DETACHED = 1
const PTHREAD_CREATE_JOINABLE = 0
const PTHREAD_EXPLICIT_SCHED = 1
const PTHREAD_INHERIT_SCHED = 0
const PTHREAD_MUTEX_DEFAULT = 0
const PTHREAD_MUTEX_ERRORCHECK = 2
const PTHREAD_MUTEX_NORMAL = 0
const PTHREAD_MUTEX_RECURSIVE = 1
const PTHREAD_MUTEX_ROBUST = 1
const PTHREAD_MUTEX_STALLED = 0
const PTHREAD_ONCE_INIT = 0
const PTHREAD_PRIO_INHERIT = 1
const PTHREAD_PRIO_NONE = 0
const PTHREAD_PRIO_PROTECT = 2
const PTHREAD_PROCESS_PRIVATE = 0
const PTHREAD_PROCESS_SHARED = 1
const PTHREAD_SCOPE_PROCESS = 1
const PTHREAD_SCOPE_SYSTEM = 0
const SCHED_BATCH = 3
const SCHED_DEADLINE = 6
const SCHED_FIFO = 1
const SCHED_IDLE = 5
const SCHED_OTHER = 0
const SCHED_RESET_ON_FORK = 1073741824
const SCHED_RR = 2
const SIGCANCEL = 33
const SIGSYNCCALL = 34
const SIGTIMER = 32
const TIMER_ABSTIME = 1
const TIME_UTC = 1
const TP_OFFSET = 0
const UTF8_LOCALE = 0
const __CCGO_SIZEOF_GO_MUTEX = 8
const __SU = 0
const a_spin = 0
const pthread = 0
const tls_mod_off_t = 0

type Tlconv = struct {
	Fdecimal_point      uintptr
	Fthousands_sep      uintptr
	Fgrouping           uintptr
	Fint_curr_symbol    uintptr
	Fcurrency_symbol    uintptr
	Fmon_decimal_point  uintptr
	Fmon_thousands_sep  uintptr
	Fmon_grouping       uintptr
	Fpositive_sign      uintptr
	Fnegative_sign      uintptr
	Fint_frac_digits    uint8
	Ffrac_digits        uint8
	Fp_cs_precedes      uint8
	Fp_sep_by_space     uint8
	Fn_cs_precedes      uint8
	Fn_sep_by_space     uint8
	Fp_sign_posn        uint8
	Fn_sign_posn        uint8
	Fint_p_cs_precedes  uint8
	Fint_p_sep_by_space uint8
	Fint_n_cs_precedes  uint8
	Fint_n_sep_by_space uint8
	Fint_p_sign_posn    uint8
	Fint_n_sign_posn    uint8
}

type t__locale_map = struct {
	Fmap1     uintptr
	Fmap_size Tsize_t
	Fname     [24]uint8
	Fnext     uintptr
}

type Tclockid_t = int32

type t__pthread = struct {
	Fself          uintptr
	Fprev          uintptr
	Fnext          uintptr
	Fsysinfo       Tuintptr_t
	Ftid           int32
	Ferrno_val     int32
	Fdetach_state  int32
	Fcancel        int32
	Fcanceldisable uint8
	Fcancelasync   uint8
	F__ccgo50      uint8
	Fmap_base      uintptr
	Fmap_size      Tsize_t
	Fstack         uintptr
	Fstack_size    Tsize_t
	Fguard_size    Tsize_t
	Fresult        uintptr
	Fcancelbuf     uintptr
	Ftsd           uintptr
	Frobust_list   struct {
		Fhead    uintptr
		Foff     int64
		Fpending uintptr
	}
	Fh_errno_val       int32
	Ftimer_id          int32
	Flocale            Tlocale_t
	Fkilllock          [1]int32
	Fdlerror_buf       uintptr
	Fstdio_locks       uintptr
	F__ccgo_join_mutex [1]int64
	Fcanary            Tuintptr_t
	Fdtv               uintptr
}

type Tpthread_once_t = int32

type Tpthread_key_t = uint32

type Tpthread_spinlock_t = int32

type Tpthread_mutexattr_t = struct {
	F__attr uint32
}

type Tpthread_condattr_t = struct {
	F__attr uint32
}

type Tpthread_barrierattr_t = struct {
	F__attr uint32
}

type Tpthread_rwlockattr_t = struct {
	F__attr [2]uint32
}

type Tpthread_mutex_t = struct {
	F__u struct {
		F__vi [0][10]int32
		F__p  [0][5]uintptr
		F__i  [10]int32
	}
}

type Tpthread_cond_t = struct {
	F__u struct {
		F__vi [0][12]int32
		F__p  [0][6]uintptr
		F__i  [12]int32
	}
}

type Tpthread_rwlock_t = struct {
	F__u struct {
		F__vi [0][14]int32
		F__p  [0][7]uintptr
		F__i  [14]int32
	}
}

type Tpthread_barrier_t = struct {
	F__u struct {
		F__vi [0][8]int32
		F__p  [0][4]uintptr
		F__i  [8]int32
	}
}

type Tsched_param = struct {
	Fsched_priority int32
	F__reserved1    int32
	F__reserved2    [2]struct {
		F__reserved1 Ttime_t
		F__reserved2 int64
	}
	F__reserved3 int32
}

type Ttimer_t = uintptr

type Ttm = struct {
	Ftm_sec      int32
	Ftm_min      int32
	Ftm_hour     int32
	Ftm_mday     int32
	Ftm_mon      int32
	Ftm_year     int32
	Ftm_wday     int32
	Ftm_yday     int32
	Ftm_isdst    int32
	F__tm_gmtoff int64
	F__tm_zone   uintptr
}

type Titimerspec = struct {
	Fit_interval Ttimespec
	Fit_value    Ttimespec
}

type t__ptcb = struct {
	F__f    uintptr
	F__x    uintptr
	F__next uintptr
}

type Tmode_t = uint32

const _DT_EXITED = 0
const _DT_EXITING = 1
const _DT_JOINABLE = 2
const _DT_DETACHED = 3

func X__ctype_get_mb_cur_max(tls *TLS) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	_ = v1
	if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
		v1 = int32(4)
	} else {
		v1 = int32(1)
	}
	return uint64(v1)
}

var _table1 = [384]Tint32_t{
	129: int32(1),
	130: int32(2),
	131: int32(3),
	132: int32(4),
	133: int32(5),
	134: int32(6),
	135: int32(7),
	136: int32(8),
	137: int32(9),
	138: int32(10),
	139: int32(11),
	140: int32(12),
	141: int32(13),
	142: int32(14),
	143: int32(15),
	144: int32(16),
	145: int32(17),
	146: int32(18),
	147: int32(19),
	148: int32(20),
	149: int32(21),
	150: int32(22),
	151: int32(23),
	152: int32(24),
	153: int32(25),
	154: int32(26),
	155: int32(27),
	156: int32(28),
	157: int32(29),
	158: int32(30),
	159: int32(31),
	160: int32(32),
	161: int32(33),
	162: int32(34),
	163: int32(35),
	164: int32(36),
	165: int32(37),
	166: int32(38),
	167: int32(39),
	168: int32(40),
	169: int32(41),
	170: int32(42),
	171: int32(43),
	172: int32(44),
	173: int32(45),
	174: int32(46),
	175: int32(47),
	176: int32(48),
	177: int32(49),
	178: int32(50),
	179: int32(51),
	180: int32(52),
	181: int32(53),
	182: int32(54),
	183: int32(55),
	184: int32(56),
	185: int32(57),
	186: int32(58),
	187: int32(59),
	188: int32(60),
	189: int32(61),
	190: int32(62),
	191: int32(63),
	192: int32(64),
	193: int32('a'),
	194: int32('b'),
	195: int32('c'),
	196: int32('d'),
	197: int32('e'),
	198: int32('f'),
	199: int32('g'),
	200: int32('h'),
	201: int32('i'),
	202: int32('j'),
	203: int32('k'),
	204: int32('l'),
	205: int32('m'),
	206: int32('n'),
	207: int32('o'),
	208: int32('p'),
	209: int32('q'),
	210: int32('r'),
	211: int32('s'),
	212: int32('t'),
	213: int32('u'),
	214: int32('v'),
	215: int32('w'),
	216: int32('x'),
	217: int32('y'),
	218: int32('z'),
	219: int32(91),
	220: int32(92),
	221: int32(93),
	222: int32(94),
	223: int32(95),
	224: int32(96),
	225: int32('a'),
	226: int32('b'),
	227: int32('c'),
	228: int32('d'),
	229: int32('e'),
	230: int32('f'),
	231: int32('g'),
	232: int32('h'),
	233: int32('i'),
	234: int32('j'),
	235: int32('k'),
	236: int32('l'),
	237: int32('m'),
	238: int32('n'),
	239: int32('o'),
	240: int32('p'),
	241: int32('q'),
	242: int32('r'),
	243: int32('s'),
	244: int32('t'),
	245: int32('u'),
	246: int32('v'),
	247: int32('w'),
	248: int32('x'),
	249: int32('y'),
	250: int32('z'),
	251: int32(123),
	252: int32(124),
	253: int32(125),
	254: int32(126),
	255: int32(127),
}

var _ptable1 = uintptr(unsafe.Pointer(&_table1)) + uintptr(128)*4

func X__ctype_tolower_loc(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(unsafe.Pointer(&_ptable1))
}

var _table2 = [384]Tint32_t{
	129: int32(1),
	130: int32(2),
	131: int32(3),
	132: int32(4),
	133: int32(5),
	134: int32(6),
	135: int32(7),
	136: int32(8),
	137: int32(9),
	138: int32(10),
	139: int32(11),
	140: int32(12),
	141: int32(13),
	142: int32(14),
	143: int32(15),
	144: int32(16),
	145: int32(17),
	146: int32(18),
	147: int32(19),
	148: int32(20),
	149: int32(21),
	150: int32(22),
	151: int32(23),
	152: int32(24),
	153: int32(25),
	154: int32(26),
	155: int32(27),
	156: int32(28),
	157: int32(29),
	158: int32(30),
	159: int32(31),
	160: int32(32),
	161: int32(33),
	162: int32(34),
	163: int32(35),
	164: int32(36),
	165: int32(37),
	166: int32(38),
	167: int32(39),
	168: int32(40),
	169: int32(41),
	170: int32(42),
	171: int32(43),
	172: int32(44),
	173: int32(45),
	174: int32(46),
	175: int32(47),
	176: int32(48),
	177: int32(49),
	178: int32(50),
	179: int32(51),
	180: int32(52),
	181: int32(53),
	182: int32(54),
	183: int32(55),
	184: int32(56),
	185: int32(57),
	186: int32(58),
	187: int32(59),
	188: int32(60),
	189: int32(61),
	190: int32(62),
	191: int32(63),
	192: int32(64),
	193: int32('A'),
	194: int32('B'),
	195: int32('C'),
	196: int32('D'),
	197: int32('E'),
	198: int32('F'),
	199: int32('G'),
	200: int32('H'),
	201: int32('I'),
	202: int32('J'),
	203: int32('K'),
	204: int32('L'),
	205: int32('M'),
	206: int32('N'),
	207: int32('O'),
	208: int32('P'),
	209: int32('Q'),
	210: int32('R'),
	211: int32('S'),
	212: int32('T'),
	213: int32('U'),
	214: int32('V'),
	215: int32('W'),
	216: int32('X'),
	217: int32('Y'),
	218: int32('Z'),
	219: int32(91),
	220: int32(92),
	221: int32(93),
	222: int32(94),
	223: int32(95),
	224: int32(96),
	225: int32('A'),
	226: int32('B'),
	227: int32('C'),
	228: int32('D'),
	229: int32('E'),
	230: int32('F'),
	231: int32('G'),
	232: int32('H'),
	233: int32('I'),
	234: int32('J'),
	235: int32('K'),
	236: int32('L'),
	237: int32('M'),
	238: int32('N'),
	239: int32('O'),
	240: int32('P'),
	241: int32('Q'),
	242: int32('R'),
	243: int32('S'),
	244: int32('T'),
	245: int32('U'),
	246: int32('V'),
	247: int32('W'),
	248: int32('X'),
	249: int32('Y'),
	250: int32('Z'),
	251: int32(123),
	252: int32(124),
	253: int32(125),
	254: int32(126),
	255: int32(127),
}

var _ptable2 = uintptr(unsafe.Pointer(&_table2)) + uintptr(128)*4

func X__ctype_toupper_loc(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(unsafe.Pointer(&_ptable2))
}

func Xisalnum(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(BoolInt32(uint32(c)|uint32(32)-uint32('a') < uint32(26)) != 0 || BoolInt32(uint32(c)-uint32('0') < uint32(10)) != 0)
}

func X__isalnum_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisalnum(tls, c)
}

func Xisalnum_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isalnum_l(tls, c, l)
}

func Xisalpha(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(uint32(c)|uint32(32)-uint32('a') < uint32(26))
}

func X__isalpha_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisalpha(tls, c)
}

func Xisalpha_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isalpha_l(tls, c, l)
}

func Xisascii(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(!(c & ^Int32FromInt32(0x7f) != 0))
}

func Xisblank(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(c == int32(' ') || c == int32('\t'))
}

func X__isblank_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisblank(tls, c)
}

func Xisblank_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isblank_l(tls, c, l)
}

func Xiscntrl(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(uint32(c) < uint32(0x20) || c == int32(0x7f))
}

func X__iscntrl_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiscntrl(tls, c)
}

func Xiscntrl_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iscntrl_l(tls, c, l)
}

func Xisdigit(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(uint32(c)-uint32('0') < uint32(10))
}

func X__isdigit_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisdigit(tls, c)
}

func Xisdigit_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isdigit_l(tls, c, l)
}

func Xisgraph(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(uint32(c)-uint32(0x21) < uint32(0x5e))
}

func X__isgraph_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisgraph(tls, c)
}

func Xisgraph_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isgraph_l(tls, c, l)
}

func Xislower(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(uint32(c)-uint32('a') < uint32(26))
}

func X__islower_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xislower(tls, c)
}

func Xislower_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__islower_l(tls, c, l)
}

func Xisprint(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(uint32(c)-uint32(0x20) < uint32(0x5f))
}

func X__isprint_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisprint(tls, c)
}

func Xisprint_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isprint_l(tls, c, l)
}

func Xispunct(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(BoolInt32(uint32(c)-uint32(0x21) < uint32(0x5e)) != 0 && !(Xisalnum(tls, c) != 0))
}

func X__ispunct_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xispunct(tls, c)
}

func Xispunct_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__ispunct_l(tls, c, l)
}

func Xisspace(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(c == int32(' ') || uint32(c)-uint32('\t') < uint32(5))
}

func X__isspace_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisspace(tls, c)
}

func Xisspace_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isspace_l(tls, c, l)
}

func Xisupper(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(uint32(c)-uint32('A') < uint32(26))
}

func X__isupper_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisupper(tls, c)
}

func Xisupper_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isupper_l(tls, c, l)
}

type Twint_t = uint32

type Twctype_t = uint64

type Twctrans_t = uintptr

func Xiswalnum(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(BoolInt32(wc-uint32('0') < uint32(10)) != 0 || Xiswalpha(tls, wc) != 0)
}

func X__iswalnum_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswalnum(tls, c)
}

func Xiswalnum_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswalnum_l(tls, c, l)
}

var _table3 = [3904]uint8{
	0:    uint8(18),
	1:    uint8(17),
	2:    uint8(19),
	3:    uint8(20),
	4:    uint8(21),
	5:    uint8(22),
	6:    uint8(23),
	7:    uint8(24),
	8:    uint8(25),
	9:    uint8(26),
	10:   uint8(27),
	11:   uint8(28),
	12:   uint8(29),
	13:   uint8(30),
	14:   uint8(31),
	15:   uint8(32),
	16:   uint8(33),
	17:   uint8(17),
	18:   uint8(34),
	19:   uint8(35),
	20:   uint8(36),
	21:   uint8(17),
	22:   uint8(37),
	23:   uint8(38),
	24:   uint8(39),
	25:   uint8(40),
	26:   uint8(41),
	27:   uint8(42),
	28:   uint8(43),
	29:   uint8(44),
	30:   uint8(17),
	31:   uint8(45),
	32:   uint8(46),
	33:   uint8(47),
	34:   uint8(16),
	35:   uint8(16),
	36:   uint8(48),
	37:   uint8(16),
	38:   uint8(16),
	39:   uint8(16),
	40:   uint8(16),
	41:   uint8(16),
	42:   uint8(16),
	43:   uint8(16),
	44:   uint8(49),
	45:   uint8(50),
	46:   uint8(51),
	47:   uint8(16),
	48:   uint8(52),
	49:   uint8(53),
	50:   uint8(16),
	51:   uint8(16),
	52:   uint8(17),
	53:   uint8(17),
	54:   uint8(17),
	55:   uint8(17),
	56:   uint8(17),
	57:   uint8(17),
	58:   uint8(17),
	59:   uint8(17),
	60:   uint8(17),
	61:   uint8(17),
	62:   uint8(17),
	63:   uint8(17),
	64:   uint8(17),
	65:   uint8(17),
	66:   uint8(17),
	67:   uint8(17),
	68:   uint8(17),
	69:   uint8(17),
	70:   uint8(17),
	71:   uint8(17),
	72:   uint8(17),
	73:   uint8(17),
	74:   uint8(17),
	75:   uint8(17),
	76:   uint8(17),
	77:   uint8(54),
	78:   uint8(17),
	79:   uint8(17),
	80:   uint8(17),
	81:   uint8(17),
	82:   uint8(17),
	83:   uint8(17),
	84:   uint8(17),
	85:   uint8(17),
	86:   uint8(17),
	87:   uint8(17),
	88:   uint8(17),
	89:   uint8(17),
	90:   uint8(17),
	91:   uint8(17),
	92:   uint8(17),
	93:   uint8(17),
	94:   uint8(17),
	95:   uint8(17),
	96:   uint8(17),
	97:   uint8(17),
	98:   uint8(17),
	99:   uint8(17),
	100:  uint8(17),
	101:  uint8(17),
	102:  uint8(17),
	103:  uint8(17),
	104:  uint8(17),
	105:  uint8(17),
	106:  uint8(17),
	107:  uint8(17),
	108:  uint8(17),
	109:  uint8(17),
	110:  uint8(17),
	111:  uint8(17),
	112:  uint8(17),
	113:  uint8(17),
	114:  uint8(17),
	115:  uint8(17),
	116:  uint8(17),
	117:  uint8(17),
	118:  uint8(17),
	119:  uint8(17),
	120:  uint8(17),
	121:  uint8(17),
	122:  uint8(17),
	123:  uint8(17),
	124:  uint8(17),
	125:  uint8(17),
	126:  uint8(17),
	127:  uint8(17),
	128:  uint8(17),
	129:  uint8(17),
	130:  uint8(17),
	131:  uint8(17),
	132:  uint8(17),
	133:  uint8(17),
	134:  uint8(17),
	135:  uint8(17),
	136:  uint8(17),
	137:  uint8(17),
	138:  uint8(17),
	139:  uint8(17),
	140:  uint8(17),
	141:  uint8(17),
	142:  uint8(17),
	143:  uint8(17),
	144:  uint8(17),
	145:  uint8(17),
	146:  uint8(17),
	147:  uint8(17),
	148:  uint8(17),
	149:  uint8(17),
	150:  uint8(17),
	151:  uint8(17),
	152:  uint8(17),
	153:  uint8(17),
	154:  uint8(17),
	155:  uint8(17),
	156:  uint8(17),
	157:  uint8(17),
	158:  uint8(17),
	159:  uint8(55),
	160:  uint8(17),
	161:  uint8(17),
	162:  uint8(17),
	163:  uint8(17),
	164:  uint8(56),
	165:  uint8(17),
	166:  uint8(57),
	167:  uint8(58),
	168:  uint8(59),
	169:  uint8(60),
	170:  uint8(61),
	171:  uint8(62),
	172:  uint8(17),
	173:  uint8(17),
	174:  uint8(17),
	175:  uint8(17),
	176:  uint8(17),
	177:  uint8(17),
	178:  uint8(17),
	179:  uint8(17),
	180:  uint8(17),
	181:  uint8(17),
	182:  uint8(17),
	183:  uint8(17),
	184:  uint8(17),
	185:  uint8(17),
	186:  uint8(17),
	187:  uint8(17),
	188:  uint8(17),
	189:  uint8(17),
	190:  uint8(17),
	191:  uint8(17),
	192:  uint8(17),
	193:  uint8(17),
	194:  uint8(17),
	195:  uint8(17),
	196:  uint8(17),
	197:  uint8(17),
	198:  uint8(17),
	199:  uint8(17),
	200:  uint8(17),
	201:  uint8(17),
	202:  uint8(17),
	203:  uint8(17),
	204:  uint8(17),
	205:  uint8(17),
	206:  uint8(17),
	207:  uint8(17),
	208:  uint8(17),
	209:  uint8(17),
	210:  uint8(17),
	211:  uint8(17),
	212:  uint8(17),
	213:  uint8(17),
	214:  uint8(17),
	215:  uint8(63),
	216:  uint8(16),
	217:  uint8(16),
	218:  uint8(16),
	219:  uint8(16),
	220:  uint8(16),
	221:  uint8(16),
	222:  uint8(16),
	223:  uint8(16),
	224:  uint8(16),
	225:  uint8(16),
	226:  uint8(16),
	227:  uint8(16),
	228:  uint8(16),
	229:  uint8(16),
	230:  uint8(16),
	231:  uint8(16),
	232:  uint8(16),
	233:  uint8(16),
	234:  uint8(16),
	235:  uint8(16),
	236:  uint8(16),
	237:  uint8(16),
	238:  uint8(16),
	239:  uint8(16),
	240:  uint8(16),
	241:  uint8(16),
	242:  uint8(16),
	243:  uint8(16),
	244:  uint8(16),
	245:  uint8(16),
	246:  uint8(16),
	247:  uint8(16),
	248:  uint8(16),
	249:  uint8(17),
	250:  uint8(64),
	251:  uint8(65),
	252:  uint8(17),
	253:  uint8(66),
	254:  uint8(67),
	255:  uint8(68),
	256:  uint8(69),
	257:  uint8(70),
	258:  uint8(71),
	259:  uint8(72),
	260:  uint8(73),
	261:  uint8(74),
	262:  uint8(17),
	263:  uint8(75),
	264:  uint8(76),
	265:  uint8(77),
	266:  uint8(78),
	267:  uint8(79),
	268:  uint8(80),
	269:  uint8(81),
	270:  uint8(16),
	271:  uint8(82),
	272:  uint8(83),
	273:  uint8(84),
	274:  uint8(85),
	275:  uint8(86),
	276:  uint8(87),
	277:  uint8(88),
	278:  uint8(89),
	279:  uint8(90),
	280:  uint8(91),
	281:  uint8(92),
	282:  uint8(93),
	283:  uint8(16),
	284:  uint8(94),
	285:  uint8(95),
	286:  uint8(96),
	287:  uint8(16),
	288:  uint8(17),
	289:  uint8(17),
	290:  uint8(17),
	291:  uint8(97),
	292:  uint8(98),
	293:  uint8(99),
	294:  uint8(16),
	295:  uint8(16),
	296:  uint8(16),
	297:  uint8(16),
	298:  uint8(16),
	299:  uint8(16),
	300:  uint8(16),
	301:  uint8(16),
	302:  uint8(16),
	303:  uint8(16),
	304:  uint8(17),
	305:  uint8(17),
	306:  uint8(17),
	307:  uint8(17),
	308:  uint8(100),
	309:  uint8(16),
	310:  uint8(16),
	311:  uint8(16),
	312:  uint8(16),
	313:  uint8(16),
	314:  uint8(16),
	315:  uint8(16),
	316:  uint8(16),
	317:  uint8(16),
	318:  uint8(16),
	319:  uint8(16),
	320:  uint8(16),
	321:  uint8(16),
	322:  uint8(16),
	323:  uint8(16),
	324:  uint8(17),
	325:  uint8(17),
	326:  uint8(101),
	327:  uint8(16),
	328:  uint8(16),
	329:  uint8(16),
	330:  uint8(16),
	331:  uint8(16),
	332:  uint8(16),
	333:  uint8(16),
	334:  uint8(16),
	335:  uint8(16),
	336:  uint8(16),
	337:  uint8(16),
	338:  uint8(16),
	339:  uint8(16),
	340:  uint8(16),
	341:  uint8(16),
	342:  uint8(16),
	343:  uint8(16),
	344:  uint8(16),
	345:  uint8(16),
	346:  uint8(16),
	347:  uint8(16),
	348:  uint8(16),
	349:  uint8(16),
	350:  uint8(16),
	351:  uint8(16),
	352:  uint8(16),
	353:  uint8(16),
	354:  uint8(16),
	355:  uint8(16),
	356:  uint8(16),
	357:  uint8(16),
	358:  uint8(16),
	359:  uint8(16),
	360:  uint8(17),
	361:  uint8(17),
	362:  uint8(102),
	363:  uint8(103),
	364:  uint8(16),
	365:  uint8(16),
	366:  uint8(104),
	367:  uint8(105),
	368:  uint8(17),
	369:  uint8(17),
	370:  uint8(17),
	371:  uint8(17),
	372:  uint8(17),
	373:  uint8(17),
	374:  uint8(17),
	375:  uint8(17),
	376:  uint8(17),
	377:  uint8(17),
	378:  uint8(17),
	379:  uint8(17),
	380:  uint8(17),
	381:  uint8(17),
	382:  uint8(17),
	383:  uint8(17),
	384:  uint8(17),
	385:  uint8(17),
	386:  uint8(17),
	387:  uint8(17),
	388:  uint8(17),
	389:  uint8(17),
	390:  uint8(17),
	391:  uint8(106),
	392:  uint8(17),
	393:  uint8(17),
	394:  uint8(107),
	395:  uint8(16),
	396:  uint8(16),
	397:  uint8(16),
	398:  uint8(16),
	399:  uint8(16),
	400:  uint8(16),
	401:  uint8(16),
	402:  uint8(16),
	403:  uint8(16),
	404:  uint8(16),
	405:  uint8(16),
	406:  uint8(16),
	407:  uint8(16),
	408:  uint8(16),
	409:  uint8(16),
	410:  uint8(16),
	411:  uint8(16),
	412:  uint8(16),
	413:  uint8(16),
	414:  uint8(16),
	415:  uint8(16),
	416:  uint8(16),
	417:  uint8(16),
	418:  uint8(16),
	419:  uint8(16),
	420:  uint8(16),
	421:  uint8(16),
	422:  uint8(16),
	423:  uint8(16),
	424:  uint8(16),
	425:  uint8(16),
	426:  uint8(16),
	427:  uint8(16),
	428:  uint8(16),
	429:  uint8(16),
	430:  uint8(16),
	431:  uint8(16),
	432:  uint8(17),
	433:  uint8(108),
	434:  uint8(109),
	435:  uint8(16),
	436:  uint8(16),
	437:  uint8(16),
	438:  uint8(16),
	439:  uint8(16),
	440:  uint8(16),
	441:  uint8(16),
	442:  uint8(16),
	443:  uint8(16),
	444:  uint8(110),
	445:  uint8(16),
	446:  uint8(16),
	447:  uint8(16),
	448:  uint8(16),
	449:  uint8(16),
	450:  uint8(16),
	451:  uint8(16),
	452:  uint8(16),
	453:  uint8(16),
	454:  uint8(16),
	455:  uint8(16),
	456:  uint8(16),
	457:  uint8(16),
	458:  uint8(16),
	459:  uint8(16),
	460:  uint8(16),
	461:  uint8(16),
	462:  uint8(16),
	463:  uint8(16),
	464:  uint8(16),
	465:  uint8(16),
	466:  uint8(16),
	467:  uint8(16),
	468:  uint8(111),
	469:  uint8(112),
	470:  uint8(113),
	471:  uint8(114),
	472:  uint8(16),
	473:  uint8(16),
	474:  uint8(16),
	475:  uint8(16),
	476:  uint8(16),
	477:  uint8(16),
	478:  uint8(16),
	479:  uint8(16),
	480:  uint8(115),
	481:  uint8(116),
	482:  uint8(117),
	483:  uint8(16),
	484:  uint8(16),
	485:  uint8(16),
	486:  uint8(16),
	487:  uint8(16),
	488:  uint8(118),
	489:  uint8(119),
	490:  uint8(16),
	491:  uint8(16),
	492:  uint8(16),
	493:  uint8(16),
	494:  uint8(120),
	495:  uint8(16),
	496:  uint8(16),
	497:  uint8(121),
	498:  uint8(16),
	499:  uint8(16),
	500:  uint8(16),
	501:  uint8(16),
	502:  uint8(16),
	503:  uint8(16),
	504:  uint8(16),
	505:  uint8(16),
	506:  uint8(16),
	507:  uint8(16),
	508:  uint8(16),
	509:  uint8(16),
	510:  uint8(16),
	511:  uint8(16),
	544:  uint8(255),
	545:  uint8(255),
	546:  uint8(255),
	547:  uint8(255),
	548:  uint8(255),
	549:  uint8(255),
	550:  uint8(255),
	551:  uint8(255),
	552:  uint8(255),
	553:  uint8(255),
	554:  uint8(255),
	555:  uint8(255),
	556:  uint8(255),
	557:  uint8(255),
	558:  uint8(255),
	559:  uint8(255),
	560:  uint8(255),
	561:  uint8(255),
	562:  uint8(255),
	563:  uint8(255),
	564:  uint8(255),
	565:  uint8(255),
	566:  uint8(255),
	567:  uint8(255),
	568:  uint8(255),
	569:  uint8(255),
	570:  uint8(255),
	571:  uint8(255),
	572:  uint8(255),
	573:  uint8(255),
	574:  uint8(255),
	575:  uint8(255),
	584:  uint8(254),
	585:  uint8(255),
	586:  uint8(255),
	587:  uint8(7),
	588:  uint8(254),
	589:  uint8(255),
	590:  uint8(255),
	591:  uint8(7),
	597:  uint8(4),
	598:  uint8(32),
	599:  uint8(4),
	600:  uint8(255),
	601:  uint8(255),
	602:  uint8(127),
	603:  uint8(255),
	604:  uint8(255),
	605:  uint8(255),
	606:  uint8(127),
	607:  uint8(255),
	608:  uint8(255),
	609:  uint8(255),
	610:  uint8(255),
	611:  uint8(255),
	612:  uint8(255),
	613:  uint8(255),
	614:  uint8(255),
	615:  uint8(255),
	616:  uint8(255),
	617:  uint8(255),
	618:  uint8(255),
	619:  uint8(255),
	620:  uint8(255),
	621:  uint8(255),
	622:  uint8(255),
	623:  uint8(255),
	624:  uint8(255),
	625:  uint8(255),
	626:  uint8(255),
	627:  uint8(255),
	628:  uint8(255),
	629:  uint8(255),
	630:  uint8(255),
	631:  uint8(255),
	632:  uint8(195),
	633:  uint8(255),
	634:  uint8(3),
	636:  uint8(31),
	637:  uint8(80),
	648:  uint8(32),
	654:  uint8(223),
	655:  uint8(188),
	656:  uint8(64),
	657:  uint8(215),
	658:  uint8(255),
	659:  uint8(255),
	660:  uint8(251),
	661:  uint8(255),
	662:  uint8(255),
	663:  uint8(255),
	664:  uint8(255),
	665:  uint8(255),
	666:  uint8(255),
	667:  uint8(255),
	668:  uint8(255),
	669:  uint8(255),
	670:  uint8(191),
	671:  uint8(255),
	672:  uint8(255),
	673:  uint8(255),
	674:  uint8(255),
	675:  uint8(255),
	676:  uint8(255),
	677:  uint8(255),
	678:  uint8(255),
	679:  uint8(255),
	680:  uint8(255),
	681:  uint8(255),
	682:  uint8(255),
	683:  uint8(255),
	684:  uint8(255),
	685:  uint8(255),
	686:  uint8(255),
	687:  uint8(255),
	688:  uint8(3),
	689:  uint8(252),
	690:  uint8(255),
	691:  uint8(255),
	692:  uint8(255),
	693:  uint8(255),
	694:  uint8(255),
	695:  uint8(255),
	696:  uint8(255),
	697:  uint8(255),
	698:  uint8(255),
	699:  uint8(255),
	700:  uint8(255),
	701:  uint8(255),
	702:  uint8(255),
	703:  uint8(255),
	704:  uint8(255),
	705:  uint8(255),
	706:  uint8(255),
	707:  uint8(255),
	708:  uint8(255),
	709:  uint8(255),
	710:  uint8(254),
	711:  uint8(255),
	712:  uint8(255),
	713:  uint8(255),
	714:  uint8(127),
	715:  uint8(2),
	716:  uint8(255),
	717:  uint8(255),
	718:  uint8(255),
	719:  uint8(255),
	720:  uint8(255),
	721:  uint8(1),
	726:  uint8(255),
	727:  uint8(191),
	728:  uint8(182),
	730:  uint8(255),
	731:  uint8(255),
	732:  uint8(255),
	733:  uint8(135),
	734:  uint8(7),
	738:  uint8(255),
	739:  uint8(7),
	740:  uint8(255),
	741:  uint8(255),
	742:  uint8(255),
	743:  uint8(255),
	744:  uint8(255),
	745:  uint8(255),
	746:  uint8(255),
	747:  uint8(254),
	748:  uint8(255),
	749:  uint8(195),
	750:  uint8(255),
	751:  uint8(255),
	752:  uint8(255),
	753:  uint8(255),
	754:  uint8(255),
	755:  uint8(255),
	756:  uint8(255),
	757:  uint8(255),
	758:  uint8(255),
	759:  uint8(255),
	760:  uint8(255),
	761:  uint8(255),
	762:  uint8(239),
	763:  uint8(31),
	764:  uint8(254),
	765:  uint8(225),
	766:  uint8(255),
	767:  uint8(159),
	770:  uint8(255),
	771:  uint8(255),
	772:  uint8(255),
	773:  uint8(255),
	774:  uint8(255),
	775:  uint8(255),
	777:  uint8(224),
	778:  uint8(255),
	779:  uint8(255),
	780:  uint8(255),
	781:  uint8(255),
	782:  uint8(255),
	783:  uint8(255),
	784:  uint8(255),
	785:  uint8(255),
	786:  uint8(255),
	787:  uint8(255),
	788:  uint8(255),
	789:  uint8(255),
	790:  uint8(3),
	792:  uint8(255),
	793:  uint8(255),
	794:  uint8(255),
	795:  uint8(255),
	796:  uint8(255),
	797:  uint8(7),
	798:  uint8(48),
	799:  uint8(4),
	800:  uint8(255),
	801:  uint8(255),
	802:  uint8(255),
	803:  uint8(252),
	804:  uint8(255),
	805:  uint8(31),
	808:  uint8(255),
	809:  uint8(255),
	810:  uint8(255),
	811:  uint8(1),
	812:  uint8(255),
	813:  uint8(7),
	820:  uint8(255),
	821:  uint8(255),
	822:  uint8(223),
	823:  uint8(63),
	826:  uint8(240),
	827:  uint8(255),
	828:  uint8(248),
	829:  uint8(3),
	830:  uint8(255),
	831:  uint8(255),
	832:  uint8(255),
	833:  uint8(255),
	834:  uint8(255),
	835:  uint8(255),
	836:  uint8(255),
	837:  uint8(255),
	838:  uint8(255),
	839:  uint8(239),
	840:  uint8(255),
	841:  uint8(223),
	842:  uint8(225),
	843:  uint8(255),
	844:  uint8(207),
	845:  uint8(255),
	846:  uint8(254),
	847:  uint8(255),
	848:  uint8(239),
	849:  uint8(159),
	850:  uint8(249),
	851:  uint8(255),
	852:  uint8(255),
	853:  uint8(253),
	854:  uint8(197),
	855:  uint8(227),
	856:  uint8(159),
	857:  uint8(89),
	858:  uint8(128),
	859:  uint8(176),
	860:  uint8(207),
	861:  uint8(255),
	862:  uint8(3),
	863:  uint8(16),
	864:  uint8(238),
	865:  uint8(135),
	866:  uint8(249),
	867:  uint8(255),
	868:  uint8(255),
	869:  uint8(253),
	870:  uint8(109),
	871:  uint8(195),
	872:  uint8(135),
	873:  uint8(25),
	874:  uint8(2),
	875:  uint8(94),
	876:  uint8(192),
	877:  uint8(255),
	878:  uint8(63),
	880:  uint8(238),
	881:  uint8(191),
	882:  uint8(251),
	883:  uint8(255),
	884:  uint8(255),
	885:  uint8(253),
	886:  uint8(237),
	887:  uint8(227),
	888:  uint8(191),
	889:  uint8(27),
	890:  uint8(1),
	892:  uint8(207),
	893:  uint8(255),
	895:  uint8(30),
	896:  uint8(238),
	897:  uint8(159),
	898:  uint8(249),
	899:  uint8(255),
	900:  uint8(255),
	901:  uint8(253),
	902:  uint8(237),
	903:  uint8(227),
	904:  uint8(159),
	905:  uint8(25),
	906:  uint8(192),
	907:  uint8(176),
	908:  uint8(207),
	909:  uint8(255),
	910:  uint8(2),
	912:  uint8(236),
	913:  uint8(199),
	914:  uint8(61),
	915:  uint8(214),
	916:  uint8(24),
	917:  uint8(199),
	918:  uint8(255),
	919:  uint8(195),
	920:  uint8(199),
	921:  uint8(29),
	922:  uint8(129),
	924:  uint8(192),
	925:  uint8(255),
	928:  uint8(239),
	929:  uint8(223),
	930:  uint8(253),
	931:  uint8(255),
	932:  uint8(255),
	933:  uint8(253),
	934:  uint8(255),
	935:  uint8(227),
	936:  uint8(223),
	937:  uint8(29),
	938:  uint8(96),
	939:  uint8(7),
	940:  uint8(207),
	941:  uint8(255),
	944:  uint8(239),
	945:  uint8(223),
	946:  uint8(253),
	947:  uint8(255),
	948:  uint8(255),
	949:  uint8(253),
	950:  uint8(239),
	951:  uint8(227),
	952:  uint8(223),
	953:  uint8(29),
	954:  uint8(96),
	955:  uint8(64),
	956:  uint8(207),
	957:  uint8(255),
	958:  uint8(6),
	960:  uint8(239),
	961:  uint8(223),
	962:  uint8(253),
	963:  uint8(255),
	964:  uint8(255),
	965:  uint8(255),
	966:  uint8(255),
	967:  uint8(231),
	968:  uint8(223),
	969:  uint8(93),
	970:  uint8(240),
	971:  uint8(128),
	972:  uint8(207),
	973:  uint8(255),
	975:  uint8(252),
	976:  uint8(236),
	977:  uint8(255),
	978:  uint8(127),
	979:  uint8(252),
	980:  uint8(255),
	981:  uint8(255),
	982:  uint8(251),
	983:  uint8(47),
	984:  uint8(127),
	985:  uint8(128),
	986:  uint8(95),
	987:  uint8(255),
	988:  uint8(192),
	989:  uint8(255),
	990:  uint8(12),
	992:  uint8(254),
	993:  uint8(255),
	994:  uint8(255),
	995:  uint8(255),
	996:  uint8(255),
	997:  uint8(127),
	998:  uint8(255),
	999:  uint8(7),
	1000: uint8(63),
	1001: uint8(32),
	1002: uint8(255),
	1003: uint8(3),
	1008: uint8(214),
	1009: uint8(247),
	1010: uint8(255),
	1011: uint8(255),
	1012: uint8(175),
	1013: uint8(255),
	1014: uint8(255),
	1015: uint8(59),
	1016: uint8(95),
	1017: uint8(32),
	1018: uint8(255),
	1019: uint8(243),
	1024: uint8(1),
	1028: uint8(255),
	1029: uint8(3),
	1032: uint8(255),
	1033: uint8(254),
	1034: uint8(255),
	1035: uint8(255),
	1036: uint8(255),
	1037: uint8(31),
	1038: uint8(254),
	1039: uint8(255),
	1040: uint8(3),
	1041: uint8(255),
	1042: uint8(255),
	1043: uint8(254),
	1044: uint8(255),
	1045: uint8(255),
	1046: uint8(255),
	1047: uint8(31),
	1056: uint8(255),
	1057: uint8(255),
	1058: uint8(255),
	1059: uint8(255),
	1060: uint8(255),
	1061: uint8(255),
	1062: uint8(127),
	1063: uint8(249),
	1064: uint8(255),
	1065: uint8(3),
	1066: uint8(255),
	1067: uint8(255),
	1068: uint8(255),
	1069: uint8(255),
	1070: uint8(255),
	1071: uint8(255),
	1072: uint8(255),
	1073: uint8(255),
	1074: uint8(255),
	1075: uint8(63),
	1076: uint8(255),
	1077: uint8(255),
	1078: uint8(255),
	1079: uint8(255),
	1080: uint8(191),
	1081: uint8(32),
	1082: uint8(255),
	1083: uint8(255),
	1084: uint8(255),
	1085: uint8(255),
	1086: uint8(255),
	1087: uint8(247),
	1088: uint8(255),
	1089: uint8(255),
	1090: uint8(255),
	1091: uint8(255),
	1092: uint8(255),
	1093: uint8(255),
	1094: uint8(255),
	1095: uint8(255),
	1096: uint8(255),
	1097: uint8(61),
	1098: uint8(127),
	1099: uint8(61),
	1100: uint8(255),
	1101: uint8(255),
	1102: uint8(255),
	1103: uint8(255),
	1104: uint8(255),
	1105: uint8(61),
	1106: uint8(255),
	1107: uint8(255),
	1108: uint8(255),
	1109: uint8(255),
	1110: uint8(61),
	1111: uint8(127),
	1112: uint8(61),
	1113: uint8(255),
	1114: uint8(127),
	1115: uint8(255),
	1116: uint8(255),
	1117: uint8(255),
	1118: uint8(255),
	1119: uint8(255),
	1120: uint8(255),
	1121: uint8(255),
	1122: uint8(61),
	1123: uint8(255),
	1124: uint8(255),
	1125: uint8(255),
	1126: uint8(255),
	1127: uint8(255),
	1128: uint8(255),
	1129: uint8(255),
	1130: uint8(255),
	1131: uint8(7),
	1136: uint8(255),
	1137: uint8(255),
	1140: uint8(255),
	1141: uint8(255),
	1142: uint8(255),
	1143: uint8(255),
	1144: uint8(255),
	1145: uint8(255),
	1146: uint8(255),
	1147: uint8(255),
	1148: uint8(255),
	1149: uint8(255),
	1150: uint8(63),
	1151: uint8(63),
	1152: uint8(254),
	1153: uint8(255),
	1154: uint8(255),
	1155: uint8(255),
	1156: uint8(255),
	1157: uint8(255),
	1158: uint8(255),
	1159: uint8(255),
	1160: uint8(255),
	1161: uint8(255),
	1162: uint8(255),
	1163: uint8(255),
	1164: uint8(255),
	1165: uint8(255),
	1166: uint8(255),
	1167: uint8(255),
	1168: uint8(255),
	1169: uint8(255),
	1170: uint8(255),
	1171: uint8(255),
	1172: uint8(255),
	1173: uint8(255),
	1174: uint8(255),
	1175: uint8(255),
	1176: uint8(255),
	1177: uint8(255),
	1178: uint8(255),
	1179: uint8(255),
	1180: uint8(255),
	1181: uint8(255),
	1182: uint8(255),
	1183: uint8(255),
	1184: uint8(255),
	1185: uint8(255),
	1186: uint8(255),
	1187: uint8(255),
	1188: uint8(255),
	1189: uint8(255),
	1190: uint8(255),
	1191: uint8(255),
	1192: uint8(255),
	1193: uint8(255),
	1194: uint8(255),
	1195: uint8(255),
	1196: uint8(255),
	1197: uint8(159),
	1198: uint8(255),
	1199: uint8(255),
	1200: uint8(254),
	1201: uint8(255),
	1202: uint8(255),
	1203: uint8(7),
	1204: uint8(255),
	1205: uint8(255),
	1206: uint8(255),
	1207: uint8(255),
	1208: uint8(255),
	1209: uint8(255),
	1210: uint8(255),
	1211: uint8(255),
	1212: uint8(255),
	1213: uint8(199),
	1214: uint8(255),
	1215: uint8(1),
	1216: uint8(255),
	1217: uint8(223),
	1218: uint8(15),
	1220: uint8(255),
	1221: uint8(255),
	1222: uint8(15),
	1224: uint8(255),
	1225: uint8(255),
	1226: uint8(15),
	1228: uint8(255),
	1229: uint8(223),
	1230: uint8(13),
	1232: uint8(255),
	1233: uint8(255),
	1234: uint8(255),
	1235: uint8(255),
	1236: uint8(255),
	1237: uint8(255),
	1238: uint8(207),
	1239: uint8(255),
	1240: uint8(255),
	1241: uint8(1),
	1242: uint8(128),
	1243: uint8(16),
	1244: uint8(255),
	1245: uint8(3),
	1250: uint8(255),
	1251: uint8(3),
	1252: uint8(255),
	1253: uint8(255),
	1254: uint8(255),
	1255: uint8(255),
	1256: uint8(255),
	1257: uint8(255),
	1258: uint8(255),
	1259: uint8(255),
	1260: uint8(255),
	1261: uint8(255),
	1262: uint8(255),
	1263: uint8(1),
	1264: uint8(255),
	1265: uint8(255),
	1266: uint8(255),
	1267: uint8(255),
	1268: uint8(255),
	1269: uint8(7),
	1270: uint8(255),
	1271: uint8(255),
	1272: uint8(255),
	1273: uint8(255),
	1274: uint8(255),
	1275: uint8(255),
	1276: uint8(255),
	1277: uint8(255),
	1278: uint8(63),
	1280: uint8(255),
	1281: uint8(255),
	1282: uint8(255),
	1283: uint8(127),
	1284: uint8(255),
	1285: uint8(15),
	1286: uint8(255),
	1287: uint8(1),
	1288: uint8(192),
	1289: uint8(255),
	1290: uint8(255),
	1291: uint8(255),
	1292: uint8(255),
	1293: uint8(63),
	1294: uint8(31),
	1296: uint8(255),
	1297: uint8(255),
	1298: uint8(255),
	1299: uint8(255),
	1300: uint8(255),
	1301: uint8(15),
	1302: uint8(255),
	1303: uint8(255),
	1304: uint8(255),
	1305: uint8(3),
	1306: uint8(255),
	1307: uint8(3),
	1312: uint8(255),
	1313: uint8(255),
	1314: uint8(255),
	1315: uint8(15),
	1316: uint8(255),
	1317: uint8(255),
	1318: uint8(255),
	1319: uint8(255),
	1320: uint8(255),
	1321: uint8(255),
	1322: uint8(255),
	1323: uint8(127),
	1324: uint8(254),
	1325: uint8(255),
	1326: uint8(31),
	1328: uint8(255),
	1329: uint8(3),
	1330: uint8(255),
	1331: uint8(3),
	1332: uint8(128),
	1344: uint8(255),
	1345: uint8(255),
	1346: uint8(255),
	1347: uint8(255),
	1348: uint8(255),
	1349: uint8(255),
	1350: uint8(239),
	1351: uint8(255),
	1352: uint8(239),
	1353: uint8(15),
	1354: uint8(255),
	1355: uint8(3),
	1360: uint8(255),
	1361: uint8(255),
	1362: uint8(255),
	1363: uint8(255),
	1364: uint8(255),
	1365: uint8(243),
	1366: uint8(255),
	1367: uint8(255),
	1368: uint8(255),
	1369: uint8(255),
	1370: uint8(255),
	1371: uint8(255),
	1372: uint8(191),
	1373: uint8(255),
	1374: uint8(3),
	1376: uint8(255),
	1377: uint8(255),
	1378: uint8(255),
	1379: uint8(255),
	1380: uint8(255),
	1381: uint8(255),
	1382: uint8(127),
	1384: uint8(255),
	1385: uint8(227),
	1386: uint8(255),
	1387: uint8(255),
	1388: uint8(255),
	1389: uint8(255),
	1390: uint8(255),
	1391: uint8(63),
	1392: uint8(255),
	1393: uint8(1),
	1394: uint8(255),
	1395: uint8(255),
	1396: uint8(255),
	1397: uint8(255),
	1398: uint8(255),
	1399: uint8(231),
	1405: uint8(222),
	1406: uint8(111),
	1407: uint8(4),
	1408: uint8(255),
	1409: uint8(255),
	1410: uint8(255),
	1411: uint8(255),
	1412: uint8(255),
	1413: uint8(255),
	1414: uint8(255),
	1415: uint8(255),
	1416: uint8(255),
	1417: uint8(255),
	1418: uint8(255),
	1419: uint8(255),
	1420: uint8(255),
	1421: uint8(255),
	1422: uint8(255),
	1423: uint8(255),
	1424: uint8(255),
	1425: uint8(255),
	1426: uint8(255),
	1427: uint8(255),
	1428: uint8(255),
	1429: uint8(255),
	1430: uint8(255),
	1431: uint8(255),
	1436: uint8(128),
	1437: uint8(255),
	1438: uint8(31),
	1440: uint8(255),
	1441: uint8(255),
	1442: uint8(63),
	1443: uint8(63),
	1444: uint8(255),
	1445: uint8(255),
	1446: uint8(255),
	1447: uint8(255),
	1448: uint8(63),
	1449: uint8(63),
	1450: uint8(255),
	1451: uint8(170),
	1452: uint8(255),
	1453: uint8(255),
	1454: uint8(255),
	1455: uint8(63),
	1456: uint8(255),
	1457: uint8(255),
	1458: uint8(255),
	1459: uint8(255),
	1460: uint8(255),
	1461: uint8(255),
	1462: uint8(223),
	1463: uint8(95),
	1464: uint8(220),
	1465: uint8(31),
	1466: uint8(207),
	1467: uint8(15),
	1468: uint8(255),
	1469: uint8(31),
	1470: uint8(220),
	1471: uint8(31),
	1486: uint8(2),
	1487: uint8(128),
	1490: uint8(255),
	1491: uint8(31),
	1504: uint8(132),
	1505: uint8(252),
	1506: uint8(47),
	1507: uint8(62),
	1508: uint8(80),
	1509: uint8(189),
	1510: uint8(255),
	1511: uint8(243),
	1512: uint8(224),
	1513: uint8(67),
	1516: uint8(255),
	1517: uint8(255),
	1518: uint8(255),
	1519: uint8(255),
	1520: uint8(255),
	1521: uint8(1),
	1558: uint8(192),
	1559: uint8(255),
	1560: uint8(255),
	1561: uint8(255),
	1562: uint8(255),
	1563: uint8(255),
	1564: uint8(255),
	1565: uint8(3),
	1568: uint8(255),
	1569: uint8(255),
	1570: uint8(255),
	1571: uint8(255),
	1572: uint8(255),
	1573: uint8(127),
	1574: uint8(255),
	1575: uint8(255),
	1576: uint8(255),
	1577: uint8(255),
	1578: uint8(255),
	1579: uint8(127),
	1580: uint8(255),
	1581: uint8(255),
	1582: uint8(255),
	1583: uint8(255),
	1584: uint8(255),
	1585: uint8(255),
	1586: uint8(255),
	1587: uint8(255),
	1588: uint8(255),
	1589: uint8(255),
	1590: uint8(255),
	1591: uint8(255),
	1592: uint8(255),
	1593: uint8(255),
	1594: uint8(255),
	1595: uint8(255),
	1596: uint8(31),
	1597: uint8(120),
	1598: uint8(12),
	1600: uint8(255),
	1601: uint8(255),
	1602: uint8(255),
	1603: uint8(255),
	1604: uint8(191),
	1605: uint8(32),
	1606: uint8(255),
	1607: uint8(255),
	1608: uint8(255),
	1609: uint8(255),
	1610: uint8(255),
	1611: uint8(255),
	1612: uint8(255),
	1613: uint8(128),
	1616: uint8(255),
	1617: uint8(255),
	1618: uint8(127),
	1620: uint8(127),
	1621: uint8(127),
	1622: uint8(127),
	1623: uint8(127),
	1624: uint8(127),
	1625: uint8(127),
	1626: uint8(127),
	1627: uint8(127),
	1628: uint8(255),
	1629: uint8(255),
	1630: uint8(255),
	1631: uint8(255),
	1637: uint8(128),
	1664: uint8(224),
	1668: uint8(254),
	1669: uint8(3),
	1670: uint8(62),
	1671: uint8(31),
	1672: uint8(254),
	1673: uint8(255),
	1674: uint8(255),
	1675: uint8(255),
	1676: uint8(255),
	1677: uint8(255),
	1678: uint8(255),
	1679: uint8(255),
	1680: uint8(255),
	1681: uint8(255),
	1682: uint8(127),
	1683: uint8(224),
	1684: uint8(254),
	1685: uint8(255),
	1686: uint8(255),
	1687: uint8(255),
	1688: uint8(255),
	1689: uint8(255),
	1690: uint8(255),
	1691: uint8(255),
	1692: uint8(255),
	1693: uint8(255),
	1694: uint8(255),
	1695: uint8(247),
	1696: uint8(224),
	1697: uint8(255),
	1698: uint8(255),
	1699: uint8(255),
	1700: uint8(255),
	1701: uint8(255),
	1702: uint8(254),
	1703: uint8(255),
	1704: uint8(255),
	1705: uint8(255),
	1706: uint8(255),
	1707: uint8(255),
	1708: uint8(255),
	1709: uint8(255),
	1710: uint8(255),
	1711: uint8(255),
	1712: uint8(255),
	1713: uint8(127),
	1716: uint8(255),
	1717: uint8(255),
	1718: uint8(255),
	1719: uint8(7),
	1726: uint8(255),
	1727: uint8(255),
	1728: uint8(255),
	1729: uint8(255),
	1730: uint8(255),
	1731: uint8(255),
	1732: uint8(255),
	1733: uint8(255),
	1734: uint8(255),
	1735: uint8(255),
	1736: uint8(255),
	1737: uint8(255),
	1738: uint8(255),
	1739: uint8(255),
	1740: uint8(255),
	1741: uint8(255),
	1742: uint8(255),
	1743: uint8(255),
	1744: uint8(255),
	1745: uint8(255),
	1746: uint8(255),
	1747: uint8(255),
	1748: uint8(255),
	1749: uint8(255),
	1750: uint8(63),
	1760: uint8(255),
	1761: uint8(255),
	1762: uint8(255),
	1763: uint8(255),
	1764: uint8(255),
	1765: uint8(255),
	1766: uint8(255),
	1767: uint8(255),
	1768: uint8(255),
	1769: uint8(255),
	1770: uint8(255),
	1771: uint8(255),
	1772: uint8(255),
	1773: uint8(255),
	1774: uint8(255),
	1775: uint8(255),
	1776: uint8(255),
	1777: uint8(255),
	1778: uint8(255),
	1779: uint8(255),
	1780: uint8(255),
	1781: uint8(255),
	1782: uint8(255),
	1783: uint8(255),
	1784: uint8(255),
	1785: uint8(255),
	1786: uint8(255),
	1787: uint8(255),
	1788: uint8(255),
	1789: uint8(255),
	1792: uint8(255),
	1793: uint8(255),
	1794: uint8(255),
	1795: uint8(255),
	1796: uint8(255),
	1797: uint8(255),
	1798: uint8(255),
	1799: uint8(255),
	1800: uint8(255),
	1801: uint8(255),
	1802: uint8(255),
	1803: uint8(255),
	1804: uint8(255),
	1805: uint8(255),
	1806: uint8(255),
	1807: uint8(255),
	1808: uint8(255),
	1809: uint8(31),
	1818: uint8(255),
	1819: uint8(255),
	1820: uint8(255),
	1821: uint8(255),
	1822: uint8(255),
	1823: uint8(63),
	1824: uint8(255),
	1825: uint8(31),
	1826: uint8(255),
	1827: uint8(255),
	1828: uint8(255),
	1829: uint8(15),
	1832: uint8(255),
	1833: uint8(255),
	1834: uint8(255),
	1835: uint8(255),
	1836: uint8(255),
	1837: uint8(127),
	1838: uint8(240),
	1839: uint8(143),
	1840: uint8(255),
	1841: uint8(255),
	1842: uint8(255),
	1843: uint8(255),
	1844: uint8(255),
	1845: uint8(255),
	1846: uint8(255),
	1847: uint8(255),
	1848: uint8(255),
	1849: uint8(255),
	1850: uint8(255),
	1851: uint8(255),
	1852: uint8(255),
	1853: uint8(255),
	1858: uint8(128),
	1859: uint8(255),
	1860: uint8(252),
	1861: uint8(255),
	1862: uint8(255),
	1863: uint8(255),
	1864: uint8(255),
	1865: uint8(255),
	1866: uint8(255),
	1867: uint8(255),
	1868: uint8(255),
	1869: uint8(255),
	1870: uint8(255),
	1871: uint8(255),
	1872: uint8(255),
	1873: uint8(249),
	1874: uint8(255),
	1875: uint8(255),
	1876: uint8(255),
	1877: uint8(255),
	1878: uint8(255),
	1879: uint8(255),
	1880: uint8(124),
	1886: uint8(128),
	1887: uint8(255),
	1888: uint8(191),
	1889: uint8(255),
	1890: uint8(255),
	1891: uint8(255),
	1892: uint8(255),
	1896: uint8(255),
	1897: uint8(255),
	1898: uint8(255),
	1899: uint8(255),
	1900: uint8(255),
	1901: uint8(255),
	1902: uint8(15),
	1904: uint8(255),
	1905: uint8(255),
	1906: uint8(255),
	1907: uint8(255),
	1908: uint8(255),
	1909: uint8(255),
	1910: uint8(255),
	1911: uint8(255),
	1912: uint8(47),
	1914: uint8(255),
	1915: uint8(3),
	1918: uint8(252),
	1919: uint8(232),
	1920: uint8(255),
	1921: uint8(255),
	1922: uint8(255),
	1923: uint8(255),
	1924: uint8(255),
	1925: uint8(7),
	1926: uint8(255),
	1927: uint8(255),
	1928: uint8(255),
	1929: uint8(255),
	1930: uint8(7),
	1932: uint8(255),
	1933: uint8(255),
	1934: uint8(255),
	1935: uint8(31),
	1936: uint8(255),
	1937: uint8(255),
	1938: uint8(255),
	1939: uint8(255),
	1940: uint8(255),
	1941: uint8(255),
	1942: uint8(247),
	1943: uint8(255),
	1945: uint8(128),
	1946: uint8(255),
	1947: uint8(3),
	1948: uint8(255),
	1949: uint8(255),
	1950: uint8(255),
	1951: uint8(127),
	1952: uint8(255),
	1953: uint8(255),
	1954: uint8(255),
	1955: uint8(255),
	1956: uint8(255),
	1957: uint8(255),
	1958: uint8(127),
	1960: uint8(255),
	1961: uint8(63),
	1962: uint8(255),
	1963: uint8(3),
	1964: uint8(255),
	1965: uint8(255),
	1966: uint8(127),
	1967: uint8(252),
	1968: uint8(255),
	1969: uint8(255),
	1970: uint8(255),
	1971: uint8(255),
	1972: uint8(255),
	1973: uint8(255),
	1974: uint8(255),
	1975: uint8(127),
	1976: uint8(5),
	1979: uint8(56),
	1980: uint8(255),
	1981: uint8(255),
	1982: uint8(60),
	1984: uint8(126),
	1985: uint8(126),
	1986: uint8(126),
	1988: uint8(127),
	1989: uint8(127),
	1990: uint8(255),
	1991: uint8(255),
	1992: uint8(255),
	1993: uint8(255),
	1994: uint8(255),
	1995: uint8(247),
	1996: uint8(255),
	1998: uint8(255),
	1999: uint8(255),
	2000: uint8(255),
	2001: uint8(255),
	2002: uint8(255),
	2003: uint8(255),
	2004: uint8(255),
	2005: uint8(255),
	2006: uint8(255),
	2007: uint8(255),
	2008: uint8(255),
	2009: uint8(255),
	2010: uint8(255),
	2011: uint8(255),
	2012: uint8(255),
	2013: uint8(7),
	2014: uint8(255),
	2015: uint8(3),
	2016: uint8(255),
	2017: uint8(255),
	2018: uint8(255),
	2019: uint8(255),
	2020: uint8(255),
	2021: uint8(255),
	2022: uint8(255),
	2023: uint8(255),
	2024: uint8(255),
	2025: uint8(255),
	2026: uint8(255),
	2027: uint8(255),
	2028: uint8(255),
	2029: uint8(255),
	2030: uint8(255),
	2031: uint8(255),
	2032: uint8(255),
	2033: uint8(255),
	2034: uint8(255),
	2035: uint8(255),
	2036: uint8(15),
	2038: uint8(255),
	2039: uint8(255),
	2040: uint8(127),
	2041: uint8(248),
	2042: uint8(255),
	2043: uint8(255),
	2044: uint8(255),
	2045: uint8(255),
	2046: uint8(255),
	2047: uint8(15),
	2048: uint8(255),
	2049: uint8(255),
	2050: uint8(255),
	2051: uint8(255),
	2052: uint8(255),
	2053: uint8(255),
	2054: uint8(255),
	2055: uint8(255),
	2056: uint8(255),
	2057: uint8(255),
	2058: uint8(255),
	2059: uint8(255),
	2060: uint8(255),
	2061: uint8(63),
	2062: uint8(255),
	2063: uint8(255),
	2064: uint8(255),
	2065: uint8(255),
	2066: uint8(255),
	2067: uint8(255),
	2068: uint8(255),
	2069: uint8(255),
	2070: uint8(255),
	2071: uint8(255),
	2072: uint8(255),
	2073: uint8(255),
	2074: uint8(255),
	2075: uint8(3),
	2080: uint8(127),
	2082: uint8(248),
	2083: uint8(224),
	2084: uint8(255),
	2085: uint8(253),
	2086: uint8(127),
	2087: uint8(95),
	2088: uint8(219),
	2089: uint8(255),
	2090: uint8(255),
	2091: uint8(255),
	2092: uint8(255),
	2093: uint8(255),
	2094: uint8(255),
	2095: uint8(255),
	2096: uint8(255),
	2097: uint8(255),
	2098: uint8(255),
	2099: uint8(255),
	2100: uint8(255),
	2101: uint8(255),
	2102: uint8(3),
	2106: uint8(248),
	2107: uint8(255),
	2108: uint8(255),
	2109: uint8(255),
	2110: uint8(255),
	2111: uint8(255),
	2112: uint8(255),
	2113: uint8(255),
	2114: uint8(255),
	2115: uint8(255),
	2116: uint8(255),
	2117: uint8(255),
	2118: uint8(255),
	2119: uint8(63),
	2122: uint8(255),
	2123: uint8(255),
	2124: uint8(255),
	2125: uint8(255),
	2126: uint8(255),
	2127: uint8(255),
	2128: uint8(255),
	2129: uint8(255),
	2130: uint8(252),
	2131: uint8(255),
	2132: uint8(255),
	2133: uint8(255),
	2134: uint8(255),
	2135: uint8(255),
	2136: uint8(255),
	2142: uint8(255),
	2143: uint8(15),
	2158: uint8(223),
	2159: uint8(255),
	2160: uint8(255),
	2161: uint8(255),
	2162: uint8(255),
	2163: uint8(255),
	2164: uint8(255),
	2165: uint8(255),
	2166: uint8(255),
	2167: uint8(255),
	2168: uint8(255),
	2169: uint8(255),
	2170: uint8(255),
	2171: uint8(255),
	2172: uint8(255),
	2173: uint8(255),
	2174: uint8(255),
	2175: uint8(31),
	2178: uint8(255),
	2179: uint8(3),
	2180: uint8(254),
	2181: uint8(255),
	2182: uint8(255),
	2183: uint8(7),
	2184: uint8(254),
	2185: uint8(255),
	2186: uint8(255),
	2187: uint8(7),
	2188: uint8(192),
	2189: uint8(255),
	2190: uint8(255),
	2191: uint8(255),
	2192: uint8(255),
	2193: uint8(255),
	2194: uint8(255),
	2195: uint8(255),
	2196: uint8(255),
	2197: uint8(255),
	2198: uint8(255),
	2199: uint8(127),
	2200: uint8(252),
	2201: uint8(252),
	2202: uint8(252),
	2203: uint8(28),
	2208: uint8(255),
	2209: uint8(239),
	2210: uint8(255),
	2211: uint8(255),
	2212: uint8(127),
	2213: uint8(255),
	2214: uint8(255),
	2215: uint8(183),
	2216: uint8(255),
	2217: uint8(63),
	2218: uint8(255),
	2219: uint8(63),
	2224: uint8(255),
	2225: uint8(255),
	2226: uint8(255),
	2227: uint8(255),
	2228: uint8(255),
	2229: uint8(255),
	2230: uint8(255),
	2231: uint8(255),
	2232: uint8(255),
	2233: uint8(255),
	2234: uint8(255),
	2235: uint8(255),
	2236: uint8(255),
	2237: uint8(255),
	2238: uint8(255),
	2239: uint8(7),
	2248: uint8(255),
	2249: uint8(255),
	2250: uint8(255),
	2251: uint8(255),
	2252: uint8(255),
	2253: uint8(255),
	2254: uint8(31),
	2288: uint8(255),
	2289: uint8(255),
	2290: uint8(255),
	2291: uint8(31),
	2292: uint8(255),
	2293: uint8(255),
	2294: uint8(255),
	2295: uint8(255),
	2296: uint8(255),
	2297: uint8(255),
	2298: uint8(1),
	2304: uint8(255),
	2305: uint8(255),
	2306: uint8(255),
	2307: uint8(255),
	2309: uint8(224),
	2310: uint8(255),
	2311: uint8(255),
	2312: uint8(255),
	2313: uint8(7),
	2314: uint8(255),
	2315: uint8(255),
	2316: uint8(255),
	2317: uint8(255),
	2318: uint8(255),
	2319: uint8(7),
	2320: uint8(255),
	2321: uint8(255),
	2322: uint8(255),
	2323: uint8(63),
	2324: uint8(255),
	2325: uint8(255),
	2326: uint8(255),
	2327: uint8(255),
	2328: uint8(15),
	2329: uint8(255),
	2330: uint8(62),
	2336: uint8(255),
	2337: uint8(255),
	2338: uint8(255),
	2339: uint8(255),
	2340: uint8(255),
	2341: uint8(255),
	2342: uint8(255),
	2343: uint8(255),
	2344: uint8(255),
	2345: uint8(255),
	2346: uint8(255),
	2347: uint8(255),
	2348: uint8(255),
	2349: uint8(255),
	2350: uint8(255),
	2351: uint8(255),
	2352: uint8(255),
	2353: uint8(255),
	2354: uint8(255),
	2355: uint8(63),
	2356: uint8(255),
	2357: uint8(3),
	2358: uint8(255),
	2359: uint8(255),
	2360: uint8(255),
	2361: uint8(255),
	2362: uint8(15),
	2363: uint8(255),
	2364: uint8(255),
	2365: uint8(255),
	2366: uint8(255),
	2367: uint8(15),
	2368: uint8(255),
	2369: uint8(255),
	2370: uint8(255),
	2371: uint8(255),
	2372: uint8(255),
	2374: uint8(255),
	2375: uint8(255),
	2376: uint8(255),
	2377: uint8(255),
	2378: uint8(255),
	2379: uint8(255),
	2380: uint8(15),
	2400: uint8(255),
	2401: uint8(255),
	2402: uint8(255),
	2403: uint8(255),
	2404: uint8(255),
	2405: uint8(255),
	2406: uint8(127),
	2408: uint8(255),
	2409: uint8(255),
	2410: uint8(63),
	2412: uint8(255),
	2432: uint8(63),
	2433: uint8(253),
	2434: uint8(255),
	2435: uint8(255),
	2436: uint8(255),
	2437: uint8(255),
	2438: uint8(191),
	2439: uint8(145),
	2440: uint8(255),
	2441: uint8(255),
	2442: uint8(63),
	2444: uint8(255),
	2445: uint8(255),
	2446: uint8(127),
	2448: uint8(255),
	2449: uint8(255),
	2450: uint8(255),
	2451: uint8(127),
	2460: uint8(255),
	2461: uint8(255),
	2462: uint8(55),
	2464: uint8(255),
	2465: uint8(255),
	2466: uint8(63),
	2468: uint8(255),
	2469: uint8(255),
	2470: uint8(255),
	2471: uint8(3),
	2480: uint8(255),
	2481: uint8(255),
	2482: uint8(255),
	2483: uint8(255),
	2484: uint8(255),
	2485: uint8(255),
	2486: uint8(255),
	2487: uint8(192),
	2496: uint8(111),
	2497: uint8(240),
	2498: uint8(239),
	2499: uint8(254),
	2500: uint8(255),
	2501: uint8(255),
	2502: uint8(63),
	2508: uint8(255),
	2509: uint8(255),
	2510: uint8(255),
	2511: uint8(31),
	2512: uint8(255),
	2513: uint8(255),
	2514: uint8(255),
	2515: uint8(31),
	2520: uint8(255),
	2521: uint8(254),
	2522: uint8(255),
	2523: uint8(255),
	2524: uint8(31),
	2528: uint8(255),
	2529: uint8(255),
	2530: uint8(255),
	2531: uint8(255),
	2532: uint8(255),
	2533: uint8(255),
	2534: uint8(63),
	2536: uint8(255),
	2537: uint8(255),
	2538: uint8(63),
	2540: uint8(255),
	2541: uint8(255),
	2542: uint8(7),
	2544: uint8(255),
	2545: uint8(255),
	2546: uint8(3),
	2560: uint8(255),
	2561: uint8(255),
	2562: uint8(255),
	2563: uint8(255),
	2564: uint8(255),
	2565: uint8(255),
	2566: uint8(255),
	2567: uint8(255),
	2568: uint8(255),
	2569: uint8(1),
	2576: uint8(255),
	2577: uint8(255),
	2578: uint8(255),
	2579: uint8(255),
	2580: uint8(255),
	2581: uint8(255),
	2582: uint8(7),
	2584: uint8(255),
	2585: uint8(255),
	2586: uint8(255),
	2587: uint8(255),
	2588: uint8(255),
	2589: uint8(255),
	2590: uint8(7),
	2592: uint8(255),
	2593: uint8(255),
	2594: uint8(255),
	2595: uint8(255),
	2596: uint8(255),
	2598: uint8(255),
	2599: uint8(3),
	2624: uint8(255),
	2625: uint8(255),
	2626: uint8(255),
	2627: uint8(31),
	2628: uint8(128),
	2630: uint8(255),
	2631: uint8(255),
	2632: uint8(63),
	2652: uint8(255),
	2653: uint8(255),
	2654: uint8(127),
	2656: uint8(255),
	2657: uint8(255),
	2658: uint8(255),
	2659: uint8(255),
	2660: uint8(255),
	2661: uint8(255),
	2662: uint8(255),
	2663: uint8(255),
	2664: uint8(63),
	2668: uint8(192),
	2669: uint8(255),
	2672: uint8(252),
	2673: uint8(255),
	2674: uint8(255),
	2675: uint8(255),
	2676: uint8(255),
	2677: uint8(255),
	2678: uint8(255),
	2679: uint8(1),
	2682: uint8(255),
	2683: uint8(255),
	2684: uint8(255),
	2685: uint8(1),
	2686: uint8(255),
	2687: uint8(3),
	2688: uint8(255),
	2689: uint8(255),
	2690: uint8(255),
	2691: uint8(255),
	2692: uint8(255),
	2693: uint8(255),
	2694: uint8(199),
	2695: uint8(255),
	2696: uint8(112),
	2698: uint8(255),
	2699: uint8(255),
	2700: uint8(255),
	2701: uint8(255),
	2702: uint8(71),
	2704: uint8(255),
	2705: uint8(255),
	2706: uint8(255),
	2707: uint8(255),
	2708: uint8(255),
	2709: uint8(255),
	2710: uint8(255),
	2711: uint8(255),
	2712: uint8(30),
	2714: uint8(255),
	2715: uint8(23),
	2720: uint8(255),
	2721: uint8(255),
	2722: uint8(251),
	2723: uint8(255),
	2724: uint8(255),
	2725: uint8(255),
	2726: uint8(159),
	2727: uint8(64),
	2736: uint8(127),
	2737: uint8(189),
	2738: uint8(255),
	2739: uint8(191),
	2740: uint8(255),
	2741: uint8(1),
	2742: uint8(255),
	2743: uint8(255),
	2744: uint8(255),
	2745: uint8(255),
	2746: uint8(255),
	2747: uint8(255),
	2748: uint8(255),
	2749: uint8(1),
	2750: uint8(255),
	2751: uint8(3),
	2752: uint8(239),
	2753: uint8(159),
	2754: uint8(249),
	2755: uint8(255),
	2756: uint8(255),
	2757: uint8(253),
	2758: uint8(237),
	2759: uint8(227),
	2760: uint8(159),
	2761: uint8(25),
	2762: uint8(129),
	2763: uint8(224),
	2764: uint8(15),
	2784: uint8(255),
	2785: uint8(255),
	2786: uint8(255),
	2787: uint8(255),
	2788: uint8(255),
	2789: uint8(255),
	2790: uint8(255),
	2791: uint8(255),
	2792: uint8(187),
	2793: uint8(7),
	2794: uint8(255),
	2795: uint8(131),
	2800: uint8(255),
	2801: uint8(255),
	2802: uint8(255),
	2803: uint8(255),
	2804: uint8(255),
	2805: uint8(255),
	2806: uint8(255),
	2807: uint8(255),
	2808: uint8(179),
	2810: uint8(255),
	2811: uint8(3),
	2832: uint8(255),
	2833: uint8(255),
	2834: uint8(255),
	2835: uint8(255),
	2836: uint8(255),
	2837: uint8(255),
	2838: uint8(63),
	2839: uint8(127),
	2843: uint8(63),
	2848: uint8(255),
	2849: uint8(255),
	2850: uint8(255),
	2851: uint8(255),
	2852: uint8(255),
	2853: uint8(255),
	2854: uint8(255),
	2855: uint8(127),
	2856: uint8(17),
	2858: uint8(255),
	2859: uint8(3),
	2864: uint8(255),
	2865: uint8(255),
	2866: uint8(255),
	2867: uint8(255),
	2868: uint8(255),
	2869: uint8(255),
	2870: uint8(63),
	2871: uint8(1),
	2872: uint8(255),
	2873: uint8(3),
	2880: uint8(255),
	2881: uint8(255),
	2882: uint8(255),
	2883: uint8(231),
	2884: uint8(255),
	2885: uint8(7),
	2886: uint8(255),
	2887: uint8(3),
	2912: uint8(255),
	2913: uint8(255),
	2914: uint8(255),
	2915: uint8(255),
	2916: uint8(255),
	2917: uint8(255),
	2918: uint8(255),
	2919: uint8(1),
	2932: uint8(255),
	2933: uint8(255),
	2934: uint8(255),
	2935: uint8(255),
	2936: uint8(255),
	2937: uint8(255),
	2938: uint8(255),
	2939: uint8(255),
	2940: uint8(255),
	2941: uint8(3),
	2943: uint8(128),
	2964: uint8(255),
	2965: uint8(252),
	2966: uint8(255),
	2967: uint8(255),
	2968: uint8(255),
	2969: uint8(255),
	2970: uint8(255),
	2971: uint8(252),
	2972: uint8(26),
	2976: uint8(255),
	2977: uint8(255),
	2978: uint8(255),
	2979: uint8(255),
	2980: uint8(255),
	2981: uint8(255),
	2982: uint8(231),
	2983: uint8(127),
	2986: uint8(255),
	2987: uint8(255),
	2988: uint8(255),
	2989: uint8(255),
	2990: uint8(255),
	2991: uint8(255),
	2992: uint8(255),
	2993: uint8(255),
	2994: uint8(255),
	2995: uint8(32),
	3000: uint8(255),
	3001: uint8(255),
	3002: uint8(255),
	3003: uint8(255),
	3004: uint8(255),
	3005: uint8(255),
	3006: uint8(255),
	3007: uint8(1),
	3008: uint8(255),
	3009: uint8(253),
	3010: uint8(255),
	3011: uint8(255),
	3012: uint8(255),
	3013: uint8(255),
	3014: uint8(127),
	3015: uint8(127),
	3016: uint8(1),
	3018: uint8(255),
	3019: uint8(3),
	3022: uint8(252),
	3023: uint8(255),
	3024: uint8(255),
	3025: uint8(255),
	3026: uint8(252),
	3027: uint8(255),
	3028: uint8(255),
	3029: uint8(254),
	3030: uint8(127),
	3040: uint8(127),
	3041: uint8(251),
	3042: uint8(255),
	3043: uint8(255),
	3044: uint8(255),
	3045: uint8(255),
	3046: uint8(127),
	3047: uint8(180),
	3048: uint8(203),
	3050: uint8(255),
	3051: uint8(3),
	3052: uint8(191),
	3053: uint8(253),
	3054: uint8(255),
	3055: uint8(255),
	3056: uint8(255),
	3057: uint8(127),
	3058: uint8(123),
	3059: uint8(1),
	3060: uint8(255),
	3061: uint8(3),
	3100: uint8(255),
	3101: uint8(255),
	3102: uint8(127),
	3104: uint8(255),
	3105: uint8(255),
	3106: uint8(255),
	3107: uint8(255),
	3108: uint8(255),
	3109: uint8(255),
	3110: uint8(255),
	3111: uint8(255),
	3112: uint8(255),
	3113: uint8(255),
	3114: uint8(255),
	3115: uint8(255),
	3116: uint8(255),
	3117: uint8(255),
	3118: uint8(255),
	3119: uint8(255),
	3120: uint8(255),
	3121: uint8(255),
	3122: uint8(255),
	3123: uint8(3),
	3136: uint8(255),
	3137: uint8(255),
	3138: uint8(255),
	3139: uint8(255),
	3140: uint8(255),
	3141: uint8(255),
	3142: uint8(255),
	3143: uint8(255),
	3144: uint8(255),
	3145: uint8(255),
	3146: uint8(255),
	3147: uint8(255),
	3148: uint8(255),
	3149: uint8(127),
	3152: uint8(255),
	3153: uint8(255),
	3154: uint8(255),
	3155: uint8(255),
	3156: uint8(255),
	3157: uint8(255),
	3158: uint8(255),
	3159: uint8(255),
	3160: uint8(255),
	3161: uint8(255),
	3162: uint8(255),
	3163: uint8(255),
	3164: uint8(255),
	3165: uint8(255),
	3166: uint8(255),
	3167: uint8(255),
	3168: uint8(255),
	3169: uint8(255),
	3170: uint8(255),
	3171: uint8(255),
	3172: uint8(255),
	3173: uint8(255),
	3174: uint8(255),
	3175: uint8(255),
	3176: uint8(15),
	3200: uint8(255),
	3201: uint8(255),
	3202: uint8(255),
	3203: uint8(255),
	3204: uint8(255),
	3205: uint8(127),
	3232: uint8(255),
	3233: uint8(255),
	3234: uint8(255),
	3235: uint8(255),
	3236: uint8(255),
	3237: uint8(255),
	3238: uint8(255),
	3239: uint8(255),
	3240: uint8(127),
	3264: uint8(255),
	3265: uint8(255),
	3266: uint8(255),
	3267: uint8(255),
	3268: uint8(255),
	3269: uint8(255),
	3270: uint8(255),
	3271: uint8(1),
	3272: uint8(255),
	3273: uint8(255),
	3274: uint8(255),
	3275: uint8(127),
	3276: uint8(255),
	3277: uint8(3),
	3290: uint8(255),
	3291: uint8(255),
	3292: uint8(255),
	3293: uint8(63),
	3296: uint8(255),
	3297: uint8(255),
	3298: uint8(255),
	3299: uint8(255),
	3300: uint8(255),
	3301: uint8(255),
	3304: uint8(15),
	3306: uint8(255),
	3307: uint8(3),
	3308: uint8(248),
	3309: uint8(255),
	3310: uint8(255),
	3311: uint8(224),
	3312: uint8(255),
	3313: uint8(255),
	3336: uint8(255),
	3337: uint8(255),
	3338: uint8(255),
	3339: uint8(255),
	3340: uint8(255),
	3341: uint8(255),
	3342: uint8(255),
	3343: uint8(255),
	3360: uint8(255),
	3361: uint8(255),
	3362: uint8(255),
	3363: uint8(255),
	3364: uint8(255),
	3365: uint8(255),
	3366: uint8(255),
	3367: uint8(255),
	3368: uint8(255),
	3369: uint8(135),
	3370: uint8(255),
	3371: uint8(255),
	3372: uint8(255),
	3373: uint8(255),
	3374: uint8(255),
	3375: uint8(255),
	3376: uint8(255),
	3377: uint8(128),
	3378: uint8(255),
	3379: uint8(255),
	3388: uint8(11),
	3392: uint8(255),
	3393: uint8(255),
	3394: uint8(255),
	3395: uint8(255),
	3396: uint8(255),
	3397: uint8(255),
	3398: uint8(255),
	3399: uint8(255),
	3400: uint8(255),
	3401: uint8(255),
	3402: uint8(255),
	3403: uint8(255),
	3404: uint8(255),
	3405: uint8(255),
	3406: uint8(255),
	3407: uint8(255),
	3408: uint8(255),
	3409: uint8(255),
	3410: uint8(255),
	3411: uint8(255),
	3412: uint8(255),
	3413: uint8(255),
	3414: uint8(255),
	3415: uint8(255),
	3416: uint8(255),
	3417: uint8(255),
	3418: uint8(255),
	3419: uint8(255),
	3420: uint8(255),
	3421: uint8(255),
	3422: uint8(255),
	3424: uint8(255),
	3425: uint8(255),
	3426: uint8(255),
	3427: uint8(255),
	3428: uint8(255),
	3429: uint8(255),
	3430: uint8(255),
	3431: uint8(255),
	3432: uint8(255),
	3433: uint8(255),
	3434: uint8(255),
	3435: uint8(255),
	3436: uint8(255),
	3437: uint8(255),
	3438: uint8(255),
	3439: uint8(255),
	3440: uint8(255),
	3441: uint8(255),
	3442: uint8(255),
	3443: uint8(255),
	3444: uint8(255),
	3445: uint8(255),
	3446: uint8(255),
	3447: uint8(255),
	3448: uint8(255),
	3449: uint8(255),
	3450: uint8(255),
	3451: uint8(255),
	3452: uint8(255),
	3453: uint8(255),
	3454: uint8(7),
	3456: uint8(255),
	3457: uint8(255),
	3458: uint8(255),
	3459: uint8(127),
	3466: uint8(7),
	3468: uint8(240),
	3470: uint8(255),
	3471: uint8(255),
	3472: uint8(255),
	3473: uint8(255),
	3474: uint8(255),
	3475: uint8(255),
	3476: uint8(255),
	3477: uint8(255),
	3478: uint8(255),
	3479: uint8(255),
	3480: uint8(255),
	3481: uint8(255),
	3482: uint8(255),
	3483: uint8(255),
	3484: uint8(255),
	3485: uint8(255),
	3486: uint8(255),
	3487: uint8(255),
	3488: uint8(255),
	3489: uint8(255),
	3490: uint8(255),
	3491: uint8(255),
	3492: uint8(255),
	3493: uint8(255),
	3494: uint8(255),
	3495: uint8(255),
	3496: uint8(255),
	3497: uint8(255),
	3498: uint8(255),
	3499: uint8(255),
	3500: uint8(255),
	3501: uint8(255),
	3502: uint8(255),
	3503: uint8(255),
	3504: uint8(255),
	3505: uint8(255),
	3506: uint8(255),
	3507: uint8(255),
	3508: uint8(255),
	3509: uint8(255),
	3510: uint8(255),
	3511: uint8(255),
	3512: uint8(255),
	3513: uint8(255),
	3514: uint8(255),
	3515: uint8(255),
	3516: uint8(255),
	3517: uint8(255),
	3518: uint8(255),
	3519: uint8(15),
	3520: uint8(255),
	3521: uint8(255),
	3522: uint8(255),
	3523: uint8(255),
	3524: uint8(255),
	3525: uint8(255),
	3526: uint8(255),
	3527: uint8(255),
	3528: uint8(255),
	3529: uint8(255),
	3530: uint8(255),
	3531: uint8(255),
	3532: uint8(255),
	3533: uint8(7),
	3534: uint8(255),
	3535: uint8(31),
	3536: uint8(255),
	3537: uint8(1),
	3538: uint8(255),
	3539: uint8(67),
	3552: uint8(255),
	3553: uint8(255),
	3554: uint8(255),
	3555: uint8(255),
	3556: uint8(255),
	3557: uint8(255),
	3558: uint8(255),
	3559: uint8(255),
	3560: uint8(255),
	3561: uint8(255),
	3562: uint8(223),
	3563: uint8(255),
	3564: uint8(255),
	3565: uint8(255),
	3566: uint8(255),
	3567: uint8(255),
	3568: uint8(255),
	3569: uint8(255),
	3570: uint8(255),
	3571: uint8(223),
	3572: uint8(100),
	3573: uint8(222),
	3574: uint8(255),
	3575: uint8(235),
	3576: uint8(239),
	3577: uint8(255),
	3578: uint8(255),
	3579: uint8(255),
	3580: uint8(255),
	3581: uint8(255),
	3582: uint8(255),
	3583: uint8(255),
	3584: uint8(191),
	3585: uint8(231),
	3586: uint8(223),
	3587: uint8(223),
	3588: uint8(255),
	3589: uint8(255),
	3590: uint8(255),
	3591: uint8(123),
	3592: uint8(95),
	3593: uint8(252),
	3594: uint8(253),
	3595: uint8(255),
	3596: uint8(255),
	3597: uint8(255),
	3598: uint8(255),
	3599: uint8(255),
	3600: uint8(255),
	3601: uint8(255),
	3602: uint8(255),
	3603: uint8(255),
	3604: uint8(255),
	3605: uint8(255),
	3606: uint8(255),
	3607: uint8(255),
	3608: uint8(255),
	3609: uint8(255),
	3610: uint8(255),
	3611: uint8(255),
	3612: uint8(255),
	3613: uint8(255),
	3614: uint8(255),
	3615: uint8(255),
	3616: uint8(255),
	3617: uint8(255),
	3618: uint8(255),
	3619: uint8(255),
	3620: uint8(255),
	3621: uint8(255),
	3622: uint8(255),
	3623: uint8(255),
	3624: uint8(255),
	3625: uint8(255),
	3626: uint8(255),
	3627: uint8(255),
	3628: uint8(255),
	3629: uint8(255),
	3630: uint8(255),
	3631: uint8(255),
	3632: uint8(255),
	3633: uint8(255),
	3634: uint8(255),
	3635: uint8(255),
	3636: uint8(63),
	3637: uint8(255),
	3638: uint8(255),
	3639: uint8(255),
	3640: uint8(253),
	3641: uint8(255),
	3642: uint8(255),
	3643: uint8(247),
	3644: uint8(255),
	3645: uint8(255),
	3646: uint8(255),
	3647: uint8(247),
	3648: uint8(255),
	3649: uint8(255),
	3650: uint8(223),
	3651: uint8(255),
	3652: uint8(255),
	3653: uint8(255),
	3654: uint8(223),
	3655: uint8(255),
	3656: uint8(255),
	3657: uint8(127),
	3658: uint8(255),
	3659: uint8(255),
	3660: uint8(255),
	3661: uint8(127),
	3662: uint8(255),
	3663: uint8(255),
	3664: uint8(255),
	3665: uint8(253),
	3666: uint8(255),
	3667: uint8(255),
	3668: uint8(255),
	3669: uint8(253),
	3670: uint8(255),
	3671: uint8(255),
	3672: uint8(247),
	3673: uint8(207),
	3674: uint8(255),
	3675: uint8(255),
	3676: uint8(255),
	3677: uint8(255),
	3678: uint8(255),
	3679: uint8(255),
	3680: uint8(127),
	3681: uint8(255),
	3682: uint8(255),
	3683: uint8(249),
	3684: uint8(219),
	3685: uint8(7),
	3712: uint8(255),
	3713: uint8(255),
	3714: uint8(255),
	3715: uint8(255),
	3716: uint8(255),
	3717: uint8(31),
	3718: uint8(128),
	3719: uint8(63),
	3720: uint8(255),
	3721: uint8(67),
	3768: uint8(255),
	3769: uint8(255),
	3770: uint8(255),
	3771: uint8(255),
	3772: uint8(255),
	3773: uint8(15),
	3774: uint8(255),
	3775: uint8(3),
	3776: uint8(255),
	3777: uint8(255),
	3778: uint8(255),
	3779: uint8(255),
	3780: uint8(255),
	3781: uint8(255),
	3782: uint8(255),
	3783: uint8(255),
	3784: uint8(255),
	3785: uint8(255),
	3786: uint8(255),
	3787: uint8(255),
	3788: uint8(255),
	3789: uint8(255),
	3790: uint8(255),
	3791: uint8(255),
	3792: uint8(255),
	3793: uint8(255),
	3794: uint8(255),
	3795: uint8(255),
	3796: uint8(255),
	3797: uint8(255),
	3798: uint8(255),
	3799: uint8(255),
	3800: uint8(31),
	3808: uint8(255),
	3809: uint8(255),
	3810: uint8(255),
	3811: uint8(255),
	3812: uint8(255),
	3813: uint8(255),
	3814: uint8(255),
	3815: uint8(255),
	3816: uint8(143),
	3817: uint8(8),
	3818: uint8(255),
	3819: uint8(3),
	3840: uint8(239),
	3841: uint8(255),
	3842: uint8(255),
	3843: uint8(255),
	3844: uint8(150),
	3845: uint8(254),
	3846: uint8(247),
	3847: uint8(10),
	3848: uint8(132),
	3849: uint8(234),
	3850: uint8(150),
	3851: uint8(170),
	3852: uint8(150),
	3853: uint8(247),
	3854: uint8(247),
	3855: uint8(94),
	3856: uint8(255),
	3857: uint8(251),
	3858: uint8(255),
	3859: uint8(15),
	3860: uint8(238),
	3861: uint8(251),
	3862: uint8(255),
	3863: uint8(15),
	3878: uint8(255),
	3879: uint8(255),
	3880: uint8(255),
	3881: uint8(3),
	3882: uint8(255),
	3883: uint8(255),
	3884: uint8(255),
	3885: uint8(3),
	3886: uint8(255),
	3887: uint8(255),
	3888: uint8(255),
	3889: uint8(3),
}

func Xiswalpha(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if wc < uint32(0x20000) {
		return int32(_table3[uint32(int32(_table3[wc>>int32(8)])*int32(32))+wc&uint32(255)>>int32(3)]) >> (wc & uint32(7)) & int32(1)
	}
	if wc < uint32(0x2fffe) {
		return int32(1)
	}
	return 0
}

func X__iswalpha_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswalpha(tls, c)
}

func Xiswalpha_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswalpha_l(tls, c, l)
}

func Xiswblank(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisblank(tls, int32(wc))
}

func X__iswblank_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswblank(tls, c)
}

func Xiswblank_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswblank_l(tls, c, l)
}

func Xiswcntrl(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(wc < uint32(32) || wc-Uint32FromInt32(0x7f) < uint32(33) || wc-Uint32FromInt32(0x2028) < uint32(2) || wc-Uint32FromInt32(0xfff9) < uint32(3))
}

func X__iswcntrl_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswcntrl(tls, c)
}

func Xiswcntrl_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswcntrl_l(tls, c, l)
}

const WCTYPE_ALNUM = 1
const WCTYPE_ALPHA = 2
const WCTYPE_BLANK = 3
const WCTYPE_CNTRL = 4
const WCTYPE_DIGIT = 5
const WCTYPE_GRAPH = 6
const WCTYPE_LOWER = 7
const WCTYPE_PRINT = 8
const WCTYPE_PUNCT = 9
const WCTYPE_SPACE = 10
const WCTYPE_UPPER = 11
const WCTYPE_XDIGIT = 12

func Xiswctype(tls *TLS, wc Twint_t, type1 Twctype_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v type1=%v, (%v:)", tls, wc, type1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	switch type1 {
	case uint64(WCTYPE_ALNUM):
		return Xiswalnum(tls, wc)
	case uint64(WCTYPE_ALPHA):
		return Xiswalpha(tls, wc)
	case uint64(WCTYPE_BLANK):
		return Xiswblank(tls, wc)
	case uint64(WCTYPE_CNTRL):
		return Xiswcntrl(tls, wc)
	case uint64(WCTYPE_DIGIT):
		return BoolInt32(wc-uint32('0') < uint32(10))
	case uint64(WCTYPE_GRAPH):
		return Xiswgraph(tls, wc)
	case uint64(WCTYPE_LOWER):
		return Xiswlower(tls, wc)
	case uint64(WCTYPE_PRINT):
		return Xiswprint(tls, wc)
	case uint64(WCTYPE_PUNCT):
		return Xiswpunct(tls, wc)
	case uint64(WCTYPE_SPACE):
		return Xiswspace(tls, wc)
	case uint64(WCTYPE_UPPER):
		return Xiswupper(tls, wc)
	case uint64(WCTYPE_XDIGIT):
		return Xiswxdigit(tls, wc)
	}
	return 0
}

func Xwctype(tls *TLS, s uintptr) (r Twctype_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i int32
	var p uintptr
	_, _ = i, p
	i = int32(1)
	p = uintptr(unsafe.Pointer(&_names))
	for {
		if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32(*(*uint8)(unsafe.Pointer(p))) && !(Xstrcmp(tls, s, p) != 0) {
			return uint64(i)
		}
		goto _1
	_1:
		;
		i++
		p += uintptr(6)
	}
	return uint64(0)
}

/* order must match! */
var _names = [73]uint8{'a', 'l', 'n', 'u', 'm', 0, 'a', 'l', 'p', 'h', 'a', 0, 'b', 'l', 'a', 'n', 'k', 0, 'c', 'n', 't', 'r', 'l', 0, 'd', 'i', 'g', 'i', 't', 0, 'g', 'r', 'a', 'p', 'h', 0, 'l', 'o', 'w', 'e', 'r', 0, 'p', 'r', 'i', 'n', 't', 0, 'p', 'u', 'n', 'c', 't', 0, 's', 'p', 'a', 'c', 'e', 0, 'u', 'p', 'p', 'e', 'r', 0, 'x', 'd', 'i', 'g', 'i', 't'}

func X__iswctype_l(tls *TLS, c Twint_t, t Twctype_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v t=%v l=%v, (%v:)", tls, c, t, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswctype(tls, c, t)
}

func X__wctype_l(tls *TLS, s uintptr, l Tlocale_t) (r Twctype_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v l=%v, (%v:)", tls, s, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwctype(tls, s)
}

func Xiswctype_l(tls *TLS, c Twint_t, t Twctype_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v t=%v l=%v, (%v:)", tls, c, t, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswctype_l(tls, c, t, l)
}

func Xwctype_l(tls *TLS, s uintptr, l Tlocale_t) (r Twctype_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v l=%v, (%v:)", tls, s, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__wctype_l(tls, s, l)
}

func Xiswdigit(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(wc-uint32('0') < uint32(10))
}

func X__iswdigit_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswdigit(tls, c)
}

func Xiswdigit_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswdigit_l(tls, c, l)
}

func Xiswgraph(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* ISO C defines this function as: */
	return BoolInt32(!(Xiswspace(tls, wc) != 0) && Xiswprint(tls, wc) != 0)
}

func X__iswgraph_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswgraph(tls, c)
}

func Xiswgraph_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswgraph_l(tls, c, l)
}

func Xiswlower(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(Xtowupper(tls, wc) != wc)
}

func X__iswlower_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswlower(tls, c)
}

func Xiswlower_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswlower_l(tls, c, l)
}

/* Consider all legal codepoints as printable except for:
 * - C0 and C1 control characters
 * - U+2028 and U+2029 (line/para break)
 * - U+FFF9 through U+FFFB (interlinear annotation controls)
 * The following code is optimized heavily to make hot paths for the
 * expected printable characters. */

func Xiswprint(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if wc < uint32(0xff) {
		return BoolInt32((wc+uint32(1))&uint32(0x7f) >= uint32(0x21))
	}
	if wc < uint32(0x2028) || wc-uint32(0x202a) < uint32(Int32FromInt32(0xd800)-Int32FromInt32(0x202a)) || wc-uint32(0xe000) < uint32(Int32FromInt32(0xfff9)-Int32FromInt32(0xe000)) {
		return int32(1)
	}
	if wc-uint32(0xfffc) > uint32(Int32FromInt32(0x10ffff)-Int32FromInt32(0xfffc)) || wc&uint32(0xfffe) == uint32(0xfffe) {
		return 0
	}
	return int32(1)
}

func X__iswprint_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswprint(tls, c)
}

func Xiswprint_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswprint_l(tls, c, l)
}

var _table4 = [4000]uint8{
	0:    uint8(18),
	1:    uint8(16),
	2:    uint8(19),
	3:    uint8(20),
	4:    uint8(21),
	5:    uint8(22),
	6:    uint8(23),
	7:    uint8(24),
	8:    uint8(25),
	9:    uint8(26),
	10:   uint8(27),
	11:   uint8(28),
	12:   uint8(29),
	13:   uint8(30),
	14:   uint8(31),
	15:   uint8(32),
	16:   uint8(33),
	17:   uint8(16),
	18:   uint8(16),
	19:   uint8(34),
	20:   uint8(35),
	21:   uint8(16),
	22:   uint8(36),
	23:   uint8(37),
	24:   uint8(38),
	25:   uint8(39),
	26:   uint8(40),
	27:   uint8(41),
	28:   uint8(42),
	29:   uint8(43),
	30:   uint8(16),
	31:   uint8(44),
	32:   uint8(45),
	33:   uint8(46),
	34:   uint8(17),
	35:   uint8(17),
	36:   uint8(47),
	37:   uint8(17),
	38:   uint8(17),
	39:   uint8(17),
	40:   uint8(17),
	41:   uint8(17),
	42:   uint8(17),
	43:   uint8(48),
	44:   uint8(49),
	45:   uint8(50),
	46:   uint8(51),
	47:   uint8(52),
	48:   uint8(53),
	49:   uint8(54),
	50:   uint8(55),
	51:   uint8(17),
	52:   uint8(16),
	53:   uint8(16),
	54:   uint8(16),
	55:   uint8(16),
	56:   uint8(16),
	57:   uint8(16),
	58:   uint8(16),
	59:   uint8(16),
	60:   uint8(16),
	61:   uint8(16),
	62:   uint8(16),
	63:   uint8(16),
	64:   uint8(16),
	65:   uint8(16),
	66:   uint8(16),
	67:   uint8(16),
	68:   uint8(16),
	69:   uint8(16),
	70:   uint8(16),
	71:   uint8(16),
	72:   uint8(16),
	73:   uint8(16),
	74:   uint8(16),
	75:   uint8(16),
	76:   uint8(16),
	77:   uint8(56),
	78:   uint8(16),
	79:   uint8(16),
	80:   uint8(16),
	81:   uint8(16),
	82:   uint8(16),
	83:   uint8(16),
	84:   uint8(16),
	85:   uint8(16),
	86:   uint8(16),
	87:   uint8(16),
	88:   uint8(16),
	89:   uint8(16),
	90:   uint8(16),
	91:   uint8(16),
	92:   uint8(16),
	93:   uint8(16),
	94:   uint8(16),
	95:   uint8(16),
	96:   uint8(16),
	97:   uint8(16),
	98:   uint8(16),
	99:   uint8(16),
	100:  uint8(16),
	101:  uint8(16),
	102:  uint8(16),
	103:  uint8(16),
	104:  uint8(16),
	105:  uint8(16),
	106:  uint8(16),
	107:  uint8(16),
	108:  uint8(16),
	109:  uint8(16),
	110:  uint8(16),
	111:  uint8(16),
	112:  uint8(16),
	113:  uint8(16),
	114:  uint8(16),
	115:  uint8(16),
	116:  uint8(16),
	117:  uint8(16),
	118:  uint8(16),
	119:  uint8(16),
	120:  uint8(16),
	121:  uint8(16),
	122:  uint8(16),
	123:  uint8(16),
	124:  uint8(16),
	125:  uint8(16),
	126:  uint8(16),
	127:  uint8(16),
	128:  uint8(16),
	129:  uint8(16),
	130:  uint8(16),
	131:  uint8(16),
	132:  uint8(16),
	133:  uint8(16),
	134:  uint8(16),
	135:  uint8(16),
	136:  uint8(16),
	137:  uint8(16),
	138:  uint8(16),
	139:  uint8(16),
	140:  uint8(16),
	141:  uint8(16),
	142:  uint8(16),
	143:  uint8(16),
	144:  uint8(16),
	145:  uint8(16),
	146:  uint8(16),
	147:  uint8(16),
	148:  uint8(16),
	149:  uint8(16),
	150:  uint8(16),
	151:  uint8(16),
	152:  uint8(16),
	153:  uint8(16),
	154:  uint8(16),
	155:  uint8(16),
	156:  uint8(16),
	157:  uint8(16),
	158:  uint8(16),
	159:  uint8(16),
	160:  uint8(16),
	161:  uint8(16),
	162:  uint8(16),
	163:  uint8(16),
	164:  uint8(57),
	165:  uint8(16),
	166:  uint8(58),
	167:  uint8(59),
	168:  uint8(60),
	169:  uint8(61),
	170:  uint8(62),
	171:  uint8(63),
	172:  uint8(16),
	173:  uint8(16),
	174:  uint8(16),
	175:  uint8(16),
	176:  uint8(16),
	177:  uint8(16),
	178:  uint8(16),
	179:  uint8(16),
	180:  uint8(16),
	181:  uint8(16),
	182:  uint8(16),
	183:  uint8(16),
	184:  uint8(16),
	185:  uint8(16),
	186:  uint8(16),
	187:  uint8(16),
	188:  uint8(16),
	189:  uint8(16),
	190:  uint8(16),
	191:  uint8(16),
	192:  uint8(16),
	193:  uint8(16),
	194:  uint8(16),
	195:  uint8(16),
	196:  uint8(16),
	197:  uint8(16),
	198:  uint8(16),
	199:  uint8(16),
	200:  uint8(16),
	201:  uint8(16),
	202:  uint8(16),
	203:  uint8(16),
	204:  uint8(16),
	205:  uint8(16),
	206:  uint8(16),
	207:  uint8(16),
	208:  uint8(16),
	209:  uint8(16),
	210:  uint8(16),
	211:  uint8(16),
	212:  uint8(16),
	213:  uint8(16),
	214:  uint8(16),
	215:  uint8(16),
	216:  uint8(16),
	217:  uint8(16),
	218:  uint8(16),
	219:  uint8(16),
	220:  uint8(16),
	221:  uint8(16),
	222:  uint8(16),
	223:  uint8(16),
	224:  uint8(64),
	225:  uint8(16),
	226:  uint8(16),
	227:  uint8(16),
	228:  uint8(16),
	229:  uint8(16),
	230:  uint8(16),
	231:  uint8(16),
	232:  uint8(16),
	233:  uint8(16),
	234:  uint8(16),
	235:  uint8(16),
	236:  uint8(16),
	237:  uint8(16),
	238:  uint8(16),
	239:  uint8(16),
	240:  uint8(16),
	241:  uint8(16),
	242:  uint8(16),
	243:  uint8(16),
	244:  uint8(16),
	245:  uint8(16),
	246:  uint8(16),
	247:  uint8(16),
	248:  uint8(65),
	249:  uint8(16),
	250:  uint8(16),
	251:  uint8(66),
	252:  uint8(16),
	253:  uint8(67),
	254:  uint8(68),
	255:  uint8(69),
	256:  uint8(16),
	257:  uint8(70),
	258:  uint8(71),
	259:  uint8(72),
	260:  uint8(16),
	261:  uint8(73),
	262:  uint8(16),
	263:  uint8(16),
	264:  uint8(74),
	265:  uint8(75),
	266:  uint8(76),
	267:  uint8(77),
	268:  uint8(78),
	269:  uint8(16),
	270:  uint8(79),
	271:  uint8(80),
	272:  uint8(81),
	273:  uint8(82),
	274:  uint8(83),
	275:  uint8(84),
	276:  uint8(85),
	277:  uint8(86),
	278:  uint8(87),
	279:  uint8(88),
	280:  uint8(89),
	281:  uint8(90),
	282:  uint8(91),
	283:  uint8(16),
	284:  uint8(92),
	285:  uint8(93),
	286:  uint8(94),
	287:  uint8(95),
	288:  uint8(16),
	289:  uint8(16),
	290:  uint8(16),
	291:  uint8(16),
	292:  uint8(96),
	293:  uint8(16),
	294:  uint8(16),
	295:  uint8(16),
	296:  uint8(16),
	297:  uint8(16),
	298:  uint8(16),
	299:  uint8(16),
	300:  uint8(16),
	301:  uint8(16),
	302:  uint8(16),
	303:  uint8(16),
	304:  uint8(16),
	305:  uint8(16),
	306:  uint8(16),
	307:  uint8(16),
	308:  uint8(97),
	309:  uint8(16),
	310:  uint8(16),
	311:  uint8(16),
	312:  uint8(16),
	313:  uint8(16),
	314:  uint8(16),
	315:  uint8(16),
	316:  uint8(16),
	317:  uint8(16),
	318:  uint8(16),
	319:  uint8(16),
	320:  uint8(16),
	321:  uint8(16),
	322:  uint8(16),
	323:  uint8(16),
	324:  uint8(16),
	325:  uint8(16),
	326:  uint8(16),
	327:  uint8(16),
	328:  uint8(16),
	329:  uint8(16),
	330:  uint8(16),
	331:  uint8(16),
	332:  uint8(16),
	333:  uint8(16),
	334:  uint8(16),
	335:  uint8(16),
	336:  uint8(16),
	337:  uint8(16),
	338:  uint8(16),
	339:  uint8(16),
	340:  uint8(16),
	341:  uint8(16),
	342:  uint8(16),
	343:  uint8(16),
	344:  uint8(16),
	345:  uint8(16),
	346:  uint8(16),
	347:  uint8(16),
	348:  uint8(16),
	349:  uint8(16),
	350:  uint8(16),
	351:  uint8(16),
	352:  uint8(16),
	353:  uint8(16),
	354:  uint8(16),
	355:  uint8(16),
	356:  uint8(16),
	357:  uint8(16),
	358:  uint8(16),
	359:  uint8(16),
	360:  uint8(16),
	361:  uint8(16),
	362:  uint8(98),
	363:  uint8(99),
	364:  uint8(16),
	365:  uint8(16),
	366:  uint8(100),
	367:  uint8(101),
	368:  uint8(16),
	369:  uint8(16),
	370:  uint8(16),
	371:  uint8(16),
	372:  uint8(16),
	373:  uint8(16),
	374:  uint8(16),
	375:  uint8(16),
	376:  uint8(16),
	377:  uint8(16),
	378:  uint8(16),
	379:  uint8(16),
	380:  uint8(16),
	381:  uint8(16),
	382:  uint8(16),
	383:  uint8(16),
	384:  uint8(16),
	385:  uint8(16),
	386:  uint8(16),
	387:  uint8(16),
	388:  uint8(16),
	389:  uint8(16),
	390:  uint8(16),
	391:  uint8(16),
	392:  uint8(16),
	393:  uint8(16),
	394:  uint8(16),
	395:  uint8(16),
	396:  uint8(16),
	397:  uint8(16),
	398:  uint8(16),
	399:  uint8(16),
	400:  uint8(16),
	401:  uint8(16),
	402:  uint8(16),
	403:  uint8(16),
	404:  uint8(16),
	405:  uint8(16),
	406:  uint8(16),
	407:  uint8(16),
	408:  uint8(16),
	409:  uint8(16),
	410:  uint8(16),
	411:  uint8(16),
	412:  uint8(16),
	413:  uint8(16),
	414:  uint8(16),
	415:  uint8(16),
	416:  uint8(16),
	417:  uint8(16),
	418:  uint8(16),
	419:  uint8(16),
	420:  uint8(16),
	421:  uint8(16),
	422:  uint8(16),
	423:  uint8(16),
	424:  uint8(16),
	425:  uint8(16),
	426:  uint8(16),
	427:  uint8(16),
	428:  uint8(16),
	429:  uint8(16),
	430:  uint8(16),
	431:  uint8(16),
	432:  uint8(16),
	433:  uint8(16),
	434:  uint8(16),
	435:  uint8(16),
	436:  uint8(16),
	437:  uint8(16),
	438:  uint8(16),
	439:  uint8(16),
	440:  uint8(16),
	441:  uint8(16),
	442:  uint8(16),
	443:  uint8(16),
	444:  uint8(102),
	445:  uint8(16),
	446:  uint8(16),
	447:  uint8(16),
	448:  uint8(16),
	449:  uint8(16),
	450:  uint8(16),
	451:  uint8(16),
	452:  uint8(16),
	453:  uint8(16),
	454:  uint8(16),
	455:  uint8(16),
	456:  uint8(16),
	457:  uint8(16),
	458:  uint8(16),
	459:  uint8(16),
	460:  uint8(16),
	461:  uint8(16),
	462:  uint8(16),
	463:  uint8(16),
	464:  uint8(103),
	465:  uint8(104),
	466:  uint8(105),
	467:  uint8(106),
	468:  uint8(16),
	469:  uint8(16),
	470:  uint8(107),
	471:  uint8(108),
	472:  uint8(17),
	473:  uint8(17),
	474:  uint8(109),
	475:  uint8(16),
	476:  uint8(16),
	477:  uint8(16),
	478:  uint8(16),
	479:  uint8(16),
	480:  uint8(16),
	481:  uint8(110),
	482:  uint8(111),
	483:  uint8(16),
	484:  uint8(16),
	485:  uint8(16),
	486:  uint8(16),
	487:  uint8(16),
	488:  uint8(112),
	489:  uint8(113),
	490:  uint8(16),
	491:  uint8(16),
	492:  uint8(114),
	493:  uint8(115),
	494:  uint8(116),
	495:  uint8(16),
	496:  uint8(117),
	497:  uint8(118),
	498:  uint8(119),
	499:  uint8(17),
	500:  uint8(17),
	501:  uint8(17),
	502:  uint8(120),
	503:  uint8(121),
	504:  uint8(122),
	505:  uint8(123),
	506:  uint8(124),
	507:  uint8(16),
	508:  uint8(16),
	509:  uint8(16),
	510:  uint8(16),
	511:  uint8(16),
	544:  uint8(255),
	545:  uint8(255),
	546:  uint8(255),
	547:  uint8(255),
	548:  uint8(255),
	549:  uint8(255),
	550:  uint8(255),
	551:  uint8(255),
	552:  uint8(255),
	553:  uint8(255),
	554:  uint8(255),
	555:  uint8(255),
	556:  uint8(255),
	557:  uint8(255),
	558:  uint8(255),
	559:  uint8(255),
	560:  uint8(255),
	561:  uint8(255),
	562:  uint8(255),
	563:  uint8(255),
	564:  uint8(255),
	565:  uint8(255),
	566:  uint8(255),
	567:  uint8(255),
	568:  uint8(255),
	569:  uint8(255),
	570:  uint8(255),
	571:  uint8(255),
	572:  uint8(255),
	573:  uint8(255),
	574:  uint8(255),
	575:  uint8(255),
	580:  uint8(254),
	581:  uint8(255),
	583:  uint8(252),
	584:  uint8(1),
	587:  uint8(248),
	588:  uint8(1),
	591:  uint8(120),
	596:  uint8(255),
	597:  uint8(251),
	598:  uint8(223),
	599:  uint8(251),
	602:  uint8(128),
	606:  uint8(128),
	632:  uint8(60),
	634:  uint8(252),
	635:  uint8(255),
	636:  uint8(224),
	637:  uint8(175),
	638:  uint8(255),
	639:  uint8(255),
	640:  uint8(255),
	641:  uint8(255),
	642:  uint8(255),
	643:  uint8(255),
	644:  uint8(255),
	645:  uint8(255),
	646:  uint8(255),
	647:  uint8(255),
	648:  uint8(223),
	649:  uint8(255),
	650:  uint8(255),
	651:  uint8(255),
	652:  uint8(255),
	653:  uint8(255),
	654:  uint8(32),
	655:  uint8(64),
	656:  uint8(176),
	670:  uint8(64),
	688:  uint8(252),
	689:  uint8(3),
	715:  uint8(252),
	721:  uint8(230),
	722:  uint8(254),
	723:  uint8(255),
	724:  uint8(255),
	725:  uint8(255),
	727:  uint8(64),
	728:  uint8(73),
	734:  uint8(24),
	736:  uint8(255),
	737:  uint8(255),
	739:  uint8(216),
	747:  uint8(1),
	749:  uint8(60),
	762:  uint8(16),
	763:  uint8(224),
	764:  uint8(1),
	765:  uint8(30),
	767:  uint8(96),
	768:  uint8(255),
	769:  uint8(191),
	776:  uint8(255),
	777:  uint8(7),
	797:  uint8(248),
	798:  uint8(207),
	799:  uint8(227),
	803:  uint8(3),
	805:  uint8(32),
	806:  uint8(255),
	807:  uint8(127),
	811:  uint8(78),
	826:  uint8(8),
	828:  uint8(7),
	829:  uint8(252),
	839:  uint8(16),
	841:  uint8(32),
	842:  uint8(30),
	844:  uint8(48),
	846:  uint8(1),
	855:  uint8(16),
	857:  uint8(32),
	862:  uint8(252),
	863:  uint8(111),
	871:  uint8(16),
	873:  uint8(32),
	878:  uint8(64),
	887:  uint8(16),
	889:  uint8(32),
	894:  uint8(3),
	895:  uint8(224),
	903:  uint8(16),
	905:  uint8(32),
	910:  uint8(253),
	921:  uint8(32),
	926:  uint8(255),
	927:  uint8(7),
	928:  uint8(16),
	937:  uint8(32),
	942:  uint8(128),
	943:  uint8(255),
	944:  uint8(16),
	951:  uint8(16),
	953:  uint8(32),
	967:  uint8(24),
	969:  uint8(160),
	971:  uint8(127),
	974:  uint8(255),
	975:  uint8(3),
	985:  uint8(4),
	990:  uint8(16),
	997:  uint8(128),
	999:  uint8(128),
	1000: uint8(192),
	1001: uint8(223),
	1003: uint8(12),
	1015: uint8(4),
	1017: uint8(31),
	1024: uint8(254),
	1025: uint8(255),
	1026: uint8(255),
	1027: uint8(255),
	1029: uint8(252),
	1030: uint8(255),
	1031: uint8(255),
	1040: uint8(252),
	1047: uint8(192),
	1048: uint8(255),
	1049: uint8(223),
	1050: uint8(255),
	1051: uint8(7),
	1062: uint8(128),
	1063: uint8(6),
	1065: uint8(252),
	1075: uint8(192),
	1087: uint8(8),
	1099: uint8(224),
	1100: uint8(255),
	1101: uint8(255),
	1102: uint8(255),
	1103: uint8(31),
	1106: uint8(255),
	1107: uint8(3),
	1120: uint8(1),
	1165: uint8(96),
	1168: uint8(1),
	1171: uint8(24),
	1181: uint8(56),
	1186: uint8(16),
	1190: uint8(112),
	1206: uint8(48),
	1209: uint8(254),
	1210: uint8(127),
	1211: uint8(47),
	1214: uint8(255),
	1215: uint8(3),
	1216: uint8(255),
	1217: uint8(127),
	1255: uint8(14),
	1256: uint8(49),
	1275: uint8(196),
	1276: uint8(255),
	1277: uint8(255),
	1278: uint8(255),
	1279: uint8(255),
	1283: uint8(192),
	1292: uint8(1),
	1294: uint8(224),
	1295: uint8(159),
	1300: uint8(127),
	1301: uint8(63),
	1302: uint8(255),
	1303: uint8(127),
	1318: uint8(16),
	1320: uint8(16),
	1323: uint8(252),
	1324: uint8(255),
	1325: uint8(255),
	1326: uint8(255),
	1327: uint8(31),
	1333: uint8(12),
	1340: uint8(64),
	1342: uint8(12),
	1343: uint8(240),
	1350: uint8(128),
	1351: uint8(248),
	1359: uint8(192),
	1368: uint8(255),
	1370: uint8(255),
	1371: uint8(255),
	1372: uint8(255),
	1373: uint8(33),
	1374: uint8(144),
	1375: uint8(3),
	1400: uint8(255),
	1401: uint8(255),
	1402: uint8(255),
	1403: uint8(255),
	1404: uint8(127),
	1406: uint8(224),
	1407: uint8(251),
	1431: uint8(160),
	1432: uint8(3),
	1433: uint8(224),
	1435: uint8(224),
	1437: uint8(224),
	1439: uint8(96),
	1440: uint8(128),
	1441: uint8(248),
	1442: uint8(255),
	1443: uint8(255),
	1444: uint8(255),
	1445: uint8(252),
	1446: uint8(255),
	1447: uint8(255),
	1448: uint8(255),
	1449: uint8(255),
	1450: uint8(255),
	1451: uint8(127),
	1452: uint8(223),
	1453: uint8(255),
	1454: uint8(241),
	1455: uint8(127),
	1456: uint8(255),
	1457: uint8(127),
	1460: uint8(255),
	1461: uint8(255),
	1462: uint8(255),
	1463: uint8(255),
	1466: uint8(255),
	1467: uint8(255),
	1468: uint8(255),
	1469: uint8(255),
	1470: uint8(1),
	1472: uint8(123),
	1473: uint8(3),
	1474: uint8(208),
	1475: uint8(193),
	1476: uint8(175),
	1477: uint8(66),
	1479: uint8(12),
	1480: uint8(31),
	1481: uint8(188),
	1482: uint8(255),
	1483: uint8(255),
	1489: uint8(14),
	1490: uint8(255),
	1491: uint8(255),
	1492: uint8(255),
	1493: uint8(255),
	1494: uint8(255),
	1495: uint8(255),
	1496: uint8(255),
	1497: uint8(255),
	1498: uint8(255),
	1499: uint8(255),
	1500: uint8(255),
	1501: uint8(255),
	1502: uint8(255),
	1503: uint8(255),
	1504: uint8(255),
	1505: uint8(255),
	1506: uint8(255),
	1507: uint8(255),
	1508: uint8(127),
	1512: uint8(255),
	1513: uint8(7),
	1516: uint8(255),
	1517: uint8(255),
	1518: uint8(255),
	1519: uint8(255),
	1520: uint8(255),
	1521: uint8(255),
	1522: uint8(255),
	1523: uint8(255),
	1524: uint8(255),
	1525: uint8(255),
	1526: uint8(63),
	1533: uint8(252),
	1534: uint8(255),
	1535: uint8(255),
	1536: uint8(255),
	1537: uint8(255),
	1538: uint8(255),
	1539: uint8(255),
	1540: uint8(255),
	1541: uint8(255),
	1542: uint8(255),
	1543: uint8(255),
	1544: uint8(255),
	1545: uint8(255),
	1546: uint8(255),
	1547: uint8(255),
	1548: uint8(255),
	1549: uint8(255),
	1550: uint8(207),
	1551: uint8(255),
	1552: uint8(255),
	1553: uint8(255),
	1554: uint8(63),
	1555: uint8(255),
	1556: uint8(255),
	1557: uint8(255),
	1558: uint8(255),
	1559: uint8(255),
	1560: uint8(255),
	1561: uint8(255),
	1562: uint8(255),
	1563: uint8(255),
	1564: uint8(255),
	1565: uint8(255),
	1566: uint8(255),
	1567: uint8(255),
	1596: uint8(224),
	1597: uint8(135),
	1598: uint8(3),
	1599: uint8(254),
	1614: uint8(1),
	1615: uint8(128),
	1632: uint8(255),
	1633: uint8(255),
	1634: uint8(255),
	1635: uint8(255),
	1636: uint8(255),
	1637: uint8(127),
	1638: uint8(255),
	1639: uint8(255),
	1640: uint8(255),
	1641: uint8(255),
	1648: uint8(255),
	1649: uint8(255),
	1650: uint8(255),
	1651: uint8(251),
	1652: uint8(255),
	1653: uint8(255),
	1654: uint8(255),
	1655: uint8(255),
	1656: uint8(255),
	1657: uint8(255),
	1658: uint8(255),
	1659: uint8(255),
	1660: uint8(255),
	1661: uint8(255),
	1662: uint8(15),
	1664: uint8(255),
	1665: uint8(255),
	1666: uint8(255),
	1667: uint8(255),
	1668: uint8(255),
	1669: uint8(255),
	1670: uint8(255),
	1671: uint8(255),
	1672: uint8(255),
	1673: uint8(255),
	1674: uint8(255),
	1675: uint8(255),
	1676: uint8(255),
	1677: uint8(255),
	1678: uint8(255),
	1679: uint8(255),
	1680: uint8(255),
	1681: uint8(255),
	1682: uint8(255),
	1683: uint8(255),
	1684: uint8(255),
	1685: uint8(255),
	1686: uint8(255),
	1687: uint8(255),
	1688: uint8(255),
	1689: uint8(255),
	1690: uint8(63),
	1694: uint8(255),
	1695: uint8(15),
	1696: uint8(30),
	1697: uint8(255),
	1698: uint8(255),
	1699: uint8(255),
	1700: uint8(1),
	1701: uint8(252),
	1702: uint8(193),
	1703: uint8(224),
	1715: uint8(30),
	1716: uint8(1),
	1727: uint8(8),
	1746: uint8(255),
	1747: uint8(255),
	1752: uint8(255),
	1753: uint8(255),
	1754: uint8(255),
	1755: uint8(255),
	1756: uint8(15),
	1760: uint8(255),
	1761: uint8(255),
	1762: uint8(255),
	1763: uint8(127),
	1764: uint8(255),
	1765: uint8(255),
	1766: uint8(255),
	1767: uint8(255),
	1768: uint8(255),
	1769: uint8(255),
	1770: uint8(255),
	1771: uint8(255),
	1772: uint8(255),
	1773: uint8(255),
	1774: uint8(255),
	1775: uint8(255),
	1776: uint8(255),
	1777: uint8(255),
	1778: uint8(255),
	1779: uint8(255),
	1780: uint8(255),
	1781: uint8(255),
	1782: uint8(255),
	1783: uint8(255),
	1784: uint8(255),
	1785: uint8(255),
	1786: uint8(255),
	1787: uint8(255),
	1788: uint8(255),
	1789: uint8(255),
	1790: uint8(255),
	1791: uint8(255),
	1816: uint8(255),
	1817: uint8(255),
	1818: uint8(255),
	1819: uint8(255),
	1820: uint8(255),
	1821: uint8(255),
	1822: uint8(255),
	1823: uint8(255),
	1842: uint8(255),
	1843: uint8(255),
	1844: uint8(255),
	1845: uint8(255),
	1846: uint8(255),
	1847: uint8(255),
	1848: uint8(127),
	1855: uint8(192),
	1857: uint8(224),
	1869: uint8(128),
	1870: uint8(15),
	1871: uint8(112),
	1886: uint8(255),
	1888: uint8(255),
	1889: uint8(255),
	1890: uint8(127),
	1892: uint8(3),
	1905: uint8(6),
	1920: uint8(64),
	1925: uint8(15),
	1926: uint8(255),
	1927: uint8(3),
	1934: uint8(240),
	1944: uint8(16),
	1945: uint8(192),
	1948: uint8(255),
	1949: uint8(255),
	1950: uint8(3),
	1951: uint8(23),
	1957: uint8(248),
	1962: uint8(8),
	1963: uint8(128),
	1974: uint8(8),
	1976: uint8(255),
	1977: uint8(63),
	1979: uint8(192),
	1995: uint8(240),
	1998: uint8(128),
	1999: uint8(3),
	2007: uint8(128),
	2008: uint8(2),
	2011: uint8(192),
	2014: uint8(67),
	2027: uint8(8),
	2045: uint8(56),
	2048: uint8(1),
	2111: uint8(128),
	2117: uint8(2),
	2134: uint8(252),
	2135: uint8(255),
	2136: uint8(3),
	2151: uint8(192),
	2175: uint8(48),
	2176: uint8(255),
	2177: uint8(255),
	2178: uint8(255),
	2179: uint8(3),
	2180: uint8(255),
	2181: uint8(255),
	2182: uint8(255),
	2183: uint8(255),
	2184: uint8(255),
	2185: uint8(255),
	2186: uint8(247),
	2187: uint8(255),
	2188: uint8(127),
	2189: uint8(15),
	2207: uint8(128),
	2208: uint8(254),
	2209: uint8(255),
	2211: uint8(252),
	2212: uint8(1),
	2215: uint8(248),
	2216: uint8(1),
	2219: uint8(248),
	2220: uint8(63),
	2236: uint8(127),
	2237: uint8(127),
	2239: uint8(48),
	2240: uint8(135),
	2241: uint8(255),
	2242: uint8(255),
	2243: uint8(255),
	2244: uint8(255),
	2245: uint8(255),
	2246: uint8(143),
	2247: uint8(255),
	2254: uint8(224),
	2255: uint8(255),
	2256: uint8(255),
	2257: uint8(127),
	2258: uint8(255),
	2259: uint8(15),
	2260: uint8(1),
	2266: uint8(255),
	2267: uint8(255),
	2268: uint8(255),
	2269: uint8(255),
	2270: uint8(255),
	2271: uint8(63),
	2300: uint8(255),
	2301: uint8(255),
	2302: uint8(255),
	2303: uint8(15),
	2308: uint8(15),
	2323: uint8(128),
	2330: uint8(1),
	2349: uint8(128),
	2378: uint8(128),
	2379: uint8(255),
	2382: uint8(128),
	2383: uint8(255),
	2388: uint8(128),
	2389: uint8(255),
	2399: uint8(248),
	2402: uint8(192),
	2403: uint8(143),
	2407: uint8(128),
	2423: uint8(48),
	2424: uint8(255),
	2425: uint8(255),
	2426: uint8(252),
	2427: uint8(255),
	2428: uint8(255),
	2429: uint8(255),
	2430: uint8(255),
	2431: uint8(255),
	2439: uint8(135),
	2440: uint8(255),
	2441: uint8(1),
	2442: uint8(255),
	2443: uint8(1),
	2447: uint8(224),
	2451: uint8(224),
	2457: uint8(1),
	2460: uint8(96),
	2461: uint8(248),
	2462: uint8(127),
	2471: uint8(254),
	2475: uint8(255),
	2479: uint8(255),
	2483: uint8(30),
	2485: uint8(254),
	2527: uint8(252),
	2540: uint8(255),
	2541: uint8(255),
	2542: uint8(255),
	2543: uint8(127),
	2563: uint8(224),
	2564: uint8(127),
	2568: uint8(192),
	2569: uint8(255),
	2570: uint8(255),
	2571: uint8(3),
	2600: uint8(192),
	2601: uint8(63),
	2602: uint8(252),
	2603: uint8(255),
	2604: uint8(63),
	2607: uint8(128),
	2608: uint8(3),
	2615: uint8(254),
	2616: uint8(3),
	2617: uint8(32),
	2630: uint8(24),
	2632: uint8(15),
	2638: uint8(56),
	2648: uint8(225),
	2649: uint8(63),
	2651: uint8(232),
	2652: uint8(254),
	2653: uint8(255),
	2654: uint8(31),
	2662: uint8(96),
	2663: uint8(63),
	2677: uint8(2),
	2685: uint8(6),
	2695: uint8(24),
	2697: uint8(32),
	2700: uint8(192),
	2701: uint8(31),
	2702: uint8(31),
	2728: uint8(68),
	2729: uint8(248),
	2731: uint8(104),
	2744: uint8(76),
	2775: uint8(128),
	2776: uint8(255),
	2777: uint8(255),
	2778: uint8(255),
	2791: uint8(128),
	2792: uint8(14),
	2796: uint8(255),
	2797: uint8(31),
	2806: uint8(192),
	2821: uint8(8),
	2823: uint8(252),
	2855: uint8(14),
	2877: uint8(252),
	2878: uint8(7),
	2908: uint8(5),
	2918: uint8(24),
	2919: uint8(128),
	2920: uint8(255),
	2931: uint8(223),
	2932: uint8(7),
	2951: uint8(128),
	2952: uint8(62),
	2955: uint8(252),
	2956: uint8(255),
	2957: uint8(31),
	2958: uint8(3),
	2984: uint8(52),
	2994: uint8(128),
	3038: uint8(128),
	3039: uint8(1),
	3064: uint8(255),
	3065: uint8(255),
	3066: uint8(255),
	3067: uint8(255),
	3068: uint8(255),
	3069: uint8(255),
	3070: uint8(3),
	3071: uint8(128),
	3086: uint8(31),
	3110: uint8(255),
	3111: uint8(1),
	3149: uint8(192),
	3166: uint8(63),
	3174: uint8(255),
	3175: uint8(255),
	3176: uint8(48),
	3179: uint8(248),
	3180: uint8(3),
	3216: uint8(255),
	3217: uint8(255),
	3218: uint8(255),
	3219: uint8(7),
	3260: uint8(4),
	3283: uint8(176),
	3284: uint8(15),
	3296: uint8(255),
	3297: uint8(255),
	3298: uint8(255),
	3299: uint8(255),
	3300: uint8(255),
	3301: uint8(255),
	3302: uint8(255),
	3303: uint8(255),
	3304: uint8(255),
	3305: uint8(255),
	3306: uint8(255),
	3307: uint8(255),
	3308: uint8(255),
	3309: uint8(255),
	3310: uint8(255),
	3311: uint8(255),
	3312: uint8(255),
	3313: uint8(255),
	3314: uint8(255),
	3315: uint8(255),
	3316: uint8(255),
	3317: uint8(255),
	3318: uint8(255),
	3319: uint8(255),
	3320: uint8(255),
	3321: uint8(255),
	3322: uint8(255),
	3323: uint8(255),
	3324: uint8(255),
	3325: uint8(255),
	3326: uint8(63),
	3328: uint8(255),
	3329: uint8(255),
	3330: uint8(255),
	3331: uint8(255),
	3332: uint8(127),
	3333: uint8(254),
	3334: uint8(255),
	3335: uint8(255),
	3336: uint8(255),
	3337: uint8(255),
	3338: uint8(255),
	3339: uint8(255),
	3340: uint8(255),
	3341: uint8(255),
	3342: uint8(255),
	3343: uint8(255),
	3344: uint8(255),
	3345: uint8(255),
	3346: uint8(255),
	3347: uint8(255),
	3348: uint8(255),
	3349: uint8(255),
	3350: uint8(255),
	3351: uint8(255),
	3352: uint8(255),
	3353: uint8(255),
	3354: uint8(255),
	3355: uint8(255),
	3356: uint8(255),
	3357: uint8(1),
	3360: uint8(255),
	3361: uint8(255),
	3362: uint8(255),
	3363: uint8(255),
	3364: uint8(255),
	3365: uint8(255),
	3366: uint8(255),
	3367: uint8(255),
	3368: uint8(63),
	3388: uint8(255),
	3389: uint8(255),
	3390: uint8(15),
	3392: uint8(255),
	3393: uint8(255),
	3394: uint8(255),
	3395: uint8(255),
	3396: uint8(255),
	3397: uint8(255),
	3398: uint8(255),
	3399: uint8(255),
	3400: uint8(255),
	3401: uint8(255),
	3402: uint8(127),
	3404: uint8(255),
	3405: uint8(255),
	3406: uint8(255),
	3407: uint8(1),
	3448: uint8(2),
	3451: uint8(8),
	3455: uint8(8),
	3458: uint8(32),
	3462: uint8(32),
	3465: uint8(128),
	3469: uint8(128),
	3473: uint8(2),
	3477: uint8(2),
	3480: uint8(8),
	3488: uint8(255),
	3489: uint8(255),
	3490: uint8(255),
	3491: uint8(255),
	3492: uint8(255),
	3493: uint8(255),
	3494: uint8(255),
	3495: uint8(255),
	3496: uint8(255),
	3497: uint8(255),
	3498: uint8(255),
	3499: uint8(255),
	3500: uint8(255),
	3501: uint8(255),
	3502: uint8(255),
	3503: uint8(255),
	3504: uint8(255),
	3505: uint8(15),
	3507: uint8(248),
	3508: uint8(254),
	3509: uint8(255),
	3526: uint8(127),
	3529: uint8(128),
	3581: uint8(240),
	3583: uint8(128),
	3608: uint8(128),
	3609: uint8(255),
	3610: uint8(127),
	3624: uint8(112),
	3625: uint8(7),
	3627: uint8(192),
	3662: uint8(254),
	3663: uint8(255),
	3664: uint8(255),
	3665: uint8(255),
	3666: uint8(255),
	3667: uint8(255),
	3668: uint8(255),
	3669: uint8(255),
	3670: uint8(31),
	3680: uint8(254),
	3681: uint8(255),
	3682: uint8(255),
	3683: uint8(255),
	3684: uint8(255),
	3685: uint8(255),
	3686: uint8(255),
	3687: uint8(63),
	3742: uint8(3),
	3744: uint8(255),
	3745: uint8(255),
	3746: uint8(255),
	3747: uint8(255),
	3748: uint8(255),
	3749: uint8(15),
	3750: uint8(255),
	3751: uint8(255),
	3752: uint8(255),
	3753: uint8(255),
	3754: uint8(255),
	3755: uint8(255),
	3756: uint8(255),
	3757: uint8(255),
	3758: uint8(255),
	3759: uint8(255),
	3760: uint8(255),
	3761: uint8(255),
	3762: uint8(15),
	3764: uint8(255),
	3765: uint8(127),
	3766: uint8(254),
	3767: uint8(255),
	3768: uint8(254),
	3769: uint8(255),
	3770: uint8(254),
	3771: uint8(255),
	3772: uint8(255),
	3773: uint8(255),
	3774: uint8(63),
	3776: uint8(255),
	3777: uint8(31),
	3778: uint8(255),
	3779: uint8(255),
	3780: uint8(255),
	3781: uint8(255),
	3785: uint8(252),
	3789: uint8(28),
	3793: uint8(252),
	3794: uint8(255),
	3795: uint8(255),
	3796: uint8(255),
	3797: uint8(31),
	3804: uint8(192),
	3805: uint8(255),
	3806: uint8(255),
	3807: uint8(255),
	3808: uint8(7),
	3810: uint8(255),
	3811: uint8(255),
	3812: uint8(255),
	3813: uint8(255),
	3814: uint8(255),
	3815: uint8(15),
	3816: uint8(255),
	3817: uint8(1),
	3818: uint8(3),
	3820: uint8(63),
	3840: uint8(255),
	3841: uint8(255),
	3842: uint8(255),
	3843: uint8(255),
	3844: uint8(255),
	3845: uint8(255),
	3846: uint8(255),
	3847: uint8(255),
	3848: uint8(255),
	3849: uint8(255),
	3850: uint8(255),
	3851: uint8(255),
	3852: uint8(255),
	3853: uint8(255),
	3854: uint8(255),
	3855: uint8(255),
	3856: uint8(255),
	3857: uint8(255),
	3858: uint8(255),
	3859: uint8(255),
	3860: uint8(255),
	3861: uint8(255),
	3862: uint8(255),
	3863: uint8(255),
	3864: uint8(255),
	3865: uint8(255),
	3866: uint8(63),
	3868: uint8(255),
	3869: uint8(31),
	3870: uint8(255),
	3871: uint8(7),
	3872: uint8(255),
	3873: uint8(255),
	3874: uint8(255),
	3875: uint8(255),
	3876: uint8(255),
	3877: uint8(255),
	3878: uint8(255),
	3879: uint8(255),
	3880: uint8(255),
	3881: uint8(255),
	3882: uint8(255),
	3883: uint8(255),
	3884: uint8(255),
	3885: uint8(255),
	3886: uint8(15),
	3888: uint8(255),
	3889: uint8(255),
	3890: uint8(255),
	3891: uint8(255),
	3892: uint8(255),
	3893: uint8(255),
	3894: uint8(255),
	3895: uint8(255),
	3896: uint8(255),
	3897: uint8(255),
	3898: uint8(255),
	3899: uint8(1),
	3900: uint8(255),
	3901: uint8(15),
	3904: uint8(255),
	3905: uint8(15),
	3906: uint8(255),
	3907: uint8(255),
	3908: uint8(255),
	3909: uint8(255),
	3910: uint8(255),
	3911: uint8(255),
	3912: uint8(255),
	3914: uint8(255),
	3915: uint8(3),
	3916: uint8(255),
	3917: uint8(255),
	3918: uint8(255),
	3919: uint8(255),
	3920: uint8(255),
	3922: uint8(255),
	3923: uint8(255),
	3924: uint8(255),
	3925: uint8(63),
	3936: uint8(255),
	3937: uint8(239),
	3938: uint8(255),
	3939: uint8(255),
	3940: uint8(255),
	3941: uint8(255),
	3942: uint8(255),
	3943: uint8(255),
	3944: uint8(255),
	3945: uint8(255),
	3946: uint8(255),
	3947: uint8(255),
	3948: uint8(255),
	3949: uint8(255),
	3950: uint8(123),
	3951: uint8(252),
	3952: uint8(255),
	3953: uint8(255),
	3954: uint8(255),
	3955: uint8(255),
	3956: uint8(231),
	3957: uint8(199),
	3958: uint8(255),
	3959: uint8(255),
	3960: uint8(255),
	3961: uint8(231),
	3962: uint8(255),
	3963: uint8(255),
	3964: uint8(255),
	3965: uint8(255),
	3966: uint8(255),
	3967: uint8(255),
	3968: uint8(255),
	3969: uint8(255),
	3970: uint8(255),
	3971: uint8(255),
	3972: uint8(255),
	3973: uint8(255),
	3974: uint8(255),
	3975: uint8(255),
	3976: uint8(255),
	3977: uint8(255),
	3978: uint8(15),
	3980: uint8(255),
	3981: uint8(63),
	3982: uint8(15),
	3983: uint8(7),
	3984: uint8(7),
	3986: uint8(63),
}

func Xiswpunct(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if wc < uint32(0x20000) {
		return int32(_table4[uint32(int32(_table4[wc>>int32(8)])*int32(32))+wc&uint32(255)>>int32(3)]) >> (wc & uint32(7)) & int32(1)
	}
	return 0
}

func X__iswpunct_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswpunct(tls, c)
}

func Xiswpunct_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswpunct_l(tls, c, l)
}

type Tmbstate_t = struct {
	F__opaque1 uint32
	F__opaque2 uint32
}

type t__mbstate_t = Tmbstate_t

/* Our definition of whitespace is the Unicode White_Space property,
 * minus non-breaking spaces (U+00A0, U+2007, and U+202F) and script-
 * specific characters with non-blank glyphs (U+1680 and U+180E). */

func Xiswspace(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(wc != 0 && Xwcschr(tls, uintptr(unsafe.Pointer(&_spaces)), wc) != 0)
}

var _spaces = [22]Twchar_t{
	0:  uint32(' '),
	1:  uint32('\t'),
	2:  uint32('\n'),
	3:  uint32('\r'),
	4:  uint32(11),
	5:  uint32(12),
	6:  uint32(0x0085),
	7:  uint32(0x2000),
	8:  uint32(0x2001),
	9:  uint32(0x2002),
	10: uint32(0x2003),
	11: uint32(0x2004),
	12: uint32(0x2005),
	13: uint32(0x2006),
	14: uint32(0x2008),
	15: uint32(0x2009),
	16: uint32(0x200a),
	17: uint32(0x2028),
	18: uint32(0x2029),
	19: uint32(0x205f),
	20: uint32(0x3000),
}

func X__iswspace_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswspace(tls, c)
}

func Xiswspace_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswspace_l(tls, c, l)
}

func Xiswupper(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(Xtowlower(tls, wc) != wc)
}

func X__iswupper_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswupper(tls, c)
}

func Xiswupper_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswupper_l(tls, c, l)
}

func Xiswxdigit(tls *TLS, wc Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(wc-Uint32FromUint8('0') < uint32(10) || wc|Uint32FromInt32(32)-Uint32FromUint8('a') < uint32(6))
}

func X__iswxdigit_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xiswxdigit(tls, c)
}

func Xiswxdigit_l(tls *TLS, c Twint_t, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__iswxdigit_l(tls, c, l)
}

func Xisxdigit(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(BoolInt32(uint32(c)-uint32('0') < uint32(10)) != 0 || uint32(c)|uint32(32)-uint32('a') < uint32(6))
}

func X__isxdigit_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xisxdigit(tls, c)
}

func Xisxdigit_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__isxdigit_l(tls, c, l)
}

// C documentation
//
//	/* nonsense function that should NEVER be used! */
func Xtoascii(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return c & int32(0x7f)
}

func Xtolower(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if BoolInt32(uint32(c)-uint32('A') < uint32(26)) != 0 {
		return c | int32(32)
	}
	return c
}

func X__tolower_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtolower(tls, c)
}

func Xtolower_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__tolower_l(tls, c, l)
}

func Xtoupper(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if BoolInt32(uint32(c)-uint32('a') < uint32(26)) != 0 {
		return c & int32(0x5f)
	}
	return c
}

func X__toupper_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtoupper(tls, c)
}

func Xtoupper_l(tls *TLS, c int32, l Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__toupper_l(tls, c, l)
}

var _tab1 = [2666]uint8{
	0:    uint8(7),
	1:    uint8(8),
	2:    uint8(9),
	3:    uint8(10),
	4:    uint8(11),
	5:    uint8(12),
	6:    uint8(6),
	7:    uint8(6),
	8:    uint8(6),
	9:    uint8(6),
	10:   uint8(6),
	11:   uint8(6),
	12:   uint8(6),
	13:   uint8(6),
	14:   uint8(6),
	15:   uint8(6),
	16:   uint8(13),
	17:   uint8(6),
	18:   uint8(6),
	19:   uint8(14),
	20:   uint8(6),
	21:   uint8(6),
	22:   uint8(6),
	23:   uint8(6),
	24:   uint8(6),
	25:   uint8(6),
	26:   uint8(6),
	27:   uint8(6),
	28:   uint8(15),
	29:   uint8(16),
	30:   uint8(17),
	31:   uint8(18),
	32:   uint8(6),
	33:   uint8(19),
	34:   uint8(6),
	35:   uint8(6),
	36:   uint8(6),
	37:   uint8(6),
	38:   uint8(6),
	39:   uint8(6),
	40:   uint8(6),
	41:   uint8(6),
	42:   uint8(6),
	43:   uint8(6),
	44:   uint8(20),
	45:   uint8(21),
	46:   uint8(6),
	47:   uint8(6),
	48:   uint8(6),
	49:   uint8(6),
	50:   uint8(6),
	51:   uint8(6),
	52:   uint8(6),
	53:   uint8(6),
	54:   uint8(6),
	55:   uint8(6),
	56:   uint8(6),
	57:   uint8(6),
	58:   uint8(6),
	59:   uint8(6),
	60:   uint8(6),
	61:   uint8(6),
	62:   uint8(6),
	63:   uint8(6),
	64:   uint8(6),
	65:   uint8(6),
	66:   uint8(6),
	67:   uint8(6),
	68:   uint8(6),
	69:   uint8(6),
	70:   uint8(6),
	71:   uint8(6),
	72:   uint8(6),
	73:   uint8(6),
	74:   uint8(6),
	75:   uint8(6),
	76:   uint8(6),
	77:   uint8(6),
	78:   uint8(6),
	79:   uint8(6),
	80:   uint8(6),
	81:   uint8(6),
	82:   uint8(6),
	83:   uint8(6),
	84:   uint8(6),
	85:   uint8(6),
	86:   uint8(6),
	87:   uint8(6),
	88:   uint8(6),
	89:   uint8(6),
	90:   uint8(6),
	91:   uint8(6),
	92:   uint8(6),
	93:   uint8(6),
	94:   uint8(6),
	95:   uint8(6),
	96:   uint8(6),
	97:   uint8(6),
	98:   uint8(6),
	99:   uint8(6),
	100:  uint8(6),
	101:  uint8(6),
	102:  uint8(6),
	103:  uint8(6),
	104:  uint8(6),
	105:  uint8(6),
	106:  uint8(6),
	107:  uint8(6),
	108:  uint8(6),
	109:  uint8(6),
	110:  uint8(6),
	111:  uint8(6),
	112:  uint8(6),
	113:  uint8(6),
	114:  uint8(6),
	115:  uint8(6),
	116:  uint8(6),
	117:  uint8(6),
	118:  uint8(6),
	119:  uint8(6),
	120:  uint8(6),
	121:  uint8(6),
	122:  uint8(6),
	123:  uint8(6),
	124:  uint8(6),
	125:  uint8(6),
	126:  uint8(6),
	127:  uint8(6),
	128:  uint8(6),
	129:  uint8(6),
	130:  uint8(6),
	131:  uint8(6),
	132:  uint8(6),
	133:  uint8(6),
	134:  uint8(6),
	135:  uint8(6),
	136:  uint8(6),
	137:  uint8(6),
	138:  uint8(6),
	139:  uint8(6),
	140:  uint8(6),
	141:  uint8(6),
	142:  uint8(6),
	143:  uint8(6),
	144:  uint8(6),
	145:  uint8(6),
	146:  uint8(6),
	147:  uint8(6),
	148:  uint8(6),
	149:  uint8(6),
	150:  uint8(6),
	151:  uint8(6),
	152:  uint8(6),
	153:  uint8(6),
	154:  uint8(6),
	155:  uint8(6),
	156:  uint8(6),
	157:  uint8(6),
	158:  uint8(6),
	159:  uint8(6),
	160:  uint8(6),
	161:  uint8(6),
	162:  uint8(6),
	163:  uint8(6),
	164:  uint8(6),
	165:  uint8(6),
	166:  uint8(22),
	167:  uint8(23),
	168:  uint8(6),
	169:  uint8(6),
	170:  uint8(6),
	171:  uint8(24),
	172:  uint8(6),
	173:  uint8(6),
	174:  uint8(6),
	175:  uint8(6),
	176:  uint8(6),
	177:  uint8(6),
	178:  uint8(6),
	179:  uint8(6),
	180:  uint8(6),
	181:  uint8(6),
	182:  uint8(6),
	183:  uint8(6),
	184:  uint8(6),
	185:  uint8(6),
	186:  uint8(6),
	187:  uint8(6),
	188:  uint8(6),
	189:  uint8(6),
	190:  uint8(6),
	191:  uint8(6),
	192:  uint8(6),
	193:  uint8(6),
	194:  uint8(6),
	195:  uint8(6),
	196:  uint8(6),
	197:  uint8(6),
	198:  uint8(6),
	199:  uint8(6),
	200:  uint8(6),
	201:  uint8(6),
	202:  uint8(6),
	203:  uint8(6),
	204:  uint8(6),
	205:  uint8(6),
	206:  uint8(6),
	207:  uint8(6),
	208:  uint8(6),
	209:  uint8(6),
	210:  uint8(6),
	211:  uint8(6),
	212:  uint8(6),
	213:  uint8(6),
	214:  uint8(6),
	215:  uint8(6),
	216:  uint8(6),
	217:  uint8(6),
	218:  uint8(6),
	219:  uint8(6),
	220:  uint8(6),
	221:  uint8(6),
	222:  uint8(6),
	223:  uint8(6),
	224:  uint8(6),
	225:  uint8(6),
	226:  uint8(6),
	227:  uint8(6),
	228:  uint8(6),
	229:  uint8(6),
	230:  uint8(6),
	231:  uint8(6),
	232:  uint8(6),
	233:  uint8(6),
	234:  uint8(6),
	235:  uint8(6),
	236:  uint8(6),
	237:  uint8(6),
	238:  uint8(6),
	239:  uint8(6),
	240:  uint8(6),
	241:  uint8(6),
	242:  uint8(6),
	243:  uint8(6),
	244:  uint8(6),
	245:  uint8(6),
	246:  uint8(6),
	247:  uint8(6),
	248:  uint8(6),
	249:  uint8(6),
	250:  uint8(6),
	251:  uint8(6),
	252:  uint8(6),
	253:  uint8(6),
	254:  uint8(6),
	255:  uint8(25),
	256:  uint8(6),
	257:  uint8(6),
	258:  uint8(6),
	259:  uint8(6),
	260:  uint8(26),
	261:  uint8(6),
	262:  uint8(6),
	263:  uint8(6),
	264:  uint8(6),
	265:  uint8(6),
	266:  uint8(6),
	267:  uint8(6),
	268:  uint8(27),
	269:  uint8(6),
	270:  uint8(6),
	271:  uint8(6),
	272:  uint8(6),
	273:  uint8(6),
	274:  uint8(6),
	275:  uint8(6),
	276:  uint8(6),
	277:  uint8(6),
	278:  uint8(6),
	279:  uint8(6),
	280:  uint8(28),
	281:  uint8(6),
	282:  uint8(6),
	283:  uint8(6),
	284:  uint8(6),
	285:  uint8(6),
	286:  uint8(6),
	287:  uint8(6),
	288:  uint8(6),
	289:  uint8(6),
	290:  uint8(6),
	291:  uint8(6),
	292:  uint8(6),
	293:  uint8(6),
	294:  uint8(6),
	295:  uint8(6),
	296:  uint8(6),
	297:  uint8(6),
	298:  uint8(6),
	299:  uint8(6),
	300:  uint8(6),
	301:  uint8(6),
	302:  uint8(6),
	303:  uint8(6),
	304:  uint8(6),
	305:  uint8(6),
	306:  uint8(6),
	307:  uint8(6),
	308:  uint8(6),
	309:  uint8(6),
	310:  uint8(6),
	311:  uint8(6),
	312:  uint8(6),
	313:  uint8(6),
	314:  uint8(6),
	315:  uint8(6),
	316:  uint8(6),
	317:  uint8(6),
	318:  uint8(6),
	319:  uint8(6),
	320:  uint8(6),
	321:  uint8(6),
	322:  uint8(6),
	323:  uint8(6),
	324:  uint8(6),
	325:  uint8(6),
	326:  uint8(6),
	327:  uint8(6),
	328:  uint8(6),
	329:  uint8(6),
	330:  uint8(6),
	331:  uint8(6),
	332:  uint8(6),
	333:  uint8(6),
	334:  uint8(6),
	335:  uint8(6),
	336:  uint8(6),
	337:  uint8(6),
	338:  uint8(6),
	339:  uint8(6),
	340:  uint8(6),
	341:  uint8(6),
	342:  uint8(6),
	343:  uint8(6),
	344:  uint8(6),
	345:  uint8(6),
	346:  uint8(6),
	347:  uint8(6),
	348:  uint8(6),
	349:  uint8(6),
	350:  uint8(6),
	351:  uint8(6),
	352:  uint8(6),
	353:  uint8(6),
	354:  uint8(6),
	355:  uint8(6),
	356:  uint8(6),
	357:  uint8(6),
	358:  uint8(6),
	359:  uint8(6),
	360:  uint8(6),
	361:  uint8(6),
	362:  uint8(6),
	363:  uint8(6),
	364:  uint8(6),
	365:  uint8(6),
	366:  uint8(29),
	367:  uint8(6),
	368:  uint8(6),
	369:  uint8(6),
	370:  uint8(6),
	371:  uint8(6),
	372:  uint8(6),
	373:  uint8(6),
	374:  uint8(6),
	375:  uint8(6),
	376:  uint8(6),
	377:  uint8(6),
	378:  uint8(6),
	379:  uint8(6),
	380:  uint8(6),
	381:  uint8(6),
	382:  uint8(6),
	383:  uint8(6),
	384:  uint8(6),
	385:  uint8(6),
	386:  uint8(6),
	387:  uint8(6),
	388:  uint8(6),
	389:  uint8(6),
	390:  uint8(6),
	391:  uint8(6),
	392:  uint8(6),
	393:  uint8(6),
	394:  uint8(6),
	395:  uint8(6),
	396:  uint8(6),
	397:  uint8(6),
	398:  uint8(6),
	399:  uint8(6),
	400:  uint8(6),
	401:  uint8(6),
	402:  uint8(6),
	403:  uint8(6),
	404:  uint8(6),
	405:  uint8(6),
	406:  uint8(6),
	407:  uint8(6),
	408:  uint8(6),
	409:  uint8(6),
	410:  uint8(6),
	411:  uint8(6),
	412:  uint8(6),
	413:  uint8(6),
	414:  uint8(6),
	415:  uint8(6),
	416:  uint8(6),
	417:  uint8(6),
	418:  uint8(6),
	419:  uint8(6),
	420:  uint8(6),
	421:  uint8(6),
	422:  uint8(6),
	423:  uint8(6),
	424:  uint8(6),
	425:  uint8(6),
	426:  uint8(6),
	427:  uint8(6),
	428:  uint8(6),
	429:  uint8(6),
	430:  uint8(6),
	431:  uint8(6),
	432:  uint8(6),
	433:  uint8(6),
	434:  uint8(6),
	435:  uint8(6),
	436:  uint8(6),
	437:  uint8(6),
	438:  uint8(6),
	439:  uint8(6),
	440:  uint8(6),
	441:  uint8(6),
	442:  uint8(6),
	443:  uint8(6),
	444:  uint8(6),
	445:  uint8(6),
	446:  uint8(6),
	447:  uint8(6),
	448:  uint8(6),
	449:  uint8(6),
	450:  uint8(6),
	451:  uint8(6),
	452:  uint8(6),
	453:  uint8(6),
	454:  uint8(6),
	455:  uint8(6),
	456:  uint8(6),
	457:  uint8(6),
	458:  uint8(6),
	459:  uint8(6),
	460:  uint8(6),
	461:  uint8(6),
	462:  uint8(6),
	463:  uint8(6),
	464:  uint8(6),
	465:  uint8(6),
	466:  uint8(6),
	467:  uint8(6),
	468:  uint8(6),
	469:  uint8(6),
	470:  uint8(6),
	471:  uint8(6),
	472:  uint8(6),
	473:  uint8(6),
	474:  uint8(6),
	475:  uint8(6),
	476:  uint8(6),
	477:  uint8(6),
	478:  uint8(6),
	479:  uint8(6),
	480:  uint8(6),
	481:  uint8(6),
	482:  uint8(6),
	483:  uint8(6),
	484:  uint8(6),
	485:  uint8(6),
	486:  uint8(6),
	487:  uint8(6),
	488:  uint8(6),
	489:  uint8(30),
	490:  uint8(6),
	491:  uint8(6),
	492:  uint8(6),
	493:  uint8(6),
	494:  uint8(6),
	495:  uint8(6),
	496:  uint8(6),
	497:  uint8(6),
	498:  uint8(6),
	499:  uint8(6),
	500:  uint8(6),
	501:  uint8(6),
	502:  uint8(6),
	503:  uint8(6),
	504:  uint8(6),
	505:  uint8(6),
	506:  uint8(6),
	507:  uint8(6),
	508:  uint8(6),
	509:  uint8(6),
	510:  uint8(6),
	511:  uint8(6),
	623:  uint8(36),
	624:  uint8(43),
	625:  uint8(43),
	626:  uint8(43),
	627:  uint8(43),
	628:  uint8(43),
	629:  uint8(43),
	630:  uint8(43),
	631:  uint8(43),
	632:  uint8(1),
	634:  uint8(84),
	635:  uint8(86),
	636:  uint8(86),
	637:  uint8(86),
	638:  uint8(86),
	639:  uint8(86),
	640:  uint8(86),
	641:  uint8(86),
	642:  uint8(86),
	662:  uint8(24),
	666:  uint8(43),
	667:  uint8(43),
	668:  uint8(43),
	669:  uint8(43),
	670:  uint8(43),
	671:  uint8(43),
	672:  uint8(43),
	673:  uint8(7),
	674:  uint8(43),
	675:  uint8(43),
	676:  uint8(91),
	677:  uint8(86),
	678:  uint8(86),
	679:  uint8(86),
	680:  uint8(86),
	681:  uint8(86),
	682:  uint8(86),
	683:  uint8(86),
	684:  uint8(74),
	685:  uint8(86),
	686:  uint8(86),
	687:  uint8(5),
	688:  uint8(49),
	689:  uint8(80),
	690:  uint8(49),
	691:  uint8(80),
	692:  uint8(49),
	693:  uint8(80),
	694:  uint8(49),
	695:  uint8(80),
	696:  uint8(49),
	697:  uint8(80),
	698:  uint8(49),
	699:  uint8(80),
	700:  uint8(49),
	701:  uint8(80),
	702:  uint8(49),
	703:  uint8(80),
	704:  uint8(36),
	705:  uint8(80),
	706:  uint8(121),
	707:  uint8(49),
	708:  uint8(80),
	709:  uint8(49),
	710:  uint8(80),
	711:  uint8(49),
	712:  uint8(56),
	713:  uint8(80),
	714:  uint8(49),
	715:  uint8(80),
	716:  uint8(49),
	717:  uint8(80),
	718:  uint8(49),
	719:  uint8(80),
	720:  uint8(49),
	721:  uint8(80),
	722:  uint8(49),
	723:  uint8(80),
	724:  uint8(49),
	725:  uint8(80),
	726:  uint8(49),
	727:  uint8(80),
	728:  uint8(78),
	729:  uint8(49),
	730:  uint8(2),
	731:  uint8(78),
	732:  uint8(13),
	733:  uint8(13),
	734:  uint8(78),
	735:  uint8(3),
	736:  uint8(78),
	738:  uint8(36),
	739:  uint8(110),
	741:  uint8(78),
	742:  uint8(49),
	743:  uint8(38),
	744:  uint8(110),
	745:  uint8(81),
	746:  uint8(78),
	747:  uint8(36),
	748:  uint8(80),
	749:  uint8(78),
	750:  uint8(57),
	751:  uint8(20),
	752:  uint8(129),
	753:  uint8(27),
	754:  uint8(29),
	755:  uint8(29),
	756:  uint8(83),
	757:  uint8(49),
	758:  uint8(80),
	759:  uint8(49),
	760:  uint8(80),
	761:  uint8(13),
	762:  uint8(49),
	763:  uint8(80),
	764:  uint8(49),
	765:  uint8(80),
	766:  uint8(49),
	767:  uint8(80),
	768:  uint8(27),
	769:  uint8(83),
	770:  uint8(36),
	771:  uint8(80),
	772:  uint8(49),
	773:  uint8(2),
	774:  uint8(92),
	775:  uint8(123),
	776:  uint8(92),
	777:  uint8(123),
	778:  uint8(92),
	779:  uint8(123),
	780:  uint8(92),
	781:  uint8(123),
	782:  uint8(92),
	783:  uint8(123),
	784:  uint8(20),
	785:  uint8(121),
	786:  uint8(92),
	787:  uint8(123),
	788:  uint8(92),
	789:  uint8(123),
	790:  uint8(92),
	791:  uint8(45),
	792:  uint8(43),
	793:  uint8(73),
	794:  uint8(3),
	795:  uint8(72),
	796:  uint8(3),
	797:  uint8(120),
	798:  uint8(92),
	799:  uint8(123),
	800:  uint8(20),
	802:  uint8(150),
	803:  uint8(10),
	804:  uint8(1),
	805:  uint8(43),
	806:  uint8(40),
	807:  uint8(6),
	808:  uint8(6),
	810:  uint8(42),
	811:  uint8(6),
	812:  uint8(42),
	813:  uint8(42),
	814:  uint8(43),
	815:  uint8(7),
	816:  uint8(187),
	817:  uint8(181),
	818:  uint8(43),
	819:  uint8(30),
	821:  uint8(43),
	822:  uint8(7),
	823:  uint8(43),
	824:  uint8(43),
	825:  uint8(43),
	826:  uint8(1),
	827:  uint8(43),
	828:  uint8(43),
	829:  uint8(43),
	830:  uint8(43),
	831:  uint8(43),
	832:  uint8(43),
	833:  uint8(43),
	834:  uint8(43),
	835:  uint8(43),
	836:  uint8(43),
	837:  uint8(43),
	838:  uint8(43),
	839:  uint8(43),
	840:  uint8(43),
	841:  uint8(43),
	842:  uint8(43),
	843:  uint8(43),
	844:  uint8(43),
	845:  uint8(43),
	846:  uint8(43),
	847:  uint8(43),
	848:  uint8(43),
	849:  uint8(43),
	850:  uint8(43),
	851:  uint8(43),
	852:  uint8(43),
	853:  uint8(43),
	854:  uint8(43),
	855:  uint8(43),
	856:  uint8(43),
	857:  uint8(43),
	858:  uint8(43),
	859:  uint8(1),
	860:  uint8(43),
	861:  uint8(43),
	862:  uint8(43),
	863:  uint8(43),
	864:  uint8(43),
	865:  uint8(43),
	866:  uint8(43),
	867:  uint8(43),
	868:  uint8(43),
	869:  uint8(43),
	870:  uint8(43),
	871:  uint8(43),
	872:  uint8(43),
	873:  uint8(43),
	874:  uint8(43),
	875:  uint8(43),
	876:  uint8(43),
	877:  uint8(43),
	878:  uint8(43),
	879:  uint8(43),
	880:  uint8(43),
	881:  uint8(43),
	882:  uint8(43),
	883:  uint8(42),
	884:  uint8(43),
	885:  uint8(43),
	886:  uint8(43),
	887:  uint8(43),
	888:  uint8(43),
	889:  uint8(43),
	890:  uint8(43),
	891:  uint8(43),
	892:  uint8(43),
	893:  uint8(43),
	894:  uint8(43),
	895:  uint8(43),
	896:  uint8(43),
	897:  uint8(205),
	898:  uint8(70),
	899:  uint8(205),
	900:  uint8(43),
	902:  uint8(37),
	903:  uint8(43),
	904:  uint8(7),
	905:  uint8(1),
	906:  uint8(6),
	907:  uint8(1),
	908:  uint8(85),
	909:  uint8(86),
	910:  uint8(86),
	911:  uint8(86),
	912:  uint8(86),
	913:  uint8(86),
	914:  uint8(85),
	915:  uint8(86),
	916:  uint8(86),
	917:  uint8(2),
	918:  uint8(36),
	919:  uint8(129),
	920:  uint8(129),
	921:  uint8(129),
	922:  uint8(129),
	923:  uint8(129),
	924:  uint8(21),
	925:  uint8(129),
	926:  uint8(129),
	927:  uint8(129),
	930:  uint8(43),
	932:  uint8(178),
	933:  uint8(209),
	934:  uint8(178),
	935:  uint8(209),
	936:  uint8(178),
	937:  uint8(209),
	938:  uint8(178),
	939:  uint8(209),
	942:  uint8(205),
	943:  uint8(204),
	944:  uint8(1),
	946:  uint8(215),
	947:  uint8(215),
	948:  uint8(215),
	949:  uint8(215),
	950:  uint8(215),
	951:  uint8(131),
	952:  uint8(129),
	953:  uint8(129),
	954:  uint8(129),
	955:  uint8(129),
	956:  uint8(129),
	957:  uint8(129),
	958:  uint8(129),
	959:  uint8(129),
	960:  uint8(129),
	961:  uint8(129),
	962:  uint8(172),
	963:  uint8(172),
	964:  uint8(172),
	965:  uint8(172),
	966:  uint8(172),
	967:  uint8(172),
	968:  uint8(172),
	969:  uint8(172),
	970:  uint8(172),
	971:  uint8(172),
	972:  uint8(28),
	978:  uint8(49),
	979:  uint8(80),
	980:  uint8(49),
	981:  uint8(80),
	982:  uint8(49),
	983:  uint8(80),
	984:  uint8(49),
	985:  uint8(80),
	986:  uint8(49),
	987:  uint8(80),
	988:  uint8(49),
	989:  uint8(2),
	992:  uint8(49),
	993:  uint8(80),
	994:  uint8(49),
	995:  uint8(80),
	996:  uint8(49),
	997:  uint8(80),
	998:  uint8(49),
	999:  uint8(80),
	1000: uint8(49),
	1001: uint8(80),
	1002: uint8(49),
	1003: uint8(80),
	1004: uint8(49),
	1005: uint8(80),
	1006: uint8(49),
	1007: uint8(80),
	1008: uint8(49),
	1009: uint8(80),
	1010: uint8(78),
	1011: uint8(49),
	1012: uint8(80),
	1013: uint8(49),
	1014: uint8(80),
	1015: uint8(78),
	1016: uint8(49),
	1017: uint8(80),
	1018: uint8(49),
	1019: uint8(80),
	1020: uint8(49),
	1021: uint8(80),
	1022: uint8(49),
	1023: uint8(80),
	1024: uint8(49),
	1025: uint8(80),
	1026: uint8(49),
	1027: uint8(80),
	1028: uint8(49),
	1029: uint8(80),
	1030: uint8(49),
	1031: uint8(2),
	1032: uint8(135),
	1033: uint8(166),
	1034: uint8(135),
	1035: uint8(166),
	1036: uint8(135),
	1037: uint8(166),
	1038: uint8(135),
	1039: uint8(166),
	1040: uint8(135),
	1041: uint8(166),
	1042: uint8(135),
	1043: uint8(166),
	1044: uint8(135),
	1045: uint8(166),
	1046: uint8(135),
	1047: uint8(166),
	1048: uint8(42),
	1049: uint8(43),
	1050: uint8(43),
	1051: uint8(43),
	1052: uint8(43),
	1053: uint8(43),
	1054: uint8(43),
	1055: uint8(43),
	1056: uint8(43),
	1057: uint8(43),
	1058: uint8(43),
	1059: uint8(43),
	1060: uint8(43),
	1064: uint8(84),
	1065: uint8(86),
	1066: uint8(86),
	1067: uint8(86),
	1068: uint8(86),
	1069: uint8(86),
	1070: uint8(86),
	1071: uint8(86),
	1072: uint8(86),
	1073: uint8(86),
	1074: uint8(86),
	1075: uint8(86),
	1076: uint8(86),
	1171: uint8(84),
	1172: uint8(86),
	1173: uint8(86),
	1174: uint8(86),
	1175: uint8(86),
	1176: uint8(86),
	1177: uint8(86),
	1178: uint8(86),
	1179: uint8(86),
	1180: uint8(86),
	1181: uint8(86),
	1182: uint8(86),
	1183: uint8(86),
	1184: uint8(12),
	1186: uint8(12),
	1187: uint8(42),
	1188: uint8(43),
	1189: uint8(43),
	1190: uint8(43),
	1191: uint8(43),
	1192: uint8(43),
	1193: uint8(43),
	1194: uint8(43),
	1195: uint8(43),
	1196: uint8(43),
	1197: uint8(43),
	1198: uint8(43),
	1199: uint8(43),
	1200: uint8(43),
	1201: uint8(7),
	1202: uint8(42),
	1203: uint8(1),
	1257: uint8(42),
	1258: uint8(43),
	1259: uint8(43),
	1260: uint8(43),
	1261: uint8(43),
	1262: uint8(43),
	1263: uint8(43),
	1264: uint8(43),
	1265: uint8(43),
	1266: uint8(43),
	1267: uint8(43),
	1268: uint8(43),
	1269: uint8(43),
	1270: uint8(43),
	1271: uint8(43),
	1272: uint8(43),
	1273: uint8(43),
	1274: uint8(43),
	1275: uint8(43),
	1276: uint8(43),
	1277: uint8(43),
	1278: uint8(43),
	1279: uint8(43),
	1280: uint8(43),
	1281: uint8(43),
	1282: uint8(43),
	1283: uint8(43),
	1284: uint8(86),
	1285: uint8(86),
	1286: uint8(108),
	1287: uint8(129),
	1288: uint8(21),
	1290: uint8(43),
	1291: uint8(43),
	1292: uint8(43),
	1293: uint8(43),
	1294: uint8(43),
	1295: uint8(43),
	1296: uint8(43),
	1297: uint8(43),
	1298: uint8(43),
	1299: uint8(43),
	1300: uint8(43),
	1301: uint8(43),
	1302: uint8(43),
	1303: uint8(43),
	1304: uint8(43),
	1305: uint8(43),
	1306: uint8(43),
	1307: uint8(43),
	1308: uint8(43),
	1309: uint8(43),
	1310: uint8(43),
	1311: uint8(43),
	1312: uint8(43),
	1313: uint8(43),
	1314: uint8(43),
	1315: uint8(43),
	1316: uint8(43),
	1317: uint8(43),
	1318: uint8(43),
	1319: uint8(43),
	1320: uint8(43),
	1321: uint8(43),
	1322: uint8(43),
	1323: uint8(43),
	1324: uint8(43),
	1325: uint8(43),
	1326: uint8(43),
	1327: uint8(43),
	1328: uint8(43),
	1329: uint8(43),
	1330: uint8(43),
	1331: uint8(43),
	1332: uint8(7),
	1333: uint8(108),
	1334: uint8(3),
	1335: uint8(65),
	1336: uint8(43),
	1337: uint8(43),
	1338: uint8(86),
	1339: uint8(86),
	1340: uint8(86),
	1341: uint8(86),
	1342: uint8(86),
	1343: uint8(86),
	1344: uint8(86),
	1345: uint8(86),
	1346: uint8(86),
	1347: uint8(86),
	1348: uint8(86),
	1349: uint8(86),
	1350: uint8(86),
	1351: uint8(86),
	1352: uint8(44),
	1353: uint8(86),
	1354: uint8(43),
	1355: uint8(43),
	1356: uint8(43),
	1357: uint8(43),
	1358: uint8(43),
	1359: uint8(43),
	1360: uint8(43),
	1361: uint8(43),
	1362: uint8(43),
	1363: uint8(43),
	1364: uint8(43),
	1365: uint8(43),
	1366: uint8(43),
	1367: uint8(43),
	1368: uint8(43),
	1369: uint8(43),
	1370: uint8(43),
	1371: uint8(43),
	1372: uint8(43),
	1373: uint8(43),
	1374: uint8(43),
	1375: uint8(1),
	1416: uint8(12),
	1417: uint8(108),
	1423: uint8(6),
	1462: uint8(6),
	1463: uint8(37),
	1464: uint8(6),
	1465: uint8(37),
	1466: uint8(6),
	1467: uint8(37),
	1468: uint8(6),
	1469: uint8(37),
	1470: uint8(6),
	1471: uint8(37),
	1472: uint8(6),
	1473: uint8(37),
	1474: uint8(6),
	1475: uint8(37),
	1476: uint8(6),
	1477: uint8(37),
	1478: uint8(6),
	1479: uint8(37),
	1480: uint8(6),
	1481: uint8(37),
	1482: uint8(6),
	1483: uint8(37),
	1484: uint8(6),
	1485: uint8(37),
	1486: uint8(6),
	1487: uint8(37),
	1488: uint8(6),
	1489: uint8(37),
	1490: uint8(6),
	1491: uint8(37),
	1492: uint8(6),
	1493: uint8(37),
	1494: uint8(6),
	1495: uint8(37),
	1496: uint8(6),
	1497: uint8(37),
	1498: uint8(6),
	1499: uint8(37),
	1500: uint8(6),
	1501: uint8(37),
	1502: uint8(6),
	1503: uint8(37),
	1504: uint8(6),
	1505: uint8(37),
	1506: uint8(6),
	1507: uint8(37),
	1508: uint8(6),
	1509: uint8(37),
	1510: uint8(6),
	1511: uint8(37),
	1512: uint8(86),
	1513: uint8(122),
	1514: uint8(158),
	1515: uint8(38),
	1516: uint8(6),
	1517: uint8(37),
	1518: uint8(6),
	1519: uint8(37),
	1520: uint8(6),
	1521: uint8(37),
	1522: uint8(6),
	1523: uint8(37),
	1524: uint8(6),
	1525: uint8(37),
	1526: uint8(6),
	1527: uint8(37),
	1528: uint8(6),
	1529: uint8(37),
	1530: uint8(6),
	1531: uint8(37),
	1532: uint8(6),
	1533: uint8(37),
	1534: uint8(6),
	1535: uint8(37),
	1536: uint8(6),
	1537: uint8(37),
	1538: uint8(6),
	1539: uint8(37),
	1540: uint8(6),
	1541: uint8(37),
	1542: uint8(6),
	1543: uint8(37),
	1544: uint8(6),
	1545: uint8(37),
	1546: uint8(6),
	1547: uint8(1),
	1548: uint8(43),
	1549: uint8(43),
	1550: uint8(79),
	1551: uint8(86),
	1552: uint8(86),
	1553: uint8(44),
	1554: uint8(43),
	1555: uint8(127),
	1556: uint8(86),
	1557: uint8(86),
	1558: uint8(57),
	1559: uint8(43),
	1560: uint8(43),
	1561: uint8(85),
	1562: uint8(86),
	1563: uint8(86),
	1564: uint8(43),
	1565: uint8(43),
	1566: uint8(79),
	1567: uint8(86),
	1568: uint8(86),
	1569: uint8(44),
	1570: uint8(43),
	1571: uint8(127),
	1572: uint8(86),
	1573: uint8(86),
	1574: uint8(129),
	1575: uint8(55),
	1576: uint8(117),
	1577: uint8(91),
	1578: uint8(123),
	1579: uint8(92),
	1580: uint8(43),
	1581: uint8(43),
	1582: uint8(79),
	1583: uint8(86),
	1584: uint8(86),
	1585: uint8(2),
	1586: uint8(172),
	1587: uint8(4),
	1590: uint8(57),
	1591: uint8(43),
	1592: uint8(43),
	1593: uint8(85),
	1594: uint8(86),
	1595: uint8(86),
	1596: uint8(43),
	1597: uint8(43),
	1598: uint8(79),
	1599: uint8(86),
	1600: uint8(86),
	1601: uint8(44),
	1602: uint8(43),
	1603: uint8(43),
	1604: uint8(86),
	1605: uint8(86),
	1606: uint8(50),
	1607: uint8(19),
	1608: uint8(129),
	1609: uint8(87),
	1611: uint8(111),
	1612: uint8(129),
	1613: uint8(126),
	1614: uint8(201),
	1615: uint8(215),
	1616: uint8(126),
	1617: uint8(45),
	1618: uint8(129),
	1619: uint8(129),
	1620: uint8(14),
	1621: uint8(126),
	1622: uint8(57),
	1623: uint8(127),
	1624: uint8(111),
	1625: uint8(87),
	1627: uint8(129),
	1628: uint8(129),
	1629: uint8(126),
	1630: uint8(21),
	1632: uint8(126),
	1633: uint8(3),
	1634: uint8(43),
	1635: uint8(43),
	1636: uint8(43),
	1637: uint8(43),
	1638: uint8(43),
	1639: uint8(43),
	1640: uint8(43),
	1641: uint8(43),
	1642: uint8(43),
	1643: uint8(43),
	1644: uint8(43),
	1645: uint8(43),
	1646: uint8(7),
	1647: uint8(43),
	1648: uint8(36),
	1649: uint8(43),
	1650: uint8(151),
	1651: uint8(43),
	1652: uint8(43),
	1653: uint8(43),
	1654: uint8(43),
	1655: uint8(43),
	1656: uint8(43),
	1657: uint8(43),
	1658: uint8(43),
	1659: uint8(43),
	1660: uint8(42),
	1661: uint8(43),
	1662: uint8(43),
	1663: uint8(43),
	1664: uint8(43),
	1665: uint8(43),
	1666: uint8(86),
	1667: uint8(86),
	1668: uint8(86),
	1669: uint8(86),
	1670: uint8(86),
	1671: uint8(128),
	1672: uint8(129),
	1673: uint8(129),
	1674: uint8(129),
	1675: uint8(129),
	1676: uint8(57),
	1677: uint8(187),
	1678: uint8(42),
	1679: uint8(43),
	1680: uint8(43),
	1681: uint8(43),
	1682: uint8(43),
	1683: uint8(43),
	1684: uint8(43),
	1685: uint8(43),
	1686: uint8(43),
	1687: uint8(43),
	1688: uint8(43),
	1689: uint8(43),
	1690: uint8(43),
	1691: uint8(43),
	1692: uint8(43),
	1693: uint8(43),
	1694: uint8(43),
	1695: uint8(43),
	1696: uint8(43),
	1697: uint8(43),
	1698: uint8(43),
	1699: uint8(43),
	1700: uint8(43),
	1701: uint8(43),
	1702: uint8(43),
	1703: uint8(43),
	1704: uint8(43),
	1705: uint8(43),
	1706: uint8(43),
	1707: uint8(43),
	1708: uint8(43),
	1709: uint8(43),
	1710: uint8(43),
	1711: uint8(43),
	1712: uint8(43),
	1713: uint8(43),
	1714: uint8(43),
	1715: uint8(43),
	1716: uint8(43),
	1717: uint8(43),
	1718: uint8(43),
	1719: uint8(1),
	1720: uint8(129),
	1721: uint8(129),
	1722: uint8(129),
	1723: uint8(129),
	1724: uint8(129),
	1725: uint8(129),
	1726: uint8(129),
	1727: uint8(129),
	1728: uint8(129),
	1729: uint8(129),
	1730: uint8(129),
	1731: uint8(129),
	1732: uint8(129),
	1733: uint8(129),
	1734: uint8(129),
	1735: uint8(201),
	1736: uint8(172),
	1737: uint8(172),
	1738: uint8(172),
	1739: uint8(172),
	1740: uint8(172),
	1741: uint8(172),
	1742: uint8(172),
	1743: uint8(172),
	1744: uint8(172),
	1745: uint8(172),
	1746: uint8(172),
	1747: uint8(172),
	1748: uint8(172),
	1749: uint8(172),
	1750: uint8(172),
	1751: uint8(208),
	1752: uint8(13),
	1754: uint8(78),
	1755: uint8(49),
	1756: uint8(2),
	1757: uint8(180),
	1758: uint8(193),
	1759: uint8(193),
	1760: uint8(215),
	1761: uint8(215),
	1762: uint8(36),
	1763: uint8(80),
	1764: uint8(49),
	1765: uint8(80),
	1766: uint8(49),
	1767: uint8(80),
	1768: uint8(49),
	1769: uint8(80),
	1770: uint8(49),
	1771: uint8(80),
	1772: uint8(49),
	1773: uint8(80),
	1774: uint8(49),
	1775: uint8(80),
	1776: uint8(49),
	1777: uint8(80),
	1778: uint8(49),
	1779: uint8(80),
	1780: uint8(49),
	1781: uint8(80),
	1782: uint8(49),
	1783: uint8(80),
	1784: uint8(49),
	1785: uint8(80),
	1786: uint8(49),
	1787: uint8(80),
	1788: uint8(49),
	1789: uint8(80),
	1790: uint8(49),
	1791: uint8(80),
	1792: uint8(49),
	1793: uint8(80),
	1794: uint8(49),
	1795: uint8(80),
	1796: uint8(215),
	1797: uint8(215),
	1798: uint8(83),
	1799: uint8(193),
	1800: uint8(71),
	1801: uint8(212),
	1802: uint8(215),
	1803: uint8(215),
	1804: uint8(215),
	1805: uint8(5),
	1806: uint8(43),
	1807: uint8(43),
	1808: uint8(43),
	1809: uint8(43),
	1810: uint8(43),
	1811: uint8(43),
	1812: uint8(43),
	1813: uint8(43),
	1814: uint8(43),
	1815: uint8(43),
	1816: uint8(43),
	1817: uint8(43),
	1818: uint8(7),
	1819: uint8(1),
	1821: uint8(1),
	1913: uint8(78),
	1914: uint8(49),
	1915: uint8(80),
	1916: uint8(49),
	1917: uint8(80),
	1918: uint8(49),
	1919: uint8(80),
	1920: uint8(49),
	1921: uint8(80),
	1922: uint8(49),
	1923: uint8(80),
	1924: uint8(49),
	1925: uint8(80),
	1926: uint8(49),
	1927: uint8(80),
	1928: uint8(13),
	1934: uint8(36),
	1935: uint8(80),
	1936: uint8(49),
	1937: uint8(80),
	1938: uint8(49),
	1939: uint8(80),
	1940: uint8(49),
	1941: uint8(80),
	1942: uint8(49),
	1943: uint8(80),
	1978: uint8(43),
	1979: uint8(43),
	1980: uint8(43),
	1981: uint8(43),
	1982: uint8(43),
	1983: uint8(43),
	1984: uint8(43),
	1985: uint8(43),
	1986: uint8(43),
	1987: uint8(43),
	1988: uint8(43),
	1989: uint8(121),
	1990: uint8(92),
	1991: uint8(123),
	1992: uint8(92),
	1993: uint8(123),
	1994: uint8(79),
	1995: uint8(123),
	1996: uint8(92),
	1997: uint8(123),
	1998: uint8(92),
	1999: uint8(123),
	2000: uint8(92),
	2001: uint8(123),
	2002: uint8(92),
	2003: uint8(123),
	2004: uint8(92),
	2005: uint8(123),
	2006: uint8(92),
	2007: uint8(123),
	2008: uint8(92),
	2009: uint8(123),
	2010: uint8(92),
	2011: uint8(123),
	2012: uint8(92),
	2013: uint8(123),
	2014: uint8(92),
	2015: uint8(45),
	2016: uint8(43),
	2017: uint8(43),
	2018: uint8(121),
	2019: uint8(20),
	2020: uint8(92),
	2021: uint8(123),
	2022: uint8(92),
	2023: uint8(45),
	2024: uint8(121),
	2025: uint8(42),
	2026: uint8(92),
	2027: uint8(39),
	2028: uint8(92),
	2029: uint8(123),
	2030: uint8(92),
	2031: uint8(123),
	2032: uint8(92),
	2033: uint8(123),
	2034: uint8(164),
	2036: uint8(10),
	2037: uint8(180),
	2038: uint8(92),
	2039: uint8(123),
	2040: uint8(92),
	2041: uint8(123),
	2042: uint8(79),
	2043: uint8(3),
	2044: uint8(42),
	2045: uint8(43),
	2046: uint8(43),
	2047: uint8(43),
	2048: uint8(43),
	2049: uint8(43),
	2050: uint8(43),
	2051: uint8(43),
	2052: uint8(43),
	2053: uint8(43),
	2054: uint8(43),
	2055: uint8(43),
	2056: uint8(43),
	2057: uint8(43),
	2058: uint8(43),
	2059: uint8(43),
	2060: uint8(43),
	2061: uint8(43),
	2062: uint8(43),
	2063: uint8(1),
	2091: uint8(72),
	2101: uint8(42),
	2102: uint8(43),
	2103: uint8(43),
	2104: uint8(43),
	2105: uint8(43),
	2106: uint8(43),
	2107: uint8(43),
	2108: uint8(43),
	2109: uint8(43),
	2110: uint8(43),
	2111: uint8(43),
	2112: uint8(43),
	2113: uint8(43),
	2114: uint8(43),
	2115: uint8(43),
	2116: uint8(43),
	2117: uint8(43),
	2118: uint8(43),
	2119: uint8(43),
	2120: uint8(43),
	2121: uint8(43),
	2122: uint8(43),
	2123: uint8(43),
	2124: uint8(43),
	2125: uint8(43),
	2126: uint8(43),
	2127: uint8(43),
	2161: uint8(43),
	2162: uint8(43),
	2163: uint8(43),
	2164: uint8(43),
	2165: uint8(43),
	2166: uint8(43),
	2167: uint8(43),
	2168: uint8(43),
	2169: uint8(7),
	2171: uint8(72),
	2172: uint8(86),
	2173: uint8(86),
	2174: uint8(86),
	2175: uint8(86),
	2176: uint8(86),
	2177: uint8(86),
	2178: uint8(86),
	2179: uint8(86),
	2180: uint8(2),
	2236: uint8(43),
	2237: uint8(43),
	2238: uint8(43),
	2239: uint8(43),
	2240: uint8(43),
	2241: uint8(43),
	2242: uint8(43),
	2243: uint8(43),
	2244: uint8(43),
	2245: uint8(43),
	2246: uint8(43),
	2247: uint8(43),
	2248: uint8(43),
	2249: uint8(85),
	2250: uint8(86),
	2251: uint8(86),
	2252: uint8(86),
	2253: uint8(86),
	2254: uint8(86),
	2255: uint8(86),
	2256: uint8(86),
	2257: uint8(86),
	2258: uint8(86),
	2259: uint8(86),
	2260: uint8(86),
	2261: uint8(86),
	2262: uint8(14),
	2294: uint8(36),
	2295: uint8(43),
	2296: uint8(43),
	2297: uint8(43),
	2298: uint8(43),
	2299: uint8(43),
	2300: uint8(43),
	2301: uint8(43),
	2302: uint8(43),
	2303: uint8(43),
	2304: uint8(43),
	2305: uint8(43),
	2306: uint8(7),
	2308: uint8(86),
	2309: uint8(86),
	2310: uint8(86),
	2311: uint8(86),
	2312: uint8(86),
	2313: uint8(86),
	2314: uint8(86),
	2315: uint8(86),
	2316: uint8(86),
	2317: uint8(86),
	2318: uint8(86),
	2319: uint8(86),
	2364: uint8(36),
	2365: uint8(43),
	2366: uint8(43),
	2367: uint8(43),
	2368: uint8(43),
	2369: uint8(43),
	2370: uint8(43),
	2371: uint8(43),
	2372: uint8(43),
	2373: uint8(43),
	2374: uint8(43),
	2375: uint8(43),
	2376: uint8(43),
	2377: uint8(43),
	2378: uint8(43),
	2379: uint8(43),
	2380: uint8(43),
	2381: uint8(7),
	2386: uint8(86),
	2387: uint8(86),
	2388: uint8(86),
	2389: uint8(86),
	2390: uint8(86),
	2391: uint8(86),
	2392: uint8(86),
	2393: uint8(86),
	2394: uint8(86),
	2395: uint8(86),
	2396: uint8(86),
	2397: uint8(86),
	2398: uint8(86),
	2399: uint8(86),
	2400: uint8(86),
	2401: uint8(86),
	2402: uint8(86),
	2461: uint8(42),
	2462: uint8(43),
	2463: uint8(43),
	2464: uint8(43),
	2465: uint8(43),
	2466: uint8(43),
	2467: uint8(43),
	2468: uint8(43),
	2469: uint8(43),
	2470: uint8(43),
	2471: uint8(43),
	2472: uint8(86),
	2473: uint8(86),
	2474: uint8(86),
	2475: uint8(86),
	2476: uint8(86),
	2477: uint8(86),
	2478: uint8(86),
	2479: uint8(86),
	2480: uint8(86),
	2481: uint8(86),
	2482: uint8(14),
	2515: uint8(42),
	2516: uint8(43),
	2517: uint8(43),
	2518: uint8(43),
	2519: uint8(43),
	2520: uint8(43),
	2521: uint8(43),
	2522: uint8(43),
	2523: uint8(43),
	2524: uint8(43),
	2525: uint8(43),
	2526: uint8(86),
	2527: uint8(86),
	2528: uint8(86),
	2529: uint8(86),
	2530: uint8(86),
	2531: uint8(86),
	2532: uint8(86),
	2533: uint8(86),
	2534: uint8(86),
	2535: uint8(86),
	2536: uint8(14),
	2580: uint8(43),
	2581: uint8(43),
	2582: uint8(43),
	2583: uint8(43),
	2584: uint8(43),
	2585: uint8(43),
	2586: uint8(43),
	2587: uint8(43),
	2588: uint8(43),
	2589: uint8(43),
	2590: uint8(43),
	2591: uint8(85),
	2592: uint8(86),
	2593: uint8(86),
	2594: uint8(86),
	2595: uint8(86),
	2596: uint8(86),
	2597: uint8(86),
	2598: uint8(86),
	2599: uint8(86),
	2600: uint8(86),
	2601: uint8(86),
	2602: uint8(14),
}
var _rules = [240]int32{
	1:   int32(0x2001),
	2:   -int32(0x2000),
	3:   int32(0x1dbf00),
	4:   int32(0x2e700),
	5:   int32(0x7900),
	6:   int32(0x2402),
	7:   int32(0x101),
	8:   -int32(0x100),
	10:  int32(0x201),
	11:  -int32(0x200),
	12:  -int32(0xc6ff),
	13:  -int32(0xe800),
	14:  -int32(0x78ff),
	15:  -int32(0x12c00),
	16:  int32(0xc300),
	17:  int32(0xd201),
	18:  int32(0xce01),
	19:  int32(0xcd01),
	20:  int32(0x4f01),
	21:  int32(0xca01),
	22:  int32(0xcb01),
	23:  int32(0xcf01),
	24:  int32(0x6100),
	25:  int32(0xd301),
	26:  int32(0xd101),
	27:  int32(0xa300),
	28:  int32(0xd501),
	29:  int32(0x8200),
	30:  int32(0xd601),
	31:  int32(0xda01),
	32:  int32(0xd901),
	33:  int32(0xdb01),
	34:  int32(0x3800),
	35:  int32(0x3),
	36:  -int32(0x4f00),
	37:  -int32(0x60ff),
	38:  -int32(0x37ff),
	39:  int32(0x242802),
	41:  int32(0x101),
	42:  -int32(0x100),
	43:  -int32(0xcd00),
	44:  -int32(0xda00),
	45:  -int32(0x81ff),
	46:  int32(0x2a2b01),
	47:  -int32(0xa2ff),
	48:  int32(0x2a2801),
	49:  int32(0x2a3f00),
	50:  -int32(0xc2ff),
	51:  int32(0x4501),
	52:  int32(0x4701),
	53:  int32(0x2a1f00),
	54:  int32(0x2a1c00),
	55:  int32(0x2a1e00),
	56:  -int32(0xd200),
	57:  -int32(0xce00),
	58:  -int32(0xca00),
	59:  -int32(0xcb00),
	60:  int32(0xa54f00),
	61:  int32(0xa54b00),
	62:  -int32(0xcf00),
	63:  int32(0xa52800),
	64:  int32(0xa54400),
	65:  -int32(0xd100),
	66:  -int32(0xd300),
	67:  int32(0x29f700),
	68:  int32(0xa54100),
	69:  int32(0x29fd00),
	70:  -int32(0xd500),
	71:  -int32(0xd600),
	72:  int32(0x29e700),
	73:  int32(0xa54300),
	74:  int32(0xa52a00),
	75:  -int32(0x4500),
	76:  -int32(0xd900),
	77:  -int32(0x4700),
	78:  -int32(0xdb00),
	79:  int32(0xa51500),
	80:  int32(0xa51200),
	81:  int32(0x4c2402),
	83:  int32(0x2001),
	84:  -int32(0x2000),
	85:  int32(0x101),
	86:  -int32(0x100),
	87:  int32(0x5400),
	88:  int32(0x7401),
	89:  int32(0x2601),
	90:  int32(0x2501),
	91:  int32(0x4001),
	92:  int32(0x3f01),
	93:  -int32(0x2600),
	94:  -int32(0x2500),
	95:  -int32(0x1f00),
	96:  -int32(0x4000),
	97:  -int32(0x3f00),
	98:  int32(0x801),
	99:  -int32(0x3e00),
	100: -int32(0x3900),
	101: -int32(0x2f00),
	102: -int32(0x3600),
	103: -int32(0x800),
	104: -int32(0x5600),
	105: -int32(0x5000),
	106: int32(0x700),
	107: -int32(0x7400),
	108: -int32(0x3bff),
	109: -int32(0x6000),
	110: -int32(0x6ff),
	111: int32(0x701a02),
	112: int32(0x101),
	113: -int32(0x100),
	114: int32(0x2001),
	115: -int32(0x2000),
	116: int32(0x5001),
	117: int32(0xf01),
	118: -int32(0xf00),
	120: int32(0x3001),
	121: -int32(0x3000),
	122: int32(0x101),
	123: -int32(0x100),
	125: int32(0xbc000),
	126: int32(0x1c6001),
	128: int32(0x97d001),
	129: int32(0x801),
	130: -int32(0x800),
	131: int32(0x8a0502),
	133: -int32(0xbbfff),
	134: -int32(0x186200),
	135: int32(0x89c200),
	136: -int32(0x182500),
	137: -int32(0x186e00),
	138: -int32(0x186d00),
	139: -int32(0x186400),
	140: -int32(0x186300),
	141: -int32(0x185c00),
	143: int32(0x8a3800),
	144: int32(0x8a0400),
	145: int32(0xee600),
	146: int32(0x101),
	147: -int32(0x100),
	149: -int32(0x3b00),
	150: -int32(0x1dbeff),
	151: int32(0x8f1d02),
	152: int32(0x800),
	153: -int32(0x7ff),
	155: int32(0x5600),
	156: -int32(0x55ff),
	157: int32(0x4a00),
	158: int32(0x6400),
	159: int32(0x8000),
	160: int32(0x7000),
	161: int32(0x7e00),
	162: int32(0x900),
	163: -int32(0x49ff),
	164: -int32(0x8ff),
	165: -int32(0x1c2500),
	166: -int32(0x63ff),
	167: -int32(0x6fff),
	168: -int32(0x7fff),
	169: -int32(0x7dff),
	170: int32(0xac0502),
	172: int32(0x1001),
	173: -int32(0x1000),
	174: int32(0x1c01),
	175: int32(0x101),
	176: -int32(0x1d5cff),
	177: -int32(0x20beff),
	178: -int32(0x2045ff),
	179: -int32(0x1c00),
	180: int32(0xb10b02),
	181: int32(0x101),
	182: -int32(0x100),
	183: int32(0x3001),
	184: -int32(0x3000),
	186: -int32(0x29f6ff),
	187: -int32(0xee5ff),
	188: -int32(0x29e6ff),
	189: -int32(0x2a2b00),
	190: -int32(0x2a2800),
	191: -int32(0x2a1bff),
	192: -int32(0x29fcff),
	193: -int32(0x2a1eff),
	194: -int32(0x2a1dff),
	195: -int32(0x2a3eff),
	197: -int32(0x1c6000),
	199: int32(0x101),
	200: -int32(0x100),
	201: int32(0xbc0c02),
	203: int32(0x101),
	204: -int32(0x100),
	205: -int32(0xa543ff),
	206: int32(0x3a001),
	207: -int32(0x8a03ff),
	208: -int32(0xa527ff),
	209: int32(0x3000),
	210: -int32(0xa54eff),
	211: -int32(0xa54aff),
	212: -int32(0xa540ff),
	213: -int32(0xa511ff),
	214: -int32(0xa529ff),
	215: -int32(0xa514ff),
	216: -int32(0x2fff),
	217: -int32(0xa542ff),
	218: -int32(0x8a37ff),
	220: -int32(0x97d000),
	221: -int32(0x3a000),
	223: int32(0x2001),
	224: -int32(0x2000),
	226: int32(0x2801),
	227: -int32(0x2800),
	229: int32(0x4001),
	230: -int32(0x4000),
	232: int32(0x2001),
	233: -int32(0x2000),
	235: int32(0x2001),
	236: -int32(0x2000),
	238: int32(0x2201),
	239: -int32(0x2200),
}
var _rulebases = [512]uint8{
	1:   uint8(6),
	2:   uint8(39),
	3:   uint8(81),
	4:   uint8(111),
	5:   uint8(119),
	16:  uint8(124),
	19:  uint8(127),
	28:  uint8(131),
	29:  uint8(142),
	30:  uint8(146),
	31:  uint8(151),
	33:  uint8(170),
	44:  uint8(180),
	45:  uint8(196),
	166: uint8(198),
	167: uint8(201),
	171: uint8(219),
	255: uint8(222),
	260: uint8(225),
	268: uint8(228),
	280: uint8(231),
	366: uint8(234),
	489: uint8(237),
}
var _exceptions = [200][2]uint8{
	0: {
		0: uint8(48),
		1: uint8(12),
	},
	1: {
		0: uint8(49),
		1: uint8(13),
	},
	2: {
		0: uint8(120),
		1: uint8(14),
	},
	3: {
		0: uint8(127),
		1: uint8(15),
	},
	4: {
		0: uint8(128),
		1: uint8(16),
	},
	5: {
		0: uint8(129),
		1: uint8(17),
	},
	6: {
		0: uint8(134),
		1: uint8(18),
	},
	7: {
		0: uint8(137),
		1: uint8(19),
	},
	8: {
		0: uint8(138),
		1: uint8(19),
	},
	9: {
		0: uint8(142),
		1: uint8(20),
	},
	10: {
		0: uint8(143),
		1: uint8(21),
	},
	11: {
		0: uint8(144),
		1: uint8(22),
	},
	12: {
		0: uint8(147),
		1: uint8(19),
	},
	13: {
		0: uint8(148),
		1: uint8(23),
	},
	14: {
		0: uint8(149),
		1: uint8(24),
	},
	15: {
		0: uint8(150),
		1: uint8(25),
	},
	16: {
		0: uint8(151),
		1: uint8(26),
	},
	17: {
		0: uint8(154),
		1: uint8(27),
	},
	18: {
		0: uint8(156),
		1: uint8(25),
	},
	19: {
		0: uint8(157),
		1: uint8(28),
	},
	20: {
		0: uint8(158),
		1: uint8(29),
	},
	21: {
		0: uint8(159),
		1: uint8(30),
	},
	22: {
		0: uint8(166),
		1: uint8(31),
	},
	23: {
		0: uint8(169),
		1: uint8(31),
	},
	24: {
		0: uint8(174),
		1: uint8(31),
	},
	25: {
		0: uint8(177),
		1: uint8(32),
	},
	26: {
		0: uint8(178),
		1: uint8(32),
	},
	27: {
		0: uint8(183),
		1: uint8(33),
	},
	28: {
		0: uint8(191),
		1: uint8(34),
	},
	29: {
		0: uint8(197),
		1: uint8(35),
	},
	30: {
		0: uint8(200),
		1: uint8(35),
	},
	31: {
		0: uint8(203),
		1: uint8(35),
	},
	32: {
		0: uint8(221),
		1: uint8(36),
	},
	33: {
		0: uint8(242),
		1: uint8(35),
	},
	34: {
		0: uint8(246),
		1: uint8(37),
	},
	35: {
		0: uint8(247),
		1: uint8(38),
	},
	36: {
		0: uint8(32),
		1: uint8(45),
	},
	37: {
		0: uint8(58),
		1: uint8(46),
	},
	38: {
		0: uint8(61),
		1: uint8(47),
	},
	39: {
		0: uint8(62),
		1: uint8(48),
	},
	40: {
		0: uint8(63),
		1: uint8(49),
	},
	41: {
		0: uint8(64),
		1: uint8(49),
	},
	42: {
		0: uint8(67),
		1: uint8(50),
	},
	43: {
		0: uint8(68),
		1: uint8(51),
	},
	44: {
		0: uint8(69),
		1: uint8(52),
	},
	45: {
		0: uint8(80),
		1: uint8(53),
	},
	46: {
		0: uint8(81),
		1: uint8(54),
	},
	47: {
		0: uint8(82),
		1: uint8(55),
	},
	48: {
		0: uint8(83),
		1: uint8(56),
	},
	49: {
		0: uint8(84),
		1: uint8(57),
	},
	50: {
		0: uint8(89),
		1: uint8(58),
	},
	51: {
		0: uint8(91),
		1: uint8(59),
	},
	52: {
		0: uint8(92),
		1: uint8(60),
	},
	53: {
		0: uint8(97),
		1: uint8(61),
	},
	54: {
		0: uint8(99),
		1: uint8(62),
	},
	55: {
		0: uint8(101),
		1: uint8(63),
	},
	56: {
		0: uint8(102),
		1: uint8(64),
	},
	57: {
		0: uint8(104),
		1: uint8(65),
	},
	58: {
		0: uint8(105),
		1: uint8(66),
	},
	59: {
		0: uint8(106),
		1: uint8(64),
	},
	60: {
		0: uint8(107),
		1: uint8(67),
	},
	61: {
		0: uint8(108),
		1: uint8(68),
	},
	62: {
		0: uint8(111),
		1: uint8(66),
	},
	63: {
		0: uint8(113),
		1: uint8(69),
	},
	64: {
		0: uint8(114),
		1: uint8(70),
	},
	65: {
		0: uint8(117),
		1: uint8(71),
	},
	66: {
		0: uint8(125),
		1: uint8(72),
	},
	67: {
		0: uint8(130),
		1: uint8(73),
	},
	68: {
		0: uint8(135),
		1: uint8(74),
	},
	69: {
		0: uint8(137),
		1: uint8(75),
	},
	70: {
		0: uint8(138),
		1: uint8(76),
	},
	71: {
		0: uint8(139),
		1: uint8(76),
	},
	72: {
		0: uint8(140),
		1: uint8(77),
	},
	73: {
		0: uint8(146),
		1: uint8(78),
	},
	74: {
		0: uint8(157),
		1: uint8(79),
	},
	75: {
		0: uint8(158),
		1: uint8(80),
	},
	76: {
		0: uint8(69),
		1: uint8(87),
	},
	77: {
		0: uint8(123),
		1: uint8(29),
	},
	78: {
		0: uint8(124),
		1: uint8(29),
	},
	79: {
		0: uint8(125),
		1: uint8(29),
	},
	80: {
		0: uint8(127),
		1: uint8(88),
	},
	81: {
		0: uint8(134),
		1: uint8(89),
	},
	82: {
		0: uint8(136),
		1: uint8(90),
	},
	83: {
		0: uint8(137),
		1: uint8(90),
	},
	84: {
		0: uint8(138),
		1: uint8(90),
	},
	85: {
		0: uint8(140),
		1: uint8(91),
	},
	86: {
		0: uint8(142),
		1: uint8(92),
	},
	87: {
		0: uint8(143),
		1: uint8(92),
	},
	88: {
		0: uint8(172),
		1: uint8(93),
	},
	89: {
		0: uint8(173),
		1: uint8(94),
	},
	90: {
		0: uint8(174),
		1: uint8(94),
	},
	91: {
		0: uint8(175),
		1: uint8(94),
	},
	92: {
		0: uint8(194),
		1: uint8(95),
	},
	93: {
		0: uint8(204),
		1: uint8(96),
	},
	94: {
		0: uint8(205),
		1: uint8(97),
	},
	95: {
		0: uint8(206),
		1: uint8(97),
	},
	96: {
		0: uint8(207),
		1: uint8(98),
	},
	97: {
		0: uint8(208),
		1: uint8(99),
	},
	98: {
		0: uint8(209),
		1: uint8(100),
	},
	99: {
		0: uint8(213),
		1: uint8(101),
	},
	100: {
		0: uint8(214),
		1: uint8(102),
	},
	101: {
		0: uint8(215),
		1: uint8(103),
	},
	102: {
		0: uint8(240),
		1: uint8(104),
	},
	103: {
		0: uint8(241),
		1: uint8(105),
	},
	104: {
		0: uint8(242),
		1: uint8(106),
	},
	105: {
		0: uint8(243),
		1: uint8(107),
	},
	106: {
		0: uint8(244),
		1: uint8(108),
	},
	107: {
		0: uint8(245),
		1: uint8(109),
	},
	108: {
		0: uint8(249),
		1: uint8(110),
	},
	109: {
		0: uint8(253),
		1: uint8(45),
	},
	110: {
		0: uint8(254),
		1: uint8(45),
	},
	111: {
		0: uint8(255),
		1: uint8(45),
	},
	112: {
		0: uint8(80),
		1: uint8(105),
	},
	113: {
		0: uint8(81),
		1: uint8(105),
	},
	114: {
		0: uint8(82),
		1: uint8(105),
	},
	115: {
		0: uint8(83),
		1: uint8(105),
	},
	116: {
		0: uint8(84),
		1: uint8(105),
	},
	117: {
		0: uint8(85),
		1: uint8(105),
	},
	118: {
		0: uint8(86),
		1: uint8(105),
	},
	119: {
		0: uint8(87),
		1: uint8(105),
	},
	120: {
		0: uint8(88),
		1: uint8(105),
	},
	121: {
		0: uint8(89),
		1: uint8(105),
	},
	122: {
		0: uint8(90),
		1: uint8(105),
	},
	123: {
		0: uint8(91),
		1: uint8(105),
	},
	124: {
		0: uint8(92),
		1: uint8(105),
	},
	125: {
		0: uint8(93),
		1: uint8(105),
	},
	126: {
		0: uint8(94),
		1: uint8(105),
	},
	127: {
		0: uint8(95),
		1: uint8(105),
	},
	128: {
		0: uint8(130),
	},
	129: {
		0: uint8(131),
	},
	130: {
		0: uint8(132),
	},
	131: {
		0: uint8(133),
	},
	132: {
		0: uint8(134),
	},
	133: {
		0: uint8(135),
	},
	134: {
		0: uint8(136),
	},
	135: {
		0: uint8(137),
	},
	136: {
		0: uint8(192),
		1: uint8(117),
	},
	137: {
		0: uint8(207),
		1: uint8(118),
	},
	138: {
		0: uint8(128),
		1: uint8(137),
	},
	139: {
		0: uint8(129),
		1: uint8(138),
	},
	140: {
		0: uint8(130),
		1: uint8(139),
	},
	141: {
		0: uint8(133),
		1: uint8(140),
	},
	142: {
		0: uint8(134),
		1: uint8(141),
	},
	143: {
		0: uint8(112),
		1: uint8(157),
	},
	144: {
		0: uint8(113),
		1: uint8(157),
	},
	145: {
		0: uint8(118),
		1: uint8(158),
	},
	146: {
		0: uint8(119),
		1: uint8(158),
	},
	147: {
		0: uint8(120),
		1: uint8(159),
	},
	148: {
		0: uint8(121),
		1: uint8(159),
	},
	149: {
		0: uint8(122),
		1: uint8(160),
	},
	150: {
		0: uint8(123),
		1: uint8(160),
	},
	151: {
		0: uint8(124),
		1: uint8(161),
	},
	152: {
		0: uint8(125),
		1: uint8(161),
	},
	153: {
		0: uint8(179),
		1: uint8(162),
	},
	154: {
		0: uint8(186),
		1: uint8(163),
	},
	155: {
		0: uint8(187),
		1: uint8(163),
	},
	156: {
		0: uint8(188),
		1: uint8(164),
	},
	157: {
		0: uint8(190),
		1: uint8(165),
	},
	158: {
		0: uint8(195),
		1: uint8(162),
	},
	159: {
		0: uint8(204),
		1: uint8(164),
	},
	160: {
		0: uint8(218),
		1: uint8(166),
	},
	161: {
		0: uint8(219),
		1: uint8(166),
	},
	162: {
		0: uint8(229),
		1: uint8(106),
	},
	163: {
		0: uint8(234),
		1: uint8(167),
	},
	164: {
		0: uint8(235),
		1: uint8(167),
	},
	165: {
		0: uint8(236),
		1: uint8(110),
	},
	166: {
		0: uint8(243),
		1: uint8(162),
	},
	167: {
		0: uint8(248),
		1: uint8(168),
	},
	168: {
		0: uint8(249),
		1: uint8(168),
	},
	169: {
		0: uint8(250),
		1: uint8(169),
	},
	170: {
		0: uint8(251),
		1: uint8(169),
	},
	171: {
		0: uint8(252),
		1: uint8(164),
	},
	172: {
		0: uint8(38),
		1: uint8(176),
	},
	173: {
		0: uint8(42),
		1: uint8(177),
	},
	174: {
		0: uint8(43),
		1: uint8(178),
	},
	175: {
		0: uint8(78),
		1: uint8(179),
	},
	176: {
		0: uint8(132),
		1: uint8(8),
	},
	177: {
		0: uint8(98),
		1: uint8(186),
	},
	178: {
		0: uint8(99),
		1: uint8(187),
	},
	179: {
		0: uint8(100),
		1: uint8(188),
	},
	180: {
		0: uint8(101),
		1: uint8(189),
	},
	181: {
		0: uint8(102),
		1: uint8(190),
	},
	182: {
		0: uint8(109),
		1: uint8(191),
	},
	183: {
		0: uint8(110),
		1: uint8(192),
	},
	184: {
		0: uint8(111),
		1: uint8(193),
	},
	185: {
		0: uint8(112),
		1: uint8(194),
	},
	186: {
		0: uint8(126),
		1: uint8(195),
	},
	187: {
		0: uint8(127),
		1: uint8(195),
	},
	188: {
		0: uint8(125),
		1: uint8(207),
	},
	189: {
		0: uint8(141),
		1: uint8(208),
	},
	190: {
		0: uint8(148),
		1: uint8(209),
	},
	191: {
		0: uint8(171),
		1: uint8(210),
	},
	192: {
		0: uint8(172),
		1: uint8(211),
	},
	193: {
		0: uint8(173),
		1: uint8(212),
	},
	194: {
		0: uint8(176),
		1: uint8(213),
	},
	195: {
		0: uint8(177),
		1: uint8(214),
	},
	196: {
		0: uint8(178),
		1: uint8(215),
	},
	197: {
		0: uint8(196),
		1: uint8(216),
	},
	198: {
		0: uint8(197),
		1: uint8(217),
	},
	199: {
		0: uint8(198),
		1: uint8(218),
	},
}

func _casemap(tls *TLS, c uint32, dir int32) (r1 int32) {
	var b, rt, try, v, x, xb, xn, y uint32
	var c0, r, rd, v1 int32
	_, _, _, _, _, _, _, _, _, _, _, _ = b, c0, r, rd, rt, try, v, x, xb, xn, y, v1
	c0 = int32(c)
	if c >= uint32(0x20000) {
		return int32(c)
	}
	b = c >> int32(8)
	c &= uint32(255)
	x = c / uint32(3)
	y = c % uint32(3)
	/* lookup entry in two-level base-6 table */
	v = uint32(_tab1[uint32(int32(_tab1[b])*int32(86))+x])
	v = v * uint32(_mt[y]) >> int32(11) % uint32(6)
	/* use the bit vector out of the tables as an index into
	 * a block-specific set of rules and decode the rule into
	 * a type and a case-mapping delta. */
	r = _rules[uint32(_rulebases[b])+v]
	rt = uint32(r & int32(255))
	rd = r >> int32(8)
	/* rules 0/1 are simple lower/upper case with a delta.
	 * apply according to desired mapping direction. */
	if rt < uint32(2) {
		return int32(uint32(c0) + uint32(rd)&-(rt^uint32(dir)))
	}
	/* binary search. endpoints of the binary search for
	 * this block are stored in the rule delta field. */
	xn = uint32(rd & int32(0xff))
	xb = uint32(rd) >> int32(8)
	for xn != 0 {
		try = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_exceptions)) + uintptr(xb+xn/uint32(2))*2)))
		if try == c {
			r = _rules[*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_exceptions)) + uintptr(xb+xn/uint32(2))*2 + 1))]
			rt = uint32(r & int32(255))
			rd = r >> int32(8)
			if rt < uint32(2) {
				return int32(uint32(c0) + uint32(rd)&-(rt^uint32(dir)))
			}
			/* Hard-coded for the four exceptional titlecase */
			if dir != 0 {
				v1 = -int32(1)
			} else {
				v1 = int32(1)
			}
			return c0 + v1
		} else {
			if try > c {
				xn /= uint32(2)
			} else {
				xb += xn / uint32(2)
				xn -= xn / uint32(2)
			}
		}
	}
	return c0
}

var _mt = [3]int32{
	0: int32(2048),
	1: int32(342),
	2: int32(57),
}

func Xtowlower(tls *TLS, wc Twint_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint32(_casemap(tls, wc, 0))
}

func Xtowupper(tls *TLS, wc Twint_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint32(_casemap(tls, wc, int32(1)))
}

func X__towupper_l(tls *TLS, c Twint_t, l Tlocale_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtowupper(tls, c)
}

func X__towlower_l(tls *TLS, c Twint_t, l Tlocale_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtowlower(tls, c)
}

func Xtowlower_l(tls *TLS, c Twint_t, l Tlocale_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__towlower_l(tls, c, l)
}

func Xtowupper_l(tls *TLS, c Twint_t, l Tlocale_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v l=%v, (%v:)", tls, c, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__towupper_l(tls, c, l)
}

func Xwcswidth(tls *TLS, wcs uintptr, n Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wcs=%v n=%v, (%v:)", tls, wcs, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var k, l, v3, v5 int32
	var v2 Tsize_t
	var v4 bool
	_, _, _, _, _, _ = k, l, v2, v3, v4, v5
	l = 0
	k = 0
	for {
		v2 = n
		n--
		if v4 = v2 != 0 && *(*Twchar_t)(unsafe.Pointer(wcs)) != 0; v4 {
			v3 = Xwcwidth(tls, *(*Twchar_t)(unsafe.Pointer(wcs)))
			k = v3
		}
		if !(v4 && v3 >= 0) {
			break
		}
		goto _1
	_1:
		;
		l += k
		wcs += 4
	}
	if k < 0 {
		v5 = k
	} else {
		v5 = l
	}
	return v5
}

func Xwctrans(tls *TLS, class uintptr) (r Twctrans_t) {
	if __ccgo_strace {
		trc("tls=%v class=%v, (%v:)", tls, class, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if !(Xstrcmp(tls, class, __ccgo_ts+196) != 0) {
		return UintptrFromInt32(1)
	}
	if !(Xstrcmp(tls, class, __ccgo_ts+204) != 0) {
		return UintptrFromInt32(2)
	}
	return uintptr(0)
}

func Xtowctrans(tls *TLS, wc Twint_t, trans Twctrans_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v wc=%v trans=%v, (%v:)", tls, wc, trans, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if trans == UintptrFromInt32(1) {
		return Xtowupper(tls, wc)
	}
	if trans == UintptrFromInt32(2) {
		return Xtowlower(tls, wc)
	}
	return wc
}

func X__wctrans_l(tls *TLS, s uintptr, l Tlocale_t) (r Twctrans_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v l=%v, (%v:)", tls, s, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwctrans(tls, s)
}

func X__towctrans_l(tls *TLS, c Twint_t, t Twctrans_t, l Tlocale_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v t=%v l=%v, (%v:)", tls, c, t, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtowctrans(tls, c, t)
}

func Xtowctrans_l(tls *TLS, c Twint_t, t Twctrans_t, l Tlocale_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v t=%v l=%v, (%v:)", tls, c, t, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__towctrans_l(tls, c, t, l)
}

func Xwctrans_l(tls *TLS, s uintptr, l Tlocale_t) (r Twctrans_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v l=%v, (%v:)", tls, s, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__wctrans_l(tls, s, l)
}

var _table5 = [2784]uint8{
	0:    uint8(16),
	1:    uint8(16),
	2:    uint8(16),
	3:    uint8(18),
	4:    uint8(19),
	5:    uint8(20),
	6:    uint8(21),
	7:    uint8(22),
	8:    uint8(23),
	9:    uint8(24),
	10:   uint8(25),
	11:   uint8(26),
	12:   uint8(27),
	13:   uint8(28),
	14:   uint8(29),
	15:   uint8(30),
	16:   uint8(31),
	17:   uint8(32),
	18:   uint8(16),
	19:   uint8(33),
	20:   uint8(16),
	21:   uint8(16),
	22:   uint8(16),
	23:   uint8(34),
	24:   uint8(35),
	25:   uint8(36),
	26:   uint8(37),
	27:   uint8(38),
	28:   uint8(39),
	29:   uint8(40),
	30:   uint8(16),
	31:   uint8(16),
	32:   uint8(41),
	33:   uint8(16),
	34:   uint8(16),
	35:   uint8(16),
	36:   uint8(16),
	37:   uint8(16),
	38:   uint8(16),
	39:   uint8(16),
	40:   uint8(16),
	41:   uint8(16),
	42:   uint8(16),
	43:   uint8(16),
	44:   uint8(42),
	45:   uint8(43),
	46:   uint8(16),
	47:   uint8(16),
	48:   uint8(44),
	49:   uint8(16),
	50:   uint8(16),
	51:   uint8(16),
	52:   uint8(16),
	53:   uint8(16),
	54:   uint8(16),
	55:   uint8(16),
	56:   uint8(16),
	57:   uint8(16),
	58:   uint8(16),
	59:   uint8(16),
	60:   uint8(16),
	61:   uint8(16),
	62:   uint8(16),
	63:   uint8(16),
	64:   uint8(16),
	65:   uint8(16),
	66:   uint8(16),
	67:   uint8(16),
	68:   uint8(16),
	69:   uint8(16),
	70:   uint8(16),
	71:   uint8(16),
	72:   uint8(16),
	73:   uint8(16),
	74:   uint8(16),
	75:   uint8(16),
	76:   uint8(16),
	77:   uint8(16),
	78:   uint8(16),
	79:   uint8(16),
	80:   uint8(16),
	81:   uint8(16),
	82:   uint8(16),
	83:   uint8(16),
	84:   uint8(16),
	85:   uint8(16),
	86:   uint8(16),
	87:   uint8(16),
	88:   uint8(16),
	89:   uint8(16),
	90:   uint8(16),
	91:   uint8(16),
	92:   uint8(16),
	93:   uint8(16),
	94:   uint8(16),
	95:   uint8(16),
	96:   uint8(16),
	97:   uint8(16),
	98:   uint8(16),
	99:   uint8(16),
	100:  uint8(16),
	101:  uint8(16),
	102:  uint8(16),
	103:  uint8(16),
	104:  uint8(16),
	105:  uint8(16),
	106:  uint8(16),
	107:  uint8(16),
	108:  uint8(16),
	109:  uint8(16),
	110:  uint8(16),
	111:  uint8(16),
	112:  uint8(16),
	113:  uint8(16),
	114:  uint8(16),
	115:  uint8(16),
	116:  uint8(16),
	117:  uint8(16),
	118:  uint8(16),
	119:  uint8(16),
	120:  uint8(16),
	121:  uint8(16),
	122:  uint8(16),
	123:  uint8(16),
	124:  uint8(16),
	125:  uint8(16),
	126:  uint8(16),
	127:  uint8(16),
	128:  uint8(16),
	129:  uint8(16),
	130:  uint8(16),
	131:  uint8(16),
	132:  uint8(16),
	133:  uint8(16),
	134:  uint8(16),
	135:  uint8(16),
	136:  uint8(16),
	137:  uint8(16),
	138:  uint8(16),
	139:  uint8(16),
	140:  uint8(16),
	141:  uint8(16),
	142:  uint8(16),
	143:  uint8(16),
	144:  uint8(16),
	145:  uint8(16),
	146:  uint8(16),
	147:  uint8(16),
	148:  uint8(16),
	149:  uint8(16),
	150:  uint8(16),
	151:  uint8(16),
	152:  uint8(16),
	153:  uint8(16),
	154:  uint8(16),
	155:  uint8(16),
	156:  uint8(16),
	157:  uint8(16),
	158:  uint8(16),
	159:  uint8(16),
	160:  uint8(16),
	161:  uint8(16),
	162:  uint8(16),
	163:  uint8(16),
	164:  uint8(16),
	165:  uint8(16),
	166:  uint8(45),
	167:  uint8(16),
	168:  uint8(46),
	169:  uint8(47),
	170:  uint8(48),
	171:  uint8(49),
	172:  uint8(16),
	173:  uint8(16),
	174:  uint8(16),
	175:  uint8(16),
	176:  uint8(16),
	177:  uint8(16),
	178:  uint8(16),
	179:  uint8(16),
	180:  uint8(16),
	181:  uint8(16),
	182:  uint8(16),
	183:  uint8(16),
	184:  uint8(16),
	185:  uint8(16),
	186:  uint8(16),
	187:  uint8(16),
	188:  uint8(16),
	189:  uint8(16),
	190:  uint8(16),
	191:  uint8(16),
	192:  uint8(16),
	193:  uint8(16),
	194:  uint8(16),
	195:  uint8(16),
	196:  uint8(16),
	197:  uint8(16),
	198:  uint8(16),
	199:  uint8(16),
	200:  uint8(16),
	201:  uint8(16),
	202:  uint8(16),
	203:  uint8(16),
	204:  uint8(16),
	205:  uint8(16),
	206:  uint8(16),
	207:  uint8(16),
	208:  uint8(16),
	209:  uint8(16),
	210:  uint8(16),
	211:  uint8(16),
	212:  uint8(16),
	213:  uint8(16),
	214:  uint8(16),
	215:  uint8(50),
	216:  uint8(16),
	217:  uint8(16),
	218:  uint8(16),
	219:  uint8(16),
	220:  uint8(16),
	221:  uint8(16),
	222:  uint8(16),
	223:  uint8(16),
	224:  uint8(16),
	225:  uint8(16),
	226:  uint8(16),
	227:  uint8(16),
	228:  uint8(16),
	229:  uint8(16),
	230:  uint8(16),
	231:  uint8(16),
	232:  uint8(16),
	233:  uint8(16),
	234:  uint8(16),
	235:  uint8(16),
	236:  uint8(16),
	237:  uint8(16),
	238:  uint8(16),
	239:  uint8(16),
	240:  uint8(16),
	241:  uint8(16),
	242:  uint8(16),
	243:  uint8(16),
	244:  uint8(16),
	245:  uint8(16),
	246:  uint8(16),
	247:  uint8(16),
	248:  uint8(16),
	249:  uint8(16),
	250:  uint8(16),
	251:  uint8(51),
	252:  uint8(16),
	253:  uint8(16),
	254:  uint8(52),
	255:  uint8(53),
	256:  uint8(16),
	257:  uint8(54),
	258:  uint8(55),
	259:  uint8(56),
	260:  uint8(16),
	261:  uint8(16),
	262:  uint8(16),
	263:  uint8(16),
	264:  uint8(16),
	265:  uint8(16),
	266:  uint8(57),
	267:  uint8(16),
	268:  uint8(16),
	269:  uint8(58),
	270:  uint8(16),
	271:  uint8(59),
	272:  uint8(60),
	273:  uint8(61),
	274:  uint8(62),
	275:  uint8(63),
	276:  uint8(64),
	277:  uint8(65),
	278:  uint8(66),
	279:  uint8(67),
	280:  uint8(68),
	281:  uint8(69),
	282:  uint8(70),
	283:  uint8(16),
	284:  uint8(71),
	285:  uint8(72),
	286:  uint8(73),
	287:  uint8(16),
	288:  uint8(16),
	289:  uint8(16),
	290:  uint8(16),
	291:  uint8(16),
	292:  uint8(16),
	293:  uint8(16),
	294:  uint8(16),
	295:  uint8(16),
	296:  uint8(16),
	297:  uint8(16),
	298:  uint8(16),
	299:  uint8(16),
	300:  uint8(16),
	301:  uint8(16),
	302:  uint8(16),
	303:  uint8(16),
	304:  uint8(16),
	305:  uint8(16),
	306:  uint8(16),
	307:  uint8(16),
	308:  uint8(74),
	309:  uint8(16),
	310:  uint8(16),
	311:  uint8(16),
	312:  uint8(16),
	313:  uint8(16),
	314:  uint8(16),
	315:  uint8(16),
	316:  uint8(16),
	317:  uint8(16),
	318:  uint8(16),
	319:  uint8(16),
	320:  uint8(16),
	321:  uint8(16),
	322:  uint8(16),
	323:  uint8(16),
	324:  uint8(16),
	325:  uint8(16),
	326:  uint8(16),
	327:  uint8(16),
	328:  uint8(16),
	329:  uint8(16),
	330:  uint8(16),
	331:  uint8(16),
	332:  uint8(16),
	333:  uint8(16),
	334:  uint8(16),
	335:  uint8(16),
	336:  uint8(16),
	337:  uint8(16),
	338:  uint8(16),
	339:  uint8(16),
	340:  uint8(16),
	341:  uint8(16),
	342:  uint8(16),
	343:  uint8(16),
	344:  uint8(16),
	345:  uint8(16),
	346:  uint8(16),
	347:  uint8(16),
	348:  uint8(16),
	349:  uint8(16),
	350:  uint8(16),
	351:  uint8(16),
	352:  uint8(16),
	353:  uint8(16),
	354:  uint8(16),
	355:  uint8(16),
	356:  uint8(16),
	357:  uint8(16),
	358:  uint8(16),
	359:  uint8(16),
	360:  uint8(16),
	361:  uint8(16),
	362:  uint8(75),
	363:  uint8(76),
	364:  uint8(16),
	365:  uint8(16),
	366:  uint8(16),
	367:  uint8(77),
	368:  uint8(16),
	369:  uint8(16),
	370:  uint8(16),
	371:  uint8(16),
	372:  uint8(16),
	373:  uint8(16),
	374:  uint8(16),
	375:  uint8(16),
	376:  uint8(16),
	377:  uint8(16),
	378:  uint8(16),
	379:  uint8(16),
	380:  uint8(16),
	381:  uint8(16),
	382:  uint8(16),
	383:  uint8(16),
	384:  uint8(16),
	385:  uint8(16),
	386:  uint8(16),
	387:  uint8(16),
	388:  uint8(16),
	389:  uint8(16),
	390:  uint8(16),
	391:  uint8(16),
	392:  uint8(16),
	393:  uint8(16),
	394:  uint8(16),
	395:  uint8(16),
	396:  uint8(16),
	397:  uint8(16),
	398:  uint8(16),
	399:  uint8(16),
	400:  uint8(16),
	401:  uint8(16),
	402:  uint8(16),
	403:  uint8(16),
	404:  uint8(16),
	405:  uint8(16),
	406:  uint8(16),
	407:  uint8(16),
	408:  uint8(16),
	409:  uint8(16),
	410:  uint8(16),
	411:  uint8(16),
	412:  uint8(16),
	413:  uint8(16),
	414:  uint8(16),
	415:  uint8(16),
	416:  uint8(16),
	417:  uint8(16),
	418:  uint8(16),
	419:  uint8(16),
	420:  uint8(16),
	421:  uint8(16),
	422:  uint8(16),
	423:  uint8(16),
	424:  uint8(16),
	425:  uint8(16),
	426:  uint8(16),
	427:  uint8(16),
	428:  uint8(16),
	429:  uint8(16),
	430:  uint8(16),
	431:  uint8(16),
	432:  uint8(16),
	433:  uint8(16),
	434:  uint8(16),
	435:  uint8(16),
	436:  uint8(16),
	437:  uint8(16),
	438:  uint8(16),
	439:  uint8(16),
	440:  uint8(16),
	441:  uint8(16),
	442:  uint8(16),
	443:  uint8(16),
	444:  uint8(78),
	445:  uint8(16),
	446:  uint8(16),
	447:  uint8(16),
	448:  uint8(16),
	449:  uint8(16),
	450:  uint8(16),
	451:  uint8(16),
	452:  uint8(16),
	453:  uint8(16),
	454:  uint8(16),
	455:  uint8(16),
	456:  uint8(16),
	457:  uint8(16),
	458:  uint8(16),
	459:  uint8(16),
	460:  uint8(16),
	461:  uint8(16),
	462:  uint8(16),
	463:  uint8(16),
	464:  uint8(16),
	465:  uint8(79),
	466:  uint8(80),
	467:  uint8(16),
	468:  uint8(16),
	469:  uint8(16),
	470:  uint8(16),
	471:  uint8(16),
	472:  uint8(16),
	473:  uint8(16),
	474:  uint8(81),
	475:  uint8(16),
	476:  uint8(16),
	477:  uint8(16),
	478:  uint8(16),
	479:  uint8(16),
	480:  uint8(82),
	481:  uint8(83),
	482:  uint8(84),
	483:  uint8(16),
	484:  uint8(16),
	485:  uint8(16),
	486:  uint8(16),
	487:  uint8(16),
	488:  uint8(85),
	489:  uint8(86),
	490:  uint8(16),
	491:  uint8(16),
	492:  uint8(16),
	493:  uint8(16),
	494:  uint8(16),
	495:  uint8(16),
	496:  uint8(16),
	497:  uint8(16),
	498:  uint8(16),
	499:  uint8(16),
	500:  uint8(16),
	501:  uint8(16),
	502:  uint8(16),
	503:  uint8(16),
	504:  uint8(16),
	505:  uint8(16),
	506:  uint8(16),
	507:  uint8(16),
	508:  uint8(16),
	509:  uint8(16),
	510:  uint8(16),
	511:  uint8(16),
	544:  uint8(255),
	545:  uint8(255),
	546:  uint8(255),
	547:  uint8(255),
	548:  uint8(255),
	549:  uint8(255),
	550:  uint8(255),
	551:  uint8(255),
	552:  uint8(255),
	553:  uint8(255),
	554:  uint8(255),
	555:  uint8(255),
	556:  uint8(255),
	557:  uint8(255),
	558:  uint8(255),
	559:  uint8(255),
	560:  uint8(255),
	561:  uint8(255),
	562:  uint8(255),
	563:  uint8(255),
	564:  uint8(255),
	565:  uint8(255),
	566:  uint8(255),
	567:  uint8(255),
	568:  uint8(255),
	569:  uint8(255),
	570:  uint8(255),
	571:  uint8(255),
	572:  uint8(255),
	573:  uint8(255),
	574:  uint8(255),
	575:  uint8(255),
	576:  uint8(255),
	577:  uint8(255),
	578:  uint8(255),
	579:  uint8(255),
	580:  uint8(255),
	581:  uint8(255),
	582:  uint8(255),
	583:  uint8(255),
	584:  uint8(255),
	585:  uint8(255),
	586:  uint8(255),
	587:  uint8(255),
	588:  uint8(255),
	589:  uint8(255),
	624:  uint8(248),
	625:  uint8(3),
	658:  uint8(254),
	659:  uint8(255),
	660:  uint8(255),
	661:  uint8(255),
	662:  uint8(255),
	663:  uint8(191),
	664:  uint8(182),
	672:  uint8(63),
	674:  uint8(255),
	675:  uint8(23),
	681:  uint8(248),
	682:  uint8(255),
	683:  uint8(255),
	686:  uint8(1),
	698:  uint8(192),
	699:  uint8(191),
	700:  uint8(159),
	701:  uint8(61),
	705:  uint8(128),
	706:  uint8(2),
	710:  uint8(255),
	711:  uint8(255),
	712:  uint8(255),
	713:  uint8(7),
	724:  uint8(192),
	725:  uint8(255),
	726:  uint8(1),
	733:  uint8(248),
	734:  uint8(15),
	735:  uint8(32),
	738:  uint8(192),
	739:  uint8(251),
	740:  uint8(239),
	741:  uint8(62),
	747:  uint8(14),
	762:  uint8(248),
	763:  uint8(255),
	764:  uint8(255),
	765:  uint8(255),
	766:  uint8(255),
	767:  uint8(255),
	768:  uint8(7),
	775:  uint8(20),
	776:  uint8(254),
	777:  uint8(33),
	778:  uint8(254),
	780:  uint8(12),
	784:  uint8(2),
	791:  uint8(16),
	792:  uint8(30),
	793:  uint8(32),
	796:  uint8(12),
	799:  uint8(64),
	800:  uint8(6),
	807:  uint8(16),
	808:  uint8(134),
	809:  uint8(57),
	810:  uint8(2),
	814:  uint8(35),
	816:  uint8(6),
	823:  uint8(16),
	824:  uint8(190),
	825:  uint8(33),
	828:  uint8(12),
	831:  uint8(252),
	832:  uint8(2),
	839:  uint8(144),
	840:  uint8(30),
	841:  uint8(32),
	842:  uint8(64),
	844:  uint8(12),
	848:  uint8(4),
	856:  uint8(1),
	857:  uint8(32),
	864:  uint8(17),
	871:  uint8(192),
	872:  uint8(193),
	873:  uint8(61),
	874:  uint8(96),
	876:  uint8(12),
	880:  uint8(2),
	887:  uint8(144),
	888:  uint8(64),
	889:  uint8(48),
	892:  uint8(12),
	896:  uint8(3),
	903:  uint8(24),
	904:  uint8(30),
	905:  uint8(32),
	908:  uint8(12),
	921:  uint8(4),
	922:  uint8(92),
	934:  uint8(242),
	935:  uint8(7),
	936:  uint8(128),
	937:  uint8(127),
	950:  uint8(242),
	951:  uint8(31),
	953:  uint8(63),
	963:  uint8(3),
	966:  uint8(160),
	967:  uint8(2),
	974:  uint8(254),
	975:  uint8(127),
	976:  uint8(223),
	977:  uint8(224),
	978:  uint8(255),
	979:  uint8(254),
	980:  uint8(255),
	981:  uint8(255),
	982:  uint8(255),
	983:  uint8(31),
	984:  uint8(64),
	997:  uint8(224),
	998:  uint8(253),
	999:  uint8(102),
	1003: uint8(195),
	1004: uint8(1),
	1006: uint8(30),
	1008: uint8(100),
	1009: uint8(32),
	1011: uint8(32),
	1036: uint8(255),
	1037: uint8(255),
	1038: uint8(255),
	1039: uint8(255),
	1040: uint8(255),
	1041: uint8(255),
	1042: uint8(255),
	1043: uint8(255),
	1044: uint8(255),
	1045: uint8(255),
	1046: uint8(255),
	1047: uint8(255),
	1048: uint8(255),
	1049: uint8(255),
	1050: uint8(255),
	1051: uint8(255),
	1052: uint8(255),
	1053: uint8(255),
	1054: uint8(255),
	1055: uint8(255),
	1067: uint8(224),
	1090: uint8(28),
	1094: uint8(28),
	1098: uint8(12),
	1102: uint8(12),
	1110: uint8(176),
	1111: uint8(63),
	1112: uint8(64),
	1113: uint8(254),
	1114: uint8(15),
	1115: uint8(32),
	1121: uint8(120),
	1136: uint8(96),
	1141: uint8(2),
	1156: uint8(135),
	1157: uint8(1),
	1158: uint8(4),
	1159: uint8(14),
	1186: uint8(128),
	1187: uint8(9),
	1194: uint8(64),
	1195: uint8(127),
	1196: uint8(229),
	1197: uint8(31),
	1198: uint8(248),
	1199: uint8(159),
	1206: uint8(255),
	1207: uint8(127),
	1216: uint8(15),
	1222: uint8(208),
	1223: uint8(23),
	1224: uint8(4),
	1229: uint8(248),
	1230: uint8(15),
	1232: uint8(3),
	1236: uint8(60),
	1237: uint8(59),
	1244: uint8(64),
	1245: uint8(163),
	1246: uint8(3),
	1253: uint8(240),
	1254: uint8(207),
	1274: uint8(247),
	1275: uint8(255),
	1276: uint8(253),
	1277: uint8(33),
	1278: uint8(16),
	1279: uint8(3),
	1304: uint8(255),
	1305: uint8(255),
	1306: uint8(255),
	1307: uint8(255),
	1308: uint8(255),
	1309: uint8(255),
	1310: uint8(255),
	1311: uint8(251),
	1313: uint8(248),
	1317: uint8(124),
	1324: uint8(223),
	1325: uint8(255),
	1338: uint8(255),
	1339: uint8(255),
	1340: uint8(255),
	1341: uint8(255),
	1342: uint8(1),
	1373: uint8(128),
	1374: uint8(3),
	1391: uint8(128),
	1404: uint8(255),
	1405: uint8(255),
	1406: uint8(255),
	1407: uint8(255),
	1413: uint8(60),
	1427: uint8(6),
	1453: uint8(128),
	1454: uint8(247),
	1455: uint8(63),
	1459: uint8(192),
	1470: uint8(3),
	1472: uint8(68),
	1473: uint8(8),
	1476: uint8(96),
	1496: uint8(48),
	1500: uint8(255),
	1501: uint8(255),
	1502: uint8(3),
	1503: uint8(128),
	1508: uint8(192),
	1509: uint8(63),
	1512: uint8(128),
	1513: uint8(255),
	1514: uint8(3),
	1520: uint8(7),
	1526: uint8(200),
	1527: uint8(51),
	1532: uint8(32),
	1541: uint8(126),
	1542: uint8(102),
	1544: uint8(8),
	1545: uint8(16),
	1551: uint8(16),
	1558: uint8(157),
	1559: uint8(193),
	1560: uint8(2),
	1565: uint8(48),
	1566: uint8(64),
	1596: uint8(32),
	1597: uint8(33),
	1622: uint8(255),
	1623: uint8(255),
	1624: uint8(255),
	1625: uint8(255),
	1626: uint8(255),
	1627: uint8(255),
	1628: uint8(255),
	1629: uint8(255),
	1630: uint8(255),
	1631: uint8(255),
	1635: uint8(64),
	1664: uint8(255),
	1665: uint8(255),
	1668: uint8(255),
	1669: uint8(255),
	1695: uint8(128),
	1727: uint8(14),
	1759: uint8(32),
	1788: uint8(1),
	1806: uint8(192),
	1807: uint8(7),
	1824: uint8(110),
	1825: uint8(240),
	1831: uint8(135),
	1852: uint8(96),
	1860: uint8(240),
	1896: uint8(192),
	1897: uint8(255),
	1898: uint8(1),
	1920: uint8(2),
	1927: uint8(255),
	1928: uint8(127),
	1935: uint8(128),
	1936: uint8(3),
	1942: uint8(120),
	1943: uint8(38),
	1945: uint8(32),
	1952: uint8(7),
	1956: uint8(128),
	1957: uint8(239),
	1958: uint8(31),
	1966: uint8(8),
	1968: uint8(3),
	1974: uint8(192),
	1975: uint8(127),
	1977: uint8(30),
	1989: uint8(128),
	1990: uint8(211),
	1991: uint8(64),
	2011: uint8(128),
	2012: uint8(248),
	2013: uint8(7),
	2016: uint8(3),
	2023: uint8(24),
	2024: uint8(1),
	2028: uint8(192),
	2029: uint8(31),
	2030: uint8(31),
	2055: uint8(255),
	2056: uint8(92),
	2059: uint8(64),
	2070: uint8(248),
	2071: uint8(133),
	2072: uint8(13),
	2102: uint8(60),
	2103: uint8(176),
	2104: uint8(1),
	2107: uint8(48),
	2118: uint8(248),
	2119: uint8(167),
	2120: uint8(1),
	2133: uint8(40),
	2134: uint8(191),
	2147: uint8(224),
	2148: uint8(188),
	2149: uint8(15),
	2181: uint8(128),
	2182: uint8(255),
	2183: uint8(6),
	2234: uint8(240),
	2235: uint8(12),
	2236: uint8(1),
	2240: uint8(254),
	2241: uint8(7),
	2246: uint8(248),
	2247: uint8(121),
	2248: uint8(128),
	2250: uint8(126),
	2251: uint8(14),
	2257: uint8(252),
	2258: uint8(127),
	2259: uint8(3),
	2278: uint8(127),
	2279: uint8(191),
	2290: uint8(252),
	2291: uint8(255),
	2292: uint8(255),
	2293: uint8(252),
	2294: uint8(109),
	2310: uint8(126),
	2311: uint8(180),
	2312: uint8(191),
	2322: uint8(163),
	2366: uint8(24),
	2374: uint8(255),
	2375: uint8(1),
	2430: uint8(31),
	2438: uint8(127),
	2473: uint8(128),
	2481: uint8(128),
	2482: uint8(7),
	2515: uint8(96),
	2516: uint8(15),
	2540: uint8(128),
	2541: uint8(3),
	2542: uint8(248),
	2543: uint8(255),
	2544: uint8(231),
	2545: uint8(15),
	2549: uint8(60),
	2568: uint8(28),
	2592: uint8(255),
	2593: uint8(255),
	2594: uint8(255),
	2595: uint8(255),
	2596: uint8(255),
	2597: uint8(255),
	2598: uint8(127),
	2599: uint8(248),
	2600: uint8(255),
	2601: uint8(255),
	2602: uint8(255),
	2603: uint8(255),
	2604: uint8(255),
	2605: uint8(31),
	2606: uint8(32),
	2608: uint8(16),
	2611: uint8(248),
	2612: uint8(254),
	2613: uint8(255),
	2624: uint8(127),
	2625: uint8(255),
	2626: uint8(255),
	2627: uint8(249),
	2628: uint8(219),
	2629: uint8(7),
	2662: uint8(127),
	2717: uint8(240),
	2746: uint8(127),
	2760: uint8(240),
	2761: uint8(7),
}

var _wtable = [1600]uint8{
	0:    uint8(16),
	1:    uint8(16),
	2:    uint8(16),
	3:    uint8(16),
	4:    uint8(16),
	5:    uint8(16),
	6:    uint8(16),
	7:    uint8(16),
	8:    uint8(16),
	9:    uint8(16),
	10:   uint8(16),
	11:   uint8(16),
	12:   uint8(16),
	13:   uint8(16),
	14:   uint8(16),
	15:   uint8(16),
	16:   uint8(16),
	17:   uint8(18),
	18:   uint8(16),
	19:   uint8(16),
	20:   uint8(16),
	21:   uint8(16),
	22:   uint8(16),
	23:   uint8(16),
	24:   uint8(16),
	25:   uint8(16),
	26:   uint8(16),
	27:   uint8(16),
	28:   uint8(16),
	29:   uint8(16),
	30:   uint8(16),
	31:   uint8(16),
	32:   uint8(16),
	33:   uint8(16),
	34:   uint8(16),
	35:   uint8(19),
	36:   uint8(16),
	37:   uint8(20),
	38:   uint8(21),
	39:   uint8(22),
	40:   uint8(16),
	41:   uint8(16),
	42:   uint8(16),
	43:   uint8(23),
	44:   uint8(16),
	45:   uint8(16),
	46:   uint8(24),
	47:   uint8(25),
	48:   uint8(26),
	49:   uint8(27),
	50:   uint8(28),
	51:   uint8(17),
	52:   uint8(17),
	53:   uint8(17),
	54:   uint8(17),
	55:   uint8(17),
	56:   uint8(17),
	57:   uint8(17),
	58:   uint8(17),
	59:   uint8(17),
	60:   uint8(17),
	61:   uint8(17),
	62:   uint8(17),
	63:   uint8(17),
	64:   uint8(17),
	65:   uint8(17),
	66:   uint8(17),
	67:   uint8(17),
	68:   uint8(17),
	69:   uint8(17),
	70:   uint8(17),
	71:   uint8(17),
	72:   uint8(17),
	73:   uint8(17),
	74:   uint8(17),
	75:   uint8(17),
	76:   uint8(17),
	77:   uint8(29),
	78:   uint8(17),
	79:   uint8(17),
	80:   uint8(17),
	81:   uint8(17),
	82:   uint8(17),
	83:   uint8(17),
	84:   uint8(17),
	85:   uint8(17),
	86:   uint8(17),
	87:   uint8(17),
	88:   uint8(17),
	89:   uint8(17),
	90:   uint8(17),
	91:   uint8(17),
	92:   uint8(17),
	93:   uint8(17),
	94:   uint8(17),
	95:   uint8(17),
	96:   uint8(17),
	97:   uint8(17),
	98:   uint8(17),
	99:   uint8(17),
	100:  uint8(17),
	101:  uint8(17),
	102:  uint8(17),
	103:  uint8(17),
	104:  uint8(17),
	105:  uint8(17),
	106:  uint8(17),
	107:  uint8(17),
	108:  uint8(17),
	109:  uint8(17),
	110:  uint8(17),
	111:  uint8(17),
	112:  uint8(17),
	113:  uint8(17),
	114:  uint8(17),
	115:  uint8(17),
	116:  uint8(17),
	117:  uint8(17),
	118:  uint8(17),
	119:  uint8(17),
	120:  uint8(17),
	121:  uint8(17),
	122:  uint8(17),
	123:  uint8(17),
	124:  uint8(17),
	125:  uint8(17),
	126:  uint8(17),
	127:  uint8(17),
	128:  uint8(17),
	129:  uint8(17),
	130:  uint8(17),
	131:  uint8(17),
	132:  uint8(17),
	133:  uint8(17),
	134:  uint8(17),
	135:  uint8(17),
	136:  uint8(17),
	137:  uint8(17),
	138:  uint8(17),
	139:  uint8(17),
	140:  uint8(17),
	141:  uint8(17),
	142:  uint8(17),
	143:  uint8(17),
	144:  uint8(17),
	145:  uint8(17),
	146:  uint8(17),
	147:  uint8(17),
	148:  uint8(17),
	149:  uint8(17),
	150:  uint8(17),
	151:  uint8(17),
	152:  uint8(17),
	153:  uint8(17),
	154:  uint8(17),
	155:  uint8(17),
	156:  uint8(17),
	157:  uint8(17),
	158:  uint8(17),
	159:  uint8(17),
	160:  uint8(17),
	161:  uint8(17),
	162:  uint8(17),
	163:  uint8(17),
	164:  uint8(30),
	165:  uint8(16),
	166:  uint8(16),
	167:  uint8(16),
	168:  uint8(16),
	169:  uint8(31),
	170:  uint8(16),
	171:  uint8(16),
	172:  uint8(17),
	173:  uint8(17),
	174:  uint8(17),
	175:  uint8(17),
	176:  uint8(17),
	177:  uint8(17),
	178:  uint8(17),
	179:  uint8(17),
	180:  uint8(17),
	181:  uint8(17),
	182:  uint8(17),
	183:  uint8(17),
	184:  uint8(17),
	185:  uint8(17),
	186:  uint8(17),
	187:  uint8(17),
	188:  uint8(17),
	189:  uint8(17),
	190:  uint8(17),
	191:  uint8(17),
	192:  uint8(17),
	193:  uint8(17),
	194:  uint8(17),
	195:  uint8(17),
	196:  uint8(17),
	197:  uint8(17),
	198:  uint8(17),
	199:  uint8(17),
	200:  uint8(17),
	201:  uint8(17),
	202:  uint8(17),
	203:  uint8(17),
	204:  uint8(17),
	205:  uint8(17),
	206:  uint8(17),
	207:  uint8(17),
	208:  uint8(17),
	209:  uint8(17),
	210:  uint8(17),
	211:  uint8(17),
	212:  uint8(17),
	213:  uint8(17),
	214:  uint8(17),
	215:  uint8(32),
	216:  uint8(16),
	217:  uint8(16),
	218:  uint8(16),
	219:  uint8(16),
	220:  uint8(16),
	221:  uint8(16),
	222:  uint8(16),
	223:  uint8(16),
	224:  uint8(16),
	225:  uint8(16),
	226:  uint8(16),
	227:  uint8(16),
	228:  uint8(16),
	229:  uint8(16),
	230:  uint8(16),
	231:  uint8(16),
	232:  uint8(16),
	233:  uint8(16),
	234:  uint8(16),
	235:  uint8(16),
	236:  uint8(16),
	237:  uint8(16),
	238:  uint8(16),
	239:  uint8(16),
	240:  uint8(16),
	241:  uint8(16),
	242:  uint8(16),
	243:  uint8(16),
	244:  uint8(16),
	245:  uint8(16),
	246:  uint8(16),
	247:  uint8(16),
	248:  uint8(16),
	249:  uint8(17),
	250:  uint8(17),
	251:  uint8(16),
	252:  uint8(16),
	253:  uint8(16),
	254:  uint8(33),
	255:  uint8(34),
	256:  uint8(16),
	257:  uint8(16),
	258:  uint8(16),
	259:  uint8(16),
	260:  uint8(16),
	261:  uint8(16),
	262:  uint8(16),
	263:  uint8(16),
	264:  uint8(16),
	265:  uint8(16),
	266:  uint8(16),
	267:  uint8(16),
	268:  uint8(16),
	269:  uint8(16),
	270:  uint8(16),
	271:  uint8(16),
	272:  uint8(16),
	273:  uint8(16),
	274:  uint8(16),
	275:  uint8(16),
	276:  uint8(16),
	277:  uint8(16),
	278:  uint8(16),
	279:  uint8(16),
	280:  uint8(16),
	281:  uint8(16),
	282:  uint8(16),
	283:  uint8(16),
	284:  uint8(16),
	285:  uint8(16),
	286:  uint8(16),
	287:  uint8(16),
	288:  uint8(16),
	289:  uint8(16),
	290:  uint8(16),
	291:  uint8(16),
	292:  uint8(16),
	293:  uint8(16),
	294:  uint8(16),
	295:  uint8(16),
	296:  uint8(16),
	297:  uint8(16),
	298:  uint8(16),
	299:  uint8(16),
	300:  uint8(16),
	301:  uint8(16),
	302:  uint8(16),
	303:  uint8(16),
	304:  uint8(16),
	305:  uint8(16),
	306:  uint8(16),
	307:  uint8(16),
	308:  uint8(16),
	309:  uint8(16),
	310:  uint8(16),
	311:  uint8(16),
	312:  uint8(16),
	313:  uint8(16),
	314:  uint8(16),
	315:  uint8(16),
	316:  uint8(16),
	317:  uint8(16),
	318:  uint8(16),
	319:  uint8(16),
	320:  uint8(16),
	321:  uint8(16),
	322:  uint8(16),
	323:  uint8(16),
	324:  uint8(16),
	325:  uint8(16),
	326:  uint8(16),
	327:  uint8(16),
	328:  uint8(16),
	329:  uint8(16),
	330:  uint8(16),
	331:  uint8(16),
	332:  uint8(16),
	333:  uint8(16),
	334:  uint8(16),
	335:  uint8(16),
	336:  uint8(16),
	337:  uint8(16),
	338:  uint8(16),
	339:  uint8(16),
	340:  uint8(16),
	341:  uint8(16),
	342:  uint8(16),
	343:  uint8(16),
	344:  uint8(16),
	345:  uint8(16),
	346:  uint8(16),
	347:  uint8(16),
	348:  uint8(16),
	349:  uint8(16),
	350:  uint8(16),
	351:  uint8(16),
	352:  uint8(16),
	353:  uint8(16),
	354:  uint8(16),
	355:  uint8(16),
	356:  uint8(16),
	357:  uint8(16),
	358:  uint8(16),
	359:  uint8(16),
	360:  uint8(16),
	361:  uint8(16),
	362:  uint8(16),
	363:  uint8(16),
	364:  uint8(16),
	365:  uint8(16),
	366:  uint8(16),
	367:  uint8(35),
	368:  uint8(17),
	369:  uint8(17),
	370:  uint8(17),
	371:  uint8(17),
	372:  uint8(17),
	373:  uint8(17),
	374:  uint8(17),
	375:  uint8(17),
	376:  uint8(17),
	377:  uint8(17),
	378:  uint8(17),
	379:  uint8(17),
	380:  uint8(17),
	381:  uint8(17),
	382:  uint8(17),
	383:  uint8(17),
	384:  uint8(17),
	385:  uint8(17),
	386:  uint8(17),
	387:  uint8(17),
	388:  uint8(17),
	389:  uint8(17),
	390:  uint8(17),
	391:  uint8(36),
	392:  uint8(17),
	393:  uint8(17),
	394:  uint8(37),
	395:  uint8(16),
	396:  uint8(16),
	397:  uint8(16),
	398:  uint8(16),
	399:  uint8(16),
	400:  uint8(16),
	401:  uint8(16),
	402:  uint8(16),
	403:  uint8(16),
	404:  uint8(16),
	405:  uint8(16),
	406:  uint8(16),
	407:  uint8(16),
	408:  uint8(16),
	409:  uint8(16),
	410:  uint8(16),
	411:  uint8(16),
	412:  uint8(16),
	413:  uint8(16),
	414:  uint8(16),
	415:  uint8(16),
	416:  uint8(16),
	417:  uint8(16),
	418:  uint8(16),
	419:  uint8(16),
	420:  uint8(16),
	421:  uint8(16),
	422:  uint8(16),
	423:  uint8(16),
	424:  uint8(16),
	425:  uint8(16),
	426:  uint8(16),
	427:  uint8(16),
	428:  uint8(16),
	429:  uint8(16),
	430:  uint8(16),
	431:  uint8(16),
	432:  uint8(17),
	433:  uint8(38),
	434:  uint8(39),
	435:  uint8(16),
	436:  uint8(16),
	437:  uint8(16),
	438:  uint8(16),
	439:  uint8(16),
	440:  uint8(16),
	441:  uint8(16),
	442:  uint8(16),
	443:  uint8(16),
	444:  uint8(16),
	445:  uint8(16),
	446:  uint8(16),
	447:  uint8(16),
	448:  uint8(16),
	449:  uint8(16),
	450:  uint8(16),
	451:  uint8(16),
	452:  uint8(16),
	453:  uint8(16),
	454:  uint8(16),
	455:  uint8(16),
	456:  uint8(16),
	457:  uint8(16),
	458:  uint8(16),
	459:  uint8(16),
	460:  uint8(16),
	461:  uint8(16),
	462:  uint8(16),
	463:  uint8(16),
	464:  uint8(16),
	465:  uint8(16),
	466:  uint8(16),
	467:  uint8(16),
	468:  uint8(16),
	469:  uint8(16),
	470:  uint8(16),
	471:  uint8(16),
	472:  uint8(16),
	473:  uint8(16),
	474:  uint8(16),
	475:  uint8(16),
	476:  uint8(16),
	477:  uint8(16),
	478:  uint8(16),
	479:  uint8(16),
	480:  uint8(16),
	481:  uint8(16),
	482:  uint8(16),
	483:  uint8(16),
	484:  uint8(16),
	485:  uint8(16),
	486:  uint8(16),
	487:  uint8(16),
	488:  uint8(16),
	489:  uint8(16),
	490:  uint8(16),
	491:  uint8(16),
	492:  uint8(16),
	493:  uint8(16),
	494:  uint8(16),
	495:  uint8(16),
	496:  uint8(40),
	497:  uint8(41),
	498:  uint8(42),
	499:  uint8(43),
	500:  uint8(44),
	501:  uint8(45),
	502:  uint8(46),
	503:  uint8(47),
	504:  uint8(16),
	505:  uint8(48),
	506:  uint8(49),
	507:  uint8(16),
	508:  uint8(16),
	509:  uint8(16),
	510:  uint8(16),
	511:  uint8(16),
	544:  uint8(255),
	545:  uint8(255),
	546:  uint8(255),
	547:  uint8(255),
	548:  uint8(255),
	549:  uint8(255),
	550:  uint8(255),
	551:  uint8(255),
	552:  uint8(255),
	553:  uint8(255),
	554:  uint8(255),
	555:  uint8(255),
	556:  uint8(255),
	557:  uint8(255),
	558:  uint8(255),
	559:  uint8(255),
	560:  uint8(255),
	561:  uint8(255),
	562:  uint8(255),
	563:  uint8(255),
	564:  uint8(255),
	565:  uint8(255),
	566:  uint8(255),
	567:  uint8(255),
	568:  uint8(255),
	569:  uint8(255),
	570:  uint8(255),
	571:  uint8(255),
	572:  uint8(255),
	573:  uint8(255),
	574:  uint8(255),
	575:  uint8(255),
	576:  uint8(255),
	577:  uint8(255),
	578:  uint8(255),
	579:  uint8(255),
	580:  uint8(255),
	581:  uint8(255),
	582:  uint8(255),
	583:  uint8(255),
	584:  uint8(255),
	585:  uint8(255),
	586:  uint8(255),
	587:  uint8(255),
	611:  uint8(12),
	613:  uint8(6),
	637:  uint8(30),
	638:  uint8(9),
	671:  uint8(96),
	674:  uint8(48),
	681:  uint8(255),
	682:  uint8(15),
	687:  uint8(128),
	690:  uint8(8),
	692:  uint8(2),
	693:  uint8(12),
	695:  uint8(96),
	696:  uint8(48),
	697:  uint8(64),
	698:  uint8(16),
	701:  uint8(4),
	702:  uint8(44),
	703:  uint8(36),
	704:  uint8(32),
	705:  uint8(12),
	709:  uint8(1),
	713:  uint8(80),
	714:  uint8(184),
	722:  uint8(224),
	726:  uint8(1),
	727:  uint8(128),
	739:  uint8(24),
	746:  uint8(33),
	784:  uint8(255),
	785:  uint8(255),
	786:  uint8(255),
	787:  uint8(251),
	788:  uint8(255),
	789:  uint8(255),
	790:  uint8(255),
	791:  uint8(255),
	792:  uint8(255),
	793:  uint8(255),
	794:  uint8(255),
	795:  uint8(255),
	796:  uint8(255),
	797:  uint8(255),
	798:  uint8(15),
	800:  uint8(255),
	801:  uint8(255),
	802:  uint8(255),
	803:  uint8(255),
	804:  uint8(255),
	805:  uint8(255),
	806:  uint8(255),
	807:  uint8(255),
	808:  uint8(255),
	809:  uint8(255),
	810:  uint8(255),
	811:  uint8(255),
	812:  uint8(255),
	813:  uint8(255),
	814:  uint8(255),
	815:  uint8(255),
	816:  uint8(255),
	817:  uint8(255),
	818:  uint8(255),
	819:  uint8(255),
	820:  uint8(255),
	821:  uint8(255),
	822:  uint8(255),
	823:  uint8(255),
	824:  uint8(255),
	825:  uint8(255),
	826:  uint8(63),
	830:  uint8(255),
	831:  uint8(15),
	832:  uint8(255),
	833:  uint8(255),
	834:  uint8(255),
	835:  uint8(255),
	836:  uint8(255),
	837:  uint8(255),
	838:  uint8(255),
	839:  uint8(127),
	840:  uint8(254),
	841:  uint8(255),
	842:  uint8(255),
	843:  uint8(255),
	844:  uint8(255),
	845:  uint8(255),
	846:  uint8(255),
	847:  uint8(255),
	848:  uint8(255),
	849:  uint8(255),
	850:  uint8(127),
	851:  uint8(254),
	852:  uint8(255),
	853:  uint8(255),
	854:  uint8(255),
	855:  uint8(255),
	856:  uint8(255),
	857:  uint8(255),
	858:  uint8(255),
	859:  uint8(255),
	860:  uint8(255),
	861:  uint8(255),
	862:  uint8(255),
	863:  uint8(255),
	864:  uint8(224),
	865:  uint8(255),
	866:  uint8(255),
	867:  uint8(255),
	868:  uint8(255),
	869:  uint8(255),
	870:  uint8(254),
	871:  uint8(255),
	872:  uint8(255),
	873:  uint8(255),
	874:  uint8(255),
	875:  uint8(255),
	876:  uint8(255),
	877:  uint8(255),
	878:  uint8(255),
	879:  uint8(255),
	880:  uint8(255),
	881:  uint8(127),
	882:  uint8(255),
	883:  uint8(255),
	884:  uint8(255),
	885:  uint8(255),
	886:  uint8(255),
	887:  uint8(7),
	888:  uint8(255),
	889:  uint8(255),
	890:  uint8(255),
	891:  uint8(255),
	892:  uint8(15),
	894:  uint8(255),
	895:  uint8(255),
	896:  uint8(255),
	897:  uint8(255),
	898:  uint8(255),
	899:  uint8(127),
	900:  uint8(255),
	901:  uint8(255),
	902:  uint8(255),
	903:  uint8(255),
	904:  uint8(255),
	906:  uint8(255),
	907:  uint8(255),
	908:  uint8(255),
	909:  uint8(255),
	910:  uint8(255),
	911:  uint8(255),
	912:  uint8(255),
	913:  uint8(255),
	914:  uint8(255),
	915:  uint8(255),
	916:  uint8(255),
	917:  uint8(255),
	918:  uint8(255),
	919:  uint8(255),
	920:  uint8(255),
	921:  uint8(255),
	922:  uint8(255),
	923:  uint8(255),
	924:  uint8(255),
	925:  uint8(255),
	926:  uint8(255),
	927:  uint8(255),
	928:  uint8(255),
	929:  uint8(255),
	930:  uint8(255),
	931:  uint8(255),
	932:  uint8(255),
	933:  uint8(255),
	934:  uint8(255),
	935:  uint8(255),
	936:  uint8(255),
	937:  uint8(255),
	938:  uint8(255),
	939:  uint8(255),
	940:  uint8(255),
	941:  uint8(255),
	942:  uint8(255),
	943:  uint8(255),
	944:  uint8(255),
	945:  uint8(255),
	946:  uint8(255),
	947:  uint8(255),
	948:  uint8(255),
	949:  uint8(255),
	950:  uint8(255),
	951:  uint8(255),
	960:  uint8(255),
	961:  uint8(255),
	962:  uint8(255),
	963:  uint8(255),
	964:  uint8(255),
	965:  uint8(255),
	966:  uint8(255),
	967:  uint8(255),
	968:  uint8(255),
	969:  uint8(255),
	970:  uint8(255),
	971:  uint8(255),
	972:  uint8(255),
	973:  uint8(255),
	974:  uint8(255),
	975:  uint8(255),
	976:  uint8(255),
	977:  uint8(31),
	978:  uint8(255),
	979:  uint8(255),
	980:  uint8(255),
	981:  uint8(255),
	982:  uint8(255),
	983:  uint8(255),
	984:  uint8(127),
	1004: uint8(255),
	1005: uint8(255),
	1006: uint8(255),
	1007: uint8(31),
	1024: uint8(255),
	1025: uint8(255),
	1026: uint8(255),
	1027: uint8(255),
	1028: uint8(255),
	1029: uint8(255),
	1030: uint8(255),
	1031: uint8(255),
	1032: uint8(255),
	1033: uint8(255),
	1034: uint8(255),
	1035: uint8(255),
	1036: uint8(255),
	1037: uint8(255),
	1038: uint8(255),
	1039: uint8(255),
	1040: uint8(255),
	1041: uint8(255),
	1042: uint8(255),
	1043: uint8(255),
	1044: uint8(15),
	1058: uint8(255),
	1059: uint8(3),
	1062: uint8(255),
	1063: uint8(255),
	1064: uint8(255),
	1065: uint8(255),
	1066: uint8(247),
	1067: uint8(255),
	1068: uint8(127),
	1069: uint8(15),
	1088: uint8(254),
	1089: uint8(255),
	1090: uint8(255),
	1091: uint8(255),
	1092: uint8(255),
	1093: uint8(255),
	1094: uint8(255),
	1095: uint8(255),
	1096: uint8(255),
	1097: uint8(255),
	1098: uint8(255),
	1099: uint8(255),
	1100: uint8(1),
	1116: uint8(127),
	1148: uint8(15),
	1152: uint8(255),
	1153: uint8(255),
	1154: uint8(255),
	1155: uint8(255),
	1156: uint8(255),
	1157: uint8(255),
	1158: uint8(255),
	1159: uint8(255),
	1160: uint8(255),
	1161: uint8(255),
	1162: uint8(255),
	1163: uint8(255),
	1164: uint8(255),
	1165: uint8(255),
	1166: uint8(255),
	1167: uint8(255),
	1168: uint8(255),
	1169: uint8(255),
	1170: uint8(255),
	1171: uint8(255),
	1172: uint8(255),
	1173: uint8(255),
	1174: uint8(255),
	1175: uint8(255),
	1176: uint8(255),
	1177: uint8(255),
	1178: uint8(255),
	1179: uint8(255),
	1180: uint8(255),
	1181: uint8(255),
	1182: uint8(255),
	1184: uint8(255),
	1185: uint8(255),
	1186: uint8(255),
	1187: uint8(255),
	1188: uint8(255),
	1189: uint8(255),
	1190: uint8(255),
	1191: uint8(255),
	1192: uint8(255),
	1193: uint8(255),
	1194: uint8(255),
	1195: uint8(255),
	1196: uint8(255),
	1197: uint8(255),
	1198: uint8(255),
	1199: uint8(255),
	1200: uint8(255),
	1201: uint8(255),
	1202: uint8(255),
	1203: uint8(255),
	1204: uint8(255),
	1205: uint8(255),
	1206: uint8(255),
	1207: uint8(255),
	1208: uint8(255),
	1209: uint8(255),
	1210: uint8(255),
	1211: uint8(255),
	1212: uint8(255),
	1213: uint8(255),
	1214: uint8(7),
	1216: uint8(255),
	1217: uint8(255),
	1218: uint8(255),
	1219: uint8(127),
	1226: uint8(7),
	1228: uint8(240),
	1230: uint8(255),
	1231: uint8(255),
	1232: uint8(255),
	1233: uint8(255),
	1234: uint8(255),
	1235: uint8(255),
	1236: uint8(255),
	1237: uint8(255),
	1238: uint8(255),
	1239: uint8(255),
	1240: uint8(255),
	1241: uint8(255),
	1242: uint8(255),
	1243: uint8(255),
	1244: uint8(255),
	1245: uint8(255),
	1246: uint8(255),
	1247: uint8(255),
	1248: uint8(255),
	1249: uint8(255),
	1250: uint8(255),
	1251: uint8(255),
	1252: uint8(255),
	1253: uint8(255),
	1254: uint8(255),
	1255: uint8(255),
	1256: uint8(255),
	1257: uint8(255),
	1258: uint8(255),
	1259: uint8(255),
	1260: uint8(255),
	1261: uint8(255),
	1262: uint8(255),
	1263: uint8(255),
	1264: uint8(255),
	1265: uint8(255),
	1266: uint8(255),
	1267: uint8(255),
	1268: uint8(255),
	1269: uint8(255),
	1270: uint8(255),
	1271: uint8(255),
	1272: uint8(255),
	1273: uint8(255),
	1274: uint8(255),
	1275: uint8(255),
	1276: uint8(255),
	1277: uint8(255),
	1278: uint8(255),
	1279: uint8(15),
	1280: uint8(16),
	1305: uint8(128),
	1329: uint8(64),
	1330: uint8(254),
	1331: uint8(7),
	1344: uint8(7),
	1346: uint8(255),
	1347: uint8(255),
	1348: uint8(255),
	1349: uint8(255),
	1350: uint8(255),
	1351: uint8(15),
	1352: uint8(255),
	1353: uint8(1),
	1354: uint8(3),
	1356: uint8(63),
	1376: uint8(255),
	1377: uint8(255),
	1378: uint8(255),
	1379: uint8(255),
	1380: uint8(1),
	1381: uint8(224),
	1382: uint8(191),
	1383: uint8(255),
	1384: uint8(255),
	1385: uint8(255),
	1386: uint8(255),
	1387: uint8(255),
	1388: uint8(255),
	1389: uint8(255),
	1390: uint8(255),
	1391: uint8(223),
	1392: uint8(255),
	1393: uint8(255),
	1394: uint8(15),
	1396: uint8(255),
	1397: uint8(255),
	1398: uint8(255),
	1399: uint8(255),
	1400: uint8(255),
	1401: uint8(135),
	1402: uint8(15),
	1404: uint8(255),
	1405: uint8(255),
	1406: uint8(17),
	1407: uint8(255),
	1408: uint8(255),
	1409: uint8(255),
	1410: uint8(255),
	1411: uint8(255),
	1412: uint8(255),
	1413: uint8(255),
	1414: uint8(255),
	1415: uint8(127),
	1416: uint8(253),
	1417: uint8(255),
	1418: uint8(255),
	1419: uint8(255),
	1420: uint8(255),
	1421: uint8(255),
	1422: uint8(255),
	1423: uint8(255),
	1424: uint8(255),
	1425: uint8(255),
	1426: uint8(255),
	1427: uint8(255),
	1428: uint8(255),
	1429: uint8(255),
	1430: uint8(255),
	1431: uint8(255),
	1432: uint8(255),
	1433: uint8(255),
	1434: uint8(255),
	1435: uint8(255),
	1436: uint8(255),
	1437: uint8(255),
	1438: uint8(255),
	1439: uint8(159),
	1440: uint8(255),
	1441: uint8(255),
	1442: uint8(255),
	1443: uint8(255),
	1444: uint8(255),
	1445: uint8(255),
	1446: uint8(255),
	1447: uint8(63),
	1449: uint8(120),
	1450: uint8(255),
	1451: uint8(255),
	1452: uint8(255),
	1455: uint8(4),
	1458: uint8(96),
	1460: uint8(16),
	1471: uint8(248),
	1472: uint8(255),
	1473: uint8(255),
	1474: uint8(255),
	1475: uint8(255),
	1476: uint8(255),
	1477: uint8(255),
	1478: uint8(255),
	1479: uint8(255),
	1480: uint8(255),
	1481: uint8(255),
	1488: uint8(255),
	1489: uint8(255),
	1490: uint8(255),
	1491: uint8(255),
	1492: uint8(255),
	1493: uint8(255),
	1494: uint8(255),
	1495: uint8(255),
	1496: uint8(63),
	1497: uint8(16),
	1498: uint8(39),
	1501: uint8(24),
	1502: uint8(240),
	1503: uint8(7),
	1532: uint8(255),
	1533: uint8(15),
	1537: uint8(224),
	1538: uint8(255),
	1539: uint8(255),
	1540: uint8(255),
	1541: uint8(255),
	1542: uint8(255),
	1543: uint8(255),
	1544: uint8(255),
	1545: uint8(255),
	1546: uint8(255),
	1547: uint8(255),
	1548: uint8(255),
	1549: uint8(255),
	1550: uint8(123),
	1551: uint8(252),
	1552: uint8(255),
	1553: uint8(255),
	1554: uint8(255),
	1555: uint8(255),
	1556: uint8(231),
	1557: uint8(199),
	1558: uint8(255),
	1559: uint8(255),
	1560: uint8(255),
	1561: uint8(231),
	1562: uint8(255),
	1563: uint8(255),
	1564: uint8(255),
	1565: uint8(255),
	1566: uint8(255),
	1567: uint8(255),
	1582: uint8(15),
	1583: uint8(7),
	1584: uint8(7),
	1586: uint8(63),
}

func Xwcwidth(tls *TLS, wc Twchar_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v, (%v:)", tls, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 int32
	_, _ = v1, v2
	if wc < uint32(0xff) {
		if (wc+uint32(1))&uint32(0x7f) >= uint32(0x21) {
			v1 = int32(1)
		} else {
			if wc != 0 {
				v2 = -int32(1)
			} else {
				v2 = 0
			}
			v1 = v2
		}
		return v1
	}
	if wc&uint32(0xfffeffff) < uint32(0xfffe) {
		if int32(_table5[uint32(int32(_table5[wc>>int32(8)])*int32(32))+wc&uint32(255)>>int32(3)])>>(wc&uint32(7))&int32(1) != 0 {
			return 0
		}
		if int32(_wtable[uint32(int32(_wtable[wc>>int32(8)])*int32(32))+wc&uint32(255)>>int32(3)])>>(wc&uint32(7))&int32(1) != 0 {
			return int32(2)
		}
		return int32(1)
	}
	if wc&uint32(0xfffe) == uint32(0xfffe) {
		return -int32(1)
	}
	if wc-uint32(0x20000) < uint32(0x20000) {
		return int32(2)
	}
	if wc == uint32(0xe0001) || wc-uint32(0xe0020) < uint32(0x5f) || wc-uint32(0xe0100) < uint32(0xef) {
		return 0
	}
	return int32(1)
}

const d_fileno = 0

type Tino_t = uint64

type Tdirent = struct {
	Fd_ino    Tino_t
	Fd_off    Toff_t
	Fd_reclen uint16
	Fd_type   uint8
	Fd_name   [256]uint8
}

func Xalphasort(tls *TLS, a uintptr, b uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v b=%v, (%v:)", tls, a, b, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrcoll(tls, *(*uintptr)(unsafe.Pointer(a))+19, *(*uintptr)(unsafe.Pointer(b))+19)
}

type TDIR = struct {
	Ftell    Toff_t
	Ffd      int32
	Fbuf_pos int32
	Fbuf_end int32
	Flock    [1]int32
	Fbuf     [2048]uint8
}

type t__dirstream = TDIR

func Xclosedir(tls *TLS, dir uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v dir=%v, (%v:)", tls, dir, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int32
	_ = ret
	ret = Xclose(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd)
	Xfree(tls, dir)
	return ret
}

func Xdirfd(tls *TLS, d uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v d=%v, (%v:)", tls, d, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return (*TDIR)(unsafe.Pointer(d)).Ffd
}

const AT_EACCESS = 512
const AT_FDCWD = -100
const AT_REMOVEDIR = 512
const AT_SYMLINK_FOLLOW = 1024
const AT_SYMLINK_NOFOLLOW = 256
const FD_CLOEXEC = 1
const F_DUPFD = 0
const F_DUPFD_CLOEXEC = 1030
const F_GETFD = 1
const F_GETFL = 3
const F_GETLK = 5
const F_GETOWN = 9
const F_GETOWNER_UIDS = 17
const F_GETOWN_EX = 16
const F_GETSIG = 11
const F_OFD_GETLK = 36
const F_OFD_SETLK = 37
const F_OFD_SETLKW = 38
const F_RDLCK = 0
const F_SETFD = 2
const F_SETFL = 4
const F_SETLK = 6
const F_SETLKW = 7
const F_SETOWN = 8
const F_SETOWN_EX = 15
const F_SETSIG = 10
const F_UNLCK = 2
const F_WRLCK = 1
const O_ACCMODE = 2097155
const O_APPEND = 1024
const O_ASYNC = 8192
const O_CLOEXEC = 524288
const O_CREAT = 64
const O_DIRECT = 65536
const O_DIRECTORY = 16384
const O_DSYNC = 4096
const O_EXCL = 128
const O_EXEC = 2097152
const O_LARGEFILE = 131072
const O_NDELAY = 2048
const O_NOATIME = 262144
const O_NOCTTY = 256
const O_NOFOLLOW = 32768
const O_NONBLOCK = 2048
const O_PATH = 2097152
const O_RDONLY = 0
const O_RDWR = 2
const O_RSYNC = 1052672
const O_SEARCH = 2097152
const O_SYNC = 1052672
const O_TMPFILE = 4210688
const O_TRUNC = 512
const O_TTY_INIT = 0
const O_WRONLY = 1
const POSIX_FADV_DONTNEED = 4
const POSIX_FADV_NOREUSE = 5
const POSIX_FADV_NORMAL = 0
const POSIX_FADV_RANDOM = 1
const POSIX_FADV_SEQUENTIAL = 2
const POSIX_FADV_WILLNEED = 3
const S_IFBLK = 24576
const S_IFCHR = 8192
const S_IFDIR = 16384
const S_IFIFO = 4096
const S_IFLNK = 40960
const S_IFMT = 61440
const S_IFREG = 32768
const S_IFSOCK = 49152
const S_IRGRP = 32
const S_IROTH = 4
const S_IRUSR = 256
const S_IRWXG = 56
const S_IRWXO = 7
const S_IRWXU = 448
const S_ISGID = 1024
const S_ISUID = 2048
const S_ISVTX = 512
const S_IWGRP = 16
const S_IWOTH = 2
const S_IWUSR = 128
const S_IXGRP = 8
const S_IXOTH = 1
const S_IXUSR = 64
const UTIME_NOW = 1073741823
const UTIME_OMIT = 1073741822

type Tflock = struct {
	Fl_type   int16
	Fl_whence int16
	Fl_start  Toff_t
	Fl_len    Toff_t
	Fl_pid    Tpid_t
}

type Tblksize_t = int32

type Tnlink_t = uint32

type Tdev_t = uint64

type Tblkcnt_t = int64

type Tstat = struct {
	Fst_dev     Tdev_t
	Fst_ino     Tino_t
	Fst_mode    Tmode_t
	Fst_nlink   Tnlink_t
	Fst_uid     Tuid_t
	Fst_gid     Tgid_t
	Fst_rdev    Tdev_t
	F__pad      uint64
	Fst_size    Toff_t
	Fst_blksize Tblksize_t
	F__pad2     int32
	Fst_blocks  Tblkcnt_t
	Fst_atim    Ttimespec
	Fst_mtim    Ttimespec
	Fst_ctim    Ttimespec
	F__unused   [2]uint32
}

func Xfdopendir(tls *TLS, fd int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var dir, v1 uintptr
	var _ /* st at bp+0 */ Tstat
	_, _ = dir, v1
	if Xfstat(tls, fd, bp) < 0 {
		return uintptr(0)
	}
	if Xfcntl(tls, fd, int32(F_GETFL), 0)&int32(O_PATH) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EBADF)
		return uintptr(0)
	}
	if !((*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&Uint32FromInt32(S_IFMT) == Uint32FromInt32(S_IFDIR)) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOTDIR)
		return uintptr(0)
	}
	v1 = Xcalloc(tls, uint64(1), uint64(2072))
	dir = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	Xfcntl(tls, fd, int32(F_SETFD), VaList(bp+136, int32(FD_CLOEXEC)))
	(*TDIR)(unsafe.Pointer(dir)).Ffd = fd
	return dir
}

const AT_EMPTY_PATH = 4096
const AT_NO_AUTOMOUNT = 2048
const AT_RECURSIVE = 32768
const AT_STATX_DONT_SYNC = 16384
const AT_STATX_FORCE_SYNC = 8192
const AT_STATX_SYNC_AS_STAT = 0
const AT_STATX_SYNC_TYPE = 24576
const DN_ACCESS = 1
const DN_ATTRIB = 32
const DN_CREATE = 4
const DN_DELETE = 8
const DN_MODIFY = 2
const DN_MULTISHOT = 2147483648
const DN_RENAME = 16
const DT_BLK = 6
const DT_CHR = 2
const DT_DIR = 4
const DT_FIFO = 1
const DT_LNK = 10
const DT_REG = 8
const DT_SOCK = 12
const DT_UNKNOWN = 0
const DT_WHT = 14
const FALLOC_FL_KEEP_SIZE = 1
const FALLOC_FL_PUNCH_HOLE = 2
const FAPPEND = 1024
const FASYNC = 8192
const FFSYNC = 1052672
const FNDELAY = 2048
const FNONBLOCK = 2048
const F_ADD_SEALS = 1033
const F_CANCELLK = 1029
const F_GETLEASE = 1025
const F_GETPIPE_SZ = 1032
const F_GET_FILE_RW_HINT = 1037
const F_GET_RW_HINT = 1035
const F_GET_SEALS = 1034
const F_NOTIFY = 1026
const F_OWNER_GID = 2
const F_OWNER_PGRP = 2
const F_OWNER_PID = 1
const F_OWNER_TID = 0
const F_SEAL_FUTURE_WRITE = 16
const F_SEAL_GROW = 4
const F_SEAL_SEAL = 1
const F_SEAL_SHRINK = 2
const F_SEAL_WRITE = 8
const F_SETLEASE = 1024
const F_SETPIPE_SZ = 1031
const F_SET_FILE_RW_HINT = 1038
const F_SET_RW_HINT = 1036
const MAX_HANDLE_SZ = 128
const RWF_WRITE_LIFE_NOT_SET = 0
const RWH_WRITE_LIFE_EXTREME = 5
const RWH_WRITE_LIFE_LONG = 4
const RWH_WRITE_LIFE_MEDIUM = 3
const RWH_WRITE_LIFE_NONE = 1
const RWH_WRITE_LIFE_SHORT = 2
const SPLICE_F_GIFT = 8
const SPLICE_F_MORE = 4
const SPLICE_F_MOVE = 1
const SPLICE_F_NONBLOCK = 2
const SYNC_FILE_RANGE_WAIT_AFTER = 4
const SYNC_FILE_RANGE_WAIT_BEFORE = 1
const SYNC_FILE_RANGE_WRITE = 2
const alloca = 0
const loff_t = 0

type Tiovec = struct {
	Fiov_base uintptr
	Fiov_len  Tsize_t
}

type Tfile_handle = struct {
	Fhandle_bytes uint32
	Fhandle_type  int32
}

type Tf_owner_ex = struct {
	Ftype1 int32
	Fpid   Tpid_t
}

func Xopendir(tls *TLS, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var dir, v2 uintptr
	var fd, v1 int32
	_, _, _, _ = dir, fd, v1, v2
	v1 = Xopen(tls, name, Int32FromInt32(O_RDONLY)|Int32FromInt32(O_DIRECTORY)|Int32FromInt32(O_CLOEXEC), 0)
	fd = v1
	if v1 < 0 {
		return uintptr(0)
	}
	v2 = Xcalloc(tls, uint64(1), uint64(2072))
	dir = v2
	if !(v2 != 0) {
		X__syscall1(tls, int64(SYS_close), int64(fd))
		return uintptr(0)
	}
	(*TDIR)(unsafe.Pointer(dir)).Ffd = fd
	return dir
}

type Tptrdiff_t = int64

type Tdirstream_buf_alignment_check = [1]uint8

func Xreaddir(tls *TLS, dir uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dir=%v, (%v:)", tls, dir, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var de uintptr
	var len1 int32
	_, _ = de, len1
	if (*TDIR)(unsafe.Pointer(dir)).Fbuf_pos >= (*TDIR)(unsafe.Pointer(dir)).Fbuf_end {
		len1 = int32(X__syscall3(tls, int64(SYS_getdents64), int64((*TDIR)(unsafe.Pointer(dir)).Ffd), int64(dir+24), int64(Uint64FromInt64(2048))))
		if len1 <= 0 {
			if len1 < 0 && len1 != -int32(ENOENT) {
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = -len1
			}
			return uintptr(0)
		}
		(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = len1
		(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = 0
	}
	de = dir + 24 + uintptr((*TDIR)(unsafe.Pointer(dir)).Fbuf_pos)
	*(*int32)(unsafe.Pointer(dir + 12)) += int32((*Tdirent)(unsafe.Pointer(de)).Fd_reclen)
	(*TDIR)(unsafe.Pointer(dir)).Ftell = (*Tdirent)(unsafe.Pointer(de)).Fd_off
	return de
}

func Xreaddir_r(tls *TLS, dir uintptr, buf uintptr, result uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v dir=%v buf=%v result=%v, (%v:)", tls, dir, buf, result, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var de uintptr
	var errno_save, ret, v1 int32
	_, _, _, _ = de, errno_save, ret, v1
	errno_save = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	___lock(tls, dir+20)
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = 0
	de = Xreaddir(tls, dir)
	v1 = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	ret = v1
	if v1 != 0 {
		___unlock(tls, dir+20)
		return ret
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = errno_save
	if de != 0 {
		Xmemcpy(tls, buf, de, uint64((*Tdirent)(unsafe.Pointer(de)).Fd_reclen))
	} else {
		buf = UintptrFromInt32(0)
	}
	___unlock(tls, dir+20)
	*(*uintptr)(unsafe.Pointer(result)) = buf
	return 0
}

func Xrewinddir(tls *TLS, dir uintptr) {
	if __ccgo_strace {
		trc("tls=%v dir=%v, (%v:)", tls, dir, origin(2))
	}
	var v1 int32
	_ = v1
	___lock(tls, dir+20)
	Xlseek(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd, 0, SEEK_SET)
	v1 = Int32FromInt32(0)
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = v1
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = v1
	(*TDIR)(unsafe.Pointer(dir)).Ftell = 0
	___unlock(tls, dir+20)
}

func Xscandir(tls *TLS, path uintptr, res uintptr, sel uintptr, cmp uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v res=%v sel=%v cmp=%v, (%v:)", tls, path, res, sel, cmp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var cnt, len1, v2, v3 Tsize_t
	var d, de, names, tmp, v1 uintptr
	var old_errno int32
	_, _, _, _, _, _, _, _, _, _ = cnt, d, de, len1, names, old_errno, tmp, v1, v2, v3
	d = Xopendir(tls, path)
	names = uintptr(0)
	cnt = uint64(0)
	len1 = uint64(0)
	old_errno = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	if !(d != 0) {
		return -int32(1)
	}
	for {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = 0
		v1 = Xreaddir(tls, d)
		de = v1
		if !(v1 != 0) {
			break
		}
		if sel != 0 && !((*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{sel})))(tls, de) != 0) {
			continue
		}
		if cnt >= len1 {
			len1 = uint64(2)*len1 + uint64(1)
			if len1 > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt64(8) {
				break
			}
			tmp = Xrealloc(tls, names, len1*uint64(8))
			if !(tmp != 0) {
				break
			}
			names = tmp
		}
		*(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)) = Xmalloc(tls, uint64((*Tdirent)(unsafe.Pointer(de)).Fd_reclen))
		if !(*(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)) != 0) {
			break
		}
		v2 = cnt
		cnt++
		Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(names + uintptr(v2)*8)), de, uint64((*Tdirent)(unsafe.Pointer(de)).Fd_reclen))
	}
	Xclosedir(tls, d)
	if *(*int32)(unsafe.Pointer(X__errno_location(tls))) != 0 {
		if names != 0 {
			for {
				v3 = cnt
				cnt--
				if !(v3 > uint64(0)) {
					break
				}
				Xfree(tls, *(*uintptr)(unsafe.Pointer(names + uintptr(cnt)*8)))
			}
		}
		Xfree(tls, names)
		return -int32(1)
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = old_errno
	if cmp != 0 {
		Xqsort(tls, names, cnt, uint64(8), cmp)
	}
	*(*uintptr)(unsafe.Pointer(res)) = names
	return int32(cnt)
}

func Xseekdir(tls *TLS, dir uintptr, off int64) {
	if __ccgo_strace {
		trc("tls=%v dir=%v off=%v, (%v:)", tls, dir, off, origin(2))
	}
	var v1 int32
	_ = v1
	___lock(tls, dir+20)
	(*TDIR)(unsafe.Pointer(dir)).Ftell = Xlseek(tls, (*TDIR)(unsafe.Pointer(dir)).Ffd, off, SEEK_SET)
	v1 = Int32FromInt32(0)
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_end = v1
	(*TDIR)(unsafe.Pointer(dir)).Fbuf_pos = v1
	___unlock(tls, dir+20)
}

func Xtelldir(tls *TLS, dir uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v dir=%v, (%v:)", tls, dir, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return (*TDIR)(unsafe.Pointer(dir)).Ftell
}

func Xversionsort(tls *TLS, a uintptr, b uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v b=%v, (%v:)", tls, a, b, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrverscmp(tls, *(*uintptr)(unsafe.Pointer(a))+19, *(*uintptr)(unsafe.Pointer(b))+19)
}

func X__reset_tls(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	var i, n Tsize_t
	var mem, p uintptr
	var self Tpthread_t
	_, _, _, _, _ = i, mem, n, p, self
	self = ___get_tp(tls)
	n = *(*Tuintptr_t)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(self)).Fdtv))
	if n != 0 {
		p = X__libc.Ftls_head
		i = Uint64FromInt32(1)
		for {
			if !(i <= n) {
				break
			}
			mem = uintptr(*(*Tuintptr_t)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(self)).Fdtv + uintptr(i)*8)) - Uint64FromInt32(DTP_OFFSET))
			Xmemcpy(tls, mem, (*Ttls_module)(unsafe.Pointer(p)).Fimage, (*Ttls_module)(unsafe.Pointer(p)).Flen1)
			Xmemset(tls, mem+uintptr((*Ttls_module)(unsafe.Pointer(p)).Flen1), 0, (*Ttls_module)(unsafe.Pointer(p)).Fsize-(*Ttls_module)(unsafe.Pointer(p)).Flen1)
			goto _1
		_1:
			;
			i++
			p = (*Ttls_module)(unsafe.Pointer(p)).Fnext
		}
	}
}

func X__init_ssp(tls *TLS, entropy uintptr) {
	if __ccgo_strace {
		trc("tls=%v entropy=%v, (%v:)", tls, entropy, origin(2))
	}
	if entropy != 0 {
		Xmemcpy(tls, uintptr(unsafe.Pointer(&X__stack_chk_guard)), entropy, uint64(8))
	} else {
		X__stack_chk_guard = Tuintptr_t(uintptr(unsafe.Pointer(&X__stack_chk_guard))) * uint64(1103515245)
	}
	/* Sacrifice 8 bits of entropy on 64bit to prevent leaking/
	 * overwriting the canary via string-manipulation functions.
	 * The NULL byte is on the second byte so that off-by-ones can
	 * still be detected. Endianness is taken care of
	 * automatically. */
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stack_chk_guard)) + 1)) = uint8(0)
	(*t__pthread)(unsafe.Pointer(___get_tp(tls))).Fcanary = X__stack_chk_guard
}

func X__stack_chk_fail(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	*(*uint8)(unsafe.Pointer(UintptrFromInt32(0))) = uint8(0)
}

func X__stack_chk_fail_local(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	X__stack_chk_fail(tls)
}

const L_INCR = 1
const L_SET = 0
const L_XTND = 2

func _dummy(tls *TLS, old uintptr, new1 uintptr) {
}

func Xclearenv(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var e, v1 uintptr
	_, _ = e, v1
	e = Xenviron
	Xenviron = uintptr(0)
	if e != 0 {
		for *(*uintptr)(unsafe.Pointer(e)) != 0 {
			v1 = e
			e += 8
			X__env_rm_add(tls, *(*uintptr)(unsafe.Pointer(v1)), uintptr(0))
		}
	}
	return 0
}

func Xgetenv(tls *TLS, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var e uintptr
	var l Tsize_t
	_, _ = e, l
	l = uint64(int64(X__strchrnul(tls, name, int32('='))) - int64(name))
	if l != 0 && !(*(*uint8)(unsafe.Pointer(name + uintptr(l))) != 0) && Xenviron != 0 {
		e = Xenviron
		for {
			if !(*(*uintptr)(unsafe.Pointer(e)) != 0) {
				break
			}
			if !(Xstrncmp(tls, name, *(*uintptr)(unsafe.Pointer(e)), l) != 0) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(e)) + uintptr(l)))) == int32('=') {
				return *(*uintptr)(unsafe.Pointer(e)) + uintptr(l) + uintptr(1)
			}
			goto _1
		_1:
			;
			e += 8
		}
	}
	return uintptr(0)
}

func _dummy1(tls *TLS, old uintptr, new1 uintptr) {
}

func X__putenv(tls *TLS, s uintptr, l Tsize_t, r uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v l=%v r=%v, (%v:)", tls, s, l, r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var e, newenv, tmp, v2 uintptr
	var i Tsize_t
	_, _, _, _, _ = e, i, newenv, tmp, v2
	i = uint64(0)
	if Xenviron != 0 {
		e = Xenviron
		for {
			if !(*(*uintptr)(unsafe.Pointer(e)) != 0) {
				break
			}
			if !(Xstrncmp(tls, s, *(*uintptr)(unsafe.Pointer(e)), l+uint64(1)) != 0) {
				tmp = *(*uintptr)(unsafe.Pointer(e))
				*(*uintptr)(unsafe.Pointer(e)) = s
				X__env_rm_add(tls, tmp, r)
				return 0
			}
			goto _1
		_1:
			;
			e += 8
			i++
		}
	}
	if Xenviron == _oldenv {
		newenv = Xrealloc(tls, _oldenv, uint64(8)*(i+uint64(2)))
		if !(newenv != 0) {
			goto oom
		}
	} else {
		newenv = Xmalloc(tls, uint64(8)*(i+uint64(2)))
		if !(newenv != 0) {
			goto oom
		}
		if i != 0 {
			Xmemcpy(tls, newenv, Xenviron, uint64(8)*i)
		}
		Xfree(tls, _oldenv)
	}
	*(*uintptr)(unsafe.Pointer(newenv + uintptr(i)*8)) = s
	*(*uintptr)(unsafe.Pointer(newenv + uintptr(i+uint64(1))*8)) = uintptr(0)
	v2 = newenv
	_oldenv = v2
	Xenviron = v2
	if r != 0 {
		X__env_rm_add(tls, uintptr(0), r)
	}
	return 0
	goto oom
oom:
	;
	Xfree(tls, r)
	return -int32(1)
}

var _oldenv uintptr

func Xputenv(tls *TLS, s uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tsize_t
	_ = l
	l = uint64(int64(X__strchrnul(tls, s, int32('='))) - int64(s))
	if !(l != 0) || !(*(*uint8)(unsafe.Pointer(s + uintptr(l))) != 0) {
		return Xunsetenv(tls, s)
	}
	return X__putenv(tls, s, l, uintptr(0))
}

const L_cuserid = 20
const NL_NMAX = 16

type Tcookie_io_functions_t = struct {
	Fread   uintptr
	Fwrite  uintptr
	Fseek   uintptr
	Fclose1 uintptr
}

type T_IO_cookie_io_functions_t = Tcookie_io_functions_t

func Xsecure_getenv(tls *TLS, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 uintptr
	_ = v1
	if X__libc.Fsecure != 0 {
		v1 = UintptrFromInt32(0)
	} else {
		v1 = Xgetenv(tls, name)
	}
	return v1
}

func X__env_rm_add(tls *TLS, old uintptr, new1 uintptr) {
	if __ccgo_strace {
		trc("tls=%v old=%v new1=%v, (%v:)", tls, old, new1, origin(2))
	}
	var i, v3 Tsize_t
	var t, v2 uintptr
	_, _, _, _ = i, t, v2, v3
	i = uint64(0)
	for {
		if !(i < _env_alloced_n) {
			break
		}
		if *(*uintptr)(unsafe.Pointer(_env_alloced + uintptr(i)*8)) == old {
			*(*uintptr)(unsafe.Pointer(_env_alloced + uintptr(i)*8)) = new1
			Xfree(tls, old)
			return
		} else {
			if !(*(*uintptr)(unsafe.Pointer(_env_alloced + uintptr(i)*8)) != 0) && new1 != 0 {
				*(*uintptr)(unsafe.Pointer(_env_alloced + uintptr(i)*8)) = new1
				new1 = uintptr(0)
			}
		}
		goto _1
	_1:
		;
		i++
	}
	if !(new1 != 0) {
		return
	}
	t = Xrealloc(tls, _env_alloced, uint64(8)*(_env_alloced_n+uint64(1)))
	if !(t != 0) {
		return
	}
	v2 = t
	_env_alloced = v2
	v3 = _env_alloced_n
	_env_alloced_n++
	*(*uintptr)(unsafe.Pointer(v2 + uintptr(v3)*8)) = new1
}

var _env_alloced uintptr

var _env_alloced_n Tsize_t

func Xsetenv(tls *TLS, var1 uintptr, value uintptr, overwrite int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v var1=%v value=%v overwrite=%v, (%v:)", tls, var1, value, overwrite, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l1, l2, v1 Tsize_t
	var s uintptr
	var v2 bool
	_, _, _, _, _ = l1, l2, s, v1, v2
	if v2 = !(var1 != 0); !v2 {
		v1 = uint64(int64(X__strchrnul(tls, var1, int32('='))) - int64(var1))
		l1 = v1
	}
	if v2 || !(v1 != 0) || *(*uint8)(unsafe.Pointer(var1 + uintptr(l1))) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	if !(overwrite != 0) && Xgetenv(tls, var1) != 0 {
		return 0
	}
	l2 = Xstrlen(tls, value)
	s = Xmalloc(tls, l1+l2+uint64(2))
	if !(s != 0) {
		return -int32(1)
	}
	Xmemcpy(tls, s, var1, l1)
	*(*uint8)(unsafe.Pointer(s + uintptr(l1))) = uint8('=')
	Xmemcpy(tls, s+uintptr(l1)+uintptr(1), value, l2+uint64(1))
	return X__putenv(tls, s, l1, s)
}

func _dummy2(tls *TLS, old uintptr, new1 uintptr) {
}

func Xunsetenv(tls *TLS, name uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var e, eo, v2 uintptr
	var l Tsize_t
	_, _, _, _ = e, eo, l, v2
	l = uint64(int64(X__strchrnul(tls, name, int32('='))) - int64(name))
	if !(l != 0) || *(*uint8)(unsafe.Pointer(name + uintptr(l))) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	if Xenviron != 0 {
		e = Xenviron
		eo = e
		for {
			if !(*(*uintptr)(unsafe.Pointer(e)) != 0) {
				break
			}
			if !(Xstrncmp(tls, name, *(*uintptr)(unsafe.Pointer(e)), l) != 0) && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(e)) + uintptr(l)))) == int32('=') {
				X__env_rm_add(tls, *(*uintptr)(unsafe.Pointer(e)), uintptr(0))
			} else {
				if eo != e {
					v2 = eo
					eo += 8
					*(*uintptr)(unsafe.Pointer(v2)) = *(*uintptr)(unsafe.Pointer(e))
				} else {
					eo += 8
				}
			}
			goto _1
		_1:
			;
			e += 8
		}
		if eo != e {
			*(*uintptr)(unsafe.Pointer(eo)) = uintptr(0)
		}
	}
	return 0
}

/* mips has one error code outside of the 8-bit range due to a
 * historical typo, so we just remap it. */

type Terrmsgstr_t = struct {
	Fstr0               [21]uint8
	FstrEILSEQ          [22]uint8
	FstrEDOM            [13]uint8
	FstrERANGE          [25]uint8
	FstrENOTTY          [10]uint8
	FstrEACCES          [18]uint8
	FstrEPERM           [24]uint8
	FstrENOENT          [26]uint8
	FstrESRCH           [16]uint8
	FstrEEXIST          [12]uint8
	FstrEOVERFLOW       [30]uint8
	FstrENOSPC          [24]uint8
	FstrENOMEM          [14]uint8
	FstrEBUSY           [14]uint8
	FstrEINTR           [24]uint8
	FstrEAGAIN          [33]uint8
	FstrESPIPE          [13]uint8
	FstrEXDEV           [18]uint8
	FstrEROFS           [22]uint8
	FstrENOTEMPTY       [20]uint8
	FstrECONNRESET      [25]uint8
	FstrETIMEDOUT       [20]uint8
	FstrECONNREFUSED    [19]uint8
	FstrEHOSTDOWN       [13]uint8
	FstrEHOSTUNREACH    [20]uint8
	FstrEADDRINUSE      [15]uint8
	FstrEPIPE           [12]uint8
	FstrEIO             [10]uint8
	FstrENXIO           [26]uint8
	FstrENOTBLK         [22]uint8
	FstrENODEV          [15]uint8
	FstrENOTDIR         [16]uint8
	FstrEISDIR          [15]uint8
	FstrETXTBSY         [15]uint8
	FstrENOEXEC         [18]uint8
	FstrEINVAL          [17]uint8
	FstrE2BIG           [23]uint8
	FstrELOOP           [19]uint8
	FstrENAMETOOLONG    [18]uint8
	FstrENFILE          [30]uint8
	FstrEMFILE          [30]uint8
	FstrEBADF           [20]uint8
	FstrECHILD          [17]uint8
	FstrEFAULT          [12]uint8
	FstrEFBIG           [15]uint8
	FstrEMLINK          [15]uint8
	FstrENOLCK          [19]uint8
	FstrEDEADLK         [30]uint8
	FstrENOTRECOVERABLE [22]uint8
	FstrEOWNERDEAD      [20]uint8
	FstrECANCELED       [19]uint8
	FstrENOSYS          [25]uint8
	FstrENOMSG          [27]uint8
	FstrEIDRM           [19]uint8
	FstrENOSTR          [20]uint8
	FstrENODATA         [18]uint8
	FstrETIME           [15]uint8
	FstrENOSR           [25]uint8
	FstrENOLINK         [22]uint8
	FstrEPROTO          [15]uint8
	FstrEBADMSG         [12]uint8
	FstrEBADFD          [29]uint8
	FstrENOTSOCK        [13]uint8
	FstrEDESTADDRREQ    [29]uint8
	FstrEMSGSIZE        [18]uint8
	FstrEPROTOTYPE      [31]uint8
	FstrENOPROTOOPT     [23]uint8
	FstrEPROTONOSUPPORT [23]uint8
	FstrESOCKTNOSUPPORT [26]uint8
	FstrENOTSUP         [14]uint8
	FstrEPFNOSUPPORT    [30]uint8
	FstrEAFNOSUPPORT    [41]uint8
	FstrEADDRNOTAVAIL   [22]uint8
	FstrENETDOWN        [16]uint8
	FstrENETUNREACH     [20]uint8
	FstrENETRESET       [28]uint8
	FstrECONNABORTED    [19]uint8
	FstrENOBUFS         [26]uint8
	FstrEISCONN         [20]uint8
	FstrENOTCONN        [21]uint8
	FstrESHUTDOWN       [34]uint8
	FstrEALREADY        [30]uint8
	FstrEINPROGRESS     [22]uint8
	FstrESTALE          [18]uint8
	FstrEREMOTEIO       [17]uint8
	FstrEDQUOT          [15]uint8
	FstrENOMEDIUM       [16]uint8
	FstrEMEDIUMTYPE     [18]uint8
	FstrEMULTIHOP       [19]uint8
	FstrENOKEY          [27]uint8
	FstrEKEYEXPIRED     [16]uint8
	FstrEKEYREVOKED     [21]uint8
	FstrEKEYREJECTED    [28]uint8
}

/* mips has one error code outside of the 8-bit range due to a
 * historical typo, so we just remap it. */

var _errmsgstr = Terrmsgstr_t{
	Fstr0:               [21]uint8{'N', 'o', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n'},
	FstrEILSEQ:          [22]uint8{'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'b', 'y', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'},
	FstrEDOM:            [13]uint8{'D', 'o', 'm', 'a', 'i', 'n', ' ', 'e', 'r', 'r', 'o', 'r'},
	FstrERANGE:          [25]uint8{'R', 'e', 's', 'u', 'l', 't', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'p', 'r', 'e', 's', 'e', 'n', 't', 'a', 'b', 'l', 'e'},
	FstrENOTTY:          [10]uint8{'N', 'o', 't', ' ', 'a', ' ', 't', 't', 'y'},
	FstrEACCES:          [18]uint8{'P', 'e', 'r', 'm', 'i', 's', 's', 'i', 'o', 'n', ' ', 'd', 'e', 'n', 'i', 'e', 'd'},
	FstrEPERM:           [24]uint8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'p', 'e', 'r', 'm', 'i', 't', 't', 'e', 'd'},
	FstrENOENT:          [26]uint8{'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'f', 'i', 'l', 'e', ' ', 'o', 'r', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y'},
	FstrESRCH:           [16]uint8{'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's'},
	FstrEEXIST:          [12]uint8{'F', 'i', 'l', 'e', ' ', 'e', 'x', 'i', 's', 't', 's'},
	FstrEOVERFLOW:       [30]uint8{'V', 'a', 'l', 'u', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e', ' ', 'f', 'o', 'r', ' ', 'd', 'a', 't', 'a', ' ', 't', 'y', 'p', 'e'},
	FstrENOSPC:          [24]uint8{'N', 'o', ' ', 's', 'p', 'a', 'c', 'e', ' ', 'l', 'e', 'f', 't', ' ', 'o', 'n', ' ', 'd', 'e', 'v', 'i', 'c', 'e'},
	FstrENOMEM:          [14]uint8{'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y'},
	FstrEBUSY:           [14]uint8{'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'b', 'u', 's', 'y'},
	FstrEINTR:           [24]uint8{'I', 'n', 't', 'e', 'r', 'r', 'u', 'p', 't', 'e', 'd', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'c', 'a', 'l', 'l'},
	FstrEAGAIN:          [33]uint8{'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', ' ', 't', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'i', 'l', 'y', ' ', 'u', 'n', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'},
	FstrESPIPE:          [13]uint8{'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 's', 'e', 'e', 'k'},
	FstrEXDEV:           [18]uint8{'C', 'r', 'o', 's', 's', '-', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'l', 'i', 'n', 'k'},
	FstrEROFS:           [22]uint8{'R', 'e', 'a', 'd', '-', 'o', 'n', 'l', 'y', ' ', 'f', 'i', 'l', 'e', ' ', 's', 'y', 's', 't', 'e', 'm'},
	FstrENOTEMPTY:       [20]uint8{'D', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y'},
	FstrECONNRESET:      [25]uint8{'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'r', 'e', 's', 'e', 't', ' ', 'b', 'y', ' ', 'p', 'e', 'e', 'r'},
	FstrETIMEDOUT:       [20]uint8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 't', 'i', 'm', 'e', 'd', ' ', 'o', 'u', 't'},
	FstrECONNREFUSED:    [19]uint8{'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'r', 'e', 'f', 'u', 's', 'e', 'd'},
	FstrEHOSTDOWN:       [13]uint8{'H', 'o', 's', 't', ' ', 'i', 's', ' ', 'd', 'o', 'w', 'n'},
	FstrEHOSTUNREACH:    [20]uint8{'H', 'o', 's', 't', ' ', 'i', 's', ' ', 'u', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e'},
	FstrEADDRINUSE:      [15]uint8{'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'i', 'n', ' ', 'u', 's', 'e'},
	FstrEPIPE:           [12]uint8{'B', 'r', 'o', 'k', 'e', 'n', ' ', 'p', 'i', 'p', 'e'},
	FstrEIO:             [10]uint8{'I', '/', 'O', ' ', 'e', 'r', 'r', 'o', 'r'},
	FstrENXIO:           [26]uint8{'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'o', 'r', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's'},
	FstrENOTBLK:         [22]uint8{'B', 'l', 'o', 'c', 'k', ' ', 'd', 'e', 'v', 'i', 'c', 'e', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'},
	FstrENODEV:          [15]uint8{'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'd', 'e', 'v', 'i', 'c', 'e'},
	FstrENOTDIR:         [16]uint8{'N', 'o', 't', ' ', 'a', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y'},
	FstrEISDIR:          [15]uint8{'I', 's', ' ', 'a', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y'},
	FstrETXTBSY:         [15]uint8{'T', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', ' ', 'b', 'u', 's', 'y'},
	FstrENOEXEC:         [18]uint8{'E', 'x', 'e', 'c', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 'e', 'r', 'r', 'o', 'r'},
	FstrEINVAL:          [17]uint8{'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't'},
	FstrE2BIG:           [23]uint8{'A', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'l', 'i', 's', 't', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g'},
	FstrELOOP:           [19]uint8{'S', 'y', 'm', 'b', 'o', 'l', 'i', 'c', ' ', 'l', 'i', 'n', 'k', ' ', 'l', 'o', 'o', 'p'},
	FstrENAMETOOLONG:    [18]uint8{'F', 'i', 'l', 'e', 'n', 'a', 'm', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g'},
	FstrENFILE:          [30]uint8{'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'o', 'p', 'e', 'n', ' ', 'f', 'i', 'l', 'e', 's', ' ', 'i', 'n', ' ', 's', 'y', 's', 't', 'e', 'm'},
	FstrEMFILE:          [30]uint8{'N', 'o', ' ', 'f', 'i', 'l', 'e', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r', 's', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'},
	FstrEBADF:           [20]uint8{'B', 'a', 'd', ' ', 'f', 'i', 'l', 'e', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r'},
	FstrECHILD:          [17]uint8{'N', 'o', ' ', 'c', 'h', 'i', 'l', 'd', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's'},
	FstrEFAULT:          [12]uint8{'B', 'a', 'd', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's'},
	FstrEFBIG:           [15]uint8{'F', 'i', 'l', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e'},
	FstrEMLINK:          [15]uint8{'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'l', 'i', 'n', 'k', 's'},
	FstrENOLCK:          [19]uint8{'N', 'o', ' ', 'l', 'o', 'c', 'k', 's', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'},
	FstrEDEADLK:         [30]uint8{'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'd', 'e', 'a', 'd', 'l', 'o', 'c', 'k', ' ', 'w', 'o', 'u', 'l', 'd', ' ', 'o', 'c', 'c', 'u', 'r'},
	FstrENOTRECOVERABLE: [22]uint8{'S', 't', 'a', 't', 'e', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'a', 'b', 'l', 'e'},
	FstrEOWNERDEAD:      [20]uint8{'P', 'r', 'e', 'v', 'i', 'o', 'u', 's', ' ', 'o', 'w', 'n', 'e', 'r', ' ', 'd', 'i', 'e', 'd'},
	FstrECANCELED:       [19]uint8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'a', 'n', 'c', 'e', 'l', 'e', 'd'},
	FstrENOSYS:          [25]uint8{'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'i', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'e', 'd'},
	FstrENOMSG:          [27]uint8{'N', 'o', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'o', 'f', ' ', 'd', 'e', 's', 'i', 'r', 'e', 'd', ' ', 't', 'y', 'p', 'e'},
	FstrEIDRM:           [19]uint8{'I', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', ' ', 'r', 'e', 'm', 'o', 'v', 'e', 'd'},
	FstrENOSTR:          [20]uint8{'D', 'e', 'v', 'i', 'c', 'e', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 't', 'r', 'e', 'a', 'm'},
	FstrENODATA:         [18]uint8{'N', 'o', ' ', 'd', 'a', 't', 'a', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'},
	FstrETIME:           [15]uint8{'D', 'e', 'v', 'i', 'c', 'e', ' ', 't', 'i', 'm', 'e', 'o', 'u', 't'},
	FstrENOSR:           [25]uint8{'O', 'u', 't', ' ', 'o', 'f', ' ', 's', 't', 'r', 'e', 'a', 'm', 's', ' ', 'r', 'e', 's', 'o', 'u', 'r', 'c', 'e', 's'},
	FstrENOLINK:         [22]uint8{'L', 'i', 'n', 'k', ' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 's', 'e', 'v', 'e', 'r', 'e', 'd'},
	FstrEPROTO:          [15]uint8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'e', 'r', 'r', 'o', 'r'},
	FstrEBADMSG:         [12]uint8{'B', 'a', 'd', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e'},
	FstrEBADFD:          [29]uint8{'F', 'i', 'l', 'e', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r', ' ', 'i', 'n', ' ', 'b', 'a', 'd', ' ', 's', 't', 'a', 't', 'e'},
	FstrENOTSOCK:        [13]uint8{'N', 'o', 't', ' ', 'a', ' ', 's', 'o', 'c', 'k', 'e', 't'},
	FstrEDESTADDRREQ:    [29]uint8{'D', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'},
	FstrEMSGSIZE:        [18]uint8{'M', 'e', 's', 's', 'a', 'g', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e'},
	FstrEPROTOTYPE:      [31]uint8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'w', 'r', 'o', 'n', 'g', ' ', 't', 'y', 'p', 'e', ' ', 'f', 'o', 'r', ' ', 's', 'o', 'c', 'k', 'e', 't'},
	FstrENOPROTOOPT:     [23]uint8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'},
	FstrEPROTONOSUPPORT: [23]uint8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'},
	FstrESOCKTNOSUPPORT: [26]uint8{'S', 'o', 'c', 'k', 'e', 't', ' ', 't', 'y', 'p', 'e', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'},
	FstrENOTSUP:         [14]uint8{'N', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'},
	FstrEPFNOSUPPORT:    [30]uint8{'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'},
	FstrEAFNOSUPPORT:    [41]uint8{'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l'},
	FstrEADDRNOTAVAIL:   [22]uint8{'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'},
	FstrENETDOWN:        [16]uint8{'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'i', 's', ' ', 'd', 'o', 'w', 'n'},
	FstrENETUNREACH:     [20]uint8{'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'u', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e'},
	FstrENETRESET:       [28]uint8{'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'r', 'e', 's', 'e', 't', ' ', 'b', 'y', ' ', 'n', 'e', 't', 'w', 'o', 'r', 'k'},
	FstrECONNABORTED:    [19]uint8{'C', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'a', 'b', 'o', 'r', 't', 'e', 'd'},
	FstrENOBUFS:         [26]uint8{'N', 'o', ' ', 'b', 'u', 'f', 'f', 'e', 'r', ' ', 's', 'p', 'a', 'c', 'e', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'},
	FstrEISCONN:         [20]uint8{'S', 'o', 'c', 'k', 'e', 't', ' ', 'i', 's', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd'},
	FstrENOTCONN:        [21]uint8{'S', 'o', 'c', 'k', 'e', 't', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd'},
	FstrESHUTDOWN:       [34]uint8{'C', 'a', 'n', 'n', 'o', 't', ' ', 's', 'e', 'n', 'd', ' ', 'a', 'f', 't', 'e', 'r', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 's', 'h', 'u', 't', 'd', 'o', 'w', 'n'},
	FstrEALREADY:        [30]uint8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's'},
	FstrEINPROGRESS:     [22]uint8{'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's'},
	FstrESTALE:          [18]uint8{'S', 't', 'a', 'l', 'e', ' ', 'f', 'i', 'l', 'e', ' ', 'h', 'a', 'n', 'd', 'l', 'e'},
	FstrEREMOTEIO:       [17]uint8{'R', 'e', 'm', 'o', 't', 'e', ' ', 'I', '/', 'O', ' ', 'e', 'r', 'r', 'o', 'r'},
	FstrEDQUOT:          [15]uint8{'Q', 'u', 'o', 't', 'a', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd'},
	FstrENOMEDIUM:       [16]uint8{'N', 'o', ' ', 'm', 'e', 'd', 'i', 'u', 'm', ' ', 'f', 'o', 'u', 'n', 'd'},
	FstrEMEDIUMTYPE:     [18]uint8{'W', 'r', 'o', 'n', 'g', ' ', 'm', 'e', 'd', 'i', 'u', 'm', ' ', 't', 'y', 'p', 'e'},
	FstrEMULTIHOP:       [19]uint8{'M', 'u', 'l', 't', 'i', 'h', 'o', 'p', ' ', 'a', 't', 't', 'e', 'm', 'p', 't', 'e', 'd'},
	FstrENOKEY:          [27]uint8{'R', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'k', 'e', 'y', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e'},
	FstrEKEYEXPIRED:     [16]uint8{'K', 'e', 'y', ' ', 'h', 'a', 's', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd'},
	FstrEKEYREVOKED:     [21]uint8{'K', 'e', 'y', ' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 'r', 'e', 'v', 'o', 'k', 'e', 'd'},
	FstrEKEYREJECTED:    [28]uint8{'K', 'e', 'y', ' ', 'w', 'a', 's', ' ', 'r', 'e', 'j', 'e', 'c', 't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 'e', 'r', 'v', 'i', 'c', 'e'},
}

var _errmsgidx = [132]uint16{
	1:   uint16(uint64(UintptrFromInt32(0) + 109)),
	2:   uint16(uint64(UintptrFromInt32(0) + 133)),
	3:   uint16(uint64(UintptrFromInt32(0) + 159)),
	4:   uint16(uint64(UintptrFromInt32(0) + 269)),
	5:   uint16(uint64(UintptrFromInt32(0) + 523)),
	6:   uint16(uint64(UintptrFromInt32(0) + 533)),
	7:   uint16(uint64(UintptrFromInt32(0) + 677)),
	8:   uint16(uint64(UintptrFromInt32(0) + 642)),
	9:   uint16(uint64(UintptrFromInt32(0) + 797)),
	10:  uint16(uint64(UintptrFromInt32(0) + 817)),
	11:  uint16(uint64(UintptrFromInt32(0) + 293)),
	12:  uint16(uint64(UintptrFromInt32(0) + 241)),
	13:  uint16(uint64(UintptrFromInt32(0) + 91)),
	14:  uint16(uint64(UintptrFromInt32(0) + 834)),
	15:  uint16(uint64(UintptrFromInt32(0) + 559)),
	16:  uint16(uint64(UintptrFromInt32(0) + 255)),
	17:  uint16(uint64(UintptrFromInt32(0) + 175)),
	18:  uint16(uint64(UintptrFromInt32(0) + 339)),
	19:  uint16(uint64(UintptrFromInt32(0) + 581)),
	20:  uint16(uint64(UintptrFromInt32(0) + 596)),
	21:  uint16(uint64(UintptrFromInt32(0) + 612)),
	22:  uint16(uint64(UintptrFromInt32(0) + 660)),
	23:  uint16(uint64(UintptrFromInt32(0) + 737)),
	24:  uint16(uint64(UintptrFromInt32(0) + 767)),
	25:  uint16(uint64(UintptrFromInt32(0) + 81)),
	26:  uint16(uint64(UintptrFromInt32(0) + 627)),
	27:  uint16(uint64(UintptrFromInt32(0) + 846)),
	28:  uint16(uint64(UintptrFromInt32(0) + 217)),
	29:  uint16(uint64(UintptrFromInt32(0) + 326)),
	30:  uint16(uint64(UintptrFromInt32(0) + 357)),
	31:  uint16(uint64(UintptrFromInt32(0) + 861)),
	32:  uint16(uint64(UintptrFromInt32(0) + 511)),
	33:  uint16(uint64(UintptrFromInt32(0) + 43)),
	34:  uint16(uint64(UintptrFromInt32(0) + 56)),
	35:  uint16(uint64(UintptrFromInt32(0) + 895)),
	36:  uint16(uint64(UintptrFromInt32(0) + 719)),
	37:  uint16(uint64(UintptrFromInt32(0) + 876)),
	38:  uint16(uint64(UintptrFromInt32(0) + 986)),
	39:  uint16(uint64(UintptrFromInt32(0) + 379)),
	40:  uint16(uint64(UintptrFromInt32(0) + 700)),
	42:  uint16(uint64(UintptrFromInt32(0) + 1011)),
	43:  uint16(uint64(UintptrFromInt32(0) + 1038)),
	60:  uint16(uint64(UintptrFromInt32(0) + 1057)),
	61:  uint16(uint64(UintptrFromInt32(0) + 1077)),
	62:  uint16(uint64(UintptrFromInt32(0) + 1095)),
	63:  uint16(uint64(UintptrFromInt32(0) + 1110)),
	67:  uint16(uint64(UintptrFromInt32(0) + 1135)),
	71:  uint16(uint64(UintptrFromInt32(0) + 1157)),
	72:  uint16(uint64(UintptrFromInt32(0) + 1803)),
	74:  uint16(uint64(UintptrFromInt32(0) + 1172)),
	75:  uint16(uint64(UintptrFromInt32(0) + 187)),
	77:  uint16(uint64(UintptrFromInt32(0) + 1184)),
	84:  uint16(uint64(UintptrFromInt32(0) + 21)),
	88:  uint16(uint64(UintptrFromInt32(0) + 1213)),
	89:  uint16(uint64(UintptrFromInt32(0) + 1226)),
	90:  uint16(uint64(UintptrFromInt32(0) + 1255)),
	91:  uint16(uint64(UintptrFromInt32(0) + 1273)),
	92:  uint16(uint64(UintptrFromInt32(0) + 1304)),
	93:  uint16(uint64(UintptrFromInt32(0) + 1327)),
	94:  uint16(uint64(UintptrFromInt32(0) + 1350)),
	95:  uint16(uint64(UintptrFromInt32(0) + 1376)),
	96:  uint16(uint64(UintptrFromInt32(0) + 1390)),
	97:  uint16(uint64(UintptrFromInt32(0) + 1420)),
	98:  uint16(uint64(UintptrFromInt32(0) + 496)),
	99:  uint16(uint64(UintptrFromInt32(0) + 1461)),
	100: uint16(uint64(UintptrFromInt32(0) + 1483)),
	101: uint16(uint64(UintptrFromInt32(0) + 1499)),
	102: uint16(uint64(UintptrFromInt32(0) + 1519)),
	103: uint16(uint64(UintptrFromInt32(0) + 1547)),
	104: uint16(uint64(UintptrFromInt32(0) + 399)),
	105: uint16(uint64(UintptrFromInt32(0) + 1566)),
	106: uint16(uint64(UintptrFromInt32(0) + 1592)),
	107: uint16(uint64(UintptrFromInt32(0) + 1612)),
	108: uint16(uint64(UintptrFromInt32(0) + 1633)),
	110: uint16(uint64(UintptrFromInt32(0) + 424)),
	111: uint16(uint64(UintptrFromInt32(0) + 444)),
	112: uint16(uint64(UintptrFromInt32(0) + 463)),
	113: uint16(uint64(UintptrFromInt32(0) + 476)),
	114: uint16(uint64(UintptrFromInt32(0) + 1667)),
	115: uint16(uint64(UintptrFromInt32(0) + 1697)),
	116: uint16(uint64(UintptrFromInt32(0) + 1719)),
	121: uint16(uint64(UintptrFromInt32(0) + 1737)),
	122: uint16(uint64(UintptrFromInt32(0) + 1754)),
	123: uint16(uint64(UintptrFromInt32(0) + 1769)),
	124: uint16(uint64(UintptrFromInt32(0) + 1785)),
	125: uint16(uint64(UintptrFromInt32(0) + 967)),
	126: uint16(uint64(UintptrFromInt32(0) + 1822)),
	127: uint16(uint64(UintptrFromInt32(0) + 1849)),
	128: uint16(uint64(UintptrFromInt32(0) + 1865)),
	129: uint16(uint64(UintptrFromInt32(0) + 1886)),
	130: uint16(uint64(UintptrFromInt32(0) + 947)),
	131: uint16(uint64(UintptrFromInt32(0) + 925)),
}

func X__strerror_l(tls *TLS, e int32, loc Tlocale_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v e=%v loc=%v, (%v:)", tls, e, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var s uintptr
	_ = s
	if uint64(e) >= Uint64FromInt64(264)/Uint64FromInt64(2) {
		e = 0
	}
	s = uintptr(unsafe.Pointer(&_errmsgstr)) + uintptr(_errmsgidx[e])
	return X__lctrans(tls, s, *(*uintptr)(unsafe.Pointer(loc + 5*8)))
}

func Xstrerror(tls *TLS, e int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v e=%v, (%v:)", tls, e, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__strerror_l(tls, e, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func Xstrerror_l(tls *TLS, e int32, loc Tlocale_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v e=%v loc=%v, (%v:)", tls, e, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__strerror_l(tls, e, loc)
}

func X_Exit(tls *TLS, ec int32) {
	if __ccgo_strace {
		trc("tls=%v ec=%v, (%v:)", tls, ec, origin(2))
	}
	X__syscall1(tls, int64(SYS_exit_group), int64(ec))
	for {
		X__syscall1(tls, int64(SYS_exit), int64(ec))
		goto _1
	_1:
	}
}

func X__assert_fail(tls *TLS, expr uintptr, file uintptr, line int32, func1 uintptr) {
	if __ccgo_strace {
		trc("tls=%v expr=%v file=%v line=%v func1=%v, (%v:)", tls, expr, file, line, func1, origin(2))
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	Xfprintf(tls, uintptr(unsafe.Pointer(&X__stderr_FILE)), __ccgo_ts+212, VaList(bp+8, expr, file, func1, line))
	Xabort(tls)
}

const COUNT = 32

var _funcs [32]uintptr
var _count int32
var _lock [1]int32

func X__funcs_on_quick_exit(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	var func1 uintptr
	var v1 int32
	_, _ = func1, v1
	___lock(tls, uintptr(unsafe.Pointer(&_lock)))
	for _count > 0 {
		_count--
		v1 = _count
		func1 = _funcs[v1]
		___unlock(tls, uintptr(unsafe.Pointer(&_lock)))
		(*(*func(*TLS))(unsafe.Pointer(&struct{ uintptr }{func1})))(tls)
		___lock(tls, uintptr(unsafe.Pointer(&_lock)))
	}
}

func Xat_quick_exit(tls *TLS, func1 uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v func1=%v, (%v:)", tls, func1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v1 int32
	_, _ = r, v1
	r = 0
	___lock(tls, uintptr(unsafe.Pointer(&_lock)))
	if _count == int32(32) {
		r = -int32(1)
	} else {
		v1 = _count
		_count++
		_funcs[v1] = func1
	}
	___unlock(tls, uintptr(unsafe.Pointer(&_lock)))
	return r
}

func _dummy3(tls *TLS) {
}

func Xquick_exit(tls *TLS, code int32) {
	if __ccgo_strace {
		trc("tls=%v code=%v, (%v:)", tls, code, origin(2))
	}
	X__funcs_on_quick_exit(tls)
	X_Exit(tls, code)
}

func Xcreat(tls *TLS, filename uintptr, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v filename=%v mode=%v, (%v:)", tls, filename, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	return Xopen(tls, filename, Int32FromInt32(O_CREAT)|Int32FromInt32(O_WRONLY)|Int32FromInt32(O_TRUNC), VaList(bp+8, mode))
}

func Xfcntl(tls *TLS, fd int32, cmd int32, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v cmd=%v va=%v, (%v:)", tls, fd, cmd, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ap Tva_list
	var arg uint64
	var ret, ret1, v1 int32
	var _ /* ex at bp+0 */ Tf_owner_ex
	_, _, _, _, _ = ap, arg, ret, ret1, v1
	ap = va
	arg = VaUint64(&ap)
	_ = ap
	if cmd == int32(F_SETFL) {
		arg |= uint64(O_LARGEFILE)
	}
	if cmd == int32(F_SETLKW) {
		return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_fcntl), int64(fd), int64(cmd), int64(uintptr(arg)), 0, 0, 0))))
	}
	if cmd == int32(F_GETOWN) {
		ret = int32(X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_GETOWN_EX)), int64(bp)))
		if ret == -int32(EINVAL) {
			return int32(X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(cmd), int64(uintptr(arg))))
		}
		if ret != 0 {
			return int32(X__syscall_ret(tls, uint64(ret)))
		}
		if (*(*Tf_owner_ex)(unsafe.Pointer(bp))).Ftype1 == int32(F_OWNER_PGRP) {
			v1 = -(*(*Tf_owner_ex)(unsafe.Pointer(bp))).Fpid
		} else {
			v1 = (*(*Tf_owner_ex)(unsafe.Pointer(bp))).Fpid
		}
		return v1
	}
	if cmd == int32(F_DUPFD_CLOEXEC) {
		ret1 = int32(X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_DUPFD_CLOEXEC)), int64(arg)))
		if ret1 != -int32(EINVAL) {
			if ret1 >= 0 {
				X__syscall3(tls, int64(SYS_fcntl), int64(ret1), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
			}
			return int32(X__syscall_ret(tls, uint64(ret1)))
		}
		ret1 = int32(X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_DUPFD_CLOEXEC)), int64(Int32FromInt32(0))))
		if ret1 != -int32(EINVAL) {
			if ret1 >= 0 {
				X__syscall1(tls, int64(SYS_close), int64(ret1))
			}
			return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
		}
		ret1 = int32(X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_DUPFD)), int64(arg)))
		if ret1 >= 0 {
			X__syscall3(tls, int64(SYS_fcntl), int64(ret1), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
		}
		return int32(X__syscall_ret(tls, uint64(ret1)))
	}
	switch cmd {
	case int32(F_SETLK):
		fallthrough
	case int32(F_GETLK):
		fallthrough
	case int32(F_GETOWN_EX):
		fallthrough
	case int32(F_SETOWN_EX):
		return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(cmd), int64(uintptr(arg))))))
	default:
		return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(cmd), int64(arg)))))
	}
	return r
}

func Xopen(tls *TLS, filename uintptr, flags int32, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v filename=%v flags=%v va=%v, (%v:)", tls, filename, flags, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var fd int32
	var mode Tmode_t
	_, _, _ = ap, fd, mode
	mode = uint32(0)
	if flags&int32(O_CREAT) != 0 || flags&int32(O_TMPFILE) == int32(O_TMPFILE) {
		ap = va
		mode = VaUint32(&ap)
		_ = ap
	}
	fd = int32(___syscall_cp(tls, int64(SYS_openat), int64(-Int32FromInt32(100)), int64(filename), int64(flags|Int32FromInt32(O_LARGEFILE)), int64(mode), 0, 0))
	if fd >= 0 && flags&int32(O_CLOEXEC) != 0 {
		X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
	}
	return int32(X__syscall_ret(tls, uint64(fd)))
}

func Xopenat(tls *TLS, fd int32, filename uintptr, flags int32, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v filename=%v flags=%v va=%v, (%v:)", tls, fd, filename, flags, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var mode Tmode_t
	_, _ = ap, mode
	mode = uint32(0)
	if flags&int32(O_CREAT) != 0 || flags&int32(O_TMPFILE) == int32(O_TMPFILE) {
		ap = va
		mode = VaUint32(&ap)
		_ = ap
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_openat), int64(fd), int64(filename), int64(flags|Int32FromInt32(O_LARGEFILE)), int64(mode), 0, 0))))
}

func Xposix_fadvise(tls *TLS, fd int32, base Toff_t, len1 Toff_t, advice int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v base=%v len1=%v advice=%v, (%v:)", tls, fd, base, len1, advice, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(-X__syscall4(tls, int64(SYS_fadvise64), int64(fd), base, len1, int64(advice)))
}

func Xposix_fallocate(tls *TLS, fd int32, base Toff_t, len1 Toff_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v base=%v len1=%v, (%v:)", tls, fd, base, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(-X__syscall4(tls, int64(SYS_fallocate), int64(fd), int64(Int32FromInt32(0)), base, len1))
}

const FE_ALL_EXCEPT = 31
const FE_DIVBYZERO = 2
const FE_DOWNWARD = 8388608
const FE_INEXACT = 16
const FE_INVALID = 1
const FE_OVERFLOW = 4
const FE_TONEAREST = 0
const FE_TOWARDZERO = 12582912
const FE_UNDERFLOW = 8
const FE_UPWARD = 4194304

type Tfexcept_t = uint32

type Tfenv_t = struct {
	F__fpcr uint32
	F__fpsr uint32
}

/* Dummy functions for archs lacking fenv implementation */

func Xfeclearexcept(tls *TLS, mask int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mask=%v, (%v:)", tls, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func Xferaiseexcept(tls *TLS, mask int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mask=%v, (%v:)", tls, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func Xfetestexcept(tls *TLS, mask int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mask=%v, (%v:)", tls, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func Xfegetround(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return FE_TONEAREST
}

func X__fesetround(tls *TLS, r int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v r=%v, (%v:)", tls, r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return 0
}

func Xfegetenv(tls *TLS, envp uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v envp=%v, (%v:)", tls, envp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func Xfesetenv(tls *TLS, envp uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v envp=%v, (%v:)", tls, envp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

const WCONTINUED = 8
const WEXITED = 4
const WNOWAIT = 16777216
const WSTOPPED = 2
const __WALL = 1073741824
const __WCLONE = 2147483648
const __WNOTHREAD = 536870912

type Tidtype_t = int32

const _P_ALL = 0
const _P_PID = 1
const _P_PGID = 2
const _P_PIDFD = 3
const F_APP = 128
const F_EOF = 16
const F_ERR = 32
const F_NORD = 4
const F_NOWR = 8
const F_PERM = 1
const F_SVB = 64
const KMAX = 128
const LDBL_EPSILON1 = 2.22044604925031308085e-16
const LDBL_MAX1 = 1.79769313486231570815e+308
const LDBL_MIN1 = 2.22507385850720138309e-308
const LD_B1B_DIG = 2
const LD_B1B_MAX = 254740991
const MASK = 127
const MAYBE_WAITERS = 1073741824
const UNGET = 8

type TFILE = struct {
	Fflags        uint32
	Frpos         uintptr
	Frend         uintptr
	Fclose1       uintptr
	Fwend         uintptr
	Fwpos         uintptr
	Fmustbezero_1 uintptr
	Fwbase        uintptr
	Fread         uintptr
	Fwrite        uintptr
	Fseek         uintptr
	Fbuf          uintptr
	Fbuf_size     Tsize_t
	Fprev         uintptr
	Fnext         uintptr
	Ffd           int32
	Fpipe_pid     int32
	Flockcount    int64
	Fmode         int32
	Flock         int32
	Flbf          int32
	Fcookie       uintptr
	Foff          Toff_t
	Fgetln_buf    uintptr
	Fmustbezero_2 uintptr
	Fshend        uintptr
	Fshlim        Toff_t
	Fshcnt        Toff_t
	Fprev_locked  uintptr
	Fnext_locked  uintptr
	Flocale       uintptr
}

type T_IO_FILE = TFILE

func _scanexp(tls *TLS, f uintptr, pok int32) (r int64) {
	var c, neg, x, v1, v10, v14, v18, v4 int32
	var y, v22 int64
	var v11, v12, v15, v16, v19, v2, v20, v3, v5, v6 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, neg, x, y, v1, v10, v11, v12, v14, v15, v16, v18, v19, v2, v20, v22, v3, v4, v5, v6
	neg = 0
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = X__shgetc(tls, f)
	}
	c = v1
	if c == int32('+') || c == int32('-') {
		neg = BoolInt32(c == int32('-'))
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v6 = f + 8
			v5 = *(*uintptr)(unsafe.Pointer(v6))
			*(*uintptr)(unsafe.Pointer(v6))++
			v4 = int32(*(*uint8)(unsafe.Pointer(v5)))
		} else {
			v4 = X__shgetc(tls, f)
		}
		c = v4
		if uint32(c-int32('0')) >= uint32(10) && pok != 0 {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
		}
	}
	if uint32(c-int32('0')) >= uint32(10) {
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		}
		return -Int64FromInt64(0x7fffffffffffffff) - Int64FromInt32(1)
	}
	x = 0
	for {
		if !(uint32(c-int32('0')) < uint32(10) && x < Int32FromInt32(INT_MAX)/Int32FromInt32(10)) {
			break
		}
		x = int32(10)*x + c - int32('0')
		goto _9
	_9:
		;
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v12 = f + 8
			v11 = *(*uintptr)(unsafe.Pointer(v12))
			*(*uintptr)(unsafe.Pointer(v12))++
			v10 = int32(*(*uint8)(unsafe.Pointer(v11)))
		} else {
			v10 = X__shgetc(tls, f)
		}
		c = v10
	}
	y = int64(x)
	for {
		if !(uint32(c-int32('0')) < uint32(10) && y < Int64FromInt64(0x7fffffffffffffff)/Int64FromInt32(100)) {
			break
		}
		y = int64(10)*y + int64(c) - int64('0')
		goto _13
	_13:
		;
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v16 = f + 8
			v15 = *(*uintptr)(unsafe.Pointer(v16))
			*(*uintptr)(unsafe.Pointer(v16))++
			v14 = int32(*(*uint8)(unsafe.Pointer(v15)))
		} else {
			v14 = X__shgetc(tls, f)
		}
		c = v14
	}
	for {
		if !(uint32(c-int32('0')) < uint32(10)) {
			break
		}
		goto _17
	_17:
		;
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v20 = f + 8
			v19 = *(*uintptr)(unsafe.Pointer(v20))
			*(*uintptr)(unsafe.Pointer(v20))++
			v18 = int32(*(*uint8)(unsafe.Pointer(v19)))
		} else {
			v18 = X__shgetc(tls, f)
		}
		c = v18
	}
	if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
		(*TFILE)(unsafe.Pointer(f)).Frpos--
	}
	if neg != 0 {
		v22 = -y
	} else {
		v22 = y
	}
	return v22
}

func _decfloat(tls *TLS, f uintptr, c int32, bits int32, emin int32, sign int32, pok int32) (r float64) {
	bp := tls.Alloc(512)
	defer tls.Free(512)
	var a, bitlim, denormal, e2, emax, gotdig, gotrad, i, j, k, lnz, p10, rp, rpm9, sh, z, v13, v14, v2, v21, v23, v29, v30, v6, v9 int32
	var bias, frac, y float64
	var carry, carry1, carry2, t, tmp, tmp2 Tuint32_t
	var dc, e10, lrp int64
	var tmp1 Tuint64_t
	var v10, v11, v15, v16, v3, v4, v7, v8 uintptr
	var _ /* x at bp+0 */ [128]Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, bias, bitlim, carry, carry1, carry2, dc, denormal, e10, e2, emax, frac, gotdig, gotrad, i, j, k, lnz, lrp, p10, rp, rpm9, sh, t, tmp, tmp1, tmp2, y, z, v10, v11, v13, v14, v15, v16, v2, v21, v23, v29, v3, v30, v4, v6, v7, v8, v9
	lrp = 0
	dc = 0
	e10 = 0
	lnz = 0
	gotdig = 0
	gotrad = 0
	emax = -emin - bits + int32(3)
	denormal = 0
	frac = Float64FromInt32(0)
	bias = Float64FromInt32(0)
	j = 0
	k = 0
	/* Don't let leading zeros consume buffer space */
	for {
		if !(c == int32('0')) {
			break
		}
		gotdig = int32(1)
		goto _1
	_1:
		;
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v4 = f + 8
			v3 = *(*uintptr)(unsafe.Pointer(v4))
			*(*uintptr)(unsafe.Pointer(v4))++
			v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
		} else {
			v2 = X__shgetc(tls, f)
		}
		c = v2
	}
	if c == int32('.') {
		gotrad = int32(1)
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v8 = f + 8
			v7 = *(*uintptr)(unsafe.Pointer(v8))
			*(*uintptr)(unsafe.Pointer(v8))++
			v6 = int32(*(*uint8)(unsafe.Pointer(v7)))
		} else {
			v6 = X__shgetc(tls, f)
		}
		c = v6
		for {
			if !(c == int32('0')) {
				break
			}
			gotdig = int32(1)
			lrp--
			goto _5
		_5:
			;
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v11 = f + 8
				v10 = *(*uintptr)(unsafe.Pointer(v11))
				*(*uintptr)(unsafe.Pointer(v11))++
				v9 = int32(*(*uint8)(unsafe.Pointer(v10)))
			} else {
				v9 = X__shgetc(tls, f)
			}
			c = v9
		}
	}
	(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[0] = uint32(0)
	for {
		if !(uint32(c-int32('0')) < uint32(10) || c == int32('.')) {
			break
		}
		if c == int32('.') {
			if gotrad != 0 {
				break
			}
			gotrad = int32(1)
			lrp = dc
		} else {
			if k < Int32FromInt32(KMAX)-Int32FromInt32(3) {
				dc++
				if c != int32('0') {
					lnz = int32(dc)
				}
				if j != 0 {
					(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k]*uint32(10) + uint32(c) - uint32('0')
				} else {
					(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = uint32(c - int32('0'))
				}
				j++
				v13 = j
				if v13 == int32(9) {
					k++
					j = 0
				}
				gotdig = int32(1)
			} else {
				dc++
				if c != int32('0') {
					lnz = (Int32FromInt32(KMAX) - Int32FromInt32(4)) * Int32FromInt32(9)
					*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(Int32FromInt32(KMAX)-Int32FromInt32(4))*4)) |= uint32(1)
				}
			}
		}
		goto _12
	_12:
		;
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v16 = f + 8
			v15 = *(*uintptr)(unsafe.Pointer(v16))
			*(*uintptr)(unsafe.Pointer(v16))++
			v14 = int32(*(*uint8)(unsafe.Pointer(v15)))
		} else {
			v14 = X__shgetc(tls, f)
		}
		c = v14
	}
	if !(gotrad != 0) {
		lrp = dc
	}
	if gotdig != 0 && c|int32(32) == int32('e') {
		e10 = _scanexp(tls, f, pok)
		if e10 == -Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1) {
			if pok != 0 {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				}
			} else {
				X__shlim(tls, f, int64(Int32FromInt32(0)))
				return Float64FromInt32(0)
			}
			e10 = 0
		}
		lrp += e10
	} else {
		if c >= 0 {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
		}
	}
	if !(gotdig != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		X__shlim(tls, f, int64(Int32FromInt32(0)))
		return Float64FromInt32(0)
	}
	/* Handle zero specially to avoid nasty special cases later */
	if !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[0] != 0) {
		return float64(sign) * float64(0)
	}
	/* Optimize small integers (w/no exponent) and over/under-flow */
	if lrp == dc && dc < int64(10) && (bits > int32(30) || (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[0]>>bits == uint32(0)) {
		return float64(sign) * float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[0])
	}
	if lrp > int64(-emin/int32(2)) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
		return float64(sign) * Float64FromFloat64(1.79769313486231570815e+308) * Float64FromFloat64(1.79769313486231570815e+308)
	}
	if lrp < int64(emin-Int32FromInt32(2)*Int32FromInt32(LDBL_MANT_DIG)) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
		return float64(sign) * Float64FromFloat64(2.22507385850720138309e-308) * Float64FromFloat64(2.22507385850720138309e-308)
	}
	/* Align incomplete final B1B digit */
	if j != 0 {
		for {
			if !(j < int32(9)) {
				break
			}
			*(*Tuint32_t)(unsafe.Pointer(bp + uintptr(k)*4)) *= uint32(10)
			goto _19
		_19:
			;
			j++
		}
		k++
		j = 0
	}
	a = 0
	z = k
	e2 = 0
	rp = int32(lrp)
	/* Optimize small to mid-size integers (even in exp. notation) */
	if lnz < int32(9) && lnz <= rp && rp < int32(18) {
		if rp == int32(9) {
			return float64(sign) * float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[0])
		}
		if rp < int32(9) {
			return float64(sign) * float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[0]) / float64(_p10s[int32(8)-rp])
		}
		bitlim = bits - int32(3)*(rp-Int32FromInt32(9))
		if bitlim > int32(30) || (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[0]>>bitlim == uint32(0) {
			return float64(sign) * float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[0]) * float64(_p10s[rp-int32(10)])
		}
	}
	/* Drop trailing zeros */
	for {
		if !!((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[z-int32(1)] != 0) {
			break
		}
		goto _20
	_20:
		;
		z--
	}
	/* Align radix point to B1B digit boundary */
	if rp%int32(9) != 0 {
		if rp >= 0 {
			v21 = rp % int32(9)
		} else {
			v21 = rp%int32(9) + int32(9)
		}
		rpm9 = v21
		p10 = _p10s[int32(8)-rpm9]
		carry = uint32(0)
		k = a
		for {
			if !(k != z) {
				break
			}
			tmp = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] % uint32(p10)
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k]/uint32(p10) + carry
			carry = uint32(int32(1000000000)/p10) * tmp
			if k == a && !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] != 0) {
				a = (a + int32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
				rp -= int32(9)
			}
			goto _22
		_22:
			;
			k++
		}
		if carry != 0 {
			v23 = z
			z++
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[v23] = carry
		}
		rp += int32(9) - rpm9
	}
	/* Upscale until desired number of bits are left of radix point */
	for rp < Int32FromInt32(9)*Int32FromInt32(LD_B1B_DIG) || rp == Int32FromInt32(9)*Int32FromInt32(LD_B1B_DIG) && (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[a] < _th[0] {
		carry1 = uint32(0)
		e2 -= int32(29)
		k = (z - int32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
		for {
			tmp1 = uint64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k])<<Int32FromInt32(29) + uint64(carry1)
			if tmp1 > uint64(1000000000) {
				carry1 = uint32(tmp1 / uint64(1000000000))
				(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = uint32(tmp1 % uint64(1000000000))
			} else {
				carry1 = uint32(0)
				(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = uint32(tmp1)
			}
			if k == (z-int32(1))&(Int32FromInt32(KMAX)-Int32FromInt32(1)) && k != a && !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] != 0) {
				z = k
			}
			if k == a {
				break
			}
			goto _24
		_24:
			;
			k = (k - int32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
		}
		if carry1 != 0 {
			rp += int32(9)
			a = (a - int32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
			if a == z {
				z = (z - int32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
				*(*Tuint32_t)(unsafe.Pointer(bp + uintptr((z-int32(1))&(Int32FromInt32(KMAX)-Int32FromInt32(1)))*4)) |= (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[z]
			}
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[a] = carry1
		}
	}
	/* Downscale until exactly number of bits are left of radix point */
	for {
		carry2 = uint32(0)
		sh = int32(1)
		i = 0
		for {
			if !(i < int32(LD_B1B_DIG)) {
				break
			}
			k = (a + i) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
			if k == z || (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] < _th[i] {
				i = int32(LD_B1B_DIG)
				break
			}
			if (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[(a+i)&(Int32FromInt32(KMAX)-Int32FromInt32(1))] > _th[i] {
				break
			}
			goto _26
		_26:
			;
			i++
		}
		if i == int32(LD_B1B_DIG) && rp == Int32FromInt32(9)*Int32FromInt32(LD_B1B_DIG) {
			break
		}
		/* FIXME: find a way to compute optimal sh */
		if rp > Int32FromInt32(9)+Int32FromInt32(9)*Int32FromInt32(LD_B1B_DIG) {
			sh = int32(9)
		}
		e2 += sh
		k = a
		for {
			if !(k != z) {
				break
			}
			tmp2 = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] & uint32(int32(1)<<sh-int32(1))
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k]>>sh + carry2
			carry2 = uint32(Int32FromInt32(1000000000)>>sh) * tmp2
			if k == a && !((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[k] != 0) {
				a = (a + int32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
				i--
				rp -= int32(9)
			}
			goto _27
		_27:
			;
			k = (k + int32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
		}
		if carry2 != 0 {
			if (z+int32(1))&(Int32FromInt32(KMAX)-Int32FromInt32(1)) != a {
				(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[z] = carry2
				z = (z + int32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
			} else {
				*(*Tuint32_t)(unsafe.Pointer(bp + uintptr((z-int32(1))&(Int32FromInt32(KMAX)-Int32FromInt32(1)))*4)) |= uint32(1)
			}
		}
		goto _25
	_25:
	}
	/* Assemble desired bits into floating point variable */
	v29 = Int32FromInt32(0)
	i = v29
	y = float64(v29)
	for {
		if !(i < int32(LD_B1B_DIG)) {
			break
		}
		if (a+i)&(Int32FromInt32(KMAX)-Int32FromInt32(1)) == z {
			v30 = (z + Int32FromInt32(1)) & (Int32FromInt32(KMAX) - Int32FromInt32(1))
			z = v30
			(*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[v30-int32(1)] = uint32(0)
		}
		y = Float64FromFloat64(1e+09)*y + float64((*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[(a+i)&(Int32FromInt32(KMAX)-Int32FromInt32(1))])
		goto _28
	_28:
		;
		i++
	}
	y *= float64(sign)
	/* Limit precision for denormal results */
	if bits > int32(LDBL_MANT_DIG)+e2-emin {
		bits = int32(LDBL_MANT_DIG) + e2 - emin
		if bits < 0 {
			bits = 0
		}
		denormal = int32(1)
	}
	/* Calculate bias term to force rounding, move out lower bits */
	if bits < int32(LDBL_MANT_DIG) {
		bias = Xcopysignl(tls, Xscalbn(tls, Float64FromInt32(1), Int32FromInt32(2)*Int32FromInt32(LDBL_MANT_DIG)-bits-int32(1)), y)
		frac = Xfmodl(tls, y, Xscalbn(tls, Float64FromInt32(1), int32(LDBL_MANT_DIG)-bits))
		y -= frac
		y += bias
	}
	/* Process tail of decimal input so it can affect rounding */
	if (a+i)&(Int32FromInt32(KMAX)-Int32FromInt32(1)) != z {
		t = (*(*[128]Tuint32_t)(unsafe.Pointer(bp)))[(a+i)&(Int32FromInt32(KMAX)-Int32FromInt32(1))]
		if t < uint32(500000000) && (t != 0 || (a+i+int32(1))&(Int32FromInt32(KMAX)-Int32FromInt32(1)) != z) {
			frac += float64(0.25) * float64(sign)
		} else {
			if t > uint32(500000000) {
				frac += float64(0.75) * float64(sign)
			} else {
				if t == uint32(500000000) {
					if (a+i+int32(1))&(Int32FromInt32(KMAX)-Int32FromInt32(1)) == z {
						frac += float64(0.5) * float64(sign)
					} else {
						frac += float64(0.75) * float64(sign)
					}
				}
			}
		}
		if int32(LDBL_MANT_DIG)-bits >= int32(2) && !(Xfmodl(tls, frac, Float64FromInt32(1)) != 0) {
			frac++
		}
	}
	y += frac
	y -= bias
	if (e2+int32(LDBL_MANT_DIG))&int32(INT_MAX) > emax-int32(5) {
		if Xfabsl(tls, y) >= Float64FromInt32(2)/Float64FromFloat64(2.22044604925031308085e-16) {
			if denormal != 0 && bits == int32(LDBL_MANT_DIG)+e2-emin {
				denormal = 0
			}
			y *= Float64FromFloat64(0.5)
			e2++
		}
		if e2+int32(LDBL_MANT_DIG) > emax || denormal != 0 && frac != 0 {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
		}
	}
	return Xscalbnl(tls, y, e2)
}

var _th = [2]Tuint32_t{
	0: uint32(9007199),
	1: uint32(254740991),
}

var _p10s = [8]int32{
	0: int32(10),
	1: int32(100),
	2: int32(1000),
	3: int32(10000),
	4: int32(100000),
	5: int32(1000000),
	6: int32(10000000),
	7: int32(100000000),
}

func _hexfloat(tls *TLS, f uintptr, bits int32, emin int32, sign int32, pok int32) (r float64) {
	var bias, scale, y float64
	var c, d, gotdig, gotrad, gottail, v1, v12, v16, v5, v8 int32
	var dc, e2, rp int64
	var x Tuint32_t
	var v10, v13, v14, v17, v18, v2, v3, v6, v7, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bias, c, d, dc, e2, gotdig, gotrad, gottail, rp, scale, x, y, v1, v10, v12, v13, v14, v16, v17, v18, v2, v3, v5, v6, v7, v8, v9
	x = uint32(0)
	y = Float64FromInt32(0)
	scale = Float64FromInt32(1)
	bias = Float64FromInt32(0)
	gottail = 0
	gotrad = 0
	gotdig = 0
	rp = 0
	dc = 0
	e2 = 0
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = X__shgetc(tls, f)
	}
	c = v1
	/* Skip leading zeros */
	for {
		if !(c == int32('0')) {
			break
		}
		gotdig = int32(1)
		goto _4
	_4:
		;
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v7 = f + 8
			v6 = *(*uintptr)(unsafe.Pointer(v7))
			*(*uintptr)(unsafe.Pointer(v7))++
			v5 = int32(*(*uint8)(unsafe.Pointer(v6)))
		} else {
			v5 = X__shgetc(tls, f)
		}
		c = v5
	}
	if c == int32('.') {
		gotrad = int32(1)
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v10 = f + 8
			v9 = *(*uintptr)(unsafe.Pointer(v10))
			*(*uintptr)(unsafe.Pointer(v10))++
			v8 = int32(*(*uint8)(unsafe.Pointer(v9)))
		} else {
			v8 = X__shgetc(tls, f)
		}
		c = v8
		/* Count zeros after the radix point before significand */
		rp = 0
		for {
			if !(c == int32('0')) {
				break
			}
			gotdig = int32(1)
			goto _11
		_11:
			;
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v14 = f + 8
				v13 = *(*uintptr)(unsafe.Pointer(v14))
				*(*uintptr)(unsafe.Pointer(v14))++
				v12 = int32(*(*uint8)(unsafe.Pointer(v13)))
			} else {
				v12 = X__shgetc(tls, f)
			}
			c = v12
			rp--
		}
	}
	for {
		if !(uint32(c-int32('0')) < uint32(10) || uint32(c|int32(32)-int32('a')) < uint32(6) || c == int32('.')) {
			break
		}
		if c == int32('.') {
			if gotrad != 0 {
				break
			}
			rp = dc
			gotrad = int32(1)
		} else {
			gotdig = int32(1)
			if c > int32('9') {
				d = c | int32(32) + int32(10) - int32('a')
			} else {
				d = c - int32('0')
			}
			if dc < int64(8) {
				x = x*uint32(16) + uint32(d)
			} else {
				if dc < int64(Int32FromInt32(LDBL_MANT_DIG)/Int32FromInt32(4)+Int32FromInt32(1)) {
					scale /= Float64FromInt32(16)
					y += float64(d) * scale
				} else {
					if d != 0 && !(gottail != 0) {
						y += Float64FromFloat64(0.5) * scale
						gottail = int32(1)
					}
				}
			}
			dc++
		}
		goto _15
	_15:
		;
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v18 = f + 8
			v17 = *(*uintptr)(unsafe.Pointer(v18))
			*(*uintptr)(unsafe.Pointer(v18))++
			v16 = int32(*(*uint8)(unsafe.Pointer(v17)))
		} else {
			v16 = X__shgetc(tls, f)
		}
		c = v16
	}
	if !(gotdig != 0) {
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		}
		if pok != 0 {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
			if gotrad != 0 {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				}
			}
		} else {
			X__shlim(tls, f, int64(Int32FromInt32(0)))
		}
		return float64(sign) * float64(0)
	}
	if !(gotrad != 0) {
		rp = dc
	}
	for dc < int64(8) {
		x *= uint32(16)
		dc++
	}
	if c|int32(32) == int32('p') {
		e2 = _scanexp(tls, f, pok)
		if e2 == -Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1) {
			if pok != 0 {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				}
			} else {
				X__shlim(tls, f, int64(Int32FromInt32(0)))
				return Float64FromInt32(0)
			}
			e2 = 0
		}
	} else {
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		}
	}
	e2 += int64(4)*rp - int64(32)
	if !(x != 0) {
		return float64(sign) * float64(0)
	}
	if e2 > int64(-emin) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
		return float64(sign) * Float64FromFloat64(1.79769313486231570815e+308) * Float64FromFloat64(1.79769313486231570815e+308)
	}
	if e2 < int64(emin-Int32FromInt32(2)*Int32FromInt32(LDBL_MANT_DIG)) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
		return float64(sign) * Float64FromFloat64(2.22507385850720138309e-308) * Float64FromFloat64(2.22507385850720138309e-308)
	}
	for x < uint32(0x80000000) {
		if y >= Float64FromFloat64(0.5) {
			x += x + uint32(1)
			y += y - Float64FromInt32(1)
		} else {
			x += x
			y += y
		}
		e2--
	}
	if int64(bits) > int64(32)+e2-int64(emin) {
		bits = int32(int64(32) + e2 - int64(emin))
		if bits < 0 {
			bits = 0
		}
	}
	if bits < int32(LDBL_MANT_DIG) {
		bias = Xcopysignl(tls, Xscalbn(tls, Float64FromInt32(1), Int32FromInt32(32)+Int32FromInt32(LDBL_MANT_DIG)-bits-int32(1)), float64(sign))
	}
	if bits < int32(32) && y != 0 && !(x&Uint32FromInt32(1) != 0) {
		x++
		y = Float64FromInt32(0)
	}
	y = bias + float64(sign)*float64(x) + float64(sign)*y
	y -= bias
	if !(y != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
	}
	return Xscalbnl(tls, y, int32(e2))
}

func X__floatscan(tls *TLS, f uintptr, prec int32, pok int32) (r float64) {
	if __ccgo_strace {
		trc("tls=%v f=%v prec=%v pok=%v, (%v:)", tls, f, prec, pok, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var bits, c, emin, sign, v1, v12, v19, v2, v22, v27, v34, v5, v6, v8 int32
	var i, v31 Tsize_t
	var v10, v13, v14, v20, v21, v23, v24, v28, v29, v3, v35, v36, v4, v9 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bits, c, emin, i, sign, v1, v10, v12, v13, v14, v19, v2, v20, v21, v22, v23, v24, v27, v28, v29, v3, v31, v34, v35, v36, v4, v5, v6, v8, v9
	sign = int32(1)
	switch prec {
	case 0:
		bits = int32(FLT_MANT_DIG)
		emin = -int32(125) - bits
	case int32(1):
		bits = int32(DBL_MANT_DIG)
		emin = -int32(1021) - bits
	case int32(2):
		bits = int32(LDBL_MANT_DIG)
		emin = -int32(1021) - bits
	default:
		return Float64FromInt32(0)
	}
	for {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v4 = f + 8
			v3 = *(*uintptr)(unsafe.Pointer(v4))
			*(*uintptr)(unsafe.Pointer(v4))++
			v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
		} else {
			v2 = X__shgetc(tls, f)
		}
		v1 = v2
		c = v1
		v5 = v1
		v6 = BoolInt32(v5 == int32(' ') || uint32(v5)-uint32('\t') < uint32(5))
		goto _7
	_7:
		if !(v6 != 0) {
			break
		}
	}
	if c == int32('+') || c == int32('-') {
		sign -= int32(2) * BoolInt32(c == int32('-'))
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v10 = f + 8
			v9 = *(*uintptr)(unsafe.Pointer(v10))
			*(*uintptr)(unsafe.Pointer(v10))++
			v8 = int32(*(*uint8)(unsafe.Pointer(v9)))
		} else {
			v8 = X__shgetc(tls, f)
		}
		c = v8
	}
	i = uint64(0)
	for {
		if !(i < uint64(8) && c|int32(32) == int32(*(*uint8)(unsafe.Pointer(__ccgo_ts + 247 + uintptr(i))))) {
			break
		}
		if i < uint64(7) {
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v14 = f + 8
				v13 = *(*uintptr)(unsafe.Pointer(v14))
				*(*uintptr)(unsafe.Pointer(v14))++
				v12 = int32(*(*uint8)(unsafe.Pointer(v13)))
			} else {
				v12 = X__shgetc(tls, f)
			}
			c = v12
		}
		goto _11
	_11:
		;
		i++
	}
	if i == uint64(3) || i == uint64(8) || i > uint64(3) && pok != 0 {
		if i != uint64(8) {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
			if pok != 0 {
				for {
					if !(i > uint64(3)) {
						break
					}
					if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
						(*TFILE)(unsafe.Pointer(f)).Frpos--
					}
					goto _16
				_16:
					;
					i--
				}
			}
		}
		return float64(float32(sign) * X__builtin_inff(tls))
	}
	if !(i != 0) {
		i = uint64(0)
		for {
			if !(i < uint64(3) && c|int32(32) == int32(*(*uint8)(unsafe.Pointer(__ccgo_ts + 256 + uintptr(i))))) {
				break
			}
			if i < uint64(2) {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v21 = f + 8
					v20 = *(*uintptr)(unsafe.Pointer(v21))
					*(*uintptr)(unsafe.Pointer(v21))++
					v19 = int32(*(*uint8)(unsafe.Pointer(v20)))
				} else {
					v19 = X__shgetc(tls, f)
				}
				c = v19
			}
			goto _18
		_18:
			;
			i++
		}
	}
	if i == uint64(3) {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v24 = f + 8
			v23 = *(*uintptr)(unsafe.Pointer(v24))
			*(*uintptr)(unsafe.Pointer(v24))++
			v22 = int32(*(*uint8)(unsafe.Pointer(v23)))
		} else {
			v22 = X__shgetc(tls, f)
		}
		if v22 != int32('(') {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
			return float64(X__builtin_nanf(tls, __ccgo_ts))
		}
		i = uint64(1)
		for {
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v29 = f + 8
				v28 = *(*uintptr)(unsafe.Pointer(v29))
				*(*uintptr)(unsafe.Pointer(v29))++
				v27 = int32(*(*uint8)(unsafe.Pointer(v28)))
			} else {
				v27 = X__shgetc(tls, f)
			}
			c = v27
			if uint32(c-int32('0')) < uint32(10) || uint32(c-int32('A')) < uint32(26) || uint32(c-int32('a')) < uint32(26) || c == int32('_') {
				goto _26
			}
			if c == int32(')') {
				return float64(X__builtin_nanf(tls, __ccgo_ts))
			}
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
			if !(pok != 0) {
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
				X__shlim(tls, f, int64(Int32FromInt32(0)))
				return Float64FromInt32(0)
			}
			for {
				v31 = i
				i--
				if !(v31 != 0) {
					break
				}
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				}
			}
			return float64(X__builtin_nanf(tls, __ccgo_ts))
			goto _26
		_26:
			;
			i++
		}
		return float64(X__builtin_nanf(tls, __ccgo_ts))
	}
	if i != 0 {
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		}
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		X__shlim(tls, f, int64(Int32FromInt32(0)))
		return Float64FromInt32(0)
	}
	if c == int32('0') {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v36 = f + 8
			v35 = *(*uintptr)(unsafe.Pointer(v36))
			*(*uintptr)(unsafe.Pointer(v36))++
			v34 = int32(*(*uint8)(unsafe.Pointer(v35)))
		} else {
			v34 = X__shgetc(tls, f)
		}
		c = v34
		if c|int32(32) == int32('x') {
			return _hexfloat(tls, f, bits, emin, sign, pok)
		}
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		}
		c = int32('0')
	}
	return _decfloat(tls, f, c, bits, emin, sign, pok)
}

// C documentation
//
//	/* Lookup table for digit values. -1==255>=36 -> invalid */
var _table6 = [257]uint8{
	0:   uint8(-Int32FromInt32(1)),
	1:   uint8(-Int32FromInt32(1)),
	2:   uint8(-Int32FromInt32(1)),
	3:   uint8(-Int32FromInt32(1)),
	4:   uint8(-Int32FromInt32(1)),
	5:   uint8(-Int32FromInt32(1)),
	6:   uint8(-Int32FromInt32(1)),
	7:   uint8(-Int32FromInt32(1)),
	8:   uint8(-Int32FromInt32(1)),
	9:   uint8(-Int32FromInt32(1)),
	10:  uint8(-Int32FromInt32(1)),
	11:  uint8(-Int32FromInt32(1)),
	12:  uint8(-Int32FromInt32(1)),
	13:  uint8(-Int32FromInt32(1)),
	14:  uint8(-Int32FromInt32(1)),
	15:  uint8(-Int32FromInt32(1)),
	16:  uint8(-Int32FromInt32(1)),
	17:  uint8(-Int32FromInt32(1)),
	18:  uint8(-Int32FromInt32(1)),
	19:  uint8(-Int32FromInt32(1)),
	20:  uint8(-Int32FromInt32(1)),
	21:  uint8(-Int32FromInt32(1)),
	22:  uint8(-Int32FromInt32(1)),
	23:  uint8(-Int32FromInt32(1)),
	24:  uint8(-Int32FromInt32(1)),
	25:  uint8(-Int32FromInt32(1)),
	26:  uint8(-Int32FromInt32(1)),
	27:  uint8(-Int32FromInt32(1)),
	28:  uint8(-Int32FromInt32(1)),
	29:  uint8(-Int32FromInt32(1)),
	30:  uint8(-Int32FromInt32(1)),
	31:  uint8(-Int32FromInt32(1)),
	32:  uint8(-Int32FromInt32(1)),
	33:  uint8(-Int32FromInt32(1)),
	34:  uint8(-Int32FromInt32(1)),
	35:  uint8(-Int32FromInt32(1)),
	36:  uint8(-Int32FromInt32(1)),
	37:  uint8(-Int32FromInt32(1)),
	38:  uint8(-Int32FromInt32(1)),
	39:  uint8(-Int32FromInt32(1)),
	40:  uint8(-Int32FromInt32(1)),
	41:  uint8(-Int32FromInt32(1)),
	42:  uint8(-Int32FromInt32(1)),
	43:  uint8(-Int32FromInt32(1)),
	44:  uint8(-Int32FromInt32(1)),
	45:  uint8(-Int32FromInt32(1)),
	46:  uint8(-Int32FromInt32(1)),
	47:  uint8(-Int32FromInt32(1)),
	48:  uint8(-Int32FromInt32(1)),
	50:  uint8(1),
	51:  uint8(2),
	52:  uint8(3),
	53:  uint8(4),
	54:  uint8(5),
	55:  uint8(6),
	56:  uint8(7),
	57:  uint8(8),
	58:  uint8(9),
	59:  uint8(-Int32FromInt32(1)),
	60:  uint8(-Int32FromInt32(1)),
	61:  uint8(-Int32FromInt32(1)),
	62:  uint8(-Int32FromInt32(1)),
	63:  uint8(-Int32FromInt32(1)),
	64:  uint8(-Int32FromInt32(1)),
	65:  uint8(-Int32FromInt32(1)),
	66:  uint8(10),
	67:  uint8(11),
	68:  uint8(12),
	69:  uint8(13),
	70:  uint8(14),
	71:  uint8(15),
	72:  uint8(16),
	73:  uint8(17),
	74:  uint8(18),
	75:  uint8(19),
	76:  uint8(20),
	77:  uint8(21),
	78:  uint8(22),
	79:  uint8(23),
	80:  uint8(24),
	81:  uint8(25),
	82:  uint8(26),
	83:  uint8(27),
	84:  uint8(28),
	85:  uint8(29),
	86:  uint8(30),
	87:  uint8(31),
	88:  uint8(32),
	89:  uint8(33),
	90:  uint8(34),
	91:  uint8(35),
	92:  uint8(-Int32FromInt32(1)),
	93:  uint8(-Int32FromInt32(1)),
	94:  uint8(-Int32FromInt32(1)),
	95:  uint8(-Int32FromInt32(1)),
	96:  uint8(-Int32FromInt32(1)),
	97:  uint8(-Int32FromInt32(1)),
	98:  uint8(10),
	99:  uint8(11),
	100: uint8(12),
	101: uint8(13),
	102: uint8(14),
	103: uint8(15),
	104: uint8(16),
	105: uint8(17),
	106: uint8(18),
	107: uint8(19),
	108: uint8(20),
	109: uint8(21),
	110: uint8(22),
	111: uint8(23),
	112: uint8(24),
	113: uint8(25),
	114: uint8(26),
	115: uint8(27),
	116: uint8(28),
	117: uint8(29),
	118: uint8(30),
	119: uint8(31),
	120: uint8(32),
	121: uint8(33),
	122: uint8(34),
	123: uint8(35),
	124: uint8(-Int32FromInt32(1)),
	125: uint8(-Int32FromInt32(1)),
	126: uint8(-Int32FromInt32(1)),
	127: uint8(-Int32FromInt32(1)),
	128: uint8(-Int32FromInt32(1)),
	129: uint8(-Int32FromInt32(1)),
	130: uint8(-Int32FromInt32(1)),
	131: uint8(-Int32FromInt32(1)),
	132: uint8(-Int32FromInt32(1)),
	133: uint8(-Int32FromInt32(1)),
	134: uint8(-Int32FromInt32(1)),
	135: uint8(-Int32FromInt32(1)),
	136: uint8(-Int32FromInt32(1)),
	137: uint8(-Int32FromInt32(1)),
	138: uint8(-Int32FromInt32(1)),
	139: uint8(-Int32FromInt32(1)),
	140: uint8(-Int32FromInt32(1)),
	141: uint8(-Int32FromInt32(1)),
	142: uint8(-Int32FromInt32(1)),
	143: uint8(-Int32FromInt32(1)),
	144: uint8(-Int32FromInt32(1)),
	145: uint8(-Int32FromInt32(1)),
	146: uint8(-Int32FromInt32(1)),
	147: uint8(-Int32FromInt32(1)),
	148: uint8(-Int32FromInt32(1)),
	149: uint8(-Int32FromInt32(1)),
	150: uint8(-Int32FromInt32(1)),
	151: uint8(-Int32FromInt32(1)),
	152: uint8(-Int32FromInt32(1)),
	153: uint8(-Int32FromInt32(1)),
	154: uint8(-Int32FromInt32(1)),
	155: uint8(-Int32FromInt32(1)),
	156: uint8(-Int32FromInt32(1)),
	157: uint8(-Int32FromInt32(1)),
	158: uint8(-Int32FromInt32(1)),
	159: uint8(-Int32FromInt32(1)),
	160: uint8(-Int32FromInt32(1)),
	161: uint8(-Int32FromInt32(1)),
	162: uint8(-Int32FromInt32(1)),
	163: uint8(-Int32FromInt32(1)),
	164: uint8(-Int32FromInt32(1)),
	165: uint8(-Int32FromInt32(1)),
	166: uint8(-Int32FromInt32(1)),
	167: uint8(-Int32FromInt32(1)),
	168: uint8(-Int32FromInt32(1)),
	169: uint8(-Int32FromInt32(1)),
	170: uint8(-Int32FromInt32(1)),
	171: uint8(-Int32FromInt32(1)),
	172: uint8(-Int32FromInt32(1)),
	173: uint8(-Int32FromInt32(1)),
	174: uint8(-Int32FromInt32(1)),
	175: uint8(-Int32FromInt32(1)),
	176: uint8(-Int32FromInt32(1)),
	177: uint8(-Int32FromInt32(1)),
	178: uint8(-Int32FromInt32(1)),
	179: uint8(-Int32FromInt32(1)),
	180: uint8(-Int32FromInt32(1)),
	181: uint8(-Int32FromInt32(1)),
	182: uint8(-Int32FromInt32(1)),
	183: uint8(-Int32FromInt32(1)),
	184: uint8(-Int32FromInt32(1)),
	185: uint8(-Int32FromInt32(1)),
	186: uint8(-Int32FromInt32(1)),
	187: uint8(-Int32FromInt32(1)),
	188: uint8(-Int32FromInt32(1)),
	189: uint8(-Int32FromInt32(1)),
	190: uint8(-Int32FromInt32(1)),
	191: uint8(-Int32FromInt32(1)),
	192: uint8(-Int32FromInt32(1)),
	193: uint8(-Int32FromInt32(1)),
	194: uint8(-Int32FromInt32(1)),
	195: uint8(-Int32FromInt32(1)),
	196: uint8(-Int32FromInt32(1)),
	197: uint8(-Int32FromInt32(1)),
	198: uint8(-Int32FromInt32(1)),
	199: uint8(-Int32FromInt32(1)),
	200: uint8(-Int32FromInt32(1)),
	201: uint8(-Int32FromInt32(1)),
	202: uint8(-Int32FromInt32(1)),
	203: uint8(-Int32FromInt32(1)),
	204: uint8(-Int32FromInt32(1)),
	205: uint8(-Int32FromInt32(1)),
	206: uint8(-Int32FromInt32(1)),
	207: uint8(-Int32FromInt32(1)),
	208: uint8(-Int32FromInt32(1)),
	209: uint8(-Int32FromInt32(1)),
	210: uint8(-Int32FromInt32(1)),
	211: uint8(-Int32FromInt32(1)),
	212: uint8(-Int32FromInt32(1)),
	213: uint8(-Int32FromInt32(1)),
	214: uint8(-Int32FromInt32(1)),
	215: uint8(-Int32FromInt32(1)),
	216: uint8(-Int32FromInt32(1)),
	217: uint8(-Int32FromInt32(1)),
	218: uint8(-Int32FromInt32(1)),
	219: uint8(-Int32FromInt32(1)),
	220: uint8(-Int32FromInt32(1)),
	221: uint8(-Int32FromInt32(1)),
	222: uint8(-Int32FromInt32(1)),
	223: uint8(-Int32FromInt32(1)),
	224: uint8(-Int32FromInt32(1)),
	225: uint8(-Int32FromInt32(1)),
	226: uint8(-Int32FromInt32(1)),
	227: uint8(-Int32FromInt32(1)),
	228: uint8(-Int32FromInt32(1)),
	229: uint8(-Int32FromInt32(1)),
	230: uint8(-Int32FromInt32(1)),
	231: uint8(-Int32FromInt32(1)),
	232: uint8(-Int32FromInt32(1)),
	233: uint8(-Int32FromInt32(1)),
	234: uint8(-Int32FromInt32(1)),
	235: uint8(-Int32FromInt32(1)),
	236: uint8(-Int32FromInt32(1)),
	237: uint8(-Int32FromInt32(1)),
	238: uint8(-Int32FromInt32(1)),
	239: uint8(-Int32FromInt32(1)),
	240: uint8(-Int32FromInt32(1)),
	241: uint8(-Int32FromInt32(1)),
	242: uint8(-Int32FromInt32(1)),
	243: uint8(-Int32FromInt32(1)),
	244: uint8(-Int32FromInt32(1)),
	245: uint8(-Int32FromInt32(1)),
	246: uint8(-Int32FromInt32(1)),
	247: uint8(-Int32FromInt32(1)),
	248: uint8(-Int32FromInt32(1)),
	249: uint8(-Int32FromInt32(1)),
	250: uint8(-Int32FromInt32(1)),
	251: uint8(-Int32FromInt32(1)),
	252: uint8(-Int32FromInt32(1)),
	253: uint8(-Int32FromInt32(1)),
	254: uint8(-Int32FromInt32(1)),
	255: uint8(-Int32FromInt32(1)),
	256: uint8(-Int32FromInt32(1)),
}

func X__intscan(tls *TLS, f uintptr, base uint32, pok int32, lim uint64) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v f=%v base=%v pok=%v lim=%v, (%v:)", tls, f, base, pok, lim, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var bs, c, neg, v1, v11, v14, v2, v21, v25, v29, v33, v37, v41, v45, v5, v6, v8 int32
	var val, v10, v12, v13, v15, v16, v22, v23, v26, v27, v3, v30, v31, v34, v35, v38, v39, v4, v42, v43, v46, v47, v9 uintptr
	var x uint32
	var y uint64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bs, c, neg, val, x, y, v1, v10, v11, v12, v13, v14, v15, v16, v2, v21, v22, v23, v25, v26, v27, v29, v3, v30, v31, v33, v34, v35, v37, v38, v39, v4, v41, v42, v43, v45, v46, v47, v5, v6, v8, v9
	val = uintptr(unsafe.Pointer(&_table6)) + uintptr(1)
	neg = 0
	if base > uint32(36) || base == uint32(1) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uint64(0)
	}
	for {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v4 = f + 8
			v3 = *(*uintptr)(unsafe.Pointer(v4))
			*(*uintptr)(unsafe.Pointer(v4))++
			v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
		} else {
			v2 = X__shgetc(tls, f)
		}
		v1 = v2
		c = v1
		v5 = v1
		v6 = BoolInt32(v5 == int32(' ') || uint32(v5)-uint32('\t') < uint32(5))
		goto _7
	_7:
		if !(v6 != 0) {
			break
		}
	}
	if c == int32('+') || c == int32('-') {
		neg = -BoolInt32(c == int32('-'))
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v10 = f + 8
			v9 = *(*uintptr)(unsafe.Pointer(v10))
			*(*uintptr)(unsafe.Pointer(v10))++
			v8 = int32(*(*uint8)(unsafe.Pointer(v9)))
		} else {
			v8 = X__shgetc(tls, f)
		}
		c = v8
	}
	if (base == uint32(0) || base == uint32(16)) && c == int32('0') {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v13 = f + 8
			v12 = *(*uintptr)(unsafe.Pointer(v13))
			*(*uintptr)(unsafe.Pointer(v13))++
			v11 = int32(*(*uint8)(unsafe.Pointer(v12)))
		} else {
			v11 = X__shgetc(tls, f)
		}
		c = v11
		if c|int32(32) == int32('x') {
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v16 = f + 8
				v15 = *(*uintptr)(unsafe.Pointer(v16))
				*(*uintptr)(unsafe.Pointer(v16))++
				v14 = int32(*(*uint8)(unsafe.Pointer(v15)))
			} else {
				v14 = X__shgetc(tls, f)
			}
			c = v14
			if int32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= int32(16) {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				}
				if pok != 0 {
					if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
						(*TFILE)(unsafe.Pointer(f)).Frpos--
					}
				} else {
					X__shlim(tls, f, int64(Int32FromInt32(0)))
				}
				return uint64(0)
			}
			base = uint32(16)
		} else {
			if base == uint32(0) {
				base = uint32(8)
			}
		}
	} else {
		if base == uint32(0) {
			base = uint32(10)
		}
		if uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) >= base {
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
			X__shlim(tls, f, int64(Int32FromInt32(0)))
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
			return uint64(0)
		}
	}
	if base == uint32(10) {
		x = uint32(0)
		for {
			if !(uint32(c-int32('0')) < uint32(10) && x <= Uint32FromUint32(0xffffffff)/Uint32FromInt32(10)-Uint32FromInt32(1)) {
				break
			}
			x = x*uint32(10) + uint32(c-Int32FromUint8('0'))
			goto _20
		_20:
			;
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v23 = f + 8
				v22 = *(*uintptr)(unsafe.Pointer(v23))
				*(*uintptr)(unsafe.Pointer(v23))++
				v21 = int32(*(*uint8)(unsafe.Pointer(v22)))
			} else {
				v21 = X__shgetc(tls, f)
			}
			c = v21
		}
		y = uint64(x)
		for {
			if !(uint32(c-int32('0')) < uint32(10) && y <= (Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))/Uint64FromInt32(10) && uint64(10)*y <= Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1)-uint64(c-Int32FromUint8('0'))) {
				break
			}
			y = y*uint64(10) + uint64(c-Int32FromUint8('0'))
			goto _24
		_24:
			;
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v27 = f + 8
				v26 = *(*uintptr)(unsafe.Pointer(v27))
				*(*uintptr)(unsafe.Pointer(v27))++
				v25 = int32(*(*uint8)(unsafe.Pointer(v26)))
			} else {
				v25 = X__shgetc(tls, f)
			}
			c = v25
		}
		if uint32(c-int32('0')) >= uint32(10) {
			goto done
		}
	} else {
		if !(base&(base-Uint32FromInt32(1)) != 0) {
			bs = int32(*(*uint8)(unsafe.Pointer(__ccgo_ts + 260 + uintptr(uint32(0x17)*base>>int32(5)&uint32(7)))))
			x = uint32(0)
			for {
				if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && x <= Uint32FromUint32(0xffffffff)/Uint32FromInt32(32)) {
					break
				}
				x = x<<bs | uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
				goto _28
			_28:
				;
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v31 = f + 8
					v30 = *(*uintptr)(unsafe.Pointer(v31))
					*(*uintptr)(unsafe.Pointer(v31))++
					v29 = int32(*(*uint8)(unsafe.Pointer(v30)))
				} else {
					v29 = X__shgetc(tls, f)
				}
				c = v29
			}
			y = uint64(x)
			for {
				if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && y <= (Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))>>bs) {
					break
				}
				y = y<<bs | uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
				goto _32
			_32:
				;
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v35 = f + 8
					v34 = *(*uintptr)(unsafe.Pointer(v35))
					*(*uintptr)(unsafe.Pointer(v35))++
					v33 = int32(*(*uint8)(unsafe.Pointer(v34)))
				} else {
					v33 = X__shgetc(tls, f)
				}
				c = v33
			}
		} else {
			x = uint32(0)
			for {
				if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && x <= Uint32FromUint32(0xffffffff)/Uint32FromInt32(36)-Uint32FromInt32(1)) {
					break
				}
				x = x*base + uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
				goto _36
			_36:
				;
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v39 = f + 8
					v38 = *(*uintptr)(unsafe.Pointer(v39))
					*(*uintptr)(unsafe.Pointer(v39))++
					v37 = int32(*(*uint8)(unsafe.Pointer(v38)))
				} else {
					v37 = X__shgetc(tls, f)
				}
				c = v37
			}
			y = uint64(x)
			for {
				if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base && y <= (Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))/uint64(base) && uint64(base)*y <= Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1)-uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))) {
					break
				}
				y = y*uint64(base) + uint64(*(*uint8)(unsafe.Pointer(val + uintptr(c))))
				goto _40
			_40:
				;
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v43 = f + 8
					v42 = *(*uintptr)(unsafe.Pointer(v43))
					*(*uintptr)(unsafe.Pointer(v43))++
					v41 = int32(*(*uint8)(unsafe.Pointer(v42)))
				} else {
					v41 = X__shgetc(tls, f)
				}
				c = v41
			}
		}
	}
	if uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base {
		for {
			if !(uint32(*(*uint8)(unsafe.Pointer(val + uintptr(c)))) < base) {
				break
			}
			goto _44
		_44:
			;
			if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
				v47 = f + 8
				v46 = *(*uintptr)(unsafe.Pointer(v47))
				*(*uintptr)(unsafe.Pointer(v47))++
				v45 = int32(*(*uint8)(unsafe.Pointer(v46)))
			} else {
				v45 = X__shgetc(tls, f)
			}
			c = v45
		}
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
		y = lim
		if lim&uint64(1) != 0 {
			neg = 0
		}
	}
	goto done
done:
	;
	if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
		(*TFILE)(unsafe.Pointer(f)).Frpos--
	}
	if y >= lim {
		if !(lim&Uint64FromInt32(1) != 0) && !(neg != 0) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
			return lim - uint64(1)
		} else {
			if y > lim {
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
				return lim
			}
		}
	}
	return y ^ uint64(neg) - uint64(neg)
}

func X__procfdname(tls *TLS, buf uintptr, fd uint32) {
	if __ccgo_strace {
		trc("tls=%v buf=%v fd=%v, (%v:)", tls, buf, fd, origin(2))
	}
	var i, j, v5 uint32
	var v2 uint8
	_, _, _, _ = i, j, v2, v5
	i = uint32(0)
	for {
		v2 = *(*uint8)(unsafe.Pointer(__ccgo_ts + 269 + uintptr(i)))
		*(*uint8)(unsafe.Pointer(buf + uintptr(i))) = v2
		if !(v2 != 0) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	if !(fd != 0) {
		*(*uint8)(unsafe.Pointer(buf + uintptr(i))) = uint8('0')
		*(*uint8)(unsafe.Pointer(buf + uintptr(i+uint32(1)))) = uint8(0)
		return
	}
	j = fd
	for {
		if !(j != 0) {
			break
		}
		goto _3
	_3:
		;
		j /= uint32(10)
		i++
	}
	*(*uint8)(unsafe.Pointer(buf + uintptr(i))) = uint8(0)
	for {
		if !(fd != 0) {
			break
		}
		i--
		v5 = i
		*(*uint8)(unsafe.Pointer(buf + uintptr(v5))) = uint8(uint32('0') + fd%uint32(10))
		goto _4
	_4:
		;
		fd /= uint32(10)
	}
}

/* The shcnt field stores the number of bytes read so far, offset by
 * the value of buf-rpos at the last function call (__shlim or __shgetc),
 * so that between calls the inline shcnt macro can add rpos-buf to get
 * the actual count. */

func X__shlim(tls *TLS, f uintptr, lim Toff_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v lim=%v, (%v:)", tls, f, lim, origin(2))
	}
	(*TFILE)(unsafe.Pointer(f)).Fshlim = lim
	(*TFILE)(unsafe.Pointer(f)).Fshcnt = int64((*TFILE)(unsafe.Pointer(f)).Fbuf) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
	/* If lim is nonzero, rend must be a valid pointer. */
	if lim != 0 && int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos) > lim {
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frpos + uintptr(lim)
	} else {
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frend
	}
}

func X__shgetc(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var c, v1 int32
	var cnt Toff_t
	var v2 bool
	_, _, _, _ = c, cnt, v1, v2
	cnt = (*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf))
	if v2 = (*TFILE)(unsafe.Pointer(f)).Fshlim != 0 && cnt >= (*TFILE)(unsafe.Pointer(f)).Fshlim; !v2 {
		v1 = X__uflow(tls, f)
		c = v1
	}
	if v2 || v1 < 0 {
		(*TFILE)(unsafe.Pointer(f)).Fshcnt = int64((*TFILE)(unsafe.Pointer(f)).Fbuf) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + cnt
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frpos
		(*TFILE)(unsafe.Pointer(f)).Fshlim = int64(-int32(1))
		return -int32(1)
	}
	cnt++
	if (*TFILE)(unsafe.Pointer(f)).Fshlim != 0 && int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos) > (*TFILE)(unsafe.Pointer(f)).Fshlim-cnt {
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frpos + uintptr((*TFILE)(unsafe.Pointer(f)).Fshlim-cnt)
	} else {
		(*TFILE)(unsafe.Pointer(f)).Fshend = (*TFILE)(unsafe.Pointer(f)).Frend
	}
	(*TFILE)(unsafe.Pointer(f)).Fshcnt = int64((*TFILE)(unsafe.Pointer(f)).Fbuf) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + cnt
	if (*TFILE)(unsafe.Pointer(f)).Frpos <= (*TFILE)(unsafe.Pointer(f)).Fbuf {
		*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos + uintptr(-Int32FromInt32(1)))) = uint8(c)
	}
	return c
}

func X__syscall_ret(tls *TLS, r uint64) (r1 int64) {
	if __ccgo_strace {
		trc("tls=%v r=%v, (%v:)", tls, r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	if r > -Uint64FromUint64(4096) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(-r)
		return int64(-int32(1))
	}
	return int64(r)
}

type TElf_Symndx = uint32

type Tdl_phdr_info = struct {
	Fdlpi_addr      TElf64_Addr
	Fdlpi_name      uintptr
	Fdlpi_phdr      uintptr
	Fdlpi_phnum     TElf64_Half
	Fdlpi_adds      uint64
	Fdlpi_subs      uint64
	Fdlpi_tls_modid Tsize_t
	Fdlpi_tls_data  uintptr
}

type Tlink_map = struct {
	Fl_addr TElf64_Addr
	Fl_name uintptr
	Fl_ld   uintptr
	Fl_next uintptr
	Fl_prev uintptr
}

type Tr_debug = struct {
	Fr_version int32
	Fr_map     uintptr
	Fr_brk     TElf64_Addr
	Fr_state   int32
	Fr_ldbase  TElf64_Addr
}

const _RT_CONSISTENT = 0
const _RT_ADD = 1
const _RT_DELETE = 2
const VERSION = "1.2.5"

const IPC_CREAT = 512
const IPC_EXCL = 1024
const IPC_INFO = 3
const IPC_NOWAIT = 2048
const IPC_RMID = 0
const IPC_SET = 1
const IPC_STAT = 2
const __ipc_perm_key = 0
const __ipc_perm_seq = 0

type Tkey_t = int32

type Tipc_perm = struct {
	F__key  Tkey_t
	Fuid    Tuid_t
	Fgid    Tgid_t
	Fcuid   Tuid_t
	Fcgid   Tgid_t
	Fmode   Tmode_t
	F__seq  int32
	F__pad1 int64
	F__pad2 int64
}

func Xftok(tls *TLS, path uintptr, id int32) (r Tkey_t) {
	if __ccgo_strace {
		trc("tls=%v path=%v id=%v, (%v:)", tls, path, id, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var _ /* st at bp+0 */ Tstat
	if Xstat(tls, path, bp) < 0 {
		return -int32(1)
	}
	return int32((*(*Tstat)(unsafe.Pointer(bp))).Fst_ino&Uint64FromInt32(0xffff) | (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev&Uint64FromInt32(0xff)<<Int32FromInt32(16) | uint64(uint32(id)&Uint32FromUint32(0xff)<<Int32FromInt32(24)))
}

const IPCOP_msgctl = 14
const IPCOP_msgget = 13
const IPCOP_msgrcv = 12
const IPCOP_msgsnd = 11
const IPCOP_semctl = 3
const IPCOP_semget = 2
const IPCOP_semop = 1
const IPCOP_semtimedop = 4
const IPCOP_shmat = 21
const IPCOP_shmctl = 24
const IPCOP_shmdt = 22
const IPCOP_shmget = 23
const IPC_TIME64 = 0
const MSG_EXCEPT = 8192
const MSG_INFO = 12
const MSG_NOERROR = 4096
const MSG_STAT = 11
const MSG_STAT_ANY = 13
const __msg_cbytes = 0

type Tmsgqnum_t = uint64

type Tmsglen_t = uint64

type Tmsqid_ds = struct {
	Fmsg_perm   Tipc_perm
	Fmsg_stime  Ttime_t
	Fmsg_rtime  Ttime_t
	Fmsg_ctime  Ttime_t
	Fmsg_cbytes uint64
	Fmsg_qnum   Tmsgqnum_t
	Fmsg_qbytes Tmsglen_t
	Fmsg_lspid  Tpid_t
	Fmsg_lrpid  Tpid_t
	F__unused   [2]uint64
}

type Tmsginfo = struct {
	Fmsgpool int32
	Fmsgmap  int32
	Fmsgmax  int32
	Fmsgmnb  int32
	Fmsgmni  int32
	Fmsgssz  int32
	Fmsgtql  int32
	Fmsgseg  uint16
}

func Xmsgctl(tls *TLS, q int32, cmd int32, buf uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v q=%v cmd=%v buf=%v, (%v:)", tls, q, cmd, buf, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = int32(X__syscall3(tls, int64(SYS_msgctl), int64(q), int64(cmd & ^(Int32FromInt32(IPC_STAT)&Int32FromInt32(0x100)) | Int32FromInt32(IPC_64)), int64(buf)))
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xmsgget(tls *TLS, k Tkey_t, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v k=%v flag=%v, (%v:)", tls, k, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_msgget), int64(k), int64(flag)))))
}

func Xmsgrcv(tls *TLS, q int32, m uintptr, len1 Tsize_t, type1 int64, flag int32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v q=%v m=%v len1=%v type1=%v flag=%v, (%v:)", tls, q, m, len1, type1, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_msgrcv), int64(q), int64(m), int64(len1), type1, int64(flag), 0)))
}

func Xmsgsnd(tls *TLS, q int32, m uintptr, len1 Tsize_t, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v q=%v m=%v len1=%v flag=%v, (%v:)", tls, q, m, len1, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_msgsnd), int64(q), int64(m), int64(len1), int64(flag), 0, 0))))
}

const GETALL = 13
const GETNCNT = 14
const GETPID = 11
const GETVAL = 12
const GETZCNT = 15
const SEM_INFO = 19
const SEM_STAT = 18
const SEM_STAT_ANY = 20
const SEM_UNDO = 4096
const SETALL = 17
const SETVAL = 16
const _SEM_SEMUN_UNDEFINED = 1

type Tsemid_ds = struct {
	Fsem_perm        Tipc_perm
	Fsem_otime       Ttime_t
	Fsem_ctime       Ttime_t
	Fsem_nsems       uint16
	F__sem_nsems_pad [6]uint8
	F__unused3       int64
	F__unused4       int64
}

type Tseminfo = struct {
	Fsemmap int32
	Fsemmni int32
	Fsemmns int32
	Fsemmnu int32
	Fsemmsl int32
	Fsemopm int32
	Fsemume int32
	Fsemusz int32
	Fsemvmx int32
	Fsemaem int32
}

type Tsembuf = struct {
	Fsem_num uint16
	Fsem_op  int16
	Fsem_flg int16
}

type Tsemun = struct {
	Fbuf         [0]uintptr
	Farray       [0]uintptr
	Fval         int32
	F__ccgo_pad3 [4]byte
}

func Xsemctl(tls *TLS, id int32, num int32, cmd int32, va uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v id=%v num=%v cmd=%v va=%v, (%v:)", tls, id, num, cmd, va, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ap Tva_list
	var r int32
	var _ /* arg at bp+0 */ Tsemun
	_, _ = ap, r
	*(*Tsemun)(unsafe.Pointer(bp)) = Tsemun{}
	*(*int32)(unsafe.Pointer(bp)) = 0
	switch cmd & ^(Int32FromInt32(IPC_STAT) & Int32FromInt32(0x100)) {
	case int32(SETVAL):
		fallthrough
	case int32(GETALL):
		fallthrough
	case int32(SETALL):
		fallthrough
	case int32(IPC_SET):
		fallthrough
	case int32(IPC_INFO):
		fallthrough
	case int32(SEM_INFO):
		fallthrough
	case Int32FromInt32(IPC_STAT) & ^(Int32FromInt32(IPC_STAT) & Int32FromInt32(0x100)):
		fallthrough
	case (Int32FromInt32(18) | Int32FromInt32(IPC_STAT)&Int32FromInt32(0x100)) & ^(Int32FromInt32(IPC_STAT) & Int32FromInt32(0x100)):
		fallthrough
	case (Int32FromInt32(20) | Int32FromInt32(IPC_STAT)&Int32FromInt32(0x100)) & ^(Int32FromInt32(IPC_STAT) & Int32FromInt32(0x100)):
		ap = va
		*(*Tsemun)(unsafe.Pointer(bp)) = *(*Tsemun)(unsafe.Pointer(VaOther(&ap, 8)))
		_ = ap
	}
	r = int32(X__syscall4(tls, int64(SYS_semctl), int64(id), int64(num), int64(cmd & ^(Int32FromInt32(IPC_STAT)&Int32FromInt32(0x100)) | Int32FromInt32(IPC_64)), int64(*(*uintptr)(unsafe.Pointer(bp)))))
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xsemget(tls *TLS, key Tkey_t, n int32, fl int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v key=%v n=%v fl=%v, (%v:)", tls, key, n, fl, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* The kernel uses the wrong type for the sem_nsems member
	 * of struct semid_ds, and thus might not check that the
	 * n fits in the correct (per POSIX) userspace type, so
	 * we have to check here. */
	if n > int32(USHRT_MAX) {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_semget), int64(key), int64(n), int64(fl)))))
}

func Xsemop(tls *TLS, id int32, buf uintptr, n Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v id=%v buf=%v n=%v, (%v:)", tls, id, buf, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_semop), int64(id), int64(buf), int64(n)))))
}

const NO_TIME32 = 0
const __key = 0
const __seq = 0

type Tipc_perm1 = struct {
	Fkey    Tkey_t
	Fuid    Tuid_t
	Fgid    Tgid_t
	Fcuid   Tuid_t
	Fcgid   Tgid_t
	Fmode   Tmode_t
	Fseq    int32
	F__pad1 int64
	F__pad2 int64
}

type Tsemid_ds1 = struct {
	Fsem_perm        Tipc_perm1
	Fsem_otime       Ttime_t
	Fsem_ctime       Ttime_t
	Fsem_nsems       uint16
	F__sem_nsems_pad [6]uint8
	F__unused3       int64
	F__unused4       int64
}

func Xsemtimedop(tls *TLS, id int32, buf uintptr, n Tsize_t, ts uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v id=%v buf=%v n=%v ts=%v, (%v:)", tls, id, buf, n, ts, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_semtimedop), int64(id), int64(buf), int64(n), int64(ts)))))
}

const SHMLBA = 4096
const SHM_DEST = 512
const SHM_EXEC = 32768
const SHM_HUGETLB = 2048
const SHM_HUGE_16GB = 2281701376
const SHM_HUGE_16MB = 1610612736
const SHM_HUGE_1GB = 2013265920
const SHM_HUGE_1MB = 1342177280
const SHM_HUGE_256MB = 1879048192
const SHM_HUGE_2GB = 2080374784
const SHM_HUGE_2MB = 1409286144
const SHM_HUGE_32MB = 1677721600
const SHM_HUGE_512KB = 1275068416
const SHM_HUGE_512MB = 1946157056
const SHM_HUGE_64KB = 1073741824
const SHM_HUGE_8MB = 1543503872
const SHM_HUGE_MASK = 63
const SHM_HUGE_SHIFT = 26
const SHM_INFO = 14
const SHM_LOCK = 11
const SHM_LOCKED = 1024
const SHM_NORESERVE = 4096
const SHM_R = 256
const SHM_RDONLY = 4096
const SHM_REMAP = 16384
const SHM_RND = 8192
const SHM_STAT = 13
const SHM_STAT_ANY = 15
const SHM_UNLOCK = 12
const SHM_W = 128

type Tshmid_ds = struct {
	Fshm_perm   Tipc_perm
	Fshm_segsz  Tsize_t
	Fshm_atime  Ttime_t
	Fshm_dtime  Ttime_t
	Fshm_ctime  Ttime_t
	Fshm_cpid   Tpid_t
	Fshm_lpid   Tpid_t
	Fshm_nattch uint64
	F__pad1     uint64
	F__pad2     uint64
}

type Tshminfo = struct {
	Fshmmax   uint64
	Fshmmin   uint64
	Fshmmni   uint64
	Fshmseg   uint64
	Fshmall   uint64
	F__unused [4]uint64
}

type Tshm_info = struct {
	F__used_ids       int32
	Fshm_tot          uint64
	Fshm_rss          uint64
	Fshm_swp          uint64
	F__swap_attempts  uint64
	F__swap_successes uint64
}

type Tshmatt_t = uint64

func Xshmat(tls *TLS, id int32, addr uintptr, flag int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v id=%v addr=%v flag=%v, (%v:)", tls, id, addr, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_shmat), int64(id), int64(addr), int64(flag)))))
}

func Xshmctl(tls *TLS, id int32, cmd int32, buf uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v id=%v cmd=%v buf=%v, (%v:)", tls, id, cmd, buf, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = int32(X__syscall3(tls, int64(SYS_shmctl), int64(id), int64(cmd & ^(Int32FromInt32(IPC_STAT)&Int32FromInt32(0x100)) | Int32FromInt32(IPC_64)), int64(buf)))
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xshmdt(tls *TLS, addr uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v, (%v:)", tls, addr, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_shmdt), int64(addr)))))
}

func Xshmget(tls *TLS, key Tkey_t, size Tsize_t, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v key=%v size=%v flag=%v, (%v:)", tls, key, size, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if size > uint64(Int64FromInt64(INT64_MAX)) {
		size = Uint64FromUint64(0xffffffffffffffff)
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_shmget), int64(key), int64(size), int64(flag)))))
}

type Tpasswd = struct {
	Fpw_name   uintptr
	Fpw_passwd uintptr
	Fpw_uid    Tuid_t
	Fpw_gid    Tgid_t
	Fpw_gecos  uintptr
	Fpw_dir    uintptr
	Fpw_shell  uintptr
}

func Xcuserid(tls *TLS, buf uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v buf=%v, (%v:)", tls, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(2112)
	defer tls.Free(2112)
	var len1 Tsize_t
	var _ /* ppw at bp+48 */ uintptr
	var _ /* pw at bp+0 */ Tpasswd
	var _ /* pwb at bp+56 */ [256]int64
	_ = len1
	if buf != 0 {
		*(*uint8)(unsafe.Pointer(buf)) = uint8(0)
	}
	Xgetpwuid_r(tls, Xgeteuid(tls), bp, bp+56, uint64(2048), bp+48)
	if !(*(*uintptr)(unsafe.Pointer(bp + 48)) != 0) {
		return buf
	}
	len1 = Xstrnlen(tls, (*(*Tpasswd)(unsafe.Pointer(bp))).Fpw_name, uint64(L_cuserid))
	if len1 == uint64(L_cuserid) {
		return buf
	}
	if !(buf != 0) {
		buf = uintptr(unsafe.Pointer(&_usridbuf))
	}
	Xmemcpy(tls, buf, (*(*Tpasswd)(unsafe.Pointer(bp))).Fpw_name, len1+uint64(1))
	return buf
}

var _usridbuf [20]uint8

func Xvwarn(tls *TLS, fmt uintptr, ap Tva_list) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v ap=%v, (%v:)", tls, fmt, ap, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	Xfprintf(tls, uintptr(unsafe.Pointer(&X__stderr_FILE)), __ccgo_ts+284, VaList(bp+8, Xprogram_invocation_short_name))
	if fmt != 0 {
		Xvfprintf(tls, uintptr(unsafe.Pointer(&X__stderr_FILE)), fmt, ap)
		Xfputs(tls, __ccgo_ts+289, uintptr(unsafe.Pointer(&X__stderr_FILE)))
	}
	Xperror(tls, uintptr(0))
}

func Xvwarnx(tls *TLS, fmt uintptr, ap Tva_list) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v ap=%v, (%v:)", tls, fmt, ap, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	Xfprintf(tls, uintptr(unsafe.Pointer(&X__stderr_FILE)), __ccgo_ts+284, VaList(bp+8, Xprogram_invocation_short_name))
	if fmt != 0 {
		Xvfprintf(tls, uintptr(unsafe.Pointer(&X__stderr_FILE)), fmt, ap)
	}
	Xputc(tls, int32('\n'), uintptr(unsafe.Pointer(&X__stderr_FILE)))
}

func Xverr(tls *TLS, status int32, fmt uintptr, ap Tva_list) {
	if __ccgo_strace {
		trc("tls=%v status=%v fmt=%v ap=%v, (%v:)", tls, status, fmt, ap, origin(2))
	}
	Xvwarn(tls, fmt, ap)
	_exit(tls, status)
}

func Xverrx(tls *TLS, status int32, fmt uintptr, ap Tva_list) {
	if __ccgo_strace {
		trc("tls=%v status=%v fmt=%v ap=%v, (%v:)", tls, status, fmt, ap, origin(2))
	}
	Xvwarnx(tls, fmt, ap)
	_exit(tls, status)
}

func Xwarn(tls *TLS, fmt uintptr, va uintptr) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v va=%v, (%v:)", tls, fmt, va, origin(2))
	}
	var ap Tva_list
	_ = ap
	ap = va
	Xvwarn(tls, fmt, ap)
	_ = ap
}

func Xwarnx(tls *TLS, fmt uintptr, va uintptr) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v va=%v, (%v:)", tls, fmt, va, origin(2))
	}
	var ap Tva_list
	_ = ap
	ap = va
	Xvwarnx(tls, fmt, ap)
	_ = ap
}

func Xerr(tls *TLS, status int32, fmt uintptr, va uintptr) {
	if __ccgo_strace {
		trc("tls=%v status=%v fmt=%v va=%v, (%v:)", tls, status, fmt, va, origin(2))
	}
	var ap Tva_list
	_ = ap
	ap = va
	Xverr(tls, status, fmt, ap)
	_ = ap
}

func Xerrx(tls *TLS, status int32, fmt uintptr, va uintptr) {
	if __ccgo_strace {
		trc("tls=%v status=%v fmt=%v va=%v, (%v:)", tls, status, fmt, va, origin(2))
	}
	var ap Tva_list
	_ = ap
	ap = va
	Xverrx(tls, status, fmt, ap)
	_ = ap
}

func Xeuidaccess(tls *TLS, filename uintptr, amode int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v filename=%v amode=%v, (%v:)", tls, filename, amode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfaccessat(tls, -int32(100), filename, amode, int32(AT_EACCESS))
}

func Xeaccess(tls *TLS, filename uintptr, amode int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v filename=%v amode=%v, (%v:)", tls, filename, amode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xeuidaccess(tls, filename, amode)
}

const FTW_CHDIR = 4
const FTW_D = 2
const FTW_DEPTH = 8
const FTW_DNR = 3
const FTW_DP = 6
const FTW_F = 1
const FTW_MOUNT = 2
const FTW_NS = 4
const FTW_PHYS = 1
const FTW_SL = 5
const FTW_SLN = 7

type TFTW = struct {
	Fbase  int32
	Flevel int32
}

func Xftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v fn=%v fd_limit=%v, (%v:)", tls, path, fn, fd_limit, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* The following cast assumes that calling a function with one
	 * argument more than it needs behaves as expected. This is
	 * actually undefined, but works on all real-world machines. */
	return Xnftw(tls, path, fn, fd_limit, int32(FTW_PHYS))
}

const STATX_ALL = 4095
const STATX_ATIME = 32
const STATX_BASIC_STATS = 2047
const STATX_BLOCKS = 1024
const STATX_BTIME = 2048
const STATX_CTIME = 128
const STATX_GID = 16
const STATX_INO = 256
const STATX_MODE = 2
const STATX_MTIME = 64
const STATX_NLINK = 4
const STATX_SIZE = 512
const STATX_TYPE = 1
const STATX_UID = 8
const S_IEXEC = 64
const S_IREAD = 256
const S_IWRITE = 128

type Tstatx_timestamp = struct {
	Ftv_sec  Tint64_t
	Ftv_nsec Tuint32_t
	F__pad   Tuint32_t
}

type Tstatx = struct {
	Fstx_mask            Tuint32_t
	Fstx_blksize         Tuint32_t
	Fstx_attributes      Tuint64_t
	Fstx_nlink           Tuint32_t
	Fstx_uid             Tuint32_t
	Fstx_gid             Tuint32_t
	Fstx_mode            Tuint16_t
	F__pad0              [1]Tuint16_t
	Fstx_ino             Tuint64_t
	Fstx_size            Tuint64_t
	Fstx_blocks          Tuint64_t
	Fstx_attributes_mask Tuint64_t
	Fstx_atime           Tstatx_timestamp
	Fstx_btime           Tstatx_timestamp
	Fstx_ctime           Tstatx_timestamp
	Fstx_mtime           Tstatx_timestamp
	Fstx_rdev_major      Tuint32_t
	Fstx_rdev_minor      Tuint32_t
	Fstx_dev_major       Tuint32_t
	Fstx_dev_minor       Tuint32_t
	F__pad1              [14]Tuint64_t
}

type Ttimezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
}

func Xfutimes(tls *TLS, fd int32, tv uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v tv=%v, (%v:)", tls, fd, tv, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* times at bp+0 */ [2]Ttimespec
	if !(tv != 0) {
		return Xfutimens(tls, fd, uintptr(0))
	}
	(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[0].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(tv))).Ftv_sec
	(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[0].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(tv))).Ftv_usec * int64(1000)
	(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(1)].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(tv + 1*16))).Ftv_sec
	(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(1)].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(tv + 1*16))).Ftv_usec * int64(1000)
	return Xfutimens(tls, fd, bp)
}

const prlimit64 = 0

func Xgetdtablesize(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 uint64
	var _ /* rl at bp+0 */ Trlimit
	_ = v1
	Xgetrlimit(tls, int32(RLIMIT_NOFILE), bp)
	if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur < uint64(INT_MAX) {
		v1 = (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur
	} else {
		v1 = uint64(INT_MAX)
	}
	return int32(v1)
}

func Xgetloadavg(tls *TLS, a uintptr, n int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v n=%v, (%v:)", tls, a, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(368)
	defer tls.Free(368)
	var i, v1 int32
	var _ /* si at bp+0 */ Tsysinfo
	_, _ = i, v1
	if n <= 0 {
		if n != 0 {
			v1 = -int32(1)
		} else {
			v1 = 0
		}
		return v1
	}
	Xsysinfo(tls, bp)
	if n > int32(3) {
		n = int32(3)
	}
	i = 0
	for {
		if !(i < n) {
			break
		}
		*(*float64)(unsafe.Pointer(a + uintptr(i)*8)) = Float64FromFloat64(1) / float64(Int32FromInt32(1)<<Int32FromInt32(SI_LOAD_SHIFT)) * float64(*(*uint64)(unsafe.Pointer(bp + 8 + uintptr(i)*8)))
		goto _2
	_2:
		;
		i++
	}
	return n
}

func Xgetpagesize(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__libc.Fpage_size)
}

const B0 = 0
const B1000000 = 4104
const B110 = 3
const B115200 = 4098
const B1152000 = 4105
const B1200 = 9
const B134 = 4
const B150 = 5
const B1500000 = 4106
const B1800 = 10
const B19200 = 14
const B200 = 6
const B2000000 = 4107
const B230400 = 4099
const B2400 = 11
const B2500000 = 4108
const B300 = 7
const B3000000 = 4109
const B3500000 = 4110
const B38400 = 15
const B4000000 = 4111
const B460800 = 4100
const B4800 = 12
const B50 = 1
const B500000 = 4101
const B57600 = 4097
const B576000 = 4102
const B600 = 8
const B75 = 2
const B921600 = 4103
const B9600 = 13
const BRKINT = 2
const BS0 = 0
const BS1 = 8192
const BSDLY = 8192
const CBAUD = 4111
const CBAUDEX = 4096
const CIBAUD = 269418496
const CLOCAL = 2048
const CMSPAR = 1073741824
const CR0 = 0
const CR1 = 512
const CR2 = 1024
const CR3 = 1536
const CRDLY = 1536
const CREAD = 128
const CRTSCTS = 2147483648
const CS5 = 0
const CS6 = 16
const CS7 = 32
const CS8 = 48
const CSIZE = 48
const CSTOPB = 64
const ECHO = 8
const ECHOCTL = 512
const ECHOE = 16
const ECHOK = 32
const ECHOKE = 2048
const ECHONL = 64
const ECHOPRT = 1024
const EXTA = 14
const EXTB = 15
const EXTPROC = 65536
const FF0 = 0
const FF1 = 32768
const FFDLY = 32768
const FLUSHO = 4096
const HUPCL = 1024
const ICANON = 2
const ICRNL = 256
const IEXTEN = 32768
const IGNBRK = 1
const IGNCR = 128
const IGNPAR = 4
const IMAXBEL = 8192
const INLCR = 64
const INPCK = 16
const ISIG = 1
const ISTRIP = 32
const IUCLC = 512
const IUTF8 = 16384
const IXANY = 2048
const IXOFF = 4096
const IXON = 1024
const NCCS = 32
const NL0 = 0
const NL1 = 256
const NLDLY = 256
const NOFLSH = 128
const OCRNL = 8
const OFDEL = 128
const OFILL = 64
const OLCUC = 2
const ONLCR = 4
const ONLRET = 32
const ONOCR = 16
const OPOST = 1
const PARENB = 256
const PARMRK = 8
const PARODD = 512
const PENDIN = 16384
const TAB0 = 0
const TAB1 = 2048
const TAB2 = 4096
const TAB3 = 6144
const TABDLY = 6144
const TCIFLUSH = 0
const TCIOFF = 2
const TCIOFLUSH = 2
const TCION = 3
const TCOFLUSH = 1
const TCOOFF = 0
const TCOON = 1
const TCSADRAIN = 1
const TCSAFLUSH = 2
const TCSANOW = 0
const TOSTOP = 256
const VDISCARD = 13
const VEOF = 4
const VEOL = 11
const VEOL2 = 16
const VERASE = 2
const VINTR = 0
const VKILL = 3
const VLNEXT = 15
const VMIN = 6
const VQUIT = 1
const VREPRINT = 12
const VSTART = 8
const VSTOP = 9
const VSUSP = 10
const VSWTC = 7
const VT0 = 0
const VT1 = 16384
const VTDLY = 16384
const VTIME = 5
const VWERASE = 14
const XCASE = 4
const XTABS = 6144

type Twinsize = struct {
	Fws_row    uint16
	Fws_col    uint16
	Fws_xpixel uint16
	Fws_ypixel uint16
}

type Tcc_t = uint8

type Tspeed_t = uint32

type Ttcflag_t = uint32

type Ttermios = struct {
	Fc_iflag    Ttcflag_t
	Fc_oflag    Ttcflag_t
	Fc_cflag    Ttcflag_t
	Fc_lflag    Ttcflag_t
	Fc_line     Tcc_t
	Fc_cc       [32]Tcc_t
	F__c_ispeed Tspeed_t
	F__c_ospeed Tspeed_t
}

func Xgetpass(tls *TLS, prompt uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v prompt=%v, (%v:)", tls, prompt, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var fd, v1 int32
	var l Tssize_t
	var v2 uintptr
	var _ /* s at bp+0 */ Ttermios
	var _ /* t at bp+60 */ Ttermios
	_, _, _, _ = fd, l, v1, v2
	v1 = Xopen(tls, __ccgo_ts+292, Int32FromInt32(O_RDWR)|Int32FromInt32(O_NOCTTY)|Int32FromInt32(O_CLOEXEC), 0)
	fd = v1
	if v1 < 0 {
		return uintptr(0)
	}
	Xtcgetattr(tls, fd, bp+60)
	*(*Ttermios)(unsafe.Pointer(bp)) = *(*Ttermios)(unsafe.Pointer(bp + 60))
	(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_lflag &= uint32(^(Int32FromInt32(ECHO) | Int32FromInt32(ISIG)))
	(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_lflag |= uint32(ICANON)
	(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_iflag &= uint32(^(Int32FromInt32(INLCR) | Int32FromInt32(IGNCR)))
	(*(*Ttermios)(unsafe.Pointer(bp + 60))).Fc_iflag |= uint32(ICRNL)
	Xtcsetattr(tls, fd, int32(TCSAFLUSH), bp+60)
	Xtcdrain(tls, fd)
	Xdprintf(tls, fd, __ccgo_ts+15, VaList(bp+128, prompt))
	l = Xread(tls, fd, uintptr(unsafe.Pointer(&_password)), uint64(128))
	if l >= 0 {
		if l > 0 && int32(_password[l-int64(1)]) == int32('\n') || uint64(l) == uint64(128) {
			l--
		}
		_password[l] = uint8(0)
	}
	Xtcsetattr(tls, fd, int32(TCSAFLUSH), bp)
	Xdprintf(tls, fd, __ccgo_ts+301, 0)
	Xclose(tls, fd)
	if l < 0 {
		v2 = uintptr(0)
	} else {
		v2 = uintptr(unsafe.Pointer(&_password))
	}
	return v2
}

var _password [128]uint8

var _defshells = [18]uint8{'/', 'b', 'i', 'n', '/', 's', 'h', 10, '/', 'b', 'i', 'n', '/', 'c', 's', 'h', 10}

var _line uintptr
var _linesize Tsize_t
var _f uintptr

func Xendusershell(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	if _f != 0 {
		Xfclose(tls, _f)
	}
	_f = uintptr(0)
}

func Xsetusershell(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	if !(_f != 0) {
		_f = Xfopen(tls, __ccgo_ts+303, __ccgo_ts+315)
	}
	if !(_f != 0) {
		_f = Xfmemopen(tls, uintptr(unsafe.Pointer(&_defshells)), Uint64FromInt64(18)-Uint64FromInt32(1), __ccgo_ts+319)
	}
}

func Xgetusershell(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tssize_t
	_ = l
	if !(_f != 0) {
		Xsetusershell(tls)
	}
	if !(_f != 0) {
		return uintptr(0)
	}
	l = Xgetline(tls, uintptr(unsafe.Pointer(&_line)), uintptr(unsafe.Pointer(&_linesize)), _f)
	if l <= 0 {
		return uintptr(0)
	}
	if int32(*(*uint8)(unsafe.Pointer(_line + uintptr(l-int64(1))))) == int32('\n') {
		*(*uint8)(unsafe.Pointer(_line + uintptr(l-int64(1)))) = uint8(0)
	}
	return _line
}

const ANYMARK = 1
const FLUSHBAND = 4
const FLUSHR = 1
const FLUSHRW = 3
const FLUSHW = 2
const FMNAMESZ = 8
const I_ATMARK = 21279
const I_CANPUT = 21282
const I_CKBAND = 21277
const I_FDINSERT = 21264
const I_FIND = 21259
const I_FLUSH = 21253
const I_FLUSHBAND = 21276
const I_GETBAND = 21278
const I_GETCLTIME = 21281
const I_GETSIG = 21258
const I_GRDOPT = 21255
const I_GWROPT = 21268
const I_LINK = 21260
const I_LIST = 21269
const I_LOOK = 21252
const I_NREAD = 21249
const I_PEEK = 21263
const I_PLINK = 21270
const I_POP = 21251
const I_PUNLINK = 21271
const I_PUSH = 21250
const I_RECVFD = 21262
const I_SENDFD = 21265
const I_SETCLTIME = 21280
const I_SETSIG = 21257
const I_SRDOPT = 21254
const I_STR = 21256
const I_SWROPT = 21267
const I_UNLINK = 21261
const LASTMARK = 2
const MORECTL = 1
const MOREDATA = 2
const MSG_ANY = 2
const MSG_BAND = 4
const MSG_HIPRI = 1
const MUXID_ALL = -1
const RMSGD = 1
const RMSGN = 2
const RNORM = 0
const RPROTDAT = 4
const RPROTDIS = 8
const RPROTMASK = 28
const RPROTNORM = 16
const RS_HIPRI = 1
const SNDPIPE = 2
const SNDZERO = 1
const S_BANDURG = 512
const S_ERROR = 16
const S_HANGUP = 32
const S_HIPRI = 2
const S_INPUT = 1
const S_MSG = 8
const S_OUTPUT = 4
const S_RDBAND = 128
const S_RDNORM = 64
const S_WRBAND = 256
const S_WRNORM = 4
const __SID = 21248

type Tbandinfo = struct {
	Fbi_pri  uint8
	Fbi_flag int32
}

type Tstrbuf = struct {
	Fmaxlen int32
	Flen1   int32
	Fbuf    uintptr
}

type Tstrpeek = struct {
	Fctlbuf  Tstrbuf
	Fdatabuf Tstrbuf
	Fflags   uint32
}

type Tstrfdinsert = struct {
	Fctlbuf  Tstrbuf
	Fdatabuf Tstrbuf
	Fflags   uint32
	Ffildes  int32
	Foffset  int32
}

type Tstrioctl = struct {
	Fic_cmd    int32
	Fic_timout int32
	Fic_len    int32
	Fic_dp     uintptr
}

type Tstrrecvfd = struct {
	Ffd     int32
	Fuid    int32
	Fgid    int32
	F__fill [8]uint8
}

type Tstr_mlist = struct {
	Fl_name [9]uint8
}

type Tstr_list = struct {
	Fsl_nmods   int32
	Fsl_modlist uintptr
}

func Xisastream(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	_ = v1
	if Xfcntl(tls, fd, int32(F_GETFD), 0) < 0 {
		v1 = -int32(1)
	} else {
		v1 = 0
	}
	return v1
}

func Xlutimes(tls *TLS, filename uintptr, tv uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v filename=%v tv=%v, (%v:)", tls, filename, tv, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var v1 uintptr
	var _ /* times at bp+0 */ [2]Ttimespec
	_ = v1
	if tv != 0 {
		(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[0].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(tv))).Ftv_sec
		(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[0].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(tv))).Ftv_usec * int64(1000)
		(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(1)].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(tv + 1*16))).Ftv_sec
		(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[int32(1)].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(tv + 1*16))).Ftv_usec * int64(1000)
	}
	if tv != 0 {
		v1 = bp
	} else {
		v1 = uintptr(0)
	}
	return Xutimensat(tls, -int32(100), filename, v1, int32(AT_SYMLINK_NOFOLLOW))
}

const UL_GETFSIZE = 1
const UL_SETFSIZE = 2

func Xulimit(tls *TLS, cmd int32, va uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v cmd=%v va=%v, (%v:)", tls, cmd, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ap Tva_list
	var val int64
	var _ /* rl at bp+0 */ Trlimit
	_, _ = ap, val
	Xgetrlimit(tls, int32(RLIMIT_FSIZE), bp)
	if cmd == int32(UL_SETFSIZE) {
		ap = va
		val = VaInt64(&ap)
		_ = ap
		(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur = uint64(512) * uint64(val)
		if Xsetrlimit(tls, int32(RLIMIT_FSIZE), bp) != 0 {
			return int64(-int32(1))
		}
	}
	return int64((*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur / uint64(512))
}

const BOOT_TIME = 2
const DEAD_PROCESS = 8
const EMPTY = 0
const INIT_PROCESS = 5
const LOGIN_PROCESS = 6
const NEW_TIME = 3
const OLD_TIME = 4
const RUN_LVL = 1
const USER_PROCESS = 7
const e_exit = 0
const e_termination = 0

type Tutmpx = struct {
	Fut_type   int16
	F__ut_pad1 int16
	Fut_pid    Tpid_t
	Fut_line   [32]uint8
	Fut_id     [4]uint8
	Fut_user   [32]uint8
	Fut_host   [256]uint8
	Fut_exit   struct {
		F__e_termination int16
		F__e_exit        int16
	}
	Fut_session int32
	F__ut_pad2  int32
	Fut_tv      Ttimeval
	Fut_addr_v6 [4]uint32
	F__unused   [20]uint8
}

func Xendutxent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
}

func Xsetutxent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
}

func Xgetutxent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return UintptrFromInt32(0)
}

func Xgetutxid(tls *TLS, ut uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ut=%v, (%v:)", tls, ut, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return UintptrFromInt32(0)
}

func Xgetutxline(tls *TLS, ut uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ut=%v, (%v:)", tls, ut, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return UintptrFromInt32(0)
}

func Xpututxline(tls *TLS, ut uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ut=%v, (%v:)", tls, ut, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return UintptrFromInt32(0)
}

func Xupdwtmpx(tls *TLS, f uintptr, u uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v u=%v, (%v:)", tls, f, u, origin(2))
	}
}

func ___utmpxname(tls *TLS, f uintptr) (r int32) {
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOPNOTSUPP)
	return -int32(1)
}

func Xendutent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	Xendutxent(tls)
}

func Xgetutent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetutxent(tls)
}

func Xgetutid(tls *TLS, ut uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ut=%v, (%v:)", tls, ut, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetutxid(tls, ut)
}

func Xgetutline(tls *TLS, ut uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ut=%v, (%v:)", tls, ut, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetutxline(tls, ut)
}

func Xpututline(tls *TLS, ut uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ut=%v, (%v:)", tls, ut, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xpututxline(tls, ut)
}

func Xsetutent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	Xsetutxent(tls)
}

func Xupdwtmp(tls *TLS, f uintptr, u uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v u=%v, (%v:)", tls, f, u, origin(2))
	}
	Xupdwtmpx(tls, f, u)
}

const ADJ_ESTERROR = 8
const ADJ_FREQUENCY = 2
const ADJ_MAXERROR = 4
const ADJ_MICRO = 4096
const ADJ_NANO = 8192
const ADJ_OFFSET = 1
const ADJ_OFFSET_SINGLESHOT = 32769
const ADJ_OFFSET_SS_READ = 40961
const ADJ_SETOFFSET = 256
const ADJ_STATUS = 16
const ADJ_TAI = 128
const ADJ_TICK = 16384
const ADJ_TIMECONST = 32
const MAXTC = 6
const MOD_CLKA = 32769
const MOD_CLKB = 16384
const MOD_ESTERROR = 8
const MOD_FREQUENCY = 2
const MOD_MAXERROR = 4
const MOD_MICRO = 4096
const MOD_NANO = 8192
const MOD_OFFSET = 1
const MOD_STATUS = 16
const MOD_TAI = 128
const MOD_TIMECONST = 32
const STA_CLK = 32768
const STA_CLOCKERR = 4096
const STA_DEL = 32
const STA_FLL = 8
const STA_FREQHOLD = 128
const STA_INS = 16
const STA_MODE = 16384
const STA_NANO = 8192
const STA_PLL = 1
const STA_PPSERROR = 2048
const STA_PPSFREQ = 2
const STA_PPSJITTER = 512
const STA_PPSSIGNAL = 256
const STA_PPSTIME = 4
const STA_PPSWANDER = 1024
const STA_RONLY = 65280
const STA_UNSYNC = 64
const TIME_BAD = 5
const TIME_DEL = 2
const TIME_ERROR = 5
const TIME_INS = 1
const TIME_OK = 0
const TIME_OOP = 3
const TIME_WAIT = 4

type Tntptimeval = struct {
	Ftime     Ttimeval
	Fmaxerror int64
	Festerror int64
}

type Ttimex = struct {
	Fmodes     uint32
	Foffset    int64
	Ffreq      int64
	Fmaxerror  int64
	Festerror  int64
	Fstatus    int32
	Fconstant  int64
	Fprecision int64
	Ftolerance int64
	Ftime      Ttimeval
	Ftick      int64
	Fppsfreq   int64
	Fjitter    int64
	Fshift     int32
	Fstabil    int64
	Fjitcnt    int64
	Fcalcnt    int64
	Ferrcnt    int64
	Fstbcnt    int64
	Ftai       int32
	F__padding [11]int32
}

func Xadjtime(tls *TLS, in uintptr, out uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v in=%v out=%v, (%v:)", tls, in, out, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(208)
	defer tls.Free(208)
	var v1 Tsuseconds_t
	var _ /* tx at bp+0 */ Ttimex
	_ = v1
	*(*Ttimex)(unsafe.Pointer(bp)) = Ttimex{}
	if in != 0 {
		if (*Ttimeval)(unsafe.Pointer(in)).Ftv_sec > int64(1000) || (*Ttimeval)(unsafe.Pointer(in)).Ftv_usec > int64(1000000000) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
			return -int32(1)
		}
		(*(*Ttimex)(unsafe.Pointer(bp))).Foffset = (*Ttimeval)(unsafe.Pointer(in)).Ftv_sec*int64(1000000) + (*Ttimeval)(unsafe.Pointer(in)).Ftv_usec
		(*(*Ttimex)(unsafe.Pointer(bp))).Fmodes = uint32(ADJ_OFFSET_SINGLESHOT)
	}
	if Xadjtimex(tls, bp) < 0 {
		return -int32(1)
	}
	if out != 0 {
		(*Ttimeval)(unsafe.Pointer(out)).Ftv_sec = (*(*Ttimex)(unsafe.Pointer(bp))).Foffset / int64(1000000)
		v1 = (*(*Ttimex)(unsafe.Pointer(bp))).Foffset % Int64FromInt32(1000000)
		(*Ttimeval)(unsafe.Pointer(out)).Ftv_usec = v1
		if v1 < 0 {
			(*Ttimeval)(unsafe.Pointer(out)).Ftv_sec--
			*(*Tsuseconds_t)(unsafe.Pointer(out + 8)) += int64(1000000)
		}
	}
	return 0
}

func Xadjtimex(tls *TLS, tx uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v tx=%v, (%v:)", tls, tx, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xclock_adjtime(tls, CLOCK_REALTIME, tx)
}

func Xbrk(tls *TLS, end uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v end=%v, (%v:)", tls, end, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(ENOMEM))))
}

func Xcapset(tls *TLS, a uintptr, b uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v b=%v, (%v:)", tls, a, b, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_capset), int64(a), int64(b)))))
}

func Xcapget(tls *TLS, a uintptr, b uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v b=%v, (%v:)", tls, a, b, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_capget), int64(a), int64(b)))))
}

func Xchroot(tls *TLS, path uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v, (%v:)", tls, path, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_chroot), int64(path)))))
}

type Tktimex64 = struct {
	Fmodes     uint32
	F__ccgo4   uint32
	Foffset    int64
	Ffreq      int64
	Fmaxerror  int64
	Festerror  int64
	Fstatus    int32
	F__ccgo44  uint32
	Fconstant  int64
	Fprecision int64
	Ftolerance int64
	Ftime_sec  int64
	Ftime_usec int64
	Ftick      int64
	Fppsfreq   int64
	Fjitter    int64
	Fshift     int32
	F__ccgo116 uint32
	Fstabil    int64
	Fjitcnt    int64
	Fcalcnt    int64
	Ferrcnt    int64
	Fstbcnt    int64
	Ftai       int32
	F__padding [11]int32
}

type Tktimex = struct {
	Fmodes     uint32
	Foffset    int64
	Ffreq      int64
	Fmaxerror  int64
	Festerror  int64
	Fstatus    int32
	Fconstant  int64
	Fprecision int64
	Ftolerance int64
	Ftime_sec  int64
	Ftime_usec int64
	Ftick      int64
	Fppsfreq   int64
	Fjitter    int64
	Fshift     int32
	Fstabil    int64
	Fjitcnt    int64
	Fcalcnt    int64
	Ferrcnt    int64
	Fstbcnt    int64
	Ftai       int32
	F__padding [11]int32
}

func Xclock_adjtime(tls *TLS, clock_id Tclockid_t, utx uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v clock_id=%v utx=%v, (%v:)", tls, clock_id, utx, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(208)
	defer tls.Free(208)
	var r int32
	var _ /* ktx at bp+0 */ Tktimex
	_ = r
	r = -int32(ENOSYS)
	if uint64(8) > uint64(8) {
		*(*Tktimex)(unsafe.Pointer(bp)) = Tktimex{
			Fmodes:     (*Ttimex)(unsafe.Pointer(utx)).Fmodes,
			Foffset:    (*Ttimex)(unsafe.Pointer(utx)).Foffset,
			Ffreq:      (*Ttimex)(unsafe.Pointer(utx)).Ffreq,
			Fmaxerror:  (*Ttimex)(unsafe.Pointer(utx)).Fmaxerror,
			Festerror:  (*Ttimex)(unsafe.Pointer(utx)).Festerror,
			Fstatus:    (*Ttimex)(unsafe.Pointer(utx)).Fstatus,
			Fconstant:  (*Ttimex)(unsafe.Pointer(utx)).Fconstant,
			Fprecision: (*Ttimex)(unsafe.Pointer(utx)).Fprecision,
			Ftolerance: (*Ttimex)(unsafe.Pointer(utx)).Ftolerance,
			Ftime_sec:  (*Ttimex)(unsafe.Pointer(utx)).Ftime.Ftv_sec,
			Ftime_usec: (*Ttimex)(unsafe.Pointer(utx)).Ftime.Ftv_usec,
			Ftick:      (*Ttimex)(unsafe.Pointer(utx)).Ftick,
			Fppsfreq:   (*Ttimex)(unsafe.Pointer(utx)).Fppsfreq,
			Fjitter:    (*Ttimex)(unsafe.Pointer(utx)).Fjitter,
			Fshift:     (*Ttimex)(unsafe.Pointer(utx)).Fshift,
			Fstabil:    (*Ttimex)(unsafe.Pointer(utx)).Fstabil,
			Fjitcnt:    (*Ttimex)(unsafe.Pointer(utx)).Fjitcnt,
			Fcalcnt:    (*Ttimex)(unsafe.Pointer(utx)).Fcalcnt,
			Ferrcnt:    (*Ttimex)(unsafe.Pointer(utx)).Ferrcnt,
			Fstbcnt:    (*Ttimex)(unsafe.Pointer(utx)).Fstbcnt,
			Ftai:       (*Ttimex)(unsafe.Pointer(utx)).Ftai,
		}
		if clock_id == CLOCK_REALTIME {
			r = int32(X__syscall1(tls, int64(SYS_adjtimex), int64(bp)))
		} else {
			r = int32(X__syscall2(tls, int64(SYS_clock_adjtime), int64(clock_id), int64(bp)))
		}
		if r >= 0 {
			(*Ttimex)(unsafe.Pointer(utx)).Fmodes = (*(*Tktimex)(unsafe.Pointer(bp))).Fmodes
			(*Ttimex)(unsafe.Pointer(utx)).Foffset = (*(*Tktimex)(unsafe.Pointer(bp))).Foffset
			(*Ttimex)(unsafe.Pointer(utx)).Ffreq = (*(*Tktimex)(unsafe.Pointer(bp))).Ffreq
			(*Ttimex)(unsafe.Pointer(utx)).Fmaxerror = (*(*Tktimex)(unsafe.Pointer(bp))).Fmaxerror
			(*Ttimex)(unsafe.Pointer(utx)).Festerror = (*(*Tktimex)(unsafe.Pointer(bp))).Festerror
			(*Ttimex)(unsafe.Pointer(utx)).Fstatus = (*(*Tktimex)(unsafe.Pointer(bp))).Fstatus
			(*Ttimex)(unsafe.Pointer(utx)).Fconstant = (*(*Tktimex)(unsafe.Pointer(bp))).Fconstant
			(*Ttimex)(unsafe.Pointer(utx)).Fprecision = (*(*Tktimex)(unsafe.Pointer(bp))).Fprecision
			(*Ttimex)(unsafe.Pointer(utx)).Ftolerance = (*(*Tktimex)(unsafe.Pointer(bp))).Ftolerance
			(*Ttimex)(unsafe.Pointer(utx)).Ftime.Ftv_sec = (*(*Tktimex)(unsafe.Pointer(bp))).Ftime_sec
			(*Ttimex)(unsafe.Pointer(utx)).Ftime.Ftv_usec = (*(*Tktimex)(unsafe.Pointer(bp))).Ftime_usec
			(*Ttimex)(unsafe.Pointer(utx)).Ftick = (*(*Tktimex)(unsafe.Pointer(bp))).Ftick
			(*Ttimex)(unsafe.Pointer(utx)).Fppsfreq = (*(*Tktimex)(unsafe.Pointer(bp))).Fppsfreq
			(*Ttimex)(unsafe.Pointer(utx)).Fjitter = (*(*Tktimex)(unsafe.Pointer(bp))).Fjitter
			(*Ttimex)(unsafe.Pointer(utx)).Fshift = (*(*Tktimex)(unsafe.Pointer(bp))).Fshift
			(*Ttimex)(unsafe.Pointer(utx)).Fstabil = (*(*Tktimex)(unsafe.Pointer(bp))).Fstabil
			(*Ttimex)(unsafe.Pointer(utx)).Fjitcnt = (*(*Tktimex)(unsafe.Pointer(bp))).Fjitcnt
			(*Ttimex)(unsafe.Pointer(utx)).Fcalcnt = (*(*Tktimex)(unsafe.Pointer(bp))).Fcalcnt
			(*Ttimex)(unsafe.Pointer(utx)).Ferrcnt = (*(*Tktimex)(unsafe.Pointer(bp))).Ferrcnt
			(*Ttimex)(unsafe.Pointer(utx)).Fstbcnt = (*(*Tktimex)(unsafe.Pointer(bp))).Fstbcnt
			(*Ttimex)(unsafe.Pointer(utx)).Ftai = (*(*Tktimex)(unsafe.Pointer(bp))).Ftai
		}
		return int32(X__syscall_ret(tls, uint64(r)))
	}
	if clock_id == CLOCK_REALTIME {
		return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_adjtimex), int64(utx)))))
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_clock_adjtime), int64(clock_id), int64(utx)))))
}

func Xcopy_file_range(tls *TLS, fd_in int32, off_in uintptr, fd_out int32, off_out uintptr, len1 Tsize_t, flags uint32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd_in=%v off_in=%v fd_out=%v off_out=%v len1=%v flags=%v, (%v:)", tls, fd_in, off_in, fd_out, off_out, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall6(tls, int64(SYS_copy_file_range), int64(fd_in), int64(off_in), int64(fd_out), int64(off_out), int64(len1), int64(flags))))
}

const EPOLLERR = 8
const EPOLLET = 2147483648
const EPOLLEXCLUSIVE = 268435456
const EPOLLHUP = 16
const EPOLLIN = 1
const EPOLLMSG = 1024
const EPOLLNVAL = 32
const EPOLLONESHOT = 1073741824
const EPOLLOUT = 4
const EPOLLPRI = 2
const EPOLLRDBAND = 128
const EPOLLRDHUP = 8192
const EPOLLRDNORM = 64
const EPOLLWAKEUP = 536870912
const EPOLLWRBAND = 512
const EPOLLWRNORM = 256
const EPOLL_CLOEXEC = 524288
const EPOLL_CTL_ADD = 1
const EPOLL_CTL_DEL = 2
const EPOLL_CTL_MOD = 3
const EPOLL_NONBLOCK = 2048

type Tfsblkcnt_t = uint64

type Tfsfilcnt_t = uint64

type _EPOLL_EVENTS = int32

const ___EPOLL_DUMMY = 0

type Tepoll_data_t = struct {
	Ffd  [0]int32
	Fu32 [0]Tuint32_t
	Fu64 [0]Tuint64_t
	Fptr uintptr
}

type Tepoll_data = Tepoll_data_t

type Tepoll_event = struct {
	Fevents Tuint32_t
	Fdata   Tepoll_data_t
}

func Xepoll_create(tls *TLS, size int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v size=%v, (%v:)", tls, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if size <= 0 {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
	}
	return Xepoll_create1(tls, 0)
}

func Xepoll_create1(tls *TLS, flags int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v flags=%v, (%v:)", tls, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = int32(X__syscall1(tls, int64(SYS_epoll_create1), int64(flags)))
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xepoll_ctl(tls *TLS, fd int32, op int32, fd2 int32, ev uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v op=%v fd2=%v ev=%v, (%v:)", tls, fd, op, fd2, ev, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_epoll_ctl), int64(fd), int64(op), int64(fd2), int64(ev)))))
}

func Xepoll_pwait(tls *TLS, fd int32, ev uintptr, cnt int32, to int32, sigs uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v ev=%v cnt=%v to=%v sigs=%v, (%v:)", tls, fd, ev, cnt, to, sigs, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = int32(___syscall_cp(tls, int64(SYS_epoll_pwait), int64(fd), int64(ev), int64(cnt), int64(to), int64(sigs), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8))))
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xepoll_wait(tls *TLS, fd int32, ev uintptr, cnt int32, to int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v ev=%v cnt=%v to=%v, (%v:)", tls, fd, ev, cnt, to, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xepoll_pwait(tls, fd, ev, cnt, to, uintptr(0))
}

const EFD_CLOEXEC = 524288
const EFD_NONBLOCK = 2048
const EFD_SEMAPHORE = 1

type Teventfd_t = uint64

func Xeventfd(tls *TLS, count uint32, flags int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v count=%v flags=%v, (%v:)", tls, count, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = int32(X__syscall2(tls, int64(SYS_eventfd2), int64(count), int64(flags)))
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xeventfd_read(tls *TLS, fd int32, value uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v value=%v, (%v:)", tls, fd, value, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	_ = v1
	if uint64(8) == uint64(Xread(tls, fd, value, uint64(8))) {
		v1 = 0
	} else {
		v1 = -int32(1)
	}
	return v1
}

func Xeventfd_write(tls *TLS, fd int32, _value Teventfd_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v _value=%v, (%v:)", tls, fd, _value, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Teventfd_t)(unsafe.Pointer(bp)) = _value
	var v1 int32
	_ = v1
	if uint64(8) == uint64(Xwrite(tls, fd, bp, uint64(8))) {
		v1 = 0
	} else {
		v1 = -int32(1)
	}
	return v1
}

func Xfallocate(tls *TLS, fd int32, mode int32, base Toff_t, len1 Toff_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v mode=%v base=%v len1=%v, (%v:)", tls, fd, mode, base, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_fallocate), int64(fd), int64(mode), base, len1))))
}

const FANOTIFY_METADATA_VERSION = 3
const FAN_ACCESS = 1
const FAN_ACCESS_PERM = 131072
const FAN_ALLOW = 1
const FAN_ALL_CLASS_BITS = 12
const FAN_ALL_EVENTS = 59
const FAN_ALL_INIT_FLAGS = 63
const FAN_ALL_MARK_FLAGS = 255
const FAN_ALL_OUTGOING_EVENTS = 213051
const FAN_ALL_PERM_EVENTS = 196608
const FAN_ATTRIB = 4
const FAN_AUDIT = 16
const FAN_CLASS_CONTENT = 4
const FAN_CLASS_NOTIF = 0
const FAN_CLASS_PRE_CONTENT = 8
const FAN_CLOEXEC = 1
const FAN_CLOSE = 24
const FAN_CLOSE_NOWRITE = 16
const FAN_CLOSE_WRITE = 8
const FAN_CREATE = 256
const FAN_DELETE = 512
const FAN_DELETE_SELF = 1024
const FAN_DENY = 2
const FAN_DIR_MODIFY = 524288
const FAN_ENABLE_AUDIT = 64
const FAN_EVENT_INFO_TYPE_DFID = 3
const FAN_EVENT_INFO_TYPE_DFID_NAME = 2
const FAN_EVENT_INFO_TYPE_FID = 1
const FAN_EVENT_METADATA_LEN = 0
const FAN_EVENT_ON_CHILD = 134217728
const FAN_MARK_ADD = 1
const FAN_MARK_DONT_FOLLOW = 4
const FAN_MARK_FILESYSTEM = 256
const FAN_MARK_FLUSH = 128
const FAN_MARK_IGNORED_MASK = 32
const FAN_MARK_IGNORED_SURV_MODIFY = 64
const FAN_MARK_INODE = 0
const FAN_MARK_MOUNT = 16
const FAN_MARK_ONLYDIR = 8
const FAN_MARK_REMOVE = 2
const FAN_MARK_TYPE_MASK = 272
const FAN_MODIFY = 2
const FAN_MOVE = 192
const FAN_MOVED_FROM = 64
const FAN_MOVED_TO = 128
const FAN_MOVE_SELF = 2048
const FAN_NOFD = -1
const FAN_NONBLOCK = 2
const FAN_ONDIR = 1073741824
const FAN_OPEN = 32
const FAN_OPEN_EXEC = 4096
const FAN_OPEN_EXEC_PERM = 262144
const FAN_OPEN_PERM = 65536
const FAN_Q_OVERFLOW = 16384
const FAN_REPORT_DFID_NAME = 3072
const FAN_REPORT_DIR_FID = 1024
const FAN_REPORT_FID = 512
const FAN_REPORT_NAME = 2048
const FAN_REPORT_TID = 256
const FAN_UNLIMITED_MARKS = 32
const FAN_UNLIMITED_QUEUE = 16
const ST_APPEND = 256
const ST_IMMUTABLE = 512
const ST_MANDLOCK = 64
const ST_NOATIME = 1024
const ST_NODEV = 4
const ST_NODIRATIME = 2048
const ST_NOEXEC = 8
const ST_NOSUID = 2
const ST_RDONLY = 1
const ST_RELATIME = 4096
const ST_SYNCHRONOUS = 16
const ST_WRITE = 128

type Tstatvfs = struct {
	Ff_bsize    uint64
	Ff_frsize   uint64
	Ff_blocks   Tfsblkcnt_t
	Ff_bfree    Tfsblkcnt_t
	Ff_bavail   Tfsblkcnt_t
	Ff_files    Tfsfilcnt_t
	Ff_ffree    Tfsfilcnt_t
	Ff_favail   Tfsfilcnt_t
	Ff_fsid     uint64
	Ff_flag     uint64
	Ff_namemax  uint64
	Ff_type     uint32
	F__reserved [5]int32
}

type Tfsid_t = struct {
	F__val [2]int32
}

type t__fsid_t = Tfsid_t

type Tstatfs = struct {
	Ff_type    uint64
	Ff_bsize   uint64
	Ff_blocks  Tfsblkcnt_t
	Ff_bfree   Tfsblkcnt_t
	Ff_bavail  Tfsblkcnt_t
	Ff_files   Tfsfilcnt_t
	Ff_ffree   Tfsfilcnt_t
	Ff_fsid    Tfsid_t
	Ff_namelen uint64
	Ff_frsize  uint64
	Ff_flags   uint64
	Ff_spare   [4]uint64
}

type Tfanotify_event_metadata = struct {
	Fevent_len    uint32
	Fvers         uint8
	Freserved     uint8
	Fmetadata_len uint16
	Fmask         uint64
	Ffd           int32
	Fpid          int32
}

type Tfanotify_event_info_header = struct {
	Finfo_type uint8
	Fpad       uint8
	Flen1      uint16
}

type Tfanotify_event_info_fid = struct {
	Fhdr  Tfanotify_event_info_header
	Ffsid Tfsid_t
}

type Tfanotify_response = struct {
	Ffd       int32
	Fresponse uint32
}

func Xfanotify_init(tls *TLS, flags uint32, event_f_flags uint32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v flags=%v event_f_flags=%v, (%v:)", tls, flags, event_f_flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_fanotify_init), int64(flags), int64(event_f_flags)))))
}

func Xfanotify_mark(tls *TLS, fanotify_fd int32, flags uint32, mask uint64, dfd int32, pathname uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fanotify_fd=%v flags=%v mask=%v dfd=%v pathname=%v, (%v:)", tls, fanotify_fd, flags, mask, dfd, pathname, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_fanotify_mark), int64(fanotify_fd), int64(flags), int64(mask), int64(dfd), int64(pathname)))))
}

const LOCK_EX = 2
const LOCK_NB = 4
const LOCK_SH = 1
const LOCK_UN = 8

func Xflock(tls *TLS, fd int32, op int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v op=%v, (%v:)", tls, fd, op, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_flock), int64(fd), int64(op)))))
}

func Xgetdents(tls *TLS, fd int32, buf uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v len1=%v, (%v:)", tls, fd, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if len1 > uint64(INT_MAX) {
		len1 = uint64(INT_MAX)
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_getdents64), int64(fd), int64(buf), int64(len1)))))
}

const GRND_INSECURE = 4
const GRND_NONBLOCK = 1
const GRND_RANDOM = 2

func Xgetrandom(tls *TLS, buf uintptr, buflen Tsize_t, flags uint32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v buf=%v buflen=%v flags=%v, (%v:)", tls, buf, buflen, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_getrandom), int64(buf), int64(buflen), int64(flags), 0, 0, 0)))
}

const IN_ACCESS = 1
const IN_ALL_EVENTS = 4095
const IN_ATTRIB = 4
const IN_CLOEXEC = 524288
const IN_CLOSE = 24
const IN_CLOSE_NOWRITE = 16
const IN_CLOSE_WRITE = 8
const IN_CREATE = 256
const IN_DELETE = 512
const IN_DELETE_SELF = 1024
const IN_DONT_FOLLOW = 33554432
const IN_EXCL_UNLINK = 67108864
const IN_IGNORED = 32768
const IN_ISDIR = 1073741824
const IN_MASK_ADD = 536870912
const IN_MASK_CREATE = 268435456
const IN_MODIFY = 2
const IN_MOVE = 192
const IN_MOVED_FROM = 64
const IN_MOVED_TO = 128
const IN_MOVE_SELF = 2048
const IN_NONBLOCK = 2048
const IN_ONESHOT = 2147483648
const IN_ONLYDIR = 16777216
const IN_OPEN = 32
const IN_Q_OVERFLOW = 16384
const IN_UNMOUNT = 8192

type Tinotify_event = struct {
	Fwd     int32
	Fmask   Tuint32_t
	Fcookie Tuint32_t
	Flen1   Tuint32_t
}

func Xinotify_init(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xinotify_init1(tls, 0)
}

func Xinotify_init1(tls *TLS, flags int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v flags=%v, (%v:)", tls, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = int32(X__syscall1(tls, int64(SYS_inotify_init1), int64(flags)))
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xinotify_add_watch(tls *TLS, fd int32, pathname uintptr, mask Tuint32_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v pathname=%v mask=%v, (%v:)", tls, fd, pathname, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_inotify_add_watch), int64(fd), int64(pathname), int64(mask)))))
}

func Xinotify_rm_watch(tls *TLS, fd int32, wd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v wd=%v, (%v:)", tls, fd, wd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_inotify_rm_watch), int64(fd), int64(wd)))))
}

func Xklogctl(tls *TLS, type1 int32, buf uintptr, len1 int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v type1=%v buf=%v len1=%v, (%v:)", tls, type1, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_syslog), int64(type1), int64(buf), int64(len1)))))
}

const MADV_COLD = 20
const MADV_DODUMP = 17
const MADV_DOFORK = 11
const MADV_DONTDUMP = 16
const MADV_DONTFORK = 10
const MADV_DONTNEED = 4
const MADV_FREE = 8
const MADV_HUGEPAGE = 14
const MADV_HWPOISON = 100
const MADV_KEEPONFORK = 19
const MADV_MERGEABLE = 12
const MADV_NOHUGEPAGE = 15
const MADV_NORMAL = 0
const MADV_PAGEOUT = 21
const MADV_RANDOM = 1
const MADV_REMOVE = 9
const MADV_SEQUENTIAL = 2
const MADV_SOFT_OFFLINE = 101
const MADV_UNMERGEABLE = 13
const MADV_WILLNEED = 3
const MADV_WIPEONFORK = 18
const MFD_ALLOW_SEALING = 2
const MFD_CLOEXEC = 1
const MFD_HUGETLB = 4
const MLOCK_ONFAULT = 1
const MREMAP_DONTUNMAP = 4
const MREMAP_FIXED = 2
const MREMAP_MAYMOVE = 1
const _GNU_SOURCE = 1

func Xmemfd_create(tls *TLS, name uintptr, flags uint32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v flags=%v, (%v:)", tls, name, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_memfd_create), int64(name), int64(flags)))))
}

func Xmlock2(tls *TLS, addr uintptr, len1 Tsize_t, flags uint32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v flags=%v, (%v:)", tls, addr, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if flags == uint32(0) {
		return Xmlock(tls, addr, len1)
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_mlock2), int64(addr), int64(len1), int64(flags)))))
}

func Xinit_module(tls *TLS, a uintptr, b uint64, c uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v b=%v c=%v, (%v:)", tls, a, b, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_init_module), int64(a), int64(b), int64(c)))))
}

func Xdelete_module(tls *TLS, a uintptr, b uint32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v b=%v, (%v:)", tls, a, b, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_delete_module), int64(a), int64(b)))))
}

const BLKBSZGET = 2147488368
const BLKBSZSET = 1073746545
const BLKFLSBUF = 4705
const BLKFRAGET = 4709
const BLKFRASET = 4708
const BLKGETSIZE = 4704
const BLKGETSIZE64 = 2147488370
const BLKRAGET = 4707
const BLKRASET = 4706
const BLKROGET = 4702
const BLKROSET = 4701
const BLKRRPART = 4703
const BLKSECTGET = 4711
const BLKSECTSET = 4710
const BLKSSZGET = 4712
const FIOASYNC = 21586
const FIOCLEX = 21585
const FIOGETOWN = 35075
const FIONBIO = 21537
const FIONCLEX = 21584
const FIONREAD = 21531
const FIOQSIZE = 21600
const FIOSETOWN = 35073
const MNT_DETACH = 2
const MNT_EXPIRE = 4
const MNT_FORCE = 1
const MS_ACTIVE = 1073741824
const MS_BIND = 4096
const MS_BORN = 536870912
const MS_DIRSYNC = 128
const MS_I_VERSION = 8388608
const MS_KERNMOUNT = 4194304
const MS_LAZYTIME = 33554432
const MS_MANDLOCK = 64
const MS_MGC_MSK = 4294901760
const MS_MGC_VAL = 3236757504
const MS_MOVE = 8192
const MS_NOATIME = 1024
const MS_NODEV = 4
const MS_NODIRATIME = 2048
const MS_NOEXEC = 8
const MS_NOREMOTELOCK = 134217728
const MS_NOSEC = 268435456
const MS_NOSUID = 2
const MS_NOSYMFOLLOW = 256
const MS_NOUSER = 2147483648
const MS_POSIXACL = 65536
const MS_PRIVATE = 262144
const MS_RDONLY = 1
const MS_REC = 16384
const MS_RELATIME = 2097152
const MS_REMOUNT = 32
const MS_RMT_MASK = 41943121
const MS_SHARED = 1048576
const MS_SILENT = 32768
const MS_SLAVE = 524288
const MS_STRICTATIME = 16777216
const MS_SYNCHRONOUS = 16
const MS_UNBINDABLE = 131072
const N_6PACK = 7
const N_AX25 = 5
const N_CAIF = 20
const N_GIGASET_M101 = 16
const N_GSM0710 = 21
const N_HCI = 15
const N_HDLC = 13
const N_IRDA = 11
const N_MASC = 8
const N_MOUSE = 2
const N_NCI = 25
const N_NULL = 27
const N_PPP = 3
const N_PPS = 18
const N_PROFIBUS_FDL = 10
const N_R3964 = 9
const N_SLCAN = 17
const N_SLIP = 1
const N_SMSBLOCK = 12
const N_SPEAKUP = 26
const N_STRIP = 4
const N_SYNC_PPP = 14
const N_TI_WL = 22
const N_TRACEROUTER = 24
const N_TRACESINK = 23
const N_TTY = 0
const N_V253 = 19
const N_X25 = 6
const SIOCADDDLCI = 35200
const SIOCADDMULTI = 35121
const SIOCADDRT = 35083
const SIOCATMARK = 35077
const SIOCDARP = 35155
const SIOCDELDLCI = 35201
const SIOCDELMULTI = 35122
const SIOCDELRT = 35084
const SIOCDEVPRIVATE = 35312
const SIOCDIFADDR = 35126
const SIOCDRARP = 35168
const SIOCGARP = 35156
const SIOCGIFADDR = 35093
const SIOCGIFBR = 35136
const SIOCGIFBRDADDR = 35097
const SIOCGIFCONF = 35090
const SIOCGIFCOUNT = 35128
const SIOCGIFDSTADDR = 35095
const SIOCGIFENCAP = 35109
const SIOCGIFFLAGS = 35091
const SIOCGIFHWADDR = 35111
const SIOCGIFINDEX = 35123
const SIOCGIFMAP = 35184
const SIOCGIFMEM = 35103
const SIOCGIFMETRIC = 35101
const SIOCGIFMTU = 35105
const SIOCGIFNAME = 35088
const SIOCGIFNETMASK = 35099
const SIOCGIFPFLAGS = 35125
const SIOCGIFSLAVE = 35113
const SIOCGIFTXQLEN = 35138
const SIOCGPGRP = 35076
const SIOCGRARP = 35169
const SIOCGSTAMP = 35078
const SIOCGSTAMPNS = 35079
const SIOCPROTOPRIVATE = 35296
const SIOCRTMSG = 35085
const SIOCSARP = 35157
const SIOCSIFADDR = 35094
const SIOCSIFBR = 35137
const SIOCSIFBRDADDR = 35098
const SIOCSIFDSTADDR = 35096
const SIOCSIFENCAP = 35110
const SIOCSIFFLAGS = 35092
const SIOCSIFHWADDR = 35108
const SIOCSIFHWBROADCAST = 35127
const SIOCSIFLINK = 35089
const SIOCSIFMAP = 35185
const SIOCSIFMEM = 35104
const SIOCSIFMETRIC = 35102
const SIOCSIFMTU = 35106
const SIOCSIFNAME = 35107
const SIOCSIFNETMASK = 35100
const SIOCSIFPFLAGS = 35124
const SIOCSIFSLAVE = 35120
const SIOCSIFTXQLEN = 35139
const SIOCSPGRP = 35074
const SIOCSRARP = 35170
const SIOGIFINDEX = 35123
const TCFLSH = 21515
const TCGETA = 21509
const TCGETS = 21505
const TCGETX = 21554
const TCSBRK = 21513
const TCSBRKP = 21541
const TCSETA = 21510
const TCSETAF = 21512
const TCSETAW = 21511
const TCSETS = 21506
const TCSETSF = 21508
const TCSETSW = 21507
const TCSETX = 21555
const TCSETXF = 21556
const TCSETXW = 21557
const TCXONC = 21514
const TIOCCBRK = 21544
const TIOCCONS = 21533
const TIOCEXCL = 21516
const TIOCGDEV = 2147767346
const TIOCGETD = 21540
const TIOCGEXCL = 2147767360
const TIOCGICOUNT = 21597
const TIOCGISO7816 = 2150126658
const TIOCGLCKTRMIOS = 21590
const TIOCGPGRP = 21519
const TIOCGPKT = 2147767352
const TIOCGPTLCK = 2147767353
const TIOCGPTN = 2147767344
const TIOCGPTPEER = 21569
const TIOCGRS485 = 21550
const TIOCGSERIAL = 21534
const TIOCGSID = 21545
const TIOCGSOFTCAR = 21529
const TIOCGWINSZ = 21523
const TIOCINQ = 21531
const TIOCLINUX = 21532
const TIOCMBIC = 21527
const TIOCMBIS = 21526
const TIOCMGET = 21525
const TIOCMIWAIT = 21596
const TIOCMSET = 21528
const TIOCM_CAR = 64
const TIOCM_CD = 64
const TIOCM_CTS = 32
const TIOCM_DSR = 256
const TIOCM_DTR = 2
const TIOCM_LE = 1
const TIOCM_LOOP = 32768
const TIOCM_OUT1 = 8192
const TIOCM_OUT2 = 16384
const TIOCM_RI = 128
const TIOCM_RNG = 128
const TIOCM_RTS = 4
const TIOCM_SR = 16
const TIOCM_ST = 8
const TIOCNOTTY = 21538
const TIOCNXCL = 21517
const TIOCOUTQ = 21521
const TIOCPKT = 21536
const TIOCPKT_DATA = 0
const TIOCPKT_DOSTOP = 32
const TIOCPKT_FLUSHREAD = 1
const TIOCPKT_FLUSHWRITE = 2
const TIOCPKT_IOCTL = 64
const TIOCPKT_NOSTOP = 16
const TIOCPKT_START = 8
const TIOCPKT_STOP = 4
const TIOCSBRK = 21543
const TIOCSCTTY = 21518
const TIOCSERCONFIG = 21587
const TIOCSERGETLSR = 21593
const TIOCSERGETMULTI = 21594
const TIOCSERGSTRUCT = 21592
const TIOCSERGWILD = 21588
const TIOCSERSETMULTI = 21595
const TIOCSERSWILD = 21589
const TIOCSER_TEMT = 1
const TIOCSETD = 21539
const TIOCSIG = 1074025526
const TIOCSISO7816 = 3223868483
const TIOCSLCKTRMIOS = 21591
const TIOCSPGRP = 21520
const TIOCSPTLCK = 1074025521
const TIOCSRS485 = 21551
const TIOCSSERIAL = 21535
const TIOCSSOFTCAR = 21530
const TIOCSTI = 21522
const TIOCSWINSZ = 21524
const TIOCVHANGUP = 21559
const UMOUNT_NOFOLLOW = 8
const _IOC_NONE = 0
const _IOC_READ = 2
const _IOC_WRITE = 1

func Xmount(tls *TLS, special uintptr, dir uintptr, fstype uintptr, flags uint64, data uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v special=%v dir=%v fstype=%v flags=%v data=%v, (%v:)", tls, special, dir, fstype, flags, data, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_mount), int64(special), int64(dir), int64(fstype), int64(flags), int64(data)))))
}

func Xumount(tls *TLS, special uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v special=%v, (%v:)", tls, special, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_umount2), int64(special), int64(Int32FromInt32(0))))))
}

func Xumount2(tls *TLS, special uintptr, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v special=%v flags=%v, (%v:)", tls, special, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_umount2), int64(special), int64(flags)))))
}

func Xname_to_handle_at(tls *TLS, dirfd int32, pathname uintptr, handle uintptr, mount_id uintptr, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v dirfd=%v pathname=%v handle=%v mount_id=%v flags=%v, (%v:)", tls, dirfd, pathname, handle, mount_id, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_name_to_handle_at), int64(dirfd), int64(pathname), int64(handle), int64(mount_id), int64(flags)))))
}

func Xopen_by_handle_at(tls *TLS, mount_fd int32, handle uintptr, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mount_fd=%v handle=%v flags=%v, (%v:)", tls, mount_fd, handle, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_open_by_handle_at), int64(mount_fd), int64(handle), int64(flags)))))
}

const ADDR_COMPAT_LAYOUT = 2097152
const ADDR_LIMIT_32BIT = 8388608
const ADDR_LIMIT_3GB = 134217728
const ADDR_NO_RANDOMIZE = 262144
const FDPIC_FUNCPTRS = 524288
const MMAP_PAGE_ZERO = 1048576
const PER_BSD = 6
const PER_HPUX = 16
const PER_IRIX32 = 67108873
const PER_IRIX64 = 67108875
const PER_IRIXN32 = 67108874
const PER_ISCR4 = 67108869
const PER_LINUX = 0
const PER_LINUX32 = 8
const PER_LINUX32_3GB = 134217736
const PER_LINUX_32BIT = 8388608
const PER_LINUX_FDPIC = 524288
const PER_MASK = 255
const PER_OSF4 = 15
const PER_OSR5 = 100663299
const PER_RISCOS = 12
const PER_SCOSVR3 = 117440515
const PER_SOLARIS = 67108877
const PER_SUNOS = 67108870
const PER_SVR3 = 83886082
const PER_SVR4 = 68157441
const PER_UW7 = 68157454
const PER_WYSEV386 = 83886084
const PER_XENIX = 83886087
const READ_IMPLIES_EXEC = 4194304
const SHORT_INODE = 16777216
const STICKY_TIMEOUTS = 67108864
const UNAME26 = 131072
const WHOLE_SECONDS = 33554432

func Xpersonality(tls *TLS, persona uint64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v persona=%v, (%v:)", tls, persona, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_personality), int64(persona)))))
}

func Xpivot_root(tls *TLS, new1 uintptr, old uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v new1=%v old=%v, (%v:)", tls, new1, old, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_pivot_root), int64(new1), int64(old)))))
}

const PR_CAPBSET_DROP = 24
const PR_CAPBSET_READ = 23
const PR_CAP_AMBIENT = 47
const PR_CAP_AMBIENT_CLEAR_ALL = 4
const PR_CAP_AMBIENT_IS_SET = 1
const PR_CAP_AMBIENT_LOWER = 3
const PR_CAP_AMBIENT_RAISE = 2
const PR_ENDIAN_BIG = 0
const PR_ENDIAN_LITTLE = 1
const PR_ENDIAN_PPC_LITTLE = 2
const PR_FPEMU_NOPRINT = 1
const PR_FPEMU_SIGFPE = 2
const PR_FP_EXC_ASYNC = 2
const PR_FP_EXC_DISABLED = 0
const PR_FP_EXC_DIV = 65536
const PR_FP_EXC_INV = 1048576
const PR_FP_EXC_NONRECOV = 1
const PR_FP_EXC_OVF = 131072
const PR_FP_EXC_PRECISE = 3
const PR_FP_EXC_RES = 524288
const PR_FP_EXC_SW_ENABLE = 128
const PR_FP_EXC_UND = 262144
const PR_FP_MODE_FR = 1
const PR_FP_MODE_FRE = 2
const PR_GET_CHILD_SUBREAPER = 37
const PR_GET_DUMPABLE = 3
const PR_GET_ENDIAN = 19
const PR_GET_FPEMU = 9
const PR_GET_FPEXC = 11
const PR_GET_FP_MODE = 46
const PR_GET_IO_FLUSHER = 58
const PR_GET_KEEPCAPS = 7
const PR_GET_NAME = 16
const PR_GET_NO_NEW_PRIVS = 39
const PR_GET_PDEATHSIG = 2
const PR_GET_SECCOMP = 21
const PR_GET_SECUREBITS = 27
const PR_GET_SPECULATION_CTRL = 52
const PR_GET_TAGGED_ADDR_CTRL = 56
const PR_GET_THP_DISABLE = 42
const PR_GET_TID_ADDRESS = 40
const PR_GET_TIMERSLACK = 30
const PR_GET_TIMING = 13
const PR_GET_TSC = 25
const PR_GET_UNALIGN = 5
const PR_MCE_KILL = 33
const PR_MCE_KILL_CLEAR = 0
const PR_MCE_KILL_DEFAULT = 2
const PR_MCE_KILL_EARLY = 1
const PR_MCE_KILL_GET = 34
const PR_MCE_KILL_LATE = 0
const PR_MCE_KILL_SET = 1
const PR_MPX_DISABLE_MANAGEMENT = 44
const PR_MPX_ENABLE_MANAGEMENT = 43
const PR_MTE_TAG_MASK = 524280
const PR_MTE_TAG_SHIFT = 3
const PR_MTE_TCF_ASYNC = 4
const PR_MTE_TCF_MASK = 6
const PR_MTE_TCF_NONE = 0
const PR_MTE_TCF_SHIFT = 1
const PR_MTE_TCF_SYNC = 2
const PR_PAC_APDAKEY = 4
const PR_PAC_APDBKEY = 8
const PR_PAC_APGAKEY = 16
const PR_PAC_APIAKEY = 1
const PR_PAC_APIBKEY = 2
const PR_PAC_GET_ENABLED_KEYS = 61
const PR_PAC_RESET_KEYS = 54
const PR_PAC_SET_ENABLED_KEYS = 60
const PR_SET_CHILD_SUBREAPER = 36
const PR_SET_DUMPABLE = 4
const PR_SET_ENDIAN = 20
const PR_SET_FPEMU = 10
const PR_SET_FPEXC = 12
const PR_SET_FP_MODE = 45
const PR_SET_IO_FLUSHER = 57
const PR_SET_KEEPCAPS = 8
const PR_SET_MM = 35
const PR_SET_MM_ARG_END = 9
const PR_SET_MM_ARG_START = 8
const PR_SET_MM_AUXV = 12
const PR_SET_MM_BRK = 7
const PR_SET_MM_END_CODE = 2
const PR_SET_MM_END_DATA = 4
const PR_SET_MM_ENV_END = 11
const PR_SET_MM_ENV_START = 10
const PR_SET_MM_EXE_FILE = 13
const PR_SET_MM_MAP = 14
const PR_SET_MM_MAP_SIZE = 15
const PR_SET_MM_START_BRK = 6
const PR_SET_MM_START_CODE = 1
const PR_SET_MM_START_DATA = 3
const PR_SET_MM_START_STACK = 5
const PR_SET_NAME = 15
const PR_SET_NO_NEW_PRIVS = 38
const PR_SET_PDEATHSIG = 1
const PR_SET_PTRACER = 1499557217
const PR_SET_PTRACER_ANY = 18446744073709551615
const PR_SET_SECCOMP = 22
const PR_SET_SECUREBITS = 28
const PR_SET_SPECULATION_CTRL = 53
const PR_SET_SYSCALL_USER_DISPATCH = 59
const PR_SET_TAGGED_ADDR_CTRL = 55
const PR_SET_THP_DISABLE = 41
const PR_SET_TIMERSLACK = 29
const PR_SET_TIMING = 14
const PR_SET_TSC = 26
const PR_SET_UNALIGN = 6
const PR_SPEC_DISABLE = 4
const PR_SPEC_DISABLE_NOEXEC = 16
const PR_SPEC_ENABLE = 2
const PR_SPEC_FORCE_DISABLE = 8
const PR_SPEC_INDIRECT_BRANCH = 1
const PR_SPEC_NOT_AFFECTED = 0
const PR_SPEC_PRCTL = 1
const PR_SPEC_STORE_BYPASS = 0
const PR_SVE_GET_VL = 51
const PR_SVE_SET_VL = 50
const PR_SVE_SET_VL_ONEXEC = 262144
const PR_SVE_VL_INHERIT = 131072
const PR_SVE_VL_LEN_MASK = 65535
const PR_SYS_DISPATCH_OFF = 0
const PR_SYS_DISPATCH_ON = 1
const PR_TAGGED_ADDR_ENABLE = 1
const PR_TASK_PERF_EVENTS_DISABLE = 31
const PR_TASK_PERF_EVENTS_ENABLE = 32
const PR_TIMING_STATISTICAL = 0
const PR_TIMING_TIMESTAMP = 1
const PR_TSC_ENABLE = 1
const PR_TSC_SIGSEGV = 2
const PR_UNALIGN_NOPRINT = 1
const PR_UNALIGN_SIGBUS = 2
const SYSCALL_DISPATCH_FILTER_ALLOW = 0
const SYSCALL_DISPATCH_FILTER_BLOCK = 1

type Tprctl_mm_map = struct {
	Fstart_code  Tuint64_t
	Fend_code    Tuint64_t
	Fstart_data  Tuint64_t
	Fend_data    Tuint64_t
	Fstart_brk   Tuint64_t
	Fbrk         Tuint64_t
	Fstart_stack Tuint64_t
	Farg_start   Tuint64_t
	Farg_end     Tuint64_t
	Fenv_start   Tuint64_t
	Fenv_end     Tuint64_t
	Fauxv        uintptr
	Fauxv_size   Tuint32_t
	Fexe_fd      Tuint32_t
}

func Xprctl(tls *TLS, op int32, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v op=%v va=%v, (%v:)", tls, op, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var i int32
	var x [4]uint64
	_, _, _ = ap, i, x
	ap = va
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		x[i] = VaUint64(&ap)
		goto _1
	_1:
		;
		i++
	}
	_ = ap
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_prctl), int64(op), int64(x[0]), int64(x[int32(1)]), int64(x[int32(2)]), int64(x[int32(3)])))))
}

const RWF_APPEND = 16
const RWF_DSYNC = 2
const RWF_HIPRI = 1
const RWF_NOWAIT = 8
const RWF_SYNC = 4
const UIO_MAXIOV = 1024

func Xpreadv2(tls *TLS, fd int32, iov uintptr, count int32, ofs Toff_t, flags int32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v iov=%v count=%v ofs=%v flags=%v, (%v:)", tls, fd, iov, count, ofs, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if !(flags != 0) {
		if ofs == int64(-int32(1)) {
			return Xreadv(tls, fd, iov, count)
		}
		return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_preadv), int64(fd), int64(iov), int64(count), ofs, ofs>>Int32FromInt32(32), 0)))
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_preadv2), int64(fd), int64(iov), int64(count), ofs, ofs>>Int32FromInt32(32), int64(flags))))
}

func Xprlimit(tls *TLS, pid Tpid_t, resource int32, new_limit uintptr, old_limit uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v pid=%v resource=%v new_limit=%v old_limit=%v, (%v:)", tls, pid, resource, new_limit, old_limit, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r int32
	var _ /* tmp at bp+0 */ Trlimit
	_ = r
	if new_limit != 0 && Bool(^Uint64FromUint64(0) != ^Uint64FromUint64(0)) {
		*(*Trlimit)(unsafe.Pointer(bp)) = *(*Trlimit)(unsafe.Pointer(new_limit))
		if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur >= ^Uint64FromUint64(0) {
			(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur = ^Uint64FromUint64(0)
		}
		if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max >= ^Uint64FromUint64(0) {
			(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max = ^Uint64FromUint64(0)
		}
		new_limit = bp
	}
	r = int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_prlimit64), int64(pid), int64(resource), int64(new_limit), int64(old_limit)))))
	if !(r != 0) && old_limit != 0 && Bool(^Uint64FromUint64(0) != ^Uint64FromUint64(0)) {
		if (*Trlimit)(unsafe.Pointer(old_limit)).Frlim_cur >= ^Uint64FromUint64(0) {
			(*Trlimit)(unsafe.Pointer(old_limit)).Frlim_cur = ^Uint64FromUint64(0)
		}
		if (*Trlimit)(unsafe.Pointer(old_limit)).Frlim_max >= ^Uint64FromUint64(0) {
			(*Trlimit)(unsafe.Pointer(old_limit)).Frlim_max = ^Uint64FromUint64(0)
		}
	}
	return r
}

func Xprocess_vm_writev(tls *TLS, pid Tpid_t, lvec uintptr, liovcnt uint64, rvec uintptr, riovcnt uint64, flags uint64) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v pid=%v lvec=%v liovcnt=%v rvec=%v riovcnt=%v flags=%v, (%v:)", tls, pid, lvec, liovcnt, rvec, riovcnt, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall6(tls, int64(SYS_process_vm_writev), int64(pid), int64(lvec), int64(liovcnt), int64(rvec), int64(riovcnt), int64(flags))))
}

func Xprocess_vm_readv(tls *TLS, pid Tpid_t, lvec uintptr, liovcnt uint64, rvec uintptr, riovcnt uint64, flags uint64) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v pid=%v lvec=%v liovcnt=%v rvec=%v riovcnt=%v flags=%v, (%v:)", tls, pid, lvec, liovcnt, rvec, riovcnt, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall6(tls, int64(SYS_process_vm_readv), int64(pid), int64(lvec), int64(liovcnt), int64(rvec), int64(riovcnt), int64(flags))))
}

const PTRACE_ATTACH = 16
const PTRACE_CONT = 7
const PTRACE_DETACH = 17
const PTRACE_EVENT_CLONE = 3
const PTRACE_EVENT_EXEC = 4
const PTRACE_EVENT_EXIT = 6
const PTRACE_EVENT_FORK = 1
const PTRACE_EVENT_SECCOMP = 7
const PTRACE_EVENT_STOP = 128
const PTRACE_EVENT_VFORK = 2
const PTRACE_EVENT_VFORK_DONE = 5
const PTRACE_GETEVENTMSG = 16897
const PTRACE_GETFPREGS = 14
const PTRACE_GETFPXREGS = 18
const PTRACE_GETREGS = 12
const PTRACE_GETREGSET = 16900
const PTRACE_GETSIGINFO = 16898
const PTRACE_GETSIGMASK = 16906
const PTRACE_GET_RSEQ_CONFIGURATION = 16911
const PTRACE_GET_SYSCALL_INFO = 16910
const PTRACE_INTERRUPT = 16903
const PTRACE_KILL = 8
const PTRACE_LISTEN = 16904
const PTRACE_O_EXITKILL = 1048576
const PTRACE_O_MASK = 3145983
const PTRACE_O_SUSPEND_SECCOMP = 2097152
const PTRACE_O_TRACECLONE = 8
const PTRACE_O_TRACEEXEC = 16
const PTRACE_O_TRACEEXIT = 64
const PTRACE_O_TRACEFORK = 2
const PTRACE_O_TRACESECCOMP = 128
const PTRACE_O_TRACESYSGOOD = 1
const PTRACE_O_TRACEVFORK = 4
const PTRACE_O_TRACEVFORKDONE = 32
const PTRACE_PEEKDATA = 2
const PTRACE_PEEKSIGINFO = 16905
const PTRACE_PEEKSIGINFO_SHARED = 1
const PTRACE_PEEKTEXT = 1
const PTRACE_PEEKUSER = 3
const PTRACE_POKEDATA = 5
const PTRACE_POKETEXT = 4
const PTRACE_POKEUSER = 6
const PTRACE_SECCOMP_GET_FILTER = 16908
const PTRACE_SECCOMP_GET_METADATA = 16909
const PTRACE_SEIZE = 16902
const PTRACE_SETFPREGS = 15
const PTRACE_SETFPXREGS = 19
const PTRACE_SETOPTIONS = 16896
const PTRACE_SETREGS = 13
const PTRACE_SETREGSET = 16901
const PTRACE_SETSIGINFO = 16899
const PTRACE_SETSIGMASK = 16907
const PTRACE_SINGLESTEP = 9
const PTRACE_SYSCALL = 24
const PTRACE_SYSCALL_INFO_ENTRY = 1
const PTRACE_SYSCALL_INFO_EXIT = 2
const PTRACE_SYSCALL_INFO_NONE = 0
const PTRACE_SYSCALL_INFO_SECCOMP = 3
const PTRACE_TRACEME = 0
const PT_ATTACH = 16
const PT_CONTINUE = 7
const PT_DETACH = 17
const PT_GETEVENTMSG = 16897
const PT_GETFPREGS = 14
const PT_GETFPXREGS = 18
const PT_GETREGS = 12
const PT_GETSIGINFO = 16898
const PT_KILL = 8
const PT_READ_D = 2
const PT_READ_I = 1
const PT_READ_U = 3
const PT_SETFPREGS = 15
const PT_SETFPXREGS = 19
const PT_SETOPTIONS = 16896
const PT_SETREGS = 13
const PT_SETSIGINFO = 16899
const PT_STEP = 9
const PT_SYSCALL = 24
const PT_TRACE_ME = 0
const PT_WRITE_D = 5
const PT_WRITE_I = 4
const PT_WRITE_U = 6

type t__ptrace_peeksiginfo_args = struct {
	Foff   Tuint64_t
	Fflags Tuint32_t
	Fnr    Tint32_t
}

type t__ptrace_seccomp_metadata = struct {
	Ffilter_off Tuint64_t
	Fflags      Tuint64_t
}

type t__ptrace_syscall_info = struct {
	Fop                  Tuint8_t
	F__pad               [3]Tuint8_t
	Farch                Tuint32_t
	Finstruction_pointer Tuint64_t
	Fstack_pointer       Tuint64_t
	F__ccgo5_24          struct {
		Fexit [0]struct {
			Frval     Tint64_t
			Fis_error Tuint8_t
		}
		Fseccomp [0]struct {
			Fnr       Tuint64_t
			Fargs     [6]Tuint64_t
			Fret_data Tuint32_t
		}
		Fentry struct {
			Fnr   Tuint64_t
			Fargs [6]Tuint64_t
		}
		F__ccgo_pad3 [8]byte
	}
}

type t__ptrace_rseq_configuration = struct {
	Frseq_abi_pointer Tuint64_t
	Frseq_abi_size    Tuint32_t
	Fsignature        Tuint32_t
	Fflags            Tuint32_t
	Fpad              Tuint32_t
}

func Xptrace(tls *TLS, req int32, va uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v req=%v va=%v, (%v:)", tls, req, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var addr, addr2, data uintptr
	var ap Tva_list
	var pid Tpid_t
	var ret int64
	var _ /* result at bp+0 */ int64
	_, _, _, _, _, _ = addr, addr2, ap, data, pid, ret
	addr2 = uintptr(0)
	ap = va
	pid = VaInt32(&ap)
	addr = VaUintptr(&ap)
	data = VaUintptr(&ap)
	/* PTRACE_{READ,WRITE}{DATA,TEXT} (16...19) are specific to SPARC. */
	_ = ap
	if uint32(req)-uint32(1) < uint32(3) {
		data = bp
	}
	ret = X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_ptrace), int64(req), int64(pid), int64(addr), int64(data), int64(addr2))))
	if ret < 0 || uint32(req)-uint32(1) >= uint32(3) {
		return ret
	}
	return *(*int64)(unsafe.Pointer(bp))
}

func Xpwritev2(tls *TLS, fd int32, iov uintptr, count int32, ofs Toff_t, flags int32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v iov=%v count=%v ofs=%v flags=%v, (%v:)", tls, fd, iov, count, ofs, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if !(flags != 0) {
		if ofs == int64(-int32(1)) {
			return Xwritev(tls, fd, iov, count)
		}
		return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_pwritev), int64(fd), int64(iov), int64(count), ofs, ofs>>Int32FromInt32(32), 0)))
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_pwritev2), int64(fd), int64(iov), int64(count), ofs, ofs>>Int32FromInt32(32), int64(flags))))
}

const GRPQUOTA = 1
const IIF_ALL = 7
const IIF_BGRACE = 1
const IIF_FLAGS = 4
const IIF_IGRACE = 2
const MAXQUOTAS = 2
const MAX_DQ_TIME = 604800
const MAX_IQ_TIME = 604800
const NR_DQHASH = 43
const NR_DQUOTS = 256
const QFMT_OCFS2 = 3
const QFMT_VFS_OLD = 1
const QFMT_VFS_V0 = 2
const QFMT_VFS_V1 = 4
const QIF_ALL = 63
const QIF_BLIMITS = 1
const QIF_BTIME = 16
const QIF_ILIMITS = 4
const QIF_INODES = 8
const QIF_ITIME = 32
const QIF_LIMITS = 5
const QIF_SPACE = 2
const QIF_TIMES = 48
const QIF_USAGE = 10
const QUOTAFILENAME = "quota"
const QUOTAGROUP = "staff"
const Q_GETFMT = 8388612
const Q_GETINFO = 8388613
const Q_GETQUOTA = 8388615
const Q_QUOTAOFF = 8388611
const Q_QUOTAON = 8388610
const Q_SETINFO = 8388614
const Q_SETQUOTA = 8388616
const Q_SYNC = 8388609
const SUBCMDMASK = 255
const SUBCMDSHIFT = 8
const USRQUOTA = 0
const _LINUX_QUOTA_VERSION = 2

type Tdqblk = struct {
	Fdqb_bhardlimit Tuint64_t
	Fdqb_bsoftlimit Tuint64_t
	Fdqb_curspace   Tuint64_t
	Fdqb_ihardlimit Tuint64_t
	Fdqb_isoftlimit Tuint64_t
	Fdqb_curinodes  Tuint64_t
	Fdqb_btime      Tuint64_t
	Fdqb_itime      Tuint64_t
	Fdqb_valid      Tuint32_t
}

type Tdqinfo = struct {
	Fdqi_bgrace Tuint64_t
	Fdqi_igrace Tuint64_t
	Fdqi_flags  Tuint32_t
	Fdqi_valid  Tuint32_t
}

func Xquotactl(tls *TLS, cmd int32, special uintptr, id int32, addr uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v cmd=%v special=%v id=%v addr=%v, (%v:)", tls, cmd, special, id, addr, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_quotactl), int64(cmd), int64(special), int64(id), int64(addr)))))
}

func Xreadahead(tls *TLS, fd int32, pos Toff_t, len1 Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v pos=%v len1=%v, (%v:)", tls, fd, pos, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_readahead), int64(fd), pos, int64(len1))))
}

const RB_AUTOBOOT = 19088743
const RB_DISABLE_CAD = 0
const RB_ENABLE_CAD = 2309737967
const RB_HALT_SYSTEM = 3454992675
const RB_KEXEC = 1163412803
const RB_POWER_OFF = 1126301404
const RB_SW_SUSPEND = 3489725666

func Xreboot(tls *TLS, type1 int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v type1=%v, (%v:)", tls, type1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_reboot), int64(Uint32FromUint32(0xfee1dead)), int64(Int32FromInt32(672274793)), int64(type1)))))
}

func Xremap_file_pages(tls *TLS, addr uintptr, size Tsize_t, prot int32, pgoff Tsize_t, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v size=%v prot=%v pgoff=%v flags=%v, (%v:)", tls, addr, size, prot, pgoff, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_remap_file_pages), int64(addr), int64(size), int64(prot), int64(pgoff), int64(flags)))))
}

func Xsbrk(tls *TLS, inc Tintptr_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v inc=%v, (%v:)", tls, inc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if inc != 0 {
		return uintptr(X__syscall_ret(tls, uint64(-Int32FromInt32(ENOMEM))))
	}
	return uintptr(X__syscall1(tls, int64(SYS_brk), int64(Int32FromInt32(0))))
}

func Xsendfile(tls *TLS, out_fd int32, in_fd int32, ofs uintptr, count Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v out_fd=%v in_fd=%v ofs=%v count=%v, (%v:)", tls, out_fd, in_fd, ofs, count, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_sendfile), int64(out_fd), int64(in_fd), int64(ofs), int64(count))))
}

func Xsetfsgid(tls *TLS, gid Tgid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v gid=%v, (%v:)", tls, gid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_setfsgid), int64(gid)))))
}

func Xsetfsuid(tls *TLS, uid Tuid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v uid=%v, (%v:)", tls, uid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_setfsuid), int64(uid)))))
}

func Xsethostname(tls *TLS, name uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v len1=%v, (%v:)", tls, name, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_sethostname), int64(name), int64(len1)))))
}

const CLONE_CHILD_CLEARTID = 2097152
const CLONE_CHILD_SETTID = 16777216
const CLONE_DETACHED = 4194304
const CLONE_FILES = 1024
const CLONE_FS = 512
const CLONE_IO = 2147483648
const CLONE_NEWCGROUP = 33554432
const CLONE_NEWIPC = 134217728
const CLONE_NEWNET = 1073741824
const CLONE_NEWNS = 131072
const CLONE_NEWPID = 536870912
const CLONE_NEWTIME = 128
const CLONE_NEWUSER = 268435456
const CLONE_NEWUTS = 67108864
const CLONE_PARENT = 32768
const CLONE_PARENT_SETTID = 1048576
const CLONE_PIDFD = 4096
const CLONE_PTRACE = 8192
const CLONE_SETTLS = 524288
const CLONE_SIGHAND = 2048
const CLONE_SYSVSEM = 262144
const CLONE_THREAD = 65536
const CLONE_UNTRACED = 8388608
const CLONE_VFORK = 16384
const CLONE_VM = 256
const CPU_SETSIZE = 1024
const CSIGNAL = 255

type Tcpu_set_t = struct {
	F__bits [16]uint64
}

func Xsetns(tls *TLS, fd int32, nstype int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v nstype=%v, (%v:)", tls, fd, nstype, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_setns), int64(fd), int64(nstype)))))
}

const __tm_gmtoff = 0
const __tm_zone = 0

type Ttm1 = struct {
	Ftm_sec    int32
	Ftm_min    int32
	Ftm_hour   int32
	Ftm_mday   int32
	Ftm_mon    int32
	Ftm_year   int32
	Ftm_wday   int32
	Ftm_yday   int32
	Ftm_isdst  int32
	Ftm_gmtoff int64
	Ftm_zone   uintptr
}

func Xsettimeofday(tls *TLS, tv uintptr, tz uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v tv=%v tz=%v, (%v:)", tls, tv, tz, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	if !(tv != 0) {
		return 0
	}
	if uint64((*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec) >= uint64(1000000) {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
	}
	*(*Ttimespec)(unsafe.Pointer(bp)) = Ttimespec{
		Ftv_sec:  (*Ttimeval)(unsafe.Pointer(tv)).Ftv_sec,
		Ftv_nsec: (*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec * int64(1000),
	}
	return Xclock_settime(tls, CLOCK_REALTIME, bp)
}

const SFD_CLOEXEC = 524288
const SFD_NONBLOCK = 2048

type Tsignalfd_siginfo = struct {
	Fssi_signo     Tuint32_t
	Fssi_errno     Tint32_t
	Fssi_code      Tint32_t
	Fssi_pid       Tuint32_t
	Fssi_uid       Tuint32_t
	Fssi_fd        Tint32_t
	Fssi_tid       Tuint32_t
	Fssi_band      Tuint32_t
	Fssi_overrun   Tuint32_t
	Fssi_trapno    Tuint32_t
	Fssi_status    Tint32_t
	Fssi_int       Tint32_t
	Fssi_ptr       Tuint64_t
	Fssi_utime     Tuint64_t
	Fssi_stime     Tuint64_t
	Fssi_addr      Tuint64_t
	Fssi_addr_lsb  Tuint16_t
	F__pad2        Tuint16_t
	Fssi_syscall   Tint32_t
	Fssi_call_addr Tuint64_t
	Fssi_arch      Tuint32_t
	F__pad         [28]Tuint8_t
}

func Xsignalfd(tls *TLS, fd int32, sigs uintptr, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v sigs=%v flags=%v, (%v:)", tls, fd, sigs, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int32
	_ = ret
	ret = int32(X__syscall4(tls, int64(SYS_signalfd4), int64(fd), int64(sigs), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)), int64(flags)))
	return int32(X__syscall_ret(tls, uint64(ret)))
}

func Xsplice(tls *TLS, fd_in int32, off_in uintptr, fd_out int32, off_out uintptr, len1 Tsize_t, flags uint32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd_in=%v off_in=%v fd_out=%v off_out=%v len1=%v flags=%v, (%v:)", tls, fd_in, off_in, fd_out, off_out, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall6(tls, int64(SYS_splice), int64(fd_in), int64(off_in), int64(fd_out), int64(off_out), int64(len1), int64(flags))))
}

func Xstatx(tls *TLS, dirfd int32, path uintptr, flags int32, mask uint32, stx uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v dirfd=%v path=%v flags=%v mask=%v stx=%v, (%v:)", tls, dirfd, path, flags, mask, stx, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var ret int32
	var _ /* st at bp+0 */ Tstat
	_ = ret
	ret = int32(X__syscall5(tls, int64(SYS_statx), int64(dirfd), int64(path), int64(flags), int64(mask), int64(stx)))
	if ret != -int32(ENOSYS) {
		return int32(X__syscall_ret(tls, uint64(ret)))
	}
	ret = Xfstatat(tls, dirfd, path, bp, flags)
	if ret != 0 {
		return ret
	}
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_dev_major = uint32((*(*Tstat)(unsafe.Pointer(bp))).Fst_dev>>Int32FromInt32(31)>>Int32FromInt32(1)&Uint64FromUint32(0xfffff000) | (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev>>Int32FromInt32(8)&Uint64FromInt32(0x00000fff))
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_dev_minor = uint32((*(*Tstat)(unsafe.Pointer(bp))).Fst_dev>>Int32FromInt32(12)&Uint64FromUint32(0xffffff00) | (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev&Uint64FromInt32(0x000000ff))
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_ino = (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_mode = uint16((*(*Tstat)(unsafe.Pointer(bp))).Fst_mode)
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_nlink = (*(*Tstat)(unsafe.Pointer(bp))).Fst_nlink
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_uid = (*(*Tstat)(unsafe.Pointer(bp))).Fst_uid
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_gid = (*(*Tstat)(unsafe.Pointer(bp))).Fst_gid
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_size = uint64((*(*Tstat)(unsafe.Pointer(bp))).Fst_size)
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_blksize = uint32((*(*Tstat)(unsafe.Pointer(bp))).Fst_blksize)
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_blocks = uint64((*(*Tstat)(unsafe.Pointer(bp))).Fst_blocks)
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_atime.Ftv_sec = (*(*Tstat)(unsafe.Pointer(bp))).Fst_atim.Ftv_sec
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_atime.Ftv_nsec = uint32((*(*Tstat)(unsafe.Pointer(bp))).Fst_atim.Ftv_nsec)
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_mtime.Ftv_sec = (*(*Tstat)(unsafe.Pointer(bp))).Fst_mtim.Ftv_sec
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_mtime.Ftv_nsec = uint32((*(*Tstat)(unsafe.Pointer(bp))).Fst_mtim.Ftv_nsec)
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_ctime.Ftv_sec = (*(*Tstat)(unsafe.Pointer(bp))).Fst_ctim.Ftv_sec
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_ctime.Ftv_nsec = uint32((*(*Tstat)(unsafe.Pointer(bp))).Fst_ctim.Ftv_nsec)
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_btime = Tstatx_timestamp{}
	(*Tstatx)(unsafe.Pointer(stx)).Fstx_mask = uint32(0x7ff)
	return 0
}

func Xstime(tls *TLS, t uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v t=%v, (%v:)", tls, t, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimeval
	*(*Ttimeval)(unsafe.Pointer(bp)) = Ttimeval{
		Ftv_sec: *(*Ttime_t)(unsafe.Pointer(t)),
	}
	return Xsettimeofday(tls, bp, UintptrFromInt32(0))
}

const SWAP_FLAG_DISCARD = 65536
const SWAP_FLAG_PREFER = 32768
const SWAP_FLAG_PRIO_MASK = 32767
const SWAP_FLAG_PRIO_SHIFT = 0

func Xswapon(tls *TLS, path uintptr, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v flags=%v, (%v:)", tls, path, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_swapon), int64(path), int64(flags)))))
}

func Xswapoff(tls *TLS, path uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v, (%v:)", tls, path, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_swapoff), int64(path)))))
}

func Xsync_file_range(tls *TLS, fd int32, pos Toff_t, len1 Toff_t, flags uint32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v pos=%v len1=%v flags=%v, (%v:)", tls, fd, pos, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_sync_file_range), int64(fd), pos, len1, int64(flags)))))
}

func Xsyncfs(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_syncfs), int64(fd)))))
}

func X__lsysinfo(tls *TLS, info uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v info=%v, (%v:)", tls, info, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_sysinfo), int64(info)))))
}

func Xsysinfo(tls *TLS, info uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v info=%v, (%v:)", tls, info, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lsysinfo(tls, info)
}

func Xtee(tls *TLS, src int32, dest int32, len1 Tsize_t, flags uint32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v src=%v dest=%v len1=%v flags=%v, (%v:)", tls, src, dest, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_tee), int64(src), int64(dest), int64(len1), int64(flags))))
}

const TFD_CLOEXEC = 524288
const TFD_NONBLOCK = 2048
const TFD_TIMER_ABSTIME = 1
const TFD_TIMER_CANCEL_ON_SET = 2

func Xtimerfd_create(tls *TLS, clockid int32, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v clockid=%v flags=%v, (%v:)", tls, clockid, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_timerfd_create), int64(clockid), int64(flags)))))
}

func Xtimerfd_settime(tls *TLS, fd int32, flags int32, new1 uintptr, old uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v flags=%v new1=%v old=%v, (%v:)", tls, fd, flags, new1, old, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_timerfd_settime), int64(fd), int64(flags), int64(new1), int64(old)))))
}

func Xtimerfd_gettime(tls *TLS, fd int32, cur uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v cur=%v, (%v:)", tls, fd, cur, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_timerfd_gettime), int64(fd), int64(cur)))))
}

func Xunshare(tls *TLS, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v flags=%v, (%v:)", tls, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_unshare), int64(flags)))))
}

func Xutimes(tls *TLS, path uintptr, times uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v times=%v, (%v:)", tls, path, times, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__futimesat(tls, -int32(100), path, times)
}

func Xvhangup(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall0(tls, int64(SYS_vhangup)))))
}

func Xvmsplice(tls *TLS, fd int32, iov uintptr, cnt Tsize_t, flags uint32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v iov=%v cnt=%v flags=%v, (%v:)", tls, fd, iov, cnt, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_vmsplice), int64(fd), int64(iov), int64(cnt), int64(flags))))
}

const ESR_MAGIC = 1163088385
const EXTRA_MAGIC = 1163416577
const FPSIMD_MAGIC = 1179680769
const NSIG = 65
const SA_NOMASK = 1073741824
const SA_ONESHOT = 2147483648
const SVE_MAGIC = 1398162689
const SVE_NUM_PREGS = 16
const SVE_NUM_ZREGS = 32
const SVE_SIG_REGS_OFFSET = 0
const SVE_SIG_ZREGS_OFFSET = 0
const SVE_VL_MAX = 8192
const SVE_VL_MIN = 16
const SVE_VQ_BYTES = 16
const SVE_VQ_MAX = 512
const SVE_VQ_MIN = 1
const SYS_SECCOMP = 1
const SYS_USER_DISPATCH = 2
const __ucontext = 0

type Tgreg_t = uint64

type Tgregset_t = [34]uint64

type Tmcontext_t1 = struct {
	Ffault_address uint64
	Fregs          [31]uint64
	Fsp            uint64
	Fpc            uint64
	Fpstate        uint64
	F__reserved    [256]float64
}

type Tsigcontext = Tmcontext_t1

type T_aarch64_ctx = struct {
	Fmagic uint32
	Fsize  uint32
}

type Tfpsimd_context = int32

type Tesr_context = struct {
	Fhead T_aarch64_ctx
	Fesr  uint64
}

type Textra_context = struct {
	Fhead       T_aarch64_ctx
	Fdatap      uint64
	Fsize       uint32
	F__reserved [3]uint32
}

type Tsve_context = struct {
	Fhead       T_aarch64_ctx
	Fvl         uint16
	F__reserved [3]uint16
}

type Tucontext_t1 = struct {
	Fuc_flags    uint64
	Fuc_link     uintptr
	Fuc_stack    Tstack_t
	Fuc_sigmask  Tsigset_t
	Fuc_mcontext Tmcontext_t1
}

type Tucontext = Tucontext_t1

type Tsig_t = uintptr

type Tsighandler_t = uintptr

func Xwait3(tls *TLS, status uintptr, options int32, usage uintptr) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v status=%v options=%v usage=%v, (%v:)", tls, status, options, usage, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwait4(tls, -int32(1), status, options, usage)
}

func Xwait4(tls *TLS, pid Tpid_t, status uintptr, options int32, ru uintptr) (r1 Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v pid=%v status=%v options=%v ru=%v, (%v:)", tls, pid, status, options, ru, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var dest, v1 uintptr
	var r int32
	var _ /* kru at bp+0 */ [4]int64
	_, _, _ = dest, r, v1
	if ru != 0 {
		v1 = ru + 32 - uintptr(Uint64FromInt32(4)*Uint64FromInt64(8))
	} else {
		v1 = uintptr(0)
	}
	dest = v1
	r = int32(X__syscall4(tls, int64(SYS_wait4), int64(pid), int64(status), int64(options), int64(dest)))
	if r > 0 && ru != 0 && Bool(uint64(8) > uint64(8)) {
		Xmemcpy(tls, bp, dest, Uint64FromInt32(4)*Uint64FromInt64(8))
		(*Trusage)(unsafe.Pointer(ru)).Fru_utime = Ttimeval{
			Ftv_sec:  (*(*[4]int64)(unsafe.Pointer(bp)))[0],
			Ftv_usec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(1)],
		}
		(*Trusage)(unsafe.Pointer(ru)).Fru_stime = Ttimeval{
			Ftv_sec:  (*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)],
			Ftv_usec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(3)],
		}
	}
	return int32(X__syscall_ret(tls, uint64(r)))
}

const XATTR_CREATE = 1
const XATTR_REPLACE = 2
const __UAPI_DEF_XATTR = 0

func Xgetxattr(tls *TLS, path uintptr, name uintptr, value uintptr, size Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v path=%v name=%v value=%v size=%v, (%v:)", tls, path, name, value, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_getxattr), int64(path), int64(name), int64(value), int64(size))))
}

func Xlgetxattr(tls *TLS, path uintptr, name uintptr, value uintptr, size Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v path=%v name=%v value=%v size=%v, (%v:)", tls, path, name, value, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_lgetxattr), int64(path), int64(name), int64(value), int64(size))))
}

func Xfgetxattr(tls *TLS, filedes int32, name uintptr, value uintptr, size Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v filedes=%v name=%v value=%v size=%v, (%v:)", tls, filedes, name, value, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_fgetxattr), int64(filedes), int64(name), int64(value), int64(size))))
}

func Xlistxattr(tls *TLS, path uintptr, list uintptr, size Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v path=%v list=%v size=%v, (%v:)", tls, path, list, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_listxattr), int64(path), int64(list), int64(size))))
}

func Xllistxattr(tls *TLS, path uintptr, list uintptr, size Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v path=%v list=%v size=%v, (%v:)", tls, path, list, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_llistxattr), int64(path), int64(list), int64(size))))
}

func Xflistxattr(tls *TLS, filedes int32, list uintptr, size Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v filedes=%v list=%v size=%v, (%v:)", tls, filedes, list, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_flistxattr), int64(filedes), int64(list), int64(size))))
}

func Xsetxattr(tls *TLS, path uintptr, name uintptr, value uintptr, size Tsize_t, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v name=%v value=%v size=%v flags=%v, (%v:)", tls, path, name, value, size, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_setxattr), int64(path), int64(name), int64(value), int64(size), int64(flags)))))
}

func Xlsetxattr(tls *TLS, path uintptr, name uintptr, value uintptr, size Tsize_t, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v name=%v value=%v size=%v flags=%v, (%v:)", tls, path, name, value, size, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_lsetxattr), int64(path), int64(name), int64(value), int64(size), int64(flags)))))
}

func Xfsetxattr(tls *TLS, filedes int32, name uintptr, value uintptr, size Tsize_t, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v filedes=%v name=%v value=%v size=%v flags=%v, (%v:)", tls, filedes, name, value, size, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_fsetxattr), int64(filedes), int64(name), int64(value), int64(size), int64(flags)))))
}

func Xremovexattr(tls *TLS, path uintptr, name uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v name=%v, (%v:)", tls, path, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_removexattr), int64(path), int64(name)))))
}

func Xlremovexattr(tls *TLS, path uintptr, name uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v name=%v, (%v:)", tls, path, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_lremovexattr), int64(path), int64(name)))))
}

func Xfremovexattr(tls *TLS, fd int32, name uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v name=%v, (%v:)", tls, fd, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_fremovexattr), int64(fd), int64(name)))))
}

type Tucontext_t2 = struct {
	Fuc_flags    uint64
	Fuc_link     uintptr
	Fuc_stack    Tstack_t
	Fuc_sigmask  Tsigset_t
	Fuc_mcontext Tmcontext_t
}

func _dummy4(tls *TLS, msg uintptr, lm uintptr) (r uintptr) {
	return msg
}

func X__lctrans(tls *TLS, msg uintptr, lm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v msg=%v lm=%v, (%v:)", tls, msg, lm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lctrans_impl(tls, msg, lm)
}

func X__lctrans_cur(tls *TLS, msg uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v msg=%v, (%v:)", tls, msg, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lctrans_impl(tls, msg, *(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale + 5*8)))
}

func _swapc(tls *TLS, x Tuint32_t, c int32) (r Tuint32_t) {
	var v1 uint32
	_ = v1
	if c != 0 {
		v1 = x>>int32(24) | x>>int32(8)&uint32(0xff00) | x<<int32(8)&uint32(0xff0000) | x<<int32(24)
	} else {
		v1 = x
	}
	return v1
}

func X__mo_lookup(tls *TLS, p uintptr, size Tsize_t, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v p=%v size=%v s=%v, (%v:)", tls, p, size, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var b, n, o, ol, os, t, tl, ts Tuint32_t
	var mo uintptr
	var sign, sw int32
	_, _, _, _, _, _, _, _, _, _, _ = b, mo, n, o, ol, os, sign, sw, t, tl, ts
	mo = p
	sw = int32(*(*Tuint32_t)(unsafe.Pointer(mo)) - uint32(0x950412de))
	b = uint32(0)
	n = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + 2*4)), sw)
	o = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + 3*4)), sw)
	t = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + 4*4)), sw)
	if uint64(n) >= size/uint64(4) || uint64(o) >= size-uint64(uint32(4)*n) || uint64(t) >= size-uint64(uint32(4)*n) || (o|t)%uint32(4) != 0 {
		return uintptr(0)
	}
	o /= uint32(4)
	t /= uint32(4)
	for {
		ol = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + uintptr(o+uint32(2)*(b+n/uint32(2)))*4)), sw)
		os = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + uintptr(o+uint32(2)*(b+n/uint32(2))+uint32(1))*4)), sw)
		if uint64(os) >= size || uint64(ol) >= size-uint64(os) || *(*uint8)(unsafe.Pointer(p + uintptr(os+ol))) != 0 {
			return uintptr(0)
		}
		sign = Xstrcmp(tls, s, p+uintptr(os))
		if !(sign != 0) {
			tl = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + uintptr(t+uint32(2)*(b+n/uint32(2)))*4)), sw)
			ts = _swapc(tls, *(*Tuint32_t)(unsafe.Pointer(mo + uintptr(t+uint32(2)*(b+n/uint32(2))+uint32(1))*4)), sw)
			if uint64(ts) >= size || uint64(tl) >= size-uint64(ts) || *(*uint8)(unsafe.Pointer(p + uintptr(ts+tl))) != 0 {
				return uintptr(0)
			}
			return p + uintptr(ts)
		} else {
			if n == uint32(1) {
				return uintptr(0)
			} else {
				if sign < 0 {
					n /= uint32(2)
				} else {
					b += n / uint32(2)
					n -= n / uint32(2)
				}
			}
		}
		goto _1
	_1:
	}
	return uintptr(0)
}

const __USE_GNU_GETTEXT = 1

func Xbind_textdomain_codeset(tls *TLS, domainname uintptr, codeset uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v domainname=%v codeset=%v, (%v:)", tls, domainname, codeset, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if codeset != 0 && Xstrcasecmp(tls, codeset, __ccgo_ts+322) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
	}
	return UintptrFromInt32(0)
}

var _empty_mo = [5]Tuint32_t{
	0: uint32(0x950412de),
	2: uint32(-Int32FromInt32(1)),
	3: uint32(-Int32FromInt32(1)),
	4: uint32(-Int32FromInt32(1)),
}

const NL_CAT_LOCALE = 1
const NL_SETD = 1

type Tnl_item = int32

type Tnl_catd = uintptr

func Xcatclose(tls *TLS, catd Tnl_catd) (r int32) {
	if __ccgo_strace {
		trc("tls=%v catd=%v, (%v:)", tls, catd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var map1 uintptr
	var v1, v2 Tuint32_t
	_, _, _ = map1, v1, v2
	map1 = catd
	v1 = *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(8)))
	v2 = v1>>int32(24) | v1>>int32(8)&uint32(0xff00) | v1<<int32(8)&uint32(0xff0000) | v1<<int32(24)
	goto _3
_3:
	Xmunmap(tls, map1, uint64(v2+uint32(20)))
	return 0
}

func _cmp(tls *TLS, a uintptr, b uintptr) (r int32) {
	var x, y, v1, v2, v4, v5 Tuint32_t
	var v7, v8 int32
	_, _, _, _, _, _, _, _ = x, y, v1, v2, v4, v5, v7, v8
	v1 = *(*Tuint32_t)(unsafe.Pointer(a))
	v2 = v1>>int32(24) | v1>>int32(8)&uint32(0xff00) | v1<<int32(8)&uint32(0xff0000) | v1<<int32(24)
	goto _3
_3:
	x = v2
	v4 = *(*Tuint32_t)(unsafe.Pointer(b))
	v5 = v4>>int32(24) | v4>>int32(8)&uint32(0xff00) | v4<<int32(8)&uint32(0xff0000) | v4<<int32(24)
	goto _6
_6:
	y = v5
	if x < y {
		v7 = -int32(1)
	} else {
		if x > y {
			v8 = int32(1)
		} else {
			v8 = 0
		}
		v7 = v8
	}
	return v7
}

func Xcatgets(tls *TLS, catd Tnl_catd, set_id int32, msg_id int32, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v catd=%v set_id=%v msg_id=%v s=%v, (%v:)", tls, catd, set_id, msg_id, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var map1, msg, msgs, set, sets, strings uintptr
	var nmsgs, nsets, v1, v10, v11, v13, v14, v16, v17, v19, v2, v20, v22, v23, v4, v5, v7, v8 Tuint32_t
	var _ /* msg_id_be at bp+4 */ Tuint32_t
	var _ /* set_id_be at bp+0 */ Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = map1, msg, msgs, nmsgs, nsets, set, sets, strings, v1, v10, v11, v13, v14, v16, v17, v19, v2, v20, v22, v23, v4, v5, v7, v8
	map1 = catd
	v1 = *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(4)))
	v2 = v1>>int32(24) | v1>>int32(8)&uint32(0xff00) | v1<<int32(8)&uint32(0xff0000) | v1<<int32(24)
	goto _3
_3:
	nsets = v2
	sets = map1 + uintptr(20)
	v4 = *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(12)))
	v5 = v4>>int32(24) | v4>>int32(8)&uint32(0xff00) | v4<<int32(8)&uint32(0xff0000) | v4<<int32(24)
	goto _6
_6:
	msgs = map1 + uintptr(20) + uintptr(v5)
	v7 = *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(16)))
	v8 = v7>>int32(24) | v7>>int32(8)&uint32(0xff00) | v7<<int32(8)&uint32(0xff0000) | v7<<int32(24)
	goto _9
_9:
	strings = map1 + uintptr(20) + uintptr(v8)
	v10 = uint32(set_id)
	v11 = v10>>int32(24) | v10>>int32(8)&uint32(0xff00) | v10<<int32(8)&uint32(0xff0000) | v10<<int32(24)
	goto _12
_12:
	*(*Tuint32_t)(unsafe.Pointer(bp)) = v11
	v13 = uint32(msg_id)
	v14 = v13>>int32(24) | v13>>int32(8)&uint32(0xff00) | v13<<int32(8)&uint32(0xff0000) | v13<<int32(24)
	goto _15
_15:
	*(*Tuint32_t)(unsafe.Pointer(bp + 4)) = v14
	set = Xbsearch(tls, bp, sets, uint64(nsets), uint64(12), __ccgo_fp(_cmp))
	if !(set != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMSG)
		return s
	}
	v16 = *(*Tuint32_t)(unsafe.Pointer(set + UintptrFromInt32(4)))
	v17 = v16>>int32(24) | v16>>int32(8)&uint32(0xff00) | v16<<int32(8)&uint32(0xff0000) | v16<<int32(24)
	goto _18
_18:
	nmsgs = v17
	v19 = *(*Tuint32_t)(unsafe.Pointer(set + UintptrFromInt32(8)))
	v20 = v19>>int32(24) | v19>>int32(8)&uint32(0xff00) | v19<<int32(8)&uint32(0xff0000) | v19<<int32(24)
	goto _21
_21:
	msgs += uintptr(uint32(12) * v20)
	msg = Xbsearch(tls, bp+4, msgs, uint64(nmsgs), uint64(12), __ccgo_fp(_cmp))
	if !(msg != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMSG)
		return s
	}
	v22 = *(*Tuint32_t)(unsafe.Pointer(msg + UintptrFromInt32(8)))
	v23 = v22>>int32(24) | v22>>int32(8)&uint32(0xff00) | v22<<int32(8)&uint32(0xff0000) | v22<<int32(24)
	goto _24
_24:
	return strings + uintptr(v23)
}

const ABDAY_1 = 131072
const ABDAY_2 = 131073
const ABDAY_3 = 131074
const ABDAY_4 = 131075
const ABDAY_5 = 131076
const ABDAY_6 = 131077
const ABDAY_7 = 131078
const ABMON_1 = 131086
const ABMON_10 = 131095
const ABMON_11 = 131096
const ABMON_12 = 131097
const ABMON_2 = 131087
const ABMON_3 = 131088
const ABMON_4 = 131089
const ABMON_5 = 131090
const ABMON_6 = 131091
const ABMON_7 = 131092
const ABMON_8 = 131093
const ABMON_9 = 131094
const ALT_DIGITS = 131119
const AM_STR = 131110
const CODESET = 14
const CRNCYSTR = 262159
const DAY_1 = 131079
const DAY_2 = 131080
const DAY_3 = 131081
const DAY_4 = 131082
const DAY_5 = 131083
const DAY_6 = 131084
const DAY_7 = 131085
const D_FMT = 131113
const D_T_FMT = 131112
const ERA = 131116
const ERA_D_FMT = 131118
const ERA_D_T_FMT = 131120
const ERA_T_FMT = 131121
const MON_1 = 131098
const MON_10 = 131107
const MON_11 = 131108
const MON_12 = 131109
const MON_2 = 131099
const MON_3 = 131100
const MON_4 = 131101
const MON_5 = 131102
const MON_6 = 131103
const MON_7 = 131104
const MON_8 = 131105
const MON_9 = 131106
const NOEXPR = 327681
const NOSTR = 327683
const PM_STR = 131111
const RADIXCHAR = 65536
const THOUSEP = 65537
const T_FMT = 131114
const T_FMT_AMPM = 131115
const YESEXPR = 327680
const YESSTR = 327682

func _do_catopen(tls *TLS, name uintptr) (r Tnl_catd) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var map1 uintptr
	var v1, v2, v5, v6 Tuint32_t
	var v4, v8 bool
	var _ /* size at bp+0 */ Tsize_t
	_, _, _, _, _, _, _ = map1, v1, v2, v4, v5, v6, v8
	map1 = X__map_file(tls, name, bp)
	/* Size recorded in the file must match file size; otherwise
	 * the information needed to unmap the file will be lost. */
	if v4 = !(map1 != 0); !v4 {
		v1 = *(*Tuint32_t)(unsafe.Pointer(map1))
		v2 = v1>>int32(24) | v1>>int32(8)&uint32(0xff00) | v1<<int32(8)&uint32(0xff0000) | v1<<int32(24)
		goto _3
	_3:
	}
	if v8 = v4 || v2 != uint32(0xff88ff89); !v8 {
		v5 = *(*Tuint32_t)(unsafe.Pointer(map1 + UintptrFromInt32(8)))
		v6 = v5>>int32(24) | v5>>int32(8)&uint32(0xff00) | v5<<int32(8)&uint32(0xff0000) | v5<<int32(24)
		goto _7
	_7:
	}
	if v8 || uint64(uint32(20)+v6) != *(*Tsize_t)(unsafe.Pointer(bp)) {
		if map1 != 0 {
			Xmunmap(tls, map1, *(*Tsize_t)(unsafe.Pointer(bp)))
		}
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOENT)
		return uintptr(-Int32FromInt32(1))
	}
	return map1
}

func Xcatopen(tls *TLS, name uintptr, oflag int32) (r Tnl_catd) {
	if __ccgo_strace {
		trc("tls=%v name=%v oflag=%v, (%v:)", tls, name, oflag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(4096)
	defer tls.Free(4096)
	var catd Tnl_catd
	var i, l Tsize_t
	var lang, p, path, v, z, v1, v3, v6, v7 uintptr
	var v2 bool
	var _ /* buf at bp+0 */ [4096]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _ = catd, i, l, lang, p, path, v, z, v1, v2, v3, v6, v7
	if Xstrchr(tls, name, int32('/')) != 0 {
		return _do_catopen(tls, name)
	}
	if v2 = X__libc.Fsecure != 0; !v2 {
		v1 = Xgetenv(tls, __ccgo_ts+328)
		path = v1
	}
	if v2 || !(v1 != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOENT)
		return uintptr(-Int32FromInt32(1))
	}
	if oflag != 0 {
		v3 = Xnl_langinfo(tls, Int32FromInt32(LC_MESSAGES)<<Int32FromInt32(16)|Int32FromInt32(0xffff))
	} else {
		v3 = Xgetenv(tls, __ccgo_ts+336)
	}
	lang = v3
	if !(lang != 0) {
		lang = __ccgo_ts
	}
	p = path
	for {
		if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			break
		}
		i = uint64(0)
		z = X__strchrnul(tls, p, int32(':'))
		for {
			if !(p < z) {
				break
			}
			if int32(*(*uint8)(unsafe.Pointer(p))) != int32('%') {
				v = p
				l = Uint64FromInt32(1)
			} else {
				p++
				v6 = p
				switch int32(*(*uint8)(unsafe.Pointer(v6))) {
				case int32('N'):
					v = name
					l = Xstrlen(tls, v)
				case int32('L'):
					v = lang
					l = Xstrlen(tls, v)
				case int32('l'):
					v = lang
					l = Xstrcspn(tls, v, __ccgo_ts+341)
				case int32('t'):
					v = X__strchrnul(tls, lang, int32('_'))
					if *(*uint8)(unsafe.Pointer(v)) != 0 {
						v++
					}
					l = Xstrcspn(tls, v, __ccgo_ts+345)
				case int32('c'):
					v = __ccgo_ts + 322
					l = uint64(5)
				case int32('%'):
					v = __ccgo_ts + 348
					l = uint64(1)
				default:
					v = uintptr(0)
				}
			}
			if !(v != 0) || l >= uint64(4096)-i {
				break
			}
			Xmemcpy(tls, bp+uintptr(i), v, l)
			i += l
			goto _5
		_5:
			;
			p++
		}
		if !(*(*uint8)(unsafe.Pointer(z)) != 0) && (p < z || !(i != 0)) {
			break
		}
		if p < z {
			goto _4
		}
		if *(*uint8)(unsafe.Pointer(z)) != 0 {
			z++
		}
		(*(*[4096]uint8)(unsafe.Pointer(bp)))[i] = uint8(0)
		/* Leading : or :: in NLSPATH is same as %N */
		if i != 0 {
			v7 = bp
		} else {
			v7 = name
		}
		catd = _do_catopen(tls, v7)
		if catd != uintptr(-Int32FromInt32(1)) {
			return catd
		}
		goto _4
	_4:
		;
		p = z
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOENT)
	return uintptr(-Int32FromInt32(1))
}

const calloc = 0
const free = 0
const malloc = 0
const realloc = 0

type Tbinding = struct {
	Fnext       uintptr
	Fdirlen     int32
	Factive     int32
	Fdomainname uintptr
	Fdirname    uintptr
}

var _bindings uintptr

func _gettextdir(tls *TLS, domainname uintptr, dirlen uintptr) (r uintptr) {
	var p uintptr
	_ = p
	p = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_bindings)))
	for {
		if !(p != 0) {
			break
		}
		if !(Xstrcmp(tls, (*Tbinding)(unsafe.Pointer(p)).Fdomainname, domainname) != 0) && AtomicLoadPInt32(p+12) != 0 {
			*(*Tsize_t)(unsafe.Pointer(dirlen)) = uint64((*Tbinding)(unsafe.Pointer(p)).Fdirlen)
			return (*Tbinding)(unsafe.Pointer(p)).Fdirname
		}
		goto _1
	_1:
		;
		p = (*Tbinding)(unsafe.Pointer(p)).Fnext
	}
	return uintptr(0)
}

var _lock1 [1]int32

func Xbindtextdomain(tls *TLS, domainname uintptr, dirname uintptr) (r1 uintptr) {
	if __ccgo_strace {
		trc("tls=%v domainname=%v dirname=%v, (%v:)", tls, domainname, dirname, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var dirlen, domlen Tsize_t
	var old, p4, q, v, v2, v6 uintptr
	var r, v3 int32
	_, _, _, _, _, _, _, _, _, _ = dirlen, domlen, old, p4, q, r, v, v2, v3, v6
	if !(domainname != 0) {
		return uintptr(0)
	}
	if !(dirname != 0) {
		*(*Tsize_t)(unsafe.Pointer(bp)) = uint64(0)
		return _gettextdir(tls, domainname, bp)
	}
	domlen = Xstrnlen(tls, domainname, uint64(Int32FromInt32(NAME_MAX)+Int32FromInt32(1)))
	dirlen = Xstrnlen(tls, dirname, uint64(PATH_MAX))
	if domlen > uint64(NAME_MAX) || dirlen >= uint64(PATH_MAX) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	___lock(tls, uintptr(unsafe.Pointer(&_lock1)))
	p4 = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_bindings)))
	for {
		if !(p4 != 0) {
			break
		}
		if !(Xstrcmp(tls, (*Tbinding)(unsafe.Pointer(p4)).Fdomainname, domainname) != 0) && !(Xstrcmp(tls, (*Tbinding)(unsafe.Pointer(p4)).Fdirname, dirname) != 0) {
			break
		}
		goto _1
	_1:
		;
		p4 = (*Tbinding)(unsafe.Pointer(p4)).Fnext
	}
	if !(p4 != 0) {
		p4 = Xcalloc(tls, uint64(32)+domlen+dirlen+uint64(2), uint64(1))
		if !(p4 != 0) {
			___unlock(tls, uintptr(unsafe.Pointer(&_lock1)))
			return uintptr(0)
		}
		(*Tbinding)(unsafe.Pointer(p4)).Fnext = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_bindings)))
		(*Tbinding)(unsafe.Pointer(p4)).Fdirlen = int32(dirlen)
		(*Tbinding)(unsafe.Pointer(p4)).Fdomainname = p4 + 32
		(*Tbinding)(unsafe.Pointer(p4)).Fdirname = p4 + 32 + uintptr(domlen) + uintptr(1)
		Xmemcpy(tls, (*Tbinding)(unsafe.Pointer(p4)).Fdomainname, domainname, domlen+uint64(1))
		Xmemcpy(tls, (*Tbinding)(unsafe.Pointer(p4)).Fdirname, dirname, dirlen+uint64(1))
		v2 = uintptr(unsafe.Pointer(&_bindings))
		for {
			// __asm__ __volatile__ ("ldaxr %0, %1" : "=r"(v) : "Q"(*(void *volatile *)p));
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 41, __ccgo_ts+399)
			v6 = v
			goto _7
		_7:
			old = v6
			if old != AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_bindings))) {
				// __asm__ __volatile__ ("dmb ish" : : : "memory");
				X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+399)
				break
			}
			goto _5
		_5:
			;
			// __asm__ __volatile__ ("stlxr %w0,%2,%1" : "=&r"(r), "=Q"(*(void *volatile *)p) : "r"(v) : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 49, __ccgo_ts+399)
			v3 = BoolInt32(!(r != 0))
			goto _4
		_4:
			;
			if !!(v3 != 0) {
				break
			}
		}
		_ = old
		goto _8
	_8:
	}
	// __asm__ __volatile__ ("dmb ish" : : : "memory");
	X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+399)
	AtomicStorePInt32(p4+12, int32(1))
	// __asm__ __volatile__ ("dmb ish" : : : "memory");
	X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+399)
	q = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_bindings)))
	for {
		if !(q != 0) {
			break
		}
		if !(Xstrcmp(tls, (*Tbinding)(unsafe.Pointer(q)).Fdomainname, domainname) != 0) && q != p4 {
			// __asm__ __volatile__ ("dmb ish" : : : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+399)
			AtomicStorePInt32(q+12, 0)
			// __asm__ __volatile__ ("dmb ish" : : : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+399)
		}
		goto _9
	_9:
		;
		q = (*Tbinding)(unsafe.Pointer(q)).Fnext
	}
	___unlock(tls, uintptr(unsafe.Pointer(&_lock1)))
	return (*Tbinding)(unsafe.Pointer(p4)).Fdirname
}

var _catnames = [6][12]uint8{
	0: {'L', 'C', '_', 'C', 'T', 'Y', 'P', 'E'},
	1: {'L', 'C', '_', 'N', 'U', 'M', 'E', 'R', 'I', 'C'},
	2: {'L', 'C', '_', 'T', 'I', 'M', 'E'},
	3: {'L', 'C', '_', 'C', 'O', 'L', 'L', 'A', 'T', 'E'},
	4: {'L', 'C', '_', 'M', 'O', 'N', 'E', 'T', 'A', 'R', 'Y'},
	5: {'L', 'C', '_', 'M', 'E', 'S', 'S', 'A', 'G', 'E', 'S'},
}

var _catlens = [6]uint8{
	0: uint8(8),
	1: uint8(10),
	2: uint8(7),
	3: uint8(10),
	4: uint8(11),
	5: uint8(11),
}

type Tmsgcat = struct {
	Fnext        uintptr
	Fmap1        uintptr
	Fmap_size    Tsize_t
	Fplural_rule uintptr
	Fnplurals    int32
	Fbinding     uintptr
	Flm          uintptr
	Fcat         int32
}

func _dummy_gettextdomain(tls *TLS) (r uintptr) {
	return __ccgo_ts + 414
}

func Xdcngettext(tls *TLS, domainname uintptr, msgid1 uintptr, msgid2 uintptr, n uint64, category int32) (r2 uintptr) {
	if __ccgo_strace {
		trc("tls=%v domainname=%v msgid1=%v msgid2=%v n=%v category=%v, (%v:)", tls, domainname, msgid1, msgid2, n, category, origin(2))
		defer func() { trc("-> %v", r2) }()
	}
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var alt_modlen, catlen, dirlen, domlen, l, loclen, modlen, rem, v5 Tsize_t
	var catname, csp, dirname, lm, loc, locname, locp, map1, modname, name, old, old_cats, p3, q, r1, rule, trans, v, v10, v17, v21, v23, v3, v8, v9 uintptr
	var np, plural, v26 uint64
	var old_errno, r, v11, v12, v14, v15, v18 int32
	var v6 t__predefined_size_t
	var _ /* map_size at bp+0 */ Tsize_t
	var _ /* z at bp+8 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = alt_modlen, catlen, catname, csp, dirlen, dirname, domlen, l, lm, loc, loclen, locname, locp, map1, modlen, modname, name, np, old, old_cats, old_errno, p3, plural, q, r, r1, rem, rule, trans, v, v10, v11, v12, v14, v15, v17, v18, v21, v23, v26, v3, v5, v6, v8, v9
	defer func() { Xrealloc(tls, name, 0) }()
	loc = (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale
	old_errno = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	/* match gnu gettext behaviour */
	if !(msgid1 != 0) {
		goto notrans
	}
	if uint32(category) >= uint32(LC_ALL) {
		goto notrans
	}
	if !(domainname != 0) {
		domainname = X__gettextdomain(tls)
	}
	domlen = Xstrnlen(tls, domainname, uint64(Int32FromInt32(NAME_MAX)+Int32FromInt32(1)))
	if domlen > uint64(NAME_MAX) {
		goto notrans
	}
	q = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_bindings)))
	for {
		if !(q != 0) {
			break
		}
		if !(Xstrcmp(tls, (*Tbinding)(unsafe.Pointer(q)).Fdomainname, domainname) != 0) && AtomicLoadPInt32(q+12) != 0 {
			break
		}
		goto _1
	_1:
		;
		q = (*Tbinding)(unsafe.Pointer(q)).Fnext
	}
	if !(q != 0) {
		goto notrans
	}
	lm = *(*uintptr)(unsafe.Pointer(loc + uintptr(category)*8))
	if !!(lm != 0) {
		goto _2
	}
	goto notrans
notrans:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = old_errno
	if n == uint64(1) {
		v3 = msgid1
	} else {
		v3 = msgid2
	}
	return v3
_2:
	;
	p3 = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_cats)))
	for {
		if !(p3 != 0) {
			break
		}
		if (*Tmsgcat)(unsafe.Pointer(p3)).Fbinding == q && (*Tmsgcat)(unsafe.Pointer(p3)).Flm == lm && (*Tmsgcat)(unsafe.Pointer(p3)).Fcat == category {
			break
		}
		goto _4
	_4:
		;
		p3 = (*Tmsgcat)(unsafe.Pointer(p3)).Fnext
	}
	if !(p3 != 0) {
		dirname = (*Tbinding)(unsafe.Pointer(q)).Fdirname
		locname = lm + 16
		catname = uintptr(unsafe.Pointer(&_catnames)) + uintptr(category)*12
		dirlen = uint64((*Tbinding)(unsafe.Pointer(q)).Fdirlen)
		loclen = Xstrlen(tls, locname)
		catlen = uint64(_catlens[category])
		/* Logically split @mod suffix from locale name. */
		modname = Xmemchr(tls, locname, int32('@'), loclen)
		if !(modname != 0) {
			modname = locname + uintptr(loclen)
		}
		v5 = loclen - uint64(int64(modname)-int64(locname))
		modlen = v5
		alt_modlen = v5
		loclen = uint64(int64(modname) - int64(locname))
		/* Drop .charset identifier; it is not used. */
		csp = Xmemchr(tls, locname, int32('.'), loclen)
		if csp != 0 {
			loclen = uint64(int64(csp) - int64(locname))
		}
		v6 = dirlen + uint64(1) + loclen + modlen + uint64(1) + catlen + uint64(1) + domlen + uint64(3) + uint64(1)
		name = Xrealloc(tls, name, v6)
		for {
			Xsnprintf(tls, name, v6, __ccgo_ts+423, VaList(bp+24, dirname, int32(loclen), locname, int32(alt_modlen), modname, catname, domainname))
			v8 = X__map_file(tls, name, bp)
			map1 = v8
			if v8 != 0 {
				break
			}
			/* Try dropping @mod, _YY, then both. */
			if alt_modlen != 0 {
				alt_modlen = uint64(0)
			} else {
				v9 = Xmemchr(tls, locname, int32('_'), loclen)
				locp = v9
				if v9 != 0 {
					loclen = uint64(int64(locp) - int64(locname))
					alt_modlen = modlen
				} else {
					break
				}
			}
			goto _7
		_7:
		}
		if !(map1 != 0) {
			goto notrans
		}
		p3 = Xcalloc(tls, uint64(64), uint64(1))
		if !(p3 != 0) {
			X__munmap(tls, map1, *(*Tsize_t)(unsafe.Pointer(bp)))
			goto notrans
		}
		(*Tmsgcat)(unsafe.Pointer(p3)).Fcat = category
		(*Tmsgcat)(unsafe.Pointer(p3)).Fbinding = q
		(*Tmsgcat)(unsafe.Pointer(p3)).Flm = lm
		(*Tmsgcat)(unsafe.Pointer(p3)).Fmap1 = map1
		(*Tmsgcat)(unsafe.Pointer(p3)).Fmap_size = *(*Tsize_t)(unsafe.Pointer(bp))
		rule = __ccgo_ts + 445
		np = uint64(2)
		r1 = X__mo_lookup(tls, (*Tmsgcat)(unsafe.Pointer(p3)).Fmap1, (*Tmsgcat)(unsafe.Pointer(p3)).Fmap_size, __ccgo_ts)
		for r1 != 0 && Xstrncmp(tls, r1, __ccgo_ts+451, uint64(13)) != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 8)) = Xstrchr(tls, r1, int32('\n'))
			if *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 {
				v10 = *(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(1)
			} else {
				v10 = uintptr(0)
			}
			r1 = v10
		}
		if r1 != 0 {
			r1 += uintptr(13)
			for {
				v11 = int32(*(*uint8)(unsafe.Pointer(r1)))
				v12 = BoolInt32(v11 == int32(' ') || uint32(v11)-uint32('\t') < uint32(5))
				goto _13
			_13:
				if !(v12 != 0) {
					break
				}
				r1++
			}
			if !(Xstrncmp(tls, r1, __ccgo_ts+465, uint64(9)) != 0) {
				np = Xstrtoul(tls, r1+uintptr(9), bp+8, int32(10))
				r1 = *(*uintptr)(unsafe.Pointer(bp + 8))
			}
			for *(*uint8)(unsafe.Pointer(r1)) != 0 && int32(*(*uint8)(unsafe.Pointer(r1))) != int32(';') {
				r1++
			}
			if *(*uint8)(unsafe.Pointer(r1)) != 0 {
				r1++
				for {
					v14 = int32(*(*uint8)(unsafe.Pointer(r1)))
					v15 = BoolInt32(v14 == int32(' ') || uint32(v14)-uint32('\t') < uint32(5))
					goto _16
				_16:
					if !(v15 != 0) {
						break
					}
					r1++
				}
				if !(Xstrncmp(tls, r1, __ccgo_ts+475, uint64(7)) != 0) {
					rule = r1 + uintptr(7)
				}
			}
		}
		(*Tmsgcat)(unsafe.Pointer(p3)).Fnplurals = int32(np)
		(*Tmsgcat)(unsafe.Pointer(p3)).Fplural_rule = rule
		for {
			old_cats = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_cats)))
			(*Tmsgcat)(unsafe.Pointer(p3)).Fnext = old_cats
			goto _25
		_25:
			;
			v17 = uintptr(unsafe.Pointer(&_cats))
			for {
				// __asm__ __volatile__ ("ldaxr %0, %1" : "=r"(v) : "Q"(*(void *volatile *)p));
				X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 41, __ccgo_ts+483)
				v21 = v
				goto _22
			_22:
				old = v21
				if old != old_cats {
					// __asm__ __volatile__ ("dmb ish" : : : "memory");
					X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+483)
					break
				}
				goto _20
			_20:
				;
				// __asm__ __volatile__ ("stlxr %w0,%2,%1" : "=&r"(r), "=Q"(*(void *volatile *)p) : "r"(v) : "memory");
				X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 49, __ccgo_ts+483)
				v18 = BoolInt32(!(r != 0))
				goto _19
			_19:
				;
				if !!(v18 != 0) {
					break
				}
			}
			v23 = old
			goto _24
		_24:
			;
			if !(v23 != old_cats) {
				break
			}
		}
	}
	trans = X__mo_lookup(tls, (*Tmsgcat)(unsafe.Pointer(p3)).Fmap1, (*Tmsgcat)(unsafe.Pointer(p3)).Fmap_size, msgid1)
	if !(trans != 0) {
		goto notrans
	}
	/* Non-plural-processing gettext forms pass a null pointer as
	 * msgid2 to request that dcngettext suppress plural processing. */
	if msgid2 != 0 && (*Tmsgcat)(unsafe.Pointer(p3)).Fnplurals != 0 {
		plural = X__pleval(tls, (*Tmsgcat)(unsafe.Pointer(p3)).Fplural_rule, n)
		if plural > uint64((*Tmsgcat)(unsafe.Pointer(p3)).Fnplurals) {
			goto notrans
		}
		for {
			v26 = plural
			plural--
			if !(v26 != 0) {
				break
			}
			rem = (*Tmsgcat)(unsafe.Pointer(p3)).Fmap_size - uint64(int64(trans)-int64((*Tmsgcat)(unsafe.Pointer(p3)).Fmap1))
			l = Xstrnlen(tls, trans, rem)
			if l+uint64(1) >= rem {
				goto notrans
			}
			trans += uintptr(l + uint64(1))
		}
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = old_errno
	return trans
}

var _cats uintptr

func Xdcgettext(tls *TLS, domainname uintptr, msgid uintptr, category int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v domainname=%v msgid=%v category=%v, (%v:)", tls, domainname, msgid, category, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xdcngettext(tls, domainname, msgid, uintptr(0), uint64(1), category)
}

func Xdngettext(tls *TLS, domainname uintptr, msgid1 uintptr, msgid2 uintptr, n uint64) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v domainname=%v msgid1=%v msgid2=%v n=%v, (%v:)", tls, domainname, msgid1, msgid2, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xdcngettext(tls, domainname, msgid1, msgid2, n, int32(LC_MESSAGES))
}

func Xdgettext(tls *TLS, domainname uintptr, msgid uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v domainname=%v msgid=%v, (%v:)", tls, domainname, msgid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xdcngettext(tls, domainname, msgid, uintptr(0), uint64(1), int32(LC_MESSAGES))
}

func X__duplocale(tls *TLS, old Tlocale_t) (r Tlocale_t) {
	if __ccgo_strace {
		trc("tls=%v old=%v, (%v:)", tls, old, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var new1 Tlocale_t
	_ = new1
	new1 = Xmalloc(tls, uint64(48))
	if !(new1 != 0) {
		return uintptr(0)
	}
	if old == uintptr(-Int32FromInt32(1)) {
		old = uintptr(unsafe.Pointer(&X__libc)) + 56
	}
	*(*t__locale_struct)(unsafe.Pointer(new1)) = *(*t__locale_struct)(unsafe.Pointer(old))
	return new1
}

func Xduplocale(tls *TLS, old Tlocale_t) (r Tlocale_t) {
	if __ccgo_strace {
		trc("tls=%v old=%v, (%v:)", tls, old, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__duplocale(tls, old)
}

func Xfreelocale(tls *TLS, l Tlocale_t) {
	if __ccgo_strace {
		trc("tls=%v l=%v, (%v:)", tls, l, origin(2))
	}
	if X__loc_is_allocated(tls, l) != 0 {
		Xfree(tls, l)
	}
}

func X__freelocale(tls *TLS, l Tlocale_t) {
	if __ccgo_strace {
		trc("tls=%v l=%v, (%v:)", tls, l, origin(2))
	}
	Xfreelocale(tls, l)
}

const BIG5 = 224
const EUC_JP = 208
const EUC_KR = 232
const GB18030 = 216
const GB2312 = 218
const GBK = 217
const ISO2022_JP = 210
const SHIFT_JIS = 209
const UCS2 = 204
const UCS2BE = 196
const UCS2LE = 197
const US_ASCII = 199
const UTF_16 = 202
const UTF_16BE = 194
const UTF_16LE = 193
const UTF_32 = 203
const UTF_32BE = 192
const UTF_32LE = 195
const UTF_8 = 200
const WCHAR_T = 198
const mbrtowc_utf8 = 0
const wctomb_utf8 = 0

type Ticonv_t = uintptr

/* Definitions of charmaps. Each charmap consists of:
 * 1. Empty-string-terminated list of null-terminated aliases.
 * 2. Special type code or number of elided quads of entries.
 * 3. Character table (size determined by field 2), consisting
 *    of 5 bytes for every 4 characters, interpreted as 10-bit
 *    indices into the legacy_chars table. */

var _charmaps = [4907]uint8{'u', 't', 'f', '8', 0, 'c', 'h', 'a', 'r', 0, 0, 200, 'w', 'c', 'h', 'a', 'r', 't', 0, 0, 198, 'u', 'c', 's', '2', 'b', 'e', 0, 0, 196, 'u', 'c', 's', '2', 'l', 'e', 0, 0, 197, 'u', 't', 'f', '1', '6', 'b', 'e', 0, 0, 194, 'u', 't', 'f', '1', '6', 'l', 'e', 0, 0, 193, 'u', 'c', 's', '4', 'b', 'e', 0, 'u', 't', 'f', '3', '2', 'b', 'e', 0, 0, 192, 'u', 'c', 's', '4', 'l', 'e', 0, 'u', 't', 'f', '3', '2', 'l', 'e', 0, 0, 195, 'a', 's', 'c', 'i', 'i', 0, 'u', 's', 'a', 's', 'c', 'i', 'i', 0, 'i', 's', 'o', '6', '4', '6', 0, 'i', 's', 'o', '6', '4', '6', 'u', 's', 0, 0, 199, 'u', 't', 'f', '1', '6', 0, 0, 202, 'u', 'c', 's', '4', 0, 'u', 't', 'f', '3', '2', 0, 0, 203, 'u', 'c', 's', '2', 0, 0, 204, 'e', 'u', 'c', 'j', 'p', 0, 0, 208, 's', 'h', 'i', 'f', 't', 'j', 'i', 's', 0, 's', 'j', 'i', 's', 0, 'c', 'p', '9', '3', '2', 0, 0, 209, 'i', 's', 'o', '2', '0', '2', '2', 'j', 'p', 0, 0, 210, 'g', 'b', '1', '8', '0', '3', '0', 0, 0, 216, 'g', 'b', 'k', 0, 'c', 'p', '9', '3', '6', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '9', '3', '6', 0, 0, 217, 'g', 'b', '2', '3', '1', '2', 0, 0, 218, 'b', 'i', 'g', '5', 0, 'b', 'i', 'g', 'f', 'i', 'v', 'e', 0, 'c', 'p', '9', '5', '0', 0, 'b', 'i', 'g', '5', 'h', 'k', 's', 'c', 's', 0, 0, 224, 'e', 'u', 'c', 'k', 'r', 0, 'k', 's', 'c', '5', '6', '0', '1', 0, 'k', 's', 'x', '1', '0', '0', '1', 0, 'c', 'p', '9', '4', '9', 0, 0, 232, 'i', 's', 'o', '8', '8', '5', '9', '1', 0, 'l', 'a', 't', 'i', 'n', '1', 0, 0, '@', 'i', 's', 'o', '8', '8', '5', '9', '2', 0, 0, '(', 160, 16, 244, 'W', 'N', 164, 220, 244, 212, ')', 168, 'T', '5', 'U', 'V', 'n', 181, '"', 23, '\\', 176, 20, 20, 152, 'N', 180, 224, 4, 149, '_', 184, 'X', 'E', 149, 'V', 'o', 13, '6', 'W', '\\', 'I', 5, '#', 140, '@', 196, 204, 'd', 208, '1', 12, '%', 'c', 209, '2', 24, '5', 227, 140, 'C', 16, 237, 244, 211, '4', 212, 20, 'e', 205, '5', 'M', 141, 165, 'M', 'Y', 220, 't', 's', 213, '7', 'J', 133, '#', 206, '@', 228, 208, 't', 208, '9', 13, 165, 's', 209, ':', 25, 181, 227, 206, 'C', 17, 241, 4, 212, '<', 244, 24, 'e', 207, '=', 'N', 145, 165, 143, 'Y', 252, 244, 131, 21, '`', 'i', 's', 'o', '8', '8', '5', '9', '3', 0, 0, '(', 160, 144, 244, 215, '(', 164, 0, ' ', 210, ')', 168, 176, '4', 21, 'G', '.', 181, 2, 0, '\\', 176, 148, '$', 203, ',', 180, 212, '2', 210, '-', 184, 180, 'D', 'U', 'G', '/', 245, 2, '@', '\\', 192, 4, '#', 12, 0, 196, '(', 132, 208, '1', 200, '$', 163, 204, '2', 204, '4', 227, 204, '3', 0, 'D', '#', 205, '4', 212, 'x', 'd', 205, '5', 26, 'e', 163, 205, '6', 220, 132, 21, 213, '7', 224, 132, '#', 14, 0, 228, ',', 148, 208, '9', 232, 164, 163, 206, ':', 236, 180, 227, 206, ';', 0, 196, '#', 207, '<', 244, '|', 'd', 207, '=', 27, 229, 163, 207, '>', 252, 136, '%', 21, '`', 'i', 's', 'o', '8', '8', '5', '9', '4', 0, 0, '(', 160, 16, '$', 211, 'R', 164, 152, 'T', 211, ')', 168, 'T', '%', 17, 'H', '[', 181, '"', 215, '+', 176, 20, 20, 24, 'S', 180, 156, 'd', 147, '_', 184, 'X', '5', 'Q', 'H', '\\', 5, '5', 151, 'P', 0, 5, '#', 204, '0', 196, 20, 'c', 140, 'J', 12, '%', 'c', 209, '2', 20, '5', 227, 12, 'J', 16, 245, '4', 20, 'L', 212, 'T', 'c', 205, '5', 216, 156, 165, 205, '6', 220, 't', 245, 213, '7', 1, 133, '#', 206, '8', 228, 148, 'c', 206, 'J', 13, 165, 's', 209, ':', 21, 181, 227, 'N', 'J', 17, 249, 'D', 'T', 'L', 244, 212, 'c', 207, '=', 248, 160, 165, 207, '>', 252, 'x', 5, 22, '`', 'i', 's', 'o', '8', '8', '5', '9', '5', 0, 0, '(', 160, 'D', '\'', 221, 't', 212, 'U', 'g', 221, 'u', 216, 'e', 167, 221, 'v', 220, 181, 210, 157, 'w', 223, 129, 23, 158, 'x', 227, 145, 'W', 158, 'y', 231, 161, 151, 158, 'z', 235, 177, 215, 158, '{', 239, 193, 23, 159, '|', 243, 209, 'W', 159, '}', 247, 225, 151, 159, '~', 251, 241, 215, 159, 127, 255, 1, 24, 160, 128, 3, 18, 'X', 160, 129, 7, '"', 152, 160, 130, 11, '2', 216, 160, 131, 15, 'B', 24, 161, 132, 19, 'R', 'X', 161, 133, 23, 'b', 152, 161, 134, 27, 'r', 216, 161, 135, '&', 127, 8, 'b', 136, '"', 142, 'H', 'b', 137, '&', 158, 136, 'b', 138, '*', 158, 178, '"', 139, 'i', 's', 'o', '8', '8', '5', '9', '6', 0, 0, '(', 160, 0, 0, 0, 0, 164, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'b', 182, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 152, 0, 0, 0, 0, 153, 0, 148, 'i', 230, 153, 'h', 166, 169, 230, 154, 'l', 182, 233, 230, 155, 'p', 198, ')', 231, 156, 't', 214, 'i', 231, 157, 'x', 230, 169, 231, 158, '|', 246, 233, '\'', 0, 0, 0, 0, 0, 0, 127, 2, 26, 168, 160, 131, 18, 'Z', 168, 161, 135, '"', 154, 168, 162, 139, '2', 218, 168, 163, 143, 'B', 26, ')', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'i', 's', 'o', '8', '8', '5', '9', '7', 0, 0, '(', 160, 'L', 'L', 241, '(', '$', 151, 'l', 202, ')', 168, 164, 146, 216, '*', 172, 180, 2, '@', 196, 176, 196, '"', 203, ',', 138, '-', 198, 216, '-', 141, '9', 246, 216, '.', 144, 245, 18, 153, 'd', 147, 'Q', 'V', 153, 'e', 151, 'a', 150, 153, 'f', 155, 'q', 214, 153, 'g', 159, 129, 22, 154, 'h', 163, 145, 6, '@', 'i', 166, 157, 134, 'Z', 'j', 170, 173, 198, 'Z', 'k', 174, 189, 6, '[', 'l', 178, 205, 'F', '[', 'm', 182, 221, 134, '[', 'n', 186, 237, 198, '[', 'o', 190, 253, 6, '\\', 'p', 194, 13, 'G', '\\', 'q', 198, 29, 135, '\\', 'r', 202, '-', 199, '\\', 's', 206, '=', 7, 29, 0, 'i', 's', 'o', '8', '8', '5', '9', '8', 0, 0, '(', 160, 0, ' ', 202, '(', 164, 148, 'b', 202, ')', 168, 164, 'r', 205, '*', 172, 180, 226, 202, '+', 176, 196, '"', 203, ',', 180, 212, 'b', 203, '-', 184, 228, 'r', 207, '.', 188, 244, 226, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 196, 'B', 14, 'I', 'd', 145, 'F', 30, 137, 'd', 146, 'J', '.', 201, 'd', 147, 'N', '>', 9, 'e', 148, 'R', 'N', 'I', 'e', 149, 'V', '^', 137, 'e', 150, 'Z', 'n', 201, '%', 0, 0, '4', 236, '0', 0, 'i', 's', 'o', '8', '8', '5', '9', '9', 0, 0, '4', 28, 'E', '#', 205, '4', 212, 'T', 'c', 205, '5', 216, 'd', 163, 205, '6', 220, 176, '4', 213, '7', 224, 132, '#', 206, '8', 228, 148, 'c', 206, '9', 232, 164, 163, 206, ':', 236, 180, 227, 206, ';', 29, 197, '#', 207, '<', 244, 212, 'c', 207, '=', 248, 228, 163, 207, '>', 252, 180, 'D', 213, '?', 'i', 's', 'o', '8', '8', '5', '9', '1', '0', 0, 0, '(', 160, 16, '$', 17, 'H', '(', 153, 4, 211, ')', '5', 'A', 'T', 213, 'V', 'r', 181, 242, 'U', 'P', 176, 20, '4', 'Q', 'H', ')', 157, 20, 211, '-', '6', 'E', 'd', 21, 'W', 's', 'E', 12, 150, 'P', 0, 5, '#', 204, '0', 196, 20, 'c', 140, 'J', 12, '%', 'c', 209, '2', 20, '5', 227, 204, '3', 208, 244, '4', 212, '4', 212, 'T', 'c', 'M', 'W', 216, 156, 165, 205, '6', 220, 't', 227, 205, '7', 1, 133, '#', 206, '8', 228, 148, 'c', 206, 'J', 13, 165, 's', 209, ':', 21, 181, 227, 206, ';', 240, 248, 'D', 212, '<', 244, 212, 'c', 143, 'W', 248, 160, 165, 207, '>', 252, 244, 227, 143, 'L', 'i', 's', 'o', '8', '8', '5', '9', '1', '1', 0, 't', 'i', 's', '6', '2', '0', 0, 0, '(', 160, 'x', 250, ')', 168, 161, 138, ':', '*', 169, 165, 154, 'z', '*', 170, 169, 170, 186, '*', 171, 173, 186, 250, '*', 172, 177, 202, ':', '+', 173, 181, 218, 'z', '+', 174, 185, 234, 186, '+', 175, 189, 250, 250, '+', 176, 193, 10, ';', ',', 177, 197, 26, '{', ',', 178, 201, '*', 187, ',', 179, 205, ':', 251, ',', 180, 209, 'J', ';', '-', 181, 213, 'Z', '{', '-', 0, 0, 0, 0, 0, 182, 217, 'j', 187, '-', 183, 221, 'z', 251, '-', 184, 225, 138, ';', '.', 185, 229, 154, '{', '.', 186, 233, 170, 187, '.', 187, 237, 186, 251, '.', 188, 241, 202, ';', '/', 189, 0, 0, 0, 0, 0, 'i', 's', 'o', '8', '8', '5', '9', '1', '3', 0, 0, '(', 160, '\\', ',', 202, '(', 164, '`', 'l', 202, ')', 216, 164, 178, 212, '*', 172, 180, 226, 138, '1', 176, 196, '"', 203, ',', 22, 215, 'b', 203, '-', 248, 228, 194, 212, '.', 188, 244, 226, 139, '9', 4, 169, 4, 144, 'A', 196, 20, 'c', 145, 'D', 12, '%', 227, 22, 'E', ' ', 193, 132, 'R', 'M', 'U', 237, 212, 211, '4', 'C', 'U', 'c', 205, '5', 'g', 229, 244, 212, 'W', 220, 192, '%', 215, '7', 5, 173, 20, 208, 'A', 228, 148, 's', 209, 'D', 13, 165, 243, 'V', 'E', '!', 197, 148, 146, 'M', 'V', 241, 228, 211, '<', 'D', 213, 'c', 207, '=', 'h', 233, 4, 21, 'X', 252, 196, '5', 23, 197, 'i', 's', 'o', '8', '8', '5', '9', '1', '4', 0, 0, '(', 160, 212, 'k', 239, '(', 10, '-', 't', 239, ')', 3, 167, 'R', '0', 190, 9, 183, 226, 'J', '[', 249, 234, 235, 209, 'G', 251, 242, 'k', 'K', 191, 4, 251, 'k', 240, 191, 10, 31, 140, '0', 192, 192, 4, '#', 204, '0', 196, 20, 'c', 204, '1', 200, '$', 163, 204, '2', 204, '4', 227, 204, '3', 'i', 'E', '#', 205, '4', 212, 'T', 'c', 'M', 192, 216, 'd', 163, 205, '6', 220, 't', 179, 214, '7', 224, 132, '#', 206, '8', 228, 148, 'c', 206, '9', 232, 164, 163, 206, ':', 236, 180, 227, 206, ';', 'j', 197, '#', 207, '<', 244, 212, 'c', 143, 192, 248, 228, 163, 207, '>', 252, 244, 195, 214, '?', 'i', 's', 'o', '8', '8', '5', '9', '1', '5', 0, 'l', 'a', 't', 'i', 'n', '9', 0, 0, ')', '$', 151, 'R', 213, ')', 'V', 165, 162, 202, '*', 172, 180, 226, 202, '+', 176, 196, '"', 203, ',', 'r', 213, 'b', 203, '-', 's', 229, 162, 203, '.', 'G', '!', 213, 214, '/', 192, 4, '#', 204, '0', 196, 20, 'c', 204, '1', 200, '$', 163, 204, '2', 204, '4', 227, 204, '3', 208, 'D', '#', 205, '4', 212, 'T', 'c', 205, '5', 216, 'd', 163, 205, '6', 220, 't', 227, 205, '7', 224, 132, '#', 206, '8', 228, 148, 'c', 206, '9', 232, 164, 163, 206, ':', 236, 180, 227, 206, ';', 240, 196, '#', 207, '<', 244, 212, 'c', 207, '=', 248, 228, 163, 207, '>', 252, 244, 227, 207, '?', 'i', 's', 'o', '8', '8', '5', '9', '1', '6', 0, 0, '(', 160, 16, 'T', 'P', 'N', '$', 'c', '\\', 213, ')', 'V', 165, 146, 215, '*', 'n', 181, 242, 22, '\\', 176, 196, 194, 144, 'N', 'r', ']', 'l', 203, '-', 's', '5', 164, 215, '.', 'G', '!', 213, 'V', '\\', 192, 4, '#', 140, '@', 196, 24, 'd', 204, '1', 200, '$', 163, 204, '2', 204, '4', 227, 204, '3', 16, 237, '$', 205, '4', 212, 20, 'e', 205, 'S', 'e', 'e', 163, 205, '6', 220, 'X', 180, 215, '7', 224, 132, '#', 206, '@', 228, 28, 'd', 206, '9', 232, 164, 163, 206, ':', 236, 180, 227, 206, ';', 17, 241, '$', 207, '<', 244, 24, 'e', 15, 'T', 'f', 229, 163, 207, '>', 252, '\\', 196, 215, '?', 'c', 'p', '1', '2', '5', '0', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '0', 0, 0, ' ', '$', 3, 'P', '1', 0, 24, 's', 156, 177, 198, 0, 't', '\\', 149, 199, 'O', 'e', '%', 151, '[', 0, 'L', 'L', 177, 197, 23, 'o', 252, '0', 196, 0, 156, 'l', 213, 199, 'P', 'i', '5', 215, '[', 160, 248, 245, 'W', 'N', 164, 16, 'd', 202, ')', 168, 164, '2', 213, '*', 172, 180, 226, 10, '\\', 176, 196, 18, 152, 'N', 180, 212, 'b', 203, '-', 184, 20, 'D', 213, '.', '7', 13, 134, 'S', '\\', 'I', 5, '#', 140, '@', 196, 204, 'd', 208, '1', 12, '%', 'c', 209, '2', 24, '5', 227, 140, 'C', 16, 237, 244, 211, '4', 212, 20, 'e', 205, '5', 'M', 141, 165, 'M', 'Y', 220, 't', 's', 213, '7', 'J', 133, '#', 206, '@', 228, 208, 't', 208, '9', 13, 165, 's', 209, ':', 25, 181, 227, 206, 'C', 17, 241, 4, 212, '<', 244, 24, 'e', 207, '=', 'N', 145, 165, 143, 'Y', 252, 244, 131, 21, '`', 'c', 'p', '1', '2', '5', '1', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '1', 0, 0, ' ', 210, 'M', 'W', 'q', 136, 24, 's', 156, 177, 198, '$', 'w', 156, 157, 199, 218, 'q', 183, 157, 'w', ' ', 'N', 'L', 177, 197, 23, 'o', 252, '0', 196, 0, 156, '|', 226, 199, '(', 170, 152, '"', 139, 160, 't', 183, '"', 'v', 164, 180, 'h', 202, ')', 209, 165, 'B', 221, '*', 172, 180, 226, 202, 'u', 176, 196, 'b', 29, 137, '.', 214, 'b', 203, '-', 31, 154, ',', 226, '.', '&', 'V', '7', 'b', 137, 223, 129, 23, 158, 'x', 227, 145, 'W', 158, 'y', 231, 161, 151, 158, 'z', 235, 177, 215, 158, '{', 239, 193, 23, 159, '|', 243, 209, 'W', 159, '}', 247, 225, 151, 159, '~', 251, 241, 215, 159, 127, 255, 1, 24, 160, 128, 3, 18, 'X', 160, 129, 7, '"', 152, 160, 130, 11, '2', 216, 160, 131, 15, 'B', 24, 161, 132, 19, 'R', 'X', 161, 133, 23, 'b', 152, 161, 134, 27, 'r', 216, 161, 135, 'c', 'p', '1', '2', '5', '2', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '2', 0, 0, ' ', '$', 3, 'P', '1', ']', 24, 's', 156, 177, 198, '}', 'u', '\\', 149, 199, 'G', 1, ' ', 23, 0, 0, 'L', 'L', 177, 197, 23, 'o', 252, '0', 196, 130, 157, 'l', 213, 199, 'H', 1, '0', 'W', '[', 160, 132, '"', 202, '(', 164, 148, 'b', 202, ')', 168, 164, 162, 202, '*', 172, 180, 226, 202, '+', 176, 196, '"', 203, ',', 180, 212, 'b', 203, '-', 184, 228, 162, 203, '.', 188, 244, 226, 203, '/', 192, 4, '#', 204, '0', 196, 20, 'c', 204, '1', 200, '$', 163, 204, '2', 204, '4', 227, 204, '3', 208, 'D', '#', 205, '4', 212, 'T', 'c', 205, '5', 216, 'd', 163, 205, '6', 220, 't', 227, 205, '7', 224, 132, '#', 206, '8', 228, 148, 'c', 206, '9', 232, 164, 163, 206, ':', 236, 180, 227, 206, ';', 240, 196, '#', 207, '<', 244, 212, 'c', 207, '=', 248, 228, 163, 207, '>', 252, 244, 227, 207, '?', 'c', 'p', '1', '2', '5', '3', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '3', 0, 0, ' ', '$', 3, 'P', '1', ']', 24, 's', 156, 177, 198, 0, 't', 12, 128, 199, 0, 0, 0, 0, 0, 0, 'L', 'L', 177, 197, 23, 'o', 252, '0', 196, 0, 156, 12, 192, 199, 0, 0, 0, 0, 0, 160, ',', 198, 216, '(', 164, 148, 'b', 202, ')', 168, 164, 2, 192, '*', 172, 180, 226, 'J', 196, 176, 196, '"', 203, ',', 138, 213, 'b', 203, '-', 141, '9', 246, 216, '.', 144, 245, 18, 153, 'd', 147, 'Q', 'V', 153, 'e', 151, 'a', 150, 153, 'f', 155, 'q', 214, 153, 'g', 159, 129, 22, 154, 'h', 163, 145, 6, '@', 'i', 166, 157, 134, 'Z', 'j', 170, 173, 198, 'Z', 'k', 174, 189, 6, '[', 'l', 178, 205, 'F', '[', 'm', 182, 221, 134, '[', 'n', 186, 237, 198, '[', 'o', 190, 253, 6, '\\', 'p', 194, 13, 'G', '\\', 'q', 198, 29, 135, '\\', 'r', 202, '-', 199, '\\', 's', 206, '=', 7, 29, 0, 'c', 'p', '1', '2', '5', '4', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '4', 0, 0, ' ', '$', 3, 'P', '1', ']', 24, 's', 156, 177, 198, '}', 'u', '\\', 149, 199, 'G', 1, 0, 0, 0, 0, 'L', 'L', 177, 197, 23, 'o', 252, '0', 196, 130, 157, 'l', 213, 199, 'H', 1, 0, '@', '[', 160, 132, '"', 202, '(', 164, 148, 'b', 202, ')', 168, 164, 162, 202, '*', 172, 180, 226, 202, '+', 176, 196, '"', 203, ',', 180, 212, 'b', 203, '-', 184, 228, 162, 203, '.', 188, 244, 226, 203, '/', 192, 4, '#', 204, '0', 196, 20, 'c', 204, '1', 200, '$', 163, 204, '2', 204, '4', 227, 204, '3', 28, 'E', '#', 205, '4', 212, 'T', 'c', 205, '5', 216, 'd', 163, 205, '6', 220, 176, '4', 213, '7', 224, 132, '#', 206, '8', 228, 148, 'c', 206, '9', 232, 164, 163, 206, ':', 236, 180, 227, 206, ';', 29, 197, '#', 207, '<', 244, 212, 'c', 207, '=', 248, 228, 163, 207, '>', 252, 180, 'D', 213, '?', 'c', 'p', '1', '2', '5', '5', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '5', 0, 0, ' ', '$', 3, 'P', '1', ']', 24, 's', 156, 177, 198, '}', 'u', 12, 128, 199, 0, 0, 0, 0, 0, 0, 'L', 'L', 177, 197, 23, 'o', 252, '0', 196, 130, 157, 12, 192, 199, 0, 0, 0, 0, 0, 160, 132, '"', 202, '(', '"', 151, 'b', 202, ')', 168, 164, 'r', 205, '*', 172, 180, 226, 202, '+', 176, 196, '"', 203, ',', 180, 212, 'b', 203, '-', 184, 228, 'r', 207, '.', 188, 244, 226, 203, '/', '/', 194, 24, 163, 140, '3', 210, 'X', 163, 141, '7', 226, 8, '@', 142, ':', 238, 200, 'c', 143, '>', 254, 8, 'd', 144, ']', 'z', 249, '%', 152, 'a', 2, 0, 0, 0, 0, 0, 0, 0, 0, 'B', 14, 'I', 'd', 145, 'F', 30, 137, 'd', 146, 'J', '.', 201, 'd', 147, 'N', '>', 9, 'e', 148, 'R', 'N', 'I', 'e', 149, 'V', '^', 137, 'e', 150, 'Z', 'n', 201, '%', 0, 0, '4', 236, '0', 0, 'c', 'p', '1', '2', '5', '6', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '6', 0, 0, ' ', '$', 'O', 'Z', '1', ']', 24, 's', 156, 177, 198, '}', 'u', ',', 169, 199, 'G', 'Q', 'z', 'i', 165, 153, 'N', 'L', 177, 197, 23, 'o', 252, '0', 196, 152, 158, 'l', 233, 199, 'H', '-', 204, 176, 166, 160, 136, ')', 202, '(', 164, 148, 'b', 202, ')', 168, 164, 178, 233, '*', 172, 180, 226, 202, '+', 176, 196, '"', 203, ',', 180, 212, 'b', 203, '-', 184, 228, '2', 230, '.', 188, 244, 226, 11, 153, 156, 150, 'i', 230, 153, 'h', 166, 169, 230, 154, 'l', 182, 233, 230, 155, 'p', 198, ')', 231, 156, 't', 214, 'i', 231, 157, 'x', 230, 169, 231, '5', '{', 242, 217, 167, 159, 127, 2, 26, 168, 160, 224, 12, '*', 14, 161, 133, 26, 'z', 232, '9', 232, 164, 163, 206, ':', 136, '&', 234, 206, ';', 138, '.', 202, 'h', 163, 244, '8', 250, 232, '=', 144, 230, 19, 233, '>', 252, '4', 236, 'p', 167, 'c', 'p', '1', '2', '5', '7', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '7', 0, 0, ' ', '$', 3, 'P', '1', 0, 24, 's', 156, 177, 198, 0, 't', 12, 128, 199, 0, 160, 226, 23, '.', 0, 'L', 'L', 177, 197, 23, 'o', 252, '0', 196, 0, 156, 12, 192, 199, 0, 188, 18, 24, 0, 160, 0, ' ', 202, '(', 164, 0, '`', 202, ')', 216, 164, 178, 212, '*', 172, 180, 226, 138, '1', 176, 196, '"', 203, ',', 180, 212, 'b', 203, '-', 248, 228, 194, 212, '.', 188, 244, 226, 139, '9', 4, 169, 4, 144, 'A', 196, 20, 'c', 145, 'D', 12, '%', 227, 22, 'E', ' ', 193, 132, 'R', 'M', 'U', 237, 212, 211, '4', 'C', 'U', 'c', 205, '5', 'g', 229, 244, 212, 'W', 220, 192, '%', 215, '7', 5, 173, 20, 208, 'A', 228, 148, 's', 209, 'D', 13, 165, 243, 'V', 'E', '!', 197, 148, 146, 'M', 'V', 241, 228, 211, '<', 'D', 213, 'c', 207, '=', 'h', 233, 4, 21, 'X', 252, 196, '5', 23, '`', 'c', 'p', '1', '2', '5', '8', 0, 'w', 'i', 'n', 'd', 'o', 'w', 's', '1', '2', '5', '8', 0, 0, ' ', '$', 3, 'P', '1', ']', 24, 's', 156, 177, 198, '}', 'u', 12, 128, 199, 'G', 1, 0, 0, 0, 0, 'L', 'L', 177, 197, 23, 'o', 252, '0', 196, 130, 157, 12, 192, 199, 'H', 1, 0, '@', '[', 160, 132, '"', 202, '(', 164, 148, 'b', 202, ')', 168, 164, 162, 202, '*', 172, 180, 226, 202, '+', 176, 196, '"', 203, ',', 180, 212, 'b', 203, '-', 184, 228, 162, 203, '.', 188, 244, 226, 203, '/', 192, 4, '#', 140, '@', 196, 20, 'c', 204, '1', 200, '$', 163, 204, '2', 132, '5', 227, 204, '3', 16, 'E', 's', 216, '4', 212, 212, 'e', 205, '5', 216, 'd', 163, 205, '6', 220, 220, 'e', 216, '7', 224, 132, '#', 206, '@', 228, 148, 'c', 206, '9', 232, 164, 163, 206, ':', 133, 181, 227, 206, ';', 17, 197, 131, 216, '<', 244, 216, 'e', 207, '=', 248, 228, 163, 207, '>', 252, 224, '5', 242, '?', 'k', 'o', 'i', '8', 'r', 0, 0, ' ', '3', 211, '\\', 179, 205, '7', 227, 156, 179, 206, ';', 243, 220, 243, 214, '\\', 'w', 237, 245, 215, '`', 135, '-', 'v', 204, 'c', 163, 156, '2', 203, '.', 191, 12, 138, 204, 176, 200, 'r', 203, '=', '>', 255, 12, 244, 135, 'A', 11, '=', '4', 209, 'E', 27, '}', '4', 210, 'I', '+', 189, '4', 211, 'M', ';', 253, 't', 't', 'P', 'G', '-', 245, 212, 'T', 'W', 'm', 245, 213, 'X', 'g', 173, 'u', '*', 29, 254, 7, '`', 133, 3, 18, '8', 161, 128, 20, 30, 136, '`', 130, 10, '.', 200, '`', 131, 14, 'z', 248, ' ', 132, 17, 'J', 'X', '`', 128, 27, 'j', 'h', 224, 133, 28, 'b', 'h', 'a', 134, 253, '}', 7, '^', '}', 227, 145, '7', 159, 'x', 244, 157, 135, '^', 'z', 234, 173, 199, '^', '{', 238, 249, 247, 30, '|', 241, 201, 'W', '^', 'x', 251, 233, 'g', 222, '}', 252, 225, 'g', '_', '~', 'k', 'o', 'i', '8', 'u', 0, 0, ' ', '3', 211, '\\', 179, 205, '7', 227, 156, 179, 206, ';', 243, 220, 243, 214, '\\', 'w', 237, 245, 215, '`', 135, '-', 'v', 204, 'c', 163, 156, '2', 203, '.', 191, 12, 138, 204, 176, 200, 'r', 203, '=', '>', 255, 12, 244, 135, '"', 10, 'M', 'b', 137, 'E', 27, '}', '4', 210, 'I', 187, 184, '4', 211, 'M', ';', 253, 't', 't', 212, 'E', 'm', 221, 'u', 'T', 'W', 'm', 245, 213, 'X', 183, 168, 'u', '*', 29, 254, 7, '`', 133, 3, 18, '8', 161, 128, 20, 30, 136, '`', 130, 10, '.', 200, '`', 131, 14, 'z', 248, ' ', 132, 17, 'J', 'X', '`', 128, 27, 'j', 'h', 224, 133, 28, 'b', 'h', 'a', 134, 253, '}', 7, '^', '}', 227, 145, '7', 159, 'x', 244, 157, 135, '^', 'z', 234, 173, 199, '^', '{', 238, 249, 247, 30, '|', 241, 201, 'W', '^', 'x', 251, 233, 'g', 222, '}', 252, 225, 'g', '_', '~', 'c', 'p', '4', '3', '7', 0, 0, ' ', 199, 240, 147, 142, '8', 228, 128, 'S', 206, '9', 234, 172, 131, 206, ';', 238, 176, 'C', 'L', '1', 201, 152, 'c', 12, '=', 246, 200, 179, 'O', '>', 255, 'X', 195, 141, '(', 163, 148, 18, '2', ']', 225, 180, '3', 143, '>', 241, 'D', 163, 138, '.', 191, 192, 204, 'J', '/', 188, 132, 178, 202, '.', '`', 135, '-', '6', 205, ':', '?', 13, '5', 209, 'C', 'G', 253, 's', 209, 'K', '+', 157, 180, 205, '7', 243, 188, 's', 206, '3', 247, 204, 't', 211, 'H', 11, '}', '5', 213, 'N', 251, 172, 'u', 213, 'V', 'K', '=', 245, 209, 'F', 3, 29, 't', 214, 'X', 227, '\\', 's', 215, '\\', '{', 253, 245, 214, 179, '}', 'c', 153, 'p', 165, 21, 'W', 139, 'q', 168, 'm', 182, 154, 'm', '*', '#', 'w', 219, 202, '-', 199, 242, 178, 203, '1', 203, '|', 15, 203, 176, 160, '|', 'K', 202, ' ', 203, '2', '6', '(', 'c', 'p', '8', '5', '0', 0, 0, ' ', 199, 240, 147, 142, '8', 228, 128, 'S', 206, '9', 234, 172, 131, 206, ';', 238, 176, 'C', 'L', '1', 201, 152, 'c', 12, '=', 246, 200, 179, 'O', '>', 255, 'X', 195, 13, '>', 163, '`', 's', 13, ']', 225, 180, '3', 143, '>', 241, 'D', 163, 138, '.', 191, 184, 194, 'J', '/', 188, 132, 178, 202, '.', '`', 135, '-', '6', 205, ':', 7, '#', 12, '0', 169, 'D', 253, 's', 209, 'K', 139, 'R', 138, 205, '7', 243, 188, 's', 206, '3', 247, '<', 206, '0', 'H', 11, '}', '5', 213, 'N', 251, 172, '5', ')', 240, '@', 163, 204, '2', 200, 180, 212, 140, '3', 207, 224, '\\', 's', 215, '\\', 155, 194, 204, 214, 211, '|', 'C', 141, '4', 245, 'T', 'S', 139, '?', 222, 'h', 179, 'M', '6', 253, 't', 243, 10, '-', 173, 196, '"', 177, '/', 182, 156, 'r', 15, '.', 176, 160, 'r', 'K', '.', 179, 200, '2', '6', '(', 'c', 'p', '8', '6', '6', 0, 0, ' ', 223, 129, 23, 158, 'x', 227, 145, 'W', 158, 'y', 231, 161, 151, 158, 'z', 235, 177, 215, 158, '{', 239, 193, 23, 159, '|', 243, 209, 'W', 159, '}', 247, 225, 151, 159, '~', 251, 241, 215, 159, 127, 255, 1, 24, 160, 128, 3, 18, 'X', 160, 129, 7, '"', 152, 160, 130, 11, '2', 216, 160, 131, '`', 135, '-', '6', 205, ':', '?', 13, '5', 209, 'C', 'G', 253, 's', 209, 'K', '+', 157, 180, 205, '7', 243, 188, 's', 206, '3', 247, 204, 't', 211, 'H', 11, '}', '5', 213, 'N', 251, 172, 'u', 213, 'V', 'K', '=', 245, 209, 'F', 3, 29, 't', 214, 'X', 227, '\\', 's', 215, '\\', '{', 253, 245, 214, 15, 'B', 24, 161, 132, 19, 'R', 'X', 161, 133, 23, 'b', 152, 161, 134, 27, 'r', 216, 161, 135, 209, '}', 'H', 157, 136, 215, 149, 216, 221, 138, 176, 160, '|', 'K', 202, '&', 147, '2', '6', '(', 'i', 'b', 'm', '1', '0', '4', '7', 0, 'c', 'p', '1', '0', '4', '7', 0, 0, 1, 156, '$', '`', 200, 31, 151, '4', 226, 200, 2, 12, '4', 224, 192, 3, 16, 'D', ' ', 193, 4, 157, 20, 130, 192, '!', 24, 'd', ' ', 201, '#', 28, 't', 224, 193, 7, 128, 4, '"', 200, ' ', 132, '(', 'p', 193, 6, 136, '$', 162, 200, '"', 140, 20, '`', 192, 1, 144, 'D', 'b', 193, '$', 148, 'T', 'b', 9, 1, 152, 'd', 162, 201, '&', 20, 'T', 224, 137, 6, ' ', 128, '"', 14, '9', 224, 132, '3', 'N', '9', 231, 196, '#', 138, 11, '<', 160, 176, 2, 31, '&', 164, 163, 206, ':', 232, 180, 227, 206, ';', 236, '|', 19, 2, 9, '*', 164, 176, 131, 23, '-', 188, ' ', 12, '1', 192, 4, '3', 'L', '1', 199, 'D', 'c', 10, 11, '%', '|', 225, 195, 15, 248, '$', 163, 204, '2', 200, '4', 227, 204, '3', 204, 128, 161, 195, 8, '@', 156, 208, 131, 8, 216, 132, '!', 198, 24, 'd', 148, 'a', 198, 25, 'h', 164, 177, 202, '.', 240, 244, 227, 'O', ',', 176, 168, 177, 6, 27, 'm', 184, 241, 6, 28, 'q', 200, 161, 138, '.', 230, 224, 'b', 12, ')', 181, 248, '1', 7, 29, 'u', 216, 'q', 7, 30, 'y', 232, 17, 202, '/', 208, 'l', 225, 141, '+', 172, 140, 'R', 202, '-', 169, 156, 'b', 11, '/', 189, 248, 210, 13, '*', 175, 't', 'A', 203, '5', '{', 4, '!', 196, 16, 'D', 20, 'a', 196, 17, 'H', '$', 209, 10, '=', 246, 200, '3', 'O', '=', '}', '(', 177, 4, 19, 'M', '8', 241, 4, 20, 'Q', 'H', 145, 203, '>', 252, 228, 163, 207, '?', '\\', 220, '3', 5, 21, 'U', 'X', 'q', 5, 22, 'Y', 'h', '!', 11, '5', 214, 'H', '3', 'M', '5', '0', 196, ' ', 195, 12, '4', 212, '`', 195, 13, '8', 228, '0', 203, '6', 220, 'd', 163, 205, '\''}

// C documentation
//
//	/* Table of characters that appear in legacy 8-bit codepages,
//	 * limited to 1024 slots (10 bit indices). The first 256 entries
//	 * are elided since those characters are obviously all included. */
var _legacy_chars = [612]uint16{
	0:   uint16(256),
	1:   uint16(257),
	2:   uint16(258),
	3:   uint16(259),
	4:   uint16(260),
	5:   uint16(261),
	6:   uint16(262),
	7:   uint16(263),
	8:   uint16(264),
	9:   uint16(265),
	10:  uint16(266),
	11:  uint16(267),
	12:  uint16(268),
	13:  uint16(269),
	14:  uint16(270),
	15:  uint16(271),
	16:  uint16(272),
	17:  uint16(273),
	18:  uint16(274),
	19:  uint16(275),
	20:  uint16(278),
	21:  uint16(279),
	22:  uint16(280),
	23:  uint16(281),
	24:  uint16(282),
	25:  uint16(283),
	26:  uint16(284),
	27:  uint16(285),
	28:  uint16(286),
	29:  uint16(287),
	30:  uint16(288),
	31:  uint16(289),
	32:  uint16(290),
	33:  uint16(291),
	34:  uint16(292),
	35:  uint16(293),
	36:  uint16(294),
	37:  uint16(295),
	38:  uint16(296),
	39:  uint16(297),
	40:  uint16(298),
	41:  uint16(299),
	42:  uint16(302),
	43:  uint16(303),
	44:  uint16(304),
	45:  uint16(305),
	46:  uint16(308),
	47:  uint16(309),
	48:  uint16(310),
	49:  uint16(311),
	50:  uint16(312),
	51:  uint16(313),
	52:  uint16(314),
	53:  uint16(315),
	54:  uint16(316),
	55:  uint16(317),
	56:  uint16(318),
	57:  uint16(321),
	58:  uint16(322),
	59:  uint16(323),
	60:  uint16(324),
	61:  uint16(325),
	62:  uint16(326),
	63:  uint16(327),
	64:  uint16(328),
	65:  uint16(330),
	66:  uint16(331),
	67:  uint16(332),
	68:  uint16(333),
	69:  uint16(336),
	70:  uint16(337),
	71:  uint16(338),
	72:  uint16(339),
	73:  uint16(340),
	74:  uint16(341),
	75:  uint16(342),
	76:  uint16(343),
	77:  uint16(344),
	78:  uint16(345),
	79:  uint16(346),
	80:  uint16(347),
	81:  uint16(348),
	82:  uint16(349),
	83:  uint16(350),
	84:  uint16(351),
	85:  uint16(352),
	86:  uint16(353),
	87:  uint16(354),
	88:  uint16(355),
	89:  uint16(356),
	90:  uint16(357),
	91:  uint16(358),
	92:  uint16(359),
	93:  uint16(360),
	94:  uint16(361),
	95:  uint16(362),
	96:  uint16(363),
	97:  uint16(364),
	98:  uint16(365),
	99:  uint16(366),
	100: uint16(367),
	101: uint16(368),
	102: uint16(369),
	103: uint16(370),
	104: uint16(371),
	105: uint16(372),
	106: uint16(373),
	107: uint16(374),
	108: uint16(375),
	109: uint16(376),
	110: uint16(377),
	111: uint16(378),
	112: uint16(379),
	113: uint16(380),
	114: uint16(381),
	115: uint16(382),
	116: uint16(402),
	117: uint16(416),
	118: uint16(417),
	119: uint16(431),
	120: uint16(432),
	121: uint16(536),
	122: uint16(537),
	123: uint16(538),
	124: uint16(539),
	125: uint16(710),
	126: uint16(711),
	127: uint16(728),
	128: uint16(729),
	129: uint16(731),
	130: uint16(732),
	131: uint16(733),
	132: uint16(768),
	133: uint16(769),
	134: uint16(771),
	135: uint16(777),
	136: uint16(803),
	137: uint16(890),
	138: uint16(900),
	139: uint16(901),
	140: uint16(902),
	141: uint16(904),
	142: uint16(905),
	143: uint16(906),
	144: uint16(908),
	145: uint16(910),
	146: uint16(911),
	147: uint16(912),
	148: uint16(913),
	149: uint16(914),
	150: uint16(915),
	151: uint16(916),
	152: uint16(917),
	153: uint16(918),
	154: uint16(919),
	155: uint16(920),
	156: uint16(921),
	157: uint16(922),
	158: uint16(923),
	159: uint16(924),
	160: uint16(925),
	161: uint16(926),
	162: uint16(927),
	163: uint16(928),
	164: uint16(929),
	165: uint16(931),
	166: uint16(932),
	167: uint16(933),
	168: uint16(934),
	169: uint16(935),
	170: uint16(936),
	171: uint16(937),
	172: uint16(938),
	173: uint16(939),
	174: uint16(940),
	175: uint16(941),
	176: uint16(942),
	177: uint16(943),
	178: uint16(944),
	179: uint16(945),
	180: uint16(946),
	181: uint16(947),
	182: uint16(948),
	183: uint16(949),
	184: uint16(950),
	185: uint16(951),
	186: uint16(952),
	187: uint16(953),
	188: uint16(954),
	189: uint16(955),
	190: uint16(956),
	191: uint16(957),
	192: uint16(958),
	193: uint16(959),
	194: uint16(960),
	195: uint16(961),
	196: uint16(962),
	197: uint16(963),
	198: uint16(964),
	199: uint16(965),
	200: uint16(966),
	201: uint16(967),
	202: uint16(968),
	203: uint16(969),
	204: uint16(970),
	205: uint16(971),
	206: uint16(972),
	207: uint16(973),
	208: uint16(974),
	209: uint16(1025),
	210: uint16(1026),
	211: uint16(1027),
	212: uint16(1028),
	213: uint16(1029),
	214: uint16(1030),
	215: uint16(1031),
	216: uint16(1032),
	217: uint16(1033),
	218: uint16(1034),
	219: uint16(1035),
	220: uint16(1036),
	221: uint16(1038),
	222: uint16(1039),
	223: uint16(1040),
	224: uint16(1041),
	225: uint16(1042),
	226: uint16(1043),
	227: uint16(1044),
	228: uint16(1045),
	229: uint16(1046),
	230: uint16(1047),
	231: uint16(1048),
	232: uint16(1049),
	233: uint16(1050),
	234: uint16(1051),
	235: uint16(1052),
	236: uint16(1053),
	237: uint16(1054),
	238: uint16(1055),
	239: uint16(1056),
	240: uint16(1057),
	241: uint16(1058),
	242: uint16(1059),
	243: uint16(1060),
	244: uint16(1061),
	245: uint16(1062),
	246: uint16(1063),
	247: uint16(1064),
	248: uint16(1065),
	249: uint16(1066),
	250: uint16(1067),
	251: uint16(1068),
	252: uint16(1069),
	253: uint16(1070),
	254: uint16(1071),
	255: uint16(1072),
	256: uint16(1073),
	257: uint16(1074),
	258: uint16(1075),
	259: uint16(1076),
	260: uint16(1077),
	261: uint16(1078),
	262: uint16(1079),
	263: uint16(1080),
	264: uint16(1081),
	265: uint16(1082),
	266: uint16(1083),
	267: uint16(1084),
	268: uint16(1085),
	269: uint16(1086),
	270: uint16(1087),
	271: uint16(1088),
	272: uint16(1089),
	273: uint16(1090),
	274: uint16(1091),
	275: uint16(1092),
	276: uint16(1093),
	277: uint16(1094),
	278: uint16(1095),
	279: uint16(1096),
	280: uint16(1097),
	281: uint16(1098),
	282: uint16(1099),
	283: uint16(1100),
	284: uint16(1101),
	285: uint16(1102),
	286: uint16(1103),
	287: uint16(1105),
	288: uint16(1106),
	289: uint16(1107),
	290: uint16(1108),
	291: uint16(1109),
	292: uint16(1110),
	293: uint16(1111),
	294: uint16(1112),
	295: uint16(1113),
	296: uint16(1114),
	297: uint16(1115),
	298: uint16(1116),
	299: uint16(1118),
	300: uint16(1119),
	301: uint16(1168),
	302: uint16(1169),
	303: uint16(1456),
	304: uint16(1457),
	305: uint16(1458),
	306: uint16(1459),
	307: uint16(1460),
	308: uint16(1461),
	309: uint16(1462),
	310: uint16(1463),
	311: uint16(1464),
	312: uint16(1465),
	313: uint16(1467),
	314: uint16(1468),
	315: uint16(1469),
	316: uint16(1470),
	317: uint16(1471),
	318: uint16(1472),
	319: uint16(1473),
	320: uint16(1474),
	321: uint16(1475),
	322: uint16(1488),
	323: uint16(1489),
	324: uint16(1490),
	325: uint16(1491),
	326: uint16(1492),
	327: uint16(1493),
	328: uint16(1494),
	329: uint16(1495),
	330: uint16(1496),
	331: uint16(1497),
	332: uint16(1498),
	333: uint16(1499),
	334: uint16(1500),
	335: uint16(1501),
	336: uint16(1502),
	337: uint16(1503),
	338: uint16(1504),
	339: uint16(1505),
	340: uint16(1506),
	341: uint16(1507),
	342: uint16(1508),
	343: uint16(1509),
	344: uint16(1510),
	345: uint16(1511),
	346: uint16(1512),
	347: uint16(1513),
	348: uint16(1514),
	349: uint16(1520),
	350: uint16(1521),
	351: uint16(1522),
	352: uint16(1523),
	353: uint16(1524),
	354: uint16(1548),
	355: uint16(1563),
	356: uint16(1567),
	357: uint16(1569),
	358: uint16(1570),
	359: uint16(1571),
	360: uint16(1572),
	361: uint16(1573),
	362: uint16(1574),
	363: uint16(1575),
	364: uint16(1576),
	365: uint16(1577),
	366: uint16(1578),
	367: uint16(1579),
	368: uint16(1580),
	369: uint16(1581),
	370: uint16(1582),
	371: uint16(1583),
	372: uint16(1584),
	373: uint16(1585),
	374: uint16(1586),
	375: uint16(1587),
	376: uint16(1588),
	377: uint16(1589),
	378: uint16(1590),
	379: uint16(1591),
	380: uint16(1592),
	381: uint16(1593),
	382: uint16(1594),
	383: uint16(1600),
	384: uint16(1601),
	385: uint16(1602),
	386: uint16(1603),
	387: uint16(1604),
	388: uint16(1605),
	389: uint16(1606),
	390: uint16(1607),
	391: uint16(1608),
	392: uint16(1609),
	393: uint16(1610),
	394: uint16(1611),
	395: uint16(1612),
	396: uint16(1613),
	397: uint16(1614),
	398: uint16(1615),
	399: uint16(1616),
	400: uint16(1617),
	401: uint16(1618),
	402: uint16(1657),
	403: uint16(1662),
	404: uint16(1670),
	405: uint16(1672),
	406: uint16(1681),
	407: uint16(1688),
	408: uint16(1705),
	409: uint16(1711),
	410: uint16(1722),
	411: uint16(1726),
	412: uint16(1729),
	413: uint16(1746),
	414: uint16(3585),
	415: uint16(3586),
	416: uint16(3587),
	417: uint16(3588),
	418: uint16(3589),
	419: uint16(3590),
	420: uint16(3591),
	421: uint16(3592),
	422: uint16(3593),
	423: uint16(3594),
	424: uint16(3595),
	425: uint16(3596),
	426: uint16(3597),
	427: uint16(3598),
	428: uint16(3599),
	429: uint16(3600),
	430: uint16(3601),
	431: uint16(3602),
	432: uint16(3603),
	433: uint16(3604),
	434: uint16(3605),
	435: uint16(3606),
	436: uint16(3607),
	437: uint16(3608),
	438: uint16(3609),
	439: uint16(3610),
	440: uint16(3611),
	441: uint16(3612),
	442: uint16(3613),
	443: uint16(3614),
	444: uint16(3615),
	445: uint16(3616),
	446: uint16(3617),
	447: uint16(3618),
	448: uint16(3619),
	449: uint16(3620),
	450: uint16(3621),
	451: uint16(3622),
	452: uint16(3623),
	453: uint16(3624),
	454: uint16(3625),
	455: uint16(3626),
	456: uint16(3627),
	457: uint16(3628),
	458: uint16(3629),
	459: uint16(3630),
	460: uint16(3631),
	461: uint16(3632),
	462: uint16(3633),
	463: uint16(3634),
	464: uint16(3635),
	465: uint16(3636),
	466: uint16(3637),
	467: uint16(3638),
	468: uint16(3639),
	469: uint16(3640),
	470: uint16(3641),
	471: uint16(3642),
	472: uint16(3647),
	473: uint16(3648),
	474: uint16(3649),
	475: uint16(3650),
	476: uint16(3651),
	477: uint16(3652),
	478: uint16(3653),
	479: uint16(3654),
	480: uint16(3655),
	481: uint16(3656),
	482: uint16(3657),
	483: uint16(3658),
	484: uint16(3659),
	485: uint16(3660),
	486: uint16(3661),
	487: uint16(3662),
	488: uint16(3663),
	489: uint16(3664),
	490: uint16(3665),
	491: uint16(3666),
	492: uint16(3667),
	493: uint16(3668),
	494: uint16(3669),
	495: uint16(3670),
	496: uint16(3671),
	497: uint16(3672),
	498: uint16(3673),
	499: uint16(3674),
	500: uint16(3675),
	501: uint16(7682),
	502: uint16(7683),
	503: uint16(7690),
	504: uint16(7691),
	505: uint16(7710),
	506: uint16(7711),
	507: uint16(7744),
	508: uint16(7745),
	509: uint16(7766),
	510: uint16(7767),
	511: uint16(7776),
	512: uint16(7777),
	513: uint16(7786),
	514: uint16(7787),
	515: uint16(7808),
	516: uint16(7809),
	517: uint16(7810),
	518: uint16(7811),
	519: uint16(7812),
	520: uint16(7813),
	521: uint16(7922),
	522: uint16(7923),
	523: uint16(8204),
	524: uint16(8205),
	525: uint16(8206),
	526: uint16(8207),
	527: uint16(8211),
	528: uint16(8212),
	529: uint16(8213),
	530: uint16(8215),
	531: uint16(8216),
	532: uint16(8217),
	533: uint16(8218),
	534: uint16(8220),
	535: uint16(8221),
	536: uint16(8222),
	537: uint16(8224),
	538: uint16(8225),
	539: uint16(8226),
	540: uint16(8230),
	541: uint16(8240),
	542: uint16(8249),
	543: uint16(8250),
	544: uint16(8319),
	545: uint16(8359),
	546: uint16(8362),
	547: uint16(8363),
	548: uint16(8364),
	549: uint16(8367),
	550: uint16(8470),
	551: uint16(8482),
	552: uint16(8729),
	553: uint16(8730),
	554: uint16(8734),
	555: uint16(8745),
	556: uint16(8776),
	557: uint16(8801),
	558: uint16(8804),
	559: uint16(8805),
	560: uint16(8976),
	561: uint16(8992),
	562: uint16(8993),
	563: uint16(9472),
	564: uint16(9474),
	565: uint16(9484),
	566: uint16(9488),
	567: uint16(9492),
	568: uint16(9496),
	569: uint16(9500),
	570: uint16(9508),
	571: uint16(9516),
	572: uint16(9524),
	573: uint16(9532),
	574: uint16(9552),
	575: uint16(9553),
	576: uint16(9554),
	577: uint16(9555),
	578: uint16(9556),
	579: uint16(9557),
	580: uint16(9558),
	581: uint16(9559),
	582: uint16(9560),
	583: uint16(9561),
	584: uint16(9562),
	585: uint16(9563),
	586: uint16(9564),
	587: uint16(9565),
	588: uint16(9566),
	589: uint16(9567),
	590: uint16(9568),
	591: uint16(9569),
	592: uint16(9570),
	593: uint16(9571),
	594: uint16(9572),
	595: uint16(9573),
	596: uint16(9574),
	597: uint16(9575),
	598: uint16(9576),
	599: uint16(9577),
	600: uint16(9578),
	601: uint16(9579),
	602: uint16(9580),
	603: uint16(9600),
	604: uint16(9604),
	605: uint16(9608),
	606: uint16(9612),
	607: uint16(9616),
	608: uint16(9617),
	609: uint16(9618),
	610: uint16(9619),
	611: uint16(9632),
}

var _jis0208 = [84][94]uint16{
	0: {
		0:  uint16(12288),
		1:  uint16(12289),
		2:  uint16(12290),
		3:  uint16(65292),
		4:  uint16(65294),
		5:  uint16(12539),
		6:  uint16(65306),
		7:  uint16(65307),
		8:  uint16(65311),
		9:  uint16(65281),
		10: uint16(12443),
		11: uint16(12444),
		12: uint16(180),
		13: uint16(65344),
		14: uint16(168),
		15: uint16(65342),
		16: uint16(65507),
		17: uint16(65343),
		18: uint16(12541),
		19: uint16(12542),
		20: uint16(12445),
		21: uint16(12446),
		22: uint16(12291),
		23: uint16(20189),
		24: uint16(12293),
		25: uint16(12294),
		26: uint16(12295),
		27: uint16(12540),
		28: uint16(8213),
		29: uint16(8208),
		30: uint16(65295),
		31: uint16(92),
		32: uint16(12316),
		33: uint16(8214),
		34: uint16(65372),
		35: uint16(8230),
		36: uint16(8229),
		37: uint16(8216),
		38: uint16(8217),
		39: uint16(8220),
		40: uint16(8221),
		41: uint16(65288),
		42: uint16(65289),
		43: uint16(12308),
		44: uint16(12309),
		45: uint16(65339),
		46: uint16(65341),
		47: uint16(65371),
		48: uint16(65373),
		49: uint16(12296),
		50: uint16(12297),
		51: uint16(12298),
		52: uint16(12299),
		53: uint16(12300),
		54: uint16(12301),
		55: uint16(12302),
		56: uint16(12303),
		57: uint16(12304),
		58: uint16(12305),
		59: uint16(65291),
		60: uint16(8722),
		61: uint16(177),
		62: uint16(215),
		63: uint16(247),
		64: uint16(65309),
		65: uint16(8800),
		66: uint16(65308),
		67: uint16(65310),
		68: uint16(8806),
		69: uint16(8807),
		70: uint16(8734),
		71: uint16(8756),
		72: uint16(9794),
		73: uint16(9792),
		74: uint16(176),
		75: uint16(8242),
		76: uint16(8243),
		77: uint16(8451),
		78: uint16(65509),
		79: uint16(65284),
		80: uint16(162),
		81: uint16(163),
		82: uint16(65285),
		83: uint16(65283),
		84: uint16(65286),
		85: uint16(65290),
		86: uint16(65312),
		87: uint16(167),
		88: uint16(9734),
		89: uint16(9733),
		90: uint16(9675),
		91: uint16(9679),
		92: uint16(9678),
		93: uint16(9671),
	},
	1: {
		0:  uint16(9670),
		1:  uint16(9633),
		2:  uint16(9632),
		3:  uint16(9651),
		4:  uint16(9650),
		5:  uint16(9661),
		6:  uint16(9660),
		7:  uint16(8251),
		8:  uint16(12306),
		9:  uint16(8594),
		10: uint16(8592),
		11: uint16(8593),
		12: uint16(8595),
		13: uint16(12307),
		25: uint16(8712),
		26: uint16(8715),
		27: uint16(8838),
		28: uint16(8839),
		29: uint16(8834),
		30: uint16(8835),
		31: uint16(8746),
		32: uint16(8745),
		41: uint16(8743),
		42: uint16(8744),
		43: uint16(172),
		44: uint16(8658),
		45: uint16(8660),
		46: uint16(8704),
		47: uint16(8707),
		59: uint16(8736),
		60: uint16(8869),
		61: uint16(8978),
		62: uint16(8706),
		63: uint16(8711),
		64: uint16(8801),
		65: uint16(8786),
		66: uint16(8810),
		67: uint16(8811),
		68: uint16(8730),
		69: uint16(8765),
		70: uint16(8733),
		71: uint16(8757),
		72: uint16(8747),
		73: uint16(8748),
		81: uint16(8491),
		82: uint16(8240),
		83: uint16(9839),
		84: uint16(9837),
		85: uint16(9834),
		86: uint16(8224),
		87: uint16(8225),
		88: uint16(182),
		93: uint16(9711),
	},
	2: {
		15: uint16(65296),
		16: uint16(65297),
		17: uint16(65298),
		18: uint16(65299),
		19: uint16(65300),
		20: uint16(65301),
		21: uint16(65302),
		22: uint16(65303),
		23: uint16(65304),
		24: uint16(65305),
		32: uint16(65313),
		33: uint16(65314),
		34: uint16(65315),
		35: uint16(65316),
		36: uint16(65317),
		37: uint16(65318),
		38: uint16(65319),
		39: uint16(65320),
		40: uint16(65321),
		41: uint16(65322),
		42: uint16(65323),
		43: uint16(65324),
		44: uint16(65325),
		45: uint16(65326),
		46: uint16(65327),
		47: uint16(65328),
		48: uint16(65329),
		49: uint16(65330),
		50: uint16(65331),
		51: uint16(65332),
		52: uint16(65333),
		53: uint16(65334),
		54: uint16(65335),
		55: uint16(65336),
		56: uint16(65337),
		57: uint16(65338),
		64: uint16(65345),
		65: uint16(65346),
		66: uint16(65347),
		67: uint16(65348),
		68: uint16(65349),
		69: uint16(65350),
		70: uint16(65351),
		71: uint16(65352),
		72: uint16(65353),
		73: uint16(65354),
		74: uint16(65355),
		75: uint16(65356),
		76: uint16(65357),
		77: uint16(65358),
		78: uint16(65359),
		79: uint16(65360),
		80: uint16(65361),
		81: uint16(65362),
		82: uint16(65363),
		83: uint16(65364),
		84: uint16(65365),
		85: uint16(65366),
		86: uint16(65367),
		87: uint16(65368),
		88: uint16(65369),
		89: uint16(65370),
	},
	3: {
		0:  uint16(12353),
		1:  uint16(12354),
		2:  uint16(12355),
		3:  uint16(12356),
		4:  uint16(12357),
		5:  uint16(12358),
		6:  uint16(12359),
		7:  uint16(12360),
		8:  uint16(12361),
		9:  uint16(12362),
		10: uint16(12363),
		11: uint16(12364),
		12: uint16(12365),
		13: uint16(12366),
		14: uint16(12367),
		15: uint16(12368),
		16: uint16(12369),
		17: uint16(12370),
		18: uint16(12371),
		19: uint16(12372),
		20: uint16(12373),
		21: uint16(12374),
		22: uint16(12375),
		23: uint16(12376),
		24: uint16(12377),
		25: uint16(12378),
		26: uint16(12379),
		27: uint16(12380),
		28: uint16(12381),
		29: uint16(12382),
		30: uint16(12383),
		31: uint16(12384),
		32: uint16(12385),
		33: uint16(12386),
		34: uint16(12387),
		35: uint16(12388),
		36: uint16(12389),
		37: uint16(12390),
		38: uint16(12391),
		39: uint16(12392),
		40: uint16(12393),
		41: uint16(12394),
		42: uint16(12395),
		43: uint16(12396),
		44: uint16(12397),
		45: uint16(12398),
		46: uint16(12399),
		47: uint16(12400),
		48: uint16(12401),
		49: uint16(12402),
		50: uint16(12403),
		51: uint16(12404),
		52: uint16(12405),
		53: uint16(12406),
		54: uint16(12407),
		55: uint16(12408),
		56: uint16(12409),
		57: uint16(12410),
		58: uint16(12411),
		59: uint16(12412),
		60: uint16(12413),
		61: uint16(12414),
		62: uint16(12415),
		63: uint16(12416),
		64: uint16(12417),
		65: uint16(12418),
		66: uint16(12419),
		67: uint16(12420),
		68: uint16(12421),
		69: uint16(12422),
		70: uint16(12423),
		71: uint16(12424),
		72: uint16(12425),
		73: uint16(12426),
		74: uint16(12427),
		75: uint16(12428),
		76: uint16(12429),
		77: uint16(12430),
		78: uint16(12431),
		79: uint16(12432),
		80: uint16(12433),
		81: uint16(12434),
		82: uint16(12435),
	},
	4: {
		0:  uint16(12449),
		1:  uint16(12450),
		2:  uint16(12451),
		3:  uint16(12452),
		4:  uint16(12453),
		5:  uint16(12454),
		6:  uint16(12455),
		7:  uint16(12456),
		8:  uint16(12457),
		9:  uint16(12458),
		10: uint16(12459),
		11: uint16(12460),
		12: uint16(12461),
		13: uint16(12462),
		14: uint16(12463),
		15: uint16(12464),
		16: uint16(12465),
		17: uint16(12466),
		18: uint16(12467),
		19: uint16(12468),
		20: uint16(12469),
		21: uint16(12470),
		22: uint16(12471),
		23: uint16(12472),
		24: uint16(12473),
		25: uint16(12474),
		26: uint16(12475),
		27: uint16(12476),
		28: uint16(12477),
		29: uint16(12478),
		30: uint16(12479),
		31: uint16(12480),
		32: uint16(12481),
		33: uint16(12482),
		34: uint16(12483),
		35: uint16(12484),
		36: uint16(12485),
		37: uint16(12486),
		38: uint16(12487),
		39: uint16(12488),
		40: uint16(12489),
		41: uint16(12490),
		42: uint16(12491),
		43: uint16(12492),
		44: uint16(12493),
		45: uint16(12494),
		46: uint16(12495),
		47: uint16(12496),
		48: uint16(12497),
		49: uint16(12498),
		50: uint16(12499),
		51: uint16(12500),
		52: uint16(12501),
		53: uint16(12502),
		54: uint16(12503),
		55: uint16(12504),
		56: uint16(12505),
		57: uint16(12506),
		58: uint16(12507),
		59: uint16(12508),
		60: uint16(12509),
		61: uint16(12510),
		62: uint16(12511),
		63: uint16(12512),
		64: uint16(12513),
		65: uint16(12514),
		66: uint16(12515),
		67: uint16(12516),
		68: uint16(12517),
		69: uint16(12518),
		70: uint16(12519),
		71: uint16(12520),
		72: uint16(12521),
		73: uint16(12522),
		74: uint16(12523),
		75: uint16(12524),
		76: uint16(12525),
		77: uint16(12526),
		78: uint16(12527),
		79: uint16(12528),
		80: uint16(12529),
		81: uint16(12530),
		82: uint16(12531),
		83: uint16(12532),
		84: uint16(12533),
		85: uint16(12534),
	},
	5: {
		0:  uint16(913),
		1:  uint16(914),
		2:  uint16(915),
		3:  uint16(916),
		4:  uint16(917),
		5:  uint16(918),
		6:  uint16(919),
		7:  uint16(920),
		8:  uint16(921),
		9:  uint16(922),
		10: uint16(923),
		11: uint16(924),
		12: uint16(925),
		13: uint16(926),
		14: uint16(927),
		15: uint16(928),
		16: uint16(929),
		17: uint16(931),
		18: uint16(932),
		19: uint16(933),
		20: uint16(934),
		21: uint16(935),
		22: uint16(936),
		23: uint16(937),
		32: uint16(945),
		33: uint16(946),
		34: uint16(947),
		35: uint16(948),
		36: uint16(949),
		37: uint16(950),
		38: uint16(951),
		39: uint16(952),
		40: uint16(953),
		41: uint16(954),
		42: uint16(955),
		43: uint16(956),
		44: uint16(957),
		45: uint16(958),
		46: uint16(959),
		47: uint16(960),
		48: uint16(961),
		49: uint16(963),
		50: uint16(964),
		51: uint16(965),
		52: uint16(966),
		53: uint16(967),
		54: uint16(968),
		55: uint16(969),
	},
	6: {
		0:  uint16(1040),
		1:  uint16(1041),
		2:  uint16(1042),
		3:  uint16(1043),
		4:  uint16(1044),
		5:  uint16(1045),
		6:  uint16(1025),
		7:  uint16(1046),
		8:  uint16(1047),
		9:  uint16(1048),
		10: uint16(1049),
		11: uint16(1050),
		12: uint16(1051),
		13: uint16(1052),
		14: uint16(1053),
		15: uint16(1054),
		16: uint16(1055),
		17: uint16(1056),
		18: uint16(1057),
		19: uint16(1058),
		20: uint16(1059),
		21: uint16(1060),
		22: uint16(1061),
		23: uint16(1062),
		24: uint16(1063),
		25: uint16(1064),
		26: uint16(1065),
		27: uint16(1066),
		28: uint16(1067),
		29: uint16(1068),
		30: uint16(1069),
		31: uint16(1070),
		32: uint16(1071),
		48: uint16(1072),
		49: uint16(1073),
		50: uint16(1074),
		51: uint16(1075),
		52: uint16(1076),
		53: uint16(1077),
		54: uint16(1105),
		55: uint16(1078),
		56: uint16(1079),
		57: uint16(1080),
		58: uint16(1081),
		59: uint16(1082),
		60: uint16(1083),
		61: uint16(1084),
		62: uint16(1085),
		63: uint16(1086),
		64: uint16(1087),
		65: uint16(1088),
		66: uint16(1089),
		67: uint16(1090),
		68: uint16(1091),
		69: uint16(1092),
		70: uint16(1093),
		71: uint16(1094),
		72: uint16(1095),
		73: uint16(1096),
		74: uint16(1097),
		75: uint16(1098),
		76: uint16(1099),
		77: uint16(1100),
		78: uint16(1101),
		79: uint16(1102),
		80: uint16(1103),
	},
	7: {
		0:  uint16(9472),
		1:  uint16(9474),
		2:  uint16(9484),
		3:  uint16(9488),
		4:  uint16(9496),
		5:  uint16(9492),
		6:  uint16(9500),
		7:  uint16(9516),
		8:  uint16(9508),
		9:  uint16(9524),
		10: uint16(9532),
		11: uint16(9473),
		12: uint16(9475),
		13: uint16(9487),
		14: uint16(9491),
		15: uint16(9499),
		16: uint16(9495),
		17: uint16(9507),
		18: uint16(9523),
		19: uint16(9515),
		20: uint16(9531),
		21: uint16(9547),
		22: uint16(9504),
		23: uint16(9519),
		24: uint16(9512),
		25: uint16(9527),
		26: uint16(9535),
		27: uint16(9501),
		28: uint16(9520),
		29: uint16(9509),
		30: uint16(9528),
		31: uint16(9538),
	},
	8:  {},
	9:  {},
	10: {},
	11: {},
	12: {},
	13: {},
	14: {},
	15: {
		0:  uint16(20124),
		1:  uint16(21782),
		2:  uint16(23043),
		3:  uint16(38463),
		4:  uint16(21696),
		5:  uint16(24859),
		6:  uint16(25384),
		7:  uint16(23030),
		8:  uint16(36898),
		9:  uint16(33909),
		10: uint16(33564),
		11: uint16(31312),
		12: uint16(24746),
		13: uint16(25569),
		14: uint16(28197),
		15: uint16(26093),
		16: uint16(33894),
		17: uint16(33446),
		18: uint16(39925),
		19: uint16(26771),
		20: uint16(22311),
		21: uint16(26017),
		22: uint16(25201),
		23: uint16(23451),
		24: uint16(22992),
		25: uint16(34427),
		26: uint16(39156),
		27: uint16(32098),
		28: uint16(32190),
		29: uint16(39822),
		30: uint16(25110),
		31: uint16(31903),
		32: uint16(34999),
		33: uint16(23433),
		34: uint16(24245),
		35: uint16(25353),
		36: uint16(26263),
		37: uint16(26696),
		38: uint16(38343),
		39: uint16(38797),
		40: uint16(26447),
		41: uint16(20197),
		42: uint16(20234),
		43: uint16(20301),
		44: uint16(20381),
		45: uint16(20553),
		46: uint16(22258),
		47: uint16(22839),
		48: uint16(22996),
		49: uint16(23041),
		50: uint16(23561),
		51: uint16(24799),
		52: uint16(24847),
		53: uint16(24944),
		54: uint16(26131),
		55: uint16(26885),
		56: uint16(28858),
		57: uint16(30031),
		58: uint16(30064),
		59: uint16(31227),
		60: uint16(32173),
		61: uint16(32239),
		62: uint16(32963),
		63: uint16(33806),
		64: uint16(34915),
		65: uint16(35586),
		66: uint16(36949),
		67: uint16(36986),
		68: uint16(21307),
		69: uint16(20117),
		70: uint16(20133),
		71: uint16(22495),
		72: uint16(32946),
		73: uint16(37057),
		74: uint16(30959),
		75: uint16(19968),
		76: uint16(22769),
		77: uint16(28322),
		78: uint16(36920),
		79: uint16(31282),
		80: uint16(33576),
		81: uint16(33419),
		82: uint16(39983),
		83: uint16(20801),
		84: uint16(21360),
		85: uint16(21693),
		86: uint16(21729),
		87: uint16(22240),
		88: uint16(23035),
		89: uint16(24341),
		90: uint16(39154),
		91: uint16(28139),
		92: uint16(32996),
		93: uint16(34093),
	},
	16: {
		0:  uint16(38498),
		1:  uint16(38512),
		2:  uint16(38560),
		3:  uint16(38907),
		4:  uint16(21515),
		5:  uint16(21491),
		6:  uint16(23431),
		7:  uint16(28879),
		8:  uint16(32701),
		9:  uint16(36802),
		10: uint16(38632),
		11: uint16(21359),
		12: uint16(40284),
		13: uint16(31418),
		14: uint16(19985),
		15: uint16(30867),
		16: uint16(33276),
		17: uint16(28198),
		18: uint16(22040),
		19: uint16(21764),
		20: uint16(27421),
		21: uint16(34074),
		22: uint16(39995),
		23: uint16(23013),
		24: uint16(21417),
		25: uint16(28006),
		26: uint16(29916),
		27: uint16(38287),
		28: uint16(22082),
		29: uint16(20113),
		30: uint16(36939),
		31: uint16(38642),
		32: uint16(33615),
		33: uint16(39180),
		34: uint16(21473),
		35: uint16(21942),
		36: uint16(23344),
		37: uint16(24433),
		38: uint16(26144),
		39: uint16(26355),
		40: uint16(26628),
		41: uint16(27704),
		42: uint16(27891),
		43: uint16(27945),
		44: uint16(29787),
		45: uint16(30408),
		46: uint16(31310),
		47: uint16(38964),
		48: uint16(33521),
		49: uint16(34907),
		50: uint16(35424),
		51: uint16(37613),
		52: uint16(28082),
		53: uint16(30123),
		54: uint16(30410),
		55: uint16(39365),
		56: uint16(24742),
		57: uint16(35585),
		58: uint16(36234),
		59: uint16(38322),
		60: uint16(27022),
		61: uint16(21421),
		62: uint16(20870),
		63: uint16(22290),
		64: uint16(22576),
		65: uint16(22852),
		66: uint16(23476),
		67: uint16(24310),
		68: uint16(24616),
		69: uint16(25513),
		70: uint16(25588),
		71: uint16(27839),
		72: uint16(28436),
		73: uint16(28814),
		74: uint16(28948),
		75: uint16(29017),
		76: uint16(29141),
		77: uint16(29503),
		78: uint16(32257),
		79: uint16(33398),
		80: uint16(33489),
		81: uint16(34199),
		82: uint16(36960),
		83: uint16(37467),
		84: uint16(40219),
		85: uint16(22633),
		86: uint16(26044),
		87: uint16(27738),
		88: uint16(29989),
		89: uint16(20985),
		90: uint16(22830),
		91: uint16(22885),
		92: uint16(24448),
		93: uint16(24540),
	},
	17: {
		0:  uint16(25276),
		1:  uint16(26106),
		2:  uint16(27178),
		3:  uint16(27431),
		4:  uint16(27572),
		5:  uint16(29579),
		6:  uint16(32705),
		7:  uint16(35158),
		8:  uint16(40236),
		9:  uint16(40206),
		10: uint16(40644),
		11: uint16(23713),
		12: uint16(27798),
		13: uint16(33659),
		14: uint16(20740),
		15: uint16(23627),
		16: uint16(25014),
		17: uint16(33222),
		18: uint16(26742),
		19: uint16(29281),
		20: uint16(20057),
		21: uint16(20474),
		22: uint16(21368),
		23: uint16(24681),
		24: uint16(28201),
		25: uint16(31311),
		26: uint16(38899),
		27: uint16(19979),
		28: uint16(21270),
		29: uint16(20206),
		30: uint16(20309),
		31: uint16(20285),
		32: uint16(20385),
		33: uint16(20339),
		34: uint16(21152),
		35: uint16(21487),
		36: uint16(22025),
		37: uint16(22799),
		38: uint16(23233),
		39: uint16(23478),
		40: uint16(23521),
		41: uint16(31185),
		42: uint16(26247),
		43: uint16(26524),
		44: uint16(26550),
		45: uint16(27468),
		46: uint16(27827),
		47: uint16(28779),
		48: uint16(29634),
		49: uint16(31117),
		50: uint16(31166),
		51: uint16(31292),
		52: uint16(31623),
		53: uint16(33457),
		54: uint16(33499),
		55: uint16(33540),
		56: uint16(33655),
		57: uint16(33775),
		58: uint16(33747),
		59: uint16(34662),
		60: uint16(35506),
		61: uint16(22057),
		62: uint16(36008),
		63: uint16(36838),
		64: uint16(36942),
		65: uint16(38686),
		66: uint16(34442),
		67: uint16(20420),
		68: uint16(23784),
		69: uint16(25105),
		70: uint16(29273),
		71: uint16(30011),
		72: uint16(33253),
		73: uint16(33469),
		74: uint16(34558),
		75: uint16(36032),
		76: uint16(38597),
		77: uint16(39187),
		78: uint16(39381),
		79: uint16(20171),
		80: uint16(20250),
		81: uint16(35299),
		82: uint16(22238),
		83: uint16(22602),
		84: uint16(22730),
		85: uint16(24315),
		86: uint16(24555),
		87: uint16(24618),
		88: uint16(24724),
		89: uint16(24674),
		90: uint16(25040),
		91: uint16(25106),
		92: uint16(25296),
		93: uint16(25913),
	},
	18: {
		0:  uint16(39745),
		1:  uint16(26214),
		2:  uint16(26800),
		3:  uint16(28023),
		4:  uint16(28784),
		5:  uint16(30028),
		6:  uint16(30342),
		7:  uint16(32117),
		8:  uint16(33445),
		9:  uint16(34809),
		10: uint16(38283),
		11: uint16(38542),
		12: uint16(35997),
		13: uint16(20977),
		14: uint16(21182),
		15: uint16(22806),
		16: uint16(21683),
		17: uint16(23475),
		18: uint16(23830),
		19: uint16(24936),
		20: uint16(27010),
		21: uint16(28079),
		22: uint16(30861),
		23: uint16(33995),
		24: uint16(34903),
		25: uint16(35442),
		26: uint16(37799),
		27: uint16(39608),
		28: uint16(28012),
		29: uint16(39336),
		30: uint16(34521),
		31: uint16(22435),
		32: uint16(26623),
		33: uint16(34510),
		34: uint16(37390),
		35: uint16(21123),
		36: uint16(22151),
		37: uint16(21508),
		38: uint16(24275),
		39: uint16(25313),
		40: uint16(25785),
		41: uint16(26684),
		42: uint16(26680),
		43: uint16(27579),
		44: uint16(29554),
		45: uint16(30906),
		46: uint16(31339),
		47: uint16(35226),
		48: uint16(35282),
		49: uint16(36203),
		50: uint16(36611),
		51: uint16(37101),
		52: uint16(38307),
		53: uint16(38548),
		54: uint16(38761),
		55: uint16(23398),
		56: uint16(23731),
		57: uint16(27005),
		58: uint16(38989),
		59: uint16(38990),
		60: uint16(25499),
		61: uint16(31520),
		62: uint16(27179),
		63: uint16(27263),
		64: uint16(26806),
		65: uint16(39949),
		66: uint16(28511),
		67: uint16(21106),
		68: uint16(21917),
		69: uint16(24688),
		70: uint16(25324),
		71: uint16(27963),
		72: uint16(28167),
		73: uint16(28369),
		74: uint16(33883),
		75: uint16(35088),
		76: uint16(36676),
		77: uint16(19988),
		78: uint16(39993),
		79: uint16(21494),
		80: uint16(26907),
		81: uint16(27194),
		82: uint16(38788),
		83: uint16(26666),
		84: uint16(20828),
		85: uint16(31427),
		86: uint16(33970),
		87: uint16(37340),
		88: uint16(37772),
		89: uint16(22107),
		90: uint16(40232),
		91: uint16(26658),
		92: uint16(33541),
		93: uint16(33841),
	},
	19: {
		0:  uint16(31909),
		1:  uint16(21000),
		2:  uint16(33477),
		3:  uint16(29926),
		4:  uint16(20094),
		5:  uint16(20355),
		6:  uint16(20896),
		7:  uint16(23506),
		8:  uint16(21002),
		9:  uint16(21208),
		10: uint16(21223),
		11: uint16(24059),
		12: uint16(21914),
		13: uint16(22570),
		14: uint16(23014),
		15: uint16(23436),
		16: uint16(23448),
		17: uint16(23515),
		18: uint16(24178),
		19: uint16(24185),
		20: uint16(24739),
		21: uint16(24863),
		22: uint16(24931),
		23: uint16(25022),
		24: uint16(25563),
		25: uint16(25954),
		26: uint16(26577),
		27: uint16(26707),
		28: uint16(26874),
		29: uint16(27454),
		30: uint16(27475),
		31: uint16(27735),
		32: uint16(28450),
		33: uint16(28567),
		34: uint16(28485),
		35: uint16(29872),
		36: uint16(29976),
		37: uint16(30435),
		38: uint16(30475),
		39: uint16(31487),
		40: uint16(31649),
		41: uint16(31777),
		42: uint16(32233),
		43: uint16(32566),
		44: uint16(32752),
		45: uint16(32925),
		46: uint16(33382),
		47: uint16(33694),
		48: uint16(35251),
		49: uint16(35532),
		50: uint16(36011),
		51: uint16(36996),
		52: uint16(37969),
		53: uint16(38291),
		54: uint16(38289),
		55: uint16(38306),
		56: uint16(38501),
		57: uint16(38867),
		58: uint16(39208),
		59: uint16(33304),
		60: uint16(20024),
		61: uint16(21547),
		62: uint16(23736),
		63: uint16(24012),
		64: uint16(29609),
		65: uint16(30284),
		66: uint16(30524),
		67: uint16(23721),
		68: uint16(32747),
		69: uint16(36107),
		70: uint16(38593),
		71: uint16(38929),
		72: uint16(38996),
		73: uint16(39000),
		74: uint16(20225),
		75: uint16(20238),
		76: uint16(21361),
		77: uint16(21916),
		78: uint16(22120),
		79: uint16(22522),
		80: uint16(22855),
		81: uint16(23305),
		82: uint16(23492),
		83: uint16(23696),
		84: uint16(24076),
		85: uint16(24190),
		86: uint16(24524),
		87: uint16(25582),
		88: uint16(26426),
		89: uint16(26071),
		90: uint16(26082),
		91: uint16(26399),
		92: uint16(26827),
		93: uint16(26820),
	},
	20: {
		0:  uint16(27231),
		1:  uint16(24112),
		2:  uint16(27589),
		3:  uint16(27671),
		4:  uint16(27773),
		5:  uint16(30079),
		6:  uint16(31048),
		7:  uint16(23395),
		8:  uint16(31232),
		9:  uint16(32000),
		10: uint16(24509),
		11: uint16(35215),
		12: uint16(35352),
		13: uint16(36020),
		14: uint16(36215),
		15: uint16(36556),
		16: uint16(36637),
		17: uint16(39138),
		18: uint16(39438),
		19: uint16(39740),
		20: uint16(20096),
		21: uint16(20605),
		22: uint16(20736),
		23: uint16(22931),
		24: uint16(23452),
		25: uint16(25135),
		26: uint16(25216),
		27: uint16(25836),
		28: uint16(27450),
		29: uint16(29344),
		30: uint16(30097),
		31: uint16(31047),
		32: uint16(32681),
		33: uint16(34811),
		34: uint16(35516),
		35: uint16(35696),
		36: uint16(25516),
		37: uint16(33738),
		38: uint16(38816),
		39: uint16(21513),
		40: uint16(21507),
		41: uint16(21931),
		42: uint16(26708),
		43: uint16(27224),
		44: uint16(35440),
		45: uint16(30759),
		46: uint16(26485),
		47: uint16(40653),
		48: uint16(21364),
		49: uint16(23458),
		50: uint16(33050),
		51: uint16(34384),
		52: uint16(36870),
		53: uint16(19992),
		54: uint16(20037),
		55: uint16(20167),
		56: uint16(20241),
		57: uint16(21450),
		58: uint16(21560),
		59: uint16(23470),
		60: uint16(24339),
		61: uint16(24613),
		62: uint16(25937),
		63: uint16(26429),
		64: uint16(27714),
		65: uint16(27762),
		66: uint16(27875),
		67: uint16(28792),
		68: uint16(29699),
		69: uint16(31350),
		70: uint16(31406),
		71: uint16(31496),
		72: uint16(32026),
		73: uint16(31998),
		74: uint16(32102),
		75: uint16(26087),
		76: uint16(29275),
		77: uint16(21435),
		78: uint16(23621),
		79: uint16(24040),
		80: uint16(25298),
		81: uint16(25312),
		82: uint16(25369),
		83: uint16(28192),
		84: uint16(34394),
		85: uint16(35377),
		86: uint16(36317),
		87: uint16(37624),
		88: uint16(28417),
		89: uint16(31142),
		90: uint16(39770),
		91: uint16(20136),
		92: uint16(20139),
		93: uint16(20140),
	},
	21: {
		0:  uint16(20379),
		1:  uint16(20384),
		2:  uint16(20689),
		3:  uint16(20807),
		4:  uint16(31478),
		5:  uint16(20849),
		6:  uint16(20982),
		7:  uint16(21332),
		8:  uint16(21281),
		9:  uint16(21375),
		10: uint16(21483),
		11: uint16(21932),
		12: uint16(22659),
		13: uint16(23777),
		14: uint16(24375),
		15: uint16(24394),
		16: uint16(24623),
		17: uint16(24656),
		18: uint16(24685),
		19: uint16(25375),
		20: uint16(25945),
		21: uint16(27211),
		22: uint16(27841),
		23: uint16(29378),
		24: uint16(29421),
		25: uint16(30703),
		26: uint16(33016),
		27: uint16(33029),
		28: uint16(33288),
		29: uint16(34126),
		30: uint16(37111),
		31: uint16(37857),
		32: uint16(38911),
		33: uint16(39255),
		34: uint16(39514),
		35: uint16(20208),
		36: uint16(20957),
		37: uint16(23597),
		38: uint16(26241),
		39: uint16(26989),
		40: uint16(23616),
		41: uint16(26354),
		42: uint16(26997),
		43: uint16(29577),
		44: uint16(26704),
		45: uint16(31873),
		46: uint16(20677),
		47: uint16(21220),
		48: uint16(22343),
		49: uint16(24062),
		50: uint16(37670),
		51: uint16(26020),
		52: uint16(27427),
		53: uint16(27453),
		54: uint16(29748),
		55: uint16(31105),
		56: uint16(31165),
		57: uint16(31563),
		58: uint16(32202),
		59: uint16(33465),
		60: uint16(33740),
		61: uint16(34943),
		62: uint16(35167),
		63: uint16(35641),
		64: uint16(36817),
		65: uint16(37329),
		66: uint16(21535),
		67: uint16(37504),
		68: uint16(20061),
		69: uint16(20534),
		70: uint16(21477),
		71: uint16(21306),
		72: uint16(29399),
		73: uint16(29590),
		74: uint16(30697),
		75: uint16(33510),
		76: uint16(36527),
		77: uint16(39366),
		78: uint16(39368),
		79: uint16(39378),
		80: uint16(20855),
		81: uint16(24858),
		82: uint16(34398),
		83: uint16(21936),
		84: uint16(31354),
		85: uint16(20598),
		86: uint16(23507),
		87: uint16(36935),
		88: uint16(38533),
		89: uint16(20018),
		90: uint16(27355),
		91: uint16(37351),
		92: uint16(23633),
		93: uint16(23624),
	},
	22: {
		0:  uint16(25496),
		1:  uint16(31391),
		2:  uint16(27795),
		3:  uint16(38772),
		4:  uint16(36705),
		5:  uint16(31402),
		6:  uint16(29066),
		7:  uint16(38536),
		8:  uint16(31874),
		9:  uint16(26647),
		10: uint16(32368),
		11: uint16(26705),
		12: uint16(37740),
		13: uint16(21234),
		14: uint16(21531),
		15: uint16(34219),
		16: uint16(35347),
		17: uint16(32676),
		18: uint16(36557),
		19: uint16(37089),
		20: uint16(21350),
		21: uint16(34952),
		22: uint16(31041),
		23: uint16(20418),
		24: uint16(20670),
		25: uint16(21009),
		26: uint16(20804),
		27: uint16(21843),
		28: uint16(22317),
		29: uint16(29674),
		30: uint16(22411),
		31: uint16(22865),
		32: uint16(24418),
		33: uint16(24452),
		34: uint16(24693),
		35: uint16(24950),
		36: uint16(24935),
		37: uint16(25001),
		38: uint16(25522),
		39: uint16(25658),
		40: uint16(25964),
		41: uint16(26223),
		42: uint16(26690),
		43: uint16(28179),
		44: uint16(30054),
		45: uint16(31293),
		46: uint16(31995),
		47: uint16(32076),
		48: uint16(32153),
		49: uint16(32331),
		50: uint16(32619),
		51: uint16(33550),
		52: uint16(33610),
		53: uint16(34509),
		54: uint16(35336),
		55: uint16(35427),
		56: uint16(35686),
		57: uint16(36605),
		58: uint16(38938),
		59: uint16(40335),
		60: uint16(33464),
		61: uint16(36814),
		62: uint16(39912),
		63: uint16(21127),
		64: uint16(25119),
		65: uint16(25731),
		66: uint16(28608),
		67: uint16(38553),
		68: uint16(26689),
		69: uint16(20625),
		70: uint16(27424),
		71: uint16(27770),
		72: uint16(28500),
		73: uint16(31348),
		74: uint16(32080),
		75: uint16(34880),
		76: uint16(35363),
		77: uint16(26376),
		78: uint16(20214),
		79: uint16(20537),
		80: uint16(20518),
		81: uint16(20581),
		82: uint16(20860),
		83: uint16(21048),
		84: uint16(21091),
		85: uint16(21927),
		86: uint16(22287),
		87: uint16(22533),
		88: uint16(23244),
		89: uint16(24314),
		90: uint16(25010),
		91: uint16(25080),
		92: uint16(25331),
		93: uint16(25458),
	},
	23: {
		0:  uint16(26908),
		1:  uint16(27177),
		2:  uint16(29309),
		3:  uint16(29356),
		4:  uint16(29486),
		5:  uint16(30740),
		6:  uint16(30831),
		7:  uint16(32121),
		8:  uint16(30476),
		9:  uint16(32937),
		10: uint16(35211),
		11: uint16(35609),
		12: uint16(36066),
		13: uint16(36562),
		14: uint16(36963),
		15: uint16(37749),
		16: uint16(38522),
		17: uint16(38997),
		18: uint16(39443),
		19: uint16(40568),
		20: uint16(20803),
		21: uint16(21407),
		22: uint16(21427),
		23: uint16(24187),
		24: uint16(24358),
		25: uint16(28187),
		26: uint16(28304),
		27: uint16(29572),
		28: uint16(29694),
		29: uint16(32067),
		30: uint16(33335),
		31: uint16(35328),
		32: uint16(35578),
		33: uint16(38480),
		34: uint16(20046),
		35: uint16(20491),
		36: uint16(21476),
		37: uint16(21628),
		38: uint16(22266),
		39: uint16(22993),
		40: uint16(23396),
		41: uint16(24049),
		42: uint16(24235),
		43: uint16(24359),
		44: uint16(25144),
		45: uint16(25925),
		46: uint16(26543),
		47: uint16(28246),
		48: uint16(29392),
		49: uint16(31946),
		50: uint16(34996),
		51: uint16(32929),
		52: uint16(32993),
		53: uint16(33776),
		54: uint16(34382),
		55: uint16(35463),
		56: uint16(36328),
		57: uint16(37431),
		58: uint16(38599),
		59: uint16(39015),
		60: uint16(40723),
		61: uint16(20116),
		62: uint16(20114),
		63: uint16(20237),
		64: uint16(21320),
		65: uint16(21577),
		66: uint16(21566),
		67: uint16(23087),
		68: uint16(24460),
		69: uint16(24481),
		70: uint16(24735),
		71: uint16(26791),
		72: uint16(27278),
		73: uint16(29786),
		74: uint16(30849),
		75: uint16(35486),
		76: uint16(35492),
		77: uint16(35703),
		78: uint16(37264),
		79: uint16(20062),
		80: uint16(39881),
		81: uint16(20132),
		82: uint16(20348),
		83: uint16(20399),
		84: uint16(20505),
		85: uint16(20502),
		86: uint16(20809),
		87: uint16(20844),
		88: uint16(21151),
		89: uint16(21177),
		90: uint16(21246),
		91: uint16(21402),
		92: uint16(21475),
		93: uint16(21521),
	},
	24: {
		0:  uint16(21518),
		1:  uint16(21897),
		2:  uint16(22353),
		3:  uint16(22434),
		4:  uint16(22909),
		5:  uint16(23380),
		6:  uint16(23389),
		7:  uint16(23439),
		8:  uint16(24037),
		9:  uint16(24039),
		10: uint16(24055),
		11: uint16(24184),
		12: uint16(24195),
		13: uint16(24218),
		14: uint16(24247),
		15: uint16(24344),
		16: uint16(24658),
		17: uint16(24908),
		18: uint16(25239),
		19: uint16(25304),
		20: uint16(25511),
		21: uint16(25915),
		22: uint16(26114),
		23: uint16(26179),
		24: uint16(26356),
		25: uint16(26477),
		26: uint16(26657),
		27: uint16(26775),
		28: uint16(27083),
		29: uint16(27743),
		30: uint16(27946),
		31: uint16(28009),
		32: uint16(28207),
		33: uint16(28317),
		34: uint16(30002),
		35: uint16(30343),
		36: uint16(30828),
		37: uint16(31295),
		38: uint16(31968),
		39: uint16(32005),
		40: uint16(32024),
		41: uint16(32094),
		42: uint16(32177),
		43: uint16(32789),
		44: uint16(32771),
		45: uint16(32943),
		46: uint16(32945),
		47: uint16(33108),
		48: uint16(33167),
		49: uint16(33322),
		50: uint16(33618),
		51: uint16(34892),
		52: uint16(34913),
		53: uint16(35611),
		54: uint16(36002),
		55: uint16(36092),
		56: uint16(37066),
		57: uint16(37237),
		58: uint16(37489),
		59: uint16(30783),
		60: uint16(37628),
		61: uint16(38308),
		62: uint16(38477),
		63: uint16(38917),
		64: uint16(39321),
		65: uint16(39640),
		66: uint16(40251),
		67: uint16(21083),
		68: uint16(21163),
		69: uint16(21495),
		70: uint16(21512),
		71: uint16(22741),
		72: uint16(25335),
		73: uint16(28640),
		74: uint16(35946),
		75: uint16(36703),
		76: uint16(40633),
		77: uint16(20811),
		78: uint16(21051),
		79: uint16(21578),
		80: uint16(22269),
		81: uint16(31296),
		82: uint16(37239),
		83: uint16(40288),
		84: uint16(40658),
		85: uint16(29508),
		86: uint16(28425),
		87: uint16(33136),
		88: uint16(29969),
		89: uint16(24573),
		90: uint16(24794),
		91: uint16(39592),
		92: uint16(29403),
		93: uint16(36796),
	},
	25: {
		0:  uint16(27492),
		1:  uint16(38915),
		2:  uint16(20170),
		3:  uint16(22256),
		4:  uint16(22372),
		5:  uint16(22718),
		6:  uint16(23130),
		7:  uint16(24680),
		8:  uint16(25031),
		9:  uint16(26127),
		10: uint16(26118),
		11: uint16(26681),
		12: uint16(26801),
		13: uint16(28151),
		14: uint16(30165),
		15: uint16(32058),
		16: uint16(33390),
		17: uint16(39746),
		18: uint16(20123),
		19: uint16(20304),
		20: uint16(21449),
		21: uint16(21766),
		22: uint16(23919),
		23: uint16(24038),
		24: uint16(24046),
		25: uint16(26619),
		26: uint16(27801),
		27: uint16(29811),
		28: uint16(30722),
		29: uint16(35408),
		30: uint16(37782),
		31: uint16(35039),
		32: uint16(22352),
		33: uint16(24231),
		34: uint16(25387),
		35: uint16(20661),
		36: uint16(20652),
		37: uint16(20877),
		38: uint16(26368),
		39: uint16(21705),
		40: uint16(22622),
		41: uint16(22971),
		42: uint16(23472),
		43: uint16(24425),
		44: uint16(25165),
		45: uint16(25505),
		46: uint16(26685),
		47: uint16(27507),
		48: uint16(28168),
		49: uint16(28797),
		50: uint16(37319),
		51: uint16(29312),
		52: uint16(30741),
		53: uint16(30758),
		54: uint16(31085),
		55: uint16(25998),
		56: uint16(32048),
		57: uint16(33756),
		58: uint16(35009),
		59: uint16(36617),
		60: uint16(38555),
		61: uint16(21092),
		62: uint16(22312),
		63: uint16(26448),
		64: uint16(32618),
		65: uint16(36001),
		66: uint16(20916),
		67: uint16(22338),
		68: uint16(38442),
		69: uint16(22586),
		70: uint16(27018),
		71: uint16(32948),
		72: uint16(21682),
		73: uint16(23822),
		74: uint16(22524),
		75: uint16(30869),
		76: uint16(40442),
		77: uint16(20316),
		78: uint16(21066),
		79: uint16(21643),
		80: uint16(25662),
		81: uint16(26152),
		82: uint16(26388),
		83: uint16(26613),
		84: uint16(31364),
		85: uint16(31574),
		86: uint16(32034),
		87: uint16(37679),
		88: uint16(26716),
		89: uint16(39853),
		90: uint16(31545),
		91: uint16(21273),
		92: uint16(20874),
		93: uint16(21047),
	},
	26: {
		0:  uint16(23519),
		1:  uint16(25334),
		2:  uint16(25774),
		3:  uint16(25830),
		4:  uint16(26413),
		5:  uint16(27578),
		6:  uint16(34217),
		7:  uint16(38609),
		8:  uint16(30352),
		9:  uint16(39894),
		10: uint16(25420),
		11: uint16(37638),
		12: uint16(39851),
		13: uint16(30399),
		14: uint16(26194),
		15: uint16(19977),
		16: uint16(20632),
		17: uint16(21442),
		18: uint16(23665),
		19: uint16(24808),
		20: uint16(25746),
		21: uint16(25955),
		22: uint16(26719),
		23: uint16(29158),
		24: uint16(29642),
		25: uint16(29987),
		26: uint16(31639),
		27: uint16(32386),
		28: uint16(34453),
		29: uint16(35715),
		30: uint16(36059),
		31: uint16(37240),
		32: uint16(39184),
		33: uint16(26028),
		34: uint16(26283),
		35: uint16(27531),
		36: uint16(20181),
		37: uint16(20180),
		38: uint16(20282),
		39: uint16(20351),
		40: uint16(21050),
		41: uint16(21496),
		42: uint16(21490),
		43: uint16(21987),
		44: uint16(22235),
		45: uint16(22763),
		46: uint16(22987),
		47: uint16(22985),
		48: uint16(23039),
		49: uint16(23376),
		50: uint16(23629),
		51: uint16(24066),
		52: uint16(24107),
		53: uint16(24535),
		54: uint16(24605),
		55: uint16(25351),
		56: uint16(25903),
		57: uint16(23388),
		58: uint16(26031),
		59: uint16(26045),
		60: uint16(26088),
		61: uint16(26525),
		62: uint16(27490),
		63: uint16(27515),
		64: uint16(27663),
		65: uint16(29509),
		66: uint16(31049),
		67: uint16(31169),
		68: uint16(31992),
		69: uint16(32025),
		70: uint16(32043),
		71: uint16(32930),
		72: uint16(33026),
		73: uint16(33267),
		74: uint16(35222),
		75: uint16(35422),
		76: uint16(35433),
		77: uint16(35430),
		78: uint16(35468),
		79: uint16(35566),
		80: uint16(36039),
		81: uint16(36060),
		82: uint16(38604),
		83: uint16(39164),
		84: uint16(27503),
		85: uint16(20107),
		86: uint16(20284),
		87: uint16(20365),
		88: uint16(20816),
		89: uint16(23383),
		90: uint16(23546),
		91: uint16(24904),
		92: uint16(25345),
		93: uint16(26178),
	},
	27: {
		0:  uint16(27425),
		1:  uint16(28363),
		2:  uint16(27835),
		3:  uint16(29246),
		4:  uint16(29885),
		5:  uint16(30164),
		6:  uint16(30913),
		7:  uint16(31034),
		8:  uint16(32780),
		9:  uint16(32819),
		10: uint16(33258),
		11: uint16(33940),
		12: uint16(36766),
		13: uint16(27728),
		14: uint16(40575),
		15: uint16(24335),
		16: uint16(35672),
		17: uint16(40235),
		18: uint16(31482),
		19: uint16(36600),
		20: uint16(23437),
		21: uint16(38635),
		22: uint16(19971),
		23: uint16(21489),
		24: uint16(22519),
		25: uint16(22833),
		26: uint16(23241),
		27: uint16(23460),
		28: uint16(24713),
		29: uint16(28287),
		30: uint16(28422),
		31: uint16(30142),
		32: uint16(36074),
		33: uint16(23455),
		34: uint16(34048),
		35: uint16(31712),
		36: uint16(20594),
		37: uint16(26612),
		38: uint16(33437),
		39: uint16(23649),
		40: uint16(34122),
		41: uint16(32286),
		42: uint16(33294),
		43: uint16(20889),
		44: uint16(23556),
		45: uint16(25448),
		46: uint16(36198),
		47: uint16(26012),
		48: uint16(29038),
		49: uint16(31038),
		50: uint16(32023),
		51: uint16(32773),
		52: uint16(35613),
		53: uint16(36554),
		54: uint16(36974),
		55: uint16(34503),
		56: uint16(37034),
		57: uint16(20511),
		58: uint16(21242),
		59: uint16(23610),
		60: uint16(26451),
		61: uint16(28796),
		62: uint16(29237),
		63: uint16(37196),
		64: uint16(37320),
		65: uint16(37675),
		66: uint16(33509),
		67: uint16(23490),
		68: uint16(24369),
		69: uint16(24825),
		70: uint16(20027),
		71: uint16(21462),
		72: uint16(23432),
		73: uint16(25163),
		74: uint16(26417),
		75: uint16(27530),
		76: uint16(29417),
		77: uint16(29664),
		78: uint16(31278),
		79: uint16(33131),
		80: uint16(36259),
		81: uint16(37202),
		82: uint16(39318),
		83: uint16(20754),
		84: uint16(21463),
		85: uint16(21610),
		86: uint16(23551),
		87: uint16(25480),
		88: uint16(27193),
		89: uint16(32172),
		90: uint16(38656),
		91: uint16(22234),
		92: uint16(21454),
		93: uint16(21608),
	},
	28: {
		0:  uint16(23447),
		1:  uint16(23601),
		2:  uint16(24030),
		3:  uint16(20462),
		4:  uint16(24833),
		5:  uint16(25342),
		6:  uint16(27954),
		7:  uint16(31168),
		8:  uint16(31179),
		9:  uint16(32066),
		10: uint16(32333),
		11: uint16(32722),
		12: uint16(33261),
		13: uint16(33311),
		14: uint16(33936),
		15: uint16(34886),
		16: uint16(35186),
		17: uint16(35728),
		18: uint16(36468),
		19: uint16(36655),
		20: uint16(36913),
		21: uint16(37195),
		22: uint16(37228),
		23: uint16(38598),
		24: uint16(37276),
		25: uint16(20160),
		26: uint16(20303),
		27: uint16(20805),
		28: uint16(21313),
		29: uint16(24467),
		30: uint16(25102),
		31: uint16(26580),
		32: uint16(27713),
		33: uint16(28171),
		34: uint16(29539),
		35: uint16(32294),
		36: uint16(37325),
		37: uint16(37507),
		38: uint16(21460),
		39: uint16(22809),
		40: uint16(23487),
		41: uint16(28113),
		42: uint16(31069),
		43: uint16(32302),
		44: uint16(31899),
		45: uint16(22654),
		46: uint16(29087),
		47: uint16(20986),
		48: uint16(34899),
		49: uint16(36848),
		50: uint16(20426),
		51: uint16(23803),
		52: uint16(26149),
		53: uint16(30636),
		54: uint16(31459),
		55: uint16(33308),
		56: uint16(39423),
		57: uint16(20934),
		58: uint16(24490),
		59: uint16(26092),
		60: uint16(26991),
		61: uint16(27529),
		62: uint16(28147),
		63: uint16(28310),
		64: uint16(28516),
		65: uint16(30462),
		66: uint16(32020),
		67: uint16(24033),
		68: uint16(36981),
		69: uint16(37255),
		70: uint16(38918),
		71: uint16(20966),
		72: uint16(21021),
		73: uint16(25152),
		74: uint16(26257),
		75: uint16(26329),
		76: uint16(28186),
		77: uint16(24246),
		78: uint16(32210),
		79: uint16(32626),
		80: uint16(26360),
		81: uint16(34223),
		82: uint16(34295),
		83: uint16(35576),
		84: uint16(21161),
		85: uint16(21465),
		86: uint16(22899),
		87: uint16(24207),
		88: uint16(24464),
		89: uint16(24661),
		90: uint16(37604),
		91: uint16(38500),
		92: uint16(20663),
		93: uint16(20767),
	},
	29: {
		0:  uint16(21213),
		1:  uint16(21280),
		2:  uint16(21319),
		3:  uint16(21484),
		4:  uint16(21736),
		5:  uint16(21830),
		6:  uint16(21809),
		7:  uint16(22039),
		8:  uint16(22888),
		9:  uint16(22974),
		10: uint16(23100),
		11: uint16(23477),
		12: uint16(23558),
		13: uint16(23567),
		14: uint16(23569),
		15: uint16(23578),
		16: uint16(24196),
		17: uint16(24202),
		18: uint16(24288),
		19: uint16(24432),
		20: uint16(25215),
		21: uint16(25220),
		22: uint16(25307),
		23: uint16(25484),
		24: uint16(25463),
		25: uint16(26119),
		26: uint16(26124),
		27: uint16(26157),
		28: uint16(26230),
		29: uint16(26494),
		30: uint16(26786),
		31: uint16(27167),
		32: uint16(27189),
		33: uint16(27836),
		34: uint16(28040),
		35: uint16(28169),
		36: uint16(28248),
		37: uint16(28988),
		38: uint16(28966),
		39: uint16(29031),
		40: uint16(30151),
		41: uint16(30465),
		42: uint16(30813),
		43: uint16(30977),
		44: uint16(31077),
		45: uint16(31216),
		46: uint16(31456),
		47: uint16(31505),
		48: uint16(31911),
		49: uint16(32057),
		50: uint16(32918),
		51: uint16(33750),
		52: uint16(33931),
		53: uint16(34121),
		54: uint16(34909),
		55: uint16(35059),
		56: uint16(35359),
		57: uint16(35388),
		58: uint16(35412),
		59: uint16(35443),
		60: uint16(35937),
		61: uint16(36062),
		62: uint16(37284),
		63: uint16(37478),
		64: uint16(37758),
		65: uint16(37912),
		66: uint16(38556),
		67: uint16(38808),
		68: uint16(19978),
		69: uint16(19976),
		70: uint16(19998),
		71: uint16(20055),
		72: uint16(20887),
		73: uint16(21104),
		74: uint16(22478),
		75: uint16(22580),
		76: uint16(22732),
		77: uint16(23330),
		78: uint16(24120),
		79: uint16(24773),
		80: uint16(25854),
		81: uint16(26465),
		82: uint16(26454),
		83: uint16(27972),
		84: uint16(29366),
		85: uint16(30067),
		86: uint16(31331),
		87: uint16(33976),
		88: uint16(35698),
		89: uint16(37304),
		90: uint16(37664),
		91: uint16(22065),
		92: uint16(22516),
		93: uint16(39166),
	},
	30: {
		0:  uint16(25325),
		1:  uint16(26893),
		2:  uint16(27542),
		3:  uint16(29165),
		4:  uint16(32340),
		5:  uint16(32887),
		6:  uint16(33394),
		7:  uint16(35302),
		8:  uint16(39135),
		9:  uint16(34645),
		10: uint16(36785),
		11: uint16(23611),
		12: uint16(20280),
		13: uint16(20449),
		14: uint16(20405),
		15: uint16(21767),
		16: uint16(23072),
		17: uint16(23517),
		18: uint16(23529),
		19: uint16(24515),
		20: uint16(24910),
		21: uint16(25391),
		22: uint16(26032),
		23: uint16(26187),
		24: uint16(26862),
		25: uint16(27035),
		26: uint16(28024),
		27: uint16(28145),
		28: uint16(30003),
		29: uint16(30137),
		30: uint16(30495),
		31: uint16(31070),
		32: uint16(31206),
		33: uint16(32051),
		34: uint16(33251),
		35: uint16(33455),
		36: uint16(34218),
		37: uint16(35242),
		38: uint16(35386),
		39: uint16(36523),
		40: uint16(36763),
		41: uint16(36914),
		42: uint16(37341),
		43: uint16(38663),
		44: uint16(20154),
		45: uint16(20161),
		46: uint16(20995),
		47: uint16(22645),
		48: uint16(22764),
		49: uint16(23563),
		50: uint16(29978),
		51: uint16(23613),
		52: uint16(33102),
		53: uint16(35338),
		54: uint16(36805),
		55: uint16(38499),
		56: uint16(38765),
		57: uint16(31525),
		58: uint16(35535),
		59: uint16(38920),
		60: uint16(37218),
		61: uint16(22259),
		62: uint16(21416),
		63: uint16(36887),
		64: uint16(21561),
		65: uint16(22402),
		66: uint16(24101),
		67: uint16(25512),
		68: uint16(27700),
		69: uint16(28810),
		70: uint16(30561),
		71: uint16(31883),
		72: uint16(32736),
		73: uint16(34928),
		74: uint16(36930),
		75: uint16(37204),
		76: uint16(37648),
		77: uint16(37656),
		78: uint16(38543),
		79: uint16(29790),
		80: uint16(39620),
		81: uint16(23815),
		82: uint16(23913),
		83: uint16(25968),
		84: uint16(26530),
		85: uint16(36264),
		86: uint16(38619),
		87: uint16(25454),
		88: uint16(26441),
		89: uint16(26905),
		90: uint16(33733),
		91: uint16(38935),
		92: uint16(38592),
		93: uint16(35070),
	},
	31: {
		0:  uint16(28548),
		1:  uint16(25722),
		2:  uint16(23544),
		3:  uint16(19990),
		4:  uint16(28716),
		5:  uint16(30045),
		6:  uint16(26159),
		7:  uint16(20932),
		8:  uint16(21046),
		9:  uint16(21218),
		10: uint16(22995),
		11: uint16(24449),
		12: uint16(24615),
		13: uint16(25104),
		14: uint16(25919),
		15: uint16(25972),
		16: uint16(26143),
		17: uint16(26228),
		18: uint16(26866),
		19: uint16(26646),
		20: uint16(27491),
		21: uint16(28165),
		22: uint16(29298),
		23: uint16(29983),
		24: uint16(30427),
		25: uint16(31934),
		26: uint16(32854),
		27: uint16(22768),
		28: uint16(35069),
		29: uint16(35199),
		30: uint16(35488),
		31: uint16(35475),
		32: uint16(35531),
		33: uint16(36893),
		34: uint16(37266),
		35: uint16(38738),
		36: uint16(38745),
		37: uint16(25993),
		38: uint16(31246),
		39: uint16(33030),
		40: uint16(38587),
		41: uint16(24109),
		42: uint16(24796),
		43: uint16(25114),
		44: uint16(26021),
		45: uint16(26132),
		46: uint16(26512),
		47: uint16(30707),
		48: uint16(31309),
		49: uint16(31821),
		50: uint16(32318),
		51: uint16(33034),
		52: uint16(36012),
		53: uint16(36196),
		54: uint16(36321),
		55: uint16(36447),
		56: uint16(30889),
		57: uint16(20999),
		58: uint16(25305),
		59: uint16(25509),
		60: uint16(25666),
		61: uint16(25240),
		62: uint16(35373),
		63: uint16(31363),
		64: uint16(31680),
		65: uint16(35500),
		66: uint16(38634),
		67: uint16(32118),
		68: uint16(33292),
		69: uint16(34633),
		70: uint16(20185),
		71: uint16(20808),
		72: uint16(21315),
		73: uint16(21344),
		74: uint16(23459),
		75: uint16(23554),
		76: uint16(23574),
		77: uint16(24029),
		78: uint16(25126),
		79: uint16(25159),
		80: uint16(25776),
		81: uint16(26643),
		82: uint16(26676),
		83: uint16(27849),
		84: uint16(27973),
		85: uint16(27927),
		86: uint16(26579),
		87: uint16(28508),
		88: uint16(29006),
		89: uint16(29053),
		90: uint16(26059),
		91: uint16(31359),
		92: uint16(31661),
		93: uint16(32218),
	},
	32: {
		0:  uint16(32330),
		1:  uint16(32680),
		2:  uint16(33146),
		3:  uint16(33307),
		4:  uint16(33337),
		5:  uint16(34214),
		6:  uint16(35438),
		7:  uint16(36046),
		8:  uint16(36341),
		9:  uint16(36984),
		10: uint16(36983),
		11: uint16(37549),
		12: uint16(37521),
		13: uint16(38275),
		14: uint16(39854),
		15: uint16(21069),
		16: uint16(21892),
		17: uint16(28472),
		18: uint16(28982),
		19: uint16(20840),
		20: uint16(31109),
		21: uint16(32341),
		22: uint16(33203),
		23: uint16(31950),
		24: uint16(22092),
		25: uint16(22609),
		26: uint16(23720),
		27: uint16(25514),
		28: uint16(26366),
		29: uint16(26365),
		30: uint16(26970),
		31: uint16(29401),
		32: uint16(30095),
		33: uint16(30094),
		34: uint16(30990),
		35: uint16(31062),
		36: uint16(31199),
		37: uint16(31895),
		38: uint16(32032),
		39: uint16(32068),
		40: uint16(34311),
		41: uint16(35380),
		42: uint16(38459),
		43: uint16(36961),
		44: uint16(40736),
		45: uint16(20711),
		46: uint16(21109),
		47: uint16(21452),
		48: uint16(21474),
		49: uint16(20489),
		50: uint16(21930),
		51: uint16(22766),
		52: uint16(22863),
		53: uint16(29245),
		54: uint16(23435),
		55: uint16(23652),
		56: uint16(21277),
		57: uint16(24803),
		58: uint16(24819),
		59: uint16(25436),
		60: uint16(25475),
		61: uint16(25407),
		62: uint16(25531),
		63: uint16(25805),
		64: uint16(26089),
		65: uint16(26361),
		66: uint16(24035),
		67: uint16(27085),
		68: uint16(27133),
		69: uint16(28437),
		70: uint16(29157),
		71: uint16(20105),
		72: uint16(30185),
		73: uint16(30456),
		74: uint16(31379),
		75: uint16(31967),
		76: uint16(32207),
		77: uint16(32156),
		78: uint16(32865),
		79: uint16(33609),
		80: uint16(33624),
		81: uint16(33900),
		82: uint16(33980),
		83: uint16(34299),
		84: uint16(35013),
		85: uint16(36208),
		86: uint16(36865),
		87: uint16(36973),
		88: uint16(37783),
		89: uint16(38684),
		90: uint16(39442),
		91: uint16(20687),
		92: uint16(22679),
		93: uint16(24974),
	},
	33: {
		0:  uint16(33235),
		1:  uint16(34101),
		2:  uint16(36104),
		3:  uint16(36896),
		4:  uint16(20419),
		5:  uint16(20596),
		6:  uint16(21063),
		7:  uint16(21363),
		8:  uint16(24687),
		9:  uint16(25417),
		10: uint16(26463),
		11: uint16(28204),
		12: uint16(36275),
		13: uint16(36895),
		14: uint16(20439),
		15: uint16(23646),
		16: uint16(36042),
		17: uint16(26063),
		18: uint16(32154),
		19: uint16(21330),
		20: uint16(34966),
		21: uint16(20854),
		22: uint16(25539),
		23: uint16(23384),
		24: uint16(23403),
		25: uint16(23562),
		26: uint16(25613),
		27: uint16(26449),
		28: uint16(36956),
		29: uint16(20182),
		30: uint16(22810),
		31: uint16(22826),
		32: uint16(27760),
		33: uint16(35409),
		34: uint16(21822),
		35: uint16(22549),
		36: uint16(22949),
		37: uint16(24816),
		38: uint16(25171),
		39: uint16(26561),
		40: uint16(33333),
		41: uint16(26965),
		42: uint16(38464),
		43: uint16(39364),
		44: uint16(39464),
		45: uint16(20307),
		46: uint16(22534),
		47: uint16(23550),
		48: uint16(32784),
		49: uint16(23729),
		50: uint16(24111),
		51: uint16(24453),
		52: uint16(24608),
		53: uint16(24907),
		54: uint16(25140),
		55: uint16(26367),
		56: uint16(27888),
		57: uint16(28382),
		58: uint16(32974),
		59: uint16(33151),
		60: uint16(33492),
		61: uint16(34955),
		62: uint16(36024),
		63: uint16(36864),
		64: uint16(36910),
		65: uint16(38538),
		66: uint16(40667),
		67: uint16(39899),
		68: uint16(20195),
		69: uint16(21488),
		70: uint16(22823),
		71: uint16(31532),
		72: uint16(37261),
		73: uint16(38988),
		74: uint16(40441),
		75: uint16(28381),
		76: uint16(28711),
		77: uint16(21331),
		78: uint16(21828),
		79: uint16(23429),
		80: uint16(25176),
		81: uint16(25246),
		82: uint16(25299),
		83: uint16(27810),
		84: uint16(28655),
		85: uint16(29730),
		86: uint16(35351),
		87: uint16(37944),
		88: uint16(28609),
		89: uint16(35582),
		90: uint16(33592),
		91: uint16(20967),
		92: uint16(34552),
		93: uint16(21482),
	},
	34: {
		0:  uint16(21481),
		1:  uint16(20294),
		2:  uint16(36948),
		3:  uint16(36784),
		4:  uint16(22890),
		5:  uint16(33073),
		6:  uint16(24061),
		7:  uint16(31466),
		8:  uint16(36799),
		9:  uint16(26842),
		10: uint16(35895),
		11: uint16(29432),
		12: uint16(40008),
		13: uint16(27197),
		14: uint16(35504),
		15: uint16(20025),
		16: uint16(21336),
		17: uint16(22022),
		18: uint16(22374),
		19: uint16(25285),
		20: uint16(25506),
		21: uint16(26086),
		22: uint16(27470),
		23: uint16(28129),
		24: uint16(28251),
		25: uint16(28845),
		26: uint16(30701),
		27: uint16(31471),
		28: uint16(31658),
		29: uint16(32187),
		30: uint16(32829),
		31: uint16(32966),
		32: uint16(34507),
		33: uint16(35477),
		34: uint16(37723),
		35: uint16(22243),
		36: uint16(22727),
		37: uint16(24382),
		38: uint16(26029),
		39: uint16(26262),
		40: uint16(27264),
		41: uint16(27573),
		42: uint16(30007),
		43: uint16(35527),
		44: uint16(20516),
		45: uint16(30693),
		46: uint16(22320),
		47: uint16(24347),
		48: uint16(24677),
		49: uint16(26234),
		50: uint16(27744),
		51: uint16(30196),
		52: uint16(31258),
		53: uint16(32622),
		54: uint16(33268),
		55: uint16(34584),
		56: uint16(36933),
		57: uint16(39347),
		58: uint16(31689),
		59: uint16(30044),
		60: uint16(31481),
		61: uint16(31569),
		62: uint16(33988),
		63: uint16(36880),
		64: uint16(31209),
		65: uint16(31378),
		66: uint16(33590),
		67: uint16(23265),
		68: uint16(30528),
		69: uint16(20013),
		70: uint16(20210),
		71: uint16(23449),
		72: uint16(24544),
		73: uint16(25277),
		74: uint16(26172),
		75: uint16(26609),
		76: uint16(27880),
		77: uint16(34411),
		78: uint16(34935),
		79: uint16(35387),
		80: uint16(37198),
		81: uint16(37619),
		82: uint16(39376),
		83: uint16(27159),
		84: uint16(28710),
		85: uint16(29482),
		86: uint16(33511),
		87: uint16(33879),
		88: uint16(36015),
		89: uint16(19969),
		90: uint16(20806),
		91: uint16(20939),
		92: uint16(21899),
		93: uint16(23541),
	},
	35: {
		0:  uint16(24086),
		1:  uint16(24115),
		2:  uint16(24193),
		3:  uint16(24340),
		4:  uint16(24373),
		5:  uint16(24427),
		6:  uint16(24500),
		7:  uint16(25074),
		8:  uint16(25361),
		9:  uint16(26274),
		10: uint16(26397),
		11: uint16(28526),
		12: uint16(29266),
		13: uint16(30010),
		14: uint16(30522),
		15: uint16(32884),
		16: uint16(33081),
		17: uint16(33144),
		18: uint16(34678),
		19: uint16(35519),
		20: uint16(35548),
		21: uint16(36229),
		22: uint16(36339),
		23: uint16(37530),
		24: uint16(38263),
		25: uint16(38914),
		26: uint16(40165),
		27: uint16(21189),
		28: uint16(25431),
		29: uint16(30452),
		30: uint16(26389),
		31: uint16(27784),
		32: uint16(29645),
		33: uint16(36035),
		34: uint16(37806),
		35: uint16(38515),
		36: uint16(27941),
		37: uint16(22684),
		38: uint16(26894),
		39: uint16(27084),
		40: uint16(36861),
		41: uint16(37786),
		42: uint16(30171),
		43: uint16(36890),
		44: uint16(22618),
		45: uint16(26626),
		46: uint16(25524),
		47: uint16(27131),
		48: uint16(20291),
		49: uint16(28460),
		50: uint16(26584),
		51: uint16(36795),
		52: uint16(34086),
		53: uint16(32180),
		54: uint16(37716),
		55: uint16(26943),
		56: uint16(28528),
		57: uint16(22378),
		58: uint16(22775),
		59: uint16(23340),
		60: uint16(32044),
		61: uint16(29226),
		62: uint16(21514),
		63: uint16(37347),
		64: uint16(40372),
		65: uint16(20141),
		66: uint16(20302),
		67: uint16(20572),
		68: uint16(20597),
		69: uint16(21059),
		70: uint16(35998),
		71: uint16(21576),
		72: uint16(22564),
		73: uint16(23450),
		74: uint16(24093),
		75: uint16(24213),
		76: uint16(24237),
		77: uint16(24311),
		78: uint16(24351),
		79: uint16(24716),
		80: uint16(25269),
		81: uint16(25402),
		82: uint16(25552),
		83: uint16(26799),
		84: uint16(27712),
		85: uint16(30855),
		86: uint16(31118),
		87: uint16(31243),
		88: uint16(32224),
		89: uint16(33351),
		90: uint16(35330),
		91: uint16(35558),
		92: uint16(36420),
		93: uint16(36883),
	},
	36: {
		0:  uint16(37048),
		1:  uint16(37165),
		2:  uint16(37336),
		3:  uint16(40718),
		4:  uint16(27877),
		5:  uint16(25688),
		6:  uint16(25826),
		7:  uint16(25973),
		8:  uint16(28404),
		9:  uint16(30340),
		10: uint16(31515),
		11: uint16(36969),
		12: uint16(37841),
		13: uint16(28346),
		14: uint16(21746),
		15: uint16(24505),
		16: uint16(25764),
		17: uint16(36685),
		18: uint16(36845),
		19: uint16(37444),
		20: uint16(20856),
		21: uint16(22635),
		22: uint16(22825),
		23: uint16(23637),
		24: uint16(24215),
		25: uint16(28155),
		26: uint16(32399),
		27: uint16(29980),
		28: uint16(36028),
		29: uint16(36578),
		30: uint16(39003),
		31: uint16(28857),
		32: uint16(20253),
		33: uint16(27583),
		34: uint16(28593),
		35: uint16(30000),
		36: uint16(38651),
		37: uint16(20814),
		38: uint16(21520),
		39: uint16(22581),
		40: uint16(22615),
		41: uint16(22956),
		42: uint16(23648),
		43: uint16(24466),
		44: uint16(26007),
		45: uint16(26460),
		46: uint16(28193),
		47: uint16(30331),
		48: uint16(33759),
		49: uint16(36077),
		50: uint16(36884),
		51: uint16(37117),
		52: uint16(37709),
		53: uint16(30757),
		54: uint16(30778),
		55: uint16(21162),
		56: uint16(24230),
		57: uint16(22303),
		58: uint16(22900),
		59: uint16(24594),
		60: uint16(20498),
		61: uint16(20826),
		62: uint16(20908),
		63: uint16(20941),
		64: uint16(20992),
		65: uint16(21776),
		66: uint16(22612),
		67: uint16(22616),
		68: uint16(22871),
		69: uint16(23445),
		70: uint16(23798),
		71: uint16(23947),
		72: uint16(24764),
		73: uint16(25237),
		74: uint16(25645),
		75: uint16(26481),
		76: uint16(26691),
		77: uint16(26812),
		78: uint16(26847),
		79: uint16(30423),
		80: uint16(28120),
		81: uint16(28271),
		82: uint16(28059),
		83: uint16(28783),
		84: uint16(29128),
		85: uint16(24403),
		86: uint16(30168),
		87: uint16(31095),
		88: uint16(31561),
		89: uint16(31572),
		90: uint16(31570),
		91: uint16(31958),
		92: uint16(32113),
		93: uint16(21040),
	},
	37: {
		0:  uint16(33891),
		1:  uint16(34153),
		2:  uint16(34276),
		3:  uint16(35342),
		4:  uint16(35588),
		5:  uint16(35910),
		6:  uint16(36367),
		7:  uint16(36867),
		8:  uint16(36879),
		9:  uint16(37913),
		10: uint16(38518),
		11: uint16(38957),
		12: uint16(39472),
		13: uint16(38360),
		14: uint16(20685),
		15: uint16(21205),
		16: uint16(21516),
		17: uint16(22530),
		18: uint16(23566),
		19: uint16(24999),
		20: uint16(25758),
		21: uint16(27934),
		22: uint16(30643),
		23: uint16(31461),
		24: uint16(33012),
		25: uint16(33796),
		26: uint16(36947),
		27: uint16(37509),
		28: uint16(23776),
		29: uint16(40199),
		30: uint16(21311),
		31: uint16(24471),
		32: uint16(24499),
		33: uint16(28060),
		34: uint16(29305),
		35: uint16(30563),
		36: uint16(31167),
		37: uint16(31716),
		38: uint16(27602),
		39: uint16(29420),
		40: uint16(35501),
		41: uint16(26627),
		42: uint16(27233),
		43: uint16(20984),
		44: uint16(31361),
		45: uint16(26932),
		46: uint16(23626),
		47: uint16(40182),
		48: uint16(33515),
		49: uint16(23493),
		50: uint16(37193),
		51: uint16(28702),
		52: uint16(22136),
		53: uint16(23663),
		54: uint16(24775),
		55: uint16(25958),
		56: uint16(27788),
		57: uint16(35930),
		58: uint16(36929),
		59: uint16(38931),
		60: uint16(21585),
		61: uint16(26311),
		62: uint16(37389),
		63: uint16(22856),
		64: uint16(37027),
		65: uint16(20869),
		66: uint16(20045),
		67: uint16(20970),
		68: uint16(34201),
		69: uint16(35598),
		70: uint16(28760),
		71: uint16(25466),
		72: uint16(37707),
		73: uint16(26978),
		74: uint16(39348),
		75: uint16(32260),
		76: uint16(30071),
		77: uint16(21335),
		78: uint16(26976),
		79: uint16(36575),
		80: uint16(38627),
		81: uint16(27741),
		82: uint16(20108),
		83: uint16(23612),
		84: uint16(24336),
		85: uint16(36841),
		86: uint16(21250),
		87: uint16(36049),
		88: uint16(32905),
		89: uint16(34425),
		90: uint16(24319),
		91: uint16(26085),
		92: uint16(20083),
		93: uint16(20837),
	},
	38: {
		0:  uint16(22914),
		1:  uint16(23615),
		2:  uint16(38894),
		3:  uint16(20219),
		4:  uint16(22922),
		5:  uint16(24525),
		6:  uint16(35469),
		7:  uint16(28641),
		8:  uint16(31152),
		9:  uint16(31074),
		10: uint16(23527),
		11: uint16(33905),
		12: uint16(29483),
		13: uint16(29105),
		14: uint16(24180),
		15: uint16(24565),
		16: uint16(25467),
		17: uint16(25754),
		18: uint16(29123),
		19: uint16(31896),
		20: uint16(20035),
		21: uint16(24316),
		22: uint16(20043),
		23: uint16(22492),
		24: uint16(22178),
		25: uint16(24745),
		26: uint16(28611),
		27: uint16(32013),
		28: uint16(33021),
		29: uint16(33075),
		30: uint16(33215),
		31: uint16(36786),
		32: uint16(35223),
		33: uint16(34468),
		34: uint16(24052),
		35: uint16(25226),
		36: uint16(25773),
		37: uint16(35207),
		38: uint16(26487),
		39: uint16(27874),
		40: uint16(27966),
		41: uint16(29750),
		42: uint16(30772),
		43: uint16(23110),
		44: uint16(32629),
		45: uint16(33453),
		46: uint16(39340),
		47: uint16(20467),
		48: uint16(24259),
		49: uint16(25309),
		50: uint16(25490),
		51: uint16(25943),
		52: uint16(26479),
		53: uint16(30403),
		54: uint16(29260),
		55: uint16(32972),
		56: uint16(32954),
		57: uint16(36649),
		58: uint16(37197),
		59: uint16(20493),
		60: uint16(22521),
		61: uint16(23186),
		62: uint16(26757),
		63: uint16(26995),
		64: uint16(29028),
		65: uint16(29437),
		66: uint16(36023),
		67: uint16(22770),
		68: uint16(36064),
		69: uint16(38506),
		70: uint16(36889),
		71: uint16(34687),
		72: uint16(31204),
		73: uint16(30695),
		74: uint16(33833),
		75: uint16(20271),
		76: uint16(21093),
		77: uint16(21338),
		78: uint16(25293),
		79: uint16(26575),
		80: uint16(27850),
		81: uint16(30333),
		82: uint16(31636),
		83: uint16(31893),
		84: uint16(33334),
		85: uint16(34180),
		86: uint16(36843),
		87: uint16(26333),
		88: uint16(28448),
		89: uint16(29190),
		90: uint16(32283),
		91: uint16(33707),
		92: uint16(39361),
		93: uint16(40614),
	},
	39: {
		0:  uint16(20989),
		1:  uint16(31665),
		2:  uint16(30834),
		3:  uint16(31672),
		4:  uint16(32903),
		5:  uint16(31560),
		6:  uint16(27368),
		7:  uint16(24161),
		8:  uint16(32908),
		9:  uint16(30033),
		10: uint16(30048),
		11: uint16(20843),
		12: uint16(37474),
		13: uint16(28300),
		14: uint16(30330),
		15: uint16(37271),
		16: uint16(39658),
		17: uint16(20240),
		18: uint16(32624),
		19: uint16(25244),
		20: uint16(31567),
		21: uint16(38309),
		22: uint16(40169),
		23: uint16(22138),
		24: uint16(22617),
		25: uint16(34532),
		26: uint16(38588),
		27: uint16(20276),
		28: uint16(21028),
		29: uint16(21322),
		30: uint16(21453),
		31: uint16(21467),
		32: uint16(24070),
		33: uint16(25644),
		34: uint16(26001),
		35: uint16(26495),
		36: uint16(27710),
		37: uint16(27726),
		38: uint16(29256),
		39: uint16(29359),
		40: uint16(29677),
		41: uint16(30036),
		42: uint16(32321),
		43: uint16(33324),
		44: uint16(34281),
		45: uint16(36009),
		46: uint16(31684),
		47: uint16(37318),
		48: uint16(29033),
		49: uint16(38930),
		50: uint16(39151),
		51: uint16(25405),
		52: uint16(26217),
		53: uint16(30058),
		54: uint16(30436),
		55: uint16(30928),
		56: uint16(34115),
		57: uint16(34542),
		58: uint16(21290),
		59: uint16(21329),
		60: uint16(21542),
		61: uint16(22915),
		62: uint16(24199),
		63: uint16(24444),
		64: uint16(24754),
		65: uint16(25161),
		66: uint16(25209),
		67: uint16(25259),
		68: uint16(26000),
		69: uint16(27604),
		70: uint16(27852),
		71: uint16(30130),
		72: uint16(30382),
		73: uint16(30865),
		74: uint16(31192),
		75: uint16(32203),
		76: uint16(32631),
		77: uint16(32933),
		78: uint16(34987),
		79: uint16(35513),
		80: uint16(36027),
		81: uint16(36991),
		82: uint16(38750),
		83: uint16(39131),
		84: uint16(27147),
		85: uint16(31800),
		86: uint16(20633),
		87: uint16(23614),
		88: uint16(24494),
		89: uint16(26503),
		90: uint16(27608),
		91: uint16(29749),
		92: uint16(30473),
		93: uint16(32654),
	},
	40: {
		0:  uint16(40763),
		1:  uint16(26570),
		2:  uint16(31255),
		3:  uint16(21305),
		4:  uint16(30091),
		5:  uint16(39661),
		6:  uint16(24422),
		7:  uint16(33181),
		8:  uint16(33777),
		9:  uint16(32920),
		10: uint16(24380),
		11: uint16(24517),
		12: uint16(30050),
		13: uint16(31558),
		14: uint16(36924),
		15: uint16(26727),
		16: uint16(23019),
		17: uint16(23195),
		18: uint16(32016),
		19: uint16(30334),
		20: uint16(35628),
		21: uint16(20469),
		22: uint16(24426),
		23: uint16(27161),
		24: uint16(27703),
		25: uint16(28418),
		26: uint16(29922),
		27: uint16(31080),
		28: uint16(34920),
		29: uint16(35413),
		30: uint16(35961),
		31: uint16(24287),
		32: uint16(25551),
		33: uint16(30149),
		34: uint16(31186),
		35: uint16(33495),
		36: uint16(37672),
		37: uint16(37618),
		38: uint16(33948),
		39: uint16(34541),
		40: uint16(39981),
		41: uint16(21697),
		42: uint16(24428),
		43: uint16(25996),
		44: uint16(27996),
		45: uint16(28693),
		46: uint16(36007),
		47: uint16(36051),
		48: uint16(38971),
		49: uint16(25935),
		50: uint16(29942),
		51: uint16(19981),
		52: uint16(20184),
		53: uint16(22496),
		54: uint16(22827),
		55: uint16(23142),
		56: uint16(23500),
		57: uint16(20904),
		58: uint16(24067),
		59: uint16(24220),
		60: uint16(24598),
		61: uint16(25206),
		62: uint16(25975),
		63: uint16(26023),
		64: uint16(26222),
		65: uint16(28014),
		66: uint16(29238),
		67: uint16(31526),
		68: uint16(33104),
		69: uint16(33178),
		70: uint16(33433),
		71: uint16(35676),
		72: uint16(36000),
		73: uint16(36070),
		74: uint16(36212),
		75: uint16(38428),
		76: uint16(38468),
		77: uint16(20398),
		78: uint16(25771),
		79: uint16(27494),
		80: uint16(33310),
		81: uint16(33889),
		82: uint16(34154),
		83: uint16(37096),
		84: uint16(23553),
		85: uint16(26963),
		86: uint16(39080),
		87: uint16(33914),
		88: uint16(34135),
		89: uint16(20239),
		90: uint16(21103),
		91: uint16(24489),
		92: uint16(24133),
		93: uint16(26381),
	},
	41: {
		0:  uint16(31119),
		1:  uint16(33145),
		2:  uint16(35079),
		3:  uint16(35206),
		4:  uint16(28149),
		5:  uint16(24343),
		6:  uint16(25173),
		7:  uint16(27832),
		8:  uint16(20175),
		9:  uint16(29289),
		10: uint16(39826),
		11: uint16(20998),
		12: uint16(21563),
		13: uint16(22132),
		14: uint16(22707),
		15: uint16(24996),
		16: uint16(25198),
		17: uint16(28954),
		18: uint16(22894),
		19: uint16(31881),
		20: uint16(31966),
		21: uint16(32027),
		22: uint16(38640),
		23: uint16(25991),
		24: uint16(32862),
		25: uint16(19993),
		26: uint16(20341),
		27: uint16(20853),
		28: uint16(22592),
		29: uint16(24163),
		30: uint16(24179),
		31: uint16(24330),
		32: uint16(26564),
		33: uint16(20006),
		34: uint16(34109),
		35: uint16(38281),
		36: uint16(38491),
		37: uint16(31859),
		38: uint16(38913),
		39: uint16(20731),
		40: uint16(22721),
		41: uint16(30294),
		42: uint16(30887),
		43: uint16(21029),
		44: uint16(30629),
		45: uint16(34065),
		46: uint16(31622),
		47: uint16(20559),
		48: uint16(22793),
		49: uint16(29255),
		50: uint16(31687),
		51: uint16(32232),
		52: uint16(36794),
		53: uint16(36820),
		54: uint16(36941),
		55: uint16(20415),
		56: uint16(21193),
		57: uint16(23081),
		58: uint16(24321),
		59: uint16(38829),
		60: uint16(20445),
		61: uint16(33303),
		62: uint16(37610),
		63: uint16(22275),
		64: uint16(25429),
		65: uint16(27497),
		66: uint16(29995),
		67: uint16(35036),
		68: uint16(36628),
		69: uint16(31298),
		70: uint16(21215),
		71: uint16(22675),
		72: uint16(24917),
		73: uint16(25098),
		74: uint16(26286),
		75: uint16(27597),
		76: uint16(31807),
		77: uint16(33769),
		78: uint16(20515),
		79: uint16(20472),
		80: uint16(21253),
		81: uint16(21574),
		82: uint16(22577),
		83: uint16(22857),
		84: uint16(23453),
		85: uint16(23792),
		86: uint16(23791),
		87: uint16(23849),
		88: uint16(24214),
		89: uint16(25265),
		90: uint16(25447),
		91: uint16(25918),
		92: uint16(26041),
		93: uint16(26379),
	},
	42: {
		0:  uint16(27861),
		1:  uint16(27873),
		2:  uint16(28921),
		3:  uint16(30770),
		4:  uint16(32299),
		5:  uint16(32990),
		6:  uint16(33459),
		7:  uint16(33804),
		8:  uint16(34028),
		9:  uint16(34562),
		10: uint16(35090),
		11: uint16(35370),
		12: uint16(35914),
		13: uint16(37030),
		14: uint16(37586),
		15: uint16(39165),
		16: uint16(40179),
		17: uint16(40300),
		18: uint16(20047),
		19: uint16(20129),
		20: uint16(20621),
		21: uint16(21078),
		22: uint16(22346),
		23: uint16(22952),
		24: uint16(24125),
		25: uint16(24536),
		26: uint16(24537),
		27: uint16(25151),
		28: uint16(26292),
		29: uint16(26395),
		30: uint16(26576),
		31: uint16(26834),
		32: uint16(20882),
		33: uint16(32033),
		34: uint16(32938),
		35: uint16(33192),
		36: uint16(35584),
		37: uint16(35980),
		38: uint16(36031),
		39: uint16(37502),
		40: uint16(38450),
		41: uint16(21536),
		42: uint16(38956),
		43: uint16(21271),
		44: uint16(20693),
		45: uint16(21340),
		46: uint16(22696),
		47: uint16(25778),
		48: uint16(26420),
		49: uint16(29287),
		50: uint16(30566),
		51: uint16(31302),
		52: uint16(37350),
		53: uint16(21187),
		54: uint16(27809),
		55: uint16(27526),
		56: uint16(22528),
		57: uint16(24140),
		58: uint16(22868),
		59: uint16(26412),
		60: uint16(32763),
		61: uint16(20961),
		62: uint16(30406),
		63: uint16(25705),
		64: uint16(30952),
		65: uint16(39764),
		66: uint16(40635),
		67: uint16(22475),
		68: uint16(22969),
		69: uint16(26151),
		70: uint16(26522),
		71: uint16(27598),
		72: uint16(21737),
		73: uint16(27097),
		74: uint16(24149),
		75: uint16(33180),
		76: uint16(26517),
		77: uint16(39850),
		78: uint16(26622),
		79: uint16(40018),
		80: uint16(26717),
		81: uint16(20134),
		82: uint16(20451),
		83: uint16(21448),
		84: uint16(25273),
		85: uint16(26411),
		86: uint16(27819),
		87: uint16(36804),
		88: uint16(20397),
		89: uint16(32365),
		90: uint16(40639),
		91: uint16(19975),
		92: uint16(24930),
		93: uint16(28288),
	},
	43: {
		0:  uint16(28459),
		1:  uint16(34067),
		2:  uint16(21619),
		3:  uint16(26410),
		4:  uint16(39749),
		5:  uint16(24051),
		6:  uint16(31637),
		7:  uint16(23724),
		8:  uint16(23494),
		9:  uint16(34588),
		10: uint16(28234),
		11: uint16(34001),
		12: uint16(31252),
		13: uint16(33032),
		14: uint16(22937),
		15: uint16(31885),
		16: uint16(27665),
		17: uint16(30496),
		18: uint16(21209),
		19: uint16(22818),
		20: uint16(28961),
		21: uint16(29279),
		22: uint16(30683),
		23: uint16(38695),
		24: uint16(40289),
		25: uint16(26891),
		26: uint16(23167),
		27: uint16(23064),
		28: uint16(20901),
		29: uint16(21517),
		30: uint16(21629),
		31: uint16(26126),
		32: uint16(30431),
		33: uint16(36855),
		34: uint16(37528),
		35: uint16(40180),
		36: uint16(23018),
		37: uint16(29277),
		38: uint16(28357),
		39: uint16(20813),
		40: uint16(26825),
		41: uint16(32191),
		42: uint16(32236),
		43: uint16(38754),
		44: uint16(40634),
		45: uint16(25720),
		46: uint16(27169),
		47: uint16(33538),
		48: uint16(22916),
		49: uint16(23391),
		50: uint16(27611),
		51: uint16(29467),
		52: uint16(30450),
		53: uint16(32178),
		54: uint16(32791),
		55: uint16(33945),
		56: uint16(20786),
		57: uint16(26408),
		58: uint16(40665),
		59: uint16(30446),
		60: uint16(26466),
		61: uint16(21247),
		62: uint16(39173),
		63: uint16(23588),
		64: uint16(25147),
		65: uint16(31870),
		66: uint16(36016),
		67: uint16(21839),
		68: uint16(24758),
		69: uint16(32011),
		70: uint16(38272),
		71: uint16(21249),
		72: uint16(20063),
		73: uint16(20918),
		74: uint16(22812),
		75: uint16(29242),
		76: uint16(32822),
		77: uint16(37326),
		78: uint16(24357),
		79: uint16(30690),
		80: uint16(21380),
		81: uint16(24441),
		82: uint16(32004),
		83: uint16(34220),
		84: uint16(35379),
		85: uint16(36493),
		86: uint16(38742),
		87: uint16(26611),
		88: uint16(34222),
		89: uint16(37971),
		90: uint16(24841),
		91: uint16(24840),
		92: uint16(27833),
		93: uint16(30290),
	},
	44: {
		0:  uint16(35565),
		1:  uint16(36664),
		2:  uint16(21807),
		3:  uint16(20305),
		4:  uint16(20778),
		5:  uint16(21191),
		6:  uint16(21451),
		7:  uint16(23461),
		8:  uint16(24189),
		9:  uint16(24736),
		10: uint16(24962),
		11: uint16(25558),
		12: uint16(26377),
		13: uint16(26586),
		14: uint16(28263),
		15: uint16(28044),
		16: uint16(29494),
		17: uint16(29495),
		18: uint16(30001),
		19: uint16(31056),
		20: uint16(35029),
		21: uint16(35480),
		22: uint16(36938),
		23: uint16(37009),
		24: uint16(37109),
		25: uint16(38596),
		26: uint16(34701),
		27: uint16(22805),
		28: uint16(20104),
		29: uint16(20313),
		30: uint16(19982),
		31: uint16(35465),
		32: uint16(36671),
		33: uint16(38928),
		34: uint16(20653),
		35: uint16(24188),
		36: uint16(22934),
		37: uint16(23481),
		38: uint16(24248),
		39: uint16(25562),
		40: uint16(25594),
		41: uint16(25793),
		42: uint16(26332),
		43: uint16(26954),
		44: uint16(27096),
		45: uint16(27915),
		46: uint16(28342),
		47: uint16(29076),
		48: uint16(29992),
		49: uint16(31407),
		50: uint16(32650),
		51: uint16(32768),
		52: uint16(33865),
		53: uint16(33993),
		54: uint16(35201),
		55: uint16(35617),
		56: uint16(36362),
		57: uint16(36965),
		58: uint16(38525),
		59: uint16(39178),
		60: uint16(24958),
		61: uint16(25233),
		62: uint16(27442),
		63: uint16(27779),
		64: uint16(28020),
		65: uint16(32716),
		66: uint16(32764),
		67: uint16(28096),
		68: uint16(32645),
		69: uint16(34746),
		70: uint16(35064),
		71: uint16(26469),
		72: uint16(33713),
		73: uint16(38972),
		74: uint16(38647),
		75: uint16(27931),
		76: uint16(32097),
		77: uint16(33853),
		78: uint16(37226),
		79: uint16(20081),
		80: uint16(21365),
		81: uint16(23888),
		82: uint16(27396),
		83: uint16(28651),
		84: uint16(34253),
		85: uint16(34349),
		86: uint16(35239),
		87: uint16(21033),
		88: uint16(21519),
		89: uint16(23653),
		90: uint16(26446),
		91: uint16(26792),
		92: uint16(29702),
		93: uint16(29827),
	},
	45: {
		0:  uint16(30178),
		1:  uint16(35023),
		2:  uint16(35041),
		3:  uint16(37324),
		4:  uint16(38626),
		5:  uint16(38520),
		6:  uint16(24459),
		7:  uint16(29575),
		8:  uint16(31435),
		9:  uint16(33870),
		10: uint16(25504),
		11: uint16(30053),
		12: uint16(21129),
		13: uint16(27969),
		14: uint16(28316),
		15: uint16(29705),
		16: uint16(30041),
		17: uint16(30827),
		18: uint16(31890),
		19: uint16(38534),
		20: uint16(31452),
		21: uint16(40845),
		22: uint16(20406),
		23: uint16(24942),
		24: uint16(26053),
		25: uint16(34396),
		26: uint16(20102),
		27: uint16(20142),
		28: uint16(20698),
		29: uint16(20001),
		30: uint16(20940),
		31: uint16(23534),
		32: uint16(26009),
		33: uint16(26753),
		34: uint16(28092),
		35: uint16(29471),
		36: uint16(30274),
		37: uint16(30637),
		38: uint16(31260),
		39: uint16(31975),
		40: uint16(33391),
		41: uint16(35538),
		42: uint16(36988),
		43: uint16(37327),
		44: uint16(38517),
		45: uint16(38936),
		46: uint16(21147),
		47: uint16(32209),
		48: uint16(20523),
		49: uint16(21400),
		50: uint16(26519),
		51: uint16(28107),
		52: uint16(29136),
		53: uint16(29747),
		54: uint16(33256),
		55: uint16(36650),
		56: uint16(38563),
		57: uint16(40023),
		58: uint16(40607),
		59: uint16(29792),
		60: uint16(22593),
		61: uint16(28057),
		62: uint16(32047),
		63: uint16(39006),
		64: uint16(20196),
		65: uint16(20278),
		66: uint16(20363),
		67: uint16(20919),
		68: uint16(21169),
		69: uint16(23994),
		70: uint16(24604),
		71: uint16(29618),
		72: uint16(31036),
		73: uint16(33491),
		74: uint16(37428),
		75: uint16(38583),
		76: uint16(38646),
		77: uint16(38666),
		78: uint16(40599),
		79: uint16(40802),
		80: uint16(26278),
		81: uint16(27508),
		82: uint16(21015),
		83: uint16(21155),
		84: uint16(28872),
		85: uint16(35010),
		86: uint16(24265),
		87: uint16(24651),
		88: uint16(24976),
		89: uint16(28451),
		90: uint16(29001),
		91: uint16(31806),
		92: uint16(32244),
		93: uint16(32879),
	},
	46: {
		0:  uint16(34030),
		1:  uint16(36899),
		2:  uint16(37676),
		3:  uint16(21570),
		4:  uint16(39791),
		5:  uint16(27347),
		6:  uint16(28809),
		7:  uint16(36034),
		8:  uint16(36335),
		9:  uint16(38706),
		10: uint16(21172),
		11: uint16(23105),
		12: uint16(24266),
		13: uint16(24324),
		14: uint16(26391),
		15: uint16(27004),
		16: uint16(27028),
		17: uint16(28010),
		18: uint16(28431),
		19: uint16(29282),
		20: uint16(29436),
		21: uint16(31725),
		22: uint16(32769),
		23: uint16(32894),
		24: uint16(34635),
		25: uint16(37070),
		26: uint16(20845),
		27: uint16(40595),
		28: uint16(31108),
		29: uint16(32907),
		30: uint16(37682),
		31: uint16(35542),
		32: uint16(20525),
		33: uint16(21644),
		34: uint16(35441),
		35: uint16(27498),
		36: uint16(36036),
		37: uint16(33031),
		38: uint16(24785),
		39: uint16(26528),
		40: uint16(40434),
		41: uint16(20121),
		42: uint16(20120),
		43: uint16(39952),
		44: uint16(35435),
		45: uint16(34241),
		46: uint16(34152),
		47: uint16(26880),
		48: uint16(28286),
		49: uint16(30871),
		50: uint16(33109),
	},
	47: {
		0:  uint16(24332),
		1:  uint16(19984),
		2:  uint16(19989),
		3:  uint16(20010),
		4:  uint16(20017),
		5:  uint16(20022),
		6:  uint16(20028),
		7:  uint16(20031),
		8:  uint16(20034),
		9:  uint16(20054),
		10: uint16(20056),
		11: uint16(20098),
		12: uint16(20101),
		13: uint16(35947),
		14: uint16(20106),
		15: uint16(33298),
		16: uint16(24333),
		17: uint16(20110),
		18: uint16(20126),
		19: uint16(20127),
		20: uint16(20128),
		21: uint16(20130),
		22: uint16(20144),
		23: uint16(20147),
		24: uint16(20150),
		25: uint16(20174),
		26: uint16(20173),
		27: uint16(20164),
		28: uint16(20166),
		29: uint16(20162),
		30: uint16(20183),
		31: uint16(20190),
		32: uint16(20205),
		33: uint16(20191),
		34: uint16(20215),
		35: uint16(20233),
		36: uint16(20314),
		37: uint16(20272),
		38: uint16(20315),
		39: uint16(20317),
		40: uint16(20311),
		41: uint16(20295),
		42: uint16(20342),
		43: uint16(20360),
		44: uint16(20367),
		45: uint16(20376),
		46: uint16(20347),
		47: uint16(20329),
		48: uint16(20336),
		49: uint16(20369),
		50: uint16(20335),
		51: uint16(20358),
		52: uint16(20374),
		53: uint16(20760),
		54: uint16(20436),
		55: uint16(20447),
		56: uint16(20430),
		57: uint16(20440),
		58: uint16(20443),
		59: uint16(20433),
		60: uint16(20442),
		61: uint16(20432),
		62: uint16(20452),
		63: uint16(20453),
		64: uint16(20506),
		65: uint16(20520),
		66: uint16(20500),
		67: uint16(20522),
		68: uint16(20517),
		69: uint16(20485),
		70: uint16(20252),
		71: uint16(20470),
		72: uint16(20513),
		73: uint16(20521),
		74: uint16(20524),
		75: uint16(20478),
		76: uint16(20463),
		77: uint16(20497),
		78: uint16(20486),
		79: uint16(20547),
		80: uint16(20551),
		81: uint16(26371),
		82: uint16(20565),
		83: uint16(20560),
		84: uint16(20552),
		85: uint16(20570),
		86: uint16(20566),
		87: uint16(20588),
		88: uint16(20600),
		89: uint16(20608),
		90: uint16(20634),
		91: uint16(20613),
		92: uint16(20660),
		93: uint16(20658),
	},
	48: {
		0:  uint16(20681),
		1:  uint16(20682),
		2:  uint16(20659),
		3:  uint16(20674),
		4:  uint16(20694),
		5:  uint16(20702),
		6:  uint16(20709),
		7:  uint16(20717),
		8:  uint16(20707),
		9:  uint16(20718),
		10: uint16(20729),
		11: uint16(20725),
		12: uint16(20745),
		13: uint16(20737),
		14: uint16(20738),
		15: uint16(20758),
		16: uint16(20757),
		17: uint16(20756),
		18: uint16(20762),
		19: uint16(20769),
		20: uint16(20794),
		21: uint16(20791),
		22: uint16(20796),
		23: uint16(20795),
		24: uint16(20799),
		25: uint16(20800),
		26: uint16(20818),
		27: uint16(20812),
		28: uint16(20820),
		29: uint16(20834),
		30: uint16(31480),
		31: uint16(20841),
		32: uint16(20842),
		33: uint16(20846),
		34: uint16(20864),
		35: uint16(20866),
		36: uint16(22232),
		37: uint16(20876),
		38: uint16(20873),
		39: uint16(20879),
		40: uint16(20881),
		41: uint16(20883),
		42: uint16(20885),
		43: uint16(20886),
		44: uint16(20900),
		45: uint16(20902),
		46: uint16(20898),
		47: uint16(20905),
		48: uint16(20906),
		49: uint16(20907),
		50: uint16(20915),
		51: uint16(20913),
		52: uint16(20914),
		53: uint16(20912),
		54: uint16(20917),
		55: uint16(20925),
		56: uint16(20933),
		57: uint16(20937),
		58: uint16(20955),
		59: uint16(20960),
		60: uint16(34389),
		61: uint16(20969),
		62: uint16(20973),
		63: uint16(20976),
		64: uint16(20981),
		65: uint16(20990),
		66: uint16(20996),
		67: uint16(21003),
		68: uint16(21012),
		69: uint16(21006),
		70: uint16(21031),
		71: uint16(21034),
		72: uint16(21038),
		73: uint16(21043),
		74: uint16(21049),
		75: uint16(21071),
		76: uint16(21060),
		77: uint16(21067),
		78: uint16(21068),
		79: uint16(21086),
		80: uint16(21076),
		81: uint16(21098),
		82: uint16(21108),
		83: uint16(21097),
		84: uint16(21107),
		85: uint16(21119),
		86: uint16(21117),
		87: uint16(21133),
		88: uint16(21140),
		89: uint16(21138),
		90: uint16(21105),
		91: uint16(21128),
		92: uint16(21137),
		93: uint16(36776),
	},
	49: {
		0:  uint16(36775),
		1:  uint16(21164),
		2:  uint16(21165),
		3:  uint16(21180),
		4:  uint16(21173),
		5:  uint16(21185),
		6:  uint16(21197),
		7:  uint16(21207),
		8:  uint16(21214),
		9:  uint16(21219),
		10: uint16(21222),
		11: uint16(39149),
		12: uint16(21216),
		13: uint16(21235),
		14: uint16(21237),
		15: uint16(21240),
		16: uint16(21241),
		17: uint16(21254),
		18: uint16(21256),
		19: uint16(30008),
		20: uint16(21261),
		21: uint16(21264),
		22: uint16(21263),
		23: uint16(21269),
		24: uint16(21274),
		25: uint16(21283),
		26: uint16(21295),
		27: uint16(21297),
		28: uint16(21299),
		29: uint16(21304),
		30: uint16(21312),
		31: uint16(21318),
		32: uint16(21317),
		33: uint16(19991),
		34: uint16(21321),
		35: uint16(21325),
		36: uint16(20950),
		37: uint16(21342),
		38: uint16(21353),
		39: uint16(21358),
		40: uint16(22808),
		41: uint16(21371),
		42: uint16(21367),
		43: uint16(21378),
		44: uint16(21398),
		45: uint16(21408),
		46: uint16(21414),
		47: uint16(21413),
		48: uint16(21422),
		49: uint16(21424),
		50: uint16(21430),
		51: uint16(21443),
		52: uint16(31762),
		53: uint16(38617),
		54: uint16(21471),
		55: uint16(26364),
		56: uint16(29166),
		57: uint16(21486),
		58: uint16(21480),
		59: uint16(21485),
		60: uint16(21498),
		61: uint16(21505),
		62: uint16(21565),
		63: uint16(21568),
		64: uint16(21548),
		65: uint16(21549),
		66: uint16(21564),
		67: uint16(21550),
		68: uint16(21558),
		69: uint16(21545),
		70: uint16(21533),
		71: uint16(21582),
		72: uint16(21647),
		73: uint16(21621),
		74: uint16(21646),
		75: uint16(21599),
		76: uint16(21617),
		77: uint16(21623),
		78: uint16(21616),
		79: uint16(21650),
		80: uint16(21627),
		81: uint16(21632),
		82: uint16(21622),
		83: uint16(21636),
		84: uint16(21648),
		85: uint16(21638),
		86: uint16(21703),
		87: uint16(21666),
		88: uint16(21688),
		89: uint16(21669),
		90: uint16(21676),
		91: uint16(21700),
		92: uint16(21704),
		93: uint16(21672),
	},
	50: {
		0:  uint16(21675),
		1:  uint16(21698),
		2:  uint16(21668),
		3:  uint16(21694),
		4:  uint16(21692),
		5:  uint16(21720),
		6:  uint16(21733),
		7:  uint16(21734),
		8:  uint16(21775),
		9:  uint16(21780),
		10: uint16(21757),
		11: uint16(21742),
		12: uint16(21741),
		13: uint16(21754),
		14: uint16(21730),
		15: uint16(21817),
		16: uint16(21824),
		17: uint16(21859),
		18: uint16(21836),
		19: uint16(21806),
		20: uint16(21852),
		21: uint16(21829),
		22: uint16(21846),
		23: uint16(21847),
		24: uint16(21816),
		25: uint16(21811),
		26: uint16(21853),
		27: uint16(21913),
		28: uint16(21888),
		29: uint16(21679),
		30: uint16(21898),
		31: uint16(21919),
		32: uint16(21883),
		33: uint16(21886),
		34: uint16(21912),
		35: uint16(21918),
		36: uint16(21934),
		37: uint16(21884),
		38: uint16(21891),
		39: uint16(21929),
		40: uint16(21895),
		41: uint16(21928),
		42: uint16(21978),
		43: uint16(21957),
		44: uint16(21983),
		45: uint16(21956),
		46: uint16(21980),
		47: uint16(21988),
		48: uint16(21972),
		49: uint16(22036),
		50: uint16(22007),
		51: uint16(22038),
		52: uint16(22014),
		53: uint16(22013),
		54: uint16(22043),
		55: uint16(22009),
		56: uint16(22094),
		57: uint16(22096),
		58: uint16(29151),
		59: uint16(22068),
		60: uint16(22070),
		61: uint16(22066),
		62: uint16(22072),
		63: uint16(22123),
		64: uint16(22116),
		65: uint16(22063),
		66: uint16(22124),
		67: uint16(22122),
		68: uint16(22150),
		69: uint16(22144),
		70: uint16(22154),
		71: uint16(22176),
		72: uint16(22164),
		73: uint16(22159),
		74: uint16(22181),
		75: uint16(22190),
		76: uint16(22198),
		77: uint16(22196),
		78: uint16(22210),
		79: uint16(22204),
		80: uint16(22209),
		81: uint16(22211),
		82: uint16(22208),
		83: uint16(22216),
		84: uint16(22222),
		85: uint16(22225),
		86: uint16(22227),
		87: uint16(22231),
		88: uint16(22254),
		89: uint16(22265),
		90: uint16(22272),
		91: uint16(22271),
		92: uint16(22276),
		93: uint16(22281),
	},
	51: {
		0:  uint16(22280),
		1:  uint16(22283),
		2:  uint16(22285),
		3:  uint16(22291),
		4:  uint16(22296),
		5:  uint16(22294),
		6:  uint16(21959),
		7:  uint16(22300),
		8:  uint16(22310),
		9:  uint16(22327),
		10: uint16(22328),
		11: uint16(22350),
		12: uint16(22331),
		13: uint16(22336),
		14: uint16(22351),
		15: uint16(22377),
		16: uint16(22464),
		17: uint16(22408),
		18: uint16(22369),
		19: uint16(22399),
		20: uint16(22409),
		21: uint16(22419),
		22: uint16(22432),
		23: uint16(22451),
		24: uint16(22436),
		25: uint16(22442),
		26: uint16(22448),
		27: uint16(22467),
		28: uint16(22470),
		29: uint16(22484),
		30: uint16(22482),
		31: uint16(22483),
		32: uint16(22538),
		33: uint16(22486),
		34: uint16(22499),
		35: uint16(22539),
		36: uint16(22553),
		37: uint16(22557),
		38: uint16(22642),
		39: uint16(22561),
		40: uint16(22626),
		41: uint16(22603),
		42: uint16(22640),
		43: uint16(27584),
		44: uint16(22610),
		45: uint16(22589),
		46: uint16(22649),
		47: uint16(22661),
		48: uint16(22713),
		49: uint16(22687),
		50: uint16(22699),
		51: uint16(22714),
		52: uint16(22750),
		53: uint16(22715),
		54: uint16(22712),
		55: uint16(22702),
		56: uint16(22725),
		57: uint16(22739),
		58: uint16(22737),
		59: uint16(22743),
		60: uint16(22745),
		61: uint16(22744),
		62: uint16(22757),
		63: uint16(22748),
		64: uint16(22756),
		65: uint16(22751),
		66: uint16(22767),
		67: uint16(22778),
		68: uint16(22777),
		69: uint16(22779),
		70: uint16(22780),
		71: uint16(22781),
		72: uint16(22786),
		73: uint16(22794),
		74: uint16(22800),
		75: uint16(22811),
		76: uint16(26790),
		77: uint16(22821),
		78: uint16(22828),
		79: uint16(22829),
		80: uint16(22834),
		81: uint16(22840),
		82: uint16(22846),
		83: uint16(31442),
		84: uint16(22869),
		85: uint16(22864),
		86: uint16(22862),
		87: uint16(22874),
		88: uint16(22872),
		89: uint16(22882),
		90: uint16(22880),
		91: uint16(22887),
		92: uint16(22892),
		93: uint16(22889),
	},
	52: {
		0:  uint16(22904),
		1:  uint16(22913),
		2:  uint16(22941),
		3:  uint16(20318),
		4:  uint16(20395),
		5:  uint16(22947),
		6:  uint16(22962),
		7:  uint16(22982),
		8:  uint16(23016),
		9:  uint16(23004),
		10: uint16(22925),
		11: uint16(23001),
		12: uint16(23002),
		13: uint16(23077),
		14: uint16(23071),
		15: uint16(23057),
		16: uint16(23068),
		17: uint16(23049),
		18: uint16(23066),
		19: uint16(23104),
		20: uint16(23148),
		21: uint16(23113),
		22: uint16(23093),
		23: uint16(23094),
		24: uint16(23138),
		25: uint16(23146),
		26: uint16(23194),
		27: uint16(23228),
		28: uint16(23230),
		29: uint16(23243),
		30: uint16(23234),
		31: uint16(23229),
		32: uint16(23267),
		33: uint16(23255),
		34: uint16(23270),
		35: uint16(23273),
		36: uint16(23254),
		37: uint16(23290),
		38: uint16(23291),
		39: uint16(23308),
		40: uint16(23307),
		41: uint16(23318),
		42: uint16(23346),
		43: uint16(23248),
		44: uint16(23338),
		45: uint16(23350),
		46: uint16(23358),
		47: uint16(23363),
		48: uint16(23365),
		49: uint16(23360),
		50: uint16(23377),
		51: uint16(23381),
		52: uint16(23386),
		53: uint16(23387),
		54: uint16(23397),
		55: uint16(23401),
		56: uint16(23408),
		57: uint16(23411),
		58: uint16(23413),
		59: uint16(23416),
		60: uint16(25992),
		61: uint16(23418),
		62: uint16(23424),
		63: uint16(23427),
		64: uint16(23462),
		65: uint16(23480),
		66: uint16(23491),
		67: uint16(23495),
		68: uint16(23497),
		69: uint16(23508),
		70: uint16(23504),
		71: uint16(23524),
		72: uint16(23526),
		73: uint16(23522),
		74: uint16(23518),
		75: uint16(23525),
		76: uint16(23531),
		77: uint16(23536),
		78: uint16(23542),
		79: uint16(23539),
		80: uint16(23557),
		81: uint16(23559),
		82: uint16(23560),
		83: uint16(23565),
		84: uint16(23571),
		85: uint16(23584),
		86: uint16(23586),
		87: uint16(23592),
		88: uint16(23608),
		89: uint16(23609),
		90: uint16(23617),
		91: uint16(23622),
		92: uint16(23630),
		93: uint16(23635),
	},
	53: {
		0:  uint16(23632),
		1:  uint16(23631),
		2:  uint16(23409),
		3:  uint16(23660),
		4:  uint16(23662),
		5:  uint16(20066),
		6:  uint16(23670),
		7:  uint16(23673),
		8:  uint16(23692),
		9:  uint16(23697),
		10: uint16(23700),
		11: uint16(22939),
		12: uint16(23723),
		13: uint16(23739),
		14: uint16(23734),
		15: uint16(23740),
		16: uint16(23735),
		17: uint16(23749),
		18: uint16(23742),
		19: uint16(23751),
		20: uint16(23769),
		21: uint16(23785),
		22: uint16(23805),
		23: uint16(23802),
		24: uint16(23789),
		25: uint16(23948),
		26: uint16(23786),
		27: uint16(23819),
		28: uint16(23829),
		29: uint16(23831),
		30: uint16(23900),
		31: uint16(23839),
		32: uint16(23835),
		33: uint16(23825),
		34: uint16(23828),
		35: uint16(23842),
		36: uint16(23834),
		37: uint16(23833),
		38: uint16(23832),
		39: uint16(23884),
		40: uint16(23890),
		41: uint16(23886),
		42: uint16(23883),
		43: uint16(23916),
		44: uint16(23923),
		45: uint16(23926),
		46: uint16(23943),
		47: uint16(23940),
		48: uint16(23938),
		49: uint16(23970),
		50: uint16(23965),
		51: uint16(23980),
		52: uint16(23982),
		53: uint16(23997),
		54: uint16(23952),
		55: uint16(23991),
		56: uint16(23996),
		57: uint16(24009),
		58: uint16(24013),
		59: uint16(24019),
		60: uint16(24018),
		61: uint16(24022),
		62: uint16(24027),
		63: uint16(24043),
		64: uint16(24050),
		65: uint16(24053),
		66: uint16(24075),
		67: uint16(24090),
		68: uint16(24089),
		69: uint16(24081),
		70: uint16(24091),
		71: uint16(24118),
		72: uint16(24119),
		73: uint16(24132),
		74: uint16(24131),
		75: uint16(24128),
		76: uint16(24142),
		77: uint16(24151),
		78: uint16(24148),
		79: uint16(24159),
		80: uint16(24162),
		81: uint16(24164),
		82: uint16(24135),
		83: uint16(24181),
		84: uint16(24182),
		85: uint16(24186),
		86: uint16(40636),
		87: uint16(24191),
		88: uint16(24224),
		89: uint16(24257),
		90: uint16(24258),
		91: uint16(24264),
		92: uint16(24272),
		93: uint16(24271),
	},
	54: {
		0:  uint16(24278),
		1:  uint16(24291),
		2:  uint16(24285),
		3:  uint16(24282),
		4:  uint16(24283),
		5:  uint16(24290),
		6:  uint16(24289),
		7:  uint16(24296),
		8:  uint16(24297),
		9:  uint16(24300),
		10: uint16(24305),
		11: uint16(24307),
		12: uint16(24304),
		13: uint16(24308),
		14: uint16(24312),
		15: uint16(24318),
		16: uint16(24323),
		17: uint16(24329),
		18: uint16(24413),
		19: uint16(24412),
		20: uint16(24331),
		21: uint16(24337),
		22: uint16(24342),
		23: uint16(24361),
		24: uint16(24365),
		25: uint16(24376),
		26: uint16(24385),
		27: uint16(24392),
		28: uint16(24396),
		29: uint16(24398),
		30: uint16(24367),
		31: uint16(24401),
		32: uint16(24406),
		33: uint16(24407),
		34: uint16(24409),
		35: uint16(24417),
		36: uint16(24429),
		37: uint16(24435),
		38: uint16(24439),
		39: uint16(24451),
		40: uint16(24450),
		41: uint16(24447),
		42: uint16(24458),
		43: uint16(24456),
		44: uint16(24465),
		45: uint16(24455),
		46: uint16(24478),
		47: uint16(24473),
		48: uint16(24472),
		49: uint16(24480),
		50: uint16(24488),
		51: uint16(24493),
		52: uint16(24508),
		53: uint16(24534),
		54: uint16(24571),
		55: uint16(24548),
		56: uint16(24568),
		57: uint16(24561),
		58: uint16(24541),
		59: uint16(24755),
		60: uint16(24575),
		61: uint16(24609),
		62: uint16(24672),
		63: uint16(24601),
		64: uint16(24592),
		65: uint16(24617),
		66: uint16(24590),
		67: uint16(24625),
		68: uint16(24603),
		69: uint16(24597),
		70: uint16(24619),
		71: uint16(24614),
		72: uint16(24591),
		73: uint16(24634),
		74: uint16(24666),
		75: uint16(24641),
		76: uint16(24682),
		77: uint16(24695),
		78: uint16(24671),
		79: uint16(24650),
		80: uint16(24646),
		81: uint16(24653),
		82: uint16(24675),
		83: uint16(24643),
		84: uint16(24676),
		85: uint16(24642),
		86: uint16(24684),
		87: uint16(24683),
		88: uint16(24665),
		89: uint16(24705),
		90: uint16(24717),
		91: uint16(24807),
		92: uint16(24707),
		93: uint16(24730),
	},
	55: {
		0:  uint16(24708),
		1:  uint16(24731),
		2:  uint16(24726),
		3:  uint16(24727),
		4:  uint16(24722),
		5:  uint16(24743),
		6:  uint16(24715),
		7:  uint16(24801),
		8:  uint16(24760),
		9:  uint16(24800),
		10: uint16(24787),
		11: uint16(24756),
		12: uint16(24560),
		13: uint16(24765),
		14: uint16(24774),
		15: uint16(24757),
		16: uint16(24792),
		17: uint16(24909),
		18: uint16(24853),
		19: uint16(24838),
		20: uint16(24822),
		21: uint16(24823),
		22: uint16(24832),
		23: uint16(24820),
		24: uint16(24826),
		25: uint16(24835),
		26: uint16(24865),
		27: uint16(24827),
		28: uint16(24817),
		29: uint16(24845),
		30: uint16(24846),
		31: uint16(24903),
		32: uint16(24894),
		33: uint16(24872),
		34: uint16(24871),
		35: uint16(24906),
		36: uint16(24895),
		37: uint16(24892),
		38: uint16(24876),
		39: uint16(24884),
		40: uint16(24893),
		41: uint16(24898),
		42: uint16(24900),
		43: uint16(24947),
		44: uint16(24951),
		45: uint16(24920),
		46: uint16(24921),
		47: uint16(24922),
		48: uint16(24939),
		49: uint16(24948),
		50: uint16(24943),
		51: uint16(24933),
		52: uint16(24945),
		53: uint16(24927),
		54: uint16(24925),
		55: uint16(24915),
		56: uint16(24949),
		57: uint16(24985),
		58: uint16(24982),
		59: uint16(24967),
		60: uint16(25004),
		61: uint16(24980),
		62: uint16(24986),
		63: uint16(24970),
		64: uint16(24977),
		65: uint16(25003),
		66: uint16(25006),
		67: uint16(25036),
		68: uint16(25034),
		69: uint16(25033),
		70: uint16(25079),
		71: uint16(25032),
		72: uint16(25027),
		73: uint16(25030),
		74: uint16(25018),
		75: uint16(25035),
		76: uint16(32633),
		77: uint16(25037),
		78: uint16(25062),
		79: uint16(25059),
		80: uint16(25078),
		81: uint16(25082),
		82: uint16(25076),
		83: uint16(25087),
		84: uint16(25085),
		85: uint16(25084),
		86: uint16(25086),
		87: uint16(25088),
		88: uint16(25096),
		89: uint16(25097),
		90: uint16(25101),
		91: uint16(25100),
		92: uint16(25108),
		93: uint16(25115),
	},
	56: {
		0:  uint16(25118),
		1:  uint16(25121),
		2:  uint16(25130),
		3:  uint16(25134),
		4:  uint16(25136),
		5:  uint16(25138),
		6:  uint16(25139),
		7:  uint16(25153),
		8:  uint16(25166),
		9:  uint16(25182),
		10: uint16(25187),
		11: uint16(25179),
		12: uint16(25184),
		13: uint16(25192),
		14: uint16(25212),
		15: uint16(25218),
		16: uint16(25225),
		17: uint16(25214),
		18: uint16(25234),
		19: uint16(25235),
		20: uint16(25238),
		21: uint16(25300),
		22: uint16(25219),
		23: uint16(25236),
		24: uint16(25303),
		25: uint16(25297),
		26: uint16(25275),
		27: uint16(25295),
		28: uint16(25343),
		29: uint16(25286),
		30: uint16(25812),
		31: uint16(25288),
		32: uint16(25308),
		33: uint16(25292),
		34: uint16(25290),
		35: uint16(25282),
		36: uint16(25287),
		37: uint16(25243),
		38: uint16(25289),
		39: uint16(25356),
		40: uint16(25326),
		41: uint16(25329),
		42: uint16(25383),
		43: uint16(25346),
		44: uint16(25352),
		45: uint16(25327),
		46: uint16(25333),
		47: uint16(25424),
		48: uint16(25406),
		49: uint16(25421),
		50: uint16(25628),
		51: uint16(25423),
		52: uint16(25494),
		53: uint16(25486),
		54: uint16(25472),
		55: uint16(25515),
		56: uint16(25462),
		57: uint16(25507),
		58: uint16(25487),
		59: uint16(25481),
		60: uint16(25503),
		61: uint16(25525),
		62: uint16(25451),
		63: uint16(25449),
		64: uint16(25534),
		65: uint16(25577),
		66: uint16(25536),
		67: uint16(25542),
		68: uint16(25571),
		69: uint16(25545),
		70: uint16(25554),
		71: uint16(25590),
		72: uint16(25540),
		73: uint16(25622),
		74: uint16(25652),
		75: uint16(25606),
		76: uint16(25619),
		77: uint16(25638),
		78: uint16(25654),
		79: uint16(25885),
		80: uint16(25623),
		81: uint16(25640),
		82: uint16(25615),
		83: uint16(25703),
		84: uint16(25711),
		85: uint16(25718),
		86: uint16(25678),
		87: uint16(25898),
		88: uint16(25749),
		89: uint16(25747),
		90: uint16(25765),
		91: uint16(25769),
		92: uint16(25736),
		93: uint16(25788),
	},
	57: {
		0:  uint16(25818),
		1:  uint16(25810),
		2:  uint16(25797),
		3:  uint16(25799),
		4:  uint16(25787),
		5:  uint16(25816),
		6:  uint16(25794),
		7:  uint16(25841),
		8:  uint16(25831),
		9:  uint16(33289),
		10: uint16(25824),
		11: uint16(25825),
		12: uint16(25260),
		13: uint16(25827),
		14: uint16(25839),
		15: uint16(25900),
		16: uint16(25846),
		17: uint16(25844),
		18: uint16(25842),
		19: uint16(25850),
		20: uint16(25856),
		21: uint16(25853),
		22: uint16(25880),
		23: uint16(25884),
		24: uint16(25861),
		25: uint16(25892),
		26: uint16(25891),
		27: uint16(25899),
		28: uint16(25908),
		29: uint16(25909),
		30: uint16(25911),
		31: uint16(25910),
		32: uint16(25912),
		33: uint16(30027),
		34: uint16(25928),
		35: uint16(25942),
		36: uint16(25941),
		37: uint16(25933),
		38: uint16(25944),
		39: uint16(25950),
		40: uint16(25949),
		41: uint16(25970),
		42: uint16(25976),
		43: uint16(25986),
		44: uint16(25987),
		45: uint16(35722),
		46: uint16(26011),
		47: uint16(26015),
		48: uint16(26027),
		49: uint16(26039),
		50: uint16(26051),
		51: uint16(26054),
		52: uint16(26049),
		53: uint16(26052),
		54: uint16(26060),
		55: uint16(26066),
		56: uint16(26075),
		57: uint16(26073),
		58: uint16(26080),
		59: uint16(26081),
		60: uint16(26097),
		61: uint16(26482),
		62: uint16(26122),
		63: uint16(26115),
		64: uint16(26107),
		65: uint16(26483),
		66: uint16(26165),
		67: uint16(26166),
		68: uint16(26164),
		69: uint16(26140),
		70: uint16(26191),
		71: uint16(26180),
		72: uint16(26185),
		73: uint16(26177),
		74: uint16(26206),
		75: uint16(26205),
		76: uint16(26212),
		77: uint16(26215),
		78: uint16(26216),
		79: uint16(26207),
		80: uint16(26210),
		81: uint16(26224),
		82: uint16(26243),
		83: uint16(26248),
		84: uint16(26254),
		85: uint16(26249),
		86: uint16(26244),
		87: uint16(26264),
		88: uint16(26269),
		89: uint16(26305),
		90: uint16(26297),
		91: uint16(26313),
		92: uint16(26302),
		93: uint16(26300),
	},
	58: {
		0:  uint16(26308),
		1:  uint16(26296),
		2:  uint16(26326),
		3:  uint16(26330),
		4:  uint16(26336),
		5:  uint16(26175),
		6:  uint16(26342),
		7:  uint16(26345),
		8:  uint16(26352),
		9:  uint16(26357),
		10: uint16(26359),
		11: uint16(26383),
		12: uint16(26390),
		13: uint16(26398),
		14: uint16(26406),
		15: uint16(26407),
		16: uint16(38712),
		17: uint16(26414),
		18: uint16(26431),
		19: uint16(26422),
		20: uint16(26433),
		21: uint16(26424),
		22: uint16(26423),
		23: uint16(26438),
		24: uint16(26462),
		25: uint16(26464),
		26: uint16(26457),
		27: uint16(26467),
		28: uint16(26468),
		29: uint16(26505),
		30: uint16(26480),
		31: uint16(26537),
		32: uint16(26492),
		33: uint16(26474),
		34: uint16(26508),
		35: uint16(26507),
		36: uint16(26534),
		37: uint16(26529),
		38: uint16(26501),
		39: uint16(26551),
		40: uint16(26607),
		41: uint16(26548),
		42: uint16(26604),
		43: uint16(26547),
		44: uint16(26601),
		45: uint16(26552),
		46: uint16(26596),
		47: uint16(26590),
		48: uint16(26589),
		49: uint16(26594),
		50: uint16(26606),
		51: uint16(26553),
		52: uint16(26574),
		53: uint16(26566),
		54: uint16(26599),
		55: uint16(27292),
		56: uint16(26654),
		57: uint16(26694),
		58: uint16(26665),
		59: uint16(26688),
		60: uint16(26701),
		61: uint16(26674),
		62: uint16(26702),
		63: uint16(26803),
		64: uint16(26667),
		65: uint16(26713),
		66: uint16(26723),
		67: uint16(26743),
		68: uint16(26751),
		69: uint16(26783),
		70: uint16(26767),
		71: uint16(26797),
		72: uint16(26772),
		73: uint16(26781),
		74: uint16(26779),
		75: uint16(26755),
		76: uint16(27310),
		77: uint16(26809),
		78: uint16(26740),
		79: uint16(26805),
		80: uint16(26784),
		81: uint16(26810),
		82: uint16(26895),
		83: uint16(26765),
		84: uint16(26750),
		85: uint16(26881),
		86: uint16(26826),
		87: uint16(26888),
		88: uint16(26840),
		89: uint16(26914),
		90: uint16(26918),
		91: uint16(26849),
		92: uint16(26892),
		93: uint16(26829),
	},
	59: {
		0:  uint16(26836),
		1:  uint16(26855),
		2:  uint16(26837),
		3:  uint16(26934),
		4:  uint16(26898),
		5:  uint16(26884),
		6:  uint16(26839),
		7:  uint16(26851),
		8:  uint16(26917),
		9:  uint16(26873),
		10: uint16(26848),
		11: uint16(26863),
		12: uint16(26920),
		13: uint16(26922),
		14: uint16(26906),
		15: uint16(26915),
		16: uint16(26913),
		17: uint16(26822),
		18: uint16(27001),
		19: uint16(26999),
		20: uint16(26972),
		21: uint16(27000),
		22: uint16(26987),
		23: uint16(26964),
		24: uint16(27006),
		25: uint16(26990),
		26: uint16(26937),
		27: uint16(26996),
		28: uint16(26941),
		29: uint16(26969),
		30: uint16(26928),
		31: uint16(26977),
		32: uint16(26974),
		33: uint16(26973),
		34: uint16(27009),
		35: uint16(26986),
		36: uint16(27058),
		37: uint16(27054),
		38: uint16(27088),
		39: uint16(27071),
		40: uint16(27073),
		41: uint16(27091),
		42: uint16(27070),
		43: uint16(27086),
		44: uint16(23528),
		45: uint16(27082),
		46: uint16(27101),
		47: uint16(27067),
		48: uint16(27075),
		49: uint16(27047),
		50: uint16(27182),
		51: uint16(27025),
		52: uint16(27040),
		53: uint16(27036),
		54: uint16(27029),
		55: uint16(27060),
		56: uint16(27102),
		57: uint16(27112),
		58: uint16(27138),
		59: uint16(27163),
		60: uint16(27135),
		61: uint16(27402),
		62: uint16(27129),
		63: uint16(27122),
		64: uint16(27111),
		65: uint16(27141),
		66: uint16(27057),
		67: uint16(27166),
		68: uint16(27117),
		69: uint16(27156),
		70: uint16(27115),
		71: uint16(27146),
		72: uint16(27154),
		73: uint16(27329),
		74: uint16(27171),
		75: uint16(27155),
		76: uint16(27204),
		77: uint16(27148),
		78: uint16(27250),
		79: uint16(27190),
		80: uint16(27256),
		81: uint16(27207),
		82: uint16(27234),
		83: uint16(27225),
		84: uint16(27238),
		85: uint16(27208),
		86: uint16(27192),
		87: uint16(27170),
		88: uint16(27280),
		89: uint16(27277),
		90: uint16(27296),
		91: uint16(27268),
		92: uint16(27298),
		93: uint16(27299),
	},
	60: {
		0:  uint16(27287),
		1:  uint16(34327),
		2:  uint16(27323),
		3:  uint16(27331),
		4:  uint16(27330),
		5:  uint16(27320),
		6:  uint16(27315),
		7:  uint16(27308),
		8:  uint16(27358),
		9:  uint16(27345),
		10: uint16(27359),
		11: uint16(27306),
		12: uint16(27354),
		13: uint16(27370),
		14: uint16(27387),
		15: uint16(27397),
		16: uint16(34326),
		17: uint16(27386),
		18: uint16(27410),
		19: uint16(27414),
		20: uint16(39729),
		21: uint16(27423),
		22: uint16(27448),
		23: uint16(27447),
		24: uint16(30428),
		25: uint16(27449),
		26: uint16(39150),
		27: uint16(27463),
		28: uint16(27459),
		29: uint16(27465),
		30: uint16(27472),
		31: uint16(27481),
		32: uint16(27476),
		33: uint16(27483),
		34: uint16(27487),
		35: uint16(27489),
		36: uint16(27512),
		37: uint16(27513),
		38: uint16(27519),
		39: uint16(27520),
		40: uint16(27524),
		41: uint16(27523),
		42: uint16(27533),
		43: uint16(27544),
		44: uint16(27541),
		45: uint16(27550),
		46: uint16(27556),
		47: uint16(27562),
		48: uint16(27563),
		49: uint16(27567),
		50: uint16(27570),
		51: uint16(27569),
		52: uint16(27571),
		53: uint16(27575),
		54: uint16(27580),
		55: uint16(27590),
		56: uint16(27595),
		57: uint16(27603),
		58: uint16(27615),
		59: uint16(27628),
		60: uint16(27627),
		61: uint16(27635),
		62: uint16(27631),
		63: uint16(40638),
		64: uint16(27656),
		65: uint16(27667),
		66: uint16(27668),
		67: uint16(27675),
		68: uint16(27684),
		69: uint16(27683),
		70: uint16(27742),
		71: uint16(27733),
		72: uint16(27746),
		73: uint16(27754),
		74: uint16(27778),
		75: uint16(27789),
		76: uint16(27802),
		77: uint16(27777),
		78: uint16(27803),
		79: uint16(27774),
		80: uint16(27752),
		81: uint16(27763),
		82: uint16(27794),
		83: uint16(27792),
		84: uint16(27844),
		85: uint16(27889),
		86: uint16(27859),
		87: uint16(27837),
		88: uint16(27863),
		89: uint16(27845),
		90: uint16(27869),
		91: uint16(27822),
		92: uint16(27825),
		93: uint16(27838),
	},
	61: {
		0:  uint16(27834),
		1:  uint16(27867),
		2:  uint16(27887),
		3:  uint16(27865),
		4:  uint16(27882),
		5:  uint16(27935),
		6:  uint16(34893),
		7:  uint16(27958),
		8:  uint16(27947),
		9:  uint16(27965),
		10: uint16(27960),
		11: uint16(27929),
		12: uint16(27957),
		13: uint16(27955),
		14: uint16(27922),
		15: uint16(27916),
		16: uint16(28003),
		17: uint16(28051),
		18: uint16(28004),
		19: uint16(27994),
		20: uint16(28025),
		21: uint16(27993),
		22: uint16(28046),
		23: uint16(28053),
		24: uint16(28644),
		25: uint16(28037),
		26: uint16(28153),
		27: uint16(28181),
		28: uint16(28170),
		29: uint16(28085),
		30: uint16(28103),
		31: uint16(28134),
		32: uint16(28088),
		33: uint16(28102),
		34: uint16(28140),
		35: uint16(28126),
		36: uint16(28108),
		37: uint16(28136),
		38: uint16(28114),
		39: uint16(28101),
		40: uint16(28154),
		41: uint16(28121),
		42: uint16(28132),
		43: uint16(28117),
		44: uint16(28138),
		45: uint16(28142),
		46: uint16(28205),
		47: uint16(28270),
		48: uint16(28206),
		49: uint16(28185),
		50: uint16(28274),
		51: uint16(28255),
		52: uint16(28222),
		53: uint16(28195),
		54: uint16(28267),
		55: uint16(28203),
		56: uint16(28278),
		57: uint16(28237),
		58: uint16(28191),
		59: uint16(28227),
		60: uint16(28218),
		61: uint16(28238),
		62: uint16(28196),
		63: uint16(28415),
		64: uint16(28189),
		65: uint16(28216),
		66: uint16(28290),
		67: uint16(28330),
		68: uint16(28312),
		69: uint16(28361),
		70: uint16(28343),
		71: uint16(28371),
		72: uint16(28349),
		73: uint16(28335),
		74: uint16(28356),
		75: uint16(28338),
		76: uint16(28372),
		77: uint16(28373),
		78: uint16(28303),
		79: uint16(28325),
		80: uint16(28354),
		81: uint16(28319),
		82: uint16(28481),
		83: uint16(28433),
		84: uint16(28748),
		85: uint16(28396),
		86: uint16(28408),
		87: uint16(28414),
		88: uint16(28479),
		89: uint16(28402),
		90: uint16(28465),
		91: uint16(28399),
		92: uint16(28466),
		93: uint16(28364),
	},
	62: {
		0:  uint16(28478),
		1:  uint16(28435),
		2:  uint16(28407),
		3:  uint16(28550),
		4:  uint16(28538),
		5:  uint16(28536),
		6:  uint16(28545),
		7:  uint16(28544),
		8:  uint16(28527),
		9:  uint16(28507),
		10: uint16(28659),
		11: uint16(28525),
		12: uint16(28546),
		13: uint16(28540),
		14: uint16(28504),
		15: uint16(28558),
		16: uint16(28561),
		17: uint16(28610),
		18: uint16(28518),
		19: uint16(28595),
		20: uint16(28579),
		21: uint16(28577),
		22: uint16(28580),
		23: uint16(28601),
		24: uint16(28614),
		25: uint16(28586),
		26: uint16(28639),
		27: uint16(28629),
		28: uint16(28652),
		29: uint16(28628),
		30: uint16(28632),
		31: uint16(28657),
		32: uint16(28654),
		33: uint16(28635),
		34: uint16(28681),
		35: uint16(28683),
		36: uint16(28666),
		37: uint16(28689),
		38: uint16(28673),
		39: uint16(28687),
		40: uint16(28670),
		41: uint16(28699),
		42: uint16(28698),
		43: uint16(28532),
		44: uint16(28701),
		45: uint16(28696),
		46: uint16(28703),
		47: uint16(28720),
		48: uint16(28734),
		49: uint16(28722),
		50: uint16(28753),
		51: uint16(28771),
		52: uint16(28825),
		53: uint16(28818),
		54: uint16(28847),
		55: uint16(28913),
		56: uint16(28844),
		57: uint16(28856),
		58: uint16(28851),
		59: uint16(28846),
		60: uint16(28895),
		61: uint16(28875),
		62: uint16(28893),
		63: uint16(28889),
		64: uint16(28937),
		65: uint16(28925),
		66: uint16(28956),
		67: uint16(28953),
		68: uint16(29029),
		69: uint16(29013),
		70: uint16(29064),
		71: uint16(29030),
		72: uint16(29026),
		73: uint16(29004),
		74: uint16(29014),
		75: uint16(29036),
		76: uint16(29071),
		77: uint16(29179),
		78: uint16(29060),
		79: uint16(29077),
		80: uint16(29096),
		81: uint16(29100),
		82: uint16(29143),
		83: uint16(29113),
		84: uint16(29118),
		85: uint16(29138),
		86: uint16(29129),
		87: uint16(29140),
		88: uint16(29134),
		89: uint16(29152),
		90: uint16(29164),
		91: uint16(29159),
		92: uint16(29173),
		93: uint16(29180),
	},
	63: {
		0:  uint16(29177),
		1:  uint16(29183),
		2:  uint16(29197),
		3:  uint16(29200),
		4:  uint16(29211),
		5:  uint16(29224),
		6:  uint16(29229),
		7:  uint16(29228),
		8:  uint16(29232),
		9:  uint16(29234),
		10: uint16(29243),
		11: uint16(29244),
		12: uint16(29247),
		13: uint16(29248),
		14: uint16(29254),
		15: uint16(29259),
		16: uint16(29272),
		17: uint16(29300),
		18: uint16(29310),
		19: uint16(29314),
		20: uint16(29313),
		21: uint16(29319),
		22: uint16(29330),
		23: uint16(29334),
		24: uint16(29346),
		25: uint16(29351),
		26: uint16(29369),
		27: uint16(29362),
		28: uint16(29379),
		29: uint16(29382),
		30: uint16(29380),
		31: uint16(29390),
		32: uint16(29394),
		33: uint16(29410),
		34: uint16(29408),
		35: uint16(29409),
		36: uint16(29433),
		37: uint16(29431),
		38: uint16(20495),
		39: uint16(29463),
		40: uint16(29450),
		41: uint16(29468),
		42: uint16(29462),
		43: uint16(29469),
		44: uint16(29492),
		45: uint16(29487),
		46: uint16(29481),
		47: uint16(29477),
		48: uint16(29502),
		49: uint16(29518),
		50: uint16(29519),
		51: uint16(40664),
		52: uint16(29527),
		53: uint16(29546),
		54: uint16(29544),
		55: uint16(29552),
		56: uint16(29560),
		57: uint16(29557),
		58: uint16(29563),
		59: uint16(29562),
		60: uint16(29640),
		61: uint16(29619),
		62: uint16(29646),
		63: uint16(29627),
		64: uint16(29632),
		65: uint16(29669),
		66: uint16(29678),
		67: uint16(29662),
		68: uint16(29858),
		69: uint16(29701),
		70: uint16(29807),
		71: uint16(29733),
		72: uint16(29688),
		73: uint16(29746),
		74: uint16(29754),
		75: uint16(29781),
		76: uint16(29759),
		77: uint16(29791),
		78: uint16(29785),
		79: uint16(29761),
		80: uint16(29788),
		81: uint16(29801),
		82: uint16(29808),
		83: uint16(29795),
		84: uint16(29802),
		85: uint16(29814),
		86: uint16(29822),
		87: uint16(29835),
		88: uint16(29854),
		89: uint16(29863),
		90: uint16(29898),
		91: uint16(29903),
		92: uint16(29908),
		93: uint16(29681),
	},
	64: {
		0:  uint16(29920),
		1:  uint16(29923),
		2:  uint16(29927),
		3:  uint16(29929),
		4:  uint16(29934),
		5:  uint16(29938),
		6:  uint16(29936),
		7:  uint16(29937),
		8:  uint16(29944),
		9:  uint16(29943),
		10: uint16(29956),
		11: uint16(29955),
		12: uint16(29957),
		13: uint16(29964),
		14: uint16(29966),
		15: uint16(29965),
		16: uint16(29973),
		17: uint16(29971),
		18: uint16(29982),
		19: uint16(29990),
		20: uint16(29996),
		21: uint16(30012),
		22: uint16(30020),
		23: uint16(30029),
		24: uint16(30026),
		25: uint16(30025),
		26: uint16(30043),
		27: uint16(30022),
		28: uint16(30042),
		29: uint16(30057),
		30: uint16(30052),
		31: uint16(30055),
		32: uint16(30059),
		33: uint16(30061),
		34: uint16(30072),
		35: uint16(30070),
		36: uint16(30086),
		37: uint16(30087),
		38: uint16(30068),
		39: uint16(30090),
		40: uint16(30089),
		41: uint16(30082),
		42: uint16(30100),
		43: uint16(30106),
		44: uint16(30109),
		45: uint16(30117),
		46: uint16(30115),
		47: uint16(30146),
		48: uint16(30131),
		49: uint16(30147),
		50: uint16(30133),
		51: uint16(30141),
		52: uint16(30136),
		53: uint16(30140),
		54: uint16(30129),
		55: uint16(30157),
		56: uint16(30154),
		57: uint16(30162),
		58: uint16(30169),
		59: uint16(30179),
		60: uint16(30174),
		61: uint16(30206),
		62: uint16(30207),
		63: uint16(30204),
		64: uint16(30209),
		65: uint16(30192),
		66: uint16(30202),
		67: uint16(30194),
		68: uint16(30195),
		69: uint16(30219),
		70: uint16(30221),
		71: uint16(30217),
		72: uint16(30239),
		73: uint16(30247),
		74: uint16(30240),
		75: uint16(30241),
		76: uint16(30242),
		77: uint16(30244),
		78: uint16(30260),
		79: uint16(30256),
		80: uint16(30267),
		81: uint16(30279),
		82: uint16(30280),
		83: uint16(30278),
		84: uint16(30300),
		85: uint16(30296),
		86: uint16(30305),
		87: uint16(30306),
		88: uint16(30312),
		89: uint16(30313),
		90: uint16(30314),
		91: uint16(30311),
		92: uint16(30316),
		93: uint16(30320),
	},
	65: {
		0:  uint16(30322),
		1:  uint16(30326),
		2:  uint16(30328),
		3:  uint16(30332),
		4:  uint16(30336),
		5:  uint16(30339),
		6:  uint16(30344),
		7:  uint16(30347),
		8:  uint16(30350),
		9:  uint16(30358),
		10: uint16(30355),
		11: uint16(30361),
		12: uint16(30362),
		13: uint16(30384),
		14: uint16(30388),
		15: uint16(30392),
		16: uint16(30393),
		17: uint16(30394),
		18: uint16(30402),
		19: uint16(30413),
		20: uint16(30422),
		21: uint16(30418),
		22: uint16(30430),
		23: uint16(30433),
		24: uint16(30437),
		25: uint16(30439),
		26: uint16(30442),
		27: uint16(34351),
		28: uint16(30459),
		29: uint16(30472),
		30: uint16(30471),
		31: uint16(30468),
		32: uint16(30505),
		33: uint16(30500),
		34: uint16(30494),
		35: uint16(30501),
		36: uint16(30502),
		37: uint16(30491),
		38: uint16(30519),
		39: uint16(30520),
		40: uint16(30535),
		41: uint16(30554),
		42: uint16(30568),
		43: uint16(30571),
		44: uint16(30555),
		45: uint16(30565),
		46: uint16(30591),
		47: uint16(30590),
		48: uint16(30585),
		49: uint16(30606),
		50: uint16(30603),
		51: uint16(30609),
		52: uint16(30624),
		53: uint16(30622),
		54: uint16(30640),
		55: uint16(30646),
		56: uint16(30649),
		57: uint16(30655),
		58: uint16(30652),
		59: uint16(30653),
		60: uint16(30651),
		61: uint16(30663),
		62: uint16(30669),
		63: uint16(30679),
		64: uint16(30682),
		65: uint16(30684),
		66: uint16(30691),
		67: uint16(30702),
		68: uint16(30716),
		69: uint16(30732),
		70: uint16(30738),
		71: uint16(31014),
		72: uint16(30752),
		73: uint16(31018),
		74: uint16(30789),
		75: uint16(30862),
		76: uint16(30836),
		77: uint16(30854),
		78: uint16(30844),
		79: uint16(30874),
		80: uint16(30860),
		81: uint16(30883),
		82: uint16(30901),
		83: uint16(30890),
		84: uint16(30895),
		85: uint16(30929),
		86: uint16(30918),
		87: uint16(30923),
		88: uint16(30932),
		89: uint16(30910),
		90: uint16(30908),
		91: uint16(30917),
		92: uint16(30922),
		93: uint16(30956),
	},
	66: {
		0:  uint16(30951),
		1:  uint16(30938),
		2:  uint16(30973),
		3:  uint16(30964),
		4:  uint16(30983),
		5:  uint16(30994),
		6:  uint16(30993),
		7:  uint16(31001),
		8:  uint16(31020),
		9:  uint16(31019),
		10: uint16(31040),
		11: uint16(31072),
		12: uint16(31063),
		13: uint16(31071),
		14: uint16(31066),
		15: uint16(31061),
		16: uint16(31059),
		17: uint16(31098),
		18: uint16(31103),
		19: uint16(31114),
		20: uint16(31133),
		21: uint16(31143),
		22: uint16(40779),
		23: uint16(31146),
		24: uint16(31150),
		25: uint16(31155),
		26: uint16(31161),
		27: uint16(31162),
		28: uint16(31177),
		29: uint16(31189),
		30: uint16(31207),
		31: uint16(31212),
		32: uint16(31201),
		33: uint16(31203),
		34: uint16(31240),
		35: uint16(31245),
		36: uint16(31256),
		37: uint16(31257),
		38: uint16(31264),
		39: uint16(31263),
		40: uint16(31104),
		41: uint16(31281),
		42: uint16(31291),
		43: uint16(31294),
		44: uint16(31287),
		45: uint16(31299),
		46: uint16(31319),
		47: uint16(31305),
		48: uint16(31329),
		49: uint16(31330),
		50: uint16(31337),
		51: uint16(40861),
		52: uint16(31344),
		53: uint16(31353),
		54: uint16(31357),
		55: uint16(31368),
		56: uint16(31383),
		57: uint16(31381),
		58: uint16(31384),
		59: uint16(31382),
		60: uint16(31401),
		61: uint16(31432),
		62: uint16(31408),
		63: uint16(31414),
		64: uint16(31429),
		65: uint16(31428),
		66: uint16(31423),
		67: uint16(36995),
		68: uint16(31431),
		69: uint16(31434),
		70: uint16(31437),
		71: uint16(31439),
		72: uint16(31445),
		73: uint16(31443),
		74: uint16(31449),
		75: uint16(31450),
		76: uint16(31453),
		77: uint16(31457),
		78: uint16(31458),
		79: uint16(31462),
		80: uint16(31469),
		81: uint16(31472),
		82: uint16(31490),
		83: uint16(31503),
		84: uint16(31498),
		85: uint16(31494),
		86: uint16(31539),
		87: uint16(31512),
		88: uint16(31513),
		89: uint16(31518),
		90: uint16(31541),
		91: uint16(31528),
		92: uint16(31542),
		93: uint16(31568),
	},
	67: {
		0:  uint16(31610),
		1:  uint16(31492),
		2:  uint16(31565),
		3:  uint16(31499),
		4:  uint16(31564),
		5:  uint16(31557),
		6:  uint16(31605),
		7:  uint16(31589),
		8:  uint16(31604),
		9:  uint16(31591),
		10: uint16(31600),
		11: uint16(31601),
		12: uint16(31596),
		13: uint16(31598),
		14: uint16(31645),
		15: uint16(31640),
		16: uint16(31647),
		17: uint16(31629),
		18: uint16(31644),
		19: uint16(31642),
		20: uint16(31627),
		21: uint16(31634),
		22: uint16(31631),
		23: uint16(31581),
		24: uint16(31641),
		25: uint16(31691),
		26: uint16(31681),
		27: uint16(31692),
		28: uint16(31695),
		29: uint16(31668),
		30: uint16(31686),
		31: uint16(31709),
		32: uint16(31721),
		33: uint16(31761),
		34: uint16(31764),
		35: uint16(31718),
		36: uint16(31717),
		37: uint16(31840),
		38: uint16(31744),
		39: uint16(31751),
		40: uint16(31763),
		41: uint16(31731),
		42: uint16(31735),
		43: uint16(31767),
		44: uint16(31757),
		45: uint16(31734),
		46: uint16(31779),
		47: uint16(31783),
		48: uint16(31786),
		49: uint16(31775),
		50: uint16(31799),
		51: uint16(31787),
		52: uint16(31805),
		53: uint16(31820),
		54: uint16(31811),
		55: uint16(31828),
		56: uint16(31823),
		57: uint16(31808),
		58: uint16(31824),
		59: uint16(31832),
		60: uint16(31839),
		61: uint16(31844),
		62: uint16(31830),
		63: uint16(31845),
		64: uint16(31852),
		65: uint16(31861),
		66: uint16(31875),
		67: uint16(31888),
		68: uint16(31908),
		69: uint16(31917),
		70: uint16(31906),
		71: uint16(31915),
		72: uint16(31905),
		73: uint16(31912),
		74: uint16(31923),
		75: uint16(31922),
		76: uint16(31921),
		77: uint16(31918),
		78: uint16(31929),
		79: uint16(31933),
		80: uint16(31936),
		81: uint16(31941),
		82: uint16(31938),
		83: uint16(31960),
		84: uint16(31954),
		85: uint16(31964),
		86: uint16(31970),
		87: uint16(39739),
		88: uint16(31983),
		89: uint16(31986),
		90: uint16(31988),
		91: uint16(31990),
		92: uint16(31994),
		93: uint16(32006),
	},
	68: {
		0:  uint16(32002),
		1:  uint16(32028),
		2:  uint16(32021),
		3:  uint16(32010),
		4:  uint16(32069),
		5:  uint16(32075),
		6:  uint16(32046),
		7:  uint16(32050),
		8:  uint16(32063),
		9:  uint16(32053),
		10: uint16(32070),
		11: uint16(32115),
		12: uint16(32086),
		13: uint16(32078),
		14: uint16(32114),
		15: uint16(32104),
		16: uint16(32110),
		17: uint16(32079),
		18: uint16(32099),
		19: uint16(32147),
		20: uint16(32137),
		21: uint16(32091),
		22: uint16(32143),
		23: uint16(32125),
		24: uint16(32155),
		25: uint16(32186),
		26: uint16(32174),
		27: uint16(32163),
		28: uint16(32181),
		29: uint16(32199),
		30: uint16(32189),
		31: uint16(32171),
		32: uint16(32317),
		33: uint16(32162),
		34: uint16(32175),
		35: uint16(32220),
		36: uint16(32184),
		37: uint16(32159),
		38: uint16(32176),
		39: uint16(32216),
		40: uint16(32221),
		41: uint16(32228),
		42: uint16(32222),
		43: uint16(32251),
		44: uint16(32242),
		45: uint16(32225),
		46: uint16(32261),
		47: uint16(32266),
		48: uint16(32291),
		49: uint16(32289),
		50: uint16(32274),
		51: uint16(32305),
		52: uint16(32287),
		53: uint16(32265),
		54: uint16(32267),
		55: uint16(32290),
		56: uint16(32326),
		57: uint16(32358),
		58: uint16(32315),
		59: uint16(32309),
		60: uint16(32313),
		61: uint16(32323),
		62: uint16(32311),
		63: uint16(32306),
		64: uint16(32314),
		65: uint16(32359),
		66: uint16(32349),
		67: uint16(32342),
		68: uint16(32350),
		69: uint16(32345),
		70: uint16(32346),
		71: uint16(32377),
		72: uint16(32362),
		73: uint16(32361),
		74: uint16(32380),
		75: uint16(32379),
		76: uint16(32387),
		77: uint16(32213),
		78: uint16(32381),
		79: uint16(36782),
		80: uint16(32383),
		81: uint16(32392),
		82: uint16(32393),
		83: uint16(32396),
		84: uint16(32402),
		85: uint16(32400),
		86: uint16(32403),
		87: uint16(32404),
		88: uint16(32406),
		89: uint16(32398),
		90: uint16(32411),
		91: uint16(32412),
		92: uint16(32568),
		93: uint16(32570),
	},
	69: {
		0:  uint16(32581),
		1:  uint16(32588),
		2:  uint16(32589),
		3:  uint16(32590),
		4:  uint16(32592),
		5:  uint16(32593),
		6:  uint16(32597),
		7:  uint16(32596),
		8:  uint16(32600),
		9:  uint16(32607),
		10: uint16(32608),
		11: uint16(32616),
		12: uint16(32617),
		13: uint16(32615),
		14: uint16(32632),
		15: uint16(32642),
		16: uint16(32646),
		17: uint16(32643),
		18: uint16(32648),
		19: uint16(32647),
		20: uint16(32652),
		21: uint16(32660),
		22: uint16(32670),
		23: uint16(32669),
		24: uint16(32666),
		25: uint16(32675),
		26: uint16(32687),
		27: uint16(32690),
		28: uint16(32697),
		29: uint16(32686),
		30: uint16(32694),
		31: uint16(32696),
		32: uint16(35697),
		33: uint16(32709),
		34: uint16(32710),
		35: uint16(32714),
		36: uint16(32725),
		37: uint16(32724),
		38: uint16(32737),
		39: uint16(32742),
		40: uint16(32745),
		41: uint16(32755),
		42: uint16(32761),
		43: uint16(39132),
		44: uint16(32774),
		45: uint16(32772),
		46: uint16(32779),
		47: uint16(32786),
		48: uint16(32792),
		49: uint16(32793),
		50: uint16(32796),
		51: uint16(32801),
		52: uint16(32808),
		53: uint16(32831),
		54: uint16(32827),
		55: uint16(32842),
		56: uint16(32838),
		57: uint16(32850),
		58: uint16(32856),
		59: uint16(32858),
		60: uint16(32863),
		61: uint16(32866),
		62: uint16(32872),
		63: uint16(32883),
		64: uint16(32882),
		65: uint16(32880),
		66: uint16(32886),
		67: uint16(32889),
		68: uint16(32893),
		69: uint16(32895),
		70: uint16(32900),
		71: uint16(32902),
		72: uint16(32901),
		73: uint16(32923),
		74: uint16(32915),
		75: uint16(32922),
		76: uint16(32941),
		77: uint16(20880),
		78: uint16(32940),
		79: uint16(32987),
		80: uint16(32997),
		81: uint16(32985),
		82: uint16(32989),
		83: uint16(32964),
		84: uint16(32986),
		85: uint16(32982),
		86: uint16(33033),
		87: uint16(33007),
		88: uint16(33009),
		89: uint16(33051),
		90: uint16(33065),
		91: uint16(33059),
		92: uint16(33071),
		93: uint16(33099),
	},
	70: {
		0:  uint16(38539),
		1:  uint16(33094),
		2:  uint16(33086),
		3:  uint16(33107),
		4:  uint16(33105),
		5:  uint16(33020),
		6:  uint16(33137),
		7:  uint16(33134),
		8:  uint16(33125),
		9:  uint16(33126),
		10: uint16(33140),
		11: uint16(33155),
		12: uint16(33160),
		13: uint16(33162),
		14: uint16(33152),
		15: uint16(33154),
		16: uint16(33184),
		17: uint16(33173),
		18: uint16(33188),
		19: uint16(33187),
		20: uint16(33119),
		21: uint16(33171),
		22: uint16(33193),
		23: uint16(33200),
		24: uint16(33205),
		25: uint16(33214),
		26: uint16(33208),
		27: uint16(33213),
		28: uint16(33216),
		29: uint16(33218),
		30: uint16(33210),
		31: uint16(33225),
		32: uint16(33229),
		33: uint16(33233),
		34: uint16(33241),
		35: uint16(33240),
		36: uint16(33224),
		37: uint16(33242),
		38: uint16(33247),
		39: uint16(33248),
		40: uint16(33255),
		41: uint16(33274),
		42: uint16(33275),
		43: uint16(33278),
		44: uint16(33281),
		45: uint16(33282),
		46: uint16(33285),
		47: uint16(33287),
		48: uint16(33290),
		49: uint16(33293),
		50: uint16(33296),
		51: uint16(33302),
		52: uint16(33321),
		53: uint16(33323),
		54: uint16(33336),
		55: uint16(33331),
		56: uint16(33344),
		57: uint16(33369),
		58: uint16(33368),
		59: uint16(33373),
		60: uint16(33370),
		61: uint16(33375),
		62: uint16(33380),
		63: uint16(33378),
		64: uint16(33384),
		65: uint16(33386),
		66: uint16(33387),
		67: uint16(33326),
		68: uint16(33393),
		69: uint16(33399),
		70: uint16(33400),
		71: uint16(33406),
		72: uint16(33421),
		73: uint16(33426),
		74: uint16(33451),
		75: uint16(33439),
		76: uint16(33467),
		77: uint16(33452),
		78: uint16(33505),
		79: uint16(33507),
		80: uint16(33503),
		81: uint16(33490),
		82: uint16(33524),
		83: uint16(33523),
		84: uint16(33530),
		85: uint16(33683),
		86: uint16(33539),
		87: uint16(33531),
		88: uint16(33529),
		89: uint16(33502),
		90: uint16(33542),
		91: uint16(33500),
		92: uint16(33545),
		93: uint16(33497),
	},
	71: {
		0:  uint16(33589),
		1:  uint16(33588),
		2:  uint16(33558),
		3:  uint16(33586),
		4:  uint16(33585),
		5:  uint16(33600),
		6:  uint16(33593),
		7:  uint16(33616),
		8:  uint16(33605),
		9:  uint16(33583),
		10: uint16(33579),
		11: uint16(33559),
		12: uint16(33560),
		13: uint16(33669),
		14: uint16(33690),
		15: uint16(33706),
		16: uint16(33695),
		17: uint16(33698),
		18: uint16(33686),
		19: uint16(33571),
		20: uint16(33678),
		21: uint16(33671),
		22: uint16(33674),
		23: uint16(33660),
		24: uint16(33717),
		25: uint16(33651),
		26: uint16(33653),
		27: uint16(33696),
		28: uint16(33673),
		29: uint16(33704),
		30: uint16(33780),
		31: uint16(33811),
		32: uint16(33771),
		33: uint16(33742),
		34: uint16(33789),
		35: uint16(33795),
		36: uint16(33752),
		37: uint16(33803),
		38: uint16(33729),
		39: uint16(33783),
		40: uint16(33799),
		41: uint16(33760),
		42: uint16(33778),
		43: uint16(33805),
		44: uint16(33826),
		45: uint16(33824),
		46: uint16(33725),
		47: uint16(33848),
		48: uint16(34054),
		49: uint16(33787),
		50: uint16(33901),
		51: uint16(33834),
		52: uint16(33852),
		53: uint16(34138),
		54: uint16(33924),
		55: uint16(33911),
		56: uint16(33899),
		57: uint16(33965),
		58: uint16(33902),
		59: uint16(33922),
		60: uint16(33897),
		61: uint16(33862),
		62: uint16(33836),
		63: uint16(33903),
		64: uint16(33913),
		65: uint16(33845),
		66: uint16(33994),
		67: uint16(33890),
		68: uint16(33977),
		69: uint16(33983),
		70: uint16(33951),
		71: uint16(34009),
		72: uint16(33997),
		73: uint16(33979),
		74: uint16(34010),
		75: uint16(34000),
		76: uint16(33985),
		77: uint16(33990),
		78: uint16(34006),
		79: uint16(33953),
		80: uint16(34081),
		81: uint16(34047),
		82: uint16(34036),
		83: uint16(34071),
		84: uint16(34072),
		85: uint16(34092),
		86: uint16(34079),
		87: uint16(34069),
		88: uint16(34068),
		89: uint16(34044),
		90: uint16(34112),
		91: uint16(34147),
		92: uint16(34136),
		93: uint16(34120),
	},
	72: {
		0:  uint16(34113),
		1:  uint16(34306),
		2:  uint16(34123),
		3:  uint16(34133),
		4:  uint16(34176),
		5:  uint16(34212),
		6:  uint16(34184),
		7:  uint16(34193),
		8:  uint16(34186),
		9:  uint16(34216),
		10: uint16(34157),
		11: uint16(34196),
		12: uint16(34203),
		13: uint16(34282),
		14: uint16(34183),
		15: uint16(34204),
		16: uint16(34167),
		17: uint16(34174),
		18: uint16(34192),
		19: uint16(34249),
		20: uint16(34234),
		21: uint16(34255),
		22: uint16(34233),
		23: uint16(34256),
		24: uint16(34261),
		25: uint16(34269),
		26: uint16(34277),
		27: uint16(34268),
		28: uint16(34297),
		29: uint16(34314),
		30: uint16(34323),
		31: uint16(34315),
		32: uint16(34302),
		33: uint16(34298),
		34: uint16(34310),
		35: uint16(34338),
		36: uint16(34330),
		37: uint16(34352),
		38: uint16(34367),
		39: uint16(34381),
		40: uint16(20053),
		41: uint16(34388),
		42: uint16(34399),
		43: uint16(34407),
		44: uint16(34417),
		45: uint16(34451),
		46: uint16(34467),
		47: uint16(34473),
		48: uint16(34474),
		49: uint16(34443),
		50: uint16(34444),
		51: uint16(34486),
		52: uint16(34479),
		53: uint16(34500),
		54: uint16(34502),
		55: uint16(34480),
		56: uint16(34505),
		57: uint16(34851),
		58: uint16(34475),
		59: uint16(34516),
		60: uint16(34526),
		61: uint16(34537),
		62: uint16(34540),
		63: uint16(34527),
		64: uint16(34523),
		65: uint16(34543),
		66: uint16(34578),
		67: uint16(34566),
		68: uint16(34568),
		69: uint16(34560),
		70: uint16(34563),
		71: uint16(34555),
		72: uint16(34577),
		73: uint16(34569),
		74: uint16(34573),
		75: uint16(34553),
		76: uint16(34570),
		77: uint16(34612),
		78: uint16(34623),
		79: uint16(34615),
		80: uint16(34619),
		81: uint16(34597),
		82: uint16(34601),
		83: uint16(34586),
		84: uint16(34656),
		85: uint16(34655),
		86: uint16(34680),
		87: uint16(34636),
		88: uint16(34638),
		89: uint16(34676),
		90: uint16(34647),
		91: uint16(34664),
		92: uint16(34670),
		93: uint16(34649),
	},
	73: {
		0:  uint16(34643),
		1:  uint16(34659),
		2:  uint16(34666),
		3:  uint16(34821),
		4:  uint16(34722),
		5:  uint16(34719),
		6:  uint16(34690),
		7:  uint16(34735),
		8:  uint16(34763),
		9:  uint16(34749),
		10: uint16(34752),
		11: uint16(34768),
		12: uint16(38614),
		13: uint16(34731),
		14: uint16(34756),
		15: uint16(34739),
		16: uint16(34759),
		17: uint16(34758),
		18: uint16(34747),
		19: uint16(34799),
		20: uint16(34802),
		21: uint16(34784),
		22: uint16(34831),
		23: uint16(34829),
		24: uint16(34814),
		25: uint16(34806),
		26: uint16(34807),
		27: uint16(34830),
		28: uint16(34770),
		29: uint16(34833),
		30: uint16(34838),
		31: uint16(34837),
		32: uint16(34850),
		33: uint16(34849),
		34: uint16(34865),
		35: uint16(34870),
		36: uint16(34873),
		37: uint16(34855),
		38: uint16(34875),
		39: uint16(34884),
		40: uint16(34882),
		41: uint16(34898),
		42: uint16(34905),
		43: uint16(34910),
		44: uint16(34914),
		45: uint16(34923),
		46: uint16(34945),
		47: uint16(34942),
		48: uint16(34974),
		49: uint16(34933),
		50: uint16(34941),
		51: uint16(34997),
		52: uint16(34930),
		53: uint16(34946),
		54: uint16(34967),
		55: uint16(34962),
		56: uint16(34990),
		57: uint16(34969),
		58: uint16(34978),
		59: uint16(34957),
		60: uint16(34980),
		61: uint16(34992),
		62: uint16(35007),
		63: uint16(34993),
		64: uint16(35011),
		65: uint16(35012),
		66: uint16(35028),
		67: uint16(35032),
		68: uint16(35033),
		69: uint16(35037),
		70: uint16(35065),
		71: uint16(35074),
		72: uint16(35068),
		73: uint16(35060),
		74: uint16(35048),
		75: uint16(35058),
		76: uint16(35076),
		77: uint16(35084),
		78: uint16(35082),
		79: uint16(35091),
		80: uint16(35139),
		81: uint16(35102),
		82: uint16(35109),
		83: uint16(35114),
		84: uint16(35115),
		85: uint16(35137),
		86: uint16(35140),
		87: uint16(35131),
		88: uint16(35126),
		89: uint16(35128),
		90: uint16(35148),
		91: uint16(35101),
		92: uint16(35168),
		93: uint16(35166),
	},
	74: {
		0:  uint16(35174),
		1:  uint16(35172),
		2:  uint16(35181),
		3:  uint16(35178),
		4:  uint16(35183),
		5:  uint16(35188),
		6:  uint16(35191),
		7:  uint16(35198),
		8:  uint16(35203),
		9:  uint16(35208),
		10: uint16(35210),
		11: uint16(35219),
		12: uint16(35224),
		13: uint16(35233),
		14: uint16(35241),
		15: uint16(35238),
		16: uint16(35244),
		17: uint16(35247),
		18: uint16(35250),
		19: uint16(35258),
		20: uint16(35261),
		21: uint16(35263),
		22: uint16(35264),
		23: uint16(35290),
		24: uint16(35292),
		25: uint16(35293),
		26: uint16(35303),
		27: uint16(35316),
		28: uint16(35320),
		29: uint16(35331),
		30: uint16(35350),
		31: uint16(35344),
		32: uint16(35340),
		33: uint16(35355),
		34: uint16(35357),
		35: uint16(35365),
		36: uint16(35382),
		37: uint16(35393),
		38: uint16(35419),
		39: uint16(35410),
		40: uint16(35398),
		41: uint16(35400),
		42: uint16(35452),
		43: uint16(35437),
		44: uint16(35436),
		45: uint16(35426),
		46: uint16(35461),
		47: uint16(35458),
		48: uint16(35460),
		49: uint16(35496),
		50: uint16(35489),
		51: uint16(35473),
		52: uint16(35493),
		53: uint16(35494),
		54: uint16(35482),
		55: uint16(35491),
		56: uint16(35524),
		57: uint16(35533),
		58: uint16(35522),
		59: uint16(35546),
		60: uint16(35563),
		61: uint16(35571),
		62: uint16(35559),
		63: uint16(35556),
		64: uint16(35569),
		65: uint16(35604),
		66: uint16(35552),
		67: uint16(35554),
		68: uint16(35575),
		69: uint16(35550),
		70: uint16(35547),
		71: uint16(35596),
		72: uint16(35591),
		73: uint16(35610),
		74: uint16(35553),
		75: uint16(35606),
		76: uint16(35600),
		77: uint16(35607),
		78: uint16(35616),
		79: uint16(35635),
		80: uint16(38827),
		81: uint16(35622),
		82: uint16(35627),
		83: uint16(35646),
		84: uint16(35624),
		85: uint16(35649),
		86: uint16(35660),
		87: uint16(35663),
		88: uint16(35662),
		89: uint16(35657),
		90: uint16(35670),
		91: uint16(35675),
		92: uint16(35674),
		93: uint16(35691),
	},
	75: {
		0:  uint16(35679),
		1:  uint16(35692),
		2:  uint16(35695),
		3:  uint16(35700),
		4:  uint16(35709),
		5:  uint16(35712),
		6:  uint16(35724),
		7:  uint16(35726),
		8:  uint16(35730),
		9:  uint16(35731),
		10: uint16(35734),
		11: uint16(35737),
		12: uint16(35738),
		13: uint16(35898),
		14: uint16(35905),
		15: uint16(35903),
		16: uint16(35912),
		17: uint16(35916),
		18: uint16(35918),
		19: uint16(35920),
		20: uint16(35925),
		21: uint16(35938),
		22: uint16(35948),
		23: uint16(35960),
		24: uint16(35962),
		25: uint16(35970),
		26: uint16(35977),
		27: uint16(35973),
		28: uint16(35978),
		29: uint16(35981),
		30: uint16(35982),
		31: uint16(35988),
		32: uint16(35964),
		33: uint16(35992),
		34: uint16(25117),
		35: uint16(36013),
		36: uint16(36010),
		37: uint16(36029),
		38: uint16(36018),
		39: uint16(36019),
		40: uint16(36014),
		41: uint16(36022),
		42: uint16(36040),
		43: uint16(36033),
		44: uint16(36068),
		45: uint16(36067),
		46: uint16(36058),
		47: uint16(36093),
		48: uint16(36090),
		49: uint16(36091),
		50: uint16(36100),
		51: uint16(36101),
		52: uint16(36106),
		53: uint16(36103),
		54: uint16(36111),
		55: uint16(36109),
		56: uint16(36112),
		57: uint16(40782),
		58: uint16(36115),
		59: uint16(36045),
		60: uint16(36116),
		61: uint16(36118),
		62: uint16(36199),
		63: uint16(36205),
		64: uint16(36209),
		65: uint16(36211),
		66: uint16(36225),
		67: uint16(36249),
		68: uint16(36290),
		69: uint16(36286),
		70: uint16(36282),
		71: uint16(36303),
		72: uint16(36314),
		73: uint16(36310),
		74: uint16(36300),
		75: uint16(36315),
		76: uint16(36299),
		77: uint16(36330),
		78: uint16(36331),
		79: uint16(36319),
		80: uint16(36323),
		81: uint16(36348),
		82: uint16(36360),
		83: uint16(36361),
		84: uint16(36351),
		85: uint16(36381),
		86: uint16(36382),
		87: uint16(36368),
		88: uint16(36383),
		89: uint16(36418),
		90: uint16(36405),
		91: uint16(36400),
		92: uint16(36404),
		93: uint16(36426),
	},
	76: {
		0:  uint16(36423),
		1:  uint16(36425),
		2:  uint16(36428),
		3:  uint16(36432),
		4:  uint16(36424),
		5:  uint16(36441),
		6:  uint16(36452),
		7:  uint16(36448),
		8:  uint16(36394),
		9:  uint16(36451),
		10: uint16(36437),
		11: uint16(36470),
		12: uint16(36466),
		13: uint16(36476),
		14: uint16(36481),
		15: uint16(36487),
		16: uint16(36485),
		17: uint16(36484),
		18: uint16(36491),
		19: uint16(36490),
		20: uint16(36499),
		21: uint16(36497),
		22: uint16(36500),
		23: uint16(36505),
		24: uint16(36522),
		25: uint16(36513),
		26: uint16(36524),
		27: uint16(36528),
		28: uint16(36550),
		29: uint16(36529),
		30: uint16(36542),
		31: uint16(36549),
		32: uint16(36552),
		33: uint16(36555),
		34: uint16(36571),
		35: uint16(36579),
		36: uint16(36604),
		37: uint16(36603),
		38: uint16(36587),
		39: uint16(36606),
		40: uint16(36618),
		41: uint16(36613),
		42: uint16(36629),
		43: uint16(36626),
		44: uint16(36633),
		45: uint16(36627),
		46: uint16(36636),
		47: uint16(36639),
		48: uint16(36635),
		49: uint16(36620),
		50: uint16(36646),
		51: uint16(36659),
		52: uint16(36667),
		53: uint16(36665),
		54: uint16(36677),
		55: uint16(36674),
		56: uint16(36670),
		57: uint16(36684),
		58: uint16(36681),
		59: uint16(36678),
		60: uint16(36686),
		61: uint16(36695),
		62: uint16(36700),
		63: uint16(36706),
		64: uint16(36707),
		65: uint16(36708),
		66: uint16(36764),
		67: uint16(36767),
		68: uint16(36771),
		69: uint16(36781),
		70: uint16(36783),
		71: uint16(36791),
		72: uint16(36826),
		73: uint16(36837),
		74: uint16(36834),
		75: uint16(36842),
		76: uint16(36847),
		77: uint16(36999),
		78: uint16(36852),
		79: uint16(36869),
		80: uint16(36857),
		81: uint16(36858),
		82: uint16(36881),
		83: uint16(36885),
		84: uint16(36897),
		85: uint16(36877),
		86: uint16(36894),
		87: uint16(36886),
		88: uint16(36875),
		89: uint16(36903),
		90: uint16(36918),
		91: uint16(36917),
		92: uint16(36921),
		93: uint16(36856),
	},
	77: {
		0:  uint16(36943),
		1:  uint16(36944),
		2:  uint16(36945),
		3:  uint16(36946),
		4:  uint16(36878),
		5:  uint16(36937),
		6:  uint16(36926),
		7:  uint16(36950),
		8:  uint16(36952),
		9:  uint16(36958),
		10: uint16(36968),
		11: uint16(36975),
		12: uint16(36982),
		13: uint16(38568),
		14: uint16(36978),
		15: uint16(36994),
		16: uint16(36989),
		17: uint16(36993),
		18: uint16(36992),
		19: uint16(37002),
		20: uint16(37001),
		21: uint16(37007),
		22: uint16(37032),
		23: uint16(37039),
		24: uint16(37041),
		25: uint16(37045),
		26: uint16(37090),
		27: uint16(37092),
		28: uint16(25160),
		29: uint16(37083),
		30: uint16(37122),
		31: uint16(37138),
		32: uint16(37145),
		33: uint16(37170),
		34: uint16(37168),
		35: uint16(37194),
		36: uint16(37206),
		37: uint16(37208),
		38: uint16(37219),
		39: uint16(37221),
		40: uint16(37225),
		41: uint16(37235),
		42: uint16(37234),
		43: uint16(37259),
		44: uint16(37257),
		45: uint16(37250),
		46: uint16(37282),
		47: uint16(37291),
		48: uint16(37295),
		49: uint16(37290),
		50: uint16(37301),
		51: uint16(37300),
		52: uint16(37306),
		53: uint16(37312),
		54: uint16(37313),
		55: uint16(37321),
		56: uint16(37323),
		57: uint16(37328),
		58: uint16(37334),
		59: uint16(37343),
		60: uint16(37345),
		61: uint16(37339),
		62: uint16(37372),
		63: uint16(37365),
		64: uint16(37366),
		65: uint16(37406),
		66: uint16(37375),
		67: uint16(37396),
		68: uint16(37420),
		69: uint16(37397),
		70: uint16(37393),
		71: uint16(37470),
		72: uint16(37463),
		73: uint16(37445),
		74: uint16(37449),
		75: uint16(37476),
		76: uint16(37448),
		77: uint16(37525),
		78: uint16(37439),
		79: uint16(37451),
		80: uint16(37456),
		81: uint16(37532),
		82: uint16(37526),
		83: uint16(37523),
		84: uint16(37531),
		85: uint16(37466),
		86: uint16(37583),
		87: uint16(37561),
		88: uint16(37559),
		89: uint16(37609),
		90: uint16(37647),
		91: uint16(37626),
		92: uint16(37700),
		93: uint16(37678),
	},
	78: {
		0:  uint16(37657),
		1:  uint16(37666),
		2:  uint16(37658),
		3:  uint16(37667),
		4:  uint16(37690),
		5:  uint16(37685),
		6:  uint16(37691),
		7:  uint16(37724),
		8:  uint16(37728),
		9:  uint16(37756),
		10: uint16(37742),
		11: uint16(37718),
		12: uint16(37808),
		13: uint16(37804),
		14: uint16(37805),
		15: uint16(37780),
		16: uint16(37817),
		17: uint16(37846),
		18: uint16(37847),
		19: uint16(37864),
		20: uint16(37861),
		21: uint16(37848),
		22: uint16(37827),
		23: uint16(37853),
		24: uint16(37840),
		25: uint16(37832),
		26: uint16(37860),
		27: uint16(37914),
		28: uint16(37908),
		29: uint16(37907),
		30: uint16(37891),
		31: uint16(37895),
		32: uint16(37904),
		33: uint16(37942),
		34: uint16(37931),
		35: uint16(37941),
		36: uint16(37921),
		37: uint16(37946),
		38: uint16(37953),
		39: uint16(37970),
		40: uint16(37956),
		41: uint16(37979),
		42: uint16(37984),
		43: uint16(37986),
		44: uint16(37982),
		45: uint16(37994),
		46: uint16(37417),
		47: uint16(38000),
		48: uint16(38005),
		49: uint16(38007),
		50: uint16(38013),
		51: uint16(37978),
		52: uint16(38012),
		53: uint16(38014),
		54: uint16(38017),
		55: uint16(38015),
		56: uint16(38274),
		57: uint16(38279),
		58: uint16(38282),
		59: uint16(38292),
		60: uint16(38294),
		61: uint16(38296),
		62: uint16(38297),
		63: uint16(38304),
		64: uint16(38312),
		65: uint16(38311),
		66: uint16(38317),
		67: uint16(38332),
		68: uint16(38331),
		69: uint16(38329),
		70: uint16(38334),
		71: uint16(38346),
		72: uint16(28662),
		73: uint16(38339),
		74: uint16(38349),
		75: uint16(38348),
		76: uint16(38357),
		77: uint16(38356),
		78: uint16(38358),
		79: uint16(38364),
		80: uint16(38369),
		81: uint16(38373),
		82: uint16(38370),
		83: uint16(38433),
		84: uint16(38440),
		85: uint16(38446),
		86: uint16(38447),
		87: uint16(38466),
		88: uint16(38476),
		89: uint16(38479),
		90: uint16(38475),
		91: uint16(38519),
		92: uint16(38492),
		93: uint16(38494),
	},
	79: {
		0:  uint16(38493),
		1:  uint16(38495),
		2:  uint16(38502),
		3:  uint16(38514),
		4:  uint16(38508),
		5:  uint16(38541),
		6:  uint16(38552),
		7:  uint16(38549),
		8:  uint16(38551),
		9:  uint16(38570),
		10: uint16(38567),
		11: uint16(38577),
		12: uint16(38578),
		13: uint16(38576),
		14: uint16(38580),
		15: uint16(38582),
		16: uint16(38584),
		17: uint16(38585),
		18: uint16(38606),
		19: uint16(38603),
		20: uint16(38601),
		21: uint16(38605),
		22: uint16(35149),
		23: uint16(38620),
		24: uint16(38669),
		25: uint16(38613),
		26: uint16(38649),
		27: uint16(38660),
		28: uint16(38662),
		29: uint16(38664),
		30: uint16(38675),
		31: uint16(38670),
		32: uint16(38673),
		33: uint16(38671),
		34: uint16(38678),
		35: uint16(38681),
		36: uint16(38692),
		37: uint16(38698),
		38: uint16(38704),
		39: uint16(38713),
		40: uint16(38717),
		41: uint16(38718),
		42: uint16(38724),
		43: uint16(38726),
		44: uint16(38728),
		45: uint16(38722),
		46: uint16(38729),
		47: uint16(38748),
		48: uint16(38752),
		49: uint16(38756),
		50: uint16(38758),
		51: uint16(38760),
		52: uint16(21202),
		53: uint16(38763),
		54: uint16(38769),
		55: uint16(38777),
		56: uint16(38789),
		57: uint16(38780),
		58: uint16(38785),
		59: uint16(38778),
		60: uint16(38790),
		61: uint16(38795),
		62: uint16(38799),
		63: uint16(38800),
		64: uint16(38812),
		65: uint16(38824),
		66: uint16(38822),
		67: uint16(38819),
		68: uint16(38835),
		69: uint16(38836),
		70: uint16(38851),
		71: uint16(38854),
		72: uint16(38856),
		73: uint16(38859),
		74: uint16(38876),
		75: uint16(38893),
		76: uint16(40783),
		77: uint16(38898),
		78: uint16(31455),
		79: uint16(38902),
		80: uint16(38901),
		81: uint16(38927),
		82: uint16(38924),
		83: uint16(38968),
		84: uint16(38948),
		85: uint16(38945),
		86: uint16(38967),
		87: uint16(38973),
		88: uint16(38982),
		89: uint16(38991),
		90: uint16(38987),
		91: uint16(39019),
		92: uint16(39023),
		93: uint16(39024),
	},
	80: {
		0:  uint16(39025),
		1:  uint16(39028),
		2:  uint16(39027),
		3:  uint16(39082),
		4:  uint16(39087),
		5:  uint16(39089),
		6:  uint16(39094),
		7:  uint16(39108),
		8:  uint16(39107),
		9:  uint16(39110),
		10: uint16(39145),
		11: uint16(39147),
		12: uint16(39171),
		13: uint16(39177),
		14: uint16(39186),
		15: uint16(39188),
		16: uint16(39192),
		17: uint16(39201),
		18: uint16(39197),
		19: uint16(39198),
		20: uint16(39204),
		21: uint16(39200),
		22: uint16(39212),
		23: uint16(39214),
		24: uint16(39229),
		25: uint16(39230),
		26: uint16(39234),
		27: uint16(39241),
		28: uint16(39237),
		29: uint16(39248),
		30: uint16(39243),
		31: uint16(39249),
		32: uint16(39250),
		33: uint16(39244),
		34: uint16(39253),
		35: uint16(39319),
		36: uint16(39320),
		37: uint16(39333),
		38: uint16(39341),
		39: uint16(39342),
		40: uint16(39356),
		41: uint16(39391),
		42: uint16(39387),
		43: uint16(39389),
		44: uint16(39384),
		45: uint16(39377),
		46: uint16(39405),
		47: uint16(39406),
		48: uint16(39409),
		49: uint16(39410),
		50: uint16(39419),
		51: uint16(39416),
		52: uint16(39425),
		53: uint16(39439),
		54: uint16(39429),
		55: uint16(39394),
		56: uint16(39449),
		57: uint16(39467),
		58: uint16(39479),
		59: uint16(39493),
		60: uint16(39490),
		61: uint16(39488),
		62: uint16(39491),
		63: uint16(39486),
		64: uint16(39509),
		65: uint16(39501),
		66: uint16(39515),
		67: uint16(39511),
		68: uint16(39519),
		69: uint16(39522),
		70: uint16(39525),
		71: uint16(39524),
		72: uint16(39529),
		73: uint16(39531),
		74: uint16(39530),
		75: uint16(39597),
		76: uint16(39600),
		77: uint16(39612),
		78: uint16(39616),
		79: uint16(39631),
		80: uint16(39633),
		81: uint16(39635),
		82: uint16(39636),
		83: uint16(39646),
		84: uint16(39647),
		85: uint16(39650),
		86: uint16(39651),
		87: uint16(39654),
		88: uint16(39663),
		89: uint16(39659),
		90: uint16(39662),
		91: uint16(39668),
		92: uint16(39665),
		93: uint16(39671),
	},
	81: {
		0:  uint16(39675),
		1:  uint16(39686),
		2:  uint16(39704),
		3:  uint16(39706),
		4:  uint16(39711),
		5:  uint16(39714),
		6:  uint16(39715),
		7:  uint16(39717),
		8:  uint16(39719),
		9:  uint16(39720),
		10: uint16(39721),
		11: uint16(39722),
		12: uint16(39726),
		13: uint16(39727),
		14: uint16(39730),
		15: uint16(39748),
		16: uint16(39747),
		17: uint16(39759),
		18: uint16(39757),
		19: uint16(39758),
		20: uint16(39761),
		21: uint16(39768),
		22: uint16(39796),
		23: uint16(39827),
		24: uint16(39811),
		25: uint16(39825),
		26: uint16(39830),
		27: uint16(39831),
		28: uint16(39839),
		29: uint16(39840),
		30: uint16(39848),
		31: uint16(39860),
		32: uint16(39872),
		33: uint16(39882),
		34: uint16(39865),
		35: uint16(39878),
		36: uint16(39887),
		37: uint16(39889),
		38: uint16(39890),
		39: uint16(39907),
		40: uint16(39906),
		41: uint16(39908),
		42: uint16(39892),
		43: uint16(39905),
		44: uint16(39994),
		45: uint16(39922),
		46: uint16(39921),
		47: uint16(39920),
		48: uint16(39957),
		49: uint16(39956),
		50: uint16(39945),
		51: uint16(39955),
		52: uint16(39948),
		53: uint16(39942),
		54: uint16(39944),
		55: uint16(39954),
		56: uint16(39946),
		57: uint16(39940),
		58: uint16(39982),
		59: uint16(39963),
		60: uint16(39973),
		61: uint16(39972),
		62: uint16(39969),
		63: uint16(39984),
		64: uint16(40007),
		65: uint16(39986),
		66: uint16(40006),
		67: uint16(39998),
		68: uint16(40026),
		69: uint16(40032),
		70: uint16(40039),
		71: uint16(40054),
		72: uint16(40056),
		73: uint16(40167),
		74: uint16(40172),
		75: uint16(40176),
		76: uint16(40201),
		77: uint16(40200),
		78: uint16(40171),
		79: uint16(40195),
		80: uint16(40198),
		81: uint16(40234),
		82: uint16(40230),
		83: uint16(40367),
		84: uint16(40227),
		85: uint16(40223),
		86: uint16(40260),
		87: uint16(40213),
		88: uint16(40210),
		89: uint16(40257),
		90: uint16(40255),
		91: uint16(40254),
		92: uint16(40262),
		93: uint16(40264),
	},
	82: {
		0:  uint16(40285),
		1:  uint16(40286),
		2:  uint16(40292),
		3:  uint16(40273),
		4:  uint16(40272),
		5:  uint16(40281),
		6:  uint16(40306),
		7:  uint16(40329),
		8:  uint16(40327),
		9:  uint16(40363),
		10: uint16(40303),
		11: uint16(40314),
		12: uint16(40346),
		13: uint16(40356),
		14: uint16(40361),
		15: uint16(40370),
		16: uint16(40388),
		17: uint16(40385),
		18: uint16(40379),
		19: uint16(40376),
		20: uint16(40378),
		21: uint16(40390),
		22: uint16(40399),
		23: uint16(40386),
		24: uint16(40409),
		25: uint16(40403),
		26: uint16(40440),
		27: uint16(40422),
		28: uint16(40429),
		29: uint16(40431),
		30: uint16(40445),
		31: uint16(40474),
		32: uint16(40475),
		33: uint16(40478),
		34: uint16(40565),
		35: uint16(40569),
		36: uint16(40573),
		37: uint16(40577),
		38: uint16(40584),
		39: uint16(40587),
		40: uint16(40588),
		41: uint16(40594),
		42: uint16(40597),
		43: uint16(40593),
		44: uint16(40605),
		45: uint16(40613),
		46: uint16(40617),
		47: uint16(40632),
		48: uint16(40618),
		49: uint16(40621),
		50: uint16(38753),
		51: uint16(40652),
		52: uint16(40654),
		53: uint16(40655),
		54: uint16(40656),
		55: uint16(40660),
		56: uint16(40668),
		57: uint16(40670),
		58: uint16(40669),
		59: uint16(40672),
		60: uint16(40677),
		61: uint16(40680),
		62: uint16(40687),
		63: uint16(40692),
		64: uint16(40694),
		65: uint16(40695),
		66: uint16(40697),
		67: uint16(40699),
		68: uint16(40700),
		69: uint16(40701),
		70: uint16(40711),
		71: uint16(40712),
		72: uint16(30391),
		73: uint16(40725),
		74: uint16(40737),
		75: uint16(40748),
		76: uint16(40766),
		77: uint16(40778),
		78: uint16(40786),
		79: uint16(40788),
		80: uint16(40803),
		81: uint16(40799),
		82: uint16(40800),
		83: uint16(40801),
		84: uint16(40806),
		85: uint16(40807),
		86: uint16(40812),
		87: uint16(40810),
		88: uint16(40823),
		89: uint16(40818),
		90: uint16(40822),
		91: uint16(40853),
		92: uint16(40860),
		93: uint16(40864),
	},
	83: {
		0: uint16(22575),
		1: uint16(27079),
		2: uint16(36953),
		3: uint16(29796),
		4: uint16(20956),
		5: uint16(29081),
	},
}

var _gb18030 = [126][190]uint16{
	0: {
		0:   uint16(19970),
		1:   uint16(19972),
		2:   uint16(19973),
		3:   uint16(19974),
		4:   uint16(19983),
		5:   uint16(19986),
		6:   uint16(19991),
		7:   uint16(19999),
		8:   uint16(20000),
		9:   uint16(20001),
		10:  uint16(20003),
		11:  uint16(20006),
		12:  uint16(20009),
		13:  uint16(20014),
		14:  uint16(20015),
		15:  uint16(20017),
		16:  uint16(20019),
		17:  uint16(20021),
		18:  uint16(20023),
		19:  uint16(20028),
		20:  uint16(20032),
		21:  uint16(20033),
		22:  uint16(20034),
		23:  uint16(20036),
		24:  uint16(20038),
		25:  uint16(20042),
		26:  uint16(20049),
		27:  uint16(20053),
		28:  uint16(20055),
		29:  uint16(20058),
		30:  uint16(20059),
		31:  uint16(20066),
		32:  uint16(20067),
		33:  uint16(20068),
		34:  uint16(20069),
		35:  uint16(20071),
		36:  uint16(20072),
		37:  uint16(20074),
		38:  uint16(20075),
		39:  uint16(20076),
		40:  uint16(20077),
		41:  uint16(20078),
		42:  uint16(20079),
		43:  uint16(20082),
		44:  uint16(20084),
		45:  uint16(20085),
		46:  uint16(20086),
		47:  uint16(20087),
		48:  uint16(20088),
		49:  uint16(20089),
		50:  uint16(20090),
		51:  uint16(20091),
		52:  uint16(20092),
		53:  uint16(20093),
		54:  uint16(20095),
		55:  uint16(20096),
		56:  uint16(20097),
		57:  uint16(20098),
		58:  uint16(20099),
		59:  uint16(20100),
		60:  uint16(20101),
		61:  uint16(20103),
		62:  uint16(20106),
		63:  uint16(20112),
		64:  uint16(20118),
		65:  uint16(20119),
		66:  uint16(20121),
		67:  uint16(20124),
		68:  uint16(20125),
		69:  uint16(20126),
		70:  uint16(20131),
		71:  uint16(20138),
		72:  uint16(20143),
		73:  uint16(20144),
		74:  uint16(20145),
		75:  uint16(20148),
		76:  uint16(20150),
		77:  uint16(20151),
		78:  uint16(20152),
		79:  uint16(20153),
		80:  uint16(20156),
		81:  uint16(20157),
		82:  uint16(20158),
		83:  uint16(20168),
		84:  uint16(20172),
		85:  uint16(20175),
		86:  uint16(20176),
		87:  uint16(20178),
		88:  uint16(20186),
		89:  uint16(20187),
		90:  uint16(20188),
		91:  uint16(20192),
		92:  uint16(20194),
		93:  uint16(20198),
		94:  uint16(20199),
		95:  uint16(20201),
		96:  uint16(20205),
		97:  uint16(20206),
		98:  uint16(20207),
		99:  uint16(20209),
		100: uint16(20212),
		101: uint16(20216),
		102: uint16(20217),
		103: uint16(20218),
		104: uint16(20220),
		105: uint16(20222),
		106: uint16(20224),
		107: uint16(20226),
		108: uint16(20227),
		109: uint16(20228),
		110: uint16(20229),
		111: uint16(20230),
		112: uint16(20231),
		113: uint16(20232),
		114: uint16(20235),
		115: uint16(20236),
		116: uint16(20242),
		117: uint16(20243),
		118: uint16(20244),
		119: uint16(20245),
		120: uint16(20246),
		121: uint16(20252),
		122: uint16(20253),
		123: uint16(20257),
		124: uint16(20259),
		125: uint16(20264),
		126: uint16(20265),
		127: uint16(20268),
		128: uint16(20269),
		129: uint16(20270),
		130: uint16(20273),
		131: uint16(20275),
		132: uint16(20277),
		133: uint16(20279),
		134: uint16(20281),
		135: uint16(20283),
		136: uint16(20286),
		137: uint16(20287),
		138: uint16(20288),
		139: uint16(20289),
		140: uint16(20290),
		141: uint16(20292),
		142: uint16(20293),
		143: uint16(20295),
		144: uint16(20296),
		145: uint16(20297),
		146: uint16(20298),
		147: uint16(20299),
		148: uint16(20300),
		149: uint16(20306),
		150: uint16(20308),
		151: uint16(20310),
		152: uint16(20321),
		153: uint16(20322),
		154: uint16(20326),
		155: uint16(20328),
		156: uint16(20330),
		157: uint16(20331),
		158: uint16(20333),
		159: uint16(20334),
		160: uint16(20337),
		161: uint16(20338),
		162: uint16(20341),
		163: uint16(20343),
		164: uint16(20344),
		165: uint16(20345),
		166: uint16(20346),
		167: uint16(20349),
		168: uint16(20352),
		169: uint16(20353),
		170: uint16(20354),
		171: uint16(20357),
		172: uint16(20358),
		173: uint16(20359),
		174: uint16(20362),
		175: uint16(20364),
		176: uint16(20366),
		177: uint16(20368),
		178: uint16(20370),
		179: uint16(20371),
		180: uint16(20373),
		181: uint16(20374),
		182: uint16(20376),
		183: uint16(20377),
		184: uint16(20378),
		185: uint16(20380),
		186: uint16(20382),
		187: uint16(20383),
		188: uint16(20385),
		189: uint16(20386),
	},
	1: {
		0:   uint16(20388),
		1:   uint16(20395),
		2:   uint16(20397),
		3:   uint16(20400),
		4:   uint16(20401),
		5:   uint16(20402),
		6:   uint16(20403),
		7:   uint16(20404),
		8:   uint16(20406),
		9:   uint16(20407),
		10:  uint16(20408),
		11:  uint16(20409),
		12:  uint16(20410),
		13:  uint16(20411),
		14:  uint16(20412),
		15:  uint16(20413),
		16:  uint16(20414),
		17:  uint16(20416),
		18:  uint16(20417),
		19:  uint16(20418),
		20:  uint16(20422),
		21:  uint16(20423),
		22:  uint16(20424),
		23:  uint16(20425),
		24:  uint16(20427),
		25:  uint16(20428),
		26:  uint16(20429),
		27:  uint16(20434),
		28:  uint16(20435),
		29:  uint16(20436),
		30:  uint16(20437),
		31:  uint16(20438),
		32:  uint16(20441),
		33:  uint16(20443),
		34:  uint16(20448),
		35:  uint16(20450),
		36:  uint16(20452),
		37:  uint16(20453),
		38:  uint16(20455),
		39:  uint16(20459),
		40:  uint16(20460),
		41:  uint16(20464),
		42:  uint16(20466),
		43:  uint16(20468),
		44:  uint16(20469),
		45:  uint16(20470),
		46:  uint16(20471),
		47:  uint16(20473),
		48:  uint16(20475),
		49:  uint16(20476),
		50:  uint16(20477),
		51:  uint16(20479),
		52:  uint16(20480),
		53:  uint16(20481),
		54:  uint16(20482),
		55:  uint16(20483),
		56:  uint16(20484),
		57:  uint16(20485),
		58:  uint16(20486),
		59:  uint16(20487),
		60:  uint16(20488),
		61:  uint16(20489),
		62:  uint16(20490),
		63:  uint16(20491),
		64:  uint16(20494),
		65:  uint16(20496),
		66:  uint16(20497),
		67:  uint16(20499),
		68:  uint16(20501),
		69:  uint16(20502),
		70:  uint16(20503),
		71:  uint16(20507),
		72:  uint16(20509),
		73:  uint16(20510),
		74:  uint16(20512),
		75:  uint16(20514),
		76:  uint16(20515),
		77:  uint16(20516),
		78:  uint16(20519),
		79:  uint16(20523),
		80:  uint16(20527),
		81:  uint16(20528),
		82:  uint16(20529),
		83:  uint16(20530),
		84:  uint16(20531),
		85:  uint16(20532),
		86:  uint16(20533),
		87:  uint16(20534),
		88:  uint16(20535),
		89:  uint16(20536),
		90:  uint16(20537),
		91:  uint16(20539),
		92:  uint16(20541),
		93:  uint16(20543),
		94:  uint16(20544),
		95:  uint16(20545),
		96:  uint16(20546),
		97:  uint16(20548),
		98:  uint16(20549),
		99:  uint16(20550),
		100: uint16(20553),
		101: uint16(20554),
		102: uint16(20555),
		103: uint16(20557),
		104: uint16(20560),
		105: uint16(20561),
		106: uint16(20562),
		107: uint16(20563),
		108: uint16(20564),
		109: uint16(20566),
		110: uint16(20567),
		111: uint16(20568),
		112: uint16(20569),
		113: uint16(20571),
		114: uint16(20573),
		115: uint16(20574),
		116: uint16(20575),
		117: uint16(20576),
		118: uint16(20577),
		119: uint16(20578),
		120: uint16(20579),
		121: uint16(20580),
		122: uint16(20582),
		123: uint16(20583),
		124: uint16(20584),
		125: uint16(20585),
		126: uint16(20586),
		127: uint16(20587),
		128: uint16(20589),
		129: uint16(20590),
		130: uint16(20591),
		131: uint16(20592),
		132: uint16(20593),
		133: uint16(20594),
		134: uint16(20595),
		135: uint16(20596),
		136: uint16(20597),
		137: uint16(20600),
		138: uint16(20601),
		139: uint16(20602),
		140: uint16(20604),
		141: uint16(20605),
		142: uint16(20609),
		143: uint16(20610),
		144: uint16(20611),
		145: uint16(20612),
		146: uint16(20614),
		147: uint16(20615),
		148: uint16(20617),
		149: uint16(20618),
		150: uint16(20619),
		151: uint16(20620),
		152: uint16(20622),
		153: uint16(20623),
		154: uint16(20624),
		155: uint16(20625),
		156: uint16(20626),
		157: uint16(20627),
		158: uint16(20628),
		159: uint16(20629),
		160: uint16(20630),
		161: uint16(20631),
		162: uint16(20632),
		163: uint16(20633),
		164: uint16(20634),
		165: uint16(20635),
		166: uint16(20636),
		167: uint16(20637),
		168: uint16(20638),
		169: uint16(20639),
		170: uint16(20640),
		171: uint16(20641),
		172: uint16(20642),
		173: uint16(20644),
		174: uint16(20646),
		175: uint16(20650),
		176: uint16(20651),
		177: uint16(20653),
		178: uint16(20654),
		179: uint16(20655),
		180: uint16(20656),
		181: uint16(20657),
		182: uint16(20659),
		183: uint16(20660),
		184: uint16(20661),
		185: uint16(20662),
		186: uint16(20663),
		187: uint16(20664),
		188: uint16(20665),
		189: uint16(20668),
	},
	2: {
		0:   uint16(20669),
		1:   uint16(20670),
		2:   uint16(20671),
		3:   uint16(20672),
		4:   uint16(20673),
		5:   uint16(20674),
		6:   uint16(20675),
		7:   uint16(20676),
		8:   uint16(20677),
		9:   uint16(20678),
		10:  uint16(20679),
		11:  uint16(20680),
		12:  uint16(20681),
		13:  uint16(20682),
		14:  uint16(20683),
		15:  uint16(20684),
		16:  uint16(20685),
		17:  uint16(20686),
		18:  uint16(20688),
		19:  uint16(20689),
		20:  uint16(20690),
		21:  uint16(20691),
		22:  uint16(20692),
		23:  uint16(20693),
		24:  uint16(20695),
		25:  uint16(20696),
		26:  uint16(20697),
		27:  uint16(20699),
		28:  uint16(20700),
		29:  uint16(20701),
		30:  uint16(20702),
		31:  uint16(20703),
		32:  uint16(20704),
		33:  uint16(20705),
		34:  uint16(20706),
		35:  uint16(20707),
		36:  uint16(20708),
		37:  uint16(20709),
		38:  uint16(20712),
		39:  uint16(20713),
		40:  uint16(20714),
		41:  uint16(20715),
		42:  uint16(20719),
		43:  uint16(20720),
		44:  uint16(20721),
		45:  uint16(20722),
		46:  uint16(20724),
		47:  uint16(20726),
		48:  uint16(20727),
		49:  uint16(20728),
		50:  uint16(20729),
		51:  uint16(20730),
		52:  uint16(20732),
		53:  uint16(20733),
		54:  uint16(20734),
		55:  uint16(20735),
		56:  uint16(20736),
		57:  uint16(20737),
		58:  uint16(20738),
		59:  uint16(20739),
		60:  uint16(20740),
		61:  uint16(20741),
		62:  uint16(20744),
		63:  uint16(20745),
		64:  uint16(20746),
		65:  uint16(20748),
		66:  uint16(20749),
		67:  uint16(20750),
		68:  uint16(20751),
		69:  uint16(20752),
		70:  uint16(20753),
		71:  uint16(20755),
		72:  uint16(20756),
		73:  uint16(20757),
		74:  uint16(20758),
		75:  uint16(20759),
		76:  uint16(20760),
		77:  uint16(20761),
		78:  uint16(20762),
		79:  uint16(20763),
		80:  uint16(20764),
		81:  uint16(20765),
		82:  uint16(20766),
		83:  uint16(20767),
		84:  uint16(20768),
		85:  uint16(20770),
		86:  uint16(20771),
		87:  uint16(20772),
		88:  uint16(20773),
		89:  uint16(20774),
		90:  uint16(20775),
		91:  uint16(20776),
		92:  uint16(20777),
		93:  uint16(20778),
		94:  uint16(20779),
		95:  uint16(20780),
		96:  uint16(20781),
		97:  uint16(20782),
		98:  uint16(20783),
		99:  uint16(20784),
		100: uint16(20785),
		101: uint16(20786),
		102: uint16(20787),
		103: uint16(20788),
		104: uint16(20789),
		105: uint16(20790),
		106: uint16(20791),
		107: uint16(20792),
		108: uint16(20793),
		109: uint16(20794),
		110: uint16(20795),
		111: uint16(20796),
		112: uint16(20797),
		113: uint16(20798),
		114: uint16(20802),
		115: uint16(20807),
		116: uint16(20810),
		117: uint16(20812),
		118: uint16(20814),
		119: uint16(20815),
		120: uint16(20816),
		121: uint16(20818),
		122: uint16(20819),
		123: uint16(20823),
		124: uint16(20824),
		125: uint16(20825),
		126: uint16(20827),
		127: uint16(20829),
		128: uint16(20830),
		129: uint16(20831),
		130: uint16(20832),
		131: uint16(20833),
		132: uint16(20835),
		133: uint16(20836),
		134: uint16(20838),
		135: uint16(20839),
		136: uint16(20841),
		137: uint16(20842),
		138: uint16(20847),
		139: uint16(20850),
		140: uint16(20858),
		141: uint16(20862),
		142: uint16(20863),
		143: uint16(20867),
		144: uint16(20868),
		145: uint16(20870),
		146: uint16(20871),
		147: uint16(20874),
		148: uint16(20875),
		149: uint16(20878),
		150: uint16(20879),
		151: uint16(20880),
		152: uint16(20881),
		153: uint16(20883),
		154: uint16(20884),
		155: uint16(20888),
		156: uint16(20890),
		157: uint16(20893),
		158: uint16(20894),
		159: uint16(20895),
		160: uint16(20897),
		161: uint16(20899),
		162: uint16(20902),
		163: uint16(20903),
		164: uint16(20904),
		165: uint16(20905),
		166: uint16(20906),
		167: uint16(20909),
		168: uint16(20910),
		169: uint16(20916),
		170: uint16(20920),
		171: uint16(20921),
		172: uint16(20922),
		173: uint16(20926),
		174: uint16(20927),
		175: uint16(20929),
		176: uint16(20930),
		177: uint16(20931),
		178: uint16(20933),
		179: uint16(20936),
		180: uint16(20938),
		181: uint16(20941),
		182: uint16(20942),
		183: uint16(20944),
		184: uint16(20946),
		185: uint16(20947),
		186: uint16(20948),
		187: uint16(20949),
		188: uint16(20950),
		189: uint16(20951),
	},
	3: {
		0:   uint16(20952),
		1:   uint16(20953),
		2:   uint16(20954),
		3:   uint16(20956),
		4:   uint16(20958),
		5:   uint16(20959),
		6:   uint16(20962),
		7:   uint16(20963),
		8:   uint16(20965),
		9:   uint16(20966),
		10:  uint16(20967),
		11:  uint16(20968),
		12:  uint16(20969),
		13:  uint16(20970),
		14:  uint16(20972),
		15:  uint16(20974),
		16:  uint16(20977),
		17:  uint16(20978),
		18:  uint16(20980),
		19:  uint16(20983),
		20:  uint16(20990),
		21:  uint16(20996),
		22:  uint16(20997),
		23:  uint16(21001),
		24:  uint16(21003),
		25:  uint16(21004),
		26:  uint16(21007),
		27:  uint16(21008),
		28:  uint16(21011),
		29:  uint16(21012),
		30:  uint16(21013),
		31:  uint16(21020),
		32:  uint16(21022),
		33:  uint16(21023),
		34:  uint16(21025),
		35:  uint16(21026),
		36:  uint16(21027),
		37:  uint16(21029),
		38:  uint16(21030),
		39:  uint16(21031),
		40:  uint16(21034),
		41:  uint16(21036),
		42:  uint16(21039),
		43:  uint16(21041),
		44:  uint16(21042),
		45:  uint16(21044),
		46:  uint16(21045),
		47:  uint16(21052),
		48:  uint16(21054),
		49:  uint16(21060),
		50:  uint16(21061),
		51:  uint16(21062),
		52:  uint16(21063),
		53:  uint16(21064),
		54:  uint16(21065),
		55:  uint16(21067),
		56:  uint16(21070),
		57:  uint16(21071),
		58:  uint16(21074),
		59:  uint16(21075),
		60:  uint16(21077),
		61:  uint16(21079),
		62:  uint16(21080),
		63:  uint16(21081),
		64:  uint16(21082),
		65:  uint16(21083),
		66:  uint16(21085),
		67:  uint16(21087),
		68:  uint16(21088),
		69:  uint16(21090),
		70:  uint16(21091),
		71:  uint16(21092),
		72:  uint16(21094),
		73:  uint16(21096),
		74:  uint16(21099),
		75:  uint16(21100),
		76:  uint16(21101),
		77:  uint16(21102),
		78:  uint16(21104),
		79:  uint16(21105),
		80:  uint16(21107),
		81:  uint16(21108),
		82:  uint16(21109),
		83:  uint16(21110),
		84:  uint16(21111),
		85:  uint16(21112),
		86:  uint16(21113),
		87:  uint16(21114),
		88:  uint16(21115),
		89:  uint16(21116),
		90:  uint16(21118),
		91:  uint16(21120),
		92:  uint16(21123),
		93:  uint16(21124),
		94:  uint16(21125),
		95:  uint16(21126),
		96:  uint16(21127),
		97:  uint16(21129),
		98:  uint16(21130),
		99:  uint16(21131),
		100: uint16(21132),
		101: uint16(21133),
		102: uint16(21134),
		103: uint16(21135),
		104: uint16(21137),
		105: uint16(21138),
		106: uint16(21140),
		107: uint16(21141),
		108: uint16(21142),
		109: uint16(21143),
		110: uint16(21144),
		111: uint16(21145),
		112: uint16(21146),
		113: uint16(21148),
		114: uint16(21156),
		115: uint16(21157),
		116: uint16(21158),
		117: uint16(21159),
		118: uint16(21166),
		119: uint16(21167),
		120: uint16(21168),
		121: uint16(21172),
		122: uint16(21173),
		123: uint16(21174),
		124: uint16(21175),
		125: uint16(21176),
		126: uint16(21177),
		127: uint16(21178),
		128: uint16(21179),
		129: uint16(21180),
		130: uint16(21181),
		131: uint16(21184),
		132: uint16(21185),
		133: uint16(21186),
		134: uint16(21188),
		135: uint16(21189),
		136: uint16(21190),
		137: uint16(21192),
		138: uint16(21194),
		139: uint16(21196),
		140: uint16(21197),
		141: uint16(21198),
		142: uint16(21199),
		143: uint16(21201),
		144: uint16(21203),
		145: uint16(21204),
		146: uint16(21205),
		147: uint16(21207),
		148: uint16(21209),
		149: uint16(21210),
		150: uint16(21211),
		151: uint16(21212),
		152: uint16(21213),
		153: uint16(21214),
		154: uint16(21216),
		155: uint16(21217),
		156: uint16(21218),
		157: uint16(21219),
		158: uint16(21221),
		159: uint16(21222),
		160: uint16(21223),
		161: uint16(21224),
		162: uint16(21225),
		163: uint16(21226),
		164: uint16(21227),
		165: uint16(21228),
		166: uint16(21229),
		167: uint16(21230),
		168: uint16(21231),
		169: uint16(21233),
		170: uint16(21234),
		171: uint16(21235),
		172: uint16(21236),
		173: uint16(21237),
		174: uint16(21238),
		175: uint16(21239),
		176: uint16(21240),
		177: uint16(21243),
		178: uint16(21244),
		179: uint16(21245),
		180: uint16(21249),
		181: uint16(21250),
		182: uint16(21251),
		183: uint16(21252),
		184: uint16(21255),
		185: uint16(21257),
		186: uint16(21258),
		187: uint16(21259),
		188: uint16(21260),
		189: uint16(21262),
	},
	4: {
		0:   uint16(21265),
		1:   uint16(21266),
		2:   uint16(21267),
		3:   uint16(21268),
		4:   uint16(21272),
		5:   uint16(21275),
		6:   uint16(21276),
		7:   uint16(21278),
		8:   uint16(21279),
		9:   uint16(21282),
		10:  uint16(21284),
		11:  uint16(21285),
		12:  uint16(21287),
		13:  uint16(21288),
		14:  uint16(21289),
		15:  uint16(21291),
		16:  uint16(21292),
		17:  uint16(21293),
		18:  uint16(21295),
		19:  uint16(21296),
		20:  uint16(21297),
		21:  uint16(21298),
		22:  uint16(21299),
		23:  uint16(21300),
		24:  uint16(21301),
		25:  uint16(21302),
		26:  uint16(21303),
		27:  uint16(21304),
		28:  uint16(21308),
		29:  uint16(21309),
		30:  uint16(21312),
		31:  uint16(21314),
		32:  uint16(21316),
		33:  uint16(21318),
		34:  uint16(21323),
		35:  uint16(21324),
		36:  uint16(21325),
		37:  uint16(21328),
		38:  uint16(21332),
		39:  uint16(21336),
		40:  uint16(21337),
		41:  uint16(21339),
		42:  uint16(21341),
		43:  uint16(21349),
		44:  uint16(21352),
		45:  uint16(21354),
		46:  uint16(21356),
		47:  uint16(21357),
		48:  uint16(21362),
		49:  uint16(21366),
		50:  uint16(21369),
		51:  uint16(21371),
		52:  uint16(21372),
		53:  uint16(21373),
		54:  uint16(21374),
		55:  uint16(21376),
		56:  uint16(21377),
		57:  uint16(21379),
		58:  uint16(21383),
		59:  uint16(21384),
		60:  uint16(21386),
		61:  uint16(21390),
		62:  uint16(21391),
		63:  uint16(21392),
		64:  uint16(21393),
		65:  uint16(21394),
		66:  uint16(21395),
		67:  uint16(21396),
		68:  uint16(21398),
		69:  uint16(21399),
		70:  uint16(21401),
		71:  uint16(21403),
		72:  uint16(21404),
		73:  uint16(21406),
		74:  uint16(21408),
		75:  uint16(21409),
		76:  uint16(21412),
		77:  uint16(21415),
		78:  uint16(21418),
		79:  uint16(21419),
		80:  uint16(21420),
		81:  uint16(21421),
		82:  uint16(21423),
		83:  uint16(21424),
		84:  uint16(21425),
		85:  uint16(21426),
		86:  uint16(21427),
		87:  uint16(21428),
		88:  uint16(21429),
		89:  uint16(21431),
		90:  uint16(21432),
		91:  uint16(21433),
		92:  uint16(21434),
		93:  uint16(21436),
		94:  uint16(21437),
		95:  uint16(21438),
		96:  uint16(21440),
		97:  uint16(21443),
		98:  uint16(21444),
		99:  uint16(21445),
		100: uint16(21446),
		101: uint16(21447),
		102: uint16(21454),
		103: uint16(21455),
		104: uint16(21456),
		105: uint16(21458),
		106: uint16(21459),
		107: uint16(21461),
		108: uint16(21466),
		109: uint16(21468),
		110: uint16(21469),
		111: uint16(21470),
		112: uint16(21473),
		113: uint16(21474),
		114: uint16(21479),
		115: uint16(21492),
		116: uint16(21498),
		117: uint16(21502),
		118: uint16(21503),
		119: uint16(21504),
		120: uint16(21506),
		121: uint16(21509),
		122: uint16(21511),
		123: uint16(21515),
		124: uint16(21524),
		125: uint16(21528),
		126: uint16(21529),
		127: uint16(21530),
		128: uint16(21532),
		129: uint16(21538),
		130: uint16(21540),
		131: uint16(21541),
		132: uint16(21546),
		133: uint16(21552),
		134: uint16(21555),
		135: uint16(21558),
		136: uint16(21559),
		137: uint16(21562),
		138: uint16(21565),
		139: uint16(21567),
		140: uint16(21569),
		141: uint16(21570),
		142: uint16(21572),
		143: uint16(21573),
		144: uint16(21575),
		145: uint16(21577),
		146: uint16(21580),
		147: uint16(21581),
		148: uint16(21582),
		149: uint16(21583),
		150: uint16(21585),
		151: uint16(21594),
		152: uint16(21597),
		153: uint16(21598),
		154: uint16(21599),
		155: uint16(21600),
		156: uint16(21601),
		157: uint16(21603),
		158: uint16(21605),
		159: uint16(21607),
		160: uint16(21609),
		161: uint16(21610),
		162: uint16(21611),
		163: uint16(21612),
		164: uint16(21613),
		165: uint16(21614),
		166: uint16(21615),
		167: uint16(21616),
		168: uint16(21620),
		169: uint16(21625),
		170: uint16(21626),
		171: uint16(21630),
		172: uint16(21631),
		173: uint16(21633),
		174: uint16(21635),
		175: uint16(21637),
		176: uint16(21639),
		177: uint16(21640),
		178: uint16(21641),
		179: uint16(21642),
		180: uint16(21645),
		181: uint16(21649),
		182: uint16(21651),
		183: uint16(21655),
		184: uint16(21656),
		185: uint16(21660),
		186: uint16(21662),
		187: uint16(21663),
		188: uint16(21664),
		189: uint16(21665),
	},
	5: {
		0:   uint16(21666),
		1:   uint16(21669),
		2:   uint16(21678),
		3:   uint16(21680),
		4:   uint16(21682),
		5:   uint16(21685),
		6:   uint16(21686),
		7:   uint16(21687),
		8:   uint16(21689),
		9:   uint16(21690),
		10:  uint16(21692),
		11:  uint16(21694),
		12:  uint16(21699),
		13:  uint16(21701),
		14:  uint16(21706),
		15:  uint16(21707),
		16:  uint16(21718),
		17:  uint16(21720),
		18:  uint16(21723),
		19:  uint16(21728),
		20:  uint16(21729),
		21:  uint16(21730),
		22:  uint16(21731),
		23:  uint16(21732),
		24:  uint16(21739),
		25:  uint16(21740),
		26:  uint16(21743),
		27:  uint16(21744),
		28:  uint16(21745),
		29:  uint16(21748),
		30:  uint16(21749),
		31:  uint16(21750),
		32:  uint16(21751),
		33:  uint16(21752),
		34:  uint16(21753),
		35:  uint16(21755),
		36:  uint16(21758),
		37:  uint16(21760),
		38:  uint16(21762),
		39:  uint16(21763),
		40:  uint16(21764),
		41:  uint16(21765),
		42:  uint16(21768),
		43:  uint16(21770),
		44:  uint16(21771),
		45:  uint16(21772),
		46:  uint16(21773),
		47:  uint16(21774),
		48:  uint16(21778),
		49:  uint16(21779),
		50:  uint16(21781),
		51:  uint16(21782),
		52:  uint16(21783),
		53:  uint16(21784),
		54:  uint16(21785),
		55:  uint16(21786),
		56:  uint16(21788),
		57:  uint16(21789),
		58:  uint16(21790),
		59:  uint16(21791),
		60:  uint16(21793),
		61:  uint16(21797),
		62:  uint16(21798),
		63:  uint16(21800),
		64:  uint16(21801),
		65:  uint16(21803),
		66:  uint16(21805),
		67:  uint16(21810),
		68:  uint16(21812),
		69:  uint16(21813),
		70:  uint16(21814),
		71:  uint16(21816),
		72:  uint16(21817),
		73:  uint16(21818),
		74:  uint16(21819),
		75:  uint16(21821),
		76:  uint16(21824),
		77:  uint16(21826),
		78:  uint16(21829),
		79:  uint16(21831),
		80:  uint16(21832),
		81:  uint16(21835),
		82:  uint16(21836),
		83:  uint16(21837),
		84:  uint16(21838),
		85:  uint16(21839),
		86:  uint16(21841),
		87:  uint16(21842),
		88:  uint16(21843),
		89:  uint16(21844),
		90:  uint16(21847),
		91:  uint16(21848),
		92:  uint16(21849),
		93:  uint16(21850),
		94:  uint16(21851),
		95:  uint16(21853),
		96:  uint16(21854),
		97:  uint16(21855),
		98:  uint16(21856),
		99:  uint16(21858),
		100: uint16(21859),
		101: uint16(21864),
		102: uint16(21865),
		103: uint16(21867),
		104: uint16(21871),
		105: uint16(21872),
		106: uint16(21873),
		107: uint16(21874),
		108: uint16(21875),
		109: uint16(21876),
		110: uint16(21881),
		111: uint16(21882),
		112: uint16(21885),
		113: uint16(21887),
		114: uint16(21893),
		115: uint16(21894),
		116: uint16(21900),
		117: uint16(21901),
		118: uint16(21902),
		119: uint16(21904),
		120: uint16(21906),
		121: uint16(21907),
		122: uint16(21909),
		123: uint16(21910),
		124: uint16(21911),
		125: uint16(21914),
		126: uint16(21915),
		127: uint16(21918),
		128: uint16(21920),
		129: uint16(21921),
		130: uint16(21922),
		131: uint16(21923),
		132: uint16(21924),
		133: uint16(21925),
		134: uint16(21926),
		135: uint16(21928),
		136: uint16(21929),
		137: uint16(21930),
		138: uint16(21931),
		139: uint16(21932),
		140: uint16(21933),
		141: uint16(21934),
		142: uint16(21935),
		143: uint16(21936),
		144: uint16(21938),
		145: uint16(21940),
		146: uint16(21942),
		147: uint16(21944),
		148: uint16(21946),
		149: uint16(21948),
		150: uint16(21951),
		151: uint16(21952),
		152: uint16(21953),
		153: uint16(21954),
		154: uint16(21955),
		155: uint16(21958),
		156: uint16(21959),
		157: uint16(21960),
		158: uint16(21962),
		159: uint16(21963),
		160: uint16(21966),
		161: uint16(21967),
		162: uint16(21968),
		163: uint16(21973),
		164: uint16(21975),
		165: uint16(21976),
		166: uint16(21977),
		167: uint16(21978),
		168: uint16(21979),
		169: uint16(21982),
		170: uint16(21984),
		171: uint16(21986),
		172: uint16(21991),
		173: uint16(21993),
		174: uint16(21997),
		175: uint16(21998),
		176: uint16(22000),
		177: uint16(22001),
		178: uint16(22004),
		179: uint16(22006),
		180: uint16(22008),
		181: uint16(22009),
		182: uint16(22010),
		183: uint16(22011),
		184: uint16(22012),
		185: uint16(22015),
		186: uint16(22018),
		187: uint16(22019),
		188: uint16(22020),
		189: uint16(22021),
	},
	6: {
		0:   uint16(22022),
		1:   uint16(22023),
		2:   uint16(22026),
		3:   uint16(22027),
		4:   uint16(22029),
		5:   uint16(22032),
		6:   uint16(22033),
		7:   uint16(22034),
		8:   uint16(22035),
		9:   uint16(22036),
		10:  uint16(22037),
		11:  uint16(22038),
		12:  uint16(22039),
		13:  uint16(22041),
		14:  uint16(22042),
		15:  uint16(22044),
		16:  uint16(22045),
		17:  uint16(22048),
		18:  uint16(22049),
		19:  uint16(22050),
		20:  uint16(22053),
		21:  uint16(22054),
		22:  uint16(22056),
		23:  uint16(22057),
		24:  uint16(22058),
		25:  uint16(22059),
		26:  uint16(22062),
		27:  uint16(22063),
		28:  uint16(22064),
		29:  uint16(22067),
		30:  uint16(22069),
		31:  uint16(22071),
		32:  uint16(22072),
		33:  uint16(22074),
		34:  uint16(22076),
		35:  uint16(22077),
		36:  uint16(22078),
		37:  uint16(22080),
		38:  uint16(22081),
		39:  uint16(22082),
		40:  uint16(22083),
		41:  uint16(22084),
		42:  uint16(22085),
		43:  uint16(22086),
		44:  uint16(22087),
		45:  uint16(22088),
		46:  uint16(22089),
		47:  uint16(22090),
		48:  uint16(22091),
		49:  uint16(22095),
		50:  uint16(22096),
		51:  uint16(22097),
		52:  uint16(22098),
		53:  uint16(22099),
		54:  uint16(22101),
		55:  uint16(22102),
		56:  uint16(22106),
		57:  uint16(22107),
		58:  uint16(22109),
		59:  uint16(22110),
		60:  uint16(22111),
		61:  uint16(22112),
		62:  uint16(22113),
		63:  uint16(22115),
		64:  uint16(22117),
		65:  uint16(22118),
		66:  uint16(22119),
		67:  uint16(22125),
		68:  uint16(22126),
		69:  uint16(22127),
		70:  uint16(22128),
		71:  uint16(22130),
		72:  uint16(22131),
		73:  uint16(22132),
		74:  uint16(22133),
		75:  uint16(22135),
		76:  uint16(22136),
		77:  uint16(22137),
		78:  uint16(22138),
		79:  uint16(22141),
		80:  uint16(22142),
		81:  uint16(22143),
		82:  uint16(22144),
		83:  uint16(22145),
		84:  uint16(22146),
		85:  uint16(22147),
		86:  uint16(22148),
		87:  uint16(22151),
		88:  uint16(22152),
		89:  uint16(22153),
		90:  uint16(22154),
		91:  uint16(22155),
		92:  uint16(22156),
		93:  uint16(22157),
		94:  uint16(22160),
		95:  uint16(22161),
		96:  uint16(22162),
		97:  uint16(22164),
		98:  uint16(22165),
		99:  uint16(22166),
		100: uint16(22167),
		101: uint16(22168),
		102: uint16(22169),
		103: uint16(22170),
		104: uint16(22171),
		105: uint16(22172),
		106: uint16(22173),
		107: uint16(22174),
		108: uint16(22175),
		109: uint16(22176),
		110: uint16(22177),
		111: uint16(22178),
		112: uint16(22180),
		113: uint16(22181),
		114: uint16(22182),
		115: uint16(22183),
		116: uint16(22184),
		117: uint16(22185),
		118: uint16(22186),
		119: uint16(22187),
		120: uint16(22188),
		121: uint16(22189),
		122: uint16(22190),
		123: uint16(22192),
		124: uint16(22193),
		125: uint16(22194),
		126: uint16(22195),
		127: uint16(22196),
		128: uint16(22197),
		129: uint16(22198),
		130: uint16(22200),
		131: uint16(22201),
		132: uint16(22202),
		133: uint16(22203),
		134: uint16(22205),
		135: uint16(22206),
		136: uint16(22207),
		137: uint16(22208),
		138: uint16(22209),
		139: uint16(22210),
		140: uint16(22211),
		141: uint16(22212),
		142: uint16(22213),
		143: uint16(22214),
		144: uint16(22215),
		145: uint16(22216),
		146: uint16(22217),
		147: uint16(22219),
		148: uint16(22220),
		149: uint16(22221),
		150: uint16(22222),
		151: uint16(22223),
		152: uint16(22224),
		153: uint16(22225),
		154: uint16(22226),
		155: uint16(22227),
		156: uint16(22229),
		157: uint16(22230),
		158: uint16(22232),
		159: uint16(22233),
		160: uint16(22236),
		161: uint16(22243),
		162: uint16(22245),
		163: uint16(22246),
		164: uint16(22247),
		165: uint16(22248),
		166: uint16(22249),
		167: uint16(22250),
		168: uint16(22252),
		169: uint16(22254),
		170: uint16(22255),
		171: uint16(22258),
		172: uint16(22259),
		173: uint16(22262),
		174: uint16(22263),
		175: uint16(22264),
		176: uint16(22267),
		177: uint16(22268),
		178: uint16(22272),
		179: uint16(22273),
		180: uint16(22274),
		181: uint16(22277),
		182: uint16(22279),
		183: uint16(22283),
		184: uint16(22284),
		185: uint16(22285),
		186: uint16(22286),
		187: uint16(22287),
		188: uint16(22288),
		189: uint16(22289),
	},
	7: {
		0:   uint16(22290),
		1:   uint16(22291),
		2:   uint16(22292),
		3:   uint16(22293),
		4:   uint16(22294),
		5:   uint16(22295),
		6:   uint16(22296),
		7:   uint16(22297),
		8:   uint16(22298),
		9:   uint16(22299),
		10:  uint16(22301),
		11:  uint16(22302),
		12:  uint16(22304),
		13:  uint16(22305),
		14:  uint16(22306),
		15:  uint16(22308),
		16:  uint16(22309),
		17:  uint16(22310),
		18:  uint16(22311),
		19:  uint16(22315),
		20:  uint16(22321),
		21:  uint16(22322),
		22:  uint16(22324),
		23:  uint16(22325),
		24:  uint16(22326),
		25:  uint16(22327),
		26:  uint16(22328),
		27:  uint16(22332),
		28:  uint16(22333),
		29:  uint16(22335),
		30:  uint16(22337),
		31:  uint16(22339),
		32:  uint16(22340),
		33:  uint16(22341),
		34:  uint16(22342),
		35:  uint16(22344),
		36:  uint16(22345),
		37:  uint16(22347),
		38:  uint16(22354),
		39:  uint16(22355),
		40:  uint16(22356),
		41:  uint16(22357),
		42:  uint16(22358),
		43:  uint16(22360),
		44:  uint16(22361),
		45:  uint16(22370),
		46:  uint16(22371),
		47:  uint16(22373),
		48:  uint16(22375),
		49:  uint16(22380),
		50:  uint16(22382),
		51:  uint16(22384),
		52:  uint16(22385),
		53:  uint16(22386),
		54:  uint16(22388),
		55:  uint16(22389),
		56:  uint16(22392),
		57:  uint16(22393),
		58:  uint16(22394),
		59:  uint16(22397),
		60:  uint16(22398),
		61:  uint16(22399),
		62:  uint16(22400),
		63:  uint16(22401),
		64:  uint16(22407),
		65:  uint16(22408),
		66:  uint16(22409),
		67:  uint16(22410),
		68:  uint16(22413),
		69:  uint16(22414),
		70:  uint16(22415),
		71:  uint16(22416),
		72:  uint16(22417),
		73:  uint16(22420),
		74:  uint16(22421),
		75:  uint16(22422),
		76:  uint16(22423),
		77:  uint16(22424),
		78:  uint16(22425),
		79:  uint16(22426),
		80:  uint16(22428),
		81:  uint16(22429),
		82:  uint16(22430),
		83:  uint16(22431),
		84:  uint16(22437),
		85:  uint16(22440),
		86:  uint16(22442),
		87:  uint16(22444),
		88:  uint16(22447),
		89:  uint16(22448),
		90:  uint16(22449),
		91:  uint16(22451),
		92:  uint16(22453),
		93:  uint16(22454),
		94:  uint16(22455),
		95:  uint16(22457),
		96:  uint16(22458),
		97:  uint16(22459),
		98:  uint16(22460),
		99:  uint16(22461),
		100: uint16(22462),
		101: uint16(22463),
		102: uint16(22464),
		103: uint16(22465),
		104: uint16(22468),
		105: uint16(22469),
		106: uint16(22470),
		107: uint16(22471),
		108: uint16(22472),
		109: uint16(22473),
		110: uint16(22474),
		111: uint16(22476),
		112: uint16(22477),
		113: uint16(22480),
		114: uint16(22481),
		115: uint16(22483),
		116: uint16(22486),
		117: uint16(22487),
		118: uint16(22491),
		119: uint16(22492),
		120: uint16(22494),
		121: uint16(22497),
		122: uint16(22498),
		123: uint16(22499),
		124: uint16(22501),
		125: uint16(22502),
		126: uint16(22503),
		127: uint16(22504),
		128: uint16(22505),
		129: uint16(22506),
		130: uint16(22507),
		131: uint16(22508),
		132: uint16(22510),
		133: uint16(22512),
		134: uint16(22513),
		135: uint16(22514),
		136: uint16(22515),
		137: uint16(22517),
		138: uint16(22518),
		139: uint16(22519),
		140: uint16(22523),
		141: uint16(22524),
		142: uint16(22526),
		143: uint16(22527),
		144: uint16(22529),
		145: uint16(22531),
		146: uint16(22532),
		147: uint16(22533),
		148: uint16(22536),
		149: uint16(22537),
		150: uint16(22538),
		151: uint16(22540),
		152: uint16(22542),
		153: uint16(22543),
		154: uint16(22544),
		155: uint16(22546),
		156: uint16(22547),
		157: uint16(22548),
		158: uint16(22550),
		159: uint16(22551),
		160: uint16(22552),
		161: uint16(22554),
		162: uint16(22555),
		163: uint16(22556),
		164: uint16(22557),
		165: uint16(22559),
		166: uint16(22562),
		167: uint16(22563),
		168: uint16(22565),
		169: uint16(22566),
		170: uint16(22567),
		171: uint16(22568),
		172: uint16(22569),
		173: uint16(22571),
		174: uint16(22572),
		175: uint16(22573),
		176: uint16(22574),
		177: uint16(22575),
		178: uint16(22577),
		179: uint16(22578),
		180: uint16(22579),
		181: uint16(22580),
		182: uint16(22582),
		183: uint16(22583),
		184: uint16(22584),
		185: uint16(22585),
		186: uint16(22586),
		187: uint16(22587),
		188: uint16(22588),
		189: uint16(22589),
	},
	8: {
		0:   uint16(22590),
		1:   uint16(22591),
		2:   uint16(22592),
		3:   uint16(22593),
		4:   uint16(22594),
		5:   uint16(22595),
		6:   uint16(22597),
		7:   uint16(22598),
		8:   uint16(22599),
		9:   uint16(22600),
		10:  uint16(22601),
		11:  uint16(22602),
		12:  uint16(22603),
		13:  uint16(22606),
		14:  uint16(22607),
		15:  uint16(22608),
		16:  uint16(22610),
		17:  uint16(22611),
		18:  uint16(22613),
		19:  uint16(22614),
		20:  uint16(22615),
		21:  uint16(22617),
		22:  uint16(22618),
		23:  uint16(22619),
		24:  uint16(22620),
		25:  uint16(22621),
		26:  uint16(22623),
		27:  uint16(22624),
		28:  uint16(22625),
		29:  uint16(22626),
		30:  uint16(22627),
		31:  uint16(22628),
		32:  uint16(22630),
		33:  uint16(22631),
		34:  uint16(22632),
		35:  uint16(22633),
		36:  uint16(22634),
		37:  uint16(22637),
		38:  uint16(22638),
		39:  uint16(22639),
		40:  uint16(22640),
		41:  uint16(22641),
		42:  uint16(22642),
		43:  uint16(22643),
		44:  uint16(22644),
		45:  uint16(22645),
		46:  uint16(22646),
		47:  uint16(22647),
		48:  uint16(22648),
		49:  uint16(22649),
		50:  uint16(22650),
		51:  uint16(22651),
		52:  uint16(22652),
		53:  uint16(22653),
		54:  uint16(22655),
		55:  uint16(22658),
		56:  uint16(22660),
		57:  uint16(22662),
		58:  uint16(22663),
		59:  uint16(22664),
		60:  uint16(22666),
		61:  uint16(22667),
		62:  uint16(22668),
		63:  uint16(22669),
		64:  uint16(22670),
		65:  uint16(22671),
		66:  uint16(22672),
		67:  uint16(22673),
		68:  uint16(22676),
		69:  uint16(22677),
		70:  uint16(22678),
		71:  uint16(22679),
		72:  uint16(22680),
		73:  uint16(22683),
		74:  uint16(22684),
		75:  uint16(22685),
		76:  uint16(22688),
		77:  uint16(22689),
		78:  uint16(22690),
		79:  uint16(22691),
		80:  uint16(22692),
		81:  uint16(22693),
		82:  uint16(22694),
		83:  uint16(22695),
		84:  uint16(22698),
		85:  uint16(22699),
		86:  uint16(22700),
		87:  uint16(22701),
		88:  uint16(22702),
		89:  uint16(22703),
		90:  uint16(22704),
		91:  uint16(22705),
		92:  uint16(22706),
		93:  uint16(22707),
		94:  uint16(22708),
		95:  uint16(22709),
		96:  uint16(22710),
		97:  uint16(22711),
		98:  uint16(22712),
		99:  uint16(22713),
		100: uint16(22714),
		101: uint16(22715),
		102: uint16(22717),
		103: uint16(22718),
		104: uint16(22719),
		105: uint16(22720),
		106: uint16(22722),
		107: uint16(22723),
		108: uint16(22724),
		109: uint16(22726),
		110: uint16(22727),
		111: uint16(22728),
		112: uint16(22729),
		113: uint16(22730),
		114: uint16(22731),
		115: uint16(22732),
		116: uint16(22733),
		117: uint16(22734),
		118: uint16(22735),
		119: uint16(22736),
		120: uint16(22738),
		121: uint16(22739),
		122: uint16(22740),
		123: uint16(22742),
		124: uint16(22743),
		125: uint16(22744),
		126: uint16(22745),
		127: uint16(22746),
		128: uint16(22747),
		129: uint16(22748),
		130: uint16(22749),
		131: uint16(22750),
		132: uint16(22751),
		133: uint16(22752),
		134: uint16(22753),
		135: uint16(22754),
		136: uint16(22755),
		137: uint16(22757),
		138: uint16(22758),
		139: uint16(22759),
		140: uint16(22760),
		141: uint16(22761),
		142: uint16(22762),
		143: uint16(22765),
		144: uint16(22767),
		145: uint16(22769),
		146: uint16(22770),
		147: uint16(22772),
		148: uint16(22773),
		149: uint16(22775),
		150: uint16(22776),
		151: uint16(22778),
		152: uint16(22779),
		153: uint16(22780),
		154: uint16(22781),
		155: uint16(22782),
		156: uint16(22783),
		157: uint16(22784),
		158: uint16(22785),
		159: uint16(22787),
		160: uint16(22789),
		161: uint16(22790),
		162: uint16(22792),
		163: uint16(22793),
		164: uint16(22794),
		165: uint16(22795),
		166: uint16(22796),
		167: uint16(22798),
		168: uint16(22800),
		169: uint16(22801),
		170: uint16(22802),
		171: uint16(22803),
		172: uint16(22807),
		173: uint16(22808),
		174: uint16(22811),
		175: uint16(22813),
		176: uint16(22814),
		177: uint16(22816),
		178: uint16(22817),
		179: uint16(22818),
		180: uint16(22819),
		181: uint16(22822),
		182: uint16(22824),
		183: uint16(22828),
		184: uint16(22832),
		185: uint16(22834),
		186: uint16(22835),
		187: uint16(22837),
		188: uint16(22838),
		189: uint16(22843),
	},
	9: {
		0:   uint16(22845),
		1:   uint16(22846),
		2:   uint16(22847),
		3:   uint16(22848),
		4:   uint16(22851),
		5:   uint16(22853),
		6:   uint16(22854),
		7:   uint16(22858),
		8:   uint16(22860),
		9:   uint16(22861),
		10:  uint16(22864),
		11:  uint16(22866),
		12:  uint16(22867),
		13:  uint16(22873),
		14:  uint16(22875),
		15:  uint16(22876),
		16:  uint16(22877),
		17:  uint16(22878),
		18:  uint16(22879),
		19:  uint16(22881),
		20:  uint16(22883),
		21:  uint16(22884),
		22:  uint16(22886),
		23:  uint16(22887),
		24:  uint16(22888),
		25:  uint16(22889),
		26:  uint16(22890),
		27:  uint16(22891),
		28:  uint16(22892),
		29:  uint16(22893),
		30:  uint16(22894),
		31:  uint16(22895),
		32:  uint16(22896),
		33:  uint16(22897),
		34:  uint16(22898),
		35:  uint16(22901),
		36:  uint16(22903),
		37:  uint16(22906),
		38:  uint16(22907),
		39:  uint16(22908),
		40:  uint16(22910),
		41:  uint16(22911),
		42:  uint16(22912),
		43:  uint16(22917),
		44:  uint16(22921),
		45:  uint16(22923),
		46:  uint16(22924),
		47:  uint16(22926),
		48:  uint16(22927),
		49:  uint16(22928),
		50:  uint16(22929),
		51:  uint16(22932),
		52:  uint16(22933),
		53:  uint16(22936),
		54:  uint16(22938),
		55:  uint16(22939),
		56:  uint16(22940),
		57:  uint16(22941),
		58:  uint16(22943),
		59:  uint16(22944),
		60:  uint16(22945),
		61:  uint16(22946),
		62:  uint16(22950),
		63:  uint16(22951),
		64:  uint16(22956),
		65:  uint16(22957),
		66:  uint16(22960),
		67:  uint16(22961),
		68:  uint16(22963),
		69:  uint16(22964),
		70:  uint16(22965),
		71:  uint16(22966),
		72:  uint16(22967),
		73:  uint16(22968),
		74:  uint16(22970),
		75:  uint16(22972),
		76:  uint16(22973),
		77:  uint16(22975),
		78:  uint16(22976),
		79:  uint16(22977),
		80:  uint16(22978),
		81:  uint16(22979),
		82:  uint16(22980),
		83:  uint16(22981),
		84:  uint16(22983),
		85:  uint16(22984),
		86:  uint16(22985),
		87:  uint16(22988),
		88:  uint16(22989),
		89:  uint16(22990),
		90:  uint16(22991),
		91:  uint16(22997),
		92:  uint16(22998),
		93:  uint16(23001),
		94:  uint16(23003),
		95:  uint16(23006),
		96:  uint16(23007),
		97:  uint16(23008),
		98:  uint16(23009),
		99:  uint16(23010),
		100: uint16(23012),
		101: uint16(23014),
		102: uint16(23015),
		103: uint16(23017),
		104: uint16(23018),
		105: uint16(23019),
		106: uint16(23021),
		107: uint16(23022),
		108: uint16(23023),
		109: uint16(23024),
		110: uint16(23025),
		111: uint16(23026),
		112: uint16(23027),
		113: uint16(23028),
		114: uint16(23029),
		115: uint16(23030),
		116: uint16(23031),
		117: uint16(23032),
		118: uint16(23034),
		119: uint16(23036),
		120: uint16(23037),
		121: uint16(23038),
		122: uint16(23040),
		123: uint16(23042),
		124: uint16(23050),
		125: uint16(23051),
		126: uint16(23053),
		127: uint16(23054),
		128: uint16(23055),
		129: uint16(23056),
		130: uint16(23058),
		131: uint16(23060),
		132: uint16(23061),
		133: uint16(23062),
		134: uint16(23063),
		135: uint16(23065),
		136: uint16(23066),
		137: uint16(23067),
		138: uint16(23069),
		139: uint16(23070),
		140: uint16(23073),
		141: uint16(23074),
		142: uint16(23076),
		143: uint16(23078),
		144: uint16(23079),
		145: uint16(23080),
		146: uint16(23082),
		147: uint16(23083),
		148: uint16(23084),
		149: uint16(23085),
		150: uint16(23086),
		151: uint16(23087),
		152: uint16(23088),
		153: uint16(23091),
		154: uint16(23093),
		155: uint16(23095),
		156: uint16(23096),
		157: uint16(23097),
		158: uint16(23098),
		159: uint16(23099),
		160: uint16(23101),
		161: uint16(23102),
		162: uint16(23103),
		163: uint16(23105),
		164: uint16(23106),
		165: uint16(23107),
		166: uint16(23108),
		167: uint16(23109),
		168: uint16(23111),
		169: uint16(23112),
		170: uint16(23115),
		171: uint16(23116),
		172: uint16(23117),
		173: uint16(23118),
		174: uint16(23119),
		175: uint16(23120),
		176: uint16(23121),
		177: uint16(23122),
		178: uint16(23123),
		179: uint16(23124),
		180: uint16(23126),
		181: uint16(23127),
		182: uint16(23128),
		183: uint16(23129),
		184: uint16(23131),
		185: uint16(23132),
		186: uint16(23133),
		187: uint16(23134),
		188: uint16(23135),
		189: uint16(23136),
	},
	10: {
		0:   uint16(23137),
		1:   uint16(23139),
		2:   uint16(23140),
		3:   uint16(23141),
		4:   uint16(23142),
		5:   uint16(23144),
		6:   uint16(23145),
		7:   uint16(23147),
		8:   uint16(23148),
		9:   uint16(23149),
		10:  uint16(23150),
		11:  uint16(23151),
		12:  uint16(23152),
		13:  uint16(23153),
		14:  uint16(23154),
		15:  uint16(23155),
		16:  uint16(23160),
		17:  uint16(23161),
		18:  uint16(23163),
		19:  uint16(23164),
		20:  uint16(23165),
		21:  uint16(23166),
		22:  uint16(23168),
		23:  uint16(23169),
		24:  uint16(23170),
		25:  uint16(23171),
		26:  uint16(23172),
		27:  uint16(23173),
		28:  uint16(23174),
		29:  uint16(23175),
		30:  uint16(23176),
		31:  uint16(23177),
		32:  uint16(23178),
		33:  uint16(23179),
		34:  uint16(23180),
		35:  uint16(23181),
		36:  uint16(23182),
		37:  uint16(23183),
		38:  uint16(23184),
		39:  uint16(23185),
		40:  uint16(23187),
		41:  uint16(23188),
		42:  uint16(23189),
		43:  uint16(23190),
		44:  uint16(23191),
		45:  uint16(23192),
		46:  uint16(23193),
		47:  uint16(23196),
		48:  uint16(23197),
		49:  uint16(23198),
		50:  uint16(23199),
		51:  uint16(23200),
		52:  uint16(23201),
		53:  uint16(23202),
		54:  uint16(23203),
		55:  uint16(23204),
		56:  uint16(23205),
		57:  uint16(23206),
		58:  uint16(23207),
		59:  uint16(23208),
		60:  uint16(23209),
		61:  uint16(23211),
		62:  uint16(23212),
		63:  uint16(23213),
		64:  uint16(23214),
		65:  uint16(23215),
		66:  uint16(23216),
		67:  uint16(23217),
		68:  uint16(23220),
		69:  uint16(23222),
		70:  uint16(23223),
		71:  uint16(23225),
		72:  uint16(23226),
		73:  uint16(23227),
		74:  uint16(23228),
		75:  uint16(23229),
		76:  uint16(23231),
		77:  uint16(23232),
		78:  uint16(23235),
		79:  uint16(23236),
		80:  uint16(23237),
		81:  uint16(23238),
		82:  uint16(23239),
		83:  uint16(23240),
		84:  uint16(23242),
		85:  uint16(23243),
		86:  uint16(23245),
		87:  uint16(23246),
		88:  uint16(23247),
		89:  uint16(23248),
		90:  uint16(23249),
		91:  uint16(23251),
		92:  uint16(23253),
		93:  uint16(23255),
		94:  uint16(23257),
		95:  uint16(23258),
		96:  uint16(23259),
		97:  uint16(23261),
		98:  uint16(23262),
		99:  uint16(23263),
		100: uint16(23266),
		101: uint16(23268),
		102: uint16(23269),
		103: uint16(23271),
		104: uint16(23272),
		105: uint16(23274),
		106: uint16(23276),
		107: uint16(23277),
		108: uint16(23278),
		109: uint16(23279),
		110: uint16(23280),
		111: uint16(23282),
		112: uint16(23283),
		113: uint16(23284),
		114: uint16(23285),
		115: uint16(23286),
		116: uint16(23287),
		117: uint16(23288),
		118: uint16(23289),
		119: uint16(23290),
		120: uint16(23291),
		121: uint16(23292),
		122: uint16(23293),
		123: uint16(23294),
		124: uint16(23295),
		125: uint16(23296),
		126: uint16(23297),
		127: uint16(23298),
		128: uint16(23299),
		129: uint16(23300),
		130: uint16(23301),
		131: uint16(23302),
		132: uint16(23303),
		133: uint16(23304),
		134: uint16(23306),
		135: uint16(23307),
		136: uint16(23308),
		137: uint16(23309),
		138: uint16(23310),
		139: uint16(23311),
		140: uint16(23312),
		141: uint16(23313),
		142: uint16(23314),
		143: uint16(23315),
		144: uint16(23316),
		145: uint16(23317),
		146: uint16(23320),
		147: uint16(23321),
		148: uint16(23322),
		149: uint16(23323),
		150: uint16(23324),
		151: uint16(23325),
		152: uint16(23326),
		153: uint16(23327),
		154: uint16(23328),
		155: uint16(23329),
		156: uint16(23330),
		157: uint16(23331),
		158: uint16(23332),
		159: uint16(23333),
		160: uint16(23334),
		161: uint16(23335),
		162: uint16(23336),
		163: uint16(23337),
		164: uint16(23338),
		165: uint16(23339),
		166: uint16(23340),
		167: uint16(23341),
		168: uint16(23342),
		169: uint16(23343),
		170: uint16(23344),
		171: uint16(23345),
		172: uint16(23347),
		173: uint16(23349),
		174: uint16(23350),
		175: uint16(23352),
		176: uint16(23353),
		177: uint16(23354),
		178: uint16(23355),
		179: uint16(23356),
		180: uint16(23357),
		181: uint16(23358),
		182: uint16(23359),
		183: uint16(23361),
		184: uint16(23362),
		185: uint16(23363),
		186: uint16(23364),
		187: uint16(23365),
		188: uint16(23366),
		189: uint16(23367),
	},
	11: {
		0:   uint16(23368),
		1:   uint16(23369),
		2:   uint16(23370),
		3:   uint16(23371),
		4:   uint16(23372),
		5:   uint16(23373),
		6:   uint16(23374),
		7:   uint16(23375),
		8:   uint16(23378),
		9:   uint16(23382),
		10:  uint16(23390),
		11:  uint16(23392),
		12:  uint16(23393),
		13:  uint16(23399),
		14:  uint16(23400),
		15:  uint16(23403),
		16:  uint16(23405),
		17:  uint16(23406),
		18:  uint16(23407),
		19:  uint16(23410),
		20:  uint16(23412),
		21:  uint16(23414),
		22:  uint16(23415),
		23:  uint16(23416),
		24:  uint16(23417),
		25:  uint16(23419),
		26:  uint16(23420),
		27:  uint16(23422),
		28:  uint16(23423),
		29:  uint16(23426),
		30:  uint16(23430),
		31:  uint16(23434),
		32:  uint16(23437),
		33:  uint16(23438),
		34:  uint16(23440),
		35:  uint16(23441),
		36:  uint16(23442),
		37:  uint16(23444),
		38:  uint16(23446),
		39:  uint16(23455),
		40:  uint16(23463),
		41:  uint16(23464),
		42:  uint16(23465),
		43:  uint16(23468),
		44:  uint16(23469),
		45:  uint16(23470),
		46:  uint16(23471),
		47:  uint16(23473),
		48:  uint16(23474),
		49:  uint16(23479),
		50:  uint16(23482),
		51:  uint16(23483),
		52:  uint16(23484),
		53:  uint16(23488),
		54:  uint16(23489),
		55:  uint16(23491),
		56:  uint16(23496),
		57:  uint16(23497),
		58:  uint16(23498),
		59:  uint16(23499),
		60:  uint16(23501),
		61:  uint16(23502),
		62:  uint16(23503),
		63:  uint16(23505),
		64:  uint16(23508),
		65:  uint16(23509),
		66:  uint16(23510),
		67:  uint16(23511),
		68:  uint16(23512),
		69:  uint16(23513),
		70:  uint16(23514),
		71:  uint16(23515),
		72:  uint16(23516),
		73:  uint16(23520),
		74:  uint16(23522),
		75:  uint16(23523),
		76:  uint16(23526),
		77:  uint16(23527),
		78:  uint16(23529),
		79:  uint16(23530),
		80:  uint16(23531),
		81:  uint16(23532),
		82:  uint16(23533),
		83:  uint16(23535),
		84:  uint16(23537),
		85:  uint16(23538),
		86:  uint16(23539),
		87:  uint16(23540),
		88:  uint16(23541),
		89:  uint16(23542),
		90:  uint16(23543),
		91:  uint16(23549),
		92:  uint16(23550),
		93:  uint16(23552),
		94:  uint16(23554),
		95:  uint16(23555),
		96:  uint16(23557),
		97:  uint16(23559),
		98:  uint16(23560),
		99:  uint16(23563),
		100: uint16(23564),
		101: uint16(23565),
		102: uint16(23566),
		103: uint16(23568),
		104: uint16(23570),
		105: uint16(23571),
		106: uint16(23575),
		107: uint16(23577),
		108: uint16(23579),
		109: uint16(23582),
		110: uint16(23583),
		111: uint16(23584),
		112: uint16(23585),
		113: uint16(23587),
		114: uint16(23590),
		115: uint16(23592),
		116: uint16(23593),
		117: uint16(23594),
		118: uint16(23595),
		119: uint16(23597),
		120: uint16(23598),
		121: uint16(23599),
		122: uint16(23600),
		123: uint16(23602),
		124: uint16(23603),
		125: uint16(23605),
		126: uint16(23606),
		127: uint16(23607),
		128: uint16(23619),
		129: uint16(23620),
		130: uint16(23622),
		131: uint16(23623),
		132: uint16(23628),
		133: uint16(23629),
		134: uint16(23634),
		135: uint16(23635),
		136: uint16(23636),
		137: uint16(23638),
		138: uint16(23639),
		139: uint16(23640),
		140: uint16(23642),
		141: uint16(23643),
		142: uint16(23644),
		143: uint16(23645),
		144: uint16(23647),
		145: uint16(23650),
		146: uint16(23652),
		147: uint16(23655),
		148: uint16(23656),
		149: uint16(23657),
		150: uint16(23658),
		151: uint16(23659),
		152: uint16(23660),
		153: uint16(23661),
		154: uint16(23664),
		155: uint16(23666),
		156: uint16(23667),
		157: uint16(23668),
		158: uint16(23669),
		159: uint16(23670),
		160: uint16(23671),
		161: uint16(23672),
		162: uint16(23675),
		163: uint16(23676),
		164: uint16(23677),
		165: uint16(23678),
		166: uint16(23680),
		167: uint16(23683),
		168: uint16(23684),
		169: uint16(23685),
		170: uint16(23686),
		171: uint16(23687),
		172: uint16(23689),
		173: uint16(23690),
		174: uint16(23691),
		175: uint16(23694),
		176: uint16(23695),
		177: uint16(23698),
		178: uint16(23699),
		179: uint16(23701),
		180: uint16(23709),
		181: uint16(23710),
		182: uint16(23711),
		183: uint16(23712),
		184: uint16(23713),
		185: uint16(23716),
		186: uint16(23717),
		187: uint16(23718),
		188: uint16(23719),
		189: uint16(23720),
	},
	12: {
		0:   uint16(23722),
		1:   uint16(23726),
		2:   uint16(23727),
		3:   uint16(23728),
		4:   uint16(23730),
		5:   uint16(23732),
		6:   uint16(23734),
		7:   uint16(23737),
		8:   uint16(23738),
		9:   uint16(23739),
		10:  uint16(23740),
		11:  uint16(23742),
		12:  uint16(23744),
		13:  uint16(23746),
		14:  uint16(23747),
		15:  uint16(23749),
		16:  uint16(23750),
		17:  uint16(23751),
		18:  uint16(23752),
		19:  uint16(23753),
		20:  uint16(23754),
		21:  uint16(23756),
		22:  uint16(23757),
		23:  uint16(23758),
		24:  uint16(23759),
		25:  uint16(23760),
		26:  uint16(23761),
		27:  uint16(23763),
		28:  uint16(23764),
		29:  uint16(23765),
		30:  uint16(23766),
		31:  uint16(23767),
		32:  uint16(23768),
		33:  uint16(23770),
		34:  uint16(23771),
		35:  uint16(23772),
		36:  uint16(23773),
		37:  uint16(23774),
		38:  uint16(23775),
		39:  uint16(23776),
		40:  uint16(23778),
		41:  uint16(23779),
		42:  uint16(23783),
		43:  uint16(23785),
		44:  uint16(23787),
		45:  uint16(23788),
		46:  uint16(23790),
		47:  uint16(23791),
		48:  uint16(23793),
		49:  uint16(23794),
		50:  uint16(23795),
		51:  uint16(23796),
		52:  uint16(23797),
		53:  uint16(23798),
		54:  uint16(23799),
		55:  uint16(23800),
		56:  uint16(23801),
		57:  uint16(23802),
		58:  uint16(23804),
		59:  uint16(23805),
		60:  uint16(23806),
		61:  uint16(23807),
		62:  uint16(23808),
		63:  uint16(23809),
		64:  uint16(23812),
		65:  uint16(23813),
		66:  uint16(23816),
		67:  uint16(23817),
		68:  uint16(23818),
		69:  uint16(23819),
		70:  uint16(23820),
		71:  uint16(23821),
		72:  uint16(23823),
		73:  uint16(23824),
		74:  uint16(23825),
		75:  uint16(23826),
		76:  uint16(23827),
		77:  uint16(23829),
		78:  uint16(23831),
		79:  uint16(23832),
		80:  uint16(23833),
		81:  uint16(23834),
		82:  uint16(23836),
		83:  uint16(23837),
		84:  uint16(23839),
		85:  uint16(23840),
		86:  uint16(23841),
		87:  uint16(23842),
		88:  uint16(23843),
		89:  uint16(23845),
		90:  uint16(23848),
		91:  uint16(23850),
		92:  uint16(23851),
		93:  uint16(23852),
		94:  uint16(23855),
		95:  uint16(23856),
		96:  uint16(23857),
		97:  uint16(23858),
		98:  uint16(23859),
		99:  uint16(23861),
		100: uint16(23862),
		101: uint16(23863),
		102: uint16(23864),
		103: uint16(23865),
		104: uint16(23866),
		105: uint16(23867),
		106: uint16(23868),
		107: uint16(23871),
		108: uint16(23872),
		109: uint16(23873),
		110: uint16(23874),
		111: uint16(23875),
		112: uint16(23876),
		113: uint16(23877),
		114: uint16(23878),
		115: uint16(23880),
		116: uint16(23881),
		117: uint16(23885),
		118: uint16(23886),
		119: uint16(23887),
		120: uint16(23888),
		121: uint16(23889),
		122: uint16(23890),
		123: uint16(23891),
		124: uint16(23892),
		125: uint16(23893),
		126: uint16(23894),
		127: uint16(23895),
		128: uint16(23897),
		129: uint16(23898),
		130: uint16(23900),
		131: uint16(23902),
		132: uint16(23903),
		133: uint16(23904),
		134: uint16(23905),
		135: uint16(23906),
		136: uint16(23907),
		137: uint16(23908),
		138: uint16(23909),
		139: uint16(23910),
		140: uint16(23911),
		141: uint16(23912),
		142: uint16(23914),
		143: uint16(23917),
		144: uint16(23918),
		145: uint16(23920),
		146: uint16(23921),
		147: uint16(23922),
		148: uint16(23923),
		149: uint16(23925),
		150: uint16(23926),
		151: uint16(23927),
		152: uint16(23928),
		153: uint16(23929),
		154: uint16(23930),
		155: uint16(23931),
		156: uint16(23932),
		157: uint16(23933),
		158: uint16(23934),
		159: uint16(23935),
		160: uint16(23936),
		161: uint16(23937),
		162: uint16(23939),
		163: uint16(23940),
		164: uint16(23941),
		165: uint16(23942),
		166: uint16(23943),
		167: uint16(23944),
		168: uint16(23945),
		169: uint16(23946),
		170: uint16(23947),
		171: uint16(23948),
		172: uint16(23949),
		173: uint16(23950),
		174: uint16(23951),
		175: uint16(23952),
		176: uint16(23953),
		177: uint16(23954),
		178: uint16(23955),
		179: uint16(23956),
		180: uint16(23957),
		181: uint16(23958),
		182: uint16(23959),
		183: uint16(23960),
		184: uint16(23962),
		185: uint16(23963),
		186: uint16(23964),
		187: uint16(23966),
		188: uint16(23967),
		189: uint16(23968),
	},
	13: {
		0:   uint16(23969),
		1:   uint16(23970),
		2:   uint16(23971),
		3:   uint16(23972),
		4:   uint16(23973),
		5:   uint16(23974),
		6:   uint16(23975),
		7:   uint16(23976),
		8:   uint16(23977),
		9:   uint16(23978),
		10:  uint16(23979),
		11:  uint16(23980),
		12:  uint16(23981),
		13:  uint16(23982),
		14:  uint16(23983),
		15:  uint16(23984),
		16:  uint16(23985),
		17:  uint16(23986),
		18:  uint16(23987),
		19:  uint16(23988),
		20:  uint16(23989),
		21:  uint16(23990),
		22:  uint16(23992),
		23:  uint16(23993),
		24:  uint16(23994),
		25:  uint16(23995),
		26:  uint16(23996),
		27:  uint16(23997),
		28:  uint16(23998),
		29:  uint16(23999),
		30:  uint16(24000),
		31:  uint16(24001),
		32:  uint16(24002),
		33:  uint16(24003),
		34:  uint16(24004),
		35:  uint16(24006),
		36:  uint16(24007),
		37:  uint16(24008),
		38:  uint16(24009),
		39:  uint16(24010),
		40:  uint16(24011),
		41:  uint16(24012),
		42:  uint16(24014),
		43:  uint16(24015),
		44:  uint16(24016),
		45:  uint16(24017),
		46:  uint16(24018),
		47:  uint16(24019),
		48:  uint16(24020),
		49:  uint16(24021),
		50:  uint16(24022),
		51:  uint16(24023),
		52:  uint16(24024),
		53:  uint16(24025),
		54:  uint16(24026),
		55:  uint16(24028),
		56:  uint16(24031),
		57:  uint16(24032),
		58:  uint16(24035),
		59:  uint16(24036),
		60:  uint16(24042),
		61:  uint16(24044),
		62:  uint16(24045),
		63:  uint16(24048),
		64:  uint16(24053),
		65:  uint16(24054),
		66:  uint16(24056),
		67:  uint16(24057),
		68:  uint16(24058),
		69:  uint16(24059),
		70:  uint16(24060),
		71:  uint16(24063),
		72:  uint16(24064),
		73:  uint16(24068),
		74:  uint16(24071),
		75:  uint16(24073),
		76:  uint16(24074),
		77:  uint16(24075),
		78:  uint16(24077),
		79:  uint16(24078),
		80:  uint16(24082),
		81:  uint16(24083),
		82:  uint16(24087),
		83:  uint16(24094),
		84:  uint16(24095),
		85:  uint16(24096),
		86:  uint16(24097),
		87:  uint16(24098),
		88:  uint16(24099),
		89:  uint16(24100),
		90:  uint16(24101),
		91:  uint16(24104),
		92:  uint16(24105),
		93:  uint16(24106),
		94:  uint16(24107),
		95:  uint16(24108),
		96:  uint16(24111),
		97:  uint16(24112),
		98:  uint16(24114),
		99:  uint16(24115),
		100: uint16(24116),
		101: uint16(24117),
		102: uint16(24118),
		103: uint16(24121),
		104: uint16(24122),
		105: uint16(24126),
		106: uint16(24127),
		107: uint16(24128),
		108: uint16(24129),
		109: uint16(24131),
		110: uint16(24134),
		111: uint16(24135),
		112: uint16(24136),
		113: uint16(24137),
		114: uint16(24138),
		115: uint16(24139),
		116: uint16(24141),
		117: uint16(24142),
		118: uint16(24143),
		119: uint16(24144),
		120: uint16(24145),
		121: uint16(24146),
		122: uint16(24147),
		123: uint16(24150),
		124: uint16(24151),
		125: uint16(24152),
		126: uint16(24153),
		127: uint16(24154),
		128: uint16(24156),
		129: uint16(24157),
		130: uint16(24159),
		131: uint16(24160),
		132: uint16(24163),
		133: uint16(24164),
		134: uint16(24165),
		135: uint16(24166),
		136: uint16(24167),
		137: uint16(24168),
		138: uint16(24169),
		139: uint16(24170),
		140: uint16(24171),
		141: uint16(24172),
		142: uint16(24173),
		143: uint16(24174),
		144: uint16(24175),
		145: uint16(24176),
		146: uint16(24177),
		147: uint16(24181),
		148: uint16(24183),
		149: uint16(24185),
		150: uint16(24190),
		151: uint16(24193),
		152: uint16(24194),
		153: uint16(24195),
		154: uint16(24197),
		155: uint16(24200),
		156: uint16(24201),
		157: uint16(24204),
		158: uint16(24205),
		159: uint16(24206),
		160: uint16(24210),
		161: uint16(24216),
		162: uint16(24219),
		163: uint16(24221),
		164: uint16(24225),
		165: uint16(24226),
		166: uint16(24227),
		167: uint16(24228),
		168: uint16(24232),
		169: uint16(24233),
		170: uint16(24234),
		171: uint16(24235),
		172: uint16(24236),
		173: uint16(24238),
		174: uint16(24239),
		175: uint16(24240),
		176: uint16(24241),
		177: uint16(24242),
		178: uint16(24244),
		179: uint16(24250),
		180: uint16(24251),
		181: uint16(24252),
		182: uint16(24253),
		183: uint16(24255),
		184: uint16(24256),
		185: uint16(24257),
		186: uint16(24258),
		187: uint16(24259),
		188: uint16(24260),
		189: uint16(24261),
	},
	14: {
		0:   uint16(24262),
		1:   uint16(24263),
		2:   uint16(24264),
		3:   uint16(24267),
		4:   uint16(24268),
		5:   uint16(24269),
		6:   uint16(24270),
		7:   uint16(24271),
		8:   uint16(24272),
		9:   uint16(24276),
		10:  uint16(24277),
		11:  uint16(24279),
		12:  uint16(24280),
		13:  uint16(24281),
		14:  uint16(24282),
		15:  uint16(24284),
		16:  uint16(24285),
		17:  uint16(24286),
		18:  uint16(24287),
		19:  uint16(24288),
		20:  uint16(24289),
		21:  uint16(24290),
		22:  uint16(24291),
		23:  uint16(24292),
		24:  uint16(24293),
		25:  uint16(24294),
		26:  uint16(24295),
		27:  uint16(24297),
		28:  uint16(24299),
		29:  uint16(24300),
		30:  uint16(24301),
		31:  uint16(24302),
		32:  uint16(24303),
		33:  uint16(24304),
		34:  uint16(24305),
		35:  uint16(24306),
		36:  uint16(24307),
		37:  uint16(24309),
		38:  uint16(24312),
		39:  uint16(24313),
		40:  uint16(24315),
		41:  uint16(24316),
		42:  uint16(24317),
		43:  uint16(24325),
		44:  uint16(24326),
		45:  uint16(24327),
		46:  uint16(24329),
		47:  uint16(24332),
		48:  uint16(24333),
		49:  uint16(24334),
		50:  uint16(24336),
		51:  uint16(24338),
		52:  uint16(24340),
		53:  uint16(24342),
		54:  uint16(24345),
		55:  uint16(24346),
		56:  uint16(24348),
		57:  uint16(24349),
		58:  uint16(24350),
		59:  uint16(24353),
		60:  uint16(24354),
		61:  uint16(24355),
		62:  uint16(24356),
		63:  uint16(24360),
		64:  uint16(24363),
		65:  uint16(24364),
		66:  uint16(24366),
		67:  uint16(24368),
		68:  uint16(24370),
		69:  uint16(24371),
		70:  uint16(24372),
		71:  uint16(24373),
		72:  uint16(24374),
		73:  uint16(24375),
		74:  uint16(24376),
		75:  uint16(24379),
		76:  uint16(24381),
		77:  uint16(24382),
		78:  uint16(24383),
		79:  uint16(24385),
		80:  uint16(24386),
		81:  uint16(24387),
		82:  uint16(24388),
		83:  uint16(24389),
		84:  uint16(24390),
		85:  uint16(24391),
		86:  uint16(24392),
		87:  uint16(24393),
		88:  uint16(24394),
		89:  uint16(24395),
		90:  uint16(24396),
		91:  uint16(24397),
		92:  uint16(24398),
		93:  uint16(24399),
		94:  uint16(24401),
		95:  uint16(24404),
		96:  uint16(24409),
		97:  uint16(24410),
		98:  uint16(24411),
		99:  uint16(24412),
		100: uint16(24414),
		101: uint16(24415),
		102: uint16(24416),
		103: uint16(24419),
		104: uint16(24421),
		105: uint16(24423),
		106: uint16(24424),
		107: uint16(24427),
		108: uint16(24430),
		109: uint16(24431),
		110: uint16(24434),
		111: uint16(24436),
		112: uint16(24437),
		113: uint16(24438),
		114: uint16(24440),
		115: uint16(24442),
		116: uint16(24445),
		117: uint16(24446),
		118: uint16(24447),
		119: uint16(24451),
		120: uint16(24454),
		121: uint16(24461),
		122: uint16(24462),
		123: uint16(24463),
		124: uint16(24465),
		125: uint16(24467),
		126: uint16(24468),
		127: uint16(24470),
		128: uint16(24474),
		129: uint16(24475),
		130: uint16(24477),
		131: uint16(24478),
		132: uint16(24479),
		133: uint16(24480),
		134: uint16(24482),
		135: uint16(24483),
		136: uint16(24484),
		137: uint16(24485),
		138: uint16(24486),
		139: uint16(24487),
		140: uint16(24489),
		141: uint16(24491),
		142: uint16(24492),
		143: uint16(24495),
		144: uint16(24496),
		145: uint16(24497),
		146: uint16(24498),
		147: uint16(24499),
		148: uint16(24500),
		149: uint16(24502),
		150: uint16(24504),
		151: uint16(24505),
		152: uint16(24506),
		153: uint16(24507),
		154: uint16(24510),
		155: uint16(24511),
		156: uint16(24512),
		157: uint16(24513),
		158: uint16(24514),
		159: uint16(24519),
		160: uint16(24520),
		161: uint16(24522),
		162: uint16(24523),
		163: uint16(24526),
		164: uint16(24531),
		165: uint16(24532),
		166: uint16(24533),
		167: uint16(24538),
		168: uint16(24539),
		169: uint16(24540),
		170: uint16(24542),
		171: uint16(24543),
		172: uint16(24546),
		173: uint16(24547),
		174: uint16(24549),
		175: uint16(24550),
		176: uint16(24552),
		177: uint16(24553),
		178: uint16(24556),
		179: uint16(24559),
		180: uint16(24560),
		181: uint16(24562),
		182: uint16(24563),
		183: uint16(24564),
		184: uint16(24566),
		185: uint16(24567),
		186: uint16(24569),
		187: uint16(24570),
		188: uint16(24572),
		189: uint16(24583),
	},
	15: {
		0:   uint16(24584),
		1:   uint16(24585),
		2:   uint16(24587),
		3:   uint16(24588),
		4:   uint16(24592),
		5:   uint16(24593),
		6:   uint16(24595),
		7:   uint16(24599),
		8:   uint16(24600),
		9:   uint16(24602),
		10:  uint16(24606),
		11:  uint16(24607),
		12:  uint16(24610),
		13:  uint16(24611),
		14:  uint16(24612),
		15:  uint16(24620),
		16:  uint16(24621),
		17:  uint16(24622),
		18:  uint16(24624),
		19:  uint16(24625),
		20:  uint16(24626),
		21:  uint16(24627),
		22:  uint16(24628),
		23:  uint16(24630),
		24:  uint16(24631),
		25:  uint16(24632),
		26:  uint16(24633),
		27:  uint16(24634),
		28:  uint16(24637),
		29:  uint16(24638),
		30:  uint16(24640),
		31:  uint16(24644),
		32:  uint16(24645),
		33:  uint16(24646),
		34:  uint16(24647),
		35:  uint16(24648),
		36:  uint16(24649),
		37:  uint16(24650),
		38:  uint16(24652),
		39:  uint16(24654),
		40:  uint16(24655),
		41:  uint16(24657),
		42:  uint16(24659),
		43:  uint16(24660),
		44:  uint16(24662),
		45:  uint16(24663),
		46:  uint16(24664),
		47:  uint16(24667),
		48:  uint16(24668),
		49:  uint16(24670),
		50:  uint16(24671),
		51:  uint16(24672),
		52:  uint16(24673),
		53:  uint16(24677),
		54:  uint16(24678),
		55:  uint16(24686),
		56:  uint16(24689),
		57:  uint16(24690),
		58:  uint16(24692),
		59:  uint16(24693),
		60:  uint16(24695),
		61:  uint16(24702),
		62:  uint16(24704),
		63:  uint16(24705),
		64:  uint16(24706),
		65:  uint16(24709),
		66:  uint16(24710),
		67:  uint16(24711),
		68:  uint16(24712),
		69:  uint16(24714),
		70:  uint16(24715),
		71:  uint16(24718),
		72:  uint16(24719),
		73:  uint16(24720),
		74:  uint16(24721),
		75:  uint16(24723),
		76:  uint16(24725),
		77:  uint16(24727),
		78:  uint16(24728),
		79:  uint16(24729),
		80:  uint16(24732),
		81:  uint16(24734),
		82:  uint16(24737),
		83:  uint16(24738),
		84:  uint16(24740),
		85:  uint16(24741),
		86:  uint16(24743),
		87:  uint16(24745),
		88:  uint16(24746),
		89:  uint16(24750),
		90:  uint16(24752),
		91:  uint16(24755),
		92:  uint16(24757),
		93:  uint16(24758),
		94:  uint16(24759),
		95:  uint16(24761),
		96:  uint16(24762),
		97:  uint16(24765),
		98:  uint16(24766),
		99:  uint16(24767),
		100: uint16(24768),
		101: uint16(24769),
		102: uint16(24770),
		103: uint16(24771),
		104: uint16(24772),
		105: uint16(24775),
		106: uint16(24776),
		107: uint16(24777),
		108: uint16(24780),
		109: uint16(24781),
		110: uint16(24782),
		111: uint16(24783),
		112: uint16(24784),
		113: uint16(24786),
		114: uint16(24787),
		115: uint16(24788),
		116: uint16(24790),
		117: uint16(24791),
		118: uint16(24793),
		119: uint16(24795),
		120: uint16(24798),
		121: uint16(24801),
		122: uint16(24802),
		123: uint16(24803),
		124: uint16(24804),
		125: uint16(24805),
		126: uint16(24810),
		127: uint16(24817),
		128: uint16(24818),
		129: uint16(24821),
		130: uint16(24823),
		131: uint16(24824),
		132: uint16(24827),
		133: uint16(24828),
		134: uint16(24829),
		135: uint16(24830),
		136: uint16(24831),
		137: uint16(24834),
		138: uint16(24835),
		139: uint16(24836),
		140: uint16(24837),
		141: uint16(24839),
		142: uint16(24842),
		143: uint16(24843),
		144: uint16(24844),
		145: uint16(24848),
		146: uint16(24849),
		147: uint16(24850),
		148: uint16(24851),
		149: uint16(24852),
		150: uint16(24854),
		151: uint16(24855),
		152: uint16(24856),
		153: uint16(24857),
		154: uint16(24859),
		155: uint16(24860),
		156: uint16(24861),
		157: uint16(24862),
		158: uint16(24865),
		159: uint16(24866),
		160: uint16(24869),
		161: uint16(24872),
		162: uint16(24873),
		163: uint16(24874),
		164: uint16(24876),
		165: uint16(24877),
		166: uint16(24878),
		167: uint16(24879),
		168: uint16(24880),
		169: uint16(24881),
		170: uint16(24882),
		171: uint16(24883),
		172: uint16(24884),
		173: uint16(24885),
		174: uint16(24886),
		175: uint16(24887),
		176: uint16(24888),
		177: uint16(24889),
		178: uint16(24890),
		179: uint16(24891),
		180: uint16(24892),
		181: uint16(24893),
		182: uint16(24894),
		183: uint16(24896),
		184: uint16(24897),
		185: uint16(24898),
		186: uint16(24899),
		187: uint16(24900),
		188: uint16(24901),
		189: uint16(24902),
	},
	16: {
		0:   uint16(24903),
		1:   uint16(24905),
		2:   uint16(24907),
		3:   uint16(24909),
		4:   uint16(24911),
		5:   uint16(24912),
		6:   uint16(24914),
		7:   uint16(24915),
		8:   uint16(24916),
		9:   uint16(24918),
		10:  uint16(24919),
		11:  uint16(24920),
		12:  uint16(24921),
		13:  uint16(24922),
		14:  uint16(24923),
		15:  uint16(24924),
		16:  uint16(24926),
		17:  uint16(24927),
		18:  uint16(24928),
		19:  uint16(24929),
		20:  uint16(24931),
		21:  uint16(24932),
		22:  uint16(24933),
		23:  uint16(24934),
		24:  uint16(24937),
		25:  uint16(24938),
		26:  uint16(24939),
		27:  uint16(24940),
		28:  uint16(24941),
		29:  uint16(24942),
		30:  uint16(24943),
		31:  uint16(24945),
		32:  uint16(24946),
		33:  uint16(24947),
		34:  uint16(24948),
		35:  uint16(24950),
		36:  uint16(24952),
		37:  uint16(24953),
		38:  uint16(24954),
		39:  uint16(24955),
		40:  uint16(24956),
		41:  uint16(24957),
		42:  uint16(24958),
		43:  uint16(24959),
		44:  uint16(24960),
		45:  uint16(24961),
		46:  uint16(24962),
		47:  uint16(24963),
		48:  uint16(24964),
		49:  uint16(24965),
		50:  uint16(24966),
		51:  uint16(24967),
		52:  uint16(24968),
		53:  uint16(24969),
		54:  uint16(24970),
		55:  uint16(24972),
		56:  uint16(24973),
		57:  uint16(24975),
		58:  uint16(24976),
		59:  uint16(24977),
		60:  uint16(24978),
		61:  uint16(24979),
		62:  uint16(24981),
		63:  uint16(24982),
		64:  uint16(24983),
		65:  uint16(24984),
		66:  uint16(24985),
		67:  uint16(24986),
		68:  uint16(24987),
		69:  uint16(24988),
		70:  uint16(24990),
		71:  uint16(24991),
		72:  uint16(24992),
		73:  uint16(24993),
		74:  uint16(24994),
		75:  uint16(24995),
		76:  uint16(24996),
		77:  uint16(24997),
		78:  uint16(24998),
		79:  uint16(25002),
		80:  uint16(25003),
		81:  uint16(25005),
		82:  uint16(25006),
		83:  uint16(25007),
		84:  uint16(25008),
		85:  uint16(25009),
		86:  uint16(25010),
		87:  uint16(25011),
		88:  uint16(25012),
		89:  uint16(25013),
		90:  uint16(25014),
		91:  uint16(25016),
		92:  uint16(25017),
		93:  uint16(25018),
		94:  uint16(25019),
		95:  uint16(25020),
		96:  uint16(25021),
		97:  uint16(25023),
		98:  uint16(25024),
		99:  uint16(25025),
		100: uint16(25027),
		101: uint16(25028),
		102: uint16(25029),
		103: uint16(25030),
		104: uint16(25031),
		105: uint16(25033),
		106: uint16(25036),
		107: uint16(25037),
		108: uint16(25038),
		109: uint16(25039),
		110: uint16(25040),
		111: uint16(25043),
		112: uint16(25045),
		113: uint16(25046),
		114: uint16(25047),
		115: uint16(25048),
		116: uint16(25049),
		117: uint16(25050),
		118: uint16(25051),
		119: uint16(25052),
		120: uint16(25053),
		121: uint16(25054),
		122: uint16(25055),
		123: uint16(25056),
		124: uint16(25057),
		125: uint16(25058),
		126: uint16(25059),
		127: uint16(25060),
		128: uint16(25061),
		129: uint16(25063),
		130: uint16(25064),
		131: uint16(25065),
		132: uint16(25066),
		133: uint16(25067),
		134: uint16(25068),
		135: uint16(25069),
		136: uint16(25070),
		137: uint16(25071),
		138: uint16(25072),
		139: uint16(25073),
		140: uint16(25074),
		141: uint16(25075),
		142: uint16(25076),
		143: uint16(25078),
		144: uint16(25079),
		145: uint16(25080),
		146: uint16(25081),
		147: uint16(25082),
		148: uint16(25083),
		149: uint16(25084),
		150: uint16(25085),
		151: uint16(25086),
		152: uint16(25088),
		153: uint16(25089),
		154: uint16(25090),
		155: uint16(25091),
		156: uint16(25092),
		157: uint16(25093),
		158: uint16(25095),
		159: uint16(25097),
		160: uint16(25107),
		161: uint16(25108),
		162: uint16(25113),
		163: uint16(25116),
		164: uint16(25117),
		165: uint16(25118),
		166: uint16(25120),
		167: uint16(25123),
		168: uint16(25126),
		169: uint16(25127),
		170: uint16(25128),
		171: uint16(25129),
		172: uint16(25131),
		173: uint16(25133),
		174: uint16(25135),
		175: uint16(25136),
		176: uint16(25137),
		177: uint16(25138),
		178: uint16(25141),
		179: uint16(25142),
		180: uint16(25144),
		181: uint16(25145),
		182: uint16(25146),
		183: uint16(25147),
		184: uint16(25148),
		185: uint16(25154),
		186: uint16(25156),
		187: uint16(25157),
		188: uint16(25158),
		189: uint16(25162),
	},
	17: {
		0:   uint16(25167),
		1:   uint16(25168),
		2:   uint16(25173),
		3:   uint16(25174),
		4:   uint16(25175),
		5:   uint16(25177),
		6:   uint16(25178),
		7:   uint16(25180),
		8:   uint16(25181),
		9:   uint16(25182),
		10:  uint16(25183),
		11:  uint16(25184),
		12:  uint16(25185),
		13:  uint16(25186),
		14:  uint16(25188),
		15:  uint16(25189),
		16:  uint16(25192),
		17:  uint16(25201),
		18:  uint16(25202),
		19:  uint16(25204),
		20:  uint16(25205),
		21:  uint16(25207),
		22:  uint16(25208),
		23:  uint16(25210),
		24:  uint16(25211),
		25:  uint16(25213),
		26:  uint16(25217),
		27:  uint16(25218),
		28:  uint16(25219),
		29:  uint16(25221),
		30:  uint16(25222),
		31:  uint16(25223),
		32:  uint16(25224),
		33:  uint16(25227),
		34:  uint16(25228),
		35:  uint16(25229),
		36:  uint16(25230),
		37:  uint16(25231),
		38:  uint16(25232),
		39:  uint16(25236),
		40:  uint16(25241),
		41:  uint16(25244),
		42:  uint16(25245),
		43:  uint16(25246),
		44:  uint16(25251),
		45:  uint16(25254),
		46:  uint16(25255),
		47:  uint16(25257),
		48:  uint16(25258),
		49:  uint16(25261),
		50:  uint16(25262),
		51:  uint16(25263),
		52:  uint16(25264),
		53:  uint16(25266),
		54:  uint16(25267),
		55:  uint16(25268),
		56:  uint16(25270),
		57:  uint16(25271),
		58:  uint16(25272),
		59:  uint16(25274),
		60:  uint16(25278),
		61:  uint16(25280),
		62:  uint16(25281),
		63:  uint16(25283),
		64:  uint16(25291),
		65:  uint16(25295),
		66:  uint16(25297),
		67:  uint16(25301),
		68:  uint16(25309),
		69:  uint16(25310),
		70:  uint16(25312),
		71:  uint16(25313),
		72:  uint16(25316),
		73:  uint16(25322),
		74:  uint16(25323),
		75:  uint16(25328),
		76:  uint16(25330),
		77:  uint16(25333),
		78:  uint16(25336),
		79:  uint16(25337),
		80:  uint16(25338),
		81:  uint16(25339),
		82:  uint16(25344),
		83:  uint16(25347),
		84:  uint16(25348),
		85:  uint16(25349),
		86:  uint16(25350),
		87:  uint16(25354),
		88:  uint16(25355),
		89:  uint16(25356),
		90:  uint16(25357),
		91:  uint16(25359),
		92:  uint16(25360),
		93:  uint16(25362),
		94:  uint16(25363),
		95:  uint16(25364),
		96:  uint16(25365),
		97:  uint16(25367),
		98:  uint16(25368),
		99:  uint16(25369),
		100: uint16(25372),
		101: uint16(25382),
		102: uint16(25383),
		103: uint16(25385),
		104: uint16(25388),
		105: uint16(25389),
		106: uint16(25390),
		107: uint16(25392),
		108: uint16(25393),
		109: uint16(25395),
		110: uint16(25396),
		111: uint16(25397),
		112: uint16(25398),
		113: uint16(25399),
		114: uint16(25400),
		115: uint16(25403),
		116: uint16(25404),
		117: uint16(25406),
		118: uint16(25407),
		119: uint16(25408),
		120: uint16(25409),
		121: uint16(25412),
		122: uint16(25415),
		123: uint16(25416),
		124: uint16(25418),
		125: uint16(25425),
		126: uint16(25426),
		127: uint16(25427),
		128: uint16(25428),
		129: uint16(25430),
		130: uint16(25431),
		131: uint16(25432),
		132: uint16(25433),
		133: uint16(25434),
		134: uint16(25435),
		135: uint16(25436),
		136: uint16(25437),
		137: uint16(25440),
		138: uint16(25444),
		139: uint16(25445),
		140: uint16(25446),
		141: uint16(25448),
		142: uint16(25450),
		143: uint16(25451),
		144: uint16(25452),
		145: uint16(25455),
		146: uint16(25456),
		147: uint16(25458),
		148: uint16(25459),
		149: uint16(25460),
		150: uint16(25461),
		151: uint16(25464),
		152: uint16(25465),
		153: uint16(25468),
		154: uint16(25469),
		155: uint16(25470),
		156: uint16(25471),
		157: uint16(25473),
		158: uint16(25475),
		159: uint16(25476),
		160: uint16(25477),
		161: uint16(25478),
		162: uint16(25483),
		163: uint16(25485),
		164: uint16(25489),
		165: uint16(25491),
		166: uint16(25492),
		167: uint16(25493),
		168: uint16(25495),
		169: uint16(25497),
		170: uint16(25498),
		171: uint16(25499),
		172: uint16(25500),
		173: uint16(25501),
		174: uint16(25502),
		175: uint16(25503),
		176: uint16(25505),
		177: uint16(25508),
		178: uint16(25510),
		179: uint16(25515),
		180: uint16(25519),
		181: uint16(25521),
		182: uint16(25522),
		183: uint16(25525),
		184: uint16(25526),
		185: uint16(25529),
		186: uint16(25531),
		187: uint16(25533),
		188: uint16(25535),
		189: uint16(25536),
	},
	18: {
		0:   uint16(25537),
		1:   uint16(25538),
		2:   uint16(25539),
		3:   uint16(25541),
		4:   uint16(25543),
		5:   uint16(25544),
		6:   uint16(25546),
		7:   uint16(25547),
		8:   uint16(25548),
		9:   uint16(25553),
		10:  uint16(25555),
		11:  uint16(25556),
		12:  uint16(25557),
		13:  uint16(25559),
		14:  uint16(25560),
		15:  uint16(25561),
		16:  uint16(25562),
		17:  uint16(25563),
		18:  uint16(25564),
		19:  uint16(25565),
		20:  uint16(25567),
		21:  uint16(25570),
		22:  uint16(25572),
		23:  uint16(25573),
		24:  uint16(25574),
		25:  uint16(25575),
		26:  uint16(25576),
		27:  uint16(25579),
		28:  uint16(25580),
		29:  uint16(25582),
		30:  uint16(25583),
		31:  uint16(25584),
		32:  uint16(25585),
		33:  uint16(25587),
		34:  uint16(25589),
		35:  uint16(25591),
		36:  uint16(25593),
		37:  uint16(25594),
		38:  uint16(25595),
		39:  uint16(25596),
		40:  uint16(25598),
		41:  uint16(25603),
		42:  uint16(25604),
		43:  uint16(25606),
		44:  uint16(25607),
		45:  uint16(25608),
		46:  uint16(25609),
		47:  uint16(25610),
		48:  uint16(25613),
		49:  uint16(25614),
		50:  uint16(25617),
		51:  uint16(25618),
		52:  uint16(25621),
		53:  uint16(25622),
		54:  uint16(25623),
		55:  uint16(25624),
		56:  uint16(25625),
		57:  uint16(25626),
		58:  uint16(25629),
		59:  uint16(25631),
		60:  uint16(25634),
		61:  uint16(25635),
		62:  uint16(25636),
		63:  uint16(25637),
		64:  uint16(25639),
		65:  uint16(25640),
		66:  uint16(25641),
		67:  uint16(25643),
		68:  uint16(25646),
		69:  uint16(25647),
		70:  uint16(25648),
		71:  uint16(25649),
		72:  uint16(25650),
		73:  uint16(25651),
		74:  uint16(25653),
		75:  uint16(25654),
		76:  uint16(25655),
		77:  uint16(25656),
		78:  uint16(25657),
		79:  uint16(25659),
		80:  uint16(25660),
		81:  uint16(25662),
		82:  uint16(25664),
		83:  uint16(25666),
		84:  uint16(25667),
		85:  uint16(25673),
		86:  uint16(25675),
		87:  uint16(25676),
		88:  uint16(25677),
		89:  uint16(25678),
		90:  uint16(25679),
		91:  uint16(25680),
		92:  uint16(25681),
		93:  uint16(25683),
		94:  uint16(25685),
		95:  uint16(25686),
		96:  uint16(25687),
		97:  uint16(25689),
		98:  uint16(25690),
		99:  uint16(25691),
		100: uint16(25692),
		101: uint16(25693),
		102: uint16(25695),
		103: uint16(25696),
		104: uint16(25697),
		105: uint16(25698),
		106: uint16(25699),
		107: uint16(25700),
		108: uint16(25701),
		109: uint16(25702),
		110: uint16(25704),
		111: uint16(25706),
		112: uint16(25707),
		113: uint16(25708),
		114: uint16(25710),
		115: uint16(25711),
		116: uint16(25712),
		117: uint16(25713),
		118: uint16(25714),
		119: uint16(25715),
		120: uint16(25716),
		121: uint16(25717),
		122: uint16(25718),
		123: uint16(25719),
		124: uint16(25723),
		125: uint16(25724),
		126: uint16(25725),
		127: uint16(25726),
		128: uint16(25727),
		129: uint16(25728),
		130: uint16(25729),
		131: uint16(25731),
		132: uint16(25734),
		133: uint16(25736),
		134: uint16(25737),
		135: uint16(25738),
		136: uint16(25739),
		137: uint16(25740),
		138: uint16(25741),
		139: uint16(25742),
		140: uint16(25743),
		141: uint16(25744),
		142: uint16(25747),
		143: uint16(25748),
		144: uint16(25751),
		145: uint16(25752),
		146: uint16(25754),
		147: uint16(25755),
		148: uint16(25756),
		149: uint16(25757),
		150: uint16(25759),
		151: uint16(25760),
		152: uint16(25761),
		153: uint16(25762),
		154: uint16(25763),
		155: uint16(25765),
		156: uint16(25766),
		157: uint16(25767),
		158: uint16(25768),
		159: uint16(25770),
		160: uint16(25771),
		161: uint16(25775),
		162: uint16(25777),
		163: uint16(25778),
		164: uint16(25779),
		165: uint16(25780),
		166: uint16(25782),
		167: uint16(25785),
		168: uint16(25787),
		169: uint16(25789),
		170: uint16(25790),
		171: uint16(25791),
		172: uint16(25793),
		173: uint16(25795),
		174: uint16(25796),
		175: uint16(25798),
		176: uint16(25799),
		177: uint16(25800),
		178: uint16(25801),
		179: uint16(25802),
		180: uint16(25803),
		181: uint16(25804),
		182: uint16(25807),
		183: uint16(25809),
		184: uint16(25811),
		185: uint16(25812),
		186: uint16(25813),
		187: uint16(25814),
		188: uint16(25817),
		189: uint16(25818),
	},
	19: {
		0:   uint16(25819),
		1:   uint16(25820),
		2:   uint16(25821),
		3:   uint16(25823),
		4:   uint16(25824),
		5:   uint16(25825),
		6:   uint16(25827),
		7:   uint16(25829),
		8:   uint16(25831),
		9:   uint16(25832),
		10:  uint16(25833),
		11:  uint16(25834),
		12:  uint16(25835),
		13:  uint16(25836),
		14:  uint16(25837),
		15:  uint16(25838),
		16:  uint16(25839),
		17:  uint16(25840),
		18:  uint16(25841),
		19:  uint16(25842),
		20:  uint16(25843),
		21:  uint16(25844),
		22:  uint16(25845),
		23:  uint16(25846),
		24:  uint16(25847),
		25:  uint16(25848),
		26:  uint16(25849),
		27:  uint16(25850),
		28:  uint16(25851),
		29:  uint16(25852),
		30:  uint16(25853),
		31:  uint16(25854),
		32:  uint16(25855),
		33:  uint16(25857),
		34:  uint16(25858),
		35:  uint16(25859),
		36:  uint16(25860),
		37:  uint16(25861),
		38:  uint16(25862),
		39:  uint16(25863),
		40:  uint16(25864),
		41:  uint16(25866),
		42:  uint16(25867),
		43:  uint16(25868),
		44:  uint16(25869),
		45:  uint16(25870),
		46:  uint16(25871),
		47:  uint16(25872),
		48:  uint16(25873),
		49:  uint16(25875),
		50:  uint16(25876),
		51:  uint16(25877),
		52:  uint16(25878),
		53:  uint16(25879),
		54:  uint16(25881),
		55:  uint16(25882),
		56:  uint16(25883),
		57:  uint16(25884),
		58:  uint16(25885),
		59:  uint16(25886),
		60:  uint16(25887),
		61:  uint16(25888),
		62:  uint16(25889),
		63:  uint16(25890),
		64:  uint16(25891),
		65:  uint16(25892),
		66:  uint16(25894),
		67:  uint16(25895),
		68:  uint16(25896),
		69:  uint16(25897),
		70:  uint16(25898),
		71:  uint16(25900),
		72:  uint16(25901),
		73:  uint16(25904),
		74:  uint16(25905),
		75:  uint16(25906),
		76:  uint16(25907),
		77:  uint16(25911),
		78:  uint16(25914),
		79:  uint16(25916),
		80:  uint16(25917),
		81:  uint16(25920),
		82:  uint16(25921),
		83:  uint16(25922),
		84:  uint16(25923),
		85:  uint16(25924),
		86:  uint16(25926),
		87:  uint16(25927),
		88:  uint16(25930),
		89:  uint16(25931),
		90:  uint16(25933),
		91:  uint16(25934),
		92:  uint16(25936),
		93:  uint16(25938),
		94:  uint16(25939),
		95:  uint16(25940),
		96:  uint16(25943),
		97:  uint16(25944),
		98:  uint16(25946),
		99:  uint16(25948),
		100: uint16(25951),
		101: uint16(25952),
		102: uint16(25953),
		103: uint16(25956),
		104: uint16(25957),
		105: uint16(25959),
		106: uint16(25960),
		107: uint16(25961),
		108: uint16(25962),
		109: uint16(25965),
		110: uint16(25966),
		111: uint16(25967),
		112: uint16(25969),
		113: uint16(25971),
		114: uint16(25973),
		115: uint16(25974),
		116: uint16(25976),
		117: uint16(25977),
		118: uint16(25978),
		119: uint16(25979),
		120: uint16(25980),
		121: uint16(25981),
		122: uint16(25982),
		123: uint16(25983),
		124: uint16(25984),
		125: uint16(25985),
		126: uint16(25986),
		127: uint16(25987),
		128: uint16(25988),
		129: uint16(25989),
		130: uint16(25990),
		131: uint16(25992),
		132: uint16(25993),
		133: uint16(25994),
		134: uint16(25997),
		135: uint16(25998),
		136: uint16(25999),
		137: uint16(26002),
		138: uint16(26004),
		139: uint16(26005),
		140: uint16(26006),
		141: uint16(26008),
		142: uint16(26010),
		143: uint16(26013),
		144: uint16(26014),
		145: uint16(26016),
		146: uint16(26018),
		147: uint16(26019),
		148: uint16(26022),
		149: uint16(26024),
		150: uint16(26026),
		151: uint16(26028),
		152: uint16(26030),
		153: uint16(26033),
		154: uint16(26034),
		155: uint16(26035),
		156: uint16(26036),
		157: uint16(26037),
		158: uint16(26038),
		159: uint16(26039),
		160: uint16(26040),
		161: uint16(26042),
		162: uint16(26043),
		163: uint16(26046),
		164: uint16(26047),
		165: uint16(26048),
		166: uint16(26050),
		167: uint16(26055),
		168: uint16(26056),
		169: uint16(26057),
		170: uint16(26058),
		171: uint16(26061),
		172: uint16(26064),
		173: uint16(26065),
		174: uint16(26067),
		175: uint16(26068),
		176: uint16(26069),
		177: uint16(26072),
		178: uint16(26073),
		179: uint16(26074),
		180: uint16(26075),
		181: uint16(26076),
		182: uint16(26077),
		183: uint16(26078),
		184: uint16(26079),
		185: uint16(26081),
		186: uint16(26083),
		187: uint16(26084),
		188: uint16(26090),
		189: uint16(26091),
	},
	20: {
		0:   uint16(26098),
		1:   uint16(26099),
		2:   uint16(26100),
		3:   uint16(26101),
		4:   uint16(26104),
		5:   uint16(26105),
		6:   uint16(26107),
		7:   uint16(26108),
		8:   uint16(26109),
		9:   uint16(26110),
		10:  uint16(26111),
		11:  uint16(26113),
		12:  uint16(26116),
		13:  uint16(26117),
		14:  uint16(26119),
		15:  uint16(26120),
		16:  uint16(26121),
		17:  uint16(26123),
		18:  uint16(26125),
		19:  uint16(26128),
		20:  uint16(26129),
		21:  uint16(26130),
		22:  uint16(26134),
		23:  uint16(26135),
		24:  uint16(26136),
		25:  uint16(26138),
		26:  uint16(26139),
		27:  uint16(26140),
		28:  uint16(26142),
		29:  uint16(26145),
		30:  uint16(26146),
		31:  uint16(26147),
		32:  uint16(26148),
		33:  uint16(26150),
		34:  uint16(26153),
		35:  uint16(26154),
		36:  uint16(26155),
		37:  uint16(26156),
		38:  uint16(26158),
		39:  uint16(26160),
		40:  uint16(26162),
		41:  uint16(26163),
		42:  uint16(26167),
		43:  uint16(26168),
		44:  uint16(26169),
		45:  uint16(26170),
		46:  uint16(26171),
		47:  uint16(26173),
		48:  uint16(26175),
		49:  uint16(26176),
		50:  uint16(26178),
		51:  uint16(26180),
		52:  uint16(26181),
		53:  uint16(26182),
		54:  uint16(26183),
		55:  uint16(26184),
		56:  uint16(26185),
		57:  uint16(26186),
		58:  uint16(26189),
		59:  uint16(26190),
		60:  uint16(26192),
		61:  uint16(26193),
		62:  uint16(26200),
		63:  uint16(26201),
		64:  uint16(26203),
		65:  uint16(26204),
		66:  uint16(26205),
		67:  uint16(26206),
		68:  uint16(26208),
		69:  uint16(26210),
		70:  uint16(26211),
		71:  uint16(26213),
		72:  uint16(26215),
		73:  uint16(26217),
		74:  uint16(26218),
		75:  uint16(26219),
		76:  uint16(26220),
		77:  uint16(26221),
		78:  uint16(26225),
		79:  uint16(26226),
		80:  uint16(26227),
		81:  uint16(26229),
		82:  uint16(26232),
		83:  uint16(26233),
		84:  uint16(26235),
		85:  uint16(26236),
		86:  uint16(26237),
		87:  uint16(26239),
		88:  uint16(26240),
		89:  uint16(26241),
		90:  uint16(26243),
		91:  uint16(26245),
		92:  uint16(26246),
		93:  uint16(26248),
		94:  uint16(26249),
		95:  uint16(26250),
		96:  uint16(26251),
		97:  uint16(26253),
		98:  uint16(26254),
		99:  uint16(26255),
		100: uint16(26256),
		101: uint16(26258),
		102: uint16(26259),
		103: uint16(26260),
		104: uint16(26261),
		105: uint16(26264),
		106: uint16(26265),
		107: uint16(26266),
		108: uint16(26267),
		109: uint16(26268),
		110: uint16(26270),
		111: uint16(26271),
		112: uint16(26272),
		113: uint16(26273),
		114: uint16(26274),
		115: uint16(26275),
		116: uint16(26276),
		117: uint16(26277),
		118: uint16(26278),
		119: uint16(26281),
		120: uint16(26282),
		121: uint16(26283),
		122: uint16(26284),
		123: uint16(26285),
		124: uint16(26287),
		125: uint16(26288),
		126: uint16(26289),
		127: uint16(26290),
		128: uint16(26291),
		129: uint16(26293),
		130: uint16(26294),
		131: uint16(26295),
		132: uint16(26296),
		133: uint16(26298),
		134: uint16(26299),
		135: uint16(26300),
		136: uint16(26301),
		137: uint16(26303),
		138: uint16(26304),
		139: uint16(26305),
		140: uint16(26306),
		141: uint16(26307),
		142: uint16(26308),
		143: uint16(26309),
		144: uint16(26310),
		145: uint16(26311),
		146: uint16(26312),
		147: uint16(26313),
		148: uint16(26314),
		149: uint16(26315),
		150: uint16(26316),
		151: uint16(26317),
		152: uint16(26318),
		153: uint16(26319),
		154: uint16(26320),
		155: uint16(26321),
		156: uint16(26322),
		157: uint16(26323),
		158: uint16(26324),
		159: uint16(26325),
		160: uint16(26326),
		161: uint16(26327),
		162: uint16(26328),
		163: uint16(26330),
		164: uint16(26334),
		165: uint16(26335),
		166: uint16(26336),
		167: uint16(26337),
		168: uint16(26338),
		169: uint16(26339),
		170: uint16(26340),
		171: uint16(26341),
		172: uint16(26343),
		173: uint16(26344),
		174: uint16(26346),
		175: uint16(26347),
		176: uint16(26348),
		177: uint16(26349),
		178: uint16(26350),
		179: uint16(26351),
		180: uint16(26353),
		181: uint16(26357),
		182: uint16(26358),
		183: uint16(26360),
		184: uint16(26362),
		185: uint16(26363),
		186: uint16(26365),
		187: uint16(26369),
		188: uint16(26370),
		189: uint16(26371),
	},
	21: {
		0:   uint16(26372),
		1:   uint16(26373),
		2:   uint16(26374),
		3:   uint16(26375),
		4:   uint16(26380),
		5:   uint16(26382),
		6:   uint16(26383),
		7:   uint16(26385),
		8:   uint16(26386),
		9:   uint16(26387),
		10:  uint16(26390),
		11:  uint16(26392),
		12:  uint16(26393),
		13:  uint16(26394),
		14:  uint16(26396),
		15:  uint16(26398),
		16:  uint16(26400),
		17:  uint16(26401),
		18:  uint16(26402),
		19:  uint16(26403),
		20:  uint16(26404),
		21:  uint16(26405),
		22:  uint16(26407),
		23:  uint16(26409),
		24:  uint16(26414),
		25:  uint16(26416),
		26:  uint16(26418),
		27:  uint16(26419),
		28:  uint16(26422),
		29:  uint16(26423),
		30:  uint16(26424),
		31:  uint16(26425),
		32:  uint16(26427),
		33:  uint16(26428),
		34:  uint16(26430),
		35:  uint16(26431),
		36:  uint16(26433),
		37:  uint16(26436),
		38:  uint16(26437),
		39:  uint16(26439),
		40:  uint16(26442),
		41:  uint16(26443),
		42:  uint16(26445),
		43:  uint16(26450),
		44:  uint16(26452),
		45:  uint16(26453),
		46:  uint16(26455),
		47:  uint16(26456),
		48:  uint16(26457),
		49:  uint16(26458),
		50:  uint16(26459),
		51:  uint16(26461),
		52:  uint16(26466),
		53:  uint16(26467),
		54:  uint16(26468),
		55:  uint16(26470),
		56:  uint16(26471),
		57:  uint16(26475),
		58:  uint16(26476),
		59:  uint16(26478),
		60:  uint16(26481),
		61:  uint16(26484),
		62:  uint16(26486),
		63:  uint16(26488),
		64:  uint16(26489),
		65:  uint16(26490),
		66:  uint16(26491),
		67:  uint16(26493),
		68:  uint16(26496),
		69:  uint16(26498),
		70:  uint16(26499),
		71:  uint16(26501),
		72:  uint16(26502),
		73:  uint16(26504),
		74:  uint16(26506),
		75:  uint16(26508),
		76:  uint16(26509),
		77:  uint16(26510),
		78:  uint16(26511),
		79:  uint16(26513),
		80:  uint16(26514),
		81:  uint16(26515),
		82:  uint16(26516),
		83:  uint16(26518),
		84:  uint16(26521),
		85:  uint16(26523),
		86:  uint16(26527),
		87:  uint16(26528),
		88:  uint16(26529),
		89:  uint16(26532),
		90:  uint16(26534),
		91:  uint16(26537),
		92:  uint16(26540),
		93:  uint16(26542),
		94:  uint16(26545),
		95:  uint16(26546),
		96:  uint16(26548),
		97:  uint16(26553),
		98:  uint16(26554),
		99:  uint16(26555),
		100: uint16(26556),
		101: uint16(26557),
		102: uint16(26558),
		103: uint16(26559),
		104: uint16(26560),
		105: uint16(26562),
		106: uint16(26565),
		107: uint16(26566),
		108: uint16(26567),
		109: uint16(26568),
		110: uint16(26569),
		111: uint16(26570),
		112: uint16(26571),
		113: uint16(26572),
		114: uint16(26573),
		115: uint16(26574),
		116: uint16(26581),
		117: uint16(26582),
		118: uint16(26583),
		119: uint16(26587),
		120: uint16(26591),
		121: uint16(26593),
		122: uint16(26595),
		123: uint16(26596),
		124: uint16(26598),
		125: uint16(26599),
		126: uint16(26600),
		127: uint16(26602),
		128: uint16(26603),
		129: uint16(26605),
		130: uint16(26606),
		131: uint16(26610),
		132: uint16(26613),
		133: uint16(26614),
		134: uint16(26615),
		135: uint16(26616),
		136: uint16(26617),
		137: uint16(26618),
		138: uint16(26619),
		139: uint16(26620),
		140: uint16(26622),
		141: uint16(26625),
		142: uint16(26626),
		143: uint16(26627),
		144: uint16(26628),
		145: uint16(26630),
		146: uint16(26637),
		147: uint16(26640),
		148: uint16(26642),
		149: uint16(26644),
		150: uint16(26645),
		151: uint16(26648),
		152: uint16(26649),
		153: uint16(26650),
		154: uint16(26651),
		155: uint16(26652),
		156: uint16(26654),
		157: uint16(26655),
		158: uint16(26656),
		159: uint16(26658),
		160: uint16(26659),
		161: uint16(26660),
		162: uint16(26661),
		163: uint16(26662),
		164: uint16(26663),
		165: uint16(26664),
		166: uint16(26667),
		167: uint16(26668),
		168: uint16(26669),
		169: uint16(26670),
		170: uint16(26671),
		171: uint16(26672),
		172: uint16(26673),
		173: uint16(26676),
		174: uint16(26677),
		175: uint16(26678),
		176: uint16(26682),
		177: uint16(26683),
		178: uint16(26687),
		179: uint16(26695),
		180: uint16(26699),
		181: uint16(26701),
		182: uint16(26703),
		183: uint16(26706),
		184: uint16(26710),
		185: uint16(26711),
		186: uint16(26712),
		187: uint16(26713),
		188: uint16(26714),
		189: uint16(26715),
	},
	22: {
		0:   uint16(26716),
		1:   uint16(26717),
		2:   uint16(26718),
		3:   uint16(26719),
		4:   uint16(26730),
		5:   uint16(26732),
		6:   uint16(26733),
		7:   uint16(26734),
		8:   uint16(26735),
		9:   uint16(26736),
		10:  uint16(26737),
		11:  uint16(26738),
		12:  uint16(26739),
		13:  uint16(26741),
		14:  uint16(26744),
		15:  uint16(26745),
		16:  uint16(26746),
		17:  uint16(26747),
		18:  uint16(26748),
		19:  uint16(26749),
		20:  uint16(26750),
		21:  uint16(26751),
		22:  uint16(26752),
		23:  uint16(26754),
		24:  uint16(26756),
		25:  uint16(26759),
		26:  uint16(26760),
		27:  uint16(26761),
		28:  uint16(26762),
		29:  uint16(26763),
		30:  uint16(26764),
		31:  uint16(26765),
		32:  uint16(26766),
		33:  uint16(26768),
		34:  uint16(26769),
		35:  uint16(26770),
		36:  uint16(26772),
		37:  uint16(26773),
		38:  uint16(26774),
		39:  uint16(26776),
		40:  uint16(26777),
		41:  uint16(26778),
		42:  uint16(26779),
		43:  uint16(26780),
		44:  uint16(26781),
		45:  uint16(26782),
		46:  uint16(26783),
		47:  uint16(26784),
		48:  uint16(26785),
		49:  uint16(26787),
		50:  uint16(26788),
		51:  uint16(26789),
		52:  uint16(26793),
		53:  uint16(26794),
		54:  uint16(26795),
		55:  uint16(26796),
		56:  uint16(26798),
		57:  uint16(26801),
		58:  uint16(26802),
		59:  uint16(26804),
		60:  uint16(26806),
		61:  uint16(26807),
		62:  uint16(26808),
		63:  uint16(26809),
		64:  uint16(26810),
		65:  uint16(26811),
		66:  uint16(26812),
		67:  uint16(26813),
		68:  uint16(26814),
		69:  uint16(26815),
		70:  uint16(26817),
		71:  uint16(26819),
		72:  uint16(26820),
		73:  uint16(26821),
		74:  uint16(26822),
		75:  uint16(26823),
		76:  uint16(26824),
		77:  uint16(26826),
		78:  uint16(26828),
		79:  uint16(26830),
		80:  uint16(26831),
		81:  uint16(26832),
		82:  uint16(26833),
		83:  uint16(26835),
		84:  uint16(26836),
		85:  uint16(26838),
		86:  uint16(26839),
		87:  uint16(26841),
		88:  uint16(26843),
		89:  uint16(26844),
		90:  uint16(26845),
		91:  uint16(26846),
		92:  uint16(26847),
		93:  uint16(26849),
		94:  uint16(26850),
		95:  uint16(26852),
		96:  uint16(26853),
		97:  uint16(26854),
		98:  uint16(26855),
		99:  uint16(26856),
		100: uint16(26857),
		101: uint16(26858),
		102: uint16(26859),
		103: uint16(26860),
		104: uint16(26861),
		105: uint16(26863),
		106: uint16(26866),
		107: uint16(26867),
		108: uint16(26868),
		109: uint16(26870),
		110: uint16(26871),
		111: uint16(26872),
		112: uint16(26875),
		113: uint16(26877),
		114: uint16(26878),
		115: uint16(26879),
		116: uint16(26880),
		117: uint16(26882),
		118: uint16(26883),
		119: uint16(26884),
		120: uint16(26886),
		121: uint16(26887),
		122: uint16(26888),
		123: uint16(26889),
		124: uint16(26890),
		125: uint16(26892),
		126: uint16(26895),
		127: uint16(26897),
		128: uint16(26899),
		129: uint16(26900),
		130: uint16(26901),
		131: uint16(26902),
		132: uint16(26903),
		133: uint16(26904),
		134: uint16(26905),
		135: uint16(26906),
		136: uint16(26907),
		137: uint16(26908),
		138: uint16(26909),
		139: uint16(26910),
		140: uint16(26913),
		141: uint16(26914),
		142: uint16(26915),
		143: uint16(26917),
		144: uint16(26918),
		145: uint16(26919),
		146: uint16(26920),
		147: uint16(26921),
		148: uint16(26922),
		149: uint16(26923),
		150: uint16(26924),
		151: uint16(26926),
		152: uint16(26927),
		153: uint16(26929),
		154: uint16(26930),
		155: uint16(26931),
		156: uint16(26933),
		157: uint16(26934),
		158: uint16(26935),
		159: uint16(26936),
		160: uint16(26938),
		161: uint16(26939),
		162: uint16(26940),
		163: uint16(26942),
		164: uint16(26944),
		165: uint16(26945),
		166: uint16(26947),
		167: uint16(26948),
		168: uint16(26949),
		169: uint16(26950),
		170: uint16(26951),
		171: uint16(26952),
		172: uint16(26953),
		173: uint16(26954),
		174: uint16(26955),
		175: uint16(26956),
		176: uint16(26957),
		177: uint16(26958),
		178: uint16(26959),
		179: uint16(26960),
		180: uint16(26961),
		181: uint16(26962),
		182: uint16(26963),
		183: uint16(26965),
		184: uint16(26966),
		185: uint16(26968),
		186: uint16(26969),
		187: uint16(26971),
		188: uint16(26972),
		189: uint16(26975),
	},
	23: {
		0:   uint16(26977),
		1:   uint16(26978),
		2:   uint16(26980),
		3:   uint16(26981),
		4:   uint16(26983),
		5:   uint16(26984),
		6:   uint16(26985),
		7:   uint16(26986),
		8:   uint16(26988),
		9:   uint16(26989),
		10:  uint16(26991),
		11:  uint16(26992),
		12:  uint16(26994),
		13:  uint16(26995),
		14:  uint16(26996),
		15:  uint16(26997),
		16:  uint16(26998),
		17:  uint16(27002),
		18:  uint16(27003),
		19:  uint16(27005),
		20:  uint16(27006),
		21:  uint16(27007),
		22:  uint16(27009),
		23:  uint16(27011),
		24:  uint16(27013),
		25:  uint16(27018),
		26:  uint16(27019),
		27:  uint16(27020),
		28:  uint16(27022),
		29:  uint16(27023),
		30:  uint16(27024),
		31:  uint16(27025),
		32:  uint16(27026),
		33:  uint16(27027),
		34:  uint16(27030),
		35:  uint16(27031),
		36:  uint16(27033),
		37:  uint16(27034),
		38:  uint16(27037),
		39:  uint16(27038),
		40:  uint16(27039),
		41:  uint16(27040),
		42:  uint16(27041),
		43:  uint16(27042),
		44:  uint16(27043),
		45:  uint16(27044),
		46:  uint16(27045),
		47:  uint16(27046),
		48:  uint16(27049),
		49:  uint16(27050),
		50:  uint16(27052),
		51:  uint16(27054),
		52:  uint16(27055),
		53:  uint16(27056),
		54:  uint16(27058),
		55:  uint16(27059),
		56:  uint16(27061),
		57:  uint16(27062),
		58:  uint16(27064),
		59:  uint16(27065),
		60:  uint16(27066),
		61:  uint16(27068),
		62:  uint16(27069),
		63:  uint16(27070),
		64:  uint16(27071),
		65:  uint16(27072),
		66:  uint16(27074),
		67:  uint16(27075),
		68:  uint16(27076),
		69:  uint16(27077),
		70:  uint16(27078),
		71:  uint16(27079),
		72:  uint16(27080),
		73:  uint16(27081),
		74:  uint16(27083),
		75:  uint16(27085),
		76:  uint16(27087),
		77:  uint16(27089),
		78:  uint16(27090),
		79:  uint16(27091),
		80:  uint16(27093),
		81:  uint16(27094),
		82:  uint16(27095),
		83:  uint16(27096),
		84:  uint16(27097),
		85:  uint16(27098),
		86:  uint16(27100),
		87:  uint16(27101),
		88:  uint16(27102),
		89:  uint16(27105),
		90:  uint16(27106),
		91:  uint16(27107),
		92:  uint16(27108),
		93:  uint16(27109),
		94:  uint16(27110),
		95:  uint16(27111),
		96:  uint16(27112),
		97:  uint16(27113),
		98:  uint16(27114),
		99:  uint16(27115),
		100: uint16(27116),
		101: uint16(27118),
		102: uint16(27119),
		103: uint16(27120),
		104: uint16(27121),
		105: uint16(27123),
		106: uint16(27124),
		107: uint16(27125),
		108: uint16(27126),
		109: uint16(27127),
		110: uint16(27128),
		111: uint16(27129),
		112: uint16(27130),
		113: uint16(27131),
		114: uint16(27132),
		115: uint16(27134),
		116: uint16(27136),
		117: uint16(27137),
		118: uint16(27138),
		119: uint16(27139),
		120: uint16(27140),
		121: uint16(27141),
		122: uint16(27142),
		123: uint16(27143),
		124: uint16(27144),
		125: uint16(27145),
		126: uint16(27147),
		127: uint16(27148),
		128: uint16(27149),
		129: uint16(27150),
		130: uint16(27151),
		131: uint16(27152),
		132: uint16(27153),
		133: uint16(27154),
		134: uint16(27155),
		135: uint16(27156),
		136: uint16(27157),
		137: uint16(27158),
		138: uint16(27161),
		139: uint16(27162),
		140: uint16(27163),
		141: uint16(27164),
		142: uint16(27165),
		143: uint16(27166),
		144: uint16(27168),
		145: uint16(27170),
		146: uint16(27171),
		147: uint16(27172),
		148: uint16(27173),
		149: uint16(27174),
		150: uint16(27175),
		151: uint16(27177),
		152: uint16(27179),
		153: uint16(27180),
		154: uint16(27181),
		155: uint16(27182),
		156: uint16(27184),
		157: uint16(27186),
		158: uint16(27187),
		159: uint16(27188),
		160: uint16(27190),
		161: uint16(27191),
		162: uint16(27192),
		163: uint16(27193),
		164: uint16(27194),
		165: uint16(27195),
		166: uint16(27196),
		167: uint16(27199),
		168: uint16(27200),
		169: uint16(27201),
		170: uint16(27202),
		171: uint16(27203),
		172: uint16(27205),
		173: uint16(27206),
		174: uint16(27208),
		175: uint16(27209),
		176: uint16(27210),
		177: uint16(27211),
		178: uint16(27212),
		179: uint16(27213),
		180: uint16(27214),
		181: uint16(27215),
		182: uint16(27217),
		183: uint16(27218),
		184: uint16(27219),
		185: uint16(27220),
		186: uint16(27221),
		187: uint16(27222),
		188: uint16(27223),
		189: uint16(27226),
	},
	24: {
		0:   uint16(27228),
		1:   uint16(27229),
		2:   uint16(27230),
		3:   uint16(27231),
		4:   uint16(27232),
		5:   uint16(27234),
		6:   uint16(27235),
		7:   uint16(27236),
		8:   uint16(27238),
		9:   uint16(27239),
		10:  uint16(27240),
		11:  uint16(27241),
		12:  uint16(27242),
		13:  uint16(27243),
		14:  uint16(27244),
		15:  uint16(27245),
		16:  uint16(27246),
		17:  uint16(27247),
		18:  uint16(27248),
		19:  uint16(27250),
		20:  uint16(27251),
		21:  uint16(27252),
		22:  uint16(27253),
		23:  uint16(27254),
		24:  uint16(27255),
		25:  uint16(27256),
		26:  uint16(27258),
		27:  uint16(27259),
		28:  uint16(27261),
		29:  uint16(27262),
		30:  uint16(27263),
		31:  uint16(27265),
		32:  uint16(27266),
		33:  uint16(27267),
		34:  uint16(27269),
		35:  uint16(27270),
		36:  uint16(27271),
		37:  uint16(27272),
		38:  uint16(27273),
		39:  uint16(27274),
		40:  uint16(27275),
		41:  uint16(27276),
		42:  uint16(27277),
		43:  uint16(27279),
		44:  uint16(27282),
		45:  uint16(27283),
		46:  uint16(27284),
		47:  uint16(27285),
		48:  uint16(27286),
		49:  uint16(27288),
		50:  uint16(27289),
		51:  uint16(27290),
		52:  uint16(27291),
		53:  uint16(27292),
		54:  uint16(27293),
		55:  uint16(27294),
		56:  uint16(27295),
		57:  uint16(27297),
		58:  uint16(27298),
		59:  uint16(27299),
		60:  uint16(27300),
		61:  uint16(27301),
		62:  uint16(27302),
		63:  uint16(27303),
		64:  uint16(27304),
		65:  uint16(27306),
		66:  uint16(27309),
		67:  uint16(27310),
		68:  uint16(27311),
		69:  uint16(27312),
		70:  uint16(27313),
		71:  uint16(27314),
		72:  uint16(27315),
		73:  uint16(27316),
		74:  uint16(27317),
		75:  uint16(27318),
		76:  uint16(27319),
		77:  uint16(27320),
		78:  uint16(27321),
		79:  uint16(27322),
		80:  uint16(27323),
		81:  uint16(27324),
		82:  uint16(27325),
		83:  uint16(27326),
		84:  uint16(27327),
		85:  uint16(27328),
		86:  uint16(27329),
		87:  uint16(27330),
		88:  uint16(27331),
		89:  uint16(27332),
		90:  uint16(27333),
		91:  uint16(27334),
		92:  uint16(27335),
		93:  uint16(27336),
		94:  uint16(27337),
		95:  uint16(27338),
		96:  uint16(27339),
		97:  uint16(27340),
		98:  uint16(27341),
		99:  uint16(27342),
		100: uint16(27343),
		101: uint16(27344),
		102: uint16(27345),
		103: uint16(27346),
		104: uint16(27347),
		105: uint16(27348),
		106: uint16(27349),
		107: uint16(27350),
		108: uint16(27351),
		109: uint16(27352),
		110: uint16(27353),
		111: uint16(27354),
		112: uint16(27355),
		113: uint16(27356),
		114: uint16(27357),
		115: uint16(27358),
		116: uint16(27359),
		117: uint16(27360),
		118: uint16(27361),
		119: uint16(27362),
		120: uint16(27363),
		121: uint16(27364),
		122: uint16(27365),
		123: uint16(27366),
		124: uint16(27367),
		125: uint16(27368),
		126: uint16(27369),
		127: uint16(27370),
		128: uint16(27371),
		129: uint16(27372),
		130: uint16(27373),
		131: uint16(27374),
		132: uint16(27375),
		133: uint16(27376),
		134: uint16(27377),
		135: uint16(27378),
		136: uint16(27379),
		137: uint16(27380),
		138: uint16(27381),
		139: uint16(27382),
		140: uint16(27383),
		141: uint16(27384),
		142: uint16(27385),
		143: uint16(27386),
		144: uint16(27387),
		145: uint16(27388),
		146: uint16(27389),
		147: uint16(27390),
		148: uint16(27391),
		149: uint16(27392),
		150: uint16(27393),
		151: uint16(27394),
		152: uint16(27395),
		153: uint16(27396),
		154: uint16(27397),
		155: uint16(27398),
		156: uint16(27399),
		157: uint16(27400),
		158: uint16(27401),
		159: uint16(27402),
		160: uint16(27403),
		161: uint16(27404),
		162: uint16(27405),
		163: uint16(27406),
		164: uint16(27407),
		165: uint16(27408),
		166: uint16(27409),
		167: uint16(27410),
		168: uint16(27411),
		169: uint16(27412),
		170: uint16(27413),
		171: uint16(27414),
		172: uint16(27415),
		173: uint16(27416),
		174: uint16(27417),
		175: uint16(27418),
		176: uint16(27419),
		177: uint16(27420),
		178: uint16(27421),
		179: uint16(27422),
		180: uint16(27423),
		181: uint16(27429),
		182: uint16(27430),
		183: uint16(27432),
		184: uint16(27433),
		185: uint16(27434),
		186: uint16(27435),
		187: uint16(27436),
		188: uint16(27437),
		189: uint16(27438),
	},
	25: {
		0:   uint16(27439),
		1:   uint16(27440),
		2:   uint16(27441),
		3:   uint16(27443),
		4:   uint16(27444),
		5:   uint16(27445),
		6:   uint16(27446),
		7:   uint16(27448),
		8:   uint16(27451),
		9:   uint16(27452),
		10:  uint16(27453),
		11:  uint16(27455),
		12:  uint16(27456),
		13:  uint16(27457),
		14:  uint16(27458),
		15:  uint16(27460),
		16:  uint16(27461),
		17:  uint16(27464),
		18:  uint16(27466),
		19:  uint16(27467),
		20:  uint16(27469),
		21:  uint16(27470),
		22:  uint16(27471),
		23:  uint16(27472),
		24:  uint16(27473),
		25:  uint16(27474),
		26:  uint16(27475),
		27:  uint16(27476),
		28:  uint16(27477),
		29:  uint16(27478),
		30:  uint16(27479),
		31:  uint16(27480),
		32:  uint16(27482),
		33:  uint16(27483),
		34:  uint16(27484),
		35:  uint16(27485),
		36:  uint16(27486),
		37:  uint16(27487),
		38:  uint16(27488),
		39:  uint16(27489),
		40:  uint16(27496),
		41:  uint16(27497),
		42:  uint16(27499),
		43:  uint16(27500),
		44:  uint16(27501),
		45:  uint16(27502),
		46:  uint16(27503),
		47:  uint16(27504),
		48:  uint16(27505),
		49:  uint16(27506),
		50:  uint16(27507),
		51:  uint16(27508),
		52:  uint16(27509),
		53:  uint16(27510),
		54:  uint16(27511),
		55:  uint16(27512),
		56:  uint16(27514),
		57:  uint16(27517),
		58:  uint16(27518),
		59:  uint16(27519),
		60:  uint16(27520),
		61:  uint16(27525),
		62:  uint16(27528),
		63:  uint16(27532),
		64:  uint16(27534),
		65:  uint16(27535),
		66:  uint16(27536),
		67:  uint16(27537),
		68:  uint16(27540),
		69:  uint16(27541),
		70:  uint16(27543),
		71:  uint16(27544),
		72:  uint16(27545),
		73:  uint16(27548),
		74:  uint16(27549),
		75:  uint16(27550),
		76:  uint16(27551),
		77:  uint16(27552),
		78:  uint16(27554),
		79:  uint16(27555),
		80:  uint16(27556),
		81:  uint16(27557),
		82:  uint16(27558),
		83:  uint16(27559),
		84:  uint16(27560),
		85:  uint16(27561),
		86:  uint16(27563),
		87:  uint16(27564),
		88:  uint16(27565),
		89:  uint16(27566),
		90:  uint16(27567),
		91:  uint16(27568),
		92:  uint16(27569),
		93:  uint16(27570),
		94:  uint16(27574),
		95:  uint16(27576),
		96:  uint16(27577),
		97:  uint16(27578),
		98:  uint16(27579),
		99:  uint16(27580),
		100: uint16(27581),
		101: uint16(27582),
		102: uint16(27584),
		103: uint16(27587),
		104: uint16(27588),
		105: uint16(27590),
		106: uint16(27591),
		107: uint16(27592),
		108: uint16(27593),
		109: uint16(27594),
		110: uint16(27596),
		111: uint16(27598),
		112: uint16(27600),
		113: uint16(27601),
		114: uint16(27608),
		115: uint16(27610),
		116: uint16(27612),
		117: uint16(27613),
		118: uint16(27614),
		119: uint16(27615),
		120: uint16(27616),
		121: uint16(27618),
		122: uint16(27619),
		123: uint16(27620),
		124: uint16(27621),
		125: uint16(27622),
		126: uint16(27623),
		127: uint16(27624),
		128: uint16(27625),
		129: uint16(27628),
		130: uint16(27629),
		131: uint16(27630),
		132: uint16(27632),
		133: uint16(27633),
		134: uint16(27634),
		135: uint16(27636),
		136: uint16(27638),
		137: uint16(27639),
		138: uint16(27640),
		139: uint16(27642),
		140: uint16(27643),
		141: uint16(27644),
		142: uint16(27646),
		143: uint16(27647),
		144: uint16(27648),
		145: uint16(27649),
		146: uint16(27650),
		147: uint16(27651),
		148: uint16(27652),
		149: uint16(27656),
		150: uint16(27657),
		151: uint16(27658),
		152: uint16(27659),
		153: uint16(27660),
		154: uint16(27662),
		155: uint16(27666),
		156: uint16(27671),
		157: uint16(27676),
		158: uint16(27677),
		159: uint16(27678),
		160: uint16(27680),
		161: uint16(27683),
		162: uint16(27685),
		163: uint16(27691),
		164: uint16(27692),
		165: uint16(27693),
		166: uint16(27697),
		167: uint16(27699),
		168: uint16(27702),
		169: uint16(27703),
		170: uint16(27705),
		171: uint16(27706),
		172: uint16(27707),
		173: uint16(27708),
		174: uint16(27710),
		175: uint16(27711),
		176: uint16(27715),
		177: uint16(27716),
		178: uint16(27717),
		179: uint16(27720),
		180: uint16(27723),
		181: uint16(27724),
		182: uint16(27725),
		183: uint16(27726),
		184: uint16(27727),
		185: uint16(27729),
		186: uint16(27730),
		187: uint16(27731),
		188: uint16(27734),
		189: uint16(27736),
	},
	26: {
		0:   uint16(27737),
		1:   uint16(27738),
		2:   uint16(27746),
		3:   uint16(27747),
		4:   uint16(27749),
		5:   uint16(27750),
		6:   uint16(27751),
		7:   uint16(27755),
		8:   uint16(27756),
		9:   uint16(27757),
		10:  uint16(27758),
		11:  uint16(27759),
		12:  uint16(27761),
		13:  uint16(27763),
		14:  uint16(27765),
		15:  uint16(27767),
		16:  uint16(27768),
		17:  uint16(27770),
		18:  uint16(27771),
		19:  uint16(27772),
		20:  uint16(27775),
		21:  uint16(27776),
		22:  uint16(27780),
		23:  uint16(27783),
		24:  uint16(27786),
		25:  uint16(27787),
		26:  uint16(27789),
		27:  uint16(27790),
		28:  uint16(27793),
		29:  uint16(27794),
		30:  uint16(27797),
		31:  uint16(27798),
		32:  uint16(27799),
		33:  uint16(27800),
		34:  uint16(27802),
		35:  uint16(27804),
		36:  uint16(27805),
		37:  uint16(27806),
		38:  uint16(27808),
		39:  uint16(27810),
		40:  uint16(27816),
		41:  uint16(27820),
		42:  uint16(27823),
		43:  uint16(27824),
		44:  uint16(27828),
		45:  uint16(27829),
		46:  uint16(27830),
		47:  uint16(27831),
		48:  uint16(27834),
		49:  uint16(27840),
		50:  uint16(27841),
		51:  uint16(27842),
		52:  uint16(27843),
		53:  uint16(27846),
		54:  uint16(27847),
		55:  uint16(27848),
		56:  uint16(27851),
		57:  uint16(27853),
		58:  uint16(27854),
		59:  uint16(27855),
		60:  uint16(27857),
		61:  uint16(27858),
		62:  uint16(27864),
		63:  uint16(27865),
		64:  uint16(27866),
		65:  uint16(27868),
		66:  uint16(27869),
		67:  uint16(27871),
		68:  uint16(27876),
		69:  uint16(27878),
		70:  uint16(27879),
		71:  uint16(27881),
		72:  uint16(27884),
		73:  uint16(27885),
		74:  uint16(27890),
		75:  uint16(27892),
		76:  uint16(27897),
		77:  uint16(27903),
		78:  uint16(27904),
		79:  uint16(27906),
		80:  uint16(27907),
		81:  uint16(27909),
		82:  uint16(27910),
		83:  uint16(27912),
		84:  uint16(27913),
		85:  uint16(27914),
		86:  uint16(27917),
		87:  uint16(27919),
		88:  uint16(27920),
		89:  uint16(27921),
		90:  uint16(27923),
		91:  uint16(27924),
		92:  uint16(27925),
		93:  uint16(27926),
		94:  uint16(27928),
		95:  uint16(27932),
		96:  uint16(27933),
		97:  uint16(27935),
		98:  uint16(27936),
		99:  uint16(27937),
		100: uint16(27938),
		101: uint16(27939),
		102: uint16(27940),
		103: uint16(27942),
		104: uint16(27944),
		105: uint16(27945),
		106: uint16(27948),
		107: uint16(27949),
		108: uint16(27951),
		109: uint16(27952),
		110: uint16(27956),
		111: uint16(27958),
		112: uint16(27959),
		113: uint16(27960),
		114: uint16(27962),
		115: uint16(27967),
		116: uint16(27968),
		117: uint16(27970),
		118: uint16(27972),
		119: uint16(27977),
		120: uint16(27980),
		121: uint16(27984),
		122: uint16(27989),
		123: uint16(27990),
		124: uint16(27991),
		125: uint16(27992),
		126: uint16(27995),
		127: uint16(27997),
		128: uint16(27999),
		129: uint16(28001),
		130: uint16(28002),
		131: uint16(28004),
		132: uint16(28005),
		133: uint16(28007),
		134: uint16(28008),
		135: uint16(28011),
		136: uint16(28012),
		137: uint16(28013),
		138: uint16(28016),
		139: uint16(28017),
		140: uint16(28018),
		141: uint16(28019),
		142: uint16(28021),
		143: uint16(28022),
		144: uint16(28025),
		145: uint16(28026),
		146: uint16(28027),
		147: uint16(28029),
		148: uint16(28030),
		149: uint16(28031),
		150: uint16(28032),
		151: uint16(28033),
		152: uint16(28035),
		153: uint16(28036),
		154: uint16(28038),
		155: uint16(28039),
		156: uint16(28042),
		157: uint16(28043),
		158: uint16(28045),
		159: uint16(28047),
		160: uint16(28048),
		161: uint16(28050),
		162: uint16(28054),
		163: uint16(28055),
		164: uint16(28056),
		165: uint16(28057),
		166: uint16(28058),
		167: uint16(28060),
		168: uint16(28066),
		169: uint16(28069),
		170: uint16(28076),
		171: uint16(28077),
		172: uint16(28080),
		173: uint16(28081),
		174: uint16(28083),
		175: uint16(28084),
		176: uint16(28086),
		177: uint16(28087),
		178: uint16(28089),
		179: uint16(28090),
		180: uint16(28091),
		181: uint16(28092),
		182: uint16(28093),
		183: uint16(28094),
		184: uint16(28097),
		185: uint16(28098),
		186: uint16(28099),
		187: uint16(28104),
		188: uint16(28105),
		189: uint16(28106),
	},
	27: {
		0:   uint16(28109),
		1:   uint16(28110),
		2:   uint16(28111),
		3:   uint16(28112),
		4:   uint16(28114),
		5:   uint16(28115),
		6:   uint16(28116),
		7:   uint16(28117),
		8:   uint16(28119),
		9:   uint16(28122),
		10:  uint16(28123),
		11:  uint16(28124),
		12:  uint16(28127),
		13:  uint16(28130),
		14:  uint16(28131),
		15:  uint16(28133),
		16:  uint16(28135),
		17:  uint16(28136),
		18:  uint16(28137),
		19:  uint16(28138),
		20:  uint16(28141),
		21:  uint16(28143),
		22:  uint16(28144),
		23:  uint16(28146),
		24:  uint16(28148),
		25:  uint16(28149),
		26:  uint16(28150),
		27:  uint16(28152),
		28:  uint16(28154),
		29:  uint16(28157),
		30:  uint16(28158),
		31:  uint16(28159),
		32:  uint16(28160),
		33:  uint16(28161),
		34:  uint16(28162),
		35:  uint16(28163),
		36:  uint16(28164),
		37:  uint16(28166),
		38:  uint16(28167),
		39:  uint16(28168),
		40:  uint16(28169),
		41:  uint16(28171),
		42:  uint16(28175),
		43:  uint16(28178),
		44:  uint16(28179),
		45:  uint16(28181),
		46:  uint16(28184),
		47:  uint16(28185),
		48:  uint16(28187),
		49:  uint16(28188),
		50:  uint16(28190),
		51:  uint16(28191),
		52:  uint16(28194),
		53:  uint16(28198),
		54:  uint16(28199),
		55:  uint16(28200),
		56:  uint16(28202),
		57:  uint16(28204),
		58:  uint16(28206),
		59:  uint16(28208),
		60:  uint16(28209),
		61:  uint16(28211),
		62:  uint16(28213),
		63:  uint16(28214),
		64:  uint16(28215),
		65:  uint16(28217),
		66:  uint16(28219),
		67:  uint16(28220),
		68:  uint16(28221),
		69:  uint16(28222),
		70:  uint16(28223),
		71:  uint16(28224),
		72:  uint16(28225),
		73:  uint16(28226),
		74:  uint16(28229),
		75:  uint16(28230),
		76:  uint16(28231),
		77:  uint16(28232),
		78:  uint16(28233),
		79:  uint16(28234),
		80:  uint16(28235),
		81:  uint16(28236),
		82:  uint16(28239),
		83:  uint16(28240),
		84:  uint16(28241),
		85:  uint16(28242),
		86:  uint16(28245),
		87:  uint16(28247),
		88:  uint16(28249),
		89:  uint16(28250),
		90:  uint16(28252),
		91:  uint16(28253),
		92:  uint16(28254),
		93:  uint16(28256),
		94:  uint16(28257),
		95:  uint16(28258),
		96:  uint16(28259),
		97:  uint16(28260),
		98:  uint16(28261),
		99:  uint16(28262),
		100: uint16(28263),
		101: uint16(28264),
		102: uint16(28265),
		103: uint16(28266),
		104: uint16(28268),
		105: uint16(28269),
		106: uint16(28271),
		107: uint16(28272),
		108: uint16(28273),
		109: uint16(28274),
		110: uint16(28275),
		111: uint16(28276),
		112: uint16(28277),
		113: uint16(28278),
		114: uint16(28279),
		115: uint16(28280),
		116: uint16(28281),
		117: uint16(28282),
		118: uint16(28283),
		119: uint16(28284),
		120: uint16(28285),
		121: uint16(28288),
		122: uint16(28289),
		123: uint16(28290),
		124: uint16(28292),
		125: uint16(28295),
		126: uint16(28296),
		127: uint16(28298),
		128: uint16(28299),
		129: uint16(28300),
		130: uint16(28301),
		131: uint16(28302),
		132: uint16(28305),
		133: uint16(28306),
		134: uint16(28307),
		135: uint16(28308),
		136: uint16(28309),
		137: uint16(28310),
		138: uint16(28311),
		139: uint16(28313),
		140: uint16(28314),
		141: uint16(28315),
		142: uint16(28317),
		143: uint16(28318),
		144: uint16(28320),
		145: uint16(28321),
		146: uint16(28323),
		147: uint16(28324),
		148: uint16(28326),
		149: uint16(28328),
		150: uint16(28329),
		151: uint16(28331),
		152: uint16(28332),
		153: uint16(28333),
		154: uint16(28334),
		155: uint16(28336),
		156: uint16(28339),
		157: uint16(28341),
		158: uint16(28344),
		159: uint16(28345),
		160: uint16(28348),
		161: uint16(28350),
		162: uint16(28351),
		163: uint16(28352),
		164: uint16(28355),
		165: uint16(28356),
		166: uint16(28357),
		167: uint16(28358),
		168: uint16(28360),
		169: uint16(28361),
		170: uint16(28362),
		171: uint16(28364),
		172: uint16(28365),
		173: uint16(28366),
		174: uint16(28368),
		175: uint16(28370),
		176: uint16(28374),
		177: uint16(28376),
		178: uint16(28377),
		179: uint16(28379),
		180: uint16(28380),
		181: uint16(28381),
		182: uint16(28387),
		183: uint16(28391),
		184: uint16(28394),
		185: uint16(28395),
		186: uint16(28396),
		187: uint16(28397),
		188: uint16(28398),
		189: uint16(28399),
	},
	28: {
		0:   uint16(28400),
		1:   uint16(28401),
		2:   uint16(28402),
		3:   uint16(28403),
		4:   uint16(28405),
		5:   uint16(28406),
		6:   uint16(28407),
		7:   uint16(28408),
		8:   uint16(28410),
		9:   uint16(28411),
		10:  uint16(28412),
		11:  uint16(28413),
		12:  uint16(28414),
		13:  uint16(28415),
		14:  uint16(28416),
		15:  uint16(28417),
		16:  uint16(28419),
		17:  uint16(28420),
		18:  uint16(28421),
		19:  uint16(28423),
		20:  uint16(28424),
		21:  uint16(28426),
		22:  uint16(28427),
		23:  uint16(28428),
		24:  uint16(28429),
		25:  uint16(28430),
		26:  uint16(28432),
		27:  uint16(28433),
		28:  uint16(28434),
		29:  uint16(28438),
		30:  uint16(28439),
		31:  uint16(28440),
		32:  uint16(28441),
		33:  uint16(28442),
		34:  uint16(28443),
		35:  uint16(28444),
		36:  uint16(28445),
		37:  uint16(28446),
		38:  uint16(28447),
		39:  uint16(28449),
		40:  uint16(28450),
		41:  uint16(28451),
		42:  uint16(28453),
		43:  uint16(28454),
		44:  uint16(28455),
		45:  uint16(28456),
		46:  uint16(28460),
		47:  uint16(28462),
		48:  uint16(28464),
		49:  uint16(28466),
		50:  uint16(28468),
		51:  uint16(28469),
		52:  uint16(28471),
		53:  uint16(28472),
		54:  uint16(28473),
		55:  uint16(28474),
		56:  uint16(28475),
		57:  uint16(28476),
		58:  uint16(28477),
		59:  uint16(28479),
		60:  uint16(28480),
		61:  uint16(28481),
		62:  uint16(28482),
		63:  uint16(28483),
		64:  uint16(28484),
		65:  uint16(28485),
		66:  uint16(28488),
		67:  uint16(28489),
		68:  uint16(28490),
		69:  uint16(28492),
		70:  uint16(28494),
		71:  uint16(28495),
		72:  uint16(28496),
		73:  uint16(28497),
		74:  uint16(28498),
		75:  uint16(28499),
		76:  uint16(28500),
		77:  uint16(28501),
		78:  uint16(28502),
		79:  uint16(28503),
		80:  uint16(28505),
		81:  uint16(28506),
		82:  uint16(28507),
		83:  uint16(28509),
		84:  uint16(28511),
		85:  uint16(28512),
		86:  uint16(28513),
		87:  uint16(28515),
		88:  uint16(28516),
		89:  uint16(28517),
		90:  uint16(28519),
		91:  uint16(28520),
		92:  uint16(28521),
		93:  uint16(28522),
		94:  uint16(28523),
		95:  uint16(28524),
		96:  uint16(28527),
		97:  uint16(28528),
		98:  uint16(28529),
		99:  uint16(28531),
		100: uint16(28533),
		101: uint16(28534),
		102: uint16(28535),
		103: uint16(28537),
		104: uint16(28539),
		105: uint16(28541),
		106: uint16(28542),
		107: uint16(28543),
		108: uint16(28544),
		109: uint16(28545),
		110: uint16(28546),
		111: uint16(28547),
		112: uint16(28549),
		113: uint16(28550),
		114: uint16(28551),
		115: uint16(28554),
		116: uint16(28555),
		117: uint16(28559),
		118: uint16(28560),
		119: uint16(28561),
		120: uint16(28562),
		121: uint16(28563),
		122: uint16(28564),
		123: uint16(28565),
		124: uint16(28566),
		125: uint16(28567),
		126: uint16(28568),
		127: uint16(28569),
		128: uint16(28570),
		129: uint16(28571),
		130: uint16(28573),
		131: uint16(28574),
		132: uint16(28575),
		133: uint16(28576),
		134: uint16(28578),
		135: uint16(28579),
		136: uint16(28580),
		137: uint16(28581),
		138: uint16(28582),
		139: uint16(28584),
		140: uint16(28585),
		141: uint16(28586),
		142: uint16(28587),
		143: uint16(28588),
		144: uint16(28589),
		145: uint16(28590),
		146: uint16(28591),
		147: uint16(28592),
		148: uint16(28593),
		149: uint16(28594),
		150: uint16(28596),
		151: uint16(28597),
		152: uint16(28599),
		153: uint16(28600),
		154: uint16(28602),
		155: uint16(28603),
		156: uint16(28604),
		157: uint16(28605),
		158: uint16(28606),
		159: uint16(28607),
		160: uint16(28609),
		161: uint16(28611),
		162: uint16(28612),
		163: uint16(28613),
		164: uint16(28614),
		165: uint16(28615),
		166: uint16(28616),
		167: uint16(28618),
		168: uint16(28619),
		169: uint16(28620),
		170: uint16(28621),
		171: uint16(28622),
		172: uint16(28623),
		173: uint16(28624),
		174: uint16(28627),
		175: uint16(28628),
		176: uint16(28629),
		177: uint16(28630),
		178: uint16(28631),
		179: uint16(28632),
		180: uint16(28633),
		181: uint16(28634),
		182: uint16(28635),
		183: uint16(28636),
		184: uint16(28637),
		185: uint16(28639),
		186: uint16(28642),
		187: uint16(28643),
		188: uint16(28644),
		189: uint16(28645),
	},
	29: {
		0:   uint16(28646),
		1:   uint16(28647),
		2:   uint16(28648),
		3:   uint16(28649),
		4:   uint16(28650),
		5:   uint16(28651),
		6:   uint16(28652),
		7:   uint16(28653),
		8:   uint16(28656),
		9:   uint16(28657),
		10:  uint16(28658),
		11:  uint16(28659),
		12:  uint16(28660),
		13:  uint16(28661),
		14:  uint16(28662),
		15:  uint16(28663),
		16:  uint16(28664),
		17:  uint16(28665),
		18:  uint16(28666),
		19:  uint16(28667),
		20:  uint16(28668),
		21:  uint16(28669),
		22:  uint16(28670),
		23:  uint16(28671),
		24:  uint16(28672),
		25:  uint16(28673),
		26:  uint16(28674),
		27:  uint16(28675),
		28:  uint16(28676),
		29:  uint16(28677),
		30:  uint16(28678),
		31:  uint16(28679),
		32:  uint16(28680),
		33:  uint16(28681),
		34:  uint16(28682),
		35:  uint16(28683),
		36:  uint16(28684),
		37:  uint16(28685),
		38:  uint16(28686),
		39:  uint16(28687),
		40:  uint16(28688),
		41:  uint16(28690),
		42:  uint16(28691),
		43:  uint16(28692),
		44:  uint16(28693),
		45:  uint16(28694),
		46:  uint16(28695),
		47:  uint16(28696),
		48:  uint16(28697),
		49:  uint16(28700),
		50:  uint16(28701),
		51:  uint16(28702),
		52:  uint16(28703),
		53:  uint16(28704),
		54:  uint16(28705),
		55:  uint16(28706),
		56:  uint16(28708),
		57:  uint16(28709),
		58:  uint16(28710),
		59:  uint16(28711),
		60:  uint16(28712),
		61:  uint16(28713),
		62:  uint16(28714),
		63:  uint16(28715),
		64:  uint16(28716),
		65:  uint16(28717),
		66:  uint16(28718),
		67:  uint16(28719),
		68:  uint16(28720),
		69:  uint16(28721),
		70:  uint16(28722),
		71:  uint16(28723),
		72:  uint16(28724),
		73:  uint16(28726),
		74:  uint16(28727),
		75:  uint16(28728),
		76:  uint16(28730),
		77:  uint16(28731),
		78:  uint16(28732),
		79:  uint16(28733),
		80:  uint16(28734),
		81:  uint16(28735),
		82:  uint16(28736),
		83:  uint16(28737),
		84:  uint16(28738),
		85:  uint16(28739),
		86:  uint16(28740),
		87:  uint16(28741),
		88:  uint16(28742),
		89:  uint16(28743),
		90:  uint16(28744),
		91:  uint16(28745),
		92:  uint16(28746),
		93:  uint16(28747),
		94:  uint16(28749),
		95:  uint16(28750),
		96:  uint16(28752),
		97:  uint16(28753),
		98:  uint16(28754),
		99:  uint16(28755),
		100: uint16(28756),
		101: uint16(28757),
		102: uint16(28758),
		103: uint16(28759),
		104: uint16(28760),
		105: uint16(28761),
		106: uint16(28762),
		107: uint16(28763),
		108: uint16(28764),
		109: uint16(28765),
		110: uint16(28767),
		111: uint16(28768),
		112: uint16(28769),
		113: uint16(28770),
		114: uint16(28771),
		115: uint16(28772),
		116: uint16(28773),
		117: uint16(28774),
		118: uint16(28775),
		119: uint16(28776),
		120: uint16(28777),
		121: uint16(28778),
		122: uint16(28782),
		123: uint16(28785),
		124: uint16(28786),
		125: uint16(28787),
		126: uint16(28788),
		127: uint16(28791),
		128: uint16(28793),
		129: uint16(28794),
		130: uint16(28795),
		131: uint16(28797),
		132: uint16(28801),
		133: uint16(28802),
		134: uint16(28803),
		135: uint16(28804),
		136: uint16(28806),
		137: uint16(28807),
		138: uint16(28808),
		139: uint16(28811),
		140: uint16(28812),
		141: uint16(28813),
		142: uint16(28815),
		143: uint16(28816),
		144: uint16(28817),
		145: uint16(28819),
		146: uint16(28823),
		147: uint16(28824),
		148: uint16(28826),
		149: uint16(28827),
		150: uint16(28830),
		151: uint16(28831),
		152: uint16(28832),
		153: uint16(28833),
		154: uint16(28834),
		155: uint16(28835),
		156: uint16(28836),
		157: uint16(28837),
		158: uint16(28838),
		159: uint16(28839),
		160: uint16(28840),
		161: uint16(28841),
		162: uint16(28842),
		163: uint16(28848),
		164: uint16(28850),
		165: uint16(28852),
		166: uint16(28853),
		167: uint16(28854),
		168: uint16(28858),
		169: uint16(28862),
		170: uint16(28863),
		171: uint16(28868),
		172: uint16(28869),
		173: uint16(28870),
		174: uint16(28871),
		175: uint16(28873),
		176: uint16(28875),
		177: uint16(28876),
		178: uint16(28877),
		179: uint16(28878),
		180: uint16(28879),
		181: uint16(28880),
		182: uint16(28881),
		183: uint16(28882),
		184: uint16(28883),
		185: uint16(28884),
		186: uint16(28885),
		187: uint16(28886),
		188: uint16(28887),
		189: uint16(28890),
	},
	30: {
		0:   uint16(28892),
		1:   uint16(28893),
		2:   uint16(28894),
		3:   uint16(28896),
		4:   uint16(28897),
		5:   uint16(28898),
		6:   uint16(28899),
		7:   uint16(28901),
		8:   uint16(28906),
		9:   uint16(28910),
		10:  uint16(28912),
		11:  uint16(28913),
		12:  uint16(28914),
		13:  uint16(28915),
		14:  uint16(28916),
		15:  uint16(28917),
		16:  uint16(28918),
		17:  uint16(28920),
		18:  uint16(28922),
		19:  uint16(28923),
		20:  uint16(28924),
		21:  uint16(28926),
		22:  uint16(28927),
		23:  uint16(28928),
		24:  uint16(28929),
		25:  uint16(28930),
		26:  uint16(28931),
		27:  uint16(28932),
		28:  uint16(28933),
		29:  uint16(28934),
		30:  uint16(28935),
		31:  uint16(28936),
		32:  uint16(28939),
		33:  uint16(28940),
		34:  uint16(28941),
		35:  uint16(28942),
		36:  uint16(28943),
		37:  uint16(28945),
		38:  uint16(28946),
		39:  uint16(28948),
		40:  uint16(28951),
		41:  uint16(28955),
		42:  uint16(28956),
		43:  uint16(28957),
		44:  uint16(28958),
		45:  uint16(28959),
		46:  uint16(28960),
		47:  uint16(28961),
		48:  uint16(28962),
		49:  uint16(28963),
		50:  uint16(28964),
		51:  uint16(28965),
		52:  uint16(28967),
		53:  uint16(28968),
		54:  uint16(28969),
		55:  uint16(28970),
		56:  uint16(28971),
		57:  uint16(28972),
		58:  uint16(28973),
		59:  uint16(28974),
		60:  uint16(28978),
		61:  uint16(28979),
		62:  uint16(28980),
		63:  uint16(28981),
		64:  uint16(28983),
		65:  uint16(28984),
		66:  uint16(28985),
		67:  uint16(28986),
		68:  uint16(28987),
		69:  uint16(28988),
		70:  uint16(28989),
		71:  uint16(28990),
		72:  uint16(28991),
		73:  uint16(28992),
		74:  uint16(28993),
		75:  uint16(28994),
		76:  uint16(28995),
		77:  uint16(28996),
		78:  uint16(28998),
		79:  uint16(28999),
		80:  uint16(29000),
		81:  uint16(29001),
		82:  uint16(29003),
		83:  uint16(29005),
		84:  uint16(29007),
		85:  uint16(29008),
		86:  uint16(29009),
		87:  uint16(29010),
		88:  uint16(29011),
		89:  uint16(29012),
		90:  uint16(29013),
		91:  uint16(29014),
		92:  uint16(29015),
		93:  uint16(29016),
		94:  uint16(29017),
		95:  uint16(29018),
		96:  uint16(29019),
		97:  uint16(29021),
		98:  uint16(29023),
		99:  uint16(29024),
		100: uint16(29025),
		101: uint16(29026),
		102: uint16(29027),
		103: uint16(29029),
		104: uint16(29033),
		105: uint16(29034),
		106: uint16(29035),
		107: uint16(29036),
		108: uint16(29037),
		109: uint16(29039),
		110: uint16(29040),
		111: uint16(29041),
		112: uint16(29044),
		113: uint16(29045),
		114: uint16(29046),
		115: uint16(29047),
		116: uint16(29049),
		117: uint16(29051),
		118: uint16(29052),
		119: uint16(29054),
		120: uint16(29055),
		121: uint16(29056),
		122: uint16(29057),
		123: uint16(29058),
		124: uint16(29059),
		125: uint16(29061),
		126: uint16(29062),
		127: uint16(29063),
		128: uint16(29064),
		129: uint16(29065),
		130: uint16(29067),
		131: uint16(29068),
		132: uint16(29069),
		133: uint16(29070),
		134: uint16(29072),
		135: uint16(29073),
		136: uint16(29074),
		137: uint16(29075),
		138: uint16(29077),
		139: uint16(29078),
		140: uint16(29079),
		141: uint16(29082),
		142: uint16(29083),
		143: uint16(29084),
		144: uint16(29085),
		145: uint16(29086),
		146: uint16(29089),
		147: uint16(29090),
		148: uint16(29091),
		149: uint16(29092),
		150: uint16(29093),
		151: uint16(29094),
		152: uint16(29095),
		153: uint16(29097),
		154: uint16(29098),
		155: uint16(29099),
		156: uint16(29101),
		157: uint16(29102),
		158: uint16(29103),
		159: uint16(29104),
		160: uint16(29105),
		161: uint16(29106),
		162: uint16(29108),
		163: uint16(29110),
		164: uint16(29111),
		165: uint16(29112),
		166: uint16(29114),
		167: uint16(29115),
		168: uint16(29116),
		169: uint16(29117),
		170: uint16(29118),
		171: uint16(29119),
		172: uint16(29120),
		173: uint16(29121),
		174: uint16(29122),
		175: uint16(29124),
		176: uint16(29125),
		177: uint16(29126),
		178: uint16(29127),
		179: uint16(29128),
		180: uint16(29129),
		181: uint16(29130),
		182: uint16(29131),
		183: uint16(29132),
		184: uint16(29133),
		185: uint16(29135),
		186: uint16(29136),
		187: uint16(29137),
		188: uint16(29138),
		189: uint16(29139),
	},
	31: {
		0:   uint16(29142),
		1:   uint16(29143),
		2:   uint16(29144),
		3:   uint16(29145),
		4:   uint16(29146),
		5:   uint16(29147),
		6:   uint16(29148),
		7:   uint16(29149),
		8:   uint16(29150),
		9:   uint16(29151),
		10:  uint16(29153),
		11:  uint16(29154),
		12:  uint16(29155),
		13:  uint16(29156),
		14:  uint16(29158),
		15:  uint16(29160),
		16:  uint16(29161),
		17:  uint16(29162),
		18:  uint16(29163),
		19:  uint16(29164),
		20:  uint16(29165),
		21:  uint16(29167),
		22:  uint16(29168),
		23:  uint16(29169),
		24:  uint16(29170),
		25:  uint16(29171),
		26:  uint16(29172),
		27:  uint16(29173),
		28:  uint16(29174),
		29:  uint16(29175),
		30:  uint16(29176),
		31:  uint16(29178),
		32:  uint16(29179),
		33:  uint16(29180),
		34:  uint16(29181),
		35:  uint16(29182),
		36:  uint16(29183),
		37:  uint16(29184),
		38:  uint16(29185),
		39:  uint16(29186),
		40:  uint16(29187),
		41:  uint16(29188),
		42:  uint16(29189),
		43:  uint16(29191),
		44:  uint16(29192),
		45:  uint16(29193),
		46:  uint16(29194),
		47:  uint16(29195),
		48:  uint16(29196),
		49:  uint16(29197),
		50:  uint16(29198),
		51:  uint16(29199),
		52:  uint16(29200),
		53:  uint16(29201),
		54:  uint16(29202),
		55:  uint16(29203),
		56:  uint16(29204),
		57:  uint16(29205),
		58:  uint16(29206),
		59:  uint16(29207),
		60:  uint16(29208),
		61:  uint16(29209),
		62:  uint16(29210),
		63:  uint16(29211),
		64:  uint16(29212),
		65:  uint16(29214),
		66:  uint16(29215),
		67:  uint16(29216),
		68:  uint16(29217),
		69:  uint16(29218),
		70:  uint16(29219),
		71:  uint16(29220),
		72:  uint16(29221),
		73:  uint16(29222),
		74:  uint16(29223),
		75:  uint16(29225),
		76:  uint16(29227),
		77:  uint16(29229),
		78:  uint16(29230),
		79:  uint16(29231),
		80:  uint16(29234),
		81:  uint16(29235),
		82:  uint16(29236),
		83:  uint16(29242),
		84:  uint16(29244),
		85:  uint16(29246),
		86:  uint16(29248),
		87:  uint16(29249),
		88:  uint16(29250),
		89:  uint16(29251),
		90:  uint16(29252),
		91:  uint16(29253),
		92:  uint16(29254),
		93:  uint16(29257),
		94:  uint16(29258),
		95:  uint16(29259),
		96:  uint16(29262),
		97:  uint16(29263),
		98:  uint16(29264),
		99:  uint16(29265),
		100: uint16(29267),
		101: uint16(29268),
		102: uint16(29269),
		103: uint16(29271),
		104: uint16(29272),
		105: uint16(29274),
		106: uint16(29276),
		107: uint16(29278),
		108: uint16(29280),
		109: uint16(29283),
		110: uint16(29284),
		111: uint16(29285),
		112: uint16(29288),
		113: uint16(29290),
		114: uint16(29291),
		115: uint16(29292),
		116: uint16(29293),
		117: uint16(29296),
		118: uint16(29297),
		119: uint16(29299),
		120: uint16(29300),
		121: uint16(29302),
		122: uint16(29303),
		123: uint16(29304),
		124: uint16(29307),
		125: uint16(29308),
		126: uint16(29309),
		127: uint16(29314),
		128: uint16(29315),
		129: uint16(29317),
		130: uint16(29318),
		131: uint16(29319),
		132: uint16(29320),
		133: uint16(29321),
		134: uint16(29324),
		135: uint16(29326),
		136: uint16(29328),
		137: uint16(29329),
		138: uint16(29331),
		139: uint16(29332),
		140: uint16(29333),
		141: uint16(29334),
		142: uint16(29335),
		143: uint16(29336),
		144: uint16(29337),
		145: uint16(29338),
		146: uint16(29339),
		147: uint16(29340),
		148: uint16(29341),
		149: uint16(29342),
		150: uint16(29344),
		151: uint16(29345),
		152: uint16(29346),
		153: uint16(29347),
		154: uint16(29348),
		155: uint16(29349),
		156: uint16(29350),
		157: uint16(29351),
		158: uint16(29352),
		159: uint16(29353),
		160: uint16(29354),
		161: uint16(29355),
		162: uint16(29358),
		163: uint16(29361),
		164: uint16(29362),
		165: uint16(29363),
		166: uint16(29365),
		167: uint16(29370),
		168: uint16(29371),
		169: uint16(29372),
		170: uint16(29373),
		171: uint16(29374),
		172: uint16(29375),
		173: uint16(29376),
		174: uint16(29381),
		175: uint16(29382),
		176: uint16(29383),
		177: uint16(29385),
		178: uint16(29386),
		179: uint16(29387),
		180: uint16(29388),
		181: uint16(29391),
		182: uint16(29393),
		183: uint16(29395),
		184: uint16(29396),
		185: uint16(29397),
		186: uint16(29398),
		187: uint16(29400),
		188: uint16(29402),
		189: uint16(29403),
	},
	32: {
		0:   uint16(58566),
		1:   uint16(58567),
		2:   uint16(58568),
		3:   uint16(58569),
		4:   uint16(58570),
		5:   uint16(58571),
		6:   uint16(58572),
		7:   uint16(58573),
		8:   uint16(58574),
		9:   uint16(58575),
		10:  uint16(58576),
		11:  uint16(58577),
		12:  uint16(58578),
		13:  uint16(58579),
		14:  uint16(58580),
		15:  uint16(58581),
		16:  uint16(58582),
		17:  uint16(58583),
		18:  uint16(58584),
		19:  uint16(58585),
		20:  uint16(58586),
		21:  uint16(58587),
		22:  uint16(58588),
		23:  uint16(58589),
		24:  uint16(58590),
		25:  uint16(58591),
		26:  uint16(58592),
		27:  uint16(58593),
		28:  uint16(58594),
		29:  uint16(58595),
		30:  uint16(58596),
		31:  uint16(58597),
		32:  uint16(58598),
		33:  uint16(58599),
		34:  uint16(58600),
		35:  uint16(58601),
		36:  uint16(58602),
		37:  uint16(58603),
		38:  uint16(58604),
		39:  uint16(58605),
		40:  uint16(58606),
		41:  uint16(58607),
		42:  uint16(58608),
		43:  uint16(58609),
		44:  uint16(58610),
		45:  uint16(58611),
		46:  uint16(58612),
		47:  uint16(58613),
		48:  uint16(58614),
		49:  uint16(58615),
		50:  uint16(58616),
		51:  uint16(58617),
		52:  uint16(58618),
		53:  uint16(58619),
		54:  uint16(58620),
		55:  uint16(58621),
		56:  uint16(58622),
		57:  uint16(58623),
		58:  uint16(58624),
		59:  uint16(58625),
		60:  uint16(58626),
		61:  uint16(58627),
		62:  uint16(58628),
		63:  uint16(58629),
		64:  uint16(58630),
		65:  uint16(58631),
		66:  uint16(58632),
		67:  uint16(58633),
		68:  uint16(58634),
		69:  uint16(58635),
		70:  uint16(58636),
		71:  uint16(58637),
		72:  uint16(58638),
		73:  uint16(58639),
		74:  uint16(58640),
		75:  uint16(58641),
		76:  uint16(58642),
		77:  uint16(58643),
		78:  uint16(58644),
		79:  uint16(58645),
		80:  uint16(58646),
		81:  uint16(58647),
		82:  uint16(58648),
		83:  uint16(58649),
		84:  uint16(58650),
		85:  uint16(58651),
		86:  uint16(58652),
		87:  uint16(58653),
		88:  uint16(58654),
		89:  uint16(58655),
		90:  uint16(58656),
		91:  uint16(58657),
		92:  uint16(58658),
		93:  uint16(58659),
		94:  uint16(58660),
		95:  uint16(58661),
		96:  uint16(12288),
		97:  uint16(12289),
		98:  uint16(12290),
		99:  uint16(183),
		100: uint16(713),
		101: uint16(711),
		102: uint16(168),
		103: uint16(12291),
		104: uint16(12293),
		105: uint16(8212),
		106: uint16(65374),
		107: uint16(8214),
		108: uint16(8230),
		109: uint16(8216),
		110: uint16(8217),
		111: uint16(8220),
		112: uint16(8221),
		113: uint16(12308),
		114: uint16(12309),
		115: uint16(12296),
		116: uint16(12297),
		117: uint16(12298),
		118: uint16(12299),
		119: uint16(12300),
		120: uint16(12301),
		121: uint16(12302),
		122: uint16(12303),
		123: uint16(12310),
		124: uint16(12311),
		125: uint16(12304),
		126: uint16(12305),
		127: uint16(177),
		128: uint16(215),
		129: uint16(247),
		130: uint16(8758),
		131: uint16(8743),
		132: uint16(8744),
		133: uint16(8721),
		134: uint16(8719),
		135: uint16(8746),
		136: uint16(8745),
		137: uint16(8712),
		138: uint16(8759),
		139: uint16(8730),
		140: uint16(8869),
		141: uint16(8741),
		142: uint16(8736),
		143: uint16(8978),
		144: uint16(8857),
		145: uint16(8747),
		146: uint16(8750),
		147: uint16(8801),
		148: uint16(8780),
		149: uint16(8776),
		150: uint16(8765),
		151: uint16(8733),
		152: uint16(8800),
		153: uint16(8814),
		154: uint16(8815),
		155: uint16(8804),
		156: uint16(8805),
		157: uint16(8734),
		158: uint16(8757),
		159: uint16(8756),
		160: uint16(9794),
		161: uint16(9792),
		162: uint16(176),
		163: uint16(8242),
		164: uint16(8243),
		165: uint16(8451),
		166: uint16(65284),
		167: uint16(164),
		168: uint16(65504),
		169: uint16(65505),
		170: uint16(8240),
		171: uint16(167),
		172: uint16(8470),
		173: uint16(9734),
		174: uint16(9733),
		175: uint16(9675),
		176: uint16(9679),
		177: uint16(9678),
		178: uint16(9671),
		179: uint16(9670),
		180: uint16(9633),
		181: uint16(9632),
		182: uint16(9651),
		183: uint16(9650),
		184: uint16(8251),
		185: uint16(8594),
		186: uint16(8592),
		187: uint16(8593),
		188: uint16(8595),
		189: uint16(12307),
	},
	33: {
		0:   uint16(58662),
		1:   uint16(58663),
		2:   uint16(58664),
		3:   uint16(58665),
		4:   uint16(58666),
		5:   uint16(58667),
		6:   uint16(58668),
		7:   uint16(58669),
		8:   uint16(58670),
		9:   uint16(58671),
		10:  uint16(58672),
		11:  uint16(58673),
		12:  uint16(58674),
		13:  uint16(58675),
		14:  uint16(58676),
		15:  uint16(58677),
		16:  uint16(58678),
		17:  uint16(58679),
		18:  uint16(58680),
		19:  uint16(58681),
		20:  uint16(58682),
		21:  uint16(58683),
		22:  uint16(58684),
		23:  uint16(58685),
		24:  uint16(58686),
		25:  uint16(58687),
		26:  uint16(58688),
		27:  uint16(58689),
		28:  uint16(58690),
		29:  uint16(58691),
		30:  uint16(58692),
		31:  uint16(58693),
		32:  uint16(58694),
		33:  uint16(58695),
		34:  uint16(58696),
		35:  uint16(58697),
		36:  uint16(58698),
		37:  uint16(58699),
		38:  uint16(58700),
		39:  uint16(58701),
		40:  uint16(58702),
		41:  uint16(58703),
		42:  uint16(58704),
		43:  uint16(58705),
		44:  uint16(58706),
		45:  uint16(58707),
		46:  uint16(58708),
		47:  uint16(58709),
		48:  uint16(58710),
		49:  uint16(58711),
		50:  uint16(58712),
		51:  uint16(58713),
		52:  uint16(58714),
		53:  uint16(58715),
		54:  uint16(58716),
		55:  uint16(58717),
		56:  uint16(58718),
		57:  uint16(58719),
		58:  uint16(58720),
		59:  uint16(58721),
		60:  uint16(58722),
		61:  uint16(58723),
		62:  uint16(58724),
		63:  uint16(58725),
		64:  uint16(58726),
		65:  uint16(58727),
		66:  uint16(58728),
		67:  uint16(58729),
		68:  uint16(58730),
		69:  uint16(58731),
		70:  uint16(58732),
		71:  uint16(58733),
		72:  uint16(58734),
		73:  uint16(58735),
		74:  uint16(58736),
		75:  uint16(58737),
		76:  uint16(58738),
		77:  uint16(58739),
		78:  uint16(58740),
		79:  uint16(58741),
		80:  uint16(58742),
		81:  uint16(58743),
		82:  uint16(58744),
		83:  uint16(58745),
		84:  uint16(58746),
		85:  uint16(58747),
		86:  uint16(58748),
		87:  uint16(58749),
		88:  uint16(58750),
		89:  uint16(58751),
		90:  uint16(58752),
		91:  uint16(58753),
		92:  uint16(58754),
		93:  uint16(58755),
		94:  uint16(58756),
		95:  uint16(58757),
		96:  uint16(8560),
		97:  uint16(8561),
		98:  uint16(8562),
		99:  uint16(8563),
		100: uint16(8564),
		101: uint16(8565),
		102: uint16(8566),
		103: uint16(8567),
		104: uint16(8568),
		105: uint16(8569),
		106: uint16(59238),
		107: uint16(59239),
		108: uint16(59240),
		109: uint16(59241),
		110: uint16(59242),
		111: uint16(59243),
		112: uint16(9352),
		113: uint16(9353),
		114: uint16(9354),
		115: uint16(9355),
		116: uint16(9356),
		117: uint16(9357),
		118: uint16(9358),
		119: uint16(9359),
		120: uint16(9360),
		121: uint16(9361),
		122: uint16(9362),
		123: uint16(9363),
		124: uint16(9364),
		125: uint16(9365),
		126: uint16(9366),
		127: uint16(9367),
		128: uint16(9368),
		129: uint16(9369),
		130: uint16(9370),
		131: uint16(9371),
		132: uint16(9332),
		133: uint16(9333),
		134: uint16(9334),
		135: uint16(9335),
		136: uint16(9336),
		137: uint16(9337),
		138: uint16(9338),
		139: uint16(9339),
		140: uint16(9340),
		141: uint16(9341),
		142: uint16(9342),
		143: uint16(9343),
		144: uint16(9344),
		145: uint16(9345),
		146: uint16(9346),
		147: uint16(9347),
		148: uint16(9348),
		149: uint16(9349),
		150: uint16(9350),
		151: uint16(9351),
		152: uint16(9312),
		153: uint16(9313),
		154: uint16(9314),
		155: uint16(9315),
		156: uint16(9316),
		157: uint16(9317),
		158: uint16(9318),
		159: uint16(9319),
		160: uint16(9320),
		161: uint16(9321),
		162: uint16(8364),
		163: uint16(59245),
		164: uint16(12832),
		165: uint16(12833),
		166: uint16(12834),
		167: uint16(12835),
		168: uint16(12836),
		169: uint16(12837),
		170: uint16(12838),
		171: uint16(12839),
		172: uint16(12840),
		173: uint16(12841),
		174: uint16(59246),
		175: uint16(59247),
		176: uint16(8544),
		177: uint16(8545),
		178: uint16(8546),
		179: uint16(8547),
		180: uint16(8548),
		181: uint16(8549),
		182: uint16(8550),
		183: uint16(8551),
		184: uint16(8552),
		185: uint16(8553),
		186: uint16(8554),
		187: uint16(8555),
		188: uint16(59248),
		189: uint16(59249),
	},
	34: {
		0:   uint16(58758),
		1:   uint16(58759),
		2:   uint16(58760),
		3:   uint16(58761),
		4:   uint16(58762),
		5:   uint16(58763),
		6:   uint16(58764),
		7:   uint16(58765),
		8:   uint16(58766),
		9:   uint16(58767),
		10:  uint16(58768),
		11:  uint16(58769),
		12:  uint16(58770),
		13:  uint16(58771),
		14:  uint16(58772),
		15:  uint16(58773),
		16:  uint16(58774),
		17:  uint16(58775),
		18:  uint16(58776),
		19:  uint16(58777),
		20:  uint16(58778),
		21:  uint16(58779),
		22:  uint16(58780),
		23:  uint16(58781),
		24:  uint16(58782),
		25:  uint16(58783),
		26:  uint16(58784),
		27:  uint16(58785),
		28:  uint16(58786),
		29:  uint16(58787),
		30:  uint16(58788),
		31:  uint16(58789),
		32:  uint16(58790),
		33:  uint16(58791),
		34:  uint16(58792),
		35:  uint16(58793),
		36:  uint16(58794),
		37:  uint16(58795),
		38:  uint16(58796),
		39:  uint16(58797),
		40:  uint16(58798),
		41:  uint16(58799),
		42:  uint16(58800),
		43:  uint16(58801),
		44:  uint16(58802),
		45:  uint16(58803),
		46:  uint16(58804),
		47:  uint16(58805),
		48:  uint16(58806),
		49:  uint16(58807),
		50:  uint16(58808),
		51:  uint16(58809),
		52:  uint16(58810),
		53:  uint16(58811),
		54:  uint16(58812),
		55:  uint16(58813),
		56:  uint16(58814),
		57:  uint16(58815),
		58:  uint16(58816),
		59:  uint16(58817),
		60:  uint16(58818),
		61:  uint16(58819),
		62:  uint16(58820),
		63:  uint16(58821),
		64:  uint16(58822),
		65:  uint16(58823),
		66:  uint16(58824),
		67:  uint16(58825),
		68:  uint16(58826),
		69:  uint16(58827),
		70:  uint16(58828),
		71:  uint16(58829),
		72:  uint16(58830),
		73:  uint16(58831),
		74:  uint16(58832),
		75:  uint16(58833),
		76:  uint16(58834),
		77:  uint16(58835),
		78:  uint16(58836),
		79:  uint16(58837),
		80:  uint16(58838),
		81:  uint16(58839),
		82:  uint16(58840),
		83:  uint16(58841),
		84:  uint16(58842),
		85:  uint16(58843),
		86:  uint16(58844),
		87:  uint16(58845),
		88:  uint16(58846),
		89:  uint16(58847),
		90:  uint16(58848),
		91:  uint16(58849),
		92:  uint16(58850),
		93:  uint16(58851),
		94:  uint16(58852),
		95:  uint16(58853),
		96:  uint16(65281),
		97:  uint16(65282),
		98:  uint16(65283),
		99:  uint16(65509),
		100: uint16(65285),
		101: uint16(65286),
		102: uint16(65287),
		103: uint16(65288),
		104: uint16(65289),
		105: uint16(65290),
		106: uint16(65291),
		107: uint16(65292),
		108: uint16(65293),
		109: uint16(65294),
		110: uint16(65295),
		111: uint16(65296),
		112: uint16(65297),
		113: uint16(65298),
		114: uint16(65299),
		115: uint16(65300),
		116: uint16(65301),
		117: uint16(65302),
		118: uint16(65303),
		119: uint16(65304),
		120: uint16(65305),
		121: uint16(65306),
		122: uint16(65307),
		123: uint16(65308),
		124: uint16(65309),
		125: uint16(65310),
		126: uint16(65311),
		127: uint16(65312),
		128: uint16(65313),
		129: uint16(65314),
		130: uint16(65315),
		131: uint16(65316),
		132: uint16(65317),
		133: uint16(65318),
		134: uint16(65319),
		135: uint16(65320),
		136: uint16(65321),
		137: uint16(65322),
		138: uint16(65323),
		139: uint16(65324),
		140: uint16(65325),
		141: uint16(65326),
		142: uint16(65327),
		143: uint16(65328),
		144: uint16(65329),
		145: uint16(65330),
		146: uint16(65331),
		147: uint16(65332),
		148: uint16(65333),
		149: uint16(65334),
		150: uint16(65335),
		151: uint16(65336),
		152: uint16(65337),
		153: uint16(65338),
		154: uint16(65339),
		155: uint16(65340),
		156: uint16(65341),
		157: uint16(65342),
		158: uint16(65343),
		159: uint16(65344),
		160: uint16(65345),
		161: uint16(65346),
		162: uint16(65347),
		163: uint16(65348),
		164: uint16(65349),
		165: uint16(65350),
		166: uint16(65351),
		167: uint16(65352),
		168: uint16(65353),
		169: uint16(65354),
		170: uint16(65355),
		171: uint16(65356),
		172: uint16(65357),
		173: uint16(65358),
		174: uint16(65359),
		175: uint16(65360),
		176: uint16(65361),
		177: uint16(65362),
		178: uint16(65363),
		179: uint16(65364),
		180: uint16(65365),
		181: uint16(65366),
		182: uint16(65367),
		183: uint16(65368),
		184: uint16(65369),
		185: uint16(65370),
		186: uint16(65371),
		187: uint16(65372),
		188: uint16(65373),
		189: uint16(65507),
	},
	35: {
		0:   uint16(58854),
		1:   uint16(58855),
		2:   uint16(58856),
		3:   uint16(58857),
		4:   uint16(58858),
		5:   uint16(58859),
		6:   uint16(58860),
		7:   uint16(58861),
		8:   uint16(58862),
		9:   uint16(58863),
		10:  uint16(58864),
		11:  uint16(58865),
		12:  uint16(58866),
		13:  uint16(58867),
		14:  uint16(58868),
		15:  uint16(58869),
		16:  uint16(58870),
		17:  uint16(58871),
		18:  uint16(58872),
		19:  uint16(58873),
		20:  uint16(58874),
		21:  uint16(58875),
		22:  uint16(58876),
		23:  uint16(58877),
		24:  uint16(58878),
		25:  uint16(58879),
		26:  uint16(58880),
		27:  uint16(58881),
		28:  uint16(58882),
		29:  uint16(58883),
		30:  uint16(58884),
		31:  uint16(58885),
		32:  uint16(58886),
		33:  uint16(58887),
		34:  uint16(58888),
		35:  uint16(58889),
		36:  uint16(58890),
		37:  uint16(58891),
		38:  uint16(58892),
		39:  uint16(58893),
		40:  uint16(58894),
		41:  uint16(58895),
		42:  uint16(58896),
		43:  uint16(58897),
		44:  uint16(58898),
		45:  uint16(58899),
		46:  uint16(58900),
		47:  uint16(58901),
		48:  uint16(58902),
		49:  uint16(58903),
		50:  uint16(58904),
		51:  uint16(58905),
		52:  uint16(58906),
		53:  uint16(58907),
		54:  uint16(58908),
		55:  uint16(58909),
		56:  uint16(58910),
		57:  uint16(58911),
		58:  uint16(58912),
		59:  uint16(58913),
		60:  uint16(58914),
		61:  uint16(58915),
		62:  uint16(58916),
		63:  uint16(58917),
		64:  uint16(58918),
		65:  uint16(58919),
		66:  uint16(58920),
		67:  uint16(58921),
		68:  uint16(58922),
		69:  uint16(58923),
		70:  uint16(58924),
		71:  uint16(58925),
		72:  uint16(58926),
		73:  uint16(58927),
		74:  uint16(58928),
		75:  uint16(58929),
		76:  uint16(58930),
		77:  uint16(58931),
		78:  uint16(58932),
		79:  uint16(58933),
		80:  uint16(58934),
		81:  uint16(58935),
		82:  uint16(58936),
		83:  uint16(58937),
		84:  uint16(58938),
		85:  uint16(58939),
		86:  uint16(58940),
		87:  uint16(58941),
		88:  uint16(58942),
		89:  uint16(58943),
		90:  uint16(58944),
		91:  uint16(58945),
		92:  uint16(58946),
		93:  uint16(58947),
		94:  uint16(58948),
		95:  uint16(58949),
		96:  uint16(12353),
		97:  uint16(12354),
		98:  uint16(12355),
		99:  uint16(12356),
		100: uint16(12357),
		101: uint16(12358),
		102: uint16(12359),
		103: uint16(12360),
		104: uint16(12361),
		105: uint16(12362),
		106: uint16(12363),
		107: uint16(12364),
		108: uint16(12365),
		109: uint16(12366),
		110: uint16(12367),
		111: uint16(12368),
		112: uint16(12369),
		113: uint16(12370),
		114: uint16(12371),
		115: uint16(12372),
		116: uint16(12373),
		117: uint16(12374),
		118: uint16(12375),
		119: uint16(12376),
		120: uint16(12377),
		121: uint16(12378),
		122: uint16(12379),
		123: uint16(12380),
		124: uint16(12381),
		125: uint16(12382),
		126: uint16(12383),
		127: uint16(12384),
		128: uint16(12385),
		129: uint16(12386),
		130: uint16(12387),
		131: uint16(12388),
		132: uint16(12389),
		133: uint16(12390),
		134: uint16(12391),
		135: uint16(12392),
		136: uint16(12393),
		137: uint16(12394),
		138: uint16(12395),
		139: uint16(12396),
		140: uint16(12397),
		141: uint16(12398),
		142: uint16(12399),
		143: uint16(12400),
		144: uint16(12401),
		145: uint16(12402),
		146: uint16(12403),
		147: uint16(12404),
		148: uint16(12405),
		149: uint16(12406),
		150: uint16(12407),
		151: uint16(12408),
		152: uint16(12409),
		153: uint16(12410),
		154: uint16(12411),
		155: uint16(12412),
		156: uint16(12413),
		157: uint16(12414),
		158: uint16(12415),
		159: uint16(12416),
		160: uint16(12417),
		161: uint16(12418),
		162: uint16(12419),
		163: uint16(12420),
		164: uint16(12421),
		165: uint16(12422),
		166: uint16(12423),
		167: uint16(12424),
		168: uint16(12425),
		169: uint16(12426),
		170: uint16(12427),
		171: uint16(12428),
		172: uint16(12429),
		173: uint16(12430),
		174: uint16(12431),
		175: uint16(12432),
		176: uint16(12433),
		177: uint16(12434),
		178: uint16(12435),
		179: uint16(59250),
		180: uint16(59251),
		181: uint16(59252),
		182: uint16(59253),
		183: uint16(59254),
		184: uint16(59255),
		185: uint16(59256),
		186: uint16(59257),
		187: uint16(59258),
		188: uint16(59259),
		189: uint16(59260),
	},
	36: {
		0:   uint16(58950),
		1:   uint16(58951),
		2:   uint16(58952),
		3:   uint16(58953),
		4:   uint16(58954),
		5:   uint16(58955),
		6:   uint16(58956),
		7:   uint16(58957),
		8:   uint16(58958),
		9:   uint16(58959),
		10:  uint16(58960),
		11:  uint16(58961),
		12:  uint16(58962),
		13:  uint16(58963),
		14:  uint16(58964),
		15:  uint16(58965),
		16:  uint16(58966),
		17:  uint16(58967),
		18:  uint16(58968),
		19:  uint16(58969),
		20:  uint16(58970),
		21:  uint16(58971),
		22:  uint16(58972),
		23:  uint16(58973),
		24:  uint16(58974),
		25:  uint16(58975),
		26:  uint16(58976),
		27:  uint16(58977),
		28:  uint16(58978),
		29:  uint16(58979),
		30:  uint16(58980),
		31:  uint16(58981),
		32:  uint16(58982),
		33:  uint16(58983),
		34:  uint16(58984),
		35:  uint16(58985),
		36:  uint16(58986),
		37:  uint16(58987),
		38:  uint16(58988),
		39:  uint16(58989),
		40:  uint16(58990),
		41:  uint16(58991),
		42:  uint16(58992),
		43:  uint16(58993),
		44:  uint16(58994),
		45:  uint16(58995),
		46:  uint16(58996),
		47:  uint16(58997),
		48:  uint16(58998),
		49:  uint16(58999),
		50:  uint16(59000),
		51:  uint16(59001),
		52:  uint16(59002),
		53:  uint16(59003),
		54:  uint16(59004),
		55:  uint16(59005),
		56:  uint16(59006),
		57:  uint16(59007),
		58:  uint16(59008),
		59:  uint16(59009),
		60:  uint16(59010),
		61:  uint16(59011),
		62:  uint16(59012),
		63:  uint16(59013),
		64:  uint16(59014),
		65:  uint16(59015),
		66:  uint16(59016),
		67:  uint16(59017),
		68:  uint16(59018),
		69:  uint16(59019),
		70:  uint16(59020),
		71:  uint16(59021),
		72:  uint16(59022),
		73:  uint16(59023),
		74:  uint16(59024),
		75:  uint16(59025),
		76:  uint16(59026),
		77:  uint16(59027),
		78:  uint16(59028),
		79:  uint16(59029),
		80:  uint16(59030),
		81:  uint16(59031),
		82:  uint16(59032),
		83:  uint16(59033),
		84:  uint16(59034),
		85:  uint16(59035),
		86:  uint16(59036),
		87:  uint16(59037),
		88:  uint16(59038),
		89:  uint16(59039),
		90:  uint16(59040),
		91:  uint16(59041),
		92:  uint16(59042),
		93:  uint16(59043),
		94:  uint16(59044),
		95:  uint16(59045),
		96:  uint16(12449),
		97:  uint16(12450),
		98:  uint16(12451),
		99:  uint16(12452),
		100: uint16(12453),
		101: uint16(12454),
		102: uint16(12455),
		103: uint16(12456),
		104: uint16(12457),
		105: uint16(12458),
		106: uint16(12459),
		107: uint16(12460),
		108: uint16(12461),
		109: uint16(12462),
		110: uint16(12463),
		111: uint16(12464),
		112: uint16(12465),
		113: uint16(12466),
		114: uint16(12467),
		115: uint16(12468),
		116: uint16(12469),
		117: uint16(12470),
		118: uint16(12471),
		119: uint16(12472),
		120: uint16(12473),
		121: uint16(12474),
		122: uint16(12475),
		123: uint16(12476),
		124: uint16(12477),
		125: uint16(12478),
		126: uint16(12479),
		127: uint16(12480),
		128: uint16(12481),
		129: uint16(12482),
		130: uint16(12483),
		131: uint16(12484),
		132: uint16(12485),
		133: uint16(12486),
		134: uint16(12487),
		135: uint16(12488),
		136: uint16(12489),
		137: uint16(12490),
		138: uint16(12491),
		139: uint16(12492),
		140: uint16(12493),
		141: uint16(12494),
		142: uint16(12495),
		143: uint16(12496),
		144: uint16(12497),
		145: uint16(12498),
		146: uint16(12499),
		147: uint16(12500),
		148: uint16(12501),
		149: uint16(12502),
		150: uint16(12503),
		151: uint16(12504),
		152: uint16(12505),
		153: uint16(12506),
		154: uint16(12507),
		155: uint16(12508),
		156: uint16(12509),
		157: uint16(12510),
		158: uint16(12511),
		159: uint16(12512),
		160: uint16(12513),
		161: uint16(12514),
		162: uint16(12515),
		163: uint16(12516),
		164: uint16(12517),
		165: uint16(12518),
		166: uint16(12519),
		167: uint16(12520),
		168: uint16(12521),
		169: uint16(12522),
		170: uint16(12523),
		171: uint16(12524),
		172: uint16(12525),
		173: uint16(12526),
		174: uint16(12527),
		175: uint16(12528),
		176: uint16(12529),
		177: uint16(12530),
		178: uint16(12531),
		179: uint16(12532),
		180: uint16(12533),
		181: uint16(12534),
		182: uint16(59261),
		183: uint16(59262),
		184: uint16(59263),
		185: uint16(59264),
		186: uint16(59265),
		187: uint16(59266),
		188: uint16(59267),
		189: uint16(59268),
	},
	37: {
		0:   uint16(59046),
		1:   uint16(59047),
		2:   uint16(59048),
		3:   uint16(59049),
		4:   uint16(59050),
		5:   uint16(59051),
		6:   uint16(59052),
		7:   uint16(59053),
		8:   uint16(59054),
		9:   uint16(59055),
		10:  uint16(59056),
		11:  uint16(59057),
		12:  uint16(59058),
		13:  uint16(59059),
		14:  uint16(59060),
		15:  uint16(59061),
		16:  uint16(59062),
		17:  uint16(59063),
		18:  uint16(59064),
		19:  uint16(59065),
		20:  uint16(59066),
		21:  uint16(59067),
		22:  uint16(59068),
		23:  uint16(59069),
		24:  uint16(59070),
		25:  uint16(59071),
		26:  uint16(59072),
		27:  uint16(59073),
		28:  uint16(59074),
		29:  uint16(59075),
		30:  uint16(59076),
		31:  uint16(59077),
		32:  uint16(59078),
		33:  uint16(59079),
		34:  uint16(59080),
		35:  uint16(59081),
		36:  uint16(59082),
		37:  uint16(59083),
		38:  uint16(59084),
		39:  uint16(59085),
		40:  uint16(59086),
		41:  uint16(59087),
		42:  uint16(59088),
		43:  uint16(59089),
		44:  uint16(59090),
		45:  uint16(59091),
		46:  uint16(59092),
		47:  uint16(59093),
		48:  uint16(59094),
		49:  uint16(59095),
		50:  uint16(59096),
		51:  uint16(59097),
		52:  uint16(59098),
		53:  uint16(59099),
		54:  uint16(59100),
		55:  uint16(59101),
		56:  uint16(59102),
		57:  uint16(59103),
		58:  uint16(59104),
		59:  uint16(59105),
		60:  uint16(59106),
		61:  uint16(59107),
		62:  uint16(59108),
		63:  uint16(59109),
		64:  uint16(59110),
		65:  uint16(59111),
		66:  uint16(59112),
		67:  uint16(59113),
		68:  uint16(59114),
		69:  uint16(59115),
		70:  uint16(59116),
		71:  uint16(59117),
		72:  uint16(59118),
		73:  uint16(59119),
		74:  uint16(59120),
		75:  uint16(59121),
		76:  uint16(59122),
		77:  uint16(59123),
		78:  uint16(59124),
		79:  uint16(59125),
		80:  uint16(59126),
		81:  uint16(59127),
		82:  uint16(59128),
		83:  uint16(59129),
		84:  uint16(59130),
		85:  uint16(59131),
		86:  uint16(59132),
		87:  uint16(59133),
		88:  uint16(59134),
		89:  uint16(59135),
		90:  uint16(59136),
		91:  uint16(59137),
		92:  uint16(59138),
		93:  uint16(59139),
		94:  uint16(59140),
		95:  uint16(59141),
		96:  uint16(913),
		97:  uint16(914),
		98:  uint16(915),
		99:  uint16(916),
		100: uint16(917),
		101: uint16(918),
		102: uint16(919),
		103: uint16(920),
		104: uint16(921),
		105: uint16(922),
		106: uint16(923),
		107: uint16(924),
		108: uint16(925),
		109: uint16(926),
		110: uint16(927),
		111: uint16(928),
		112: uint16(929),
		113: uint16(931),
		114: uint16(932),
		115: uint16(933),
		116: uint16(934),
		117: uint16(935),
		118: uint16(936),
		119: uint16(937),
		120: uint16(59269),
		121: uint16(59270),
		122: uint16(59271),
		123: uint16(59272),
		124: uint16(59273),
		125: uint16(59274),
		126: uint16(59275),
		127: uint16(59276),
		128: uint16(945),
		129: uint16(946),
		130: uint16(947),
		131: uint16(948),
		132: uint16(949),
		133: uint16(950),
		134: uint16(951),
		135: uint16(952),
		136: uint16(953),
		137: uint16(954),
		138: uint16(955),
		139: uint16(956),
		140: uint16(957),
		141: uint16(958),
		142: uint16(959),
		143: uint16(960),
		144: uint16(961),
		145: uint16(963),
		146: uint16(964),
		147: uint16(965),
		148: uint16(966),
		149: uint16(967),
		150: uint16(968),
		151: uint16(969),
		152: uint16(59277),
		153: uint16(59278),
		154: uint16(59279),
		155: uint16(59280),
		156: uint16(59281),
		157: uint16(59282),
		158: uint16(59283),
		159: uint16(65077),
		160: uint16(65078),
		161: uint16(65081),
		162: uint16(65082),
		163: uint16(65087),
		164: uint16(65088),
		165: uint16(65085),
		166: uint16(65086),
		167: uint16(65089),
		168: uint16(65090),
		169: uint16(65091),
		170: uint16(65092),
		171: uint16(59284),
		172: uint16(59285),
		173: uint16(65083),
		174: uint16(65084),
		175: uint16(65079),
		176: uint16(65080),
		177: uint16(65073),
		178: uint16(59286),
		179: uint16(65075),
		180: uint16(65076),
		181: uint16(59287),
		182: uint16(59288),
		183: uint16(59289),
		184: uint16(59290),
		185: uint16(59291),
		186: uint16(59292),
		187: uint16(59293),
		188: uint16(59294),
		189: uint16(59295),
	},
	38: {
		0:   uint16(59142),
		1:   uint16(59143),
		2:   uint16(59144),
		3:   uint16(59145),
		4:   uint16(59146),
		5:   uint16(59147),
		6:   uint16(59148),
		7:   uint16(59149),
		8:   uint16(59150),
		9:   uint16(59151),
		10:  uint16(59152),
		11:  uint16(59153),
		12:  uint16(59154),
		13:  uint16(59155),
		14:  uint16(59156),
		15:  uint16(59157),
		16:  uint16(59158),
		17:  uint16(59159),
		18:  uint16(59160),
		19:  uint16(59161),
		20:  uint16(59162),
		21:  uint16(59163),
		22:  uint16(59164),
		23:  uint16(59165),
		24:  uint16(59166),
		25:  uint16(59167),
		26:  uint16(59168),
		27:  uint16(59169),
		28:  uint16(59170),
		29:  uint16(59171),
		30:  uint16(59172),
		31:  uint16(59173),
		32:  uint16(59174),
		33:  uint16(59175),
		34:  uint16(59176),
		35:  uint16(59177),
		36:  uint16(59178),
		37:  uint16(59179),
		38:  uint16(59180),
		39:  uint16(59181),
		40:  uint16(59182),
		41:  uint16(59183),
		42:  uint16(59184),
		43:  uint16(59185),
		44:  uint16(59186),
		45:  uint16(59187),
		46:  uint16(59188),
		47:  uint16(59189),
		48:  uint16(59190),
		49:  uint16(59191),
		50:  uint16(59192),
		51:  uint16(59193),
		52:  uint16(59194),
		53:  uint16(59195),
		54:  uint16(59196),
		55:  uint16(59197),
		56:  uint16(59198),
		57:  uint16(59199),
		58:  uint16(59200),
		59:  uint16(59201),
		60:  uint16(59202),
		61:  uint16(59203),
		62:  uint16(59204),
		63:  uint16(59205),
		64:  uint16(59206),
		65:  uint16(59207),
		66:  uint16(59208),
		67:  uint16(59209),
		68:  uint16(59210),
		69:  uint16(59211),
		70:  uint16(59212),
		71:  uint16(59213),
		72:  uint16(59214),
		73:  uint16(59215),
		74:  uint16(59216),
		75:  uint16(59217),
		76:  uint16(59218),
		77:  uint16(59219),
		78:  uint16(59220),
		79:  uint16(59221),
		80:  uint16(59222),
		81:  uint16(59223),
		82:  uint16(59224),
		83:  uint16(59225),
		84:  uint16(59226),
		85:  uint16(59227),
		86:  uint16(59228),
		87:  uint16(59229),
		88:  uint16(59230),
		89:  uint16(59231),
		90:  uint16(59232),
		91:  uint16(59233),
		92:  uint16(59234),
		93:  uint16(59235),
		94:  uint16(59236),
		95:  uint16(59237),
		96:  uint16(1040),
		97:  uint16(1041),
		98:  uint16(1042),
		99:  uint16(1043),
		100: uint16(1044),
		101: uint16(1045),
		102: uint16(1025),
		103: uint16(1046),
		104: uint16(1047),
		105: uint16(1048),
		106: uint16(1049),
		107: uint16(1050),
		108: uint16(1051),
		109: uint16(1052),
		110: uint16(1053),
		111: uint16(1054),
		112: uint16(1055),
		113: uint16(1056),
		114: uint16(1057),
		115: uint16(1058),
		116: uint16(1059),
		117: uint16(1060),
		118: uint16(1061),
		119: uint16(1062),
		120: uint16(1063),
		121: uint16(1064),
		122: uint16(1065),
		123: uint16(1066),
		124: uint16(1067),
		125: uint16(1068),
		126: uint16(1069),
		127: uint16(1070),
		128: uint16(1071),
		129: uint16(59296),
		130: uint16(59297),
		131: uint16(59298),
		132: uint16(59299),
		133: uint16(59300),
		134: uint16(59301),
		135: uint16(59302),
		136: uint16(59303),
		137: uint16(59304),
		138: uint16(59305),
		139: uint16(59306),
		140: uint16(59307),
		141: uint16(59308),
		142: uint16(59309),
		143: uint16(59310),
		144: uint16(1072),
		145: uint16(1073),
		146: uint16(1074),
		147: uint16(1075),
		148: uint16(1076),
		149: uint16(1077),
		150: uint16(1105),
		151: uint16(1078),
		152: uint16(1079),
		153: uint16(1080),
		154: uint16(1081),
		155: uint16(1082),
		156: uint16(1083),
		157: uint16(1084),
		158: uint16(1085),
		159: uint16(1086),
		160: uint16(1087),
		161: uint16(1088),
		162: uint16(1089),
		163: uint16(1090),
		164: uint16(1091),
		165: uint16(1092),
		166: uint16(1093),
		167: uint16(1094),
		168: uint16(1095),
		169: uint16(1096),
		170: uint16(1097),
		171: uint16(1098),
		172: uint16(1099),
		173: uint16(1100),
		174: uint16(1101),
		175: uint16(1102),
		176: uint16(1103),
		177: uint16(59311),
		178: uint16(59312),
		179: uint16(59313),
		180: uint16(59314),
		181: uint16(59315),
		182: uint16(59316),
		183: uint16(59317),
		184: uint16(59318),
		185: uint16(59319),
		186: uint16(59320),
		187: uint16(59321),
		188: uint16(59322),
		189: uint16(59323),
	},
	39: {
		0:   uint16(714),
		1:   uint16(715),
		2:   uint16(729),
		3:   uint16(8211),
		4:   uint16(8213),
		5:   uint16(8229),
		6:   uint16(8245),
		7:   uint16(8453),
		8:   uint16(8457),
		9:   uint16(8598),
		10:  uint16(8599),
		11:  uint16(8600),
		12:  uint16(8601),
		13:  uint16(8725),
		14:  uint16(8735),
		15:  uint16(8739),
		16:  uint16(8786),
		17:  uint16(8806),
		18:  uint16(8807),
		19:  uint16(8895),
		20:  uint16(9552),
		21:  uint16(9553),
		22:  uint16(9554),
		23:  uint16(9555),
		24:  uint16(9556),
		25:  uint16(9557),
		26:  uint16(9558),
		27:  uint16(9559),
		28:  uint16(9560),
		29:  uint16(9561),
		30:  uint16(9562),
		31:  uint16(9563),
		32:  uint16(9564),
		33:  uint16(9565),
		34:  uint16(9566),
		35:  uint16(9567),
		36:  uint16(9568),
		37:  uint16(9569),
		38:  uint16(9570),
		39:  uint16(9571),
		40:  uint16(9572),
		41:  uint16(9573),
		42:  uint16(9574),
		43:  uint16(9575),
		44:  uint16(9576),
		45:  uint16(9577),
		46:  uint16(9578),
		47:  uint16(9579),
		48:  uint16(9580),
		49:  uint16(9581),
		50:  uint16(9582),
		51:  uint16(9583),
		52:  uint16(9584),
		53:  uint16(9585),
		54:  uint16(9586),
		55:  uint16(9587),
		56:  uint16(9601),
		57:  uint16(9602),
		58:  uint16(9603),
		59:  uint16(9604),
		60:  uint16(9605),
		61:  uint16(9606),
		62:  uint16(9607),
		63:  uint16(9608),
		64:  uint16(9609),
		65:  uint16(9610),
		66:  uint16(9611),
		67:  uint16(9612),
		68:  uint16(9613),
		69:  uint16(9614),
		70:  uint16(9615),
		71:  uint16(9619),
		72:  uint16(9620),
		73:  uint16(9621),
		74:  uint16(9660),
		75:  uint16(9661),
		76:  uint16(9698),
		77:  uint16(9699),
		78:  uint16(9700),
		79:  uint16(9701),
		80:  uint16(9737),
		81:  uint16(8853),
		82:  uint16(12306),
		83:  uint16(12317),
		84:  uint16(12318),
		85:  uint16(59324),
		86:  uint16(59325),
		87:  uint16(59326),
		88:  uint16(59327),
		89:  uint16(59328),
		90:  uint16(59329),
		91:  uint16(59330),
		92:  uint16(59331),
		93:  uint16(59332),
		94:  uint16(59333),
		95:  uint16(59334),
		96:  uint16(257),
		97:  uint16(225),
		98:  uint16(462),
		99:  uint16(224),
		100: uint16(275),
		101: uint16(233),
		102: uint16(283),
		103: uint16(232),
		104: uint16(299),
		105: uint16(237),
		106: uint16(464),
		107: uint16(236),
		108: uint16(333),
		109: uint16(243),
		110: uint16(466),
		111: uint16(242),
		112: uint16(363),
		113: uint16(250),
		114: uint16(468),
		115: uint16(249),
		116: uint16(470),
		117: uint16(472),
		118: uint16(474),
		119: uint16(476),
		120: uint16(252),
		121: uint16(234),
		122: uint16(593),
		123: uint16(59335),
		124: uint16(324),
		125: uint16(328),
		126: uint16(505),
		127: uint16(609),
		128: uint16(59337),
		129: uint16(59338),
		130: uint16(59339),
		131: uint16(59340),
		132: uint16(12549),
		133: uint16(12550),
		134: uint16(12551),
		135: uint16(12552),
		136: uint16(12553),
		137: uint16(12554),
		138: uint16(12555),
		139: uint16(12556),
		140: uint16(12557),
		141: uint16(12558),
		142: uint16(12559),
		143: uint16(12560),
		144: uint16(12561),
		145: uint16(12562),
		146: uint16(12563),
		147: uint16(12564),
		148: uint16(12565),
		149: uint16(12566),
		150: uint16(12567),
		151: uint16(12568),
		152: uint16(12569),
		153: uint16(12570),
		154: uint16(12571),
		155: uint16(12572),
		156: uint16(12573),
		157: uint16(12574),
		158: uint16(12575),
		159: uint16(12576),
		160: uint16(12577),
		161: uint16(12578),
		162: uint16(12579),
		163: uint16(12580),
		164: uint16(12581),
		165: uint16(12582),
		166: uint16(12583),
		167: uint16(12584),
		168: uint16(12585),
		169: uint16(59341),
		170: uint16(59342),
		171: uint16(59343),
		172: uint16(59344),
		173: uint16(59345),
		174: uint16(59346),
		175: uint16(59347),
		176: uint16(59348),
		177: uint16(59349),
		178: uint16(59350),
		179: uint16(59351),
		180: uint16(59352),
		181: uint16(59353),
		182: uint16(59354),
		183: uint16(59355),
		184: uint16(59356),
		185: uint16(59357),
		186: uint16(59358),
		187: uint16(59359),
		188: uint16(59360),
		189: uint16(59361),
	},
	40: {
		0:   uint16(12321),
		1:   uint16(12322),
		2:   uint16(12323),
		3:   uint16(12324),
		4:   uint16(12325),
		5:   uint16(12326),
		6:   uint16(12327),
		7:   uint16(12328),
		8:   uint16(12329),
		9:   uint16(12963),
		10:  uint16(13198),
		11:  uint16(13199),
		12:  uint16(13212),
		13:  uint16(13213),
		14:  uint16(13214),
		15:  uint16(13217),
		16:  uint16(13252),
		17:  uint16(13262),
		18:  uint16(13265),
		19:  uint16(13266),
		20:  uint16(13269),
		21:  uint16(65072),
		22:  uint16(65506),
		23:  uint16(65508),
		24:  uint16(59362),
		25:  uint16(8481),
		26:  uint16(12849),
		27:  uint16(59363),
		28:  uint16(8208),
		29:  uint16(59364),
		30:  uint16(59365),
		31:  uint16(59366),
		32:  uint16(12540),
		33:  uint16(12443),
		34:  uint16(12444),
		35:  uint16(12541),
		36:  uint16(12542),
		37:  uint16(12294),
		38:  uint16(12445),
		39:  uint16(12446),
		40:  uint16(65097),
		41:  uint16(65098),
		42:  uint16(65099),
		43:  uint16(65100),
		44:  uint16(65101),
		45:  uint16(65102),
		46:  uint16(65103),
		47:  uint16(65104),
		48:  uint16(65105),
		49:  uint16(65106),
		50:  uint16(65108),
		51:  uint16(65109),
		52:  uint16(65110),
		53:  uint16(65111),
		54:  uint16(65113),
		55:  uint16(65114),
		56:  uint16(65115),
		57:  uint16(65116),
		58:  uint16(65117),
		59:  uint16(65118),
		60:  uint16(65119),
		61:  uint16(65120),
		62:  uint16(65121),
		63:  uint16(65122),
		64:  uint16(65123),
		65:  uint16(65124),
		66:  uint16(65125),
		67:  uint16(65126),
		68:  uint16(65128),
		69:  uint16(65129),
		70:  uint16(65130),
		71:  uint16(65131),
		72:  uint16(12350),
		73:  uint16(12272),
		74:  uint16(12273),
		75:  uint16(12274),
		76:  uint16(12275),
		77:  uint16(12276),
		78:  uint16(12277),
		79:  uint16(12278),
		80:  uint16(12279),
		81:  uint16(12280),
		82:  uint16(12281),
		83:  uint16(12282),
		84:  uint16(12283),
		85:  uint16(12295),
		86:  uint16(59380),
		87:  uint16(59381),
		88:  uint16(59382),
		89:  uint16(59383),
		90:  uint16(59384),
		91:  uint16(59385),
		92:  uint16(59386),
		93:  uint16(59387),
		94:  uint16(59388),
		95:  uint16(59389),
		96:  uint16(59390),
		97:  uint16(59391),
		98:  uint16(59392),
		99:  uint16(9472),
		100: uint16(9473),
		101: uint16(9474),
		102: uint16(9475),
		103: uint16(9476),
		104: uint16(9477),
		105: uint16(9478),
		106: uint16(9479),
		107: uint16(9480),
		108: uint16(9481),
		109: uint16(9482),
		110: uint16(9483),
		111: uint16(9484),
		112: uint16(9485),
		113: uint16(9486),
		114: uint16(9487),
		115: uint16(9488),
		116: uint16(9489),
		117: uint16(9490),
		118: uint16(9491),
		119: uint16(9492),
		120: uint16(9493),
		121: uint16(9494),
		122: uint16(9495),
		123: uint16(9496),
		124: uint16(9497),
		125: uint16(9498),
		126: uint16(9499),
		127: uint16(9500),
		128: uint16(9501),
		129: uint16(9502),
		130: uint16(9503),
		131: uint16(9504),
		132: uint16(9505),
		133: uint16(9506),
		134: uint16(9507),
		135: uint16(9508),
		136: uint16(9509),
		137: uint16(9510),
		138: uint16(9511),
		139: uint16(9512),
		140: uint16(9513),
		141: uint16(9514),
		142: uint16(9515),
		143: uint16(9516),
		144: uint16(9517),
		145: uint16(9518),
		146: uint16(9519),
		147: uint16(9520),
		148: uint16(9521),
		149: uint16(9522),
		150: uint16(9523),
		151: uint16(9524),
		152: uint16(9525),
		153: uint16(9526),
		154: uint16(9527),
		155: uint16(9528),
		156: uint16(9529),
		157: uint16(9530),
		158: uint16(9531),
		159: uint16(9532),
		160: uint16(9533),
		161: uint16(9534),
		162: uint16(9535),
		163: uint16(9536),
		164: uint16(9537),
		165: uint16(9538),
		166: uint16(9539),
		167: uint16(9540),
		168: uint16(9541),
		169: uint16(9542),
		170: uint16(9543),
		171: uint16(9544),
		172: uint16(9545),
		173: uint16(9546),
		174: uint16(9547),
		175: uint16(59393),
		176: uint16(59394),
		177: uint16(59395),
		178: uint16(59396),
		179: uint16(59397),
		180: uint16(59398),
		181: uint16(59399),
		182: uint16(59400),
		183: uint16(59401),
		184: uint16(59402),
		185: uint16(59403),
		186: uint16(59404),
		187: uint16(59405),
		188: uint16(59406),
		189: uint16(59407),
	},
	41: {
		0:   uint16(29404),
		1:   uint16(29405),
		2:   uint16(29407),
		3:   uint16(29410),
		4:   uint16(29411),
		5:   uint16(29412),
		6:   uint16(29413),
		7:   uint16(29414),
		8:   uint16(29415),
		9:   uint16(29418),
		10:  uint16(29419),
		11:  uint16(29429),
		12:  uint16(29430),
		13:  uint16(29433),
		14:  uint16(29437),
		15:  uint16(29438),
		16:  uint16(29439),
		17:  uint16(29440),
		18:  uint16(29442),
		19:  uint16(29444),
		20:  uint16(29445),
		21:  uint16(29446),
		22:  uint16(29447),
		23:  uint16(29448),
		24:  uint16(29449),
		25:  uint16(29451),
		26:  uint16(29452),
		27:  uint16(29453),
		28:  uint16(29455),
		29:  uint16(29456),
		30:  uint16(29457),
		31:  uint16(29458),
		32:  uint16(29460),
		33:  uint16(29464),
		34:  uint16(29465),
		35:  uint16(29466),
		36:  uint16(29471),
		37:  uint16(29472),
		38:  uint16(29475),
		39:  uint16(29476),
		40:  uint16(29478),
		41:  uint16(29479),
		42:  uint16(29480),
		43:  uint16(29485),
		44:  uint16(29487),
		45:  uint16(29488),
		46:  uint16(29490),
		47:  uint16(29491),
		48:  uint16(29493),
		49:  uint16(29494),
		50:  uint16(29498),
		51:  uint16(29499),
		52:  uint16(29500),
		53:  uint16(29501),
		54:  uint16(29504),
		55:  uint16(29505),
		56:  uint16(29506),
		57:  uint16(29507),
		58:  uint16(29508),
		59:  uint16(29509),
		60:  uint16(29510),
		61:  uint16(29511),
		62:  uint16(29512),
		63:  uint16(29513),
		64:  uint16(29514),
		65:  uint16(29515),
		66:  uint16(29516),
		67:  uint16(29518),
		68:  uint16(29519),
		69:  uint16(29521),
		70:  uint16(29523),
		71:  uint16(29524),
		72:  uint16(29525),
		73:  uint16(29526),
		74:  uint16(29528),
		75:  uint16(29529),
		76:  uint16(29530),
		77:  uint16(29531),
		78:  uint16(29532),
		79:  uint16(29533),
		80:  uint16(29534),
		81:  uint16(29535),
		82:  uint16(29537),
		83:  uint16(29538),
		84:  uint16(29539),
		85:  uint16(29540),
		86:  uint16(29541),
		87:  uint16(29542),
		88:  uint16(29543),
		89:  uint16(29544),
		90:  uint16(29545),
		91:  uint16(29546),
		92:  uint16(29547),
		93:  uint16(29550),
		94:  uint16(29552),
		95:  uint16(29553),
		96:  uint16(57344),
		97:  uint16(57345),
		98:  uint16(57346),
		99:  uint16(57347),
		100: uint16(57348),
		101: uint16(57349),
		102: uint16(57350),
		103: uint16(57351),
		104: uint16(57352),
		105: uint16(57353),
		106: uint16(57354),
		107: uint16(57355),
		108: uint16(57356),
		109: uint16(57357),
		110: uint16(57358),
		111: uint16(57359),
		112: uint16(57360),
		113: uint16(57361),
		114: uint16(57362),
		115: uint16(57363),
		116: uint16(57364),
		117: uint16(57365),
		118: uint16(57366),
		119: uint16(57367),
		120: uint16(57368),
		121: uint16(57369),
		122: uint16(57370),
		123: uint16(57371),
		124: uint16(57372),
		125: uint16(57373),
		126: uint16(57374),
		127: uint16(57375),
		128: uint16(57376),
		129: uint16(57377),
		130: uint16(57378),
		131: uint16(57379),
		132: uint16(57380),
		133: uint16(57381),
		134: uint16(57382),
		135: uint16(57383),
		136: uint16(57384),
		137: uint16(57385),
		138: uint16(57386),
		139: uint16(57387),
		140: uint16(57388),
		141: uint16(57389),
		142: uint16(57390),
		143: uint16(57391),
		144: uint16(57392),
		145: uint16(57393),
		146: uint16(57394),
		147: uint16(57395),
		148: uint16(57396),
		149: uint16(57397),
		150: uint16(57398),
		151: uint16(57399),
		152: uint16(57400),
		153: uint16(57401),
		154: uint16(57402),
		155: uint16(57403),
		156: uint16(57404),
		157: uint16(57405),
		158: uint16(57406),
		159: uint16(57407),
		160: uint16(57408),
		161: uint16(57409),
		162: uint16(57410),
		163: uint16(57411),
		164: uint16(57412),
		165: uint16(57413),
		166: uint16(57414),
		167: uint16(57415),
		168: uint16(57416),
		169: uint16(57417),
		170: uint16(57418),
		171: uint16(57419),
		172: uint16(57420),
		173: uint16(57421),
		174: uint16(57422),
		175: uint16(57423),
		176: uint16(57424),
		177: uint16(57425),
		178: uint16(57426),
		179: uint16(57427),
		180: uint16(57428),
		181: uint16(57429),
		182: uint16(57430),
		183: uint16(57431),
		184: uint16(57432),
		185: uint16(57433),
		186: uint16(57434),
		187: uint16(57435),
		188: uint16(57436),
		189: uint16(57437),
	},
	42: {
		0:   uint16(29554),
		1:   uint16(29555),
		2:   uint16(29556),
		3:   uint16(29557),
		4:   uint16(29558),
		5:   uint16(29559),
		6:   uint16(29560),
		7:   uint16(29561),
		8:   uint16(29562),
		9:   uint16(29563),
		10:  uint16(29564),
		11:  uint16(29565),
		12:  uint16(29567),
		13:  uint16(29568),
		14:  uint16(29569),
		15:  uint16(29570),
		16:  uint16(29571),
		17:  uint16(29573),
		18:  uint16(29574),
		19:  uint16(29576),
		20:  uint16(29578),
		21:  uint16(29580),
		22:  uint16(29581),
		23:  uint16(29583),
		24:  uint16(29584),
		25:  uint16(29586),
		26:  uint16(29587),
		27:  uint16(29588),
		28:  uint16(29589),
		29:  uint16(29591),
		30:  uint16(29592),
		31:  uint16(29593),
		32:  uint16(29594),
		33:  uint16(29596),
		34:  uint16(29597),
		35:  uint16(29598),
		36:  uint16(29600),
		37:  uint16(29601),
		38:  uint16(29603),
		39:  uint16(29604),
		40:  uint16(29605),
		41:  uint16(29606),
		42:  uint16(29607),
		43:  uint16(29608),
		44:  uint16(29610),
		45:  uint16(29612),
		46:  uint16(29613),
		47:  uint16(29617),
		48:  uint16(29620),
		49:  uint16(29621),
		50:  uint16(29622),
		51:  uint16(29624),
		52:  uint16(29625),
		53:  uint16(29628),
		54:  uint16(29629),
		55:  uint16(29630),
		56:  uint16(29631),
		57:  uint16(29633),
		58:  uint16(29635),
		59:  uint16(29636),
		60:  uint16(29637),
		61:  uint16(29638),
		62:  uint16(29639),
		63:  uint16(29643),
		64:  uint16(29644),
		65:  uint16(29646),
		66:  uint16(29650),
		67:  uint16(29651),
		68:  uint16(29652),
		69:  uint16(29653),
		70:  uint16(29654),
		71:  uint16(29655),
		72:  uint16(29656),
		73:  uint16(29658),
		74:  uint16(29659),
		75:  uint16(29660),
		76:  uint16(29661),
		77:  uint16(29663),
		78:  uint16(29665),
		79:  uint16(29666),
		80:  uint16(29667),
		81:  uint16(29668),
		82:  uint16(29670),
		83:  uint16(29672),
		84:  uint16(29674),
		85:  uint16(29675),
		86:  uint16(29676),
		87:  uint16(29678),
		88:  uint16(29679),
		89:  uint16(29680),
		90:  uint16(29681),
		91:  uint16(29683),
		92:  uint16(29684),
		93:  uint16(29685),
		94:  uint16(29686),
		95:  uint16(29687),
		96:  uint16(57438),
		97:  uint16(57439),
		98:  uint16(57440),
		99:  uint16(57441),
		100: uint16(57442),
		101: uint16(57443),
		102: uint16(57444),
		103: uint16(57445),
		104: uint16(57446),
		105: uint16(57447),
		106: uint16(57448),
		107: uint16(57449),
		108: uint16(57450),
		109: uint16(57451),
		110: uint16(57452),
		111: uint16(57453),
		112: uint16(57454),
		113: uint16(57455),
		114: uint16(57456),
		115: uint16(57457),
		116: uint16(57458),
		117: uint16(57459),
		118: uint16(57460),
		119: uint16(57461),
		120: uint16(57462),
		121: uint16(57463),
		122: uint16(57464),
		123: uint16(57465),
		124: uint16(57466),
		125: uint16(57467),
		126: uint16(57468),
		127: uint16(57469),
		128: uint16(57470),
		129: uint16(57471),
		130: uint16(57472),
		131: uint16(57473),
		132: uint16(57474),
		133: uint16(57475),
		134: uint16(57476),
		135: uint16(57477),
		136: uint16(57478),
		137: uint16(57479),
		138: uint16(57480),
		139: uint16(57481),
		140: uint16(57482),
		141: uint16(57483),
		142: uint16(57484),
		143: uint16(57485),
		144: uint16(57486),
		145: uint16(57487),
		146: uint16(57488),
		147: uint16(57489),
		148: uint16(57490),
		149: uint16(57491),
		150: uint16(57492),
		151: uint16(57493),
		152: uint16(57494),
		153: uint16(57495),
		154: uint16(57496),
		155: uint16(57497),
		156: uint16(57498),
		157: uint16(57499),
		158: uint16(57500),
		159: uint16(57501),
		160: uint16(57502),
		161: uint16(57503),
		162: uint16(57504),
		163: uint16(57505),
		164: uint16(57506),
		165: uint16(57507),
		166: uint16(57508),
		167: uint16(57509),
		168: uint16(57510),
		169: uint16(57511),
		170: uint16(57512),
		171: uint16(57513),
		172: uint16(57514),
		173: uint16(57515),
		174: uint16(57516),
		175: uint16(57517),
		176: uint16(57518),
		177: uint16(57519),
		178: uint16(57520),
		179: uint16(57521),
		180: uint16(57522),
		181: uint16(57523),
		182: uint16(57524),
		183: uint16(57525),
		184: uint16(57526),
		185: uint16(57527),
		186: uint16(57528),
		187: uint16(57529),
		188: uint16(57530),
		189: uint16(57531),
	},
	43: {
		0:   uint16(29688),
		1:   uint16(29689),
		2:   uint16(29690),
		3:   uint16(29691),
		4:   uint16(29692),
		5:   uint16(29693),
		6:   uint16(29694),
		7:   uint16(29695),
		8:   uint16(29696),
		9:   uint16(29697),
		10:  uint16(29698),
		11:  uint16(29700),
		12:  uint16(29703),
		13:  uint16(29704),
		14:  uint16(29707),
		15:  uint16(29708),
		16:  uint16(29709),
		17:  uint16(29710),
		18:  uint16(29713),
		19:  uint16(29714),
		20:  uint16(29715),
		21:  uint16(29716),
		22:  uint16(29717),
		23:  uint16(29718),
		24:  uint16(29719),
		25:  uint16(29720),
		26:  uint16(29721),
		27:  uint16(29724),
		28:  uint16(29725),
		29:  uint16(29726),
		30:  uint16(29727),
		31:  uint16(29728),
		32:  uint16(29729),
		33:  uint16(29731),
		34:  uint16(29732),
		35:  uint16(29735),
		36:  uint16(29737),
		37:  uint16(29739),
		38:  uint16(29741),
		39:  uint16(29743),
		40:  uint16(29745),
		41:  uint16(29746),
		42:  uint16(29751),
		43:  uint16(29752),
		44:  uint16(29753),
		45:  uint16(29754),
		46:  uint16(29755),
		47:  uint16(29757),
		48:  uint16(29758),
		49:  uint16(29759),
		50:  uint16(29760),
		51:  uint16(29762),
		52:  uint16(29763),
		53:  uint16(29764),
		54:  uint16(29765),
		55:  uint16(29766),
		56:  uint16(29767),
		57:  uint16(29768),
		58:  uint16(29769),
		59:  uint16(29770),
		60:  uint16(29771),
		61:  uint16(29772),
		62:  uint16(29773),
		63:  uint16(29774),
		64:  uint16(29775),
		65:  uint16(29776),
		66:  uint16(29777),
		67:  uint16(29778),
		68:  uint16(29779),
		69:  uint16(29780),
		70:  uint16(29782),
		71:  uint16(29784),
		72:  uint16(29789),
		73:  uint16(29792),
		74:  uint16(29793),
		75:  uint16(29794),
		76:  uint16(29795),
		77:  uint16(29796),
		78:  uint16(29797),
		79:  uint16(29798),
		80:  uint16(29799),
		81:  uint16(29800),
		82:  uint16(29801),
		83:  uint16(29802),
		84:  uint16(29803),
		85:  uint16(29804),
		86:  uint16(29806),
		87:  uint16(29807),
		88:  uint16(29809),
		89:  uint16(29810),
		90:  uint16(29811),
		91:  uint16(29812),
		92:  uint16(29813),
		93:  uint16(29816),
		94:  uint16(29817),
		95:  uint16(29818),
		96:  uint16(57532),
		97:  uint16(57533),
		98:  uint16(57534),
		99:  uint16(57535),
		100: uint16(57536),
		101: uint16(57537),
		102: uint16(57538),
		103: uint16(57539),
		104: uint16(57540),
		105: uint16(57541),
		106: uint16(57542),
		107: uint16(57543),
		108: uint16(57544),
		109: uint16(57545),
		110: uint16(57546),
		111: uint16(57547),
		112: uint16(57548),
		113: uint16(57549),
		114: uint16(57550),
		115: uint16(57551),
		116: uint16(57552),
		117: uint16(57553),
		118: uint16(57554),
		119: uint16(57555),
		120: uint16(57556),
		121: uint16(57557),
		122: uint16(57558),
		123: uint16(57559),
		124: uint16(57560),
		125: uint16(57561),
		126: uint16(57562),
		127: uint16(57563),
		128: uint16(57564),
		129: uint16(57565),
		130: uint16(57566),
		131: uint16(57567),
		132: uint16(57568),
		133: uint16(57569),
		134: uint16(57570),
		135: uint16(57571),
		136: uint16(57572),
		137: uint16(57573),
		138: uint16(57574),
		139: uint16(57575),
		140: uint16(57576),
		141: uint16(57577),
		142: uint16(57578),
		143: uint16(57579),
		144: uint16(57580),
		145: uint16(57581),
		146: uint16(57582),
		147: uint16(57583),
		148: uint16(57584),
		149: uint16(57585),
		150: uint16(57586),
		151: uint16(57587),
		152: uint16(57588),
		153: uint16(57589),
		154: uint16(57590),
		155: uint16(57591),
		156: uint16(57592),
		157: uint16(57593),
		158: uint16(57594),
		159: uint16(57595),
		160: uint16(57596),
		161: uint16(57597),
		162: uint16(57598),
		163: uint16(57599),
		164: uint16(57600),
		165: uint16(57601),
		166: uint16(57602),
		167: uint16(57603),
		168: uint16(57604),
		169: uint16(57605),
		170: uint16(57606),
		171: uint16(57607),
		172: uint16(57608),
		173: uint16(57609),
		174: uint16(57610),
		175: uint16(57611),
		176: uint16(57612),
		177: uint16(57613),
		178: uint16(57614),
		179: uint16(57615),
		180: uint16(57616),
		181: uint16(57617),
		182: uint16(57618),
		183: uint16(57619),
		184: uint16(57620),
		185: uint16(57621),
		186: uint16(57622),
		187: uint16(57623),
		188: uint16(57624),
		189: uint16(57625),
	},
	44: {
		0:   uint16(29819),
		1:   uint16(29820),
		2:   uint16(29821),
		3:   uint16(29823),
		4:   uint16(29826),
		5:   uint16(29828),
		6:   uint16(29829),
		7:   uint16(29830),
		8:   uint16(29832),
		9:   uint16(29833),
		10:  uint16(29834),
		11:  uint16(29836),
		12:  uint16(29837),
		13:  uint16(29839),
		14:  uint16(29841),
		15:  uint16(29842),
		16:  uint16(29843),
		17:  uint16(29844),
		18:  uint16(29845),
		19:  uint16(29846),
		20:  uint16(29847),
		21:  uint16(29848),
		22:  uint16(29849),
		23:  uint16(29850),
		24:  uint16(29851),
		25:  uint16(29853),
		26:  uint16(29855),
		27:  uint16(29856),
		28:  uint16(29857),
		29:  uint16(29858),
		30:  uint16(29859),
		31:  uint16(29860),
		32:  uint16(29861),
		33:  uint16(29862),
		34:  uint16(29866),
		35:  uint16(29867),
		36:  uint16(29868),
		37:  uint16(29869),
		38:  uint16(29870),
		39:  uint16(29871),
		40:  uint16(29872),
		41:  uint16(29873),
		42:  uint16(29874),
		43:  uint16(29875),
		44:  uint16(29876),
		45:  uint16(29877),
		46:  uint16(29878),
		47:  uint16(29879),
		48:  uint16(29880),
		49:  uint16(29881),
		50:  uint16(29883),
		51:  uint16(29884),
		52:  uint16(29885),
		53:  uint16(29886),
		54:  uint16(29887),
		55:  uint16(29888),
		56:  uint16(29889),
		57:  uint16(29890),
		58:  uint16(29891),
		59:  uint16(29892),
		60:  uint16(29893),
		61:  uint16(29894),
		62:  uint16(29895),
		63:  uint16(29896),
		64:  uint16(29897),
		65:  uint16(29898),
		66:  uint16(29899),
		67:  uint16(29900),
		68:  uint16(29901),
		69:  uint16(29902),
		70:  uint16(29903),
		71:  uint16(29904),
		72:  uint16(29905),
		73:  uint16(29907),
		74:  uint16(29908),
		75:  uint16(29909),
		76:  uint16(29910),
		77:  uint16(29911),
		78:  uint16(29912),
		79:  uint16(29913),
		80:  uint16(29914),
		81:  uint16(29915),
		82:  uint16(29917),
		83:  uint16(29919),
		84:  uint16(29921),
		85:  uint16(29925),
		86:  uint16(29927),
		87:  uint16(29928),
		88:  uint16(29929),
		89:  uint16(29930),
		90:  uint16(29931),
		91:  uint16(29932),
		92:  uint16(29933),
		93:  uint16(29936),
		94:  uint16(29937),
		95:  uint16(29938),
		96:  uint16(57626),
		97:  uint16(57627),
		98:  uint16(57628),
		99:  uint16(57629),
		100: uint16(57630),
		101: uint16(57631),
		102: uint16(57632),
		103: uint16(57633),
		104: uint16(57634),
		105: uint16(57635),
		106: uint16(57636),
		107: uint16(57637),
		108: uint16(57638),
		109: uint16(57639),
		110: uint16(57640),
		111: uint16(57641),
		112: uint16(57642),
		113: uint16(57643),
		114: uint16(57644),
		115: uint16(57645),
		116: uint16(57646),
		117: uint16(57647),
		118: uint16(57648),
		119: uint16(57649),
		120: uint16(57650),
		121: uint16(57651),
		122: uint16(57652),
		123: uint16(57653),
		124: uint16(57654),
		125: uint16(57655),
		126: uint16(57656),
		127: uint16(57657),
		128: uint16(57658),
		129: uint16(57659),
		130: uint16(57660),
		131: uint16(57661),
		132: uint16(57662),
		133: uint16(57663),
		134: uint16(57664),
		135: uint16(57665),
		136: uint16(57666),
		137: uint16(57667),
		138: uint16(57668),
		139: uint16(57669),
		140: uint16(57670),
		141: uint16(57671),
		142: uint16(57672),
		143: uint16(57673),
		144: uint16(57674),
		145: uint16(57675),
		146: uint16(57676),
		147: uint16(57677),
		148: uint16(57678),
		149: uint16(57679),
		150: uint16(57680),
		151: uint16(57681),
		152: uint16(57682),
		153: uint16(57683),
		154: uint16(57684),
		155: uint16(57685),
		156: uint16(57686),
		157: uint16(57687),
		158: uint16(57688),
		159: uint16(57689),
		160: uint16(57690),
		161: uint16(57691),
		162: uint16(57692),
		163: uint16(57693),
		164: uint16(57694),
		165: uint16(57695),
		166: uint16(57696),
		167: uint16(57697),
		168: uint16(57698),
		169: uint16(57699),
		170: uint16(57700),
		171: uint16(57701),
		172: uint16(57702),
		173: uint16(57703),
		174: uint16(57704),
		175: uint16(57705),
		176: uint16(57706),
		177: uint16(57707),
		178: uint16(57708),
		179: uint16(57709),
		180: uint16(57710),
		181: uint16(57711),
		182: uint16(57712),
		183: uint16(57713),
		184: uint16(57714),
		185: uint16(57715),
		186: uint16(57716),
		187: uint16(57717),
		188: uint16(57718),
		189: uint16(57719),
	},
	45: {
		0:   uint16(29939),
		1:   uint16(29941),
		2:   uint16(29944),
		3:   uint16(29945),
		4:   uint16(29946),
		5:   uint16(29947),
		6:   uint16(29948),
		7:   uint16(29949),
		8:   uint16(29950),
		9:   uint16(29952),
		10:  uint16(29953),
		11:  uint16(29954),
		12:  uint16(29955),
		13:  uint16(29957),
		14:  uint16(29958),
		15:  uint16(29959),
		16:  uint16(29960),
		17:  uint16(29961),
		18:  uint16(29962),
		19:  uint16(29963),
		20:  uint16(29964),
		21:  uint16(29966),
		22:  uint16(29968),
		23:  uint16(29970),
		24:  uint16(29972),
		25:  uint16(29973),
		26:  uint16(29974),
		27:  uint16(29975),
		28:  uint16(29979),
		29:  uint16(29981),
		30:  uint16(29982),
		31:  uint16(29984),
		32:  uint16(29985),
		33:  uint16(29986),
		34:  uint16(29987),
		35:  uint16(29988),
		36:  uint16(29990),
		37:  uint16(29991),
		38:  uint16(29994),
		39:  uint16(29998),
		40:  uint16(30004),
		41:  uint16(30006),
		42:  uint16(30009),
		43:  uint16(30012),
		44:  uint16(30013),
		45:  uint16(30015),
		46:  uint16(30017),
		47:  uint16(30018),
		48:  uint16(30019),
		49:  uint16(30020),
		50:  uint16(30022),
		51:  uint16(30023),
		52:  uint16(30025),
		53:  uint16(30026),
		54:  uint16(30029),
		55:  uint16(30032),
		56:  uint16(30033),
		57:  uint16(30034),
		58:  uint16(30035),
		59:  uint16(30037),
		60:  uint16(30038),
		61:  uint16(30039),
		62:  uint16(30040),
		63:  uint16(30045),
		64:  uint16(30046),
		65:  uint16(30047),
		66:  uint16(30048),
		67:  uint16(30049),
		68:  uint16(30050),
		69:  uint16(30051),
		70:  uint16(30052),
		71:  uint16(30055),
		72:  uint16(30056),
		73:  uint16(30057),
		74:  uint16(30059),
		75:  uint16(30060),
		76:  uint16(30061),
		77:  uint16(30062),
		78:  uint16(30063),
		79:  uint16(30064),
		80:  uint16(30065),
		81:  uint16(30067),
		82:  uint16(30069),
		83:  uint16(30070),
		84:  uint16(30071),
		85:  uint16(30074),
		86:  uint16(30075),
		87:  uint16(30076),
		88:  uint16(30077),
		89:  uint16(30078),
		90:  uint16(30080),
		91:  uint16(30081),
		92:  uint16(30082),
		93:  uint16(30084),
		94:  uint16(30085),
		95:  uint16(30087),
		96:  uint16(57720),
		97:  uint16(57721),
		98:  uint16(57722),
		99:  uint16(57723),
		100: uint16(57724),
		101: uint16(57725),
		102: uint16(57726),
		103: uint16(57727),
		104: uint16(57728),
		105: uint16(57729),
		106: uint16(57730),
		107: uint16(57731),
		108: uint16(57732),
		109: uint16(57733),
		110: uint16(57734),
		111: uint16(57735),
		112: uint16(57736),
		113: uint16(57737),
		114: uint16(57738),
		115: uint16(57739),
		116: uint16(57740),
		117: uint16(57741),
		118: uint16(57742),
		119: uint16(57743),
		120: uint16(57744),
		121: uint16(57745),
		122: uint16(57746),
		123: uint16(57747),
		124: uint16(57748),
		125: uint16(57749),
		126: uint16(57750),
		127: uint16(57751),
		128: uint16(57752),
		129: uint16(57753),
		130: uint16(57754),
		131: uint16(57755),
		132: uint16(57756),
		133: uint16(57757),
		134: uint16(57758),
		135: uint16(57759),
		136: uint16(57760),
		137: uint16(57761),
		138: uint16(57762),
		139: uint16(57763),
		140: uint16(57764),
		141: uint16(57765),
		142: uint16(57766),
		143: uint16(57767),
		144: uint16(57768),
		145: uint16(57769),
		146: uint16(57770),
		147: uint16(57771),
		148: uint16(57772),
		149: uint16(57773),
		150: uint16(57774),
		151: uint16(57775),
		152: uint16(57776),
		153: uint16(57777),
		154: uint16(57778),
		155: uint16(57779),
		156: uint16(57780),
		157: uint16(57781),
		158: uint16(57782),
		159: uint16(57783),
		160: uint16(57784),
		161: uint16(57785),
		162: uint16(57786),
		163: uint16(57787),
		164: uint16(57788),
		165: uint16(57789),
		166: uint16(57790),
		167: uint16(57791),
		168: uint16(57792),
		169: uint16(57793),
		170: uint16(57794),
		171: uint16(57795),
		172: uint16(57796),
		173: uint16(57797),
		174: uint16(57798),
		175: uint16(57799),
		176: uint16(57800),
		177: uint16(57801),
		178: uint16(57802),
		179: uint16(57803),
		180: uint16(57804),
		181: uint16(57805),
		182: uint16(57806),
		183: uint16(57807),
		184: uint16(57808),
		185: uint16(57809),
		186: uint16(57810),
		187: uint16(57811),
		188: uint16(57812),
		189: uint16(57813),
	},
	46: {
		0:   uint16(30088),
		1:   uint16(30089),
		2:   uint16(30090),
		3:   uint16(30092),
		4:   uint16(30093),
		5:   uint16(30094),
		6:   uint16(30096),
		7:   uint16(30099),
		8:   uint16(30101),
		9:   uint16(30104),
		10:  uint16(30107),
		11:  uint16(30108),
		12:  uint16(30110),
		13:  uint16(30114),
		14:  uint16(30118),
		15:  uint16(30119),
		16:  uint16(30120),
		17:  uint16(30121),
		18:  uint16(30122),
		19:  uint16(30125),
		20:  uint16(30134),
		21:  uint16(30135),
		22:  uint16(30138),
		23:  uint16(30139),
		24:  uint16(30143),
		25:  uint16(30144),
		26:  uint16(30145),
		27:  uint16(30150),
		28:  uint16(30155),
		29:  uint16(30156),
		30:  uint16(30158),
		31:  uint16(30159),
		32:  uint16(30160),
		33:  uint16(30161),
		34:  uint16(30163),
		35:  uint16(30167),
		36:  uint16(30169),
		37:  uint16(30170),
		38:  uint16(30172),
		39:  uint16(30173),
		40:  uint16(30175),
		41:  uint16(30176),
		42:  uint16(30177),
		43:  uint16(30181),
		44:  uint16(30185),
		45:  uint16(30188),
		46:  uint16(30189),
		47:  uint16(30190),
		48:  uint16(30191),
		49:  uint16(30194),
		50:  uint16(30195),
		51:  uint16(30197),
		52:  uint16(30198),
		53:  uint16(30199),
		54:  uint16(30200),
		55:  uint16(30202),
		56:  uint16(30203),
		57:  uint16(30205),
		58:  uint16(30206),
		59:  uint16(30210),
		60:  uint16(30212),
		61:  uint16(30214),
		62:  uint16(30215),
		63:  uint16(30216),
		64:  uint16(30217),
		65:  uint16(30219),
		66:  uint16(30221),
		67:  uint16(30222),
		68:  uint16(30223),
		69:  uint16(30225),
		70:  uint16(30226),
		71:  uint16(30227),
		72:  uint16(30228),
		73:  uint16(30230),
		74:  uint16(30234),
		75:  uint16(30236),
		76:  uint16(30237),
		77:  uint16(30238),
		78:  uint16(30241),
		79:  uint16(30243),
		80:  uint16(30247),
		81:  uint16(30248),
		82:  uint16(30252),
		83:  uint16(30254),
		84:  uint16(30255),
		85:  uint16(30257),
		86:  uint16(30258),
		87:  uint16(30262),
		88:  uint16(30263),
		89:  uint16(30265),
		90:  uint16(30266),
		91:  uint16(30267),
		92:  uint16(30269),
		93:  uint16(30273),
		94:  uint16(30274),
		95:  uint16(30276),
		96:  uint16(57814),
		97:  uint16(57815),
		98:  uint16(57816),
		99:  uint16(57817),
		100: uint16(57818),
		101: uint16(57819),
		102: uint16(57820),
		103: uint16(57821),
		104: uint16(57822),
		105: uint16(57823),
		106: uint16(57824),
		107: uint16(57825),
		108: uint16(57826),
		109: uint16(57827),
		110: uint16(57828),
		111: uint16(57829),
		112: uint16(57830),
		113: uint16(57831),
		114: uint16(57832),
		115: uint16(57833),
		116: uint16(57834),
		117: uint16(57835),
		118: uint16(57836),
		119: uint16(57837),
		120: uint16(57838),
		121: uint16(57839),
		122: uint16(57840),
		123: uint16(57841),
		124: uint16(57842),
		125: uint16(57843),
		126: uint16(57844),
		127: uint16(57845),
		128: uint16(57846),
		129: uint16(57847),
		130: uint16(57848),
		131: uint16(57849),
		132: uint16(57850),
		133: uint16(57851),
		134: uint16(57852),
		135: uint16(57853),
		136: uint16(57854),
		137: uint16(57855),
		138: uint16(57856),
		139: uint16(57857),
		140: uint16(57858),
		141: uint16(57859),
		142: uint16(57860),
		143: uint16(57861),
		144: uint16(57862),
		145: uint16(57863),
		146: uint16(57864),
		147: uint16(57865),
		148: uint16(57866),
		149: uint16(57867),
		150: uint16(57868),
		151: uint16(57869),
		152: uint16(57870),
		153: uint16(57871),
		154: uint16(57872),
		155: uint16(57873),
		156: uint16(57874),
		157: uint16(57875),
		158: uint16(57876),
		159: uint16(57877),
		160: uint16(57878),
		161: uint16(57879),
		162: uint16(57880),
		163: uint16(57881),
		164: uint16(57882),
		165: uint16(57883),
		166: uint16(57884),
		167: uint16(57885),
		168: uint16(57886),
		169: uint16(57887),
		170: uint16(57888),
		171: uint16(57889),
		172: uint16(57890),
		173: uint16(57891),
		174: uint16(57892),
		175: uint16(57893),
		176: uint16(57894),
		177: uint16(57895),
		178: uint16(57896),
		179: uint16(57897),
		180: uint16(57898),
		181: uint16(57899),
		182: uint16(57900),
		183: uint16(57901),
		184: uint16(57902),
		185: uint16(57903),
		186: uint16(57904),
		187: uint16(57905),
		188: uint16(57906),
		189: uint16(57907),
	},
	47: {
		0:   uint16(30277),
		1:   uint16(30278),
		2:   uint16(30279),
		3:   uint16(30280),
		4:   uint16(30281),
		5:   uint16(30282),
		6:   uint16(30283),
		7:   uint16(30286),
		8:   uint16(30287),
		9:   uint16(30288),
		10:  uint16(30289),
		11:  uint16(30290),
		12:  uint16(30291),
		13:  uint16(30293),
		14:  uint16(30295),
		15:  uint16(30296),
		16:  uint16(30297),
		17:  uint16(30298),
		18:  uint16(30299),
		19:  uint16(30301),
		20:  uint16(30303),
		21:  uint16(30304),
		22:  uint16(30305),
		23:  uint16(30306),
		24:  uint16(30308),
		25:  uint16(30309),
		26:  uint16(30310),
		27:  uint16(30311),
		28:  uint16(30312),
		29:  uint16(30313),
		30:  uint16(30314),
		31:  uint16(30316),
		32:  uint16(30317),
		33:  uint16(30318),
		34:  uint16(30320),
		35:  uint16(30321),
		36:  uint16(30322),
		37:  uint16(30323),
		38:  uint16(30324),
		39:  uint16(30325),
		40:  uint16(30326),
		41:  uint16(30327),
		42:  uint16(30329),
		43:  uint16(30330),
		44:  uint16(30332),
		45:  uint16(30335),
		46:  uint16(30336),
		47:  uint16(30337),
		48:  uint16(30339),
		49:  uint16(30341),
		50:  uint16(30345),
		51:  uint16(30346),
		52:  uint16(30348),
		53:  uint16(30349),
		54:  uint16(30351),
		55:  uint16(30352),
		56:  uint16(30354),
		57:  uint16(30356),
		58:  uint16(30357),
		59:  uint16(30359),
		60:  uint16(30360),
		61:  uint16(30362),
		62:  uint16(30363),
		63:  uint16(30364),
		64:  uint16(30365),
		65:  uint16(30366),
		66:  uint16(30367),
		67:  uint16(30368),
		68:  uint16(30369),
		69:  uint16(30370),
		70:  uint16(30371),
		71:  uint16(30373),
		72:  uint16(30374),
		73:  uint16(30375),
		74:  uint16(30376),
		75:  uint16(30377),
		76:  uint16(30378),
		77:  uint16(30379),
		78:  uint16(30380),
		79:  uint16(30381),
		80:  uint16(30383),
		81:  uint16(30384),
		82:  uint16(30387),
		83:  uint16(30389),
		84:  uint16(30390),
		85:  uint16(30391),
		86:  uint16(30392),
		87:  uint16(30393),
		88:  uint16(30394),
		89:  uint16(30395),
		90:  uint16(30396),
		91:  uint16(30397),
		92:  uint16(30398),
		93:  uint16(30400),
		94:  uint16(30401),
		95:  uint16(30403),
		96:  uint16(21834),
		97:  uint16(38463),
		98:  uint16(22467),
		99:  uint16(25384),
		100: uint16(21710),
		101: uint16(21769),
		102: uint16(21696),
		103: uint16(30353),
		104: uint16(30284),
		105: uint16(34108),
		106: uint16(30702),
		107: uint16(33406),
		108: uint16(30861),
		109: uint16(29233),
		110: uint16(38552),
		111: uint16(38797),
		112: uint16(27688),
		113: uint16(23433),
		114: uint16(20474),
		115: uint16(25353),
		116: uint16(26263),
		117: uint16(23736),
		118: uint16(33018),
		119: uint16(26696),
		120: uint16(32942),
		121: uint16(26114),
		122: uint16(30414),
		123: uint16(20985),
		124: uint16(25942),
		125: uint16(29100),
		126: uint16(32753),
		127: uint16(34948),
		128: uint16(20658),
		129: uint16(22885),
		130: uint16(25034),
		131: uint16(28595),
		132: uint16(33453),
		133: uint16(25420),
		134: uint16(25170),
		135: uint16(21485),
		136: uint16(21543),
		137: uint16(31494),
		138: uint16(20843),
		139: uint16(30116),
		140: uint16(24052),
		141: uint16(25300),
		142: uint16(36299),
		143: uint16(38774),
		144: uint16(25226),
		145: uint16(32793),
		146: uint16(22365),
		147: uint16(38712),
		148: uint16(32610),
		149: uint16(29240),
		150: uint16(30333),
		151: uint16(26575),
		152: uint16(30334),
		153: uint16(25670),
		154: uint16(20336),
		155: uint16(36133),
		156: uint16(25308),
		157: uint16(31255),
		158: uint16(26001),
		159: uint16(29677),
		160: uint16(25644),
		161: uint16(25203),
		162: uint16(33324),
		163: uint16(39041),
		164: uint16(26495),
		165: uint16(29256),
		166: uint16(25198),
		167: uint16(25292),
		168: uint16(20276),
		169: uint16(29923),
		170: uint16(21322),
		171: uint16(21150),
		172: uint16(32458),
		173: uint16(37030),
		174: uint16(24110),
		175: uint16(26758),
		176: uint16(27036),
		177: uint16(33152),
		178: uint16(32465),
		179: uint16(26834),
		180: uint16(30917),
		181: uint16(34444),
		182: uint16(38225),
		183: uint16(20621),
		184: uint16(35876),
		185: uint16(33502),
		186: uint16(32990),
		187: uint16(21253),
		188: uint16(35090),
		189: uint16(21093),
	},
	48: {
		0:   uint16(30404),
		1:   uint16(30407),
		2:   uint16(30409),
		3:   uint16(30411),
		4:   uint16(30412),
		5:   uint16(30419),
		6:   uint16(30421),
		7:   uint16(30425),
		8:   uint16(30426),
		9:   uint16(30428),
		10:  uint16(30429),
		11:  uint16(30430),
		12:  uint16(30432),
		13:  uint16(30433),
		14:  uint16(30434),
		15:  uint16(30435),
		16:  uint16(30436),
		17:  uint16(30438),
		18:  uint16(30439),
		19:  uint16(30440),
		20:  uint16(30441),
		21:  uint16(30442),
		22:  uint16(30443),
		23:  uint16(30444),
		24:  uint16(30445),
		25:  uint16(30448),
		26:  uint16(30451),
		27:  uint16(30453),
		28:  uint16(30454),
		29:  uint16(30455),
		30:  uint16(30458),
		31:  uint16(30459),
		32:  uint16(30461),
		33:  uint16(30463),
		34:  uint16(30464),
		35:  uint16(30466),
		36:  uint16(30467),
		37:  uint16(30469),
		38:  uint16(30470),
		39:  uint16(30474),
		40:  uint16(30476),
		41:  uint16(30478),
		42:  uint16(30479),
		43:  uint16(30480),
		44:  uint16(30481),
		45:  uint16(30482),
		46:  uint16(30483),
		47:  uint16(30484),
		48:  uint16(30485),
		49:  uint16(30486),
		50:  uint16(30487),
		51:  uint16(30488),
		52:  uint16(30491),
		53:  uint16(30492),
		54:  uint16(30493),
		55:  uint16(30494),
		56:  uint16(30497),
		57:  uint16(30499),
		58:  uint16(30500),
		59:  uint16(30501),
		60:  uint16(30503),
		61:  uint16(30506),
		62:  uint16(30507),
		63:  uint16(30508),
		64:  uint16(30510),
		65:  uint16(30512),
		66:  uint16(30513),
		67:  uint16(30514),
		68:  uint16(30515),
		69:  uint16(30516),
		70:  uint16(30521),
		71:  uint16(30523),
		72:  uint16(30525),
		73:  uint16(30526),
		74:  uint16(30527),
		75:  uint16(30530),
		76:  uint16(30532),
		77:  uint16(30533),
		78:  uint16(30534),
		79:  uint16(30536),
		80:  uint16(30537),
		81:  uint16(30538),
		82:  uint16(30539),
		83:  uint16(30540),
		84:  uint16(30541),
		85:  uint16(30542),
		86:  uint16(30543),
		87:  uint16(30546),
		88:  uint16(30547),
		89:  uint16(30548),
		90:  uint16(30549),
		91:  uint16(30550),
		92:  uint16(30551),
		93:  uint16(30552),
		94:  uint16(30553),
		95:  uint16(30556),
		96:  uint16(34180),
		97:  uint16(38649),
		98:  uint16(20445),
		99:  uint16(22561),
		100: uint16(39281),
		101: uint16(23453),
		102: uint16(25265),
		103: uint16(25253),
		104: uint16(26292),
		105: uint16(35961),
		106: uint16(40077),
		107: uint16(29190),
		108: uint16(26479),
		109: uint16(30865),
		110: uint16(24754),
		111: uint16(21329),
		112: uint16(21271),
		113: uint16(36744),
		114: uint16(32972),
		115: uint16(36125),
		116: uint16(38049),
		117: uint16(20493),
		118: uint16(29384),
		119: uint16(22791),
		120: uint16(24811),
		121: uint16(28953),
		122: uint16(34987),
		123: uint16(22868),
		124: uint16(33519),
		125: uint16(26412),
		126: uint16(31528),
		127: uint16(23849),
		128: uint16(32503),
		129: uint16(29997),
		130: uint16(27893),
		131: uint16(36454),
		132: uint16(36856),
		133: uint16(36924),
		134: uint16(40763),
		135: uint16(27604),
		136: uint16(37145),
		137: uint16(31508),
		138: uint16(24444),
		139: uint16(30887),
		140: uint16(34006),
		141: uint16(34109),
		142: uint16(27605),
		143: uint16(27609),
		144: uint16(27606),
		145: uint16(24065),
		146: uint16(24199),
		147: uint16(30201),
		148: uint16(38381),
		149: uint16(25949),
		150: uint16(24330),
		151: uint16(24517),
		152: uint16(36767),
		153: uint16(22721),
		154: uint16(33218),
		155: uint16(36991),
		156: uint16(38491),
		157: uint16(38829),
		158: uint16(36793),
		159: uint16(32534),
		160: uint16(36140),
		161: uint16(25153),
		162: uint16(20415),
		163: uint16(21464),
		164: uint16(21342),
		165: uint16(36776),
		166: uint16(36777),
		167: uint16(36779),
		168: uint16(36941),
		169: uint16(26631),
		170: uint16(24426),
		171: uint16(33176),
		172: uint16(34920),
		173: uint16(40150),
		174: uint16(24971),
		175: uint16(21035),
		176: uint16(30250),
		177: uint16(24428),
		178: uint16(25996),
		179: uint16(28626),
		180: uint16(28392),
		181: uint16(23486),
		182: uint16(25672),
		183: uint16(20853),
		184: uint16(20912),
		185: uint16(26564),
		186: uint16(19993),
		187: uint16(31177),
		188: uint16(39292),
		189: uint16(28851),
	},
	49: {
		0:   uint16(30557),
		1:   uint16(30558),
		2:   uint16(30559),
		3:   uint16(30560),
		4:   uint16(30564),
		5:   uint16(30567),
		6:   uint16(30569),
		7:   uint16(30570),
		8:   uint16(30573),
		9:   uint16(30574),
		10:  uint16(30575),
		11:  uint16(30576),
		12:  uint16(30577),
		13:  uint16(30578),
		14:  uint16(30579),
		15:  uint16(30580),
		16:  uint16(30581),
		17:  uint16(30582),
		18:  uint16(30583),
		19:  uint16(30584),
		20:  uint16(30586),
		21:  uint16(30587),
		22:  uint16(30588),
		23:  uint16(30593),
		24:  uint16(30594),
		25:  uint16(30595),
		26:  uint16(30598),
		27:  uint16(30599),
		28:  uint16(30600),
		29:  uint16(30601),
		30:  uint16(30602),
		31:  uint16(30603),
		32:  uint16(30607),
		33:  uint16(30608),
		34:  uint16(30611),
		35:  uint16(30612),
		36:  uint16(30613),
		37:  uint16(30614),
		38:  uint16(30615),
		39:  uint16(30616),
		40:  uint16(30617),
		41:  uint16(30618),
		42:  uint16(30619),
		43:  uint16(30620),
		44:  uint16(30621),
		45:  uint16(30622),
		46:  uint16(30625),
		47:  uint16(30627),
		48:  uint16(30628),
		49:  uint16(30630),
		50:  uint16(30632),
		51:  uint16(30635),
		52:  uint16(30637),
		53:  uint16(30638),
		54:  uint16(30639),
		55:  uint16(30641),
		56:  uint16(30642),
		57:  uint16(30644),
		58:  uint16(30646),
		59:  uint16(30647),
		60:  uint16(30648),
		61:  uint16(30649),
		62:  uint16(30650),
		63:  uint16(30652),
		64:  uint16(30654),
		65:  uint16(30656),
		66:  uint16(30657),
		67:  uint16(30658),
		68:  uint16(30659),
		69:  uint16(30660),
		70:  uint16(30661),
		71:  uint16(30662),
		72:  uint16(30663),
		73:  uint16(30664),
		74:  uint16(30665),
		75:  uint16(30666),
		76:  uint16(30667),
		77:  uint16(30668),
		78:  uint16(30670),
		79:  uint16(30671),
		80:  uint16(30672),
		81:  uint16(30673),
		82:  uint16(30674),
		83:  uint16(30675),
		84:  uint16(30676),
		85:  uint16(30677),
		86:  uint16(30678),
		87:  uint16(30680),
		88:  uint16(30681),
		89:  uint16(30682),
		90:  uint16(30685),
		91:  uint16(30686),
		92:  uint16(30687),
		93:  uint16(30688),
		94:  uint16(30689),
		95:  uint16(30692),
		96:  uint16(30149),
		97:  uint16(24182),
		98:  uint16(29627),
		99:  uint16(33760),
		100: uint16(25773),
		101: uint16(25320),
		102: uint16(38069),
		103: uint16(27874),
		104: uint16(21338),
		105: uint16(21187),
		106: uint16(25615),
		107: uint16(38082),
		108: uint16(31636),
		109: uint16(20271),
		110: uint16(24091),
		111: uint16(33334),
		112: uint16(33046),
		113: uint16(33162),
		114: uint16(28196),
		115: uint16(27850),
		116: uint16(39539),
		117: uint16(25429),
		118: uint16(21340),
		119: uint16(21754),
		120: uint16(34917),
		121: uint16(22496),
		122: uint16(19981),
		123: uint16(24067),
		124: uint16(27493),
		125: uint16(31807),
		126: uint16(37096),
		127: uint16(24598),
		128: uint16(25830),
		129: uint16(29468),
		130: uint16(35009),
		131: uint16(26448),
		132: uint16(25165),
		133: uint16(36130),
		134: uint16(30572),
		135: uint16(36393),
		136: uint16(37319),
		137: uint16(24425),
		138: uint16(33756),
		139: uint16(34081),
		140: uint16(39184),
		141: uint16(21442),
		142: uint16(34453),
		143: uint16(27531),
		144: uint16(24813),
		145: uint16(24808),
		146: uint16(28799),
		147: uint16(33485),
		148: uint16(33329),
		149: uint16(20179),
		150: uint16(27815),
		151: uint16(34255),
		152: uint16(25805),
		153: uint16(31961),
		154: uint16(27133),
		155: uint16(26361),
		156: uint16(33609),
		157: uint16(21397),
		158: uint16(31574),
		159: uint16(20391),
		160: uint16(20876),
		161: uint16(27979),
		162: uint16(23618),
		163: uint16(36461),
		164: uint16(25554),
		165: uint16(21449),
		166: uint16(33580),
		167: uint16(33590),
		168: uint16(26597),
		169: uint16(30900),
		170: uint16(25661),
		171: uint16(23519),
		172: uint16(23700),
		173: uint16(24046),
		174: uint16(35815),
		175: uint16(25286),
		176: uint16(26612),
		177: uint16(35962),
		178: uint16(25600),
		179: uint16(25530),
		180: uint16(34633),
		181: uint16(39307),
		182: uint16(35863),
		183: uint16(32544),
		184: uint16(38130),
		185: uint16(20135),
		186: uint16(38416),
		187: uint16(39076),
		188: uint16(26124),
		189: uint16(29462),
	},
	50: {
		0:   uint16(30694),
		1:   uint16(30696),
		2:   uint16(30698),
		3:   uint16(30703),
		4:   uint16(30704),
		5:   uint16(30705),
		6:   uint16(30706),
		7:   uint16(30708),
		8:   uint16(30709),
		9:   uint16(30711),
		10:  uint16(30713),
		11:  uint16(30714),
		12:  uint16(30715),
		13:  uint16(30716),
		14:  uint16(30723),
		15:  uint16(30724),
		16:  uint16(30725),
		17:  uint16(30726),
		18:  uint16(30727),
		19:  uint16(30728),
		20:  uint16(30730),
		21:  uint16(30731),
		22:  uint16(30734),
		23:  uint16(30735),
		24:  uint16(30736),
		25:  uint16(30739),
		26:  uint16(30741),
		27:  uint16(30745),
		28:  uint16(30747),
		29:  uint16(30750),
		30:  uint16(30752),
		31:  uint16(30753),
		32:  uint16(30754),
		33:  uint16(30756),
		34:  uint16(30760),
		35:  uint16(30762),
		36:  uint16(30763),
		37:  uint16(30766),
		38:  uint16(30767),
		39:  uint16(30769),
		40:  uint16(30770),
		41:  uint16(30771),
		42:  uint16(30773),
		43:  uint16(30774),
		44:  uint16(30781),
		45:  uint16(30783),
		46:  uint16(30785),
		47:  uint16(30786),
		48:  uint16(30787),
		49:  uint16(30788),
		50:  uint16(30790),
		51:  uint16(30792),
		52:  uint16(30793),
		53:  uint16(30794),
		54:  uint16(30795),
		55:  uint16(30797),
		56:  uint16(30799),
		57:  uint16(30801),
		58:  uint16(30803),
		59:  uint16(30804),
		60:  uint16(30808),
		61:  uint16(30809),
		62:  uint16(30810),
		63:  uint16(30811),
		64:  uint16(30812),
		65:  uint16(30814),
		66:  uint16(30815),
		67:  uint16(30816),
		68:  uint16(30817),
		69:  uint16(30818),
		70:  uint16(30819),
		71:  uint16(30820),
		72:  uint16(30821),
		73:  uint16(30822),
		74:  uint16(30823),
		75:  uint16(30824),
		76:  uint16(30825),
		77:  uint16(30831),
		78:  uint16(30832),
		79:  uint16(30833),
		80:  uint16(30834),
		81:  uint16(30835),
		82:  uint16(30836),
		83:  uint16(30837),
		84:  uint16(30838),
		85:  uint16(30840),
		86:  uint16(30841),
		87:  uint16(30842),
		88:  uint16(30843),
		89:  uint16(30845),
		90:  uint16(30846),
		91:  uint16(30847),
		92:  uint16(30848),
		93:  uint16(30849),
		94:  uint16(30850),
		95:  uint16(30851),
		96:  uint16(22330),
		97:  uint16(23581),
		98:  uint16(24120),
		99:  uint16(38271),
		100: uint16(20607),
		101: uint16(32928),
		102: uint16(21378),
		103: uint16(25950),
		104: uint16(30021),
		105: uint16(21809),
		106: uint16(20513),
		107: uint16(36229),
		108: uint16(25220),
		109: uint16(38046),
		110: uint16(26397),
		111: uint16(22066),
		112: uint16(28526),
		113: uint16(24034),
		114: uint16(21557),
		115: uint16(28818),
		116: uint16(36710),
		117: uint16(25199),
		118: uint16(25764),
		119: uint16(25507),
		120: uint16(24443),
		121: uint16(28552),
		122: uint16(37108),
		123: uint16(33251),
		124: uint16(36784),
		125: uint16(23576),
		126: uint16(26216),
		127: uint16(24561),
		128: uint16(27785),
		129: uint16(38472),
		130: uint16(36225),
		131: uint16(34924),
		132: uint16(25745),
		133: uint16(31216),
		134: uint16(22478),
		135: uint16(27225),
		136: uint16(25104),
		137: uint16(21576),
		138: uint16(20056),
		139: uint16(31243),
		140: uint16(24809),
		141: uint16(28548),
		142: uint16(35802),
		143: uint16(25215),
		144: uint16(36894),
		145: uint16(39563),
		146: uint16(31204),
		147: uint16(21507),
		148: uint16(30196),
		149: uint16(25345),
		150: uint16(21273),
		151: uint16(27744),
		152: uint16(36831),
		153: uint16(24347),
		154: uint16(39536),
		155: uint16(32827),
		156: uint16(40831),
		157: uint16(20360),
		158: uint16(23610),
		159: uint16(36196),
		160: uint16(32709),
		161: uint16(26021),
		162: uint16(28861),
		163: uint16(20805),
		164: uint16(20914),
		165: uint16(34411),
		166: uint16(23815),
		167: uint16(23456),
		168: uint16(25277),
		169: uint16(37228),
		170: uint16(30068),
		171: uint16(36364),
		172: uint16(31264),
		173: uint16(24833),
		174: uint16(31609),
		175: uint16(20167),
		176: uint16(32504),
		177: uint16(30597),
		178: uint16(19985),
		179: uint16(33261),
		180: uint16(21021),
		181: uint16(20986),
		182: uint16(27249),
		183: uint16(21416),
		184: uint16(36487),
		185: uint16(38148),
		186: uint16(38607),
		187: uint16(28353),
		188: uint16(38500),
		189: uint16(26970),
	},
	51: {
		0:   uint16(30852),
		1:   uint16(30853),
		2:   uint16(30854),
		3:   uint16(30856),
		4:   uint16(30858),
		5:   uint16(30859),
		6:   uint16(30863),
		7:   uint16(30864),
		8:   uint16(30866),
		9:   uint16(30868),
		10:  uint16(30869),
		11:  uint16(30870),
		12:  uint16(30873),
		13:  uint16(30877),
		14:  uint16(30878),
		15:  uint16(30880),
		16:  uint16(30882),
		17:  uint16(30884),
		18:  uint16(30886),
		19:  uint16(30888),
		20:  uint16(30889),
		21:  uint16(30890),
		22:  uint16(30891),
		23:  uint16(30892),
		24:  uint16(30893),
		25:  uint16(30894),
		26:  uint16(30895),
		27:  uint16(30901),
		28:  uint16(30902),
		29:  uint16(30903),
		30:  uint16(30904),
		31:  uint16(30906),
		32:  uint16(30907),
		33:  uint16(30908),
		34:  uint16(30909),
		35:  uint16(30911),
		36:  uint16(30912),
		37:  uint16(30914),
		38:  uint16(30915),
		39:  uint16(30916),
		40:  uint16(30918),
		41:  uint16(30919),
		42:  uint16(30920),
		43:  uint16(30924),
		44:  uint16(30925),
		45:  uint16(30926),
		46:  uint16(30927),
		47:  uint16(30929),
		48:  uint16(30930),
		49:  uint16(30931),
		50:  uint16(30934),
		51:  uint16(30935),
		52:  uint16(30936),
		53:  uint16(30938),
		54:  uint16(30939),
		55:  uint16(30940),
		56:  uint16(30941),
		57:  uint16(30942),
		58:  uint16(30943),
		59:  uint16(30944),
		60:  uint16(30945),
		61:  uint16(30946),
		62:  uint16(30947),
		63:  uint16(30948),
		64:  uint16(30949),
		65:  uint16(30950),
		66:  uint16(30951),
		67:  uint16(30953),
		68:  uint16(30954),
		69:  uint16(30955),
		70:  uint16(30957),
		71:  uint16(30958),
		72:  uint16(30959),
		73:  uint16(30960),
		74:  uint16(30961),
		75:  uint16(30963),
		76:  uint16(30965),
		77:  uint16(30966),
		78:  uint16(30968),
		79:  uint16(30969),
		80:  uint16(30971),
		81:  uint16(30972),
		82:  uint16(30973),
		83:  uint16(30974),
		84:  uint16(30975),
		85:  uint16(30976),
		86:  uint16(30978),
		87:  uint16(30979),
		88:  uint16(30980),
		89:  uint16(30982),
		90:  uint16(30983),
		91:  uint16(30984),
		92:  uint16(30985),
		93:  uint16(30986),
		94:  uint16(30987),
		95:  uint16(30988),
		96:  uint16(30784),
		97:  uint16(20648),
		98:  uint16(30679),
		99:  uint16(25616),
		100: uint16(35302),
		101: uint16(22788),
		102: uint16(25571),
		103: uint16(24029),
		104: uint16(31359),
		105: uint16(26941),
		106: uint16(20256),
		107: uint16(33337),
		108: uint16(21912),
		109: uint16(20018),
		110: uint16(30126),
		111: uint16(31383),
		112: uint16(24162),
		113: uint16(24202),
		114: uint16(38383),
		115: uint16(21019),
		116: uint16(21561),
		117: uint16(28810),
		118: uint16(25462),
		119: uint16(38180),
		120: uint16(22402),
		121: uint16(26149),
		122: uint16(26943),
		123: uint16(37255),
		124: uint16(21767),
		125: uint16(28147),
		126: uint16(32431),
		127: uint16(34850),
		128: uint16(25139),
		129: uint16(32496),
		130: uint16(30133),
		131: uint16(33576),
		132: uint16(30913),
		133: uint16(38604),
		134: uint16(36766),
		135: uint16(24904),
		136: uint16(29943),
		137: uint16(35789),
		138: uint16(27492),
		139: uint16(21050),
		140: uint16(36176),
		141: uint16(27425),
		142: uint16(32874),
		143: uint16(33905),
		144: uint16(22257),
		145: uint16(21254),
		146: uint16(20174),
		147: uint16(19995),
		148: uint16(20945),
		149: uint16(31895),
		150: uint16(37259),
		151: uint16(31751),
		152: uint16(20419),
		153: uint16(36479),
		154: uint16(31713),
		155: uint16(31388),
		156: uint16(25703),
		157: uint16(23828),
		158: uint16(20652),
		159: uint16(33030),
		160: uint16(30209),
		161: uint16(31929),
		162: uint16(28140),
		163: uint16(32736),
		164: uint16(26449),
		165: uint16(23384),
		166: uint16(23544),
		167: uint16(30923),
		168: uint16(25774),
		169: uint16(25619),
		170: uint16(25514),
		171: uint16(25387),
		172: uint16(38169),
		173: uint16(25645),
		174: uint16(36798),
		175: uint16(31572),
		176: uint16(30249),
		177: uint16(25171),
		178: uint16(22823),
		179: uint16(21574),
		180: uint16(27513),
		181: uint16(20643),
		182: uint16(25140),
		183: uint16(24102),
		184: uint16(27526),
		185: uint16(20195),
		186: uint16(36151),
		187: uint16(34955),
		188: uint16(24453),
		189: uint16(36910),
	},
	52: {
		0:   uint16(30989),
		1:   uint16(30990),
		2:   uint16(30991),
		3:   uint16(30992),
		4:   uint16(30993),
		5:   uint16(30994),
		6:   uint16(30996),
		7:   uint16(30997),
		8:   uint16(30998),
		9:   uint16(30999),
		10:  uint16(31000),
		11:  uint16(31001),
		12:  uint16(31002),
		13:  uint16(31003),
		14:  uint16(31004),
		15:  uint16(31005),
		16:  uint16(31007),
		17:  uint16(31008),
		18:  uint16(31009),
		19:  uint16(31010),
		20:  uint16(31011),
		21:  uint16(31013),
		22:  uint16(31014),
		23:  uint16(31015),
		24:  uint16(31016),
		25:  uint16(31017),
		26:  uint16(31018),
		27:  uint16(31019),
		28:  uint16(31020),
		29:  uint16(31021),
		30:  uint16(31022),
		31:  uint16(31023),
		32:  uint16(31024),
		33:  uint16(31025),
		34:  uint16(31026),
		35:  uint16(31027),
		36:  uint16(31029),
		37:  uint16(31030),
		38:  uint16(31031),
		39:  uint16(31032),
		40:  uint16(31033),
		41:  uint16(31037),
		42:  uint16(31039),
		43:  uint16(31042),
		44:  uint16(31043),
		45:  uint16(31044),
		46:  uint16(31045),
		47:  uint16(31047),
		48:  uint16(31050),
		49:  uint16(31051),
		50:  uint16(31052),
		51:  uint16(31053),
		52:  uint16(31054),
		53:  uint16(31055),
		54:  uint16(31056),
		55:  uint16(31057),
		56:  uint16(31058),
		57:  uint16(31060),
		58:  uint16(31061),
		59:  uint16(31064),
		60:  uint16(31065),
		61:  uint16(31073),
		62:  uint16(31075),
		63:  uint16(31076),
		64:  uint16(31078),
		65:  uint16(31081),
		66:  uint16(31082),
		67:  uint16(31083),
		68:  uint16(31084),
		69:  uint16(31086),
		70:  uint16(31088),
		71:  uint16(31089),
		72:  uint16(31090),
		73:  uint16(31091),
		74:  uint16(31092),
		75:  uint16(31093),
		76:  uint16(31094),
		77:  uint16(31097),
		78:  uint16(31099),
		79:  uint16(31100),
		80:  uint16(31101),
		81:  uint16(31102),
		82:  uint16(31103),
		83:  uint16(31106),
		84:  uint16(31107),
		85:  uint16(31110),
		86:  uint16(31111),
		87:  uint16(31112),
		88:  uint16(31113),
		89:  uint16(31115),
		90:  uint16(31116),
		91:  uint16(31117),
		92:  uint16(31118),
		93:  uint16(31120),
		94:  uint16(31121),
		95:  uint16(31122),
		96:  uint16(24608),
		97:  uint16(32829),
		98:  uint16(25285),
		99:  uint16(20025),
		100: uint16(21333),
		101: uint16(37112),
		102: uint16(25528),
		103: uint16(32966),
		104: uint16(26086),
		105: uint16(27694),
		106: uint16(20294),
		107: uint16(24814),
		108: uint16(28129),
		109: uint16(35806),
		110: uint16(24377),
		111: uint16(34507),
		112: uint16(24403),
		113: uint16(25377),
		114: uint16(20826),
		115: uint16(33633),
		116: uint16(26723),
		117: uint16(20992),
		118: uint16(25443),
		119: uint16(36424),
		120: uint16(20498),
		121: uint16(23707),
		122: uint16(31095),
		123: uint16(23548),
		124: uint16(21040),
		125: uint16(31291),
		126: uint16(24764),
		127: uint16(36947),
		128: uint16(30423),
		129: uint16(24503),
		130: uint16(24471),
		131: uint16(30340),
		132: uint16(36460),
		133: uint16(28783),
		134: uint16(30331),
		135: uint16(31561),
		136: uint16(30634),
		137: uint16(20979),
		138: uint16(37011),
		139: uint16(22564),
		140: uint16(20302),
		141: uint16(28404),
		142: uint16(36842),
		143: uint16(25932),
		144: uint16(31515),
		145: uint16(29380),
		146: uint16(28068),
		147: uint16(32735),
		148: uint16(23265),
		149: uint16(25269),
		150: uint16(24213),
		151: uint16(22320),
		152: uint16(33922),
		153: uint16(31532),
		154: uint16(24093),
		155: uint16(24351),
		156: uint16(36882),
		157: uint16(32532),
		158: uint16(39072),
		159: uint16(25474),
		160: uint16(28359),
		161: uint16(30872),
		162: uint16(28857),
		163: uint16(20856),
		164: uint16(38747),
		165: uint16(22443),
		166: uint16(30005),
		167: uint16(20291),
		168: uint16(30008),
		169: uint16(24215),
		170: uint16(24806),
		171: uint16(22880),
		172: uint16(28096),
		173: uint16(27583),
		174: uint16(30857),
		175: uint16(21500),
		176: uint16(38613),
		177: uint16(20939),
		178: uint16(20993),
		179: uint16(25481),
		180: uint16(21514),
		181: uint16(38035),
		182: uint16(35843),
		183: uint16(36300),
		184: uint16(29241),
		185: uint16(30879),
		186: uint16(34678),
		187: uint16(36845),
		188: uint16(35853),
		189: uint16(21472),
	},
	53: {
		0:   uint16(31123),
		1:   uint16(31124),
		2:   uint16(31125),
		3:   uint16(31126),
		4:   uint16(31127),
		5:   uint16(31128),
		6:   uint16(31129),
		7:   uint16(31131),
		8:   uint16(31132),
		9:   uint16(31133),
		10:  uint16(31134),
		11:  uint16(31135),
		12:  uint16(31136),
		13:  uint16(31137),
		14:  uint16(31138),
		15:  uint16(31139),
		16:  uint16(31140),
		17:  uint16(31141),
		18:  uint16(31142),
		19:  uint16(31144),
		20:  uint16(31145),
		21:  uint16(31146),
		22:  uint16(31147),
		23:  uint16(31148),
		24:  uint16(31149),
		25:  uint16(31150),
		26:  uint16(31151),
		27:  uint16(31152),
		28:  uint16(31153),
		29:  uint16(31154),
		30:  uint16(31156),
		31:  uint16(31157),
		32:  uint16(31158),
		33:  uint16(31159),
		34:  uint16(31160),
		35:  uint16(31164),
		36:  uint16(31167),
		37:  uint16(31170),
		38:  uint16(31172),
		39:  uint16(31173),
		40:  uint16(31175),
		41:  uint16(31176),
		42:  uint16(31178),
		43:  uint16(31180),
		44:  uint16(31182),
		45:  uint16(31183),
		46:  uint16(31184),
		47:  uint16(31187),
		48:  uint16(31188),
		49:  uint16(31190),
		50:  uint16(31191),
		51:  uint16(31193),
		52:  uint16(31194),
		53:  uint16(31195),
		54:  uint16(31196),
		55:  uint16(31197),
		56:  uint16(31198),
		57:  uint16(31200),
		58:  uint16(31201),
		59:  uint16(31202),
		60:  uint16(31205),
		61:  uint16(31208),
		62:  uint16(31210),
		63:  uint16(31212),
		64:  uint16(31214),
		65:  uint16(31217),
		66:  uint16(31218),
		67:  uint16(31219),
		68:  uint16(31220),
		69:  uint16(31221),
		70:  uint16(31222),
		71:  uint16(31223),
		72:  uint16(31225),
		73:  uint16(31226),
		74:  uint16(31228),
		75:  uint16(31230),
		76:  uint16(31231),
		77:  uint16(31233),
		78:  uint16(31236),
		79:  uint16(31237),
		80:  uint16(31239),
		81:  uint16(31240),
		82:  uint16(31241),
		83:  uint16(31242),
		84:  uint16(31244),
		85:  uint16(31247),
		86:  uint16(31248),
		87:  uint16(31249),
		88:  uint16(31250),
		89:  uint16(31251),
		90:  uint16(31253),
		91:  uint16(31254),
		92:  uint16(31256),
		93:  uint16(31257),
		94:  uint16(31259),
		95:  uint16(31260),
		96:  uint16(19969),
		97:  uint16(30447),
		98:  uint16(21486),
		99:  uint16(38025),
		100: uint16(39030),
		101: uint16(40718),
		102: uint16(38189),
		103: uint16(23450),
		104: uint16(35746),
		105: uint16(20002),
		106: uint16(19996),
		107: uint16(20908),
		108: uint16(33891),
		109: uint16(25026),
		110: uint16(21160),
		111: uint16(26635),
		112: uint16(20375),
		113: uint16(24683),
		114: uint16(20923),
		115: uint16(27934),
		116: uint16(20828),
		117: uint16(25238),
		118: uint16(26007),
		119: uint16(38497),
		120: uint16(35910),
		121: uint16(36887),
		122: uint16(30168),
		123: uint16(37117),
		124: uint16(30563),
		125: uint16(27602),
		126: uint16(29322),
		127: uint16(29420),
		128: uint16(35835),
		129: uint16(22581),
		130: uint16(30585),
		131: uint16(36172),
		132: uint16(26460),
		133: uint16(38208),
		134: uint16(32922),
		135: uint16(24230),
		136: uint16(28193),
		137: uint16(22930),
		138: uint16(31471),
		139: uint16(30701),
		140: uint16(38203),
		141: uint16(27573),
		142: uint16(26029),
		143: uint16(32526),
		144: uint16(22534),
		145: uint16(20817),
		146: uint16(38431),
		147: uint16(23545),
		148: uint16(22697),
		149: uint16(21544),
		150: uint16(36466),
		151: uint16(25958),
		152: uint16(39039),
		153: uint16(22244),
		154: uint16(38045),
		155: uint16(30462),
		156: uint16(36929),
		157: uint16(25479),
		158: uint16(21702),
		159: uint16(22810),
		160: uint16(22842),
		161: uint16(22427),
		162: uint16(36530),
		163: uint16(26421),
		164: uint16(36346),
		165: uint16(33333),
		166: uint16(21057),
		167: uint16(24816),
		168: uint16(22549),
		169: uint16(34558),
		170: uint16(23784),
		171: uint16(40517),
		172: uint16(20420),
		173: uint16(39069),
		174: uint16(35769),
		175: uint16(23077),
		176: uint16(24694),
		177: uint16(21380),
		178: uint16(25212),
		179: uint16(36943),
		180: uint16(37122),
		181: uint16(39295),
		182: uint16(24681),
		183: uint16(32780),
		184: uint16(20799),
		185: uint16(32819),
		186: uint16(23572),
		187: uint16(39285),
		188: uint16(27953),
		189: uint16(20108),
	},
	54: {
		0:   uint16(31261),
		1:   uint16(31263),
		2:   uint16(31265),
		3:   uint16(31266),
		4:   uint16(31268),
		5:   uint16(31269),
		6:   uint16(31270),
		7:   uint16(31271),
		8:   uint16(31272),
		9:   uint16(31273),
		10:  uint16(31274),
		11:  uint16(31275),
		12:  uint16(31276),
		13:  uint16(31277),
		14:  uint16(31278),
		15:  uint16(31279),
		16:  uint16(31280),
		17:  uint16(31281),
		18:  uint16(31282),
		19:  uint16(31284),
		20:  uint16(31285),
		21:  uint16(31286),
		22:  uint16(31288),
		23:  uint16(31290),
		24:  uint16(31294),
		25:  uint16(31296),
		26:  uint16(31297),
		27:  uint16(31298),
		28:  uint16(31299),
		29:  uint16(31300),
		30:  uint16(31301),
		31:  uint16(31303),
		32:  uint16(31304),
		33:  uint16(31305),
		34:  uint16(31306),
		35:  uint16(31307),
		36:  uint16(31308),
		37:  uint16(31309),
		38:  uint16(31310),
		39:  uint16(31311),
		40:  uint16(31312),
		41:  uint16(31314),
		42:  uint16(31315),
		43:  uint16(31316),
		44:  uint16(31317),
		45:  uint16(31318),
		46:  uint16(31320),
		47:  uint16(31321),
		48:  uint16(31322),
		49:  uint16(31323),
		50:  uint16(31324),
		51:  uint16(31325),
		52:  uint16(31326),
		53:  uint16(31327),
		54:  uint16(31328),
		55:  uint16(31329),
		56:  uint16(31330),
		57:  uint16(31331),
		58:  uint16(31332),
		59:  uint16(31333),
		60:  uint16(31334),
		61:  uint16(31335),
		62:  uint16(31336),
		63:  uint16(31337),
		64:  uint16(31338),
		65:  uint16(31339),
		66:  uint16(31340),
		67:  uint16(31341),
		68:  uint16(31342),
		69:  uint16(31343),
		70:  uint16(31345),
		71:  uint16(31346),
		72:  uint16(31347),
		73:  uint16(31349),
		74:  uint16(31355),
		75:  uint16(31356),
		76:  uint16(31357),
		77:  uint16(31358),
		78:  uint16(31362),
		79:  uint16(31365),
		80:  uint16(31367),
		81:  uint16(31369),
		82:  uint16(31370),
		83:  uint16(31371),
		84:  uint16(31372),
		85:  uint16(31374),
		86:  uint16(31375),
		87:  uint16(31376),
		88:  uint16(31379),
		89:  uint16(31380),
		90:  uint16(31385),
		91:  uint16(31386),
		92:  uint16(31387),
		93:  uint16(31390),
		94:  uint16(31393),
		95:  uint16(31394),
		96:  uint16(36144),
		97:  uint16(21457),
		98:  uint16(32602),
		99:  uint16(31567),
		100: uint16(20240),
		101: uint16(20047),
		102: uint16(38400),
		103: uint16(27861),
		104: uint16(29648),
		105: uint16(34281),
		106: uint16(24070),
		107: uint16(30058),
		108: uint16(32763),
		109: uint16(27146),
		110: uint16(30718),
		111: uint16(38034),
		112: uint16(32321),
		113: uint16(20961),
		114: uint16(28902),
		115: uint16(21453),
		116: uint16(36820),
		117: uint16(33539),
		118: uint16(36137),
		119: uint16(29359),
		120: uint16(39277),
		121: uint16(27867),
		122: uint16(22346),
		123: uint16(33459),
		124: uint16(26041),
		125: uint16(32938),
		126: uint16(25151),
		127: uint16(38450),
		128: uint16(22952),
		129: uint16(20223),
		130: uint16(35775),
		131: uint16(32442),
		132: uint16(25918),
		133: uint16(33778),
		134: uint16(38750),
		135: uint16(21857),
		136: uint16(39134),
		137: uint16(32933),
		138: uint16(21290),
		139: uint16(35837),
		140: uint16(21536),
		141: uint16(32954),
		142: uint16(24223),
		143: uint16(27832),
		144: uint16(36153),
		145: uint16(33452),
		146: uint16(37210),
		147: uint16(21545),
		148: uint16(27675),
		149: uint16(20998),
		150: uint16(32439),
		151: uint16(22367),
		152: uint16(28954),
		153: uint16(27774),
		154: uint16(31881),
		155: uint16(22859),
		156: uint16(20221),
		157: uint16(24575),
		158: uint16(24868),
		159: uint16(31914),
		160: uint16(20016),
		161: uint16(23553),
		162: uint16(26539),
		163: uint16(34562),
		164: uint16(23792),
		165: uint16(38155),
		166: uint16(39118),
		167: uint16(30127),
		168: uint16(28925),
		169: uint16(36898),
		170: uint16(20911),
		171: uint16(32541),
		172: uint16(35773),
		173: uint16(22857),
		174: uint16(20964),
		175: uint16(20315),
		176: uint16(21542),
		177: uint16(22827),
		178: uint16(25975),
		179: uint16(32932),
		180: uint16(23413),
		181: uint16(25206),
		182: uint16(25282),
		183: uint16(36752),
		184: uint16(24133),
		185: uint16(27679),
		186: uint16(31526),
		187: uint16(20239),
		188: uint16(20440),
		189: uint16(26381),
	},
	55: {
		0:   uint16(31395),
		1:   uint16(31396),
		2:   uint16(31399),
		3:   uint16(31401),
		4:   uint16(31402),
		5:   uint16(31403),
		6:   uint16(31406),
		7:   uint16(31407),
		8:   uint16(31408),
		9:   uint16(31409),
		10:  uint16(31410),
		11:  uint16(31412),
		12:  uint16(31413),
		13:  uint16(31414),
		14:  uint16(31415),
		15:  uint16(31416),
		16:  uint16(31417),
		17:  uint16(31418),
		18:  uint16(31419),
		19:  uint16(31420),
		20:  uint16(31421),
		21:  uint16(31422),
		22:  uint16(31424),
		23:  uint16(31425),
		24:  uint16(31426),
		25:  uint16(31427),
		26:  uint16(31428),
		27:  uint16(31429),
		28:  uint16(31430),
		29:  uint16(31431),
		30:  uint16(31432),
		31:  uint16(31433),
		32:  uint16(31434),
		33:  uint16(31436),
		34:  uint16(31437),
		35:  uint16(31438),
		36:  uint16(31439),
		37:  uint16(31440),
		38:  uint16(31441),
		39:  uint16(31442),
		40:  uint16(31443),
		41:  uint16(31444),
		42:  uint16(31445),
		43:  uint16(31447),
		44:  uint16(31448),
		45:  uint16(31450),
		46:  uint16(31451),
		47:  uint16(31452),
		48:  uint16(31453),
		49:  uint16(31457),
		50:  uint16(31458),
		51:  uint16(31460),
		52:  uint16(31463),
		53:  uint16(31464),
		54:  uint16(31465),
		55:  uint16(31466),
		56:  uint16(31467),
		57:  uint16(31468),
		58:  uint16(31470),
		59:  uint16(31472),
		60:  uint16(31473),
		61:  uint16(31474),
		62:  uint16(31475),
		63:  uint16(31476),
		64:  uint16(31477),
		65:  uint16(31478),
		66:  uint16(31479),
		67:  uint16(31480),
		68:  uint16(31483),
		69:  uint16(31484),
		70:  uint16(31486),
		71:  uint16(31488),
		72:  uint16(31489),
		73:  uint16(31490),
		74:  uint16(31493),
		75:  uint16(31495),
		76:  uint16(31497),
		77:  uint16(31500),
		78:  uint16(31501),
		79:  uint16(31502),
		80:  uint16(31504),
		81:  uint16(31506),
		82:  uint16(31507),
		83:  uint16(31510),
		84:  uint16(31511),
		85:  uint16(31512),
		86:  uint16(31514),
		87:  uint16(31516),
		88:  uint16(31517),
		89:  uint16(31519),
		90:  uint16(31521),
		91:  uint16(31522),
		92:  uint16(31523),
		93:  uint16(31527),
		94:  uint16(31529),
		95:  uint16(31533),
		96:  uint16(28014),
		97:  uint16(28074),
		98:  uint16(31119),
		99:  uint16(34993),
		100: uint16(24343),
		101: uint16(29995),
		102: uint16(25242),
		103: uint16(36741),
		104: uint16(20463),
		105: uint16(37340),
		106: uint16(26023),
		107: uint16(33071),
		108: uint16(33105),
		109: uint16(24220),
		110: uint16(33104),
		111: uint16(36212),
		112: uint16(21103),
		113: uint16(35206),
		114: uint16(36171),
		115: uint16(22797),
		116: uint16(20613),
		117: uint16(20184),
		118: uint16(38428),
		119: uint16(29238),
		120: uint16(33145),
		121: uint16(36127),
		122: uint16(23500),
		123: uint16(35747),
		124: uint16(38468),
		125: uint16(22919),
		126: uint16(32538),
		127: uint16(21648),
		128: uint16(22134),
		129: uint16(22030),
		130: uint16(35813),
		131: uint16(25913),
		132: uint16(27010),
		133: uint16(38041),
		134: uint16(30422),
		135: uint16(28297),
		136: uint16(24178),
		137: uint16(29976),
		138: uint16(26438),
		139: uint16(26577),
		140: uint16(31487),
		141: uint16(32925),
		142: uint16(36214),
		143: uint16(24863),
		144: uint16(31174),
		145: uint16(25954),
		146: uint16(36195),
		147: uint16(20872),
		148: uint16(21018),
		149: uint16(38050),
		150: uint16(32568),
		151: uint16(32923),
		152: uint16(32434),
		153: uint16(23703),
		154: uint16(28207),
		155: uint16(26464),
		156: uint16(31705),
		157: uint16(30347),
		158: uint16(39640),
		159: uint16(33167),
		160: uint16(32660),
		161: uint16(31957),
		162: uint16(25630),
		163: uint16(38224),
		164: uint16(31295),
		165: uint16(21578),
		166: uint16(21733),
		167: uint16(27468),
		168: uint16(25601),
		169: uint16(25096),
		170: uint16(40509),
		171: uint16(33011),
		172: uint16(30105),
		173: uint16(21106),
		174: uint16(38761),
		175: uint16(33883),
		176: uint16(26684),
		177: uint16(34532),
		178: uint16(38401),
		179: uint16(38548),
		180: uint16(38124),
		181: uint16(20010),
		182: uint16(21508),
		183: uint16(32473),
		184: uint16(26681),
		185: uint16(36319),
		186: uint16(32789),
		187: uint16(26356),
		188: uint16(24218),
		189: uint16(32697),
	},
	56: {
		0:   uint16(31535),
		1:   uint16(31536),
		2:   uint16(31538),
		3:   uint16(31540),
		4:   uint16(31541),
		5:   uint16(31542),
		6:   uint16(31543),
		7:   uint16(31545),
		8:   uint16(31547),
		9:   uint16(31549),
		10:  uint16(31551),
		11:  uint16(31552),
		12:  uint16(31553),
		13:  uint16(31554),
		14:  uint16(31555),
		15:  uint16(31556),
		16:  uint16(31558),
		17:  uint16(31560),
		18:  uint16(31562),
		19:  uint16(31565),
		20:  uint16(31566),
		21:  uint16(31571),
		22:  uint16(31573),
		23:  uint16(31575),
		24:  uint16(31577),
		25:  uint16(31580),
		26:  uint16(31582),
		27:  uint16(31583),
		28:  uint16(31585),
		29:  uint16(31587),
		30:  uint16(31588),
		31:  uint16(31589),
		32:  uint16(31590),
		33:  uint16(31591),
		34:  uint16(31592),
		35:  uint16(31593),
		36:  uint16(31594),
		37:  uint16(31595),
		38:  uint16(31596),
		39:  uint16(31597),
		40:  uint16(31599),
		41:  uint16(31600),
		42:  uint16(31603),
		43:  uint16(31604),
		44:  uint16(31606),
		45:  uint16(31608),
		46:  uint16(31610),
		47:  uint16(31612),
		48:  uint16(31613),
		49:  uint16(31615),
		50:  uint16(31617),
		51:  uint16(31618),
		52:  uint16(31619),
		53:  uint16(31620),
		54:  uint16(31622),
		55:  uint16(31623),
		56:  uint16(31624),
		57:  uint16(31625),
		58:  uint16(31626),
		59:  uint16(31627),
		60:  uint16(31628),
		61:  uint16(31630),
		62:  uint16(31631),
		63:  uint16(31633),
		64:  uint16(31634),
		65:  uint16(31635),
		66:  uint16(31638),
		67:  uint16(31640),
		68:  uint16(31641),
		69:  uint16(31642),
		70:  uint16(31643),
		71:  uint16(31646),
		72:  uint16(31647),
		73:  uint16(31648),
		74:  uint16(31651),
		75:  uint16(31652),
		76:  uint16(31653),
		77:  uint16(31662),
		78:  uint16(31663),
		79:  uint16(31664),
		80:  uint16(31666),
		81:  uint16(31667),
		82:  uint16(31669),
		83:  uint16(31670),
		84:  uint16(31671),
		85:  uint16(31673),
		86:  uint16(31674),
		87:  uint16(31675),
		88:  uint16(31676),
		89:  uint16(31677),
		90:  uint16(31678),
		91:  uint16(31679),
		92:  uint16(31680),
		93:  uint16(31682),
		94:  uint16(31683),
		95:  uint16(31684),
		96:  uint16(22466),
		97:  uint16(32831),
		98:  uint16(26775),
		99:  uint16(24037),
		100: uint16(25915),
		101: uint16(21151),
		102: uint16(24685),
		103: uint16(40858),
		104: uint16(20379),
		105: uint16(36524),
		106: uint16(20844),
		107: uint16(23467),
		108: uint16(24339),
		109: uint16(24041),
		110: uint16(27742),
		111: uint16(25329),
		112: uint16(36129),
		113: uint16(20849),
		114: uint16(38057),
		115: uint16(21246),
		116: uint16(27807),
		117: uint16(33503),
		118: uint16(29399),
		119: uint16(22434),
		120: uint16(26500),
		121: uint16(36141),
		122: uint16(22815),
		123: uint16(36764),
		124: uint16(33735),
		125: uint16(21653),
		126: uint16(31629),
		127: uint16(20272),
		128: uint16(27837),
		129: uint16(23396),
		130: uint16(22993),
		131: uint16(40723),
		132: uint16(21476),
		133: uint16(34506),
		134: uint16(39592),
		135: uint16(35895),
		136: uint16(32929),
		137: uint16(25925),
		138: uint16(39038),
		139: uint16(22266),
		140: uint16(38599),
		141: uint16(21038),
		142: uint16(29916),
		143: uint16(21072),
		144: uint16(23521),
		145: uint16(25346),
		146: uint16(35074),
		147: uint16(20054),
		148: uint16(25296),
		149: uint16(24618),
		150: uint16(26874),
		151: uint16(20851),
		152: uint16(23448),
		153: uint16(20896),
		154: uint16(35266),
		155: uint16(31649),
		156: uint16(39302),
		157: uint16(32592),
		158: uint16(24815),
		159: uint16(28748),
		160: uint16(36143),
		161: uint16(20809),
		162: uint16(24191),
		163: uint16(36891),
		164: uint16(29808),
		165: uint16(35268),
		166: uint16(22317),
		167: uint16(30789),
		168: uint16(24402),
		169: uint16(40863),
		170: uint16(38394),
		171: uint16(36712),
		172: uint16(39740),
		173: uint16(35809),
		174: uint16(30328),
		175: uint16(26690),
		176: uint16(26588),
		177: uint16(36330),
		178: uint16(36149),
		179: uint16(21053),
		180: uint16(36746),
		181: uint16(28378),
		182: uint16(26829),
		183: uint16(38149),
		184: uint16(37101),
		185: uint16(22269),
		186: uint16(26524),
		187: uint16(35065),
		188: uint16(36807),
		189: uint16(21704),
	},
	57: {
		0:   uint16(31685),
		1:   uint16(31688),
		2:   uint16(31689),
		3:   uint16(31690),
		4:   uint16(31691),
		5:   uint16(31693),
		6:   uint16(31694),
		7:   uint16(31695),
		8:   uint16(31696),
		9:   uint16(31698),
		10:  uint16(31700),
		11:  uint16(31701),
		12:  uint16(31702),
		13:  uint16(31703),
		14:  uint16(31704),
		15:  uint16(31707),
		16:  uint16(31708),
		17:  uint16(31710),
		18:  uint16(31711),
		19:  uint16(31712),
		20:  uint16(31714),
		21:  uint16(31715),
		22:  uint16(31716),
		23:  uint16(31719),
		24:  uint16(31720),
		25:  uint16(31721),
		26:  uint16(31723),
		27:  uint16(31724),
		28:  uint16(31725),
		29:  uint16(31727),
		30:  uint16(31728),
		31:  uint16(31730),
		32:  uint16(31731),
		33:  uint16(31732),
		34:  uint16(31733),
		35:  uint16(31734),
		36:  uint16(31736),
		37:  uint16(31737),
		38:  uint16(31738),
		39:  uint16(31739),
		40:  uint16(31741),
		41:  uint16(31743),
		42:  uint16(31744),
		43:  uint16(31745),
		44:  uint16(31746),
		45:  uint16(31747),
		46:  uint16(31748),
		47:  uint16(31749),
		48:  uint16(31750),
		49:  uint16(31752),
		50:  uint16(31753),
		51:  uint16(31754),
		52:  uint16(31757),
		53:  uint16(31758),
		54:  uint16(31760),
		55:  uint16(31761),
		56:  uint16(31762),
		57:  uint16(31763),
		58:  uint16(31764),
		59:  uint16(31765),
		60:  uint16(31767),
		61:  uint16(31768),
		62:  uint16(31769),
		63:  uint16(31770),
		64:  uint16(31771),
		65:  uint16(31772),
		66:  uint16(31773),
		67:  uint16(31774),
		68:  uint16(31776),
		69:  uint16(31777),
		70:  uint16(31778),
		71:  uint16(31779),
		72:  uint16(31780),
		73:  uint16(31781),
		74:  uint16(31784),
		75:  uint16(31785),
		76:  uint16(31787),
		77:  uint16(31788),
		78:  uint16(31789),
		79:  uint16(31790),
		80:  uint16(31791),
		81:  uint16(31792),
		82:  uint16(31793),
		83:  uint16(31794),
		84:  uint16(31795),
		85:  uint16(31796),
		86:  uint16(31797),
		87:  uint16(31798),
		88:  uint16(31799),
		89:  uint16(31801),
		90:  uint16(31802),
		91:  uint16(31803),
		92:  uint16(31804),
		93:  uint16(31805),
		94:  uint16(31806),
		95:  uint16(31810),
		96:  uint16(39608),
		97:  uint16(23401),
		98:  uint16(28023),
		99:  uint16(27686),
		100: uint16(20133),
		101: uint16(23475),
		102: uint16(39559),
		103: uint16(37219),
		104: uint16(25000),
		105: uint16(37039),
		106: uint16(38889),
		107: uint16(21547),
		108: uint16(28085),
		109: uint16(23506),
		110: uint16(20989),
		111: uint16(21898),
		112: uint16(32597),
		113: uint16(32752),
		114: uint16(25788),
		115: uint16(25421),
		116: uint16(26097),
		117: uint16(25022),
		118: uint16(24717),
		119: uint16(28938),
		120: uint16(27735),
		121: uint16(27721),
		122: uint16(22831),
		123: uint16(26477),
		124: uint16(33322),
		125: uint16(22741),
		126: uint16(22158),
		127: uint16(35946),
		128: uint16(27627),
		129: uint16(37085),
		130: uint16(22909),
		131: uint16(32791),
		132: uint16(21495),
		133: uint16(28009),
		134: uint16(21621),
		135: uint16(21917),
		136: uint16(33655),
		137: uint16(33743),
		138: uint16(26680),
		139: uint16(31166),
		140: uint16(21644),
		141: uint16(20309),
		142: uint16(21512),
		143: uint16(30418),
		144: uint16(35977),
		145: uint16(38402),
		146: uint16(27827),
		147: uint16(28088),
		148: uint16(36203),
		149: uint16(35088),
		150: uint16(40548),
		151: uint16(36154),
		152: uint16(22079),
		153: uint16(40657),
		154: uint16(30165),
		155: uint16(24456),
		156: uint16(29408),
		157: uint16(24680),
		158: uint16(21756),
		159: uint16(20136),
		160: uint16(27178),
		161: uint16(34913),
		162: uint16(24658),
		163: uint16(36720),
		164: uint16(21700),
		165: uint16(28888),
		166: uint16(34425),
		167: uint16(40511),
		168: uint16(27946),
		169: uint16(23439),
		170: uint16(24344),
		171: uint16(32418),
		172: uint16(21897),
		173: uint16(20399),
		174: uint16(29492),
		175: uint16(21564),
		176: uint16(21402),
		177: uint16(20505),
		178: uint16(21518),
		179: uint16(21628),
		180: uint16(20046),
		181: uint16(24573),
		182: uint16(29786),
		183: uint16(22774),
		184: uint16(33899),
		185: uint16(32993),
		186: uint16(34676),
		187: uint16(29392),
		188: uint16(31946),
		189: uint16(28246),
	},
	58: {
		0:   uint16(31811),
		1:   uint16(31812),
		2:   uint16(31813),
		3:   uint16(31814),
		4:   uint16(31815),
		5:   uint16(31816),
		6:   uint16(31817),
		7:   uint16(31818),
		8:   uint16(31819),
		9:   uint16(31820),
		10:  uint16(31822),
		11:  uint16(31823),
		12:  uint16(31824),
		13:  uint16(31825),
		14:  uint16(31826),
		15:  uint16(31827),
		16:  uint16(31828),
		17:  uint16(31829),
		18:  uint16(31830),
		19:  uint16(31831),
		20:  uint16(31832),
		21:  uint16(31833),
		22:  uint16(31834),
		23:  uint16(31835),
		24:  uint16(31836),
		25:  uint16(31837),
		26:  uint16(31838),
		27:  uint16(31839),
		28:  uint16(31840),
		29:  uint16(31841),
		30:  uint16(31842),
		31:  uint16(31843),
		32:  uint16(31844),
		33:  uint16(31845),
		34:  uint16(31846),
		35:  uint16(31847),
		36:  uint16(31848),
		37:  uint16(31849),
		38:  uint16(31850),
		39:  uint16(31851),
		40:  uint16(31852),
		41:  uint16(31853),
		42:  uint16(31854),
		43:  uint16(31855),
		44:  uint16(31856),
		45:  uint16(31857),
		46:  uint16(31858),
		47:  uint16(31861),
		48:  uint16(31862),
		49:  uint16(31863),
		50:  uint16(31864),
		51:  uint16(31865),
		52:  uint16(31866),
		53:  uint16(31870),
		54:  uint16(31871),
		55:  uint16(31872),
		56:  uint16(31873),
		57:  uint16(31874),
		58:  uint16(31875),
		59:  uint16(31876),
		60:  uint16(31877),
		61:  uint16(31878),
		62:  uint16(31879),
		63:  uint16(31880),
		64:  uint16(31882),
		65:  uint16(31883),
		66:  uint16(31884),
		67:  uint16(31885),
		68:  uint16(31886),
		69:  uint16(31887),
		70:  uint16(31888),
		71:  uint16(31891),
		72:  uint16(31892),
		73:  uint16(31894),
		74:  uint16(31897),
		75:  uint16(31898),
		76:  uint16(31899),
		77:  uint16(31904),
		78:  uint16(31905),
		79:  uint16(31907),
		80:  uint16(31910),
		81:  uint16(31911),
		82:  uint16(31912),
		83:  uint16(31913),
		84:  uint16(31915),
		85:  uint16(31916),
		86:  uint16(31917),
		87:  uint16(31919),
		88:  uint16(31920),
		89:  uint16(31924),
		90:  uint16(31925),
		91:  uint16(31926),
		92:  uint16(31927),
		93:  uint16(31928),
		94:  uint16(31930),
		95:  uint16(31931),
		96:  uint16(24359),
		97:  uint16(34382),
		98:  uint16(21804),
		99:  uint16(25252),
		100: uint16(20114),
		101: uint16(27818),
		102: uint16(25143),
		103: uint16(33457),
		104: uint16(21719),
		105: uint16(21326),
		106: uint16(29502),
		107: uint16(28369),
		108: uint16(30011),
		109: uint16(21010),
		110: uint16(21270),
		111: uint16(35805),
		112: uint16(27088),
		113: uint16(24458),
		114: uint16(24576),
		115: uint16(28142),
		116: uint16(22351),
		117: uint16(27426),
		118: uint16(29615),
		119: uint16(26707),
		120: uint16(36824),
		121: uint16(32531),
		122: uint16(25442),
		123: uint16(24739),
		124: uint16(21796),
		125: uint16(30186),
		126: uint16(35938),
		127: uint16(28949),
		128: uint16(28067),
		129: uint16(23462),
		130: uint16(24187),
		131: uint16(33618),
		132: uint16(24908),
		133: uint16(40644),
		134: uint16(30970),
		135: uint16(34647),
		136: uint16(31783),
		137: uint16(30343),
		138: uint16(20976),
		139: uint16(24822),
		140: uint16(29004),
		141: uint16(26179),
		142: uint16(24140),
		143: uint16(24653),
		144: uint16(35854),
		145: uint16(28784),
		146: uint16(25381),
		147: uint16(36745),
		148: uint16(24509),
		149: uint16(24674),
		150: uint16(34516),
		151: uint16(22238),
		152: uint16(27585),
		153: uint16(24724),
		154: uint16(24935),
		155: uint16(21321),
		156: uint16(24800),
		157: uint16(26214),
		158: uint16(36159),
		159: uint16(31229),
		160: uint16(20250),
		161: uint16(28905),
		162: uint16(27719),
		163: uint16(35763),
		164: uint16(35826),
		165: uint16(32472),
		166: uint16(33636),
		167: uint16(26127),
		168: uint16(23130),
		169: uint16(39746),
		170: uint16(27985),
		171: uint16(28151),
		172: uint16(35905),
		173: uint16(27963),
		174: uint16(20249),
		175: uint16(28779),
		176: uint16(33719),
		177: uint16(25110),
		178: uint16(24785),
		179: uint16(38669),
		180: uint16(36135),
		181: uint16(31096),
		182: uint16(20987),
		183: uint16(22334),
		184: uint16(22522),
		185: uint16(26426),
		186: uint16(30072),
		187: uint16(31293),
		188: uint16(31215),
		189: uint16(31637),
	},
	59: {
		0:   uint16(31935),
		1:   uint16(31936),
		2:   uint16(31938),
		3:   uint16(31939),
		4:   uint16(31940),
		5:   uint16(31942),
		6:   uint16(31945),
		7:   uint16(31947),
		8:   uint16(31950),
		9:   uint16(31951),
		10:  uint16(31952),
		11:  uint16(31953),
		12:  uint16(31954),
		13:  uint16(31955),
		14:  uint16(31956),
		15:  uint16(31960),
		16:  uint16(31962),
		17:  uint16(31963),
		18:  uint16(31965),
		19:  uint16(31966),
		20:  uint16(31969),
		21:  uint16(31970),
		22:  uint16(31971),
		23:  uint16(31972),
		24:  uint16(31973),
		25:  uint16(31974),
		26:  uint16(31975),
		27:  uint16(31977),
		28:  uint16(31978),
		29:  uint16(31979),
		30:  uint16(31980),
		31:  uint16(31981),
		32:  uint16(31982),
		33:  uint16(31984),
		34:  uint16(31985),
		35:  uint16(31986),
		36:  uint16(31987),
		37:  uint16(31988),
		38:  uint16(31989),
		39:  uint16(31990),
		40:  uint16(31991),
		41:  uint16(31993),
		42:  uint16(31994),
		43:  uint16(31996),
		44:  uint16(31997),
		45:  uint16(31998),
		46:  uint16(31999),
		47:  uint16(32000),
		48:  uint16(32001),
		49:  uint16(32002),
		50:  uint16(32003),
		51:  uint16(32004),
		52:  uint16(32005),
		53:  uint16(32006),
		54:  uint16(32007),
		55:  uint16(32008),
		56:  uint16(32009),
		57:  uint16(32011),
		58:  uint16(32012),
		59:  uint16(32013),
		60:  uint16(32014),
		61:  uint16(32015),
		62:  uint16(32016),
		63:  uint16(32017),
		64:  uint16(32018),
		65:  uint16(32019),
		66:  uint16(32020),
		67:  uint16(32021),
		68:  uint16(32022),
		69:  uint16(32023),
		70:  uint16(32024),
		71:  uint16(32025),
		72:  uint16(32026),
		73:  uint16(32027),
		74:  uint16(32028),
		75:  uint16(32029),
		76:  uint16(32030),
		77:  uint16(32031),
		78:  uint16(32033),
		79:  uint16(32035),
		80:  uint16(32036),
		81:  uint16(32037),
		82:  uint16(32038),
		83:  uint16(32040),
		84:  uint16(32041),
		85:  uint16(32042),
		86:  uint16(32044),
		87:  uint16(32045),
		88:  uint16(32046),
		89:  uint16(32048),
		90:  uint16(32049),
		91:  uint16(32050),
		92:  uint16(32051),
		93:  uint16(32052),
		94:  uint16(32053),
		95:  uint16(32054),
		96:  uint16(32908),
		97:  uint16(39269),
		98:  uint16(36857),
		99:  uint16(28608),
		100: uint16(35749),
		101: uint16(40481),
		102: uint16(23020),
		103: uint16(32489),
		104: uint16(32521),
		105: uint16(21513),
		106: uint16(26497),
		107: uint16(26840),
		108: uint16(36753),
		109: uint16(31821),
		110: uint16(38598),
		111: uint16(21450),
		112: uint16(24613),
		113: uint16(30142),
		114: uint16(27762),
		115: uint16(21363),
		116: uint16(23241),
		117: uint16(32423),
		118: uint16(25380),
		119: uint16(20960),
		120: uint16(33034),
		121: uint16(24049),
		122: uint16(34015),
		123: uint16(25216),
		124: uint16(20864),
		125: uint16(23395),
		126: uint16(20238),
		127: uint16(31085),
		128: uint16(21058),
		129: uint16(24760),
		130: uint16(27982),
		131: uint16(23492),
		132: uint16(23490),
		133: uint16(35745),
		134: uint16(35760),
		135: uint16(26082),
		136: uint16(24524),
		137: uint16(38469),
		138: uint16(22931),
		139: uint16(32487),
		140: uint16(32426),
		141: uint16(22025),
		142: uint16(26551),
		143: uint16(22841),
		144: uint16(20339),
		145: uint16(23478),
		146: uint16(21152),
		147: uint16(33626),
		148: uint16(39050),
		149: uint16(36158),
		150: uint16(30002),
		151: uint16(38078),
		152: uint16(20551),
		153: uint16(31292),
		154: uint16(20215),
		155: uint16(26550),
		156: uint16(39550),
		157: uint16(23233),
		158: uint16(27516),
		159: uint16(30417),
		160: uint16(22362),
		161: uint16(23574),
		162: uint16(31546),
		163: uint16(38388),
		164: uint16(29006),
		165: uint16(20860),
		166: uint16(32937),
		167: uint16(33392),
		168: uint16(22904),
		169: uint16(32516),
		170: uint16(33575),
		171: uint16(26816),
		172: uint16(26604),
		173: uint16(30897),
		174: uint16(30839),
		175: uint16(25315),
		176: uint16(25441),
		177: uint16(31616),
		178: uint16(20461),
		179: uint16(21098),
		180: uint16(20943),
		181: uint16(33616),
		182: uint16(27099),
		183: uint16(37492),
		184: uint16(36341),
		185: uint16(36145),
		186: uint16(35265),
		187: uint16(38190),
		188: uint16(31661),
		189: uint16(20214),
	},
	60: {
		0:   uint16(32055),
		1:   uint16(32056),
		2:   uint16(32057),
		3:   uint16(32058),
		4:   uint16(32059),
		5:   uint16(32060),
		6:   uint16(32061),
		7:   uint16(32062),
		8:   uint16(32063),
		9:   uint16(32064),
		10:  uint16(32065),
		11:  uint16(32066),
		12:  uint16(32067),
		13:  uint16(32068),
		14:  uint16(32069),
		15:  uint16(32070),
		16:  uint16(32071),
		17:  uint16(32072),
		18:  uint16(32073),
		19:  uint16(32074),
		20:  uint16(32075),
		21:  uint16(32076),
		22:  uint16(32077),
		23:  uint16(32078),
		24:  uint16(32079),
		25:  uint16(32080),
		26:  uint16(32081),
		27:  uint16(32082),
		28:  uint16(32083),
		29:  uint16(32084),
		30:  uint16(32085),
		31:  uint16(32086),
		32:  uint16(32087),
		33:  uint16(32088),
		34:  uint16(32089),
		35:  uint16(32090),
		36:  uint16(32091),
		37:  uint16(32092),
		38:  uint16(32093),
		39:  uint16(32094),
		40:  uint16(32095),
		41:  uint16(32096),
		42:  uint16(32097),
		43:  uint16(32098),
		44:  uint16(32099),
		45:  uint16(32100),
		46:  uint16(32101),
		47:  uint16(32102),
		48:  uint16(32103),
		49:  uint16(32104),
		50:  uint16(32105),
		51:  uint16(32106),
		52:  uint16(32107),
		53:  uint16(32108),
		54:  uint16(32109),
		55:  uint16(32111),
		56:  uint16(32112),
		57:  uint16(32113),
		58:  uint16(32114),
		59:  uint16(32115),
		60:  uint16(32116),
		61:  uint16(32117),
		62:  uint16(32118),
		63:  uint16(32120),
		64:  uint16(32121),
		65:  uint16(32122),
		66:  uint16(32123),
		67:  uint16(32124),
		68:  uint16(32125),
		69:  uint16(32126),
		70:  uint16(32127),
		71:  uint16(32128),
		72:  uint16(32129),
		73:  uint16(32130),
		74:  uint16(32131),
		75:  uint16(32132),
		76:  uint16(32133),
		77:  uint16(32134),
		78:  uint16(32135),
		79:  uint16(32136),
		80:  uint16(32137),
		81:  uint16(32138),
		82:  uint16(32139),
		83:  uint16(32140),
		84:  uint16(32141),
		85:  uint16(32142),
		86:  uint16(32143),
		87:  uint16(32144),
		88:  uint16(32145),
		89:  uint16(32146),
		90:  uint16(32147),
		91:  uint16(32148),
		92:  uint16(32149),
		93:  uint16(32150),
		94:  uint16(32151),
		95:  uint16(32152),
		96:  uint16(20581),
		97:  uint16(33328),
		98:  uint16(21073),
		99:  uint16(39279),
		100: uint16(28176),
		101: uint16(28293),
		102: uint16(28071),
		103: uint16(24314),
		104: uint16(20725),
		105: uint16(23004),
		106: uint16(23558),
		107: uint16(27974),
		108: uint16(27743),
		109: uint16(30086),
		110: uint16(33931),
		111: uint16(26728),
		112: uint16(22870),
		113: uint16(35762),
		114: uint16(21280),
		115: uint16(37233),
		116: uint16(38477),
		117: uint16(34121),
		118: uint16(26898),
		119: uint16(30977),
		120: uint16(28966),
		121: uint16(33014),
		122: uint16(20132),
		123: uint16(37066),
		124: uint16(27975),
		125: uint16(39556),
		126: uint16(23047),
		127: uint16(22204),
		128: uint16(25605),
		129: uint16(38128),
		130: uint16(30699),
		131: uint16(20389),
		132: uint16(33050),
		133: uint16(29409),
		134: uint16(35282),
		135: uint16(39290),
		136: uint16(32564),
		137: uint16(32478),
		138: uint16(21119),
		139: uint16(25945),
		140: uint16(37237),
		141: uint16(36735),
		142: uint16(36739),
		143: uint16(21483),
		144: uint16(31382),
		145: uint16(25581),
		146: uint16(25509),
		147: uint16(30342),
		148: uint16(31224),
		149: uint16(34903),
		150: uint16(38454),
		151: uint16(25130),
		152: uint16(21163),
		153: uint16(33410),
		154: uint16(26708),
		155: uint16(26480),
		156: uint16(25463),
		157: uint16(30571),
		158: uint16(31469),
		159: uint16(27905),
		160: uint16(32467),
		161: uint16(35299),
		162: uint16(22992),
		163: uint16(25106),
		164: uint16(34249),
		165: uint16(33445),
		166: uint16(30028),
		167: uint16(20511),
		168: uint16(20171),
		169: uint16(30117),
		170: uint16(35819),
		171: uint16(23626),
		172: uint16(24062),
		173: uint16(31563),
		174: uint16(26020),
		175: uint16(37329),
		176: uint16(20170),
		177: uint16(27941),
		178: uint16(35167),
		179: uint16(32039),
		180: uint16(38182),
		181: uint16(20165),
		182: uint16(35880),
		183: uint16(36827),
		184: uint16(38771),
		185: uint16(26187),
		186: uint16(31105),
		187: uint16(36817),
		188: uint16(28908),
		189: uint16(28024),
	},
	61: {
		0:   uint16(32153),
		1:   uint16(32154),
		2:   uint16(32155),
		3:   uint16(32156),
		4:   uint16(32157),
		5:   uint16(32158),
		6:   uint16(32159),
		7:   uint16(32160),
		8:   uint16(32161),
		9:   uint16(32162),
		10:  uint16(32163),
		11:  uint16(32164),
		12:  uint16(32165),
		13:  uint16(32167),
		14:  uint16(32168),
		15:  uint16(32169),
		16:  uint16(32170),
		17:  uint16(32171),
		18:  uint16(32172),
		19:  uint16(32173),
		20:  uint16(32175),
		21:  uint16(32176),
		22:  uint16(32177),
		23:  uint16(32178),
		24:  uint16(32179),
		25:  uint16(32180),
		26:  uint16(32181),
		27:  uint16(32182),
		28:  uint16(32183),
		29:  uint16(32184),
		30:  uint16(32185),
		31:  uint16(32186),
		32:  uint16(32187),
		33:  uint16(32188),
		34:  uint16(32189),
		35:  uint16(32190),
		36:  uint16(32191),
		37:  uint16(32192),
		38:  uint16(32193),
		39:  uint16(32194),
		40:  uint16(32195),
		41:  uint16(32196),
		42:  uint16(32197),
		43:  uint16(32198),
		44:  uint16(32199),
		45:  uint16(32200),
		46:  uint16(32201),
		47:  uint16(32202),
		48:  uint16(32203),
		49:  uint16(32204),
		50:  uint16(32205),
		51:  uint16(32206),
		52:  uint16(32207),
		53:  uint16(32208),
		54:  uint16(32209),
		55:  uint16(32210),
		56:  uint16(32211),
		57:  uint16(32212),
		58:  uint16(32213),
		59:  uint16(32214),
		60:  uint16(32215),
		61:  uint16(32216),
		62:  uint16(32217),
		63:  uint16(32218),
		64:  uint16(32219),
		65:  uint16(32220),
		66:  uint16(32221),
		67:  uint16(32222),
		68:  uint16(32223),
		69:  uint16(32224),
		70:  uint16(32225),
		71:  uint16(32226),
		72:  uint16(32227),
		73:  uint16(32228),
		74:  uint16(32229),
		75:  uint16(32230),
		76:  uint16(32231),
		77:  uint16(32232),
		78:  uint16(32233),
		79:  uint16(32234),
		80:  uint16(32235),
		81:  uint16(32236),
		82:  uint16(32237),
		83:  uint16(32238),
		84:  uint16(32239),
		85:  uint16(32240),
		86:  uint16(32241),
		87:  uint16(32242),
		88:  uint16(32243),
		89:  uint16(32244),
		90:  uint16(32245),
		91:  uint16(32246),
		92:  uint16(32247),
		93:  uint16(32248),
		94:  uint16(32249),
		95:  uint16(32250),
		96:  uint16(23613),
		97:  uint16(21170),
		98:  uint16(33606),
		99:  uint16(20834),
		100: uint16(33550),
		101: uint16(30555),
		102: uint16(26230),
		103: uint16(40120),
		104: uint16(20140),
		105: uint16(24778),
		106: uint16(31934),
		107: uint16(31923),
		108: uint16(32463),
		109: uint16(20117),
		110: uint16(35686),
		111: uint16(26223),
		112: uint16(39048),
		113: uint16(38745),
		114: uint16(22659),
		115: uint16(25964),
		116: uint16(38236),
		117: uint16(24452),
		118: uint16(30153),
		119: uint16(38742),
		120: uint16(31455),
		121: uint16(31454),
		122: uint16(20928),
		123: uint16(28847),
		124: uint16(31384),
		125: uint16(25578),
		126: uint16(31350),
		127: uint16(32416),
		128: uint16(29590),
		129: uint16(38893),
		130: uint16(20037),
		131: uint16(28792),
		132: uint16(20061),
		133: uint16(37202),
		134: uint16(21417),
		135: uint16(25937),
		136: uint16(26087),
		137: uint16(33276),
		138: uint16(33285),
		139: uint16(21646),
		140: uint16(23601),
		141: uint16(30106),
		142: uint16(38816),
		143: uint16(25304),
		144: uint16(29401),
		145: uint16(30141),
		146: uint16(23621),
		147: uint16(39545),
		148: uint16(33738),
		149: uint16(23616),
		150: uint16(21632),
		151: uint16(30697),
		152: uint16(20030),
		153: uint16(27822),
		154: uint16(32858),
		155: uint16(25298),
		156: uint16(25454),
		157: uint16(24040),
		158: uint16(20855),
		159: uint16(36317),
		160: uint16(36382),
		161: uint16(38191),
		162: uint16(20465),
		163: uint16(21477),
		164: uint16(24807),
		165: uint16(28844),
		166: uint16(21095),
		167: uint16(25424),
		168: uint16(40515),
		169: uint16(23071),
		170: uint16(20518),
		171: uint16(30519),
		172: uint16(21367),
		173: uint16(32482),
		174: uint16(25733),
		175: uint16(25899),
		176: uint16(25225),
		177: uint16(25496),
		178: uint16(20500),
		179: uint16(29237),
		180: uint16(35273),
		181: uint16(20915),
		182: uint16(35776),
		183: uint16(32477),
		184: uint16(22343),
		185: uint16(33740),
		186: uint16(38055),
		187: uint16(20891),
		188: uint16(21531),
		189: uint16(23803),
	},
	62: {
		0:   uint16(32251),
		1:   uint16(32252),
		2:   uint16(32253),
		3:   uint16(32254),
		4:   uint16(32255),
		5:   uint16(32256),
		6:   uint16(32257),
		7:   uint16(32258),
		8:   uint16(32259),
		9:   uint16(32260),
		10:  uint16(32261),
		11:  uint16(32262),
		12:  uint16(32263),
		13:  uint16(32264),
		14:  uint16(32265),
		15:  uint16(32266),
		16:  uint16(32267),
		17:  uint16(32268),
		18:  uint16(32269),
		19:  uint16(32270),
		20:  uint16(32271),
		21:  uint16(32272),
		22:  uint16(32273),
		23:  uint16(32274),
		24:  uint16(32275),
		25:  uint16(32276),
		26:  uint16(32277),
		27:  uint16(32278),
		28:  uint16(32279),
		29:  uint16(32280),
		30:  uint16(32281),
		31:  uint16(32282),
		32:  uint16(32283),
		33:  uint16(32284),
		34:  uint16(32285),
		35:  uint16(32286),
		36:  uint16(32287),
		37:  uint16(32288),
		38:  uint16(32289),
		39:  uint16(32290),
		40:  uint16(32291),
		41:  uint16(32292),
		42:  uint16(32293),
		43:  uint16(32294),
		44:  uint16(32295),
		45:  uint16(32296),
		46:  uint16(32297),
		47:  uint16(32298),
		48:  uint16(32299),
		49:  uint16(32300),
		50:  uint16(32301),
		51:  uint16(32302),
		52:  uint16(32303),
		53:  uint16(32304),
		54:  uint16(32305),
		55:  uint16(32306),
		56:  uint16(32307),
		57:  uint16(32308),
		58:  uint16(32309),
		59:  uint16(32310),
		60:  uint16(32311),
		61:  uint16(32312),
		62:  uint16(32313),
		63:  uint16(32314),
		64:  uint16(32316),
		65:  uint16(32317),
		66:  uint16(32318),
		67:  uint16(32319),
		68:  uint16(32320),
		69:  uint16(32322),
		70:  uint16(32323),
		71:  uint16(32324),
		72:  uint16(32325),
		73:  uint16(32326),
		74:  uint16(32328),
		75:  uint16(32329),
		76:  uint16(32330),
		77:  uint16(32331),
		78:  uint16(32332),
		79:  uint16(32333),
		80:  uint16(32334),
		81:  uint16(32335),
		82:  uint16(32336),
		83:  uint16(32337),
		84:  uint16(32338),
		85:  uint16(32339),
		86:  uint16(32340),
		87:  uint16(32341),
		88:  uint16(32342),
		89:  uint16(32343),
		90:  uint16(32344),
		91:  uint16(32345),
		92:  uint16(32346),
		93:  uint16(32347),
		94:  uint16(32348),
		95:  uint16(32349),
		96:  uint16(20426),
		97:  uint16(31459),
		98:  uint16(27994),
		99:  uint16(37089),
		100: uint16(39567),
		101: uint16(21888),
		102: uint16(21654),
		103: uint16(21345),
		104: uint16(21679),
		105: uint16(24320),
		106: uint16(25577),
		107: uint16(26999),
		108: uint16(20975),
		109: uint16(24936),
		110: uint16(21002),
		111: uint16(22570),
		112: uint16(21208),
		113: uint16(22350),
		114: uint16(30733),
		115: uint16(30475),
		116: uint16(24247),
		117: uint16(24951),
		118: uint16(31968),
		119: uint16(25179),
		120: uint16(25239),
		121: uint16(20130),
		122: uint16(28821),
		123: uint16(32771),
		124: uint16(25335),
		125: uint16(28900),
		126: uint16(38752),
		127: uint16(22391),
		128: uint16(33499),
		129: uint16(26607),
		130: uint16(26869),
		131: uint16(30933),
		132: uint16(39063),
		133: uint16(31185),
		134: uint16(22771),
		135: uint16(21683),
		136: uint16(21487),
		137: uint16(28212),
		138: uint16(20811),
		139: uint16(21051),
		140: uint16(23458),
		141: uint16(35838),
		142: uint16(32943),
		143: uint16(21827),
		144: uint16(22438),
		145: uint16(24691),
		146: uint16(22353),
		147: uint16(21549),
		148: uint16(31354),
		149: uint16(24656),
		150: uint16(23380),
		151: uint16(25511),
		152: uint16(25248),
		153: uint16(21475),
		154: uint16(25187),
		155: uint16(23495),
		156: uint16(26543),
		157: uint16(21741),
		158: uint16(31391),
		159: uint16(33510),
		160: uint16(37239),
		161: uint16(24211),
		162: uint16(35044),
		163: uint16(22840),
		164: uint16(22446),
		165: uint16(25358),
		166: uint16(36328),
		167: uint16(33007),
		168: uint16(22359),
		169: uint16(31607),
		170: uint16(20393),
		171: uint16(24555),
		172: uint16(23485),
		173: uint16(27454),
		174: uint16(21281),
		175: uint16(31568),
		176: uint16(29378),
		177: uint16(26694),
		178: uint16(30719),
		179: uint16(30518),
		180: uint16(26103),
		181: uint16(20917),
		182: uint16(20111),
		183: uint16(30420),
		184: uint16(23743),
		185: uint16(31397),
		186: uint16(33909),
		187: uint16(22862),
		188: uint16(39745),
		189: uint16(20608),
	},
	63: {
		0:   uint16(32350),
		1:   uint16(32351),
		2:   uint16(32352),
		3:   uint16(32353),
		4:   uint16(32354),
		5:   uint16(32355),
		6:   uint16(32356),
		7:   uint16(32357),
		8:   uint16(32358),
		9:   uint16(32359),
		10:  uint16(32360),
		11:  uint16(32361),
		12:  uint16(32362),
		13:  uint16(32363),
		14:  uint16(32364),
		15:  uint16(32365),
		16:  uint16(32366),
		17:  uint16(32367),
		18:  uint16(32368),
		19:  uint16(32369),
		20:  uint16(32370),
		21:  uint16(32371),
		22:  uint16(32372),
		23:  uint16(32373),
		24:  uint16(32374),
		25:  uint16(32375),
		26:  uint16(32376),
		27:  uint16(32377),
		28:  uint16(32378),
		29:  uint16(32379),
		30:  uint16(32380),
		31:  uint16(32381),
		32:  uint16(32382),
		33:  uint16(32383),
		34:  uint16(32384),
		35:  uint16(32385),
		36:  uint16(32387),
		37:  uint16(32388),
		38:  uint16(32389),
		39:  uint16(32390),
		40:  uint16(32391),
		41:  uint16(32392),
		42:  uint16(32393),
		43:  uint16(32394),
		44:  uint16(32395),
		45:  uint16(32396),
		46:  uint16(32397),
		47:  uint16(32398),
		48:  uint16(32399),
		49:  uint16(32400),
		50:  uint16(32401),
		51:  uint16(32402),
		52:  uint16(32403),
		53:  uint16(32404),
		54:  uint16(32405),
		55:  uint16(32406),
		56:  uint16(32407),
		57:  uint16(32408),
		58:  uint16(32409),
		59:  uint16(32410),
		60:  uint16(32412),
		61:  uint16(32413),
		62:  uint16(32414),
		63:  uint16(32430),
		64:  uint16(32436),
		65:  uint16(32443),
		66:  uint16(32444),
		67:  uint16(32470),
		68:  uint16(32484),
		69:  uint16(32492),
		70:  uint16(32505),
		71:  uint16(32522),
		72:  uint16(32528),
		73:  uint16(32542),
		74:  uint16(32567),
		75:  uint16(32569),
		76:  uint16(32571),
		77:  uint16(32572),
		78:  uint16(32573),
		79:  uint16(32574),
		80:  uint16(32575),
		81:  uint16(32576),
		82:  uint16(32577),
		83:  uint16(32579),
		84:  uint16(32582),
		85:  uint16(32583),
		86:  uint16(32584),
		87:  uint16(32585),
		88:  uint16(32586),
		89:  uint16(32587),
		90:  uint16(32588),
		91:  uint16(32589),
		92:  uint16(32590),
		93:  uint16(32591),
		94:  uint16(32594),
		95:  uint16(32595),
		96:  uint16(39304),
		97:  uint16(24871),
		98:  uint16(28291),
		99:  uint16(22372),
		100: uint16(26118),
		101: uint16(25414),
		102: uint16(22256),
		103: uint16(25324),
		104: uint16(25193),
		105: uint16(24275),
		106: uint16(38420),
		107: uint16(22403),
		108: uint16(25289),
		109: uint16(21895),
		110: uint16(34593),
		111: uint16(33098),
		112: uint16(36771),
		113: uint16(21862),
		114: uint16(33713),
		115: uint16(26469),
		116: uint16(36182),
		117: uint16(34013),
		118: uint16(23146),
		119: uint16(26639),
		120: uint16(25318),
		121: uint16(31726),
		122: uint16(38417),
		123: uint16(20848),
		124: uint16(28572),
		125: uint16(35888),
		126: uint16(25597),
		127: uint16(35272),
		128: uint16(25042),
		129: uint16(32518),
		130: uint16(28866),
		131: uint16(28389),
		132: uint16(29701),
		133: uint16(27028),
		134: uint16(29436),
		135: uint16(24266),
		136: uint16(37070),
		137: uint16(26391),
		138: uint16(28010),
		139: uint16(25438),
		140: uint16(21171),
		141: uint16(29282),
		142: uint16(32769),
		143: uint16(20332),
		144: uint16(23013),
		145: uint16(37226),
		146: uint16(28889),
		147: uint16(28061),
		148: uint16(21202),
		149: uint16(20048),
		150: uint16(38647),
		151: uint16(38253),
		152: uint16(34174),
		153: uint16(30922),
		154: uint16(32047),
		155: uint16(20769),
		156: uint16(22418),
		157: uint16(25794),
		158: uint16(32907),
		159: uint16(31867),
		160: uint16(27882),
		161: uint16(26865),
		162: uint16(26974),
		163: uint16(20919),
		164: uint16(21400),
		165: uint16(26792),
		166: uint16(29313),
		167: uint16(40654),
		168: uint16(31729),
		169: uint16(29432),
		170: uint16(31163),
		171: uint16(28435),
		172: uint16(29702),
		173: uint16(26446),
		174: uint16(37324),
		175: uint16(40100),
		176: uint16(31036),
		177: uint16(33673),
		178: uint16(33620),
		179: uint16(21519),
		180: uint16(26647),
		181: uint16(20029),
		182: uint16(21385),
		183: uint16(21169),
		184: uint16(30782),
		185: uint16(21382),
		186: uint16(21033),
		187: uint16(20616),
		188: uint16(20363),
		189: uint16(20432),
	},
	64: {
		0:   uint16(32598),
		1:   uint16(32601),
		2:   uint16(32603),
		3:   uint16(32604),
		4:   uint16(32605),
		5:   uint16(32606),
		6:   uint16(32608),
		7:   uint16(32611),
		8:   uint16(32612),
		9:   uint16(32613),
		10:  uint16(32614),
		11:  uint16(32615),
		12:  uint16(32619),
		13:  uint16(32620),
		14:  uint16(32621),
		15:  uint16(32623),
		16:  uint16(32624),
		17:  uint16(32627),
		18:  uint16(32629),
		19:  uint16(32630),
		20:  uint16(32631),
		21:  uint16(32632),
		22:  uint16(32634),
		23:  uint16(32635),
		24:  uint16(32636),
		25:  uint16(32637),
		26:  uint16(32639),
		27:  uint16(32640),
		28:  uint16(32642),
		29:  uint16(32643),
		30:  uint16(32644),
		31:  uint16(32645),
		32:  uint16(32646),
		33:  uint16(32647),
		34:  uint16(32648),
		35:  uint16(32649),
		36:  uint16(32651),
		37:  uint16(32653),
		38:  uint16(32655),
		39:  uint16(32656),
		40:  uint16(32657),
		41:  uint16(32658),
		42:  uint16(32659),
		43:  uint16(32661),
		44:  uint16(32662),
		45:  uint16(32663),
		46:  uint16(32664),
		47:  uint16(32665),
		48:  uint16(32667),
		49:  uint16(32668),
		50:  uint16(32672),
		51:  uint16(32674),
		52:  uint16(32675),
		53:  uint16(32677),
		54:  uint16(32678),
		55:  uint16(32680),
		56:  uint16(32681),
		57:  uint16(32682),
		58:  uint16(32683),
		59:  uint16(32684),
		60:  uint16(32685),
		61:  uint16(32686),
		62:  uint16(32689),
		63:  uint16(32691),
		64:  uint16(32692),
		65:  uint16(32693),
		66:  uint16(32694),
		67:  uint16(32695),
		68:  uint16(32698),
		69:  uint16(32699),
		70:  uint16(32702),
		71:  uint16(32704),
		72:  uint16(32706),
		73:  uint16(32707),
		74:  uint16(32708),
		75:  uint16(32710),
		76:  uint16(32711),
		77:  uint16(32712),
		78:  uint16(32713),
		79:  uint16(32715),
		80:  uint16(32717),
		81:  uint16(32719),
		82:  uint16(32720),
		83:  uint16(32721),
		84:  uint16(32722),
		85:  uint16(32723),
		86:  uint16(32726),
		87:  uint16(32727),
		88:  uint16(32729),
		89:  uint16(32730),
		90:  uint16(32731),
		91:  uint16(32732),
		92:  uint16(32733),
		93:  uint16(32734),
		94:  uint16(32738),
		95:  uint16(32739),
		96:  uint16(30178),
		97:  uint16(31435),
		98:  uint16(31890),
		99:  uint16(27813),
		100: uint16(38582),
		101: uint16(21147),
		102: uint16(29827),
		103: uint16(21737),
		104: uint16(20457),
		105: uint16(32852),
		106: uint16(33714),
		107: uint16(36830),
		108: uint16(38256),
		109: uint16(24265),
		110: uint16(24604),
		111: uint16(28063),
		112: uint16(24088),
		113: uint16(25947),
		114: uint16(33080),
		115: uint16(38142),
		116: uint16(24651),
		117: uint16(28860),
		118: uint16(32451),
		119: uint16(31918),
		120: uint16(20937),
		121: uint16(26753),
		122: uint16(31921),
		123: uint16(33391),
		124: uint16(20004),
		125: uint16(36742),
		126: uint16(37327),
		127: uint16(26238),
		128: uint16(20142),
		129: uint16(35845),
		130: uint16(25769),
		131: uint16(32842),
		132: uint16(20698),
		133: uint16(30103),
		134: uint16(29134),
		135: uint16(23525),
		136: uint16(36797),
		137: uint16(28518),
		138: uint16(20102),
		139: uint16(25730),
		140: uint16(38243),
		141: uint16(24278),
		142: uint16(26009),
		143: uint16(21015),
		144: uint16(35010),
		145: uint16(28872),
		146: uint16(21155),
		147: uint16(29454),
		148: uint16(29747),
		149: uint16(26519),
		150: uint16(30967),
		151: uint16(38678),
		152: uint16(20020),
		153: uint16(37051),
		154: uint16(40158),
		155: uint16(28107),
		156: uint16(20955),
		157: uint16(36161),
		158: uint16(21533),
		159: uint16(25294),
		160: uint16(29618),
		161: uint16(33777),
		162: uint16(38646),
		163: uint16(40836),
		164: uint16(38083),
		165: uint16(20278),
		166: uint16(32666),
		167: uint16(20940),
		168: uint16(28789),
		169: uint16(38517),
		170: uint16(23725),
		171: uint16(39046),
		172: uint16(21478),
		173: uint16(20196),
		174: uint16(28316),
		175: uint16(29705),
		176: uint16(27060),
		177: uint16(30827),
		178: uint16(39311),
		179: uint16(30041),
		180: uint16(21016),
		181: uint16(30244),
		182: uint16(27969),
		183: uint16(26611),
		184: uint16(20845),
		185: uint16(40857),
		186: uint16(32843),
		187: uint16(21657),
		188: uint16(31548),
		189: uint16(31423),
	},
	65: {
		0:   uint16(32740),
		1:   uint16(32743),
		2:   uint16(32744),
		3:   uint16(32746),
		4:   uint16(32747),
		5:   uint16(32748),
		6:   uint16(32749),
		7:   uint16(32751),
		8:   uint16(32754),
		9:   uint16(32756),
		10:  uint16(32757),
		11:  uint16(32758),
		12:  uint16(32759),
		13:  uint16(32760),
		14:  uint16(32761),
		15:  uint16(32762),
		16:  uint16(32765),
		17:  uint16(32766),
		18:  uint16(32767),
		19:  uint16(32770),
		20:  uint16(32775),
		21:  uint16(32776),
		22:  uint16(32777),
		23:  uint16(32778),
		24:  uint16(32782),
		25:  uint16(32783),
		26:  uint16(32785),
		27:  uint16(32787),
		28:  uint16(32794),
		29:  uint16(32795),
		30:  uint16(32797),
		31:  uint16(32798),
		32:  uint16(32799),
		33:  uint16(32801),
		34:  uint16(32803),
		35:  uint16(32804),
		36:  uint16(32811),
		37:  uint16(32812),
		38:  uint16(32813),
		39:  uint16(32814),
		40:  uint16(32815),
		41:  uint16(32816),
		42:  uint16(32818),
		43:  uint16(32820),
		44:  uint16(32825),
		45:  uint16(32826),
		46:  uint16(32828),
		47:  uint16(32830),
		48:  uint16(32832),
		49:  uint16(32833),
		50:  uint16(32836),
		51:  uint16(32837),
		52:  uint16(32839),
		53:  uint16(32840),
		54:  uint16(32841),
		55:  uint16(32846),
		56:  uint16(32847),
		57:  uint16(32848),
		58:  uint16(32849),
		59:  uint16(32851),
		60:  uint16(32853),
		61:  uint16(32854),
		62:  uint16(32855),
		63:  uint16(32857),
		64:  uint16(32859),
		65:  uint16(32860),
		66:  uint16(32861),
		67:  uint16(32862),
		68:  uint16(32863),
		69:  uint16(32864),
		70:  uint16(32865),
		71:  uint16(32866),
		72:  uint16(32867),
		73:  uint16(32868),
		74:  uint16(32869),
		75:  uint16(32870),
		76:  uint16(32871),
		77:  uint16(32872),
		78:  uint16(32875),
		79:  uint16(32876),
		80:  uint16(32877),
		81:  uint16(32878),
		82:  uint16(32879),
		83:  uint16(32880),
		84:  uint16(32882),
		85:  uint16(32883),
		86:  uint16(32884),
		87:  uint16(32885),
		88:  uint16(32886),
		89:  uint16(32887),
		90:  uint16(32888),
		91:  uint16(32889),
		92:  uint16(32890),
		93:  uint16(32891),
		94:  uint16(32892),
		95:  uint16(32893),
		96:  uint16(38534),
		97:  uint16(22404),
		98:  uint16(25314),
		99:  uint16(38471),
		100: uint16(27004),
		101: uint16(23044),
		102: uint16(25602),
		103: uint16(31699),
		104: uint16(28431),
		105: uint16(38475),
		106: uint16(33446),
		107: uint16(21346),
		108: uint16(39045),
		109: uint16(24208),
		110: uint16(28809),
		111: uint16(25523),
		112: uint16(21348),
		113: uint16(34383),
		114: uint16(40065),
		115: uint16(40595),
		116: uint16(30860),
		117: uint16(38706),
		118: uint16(36335),
		119: uint16(36162),
		120: uint16(40575),
		121: uint16(28510),
		122: uint16(31108),
		123: uint16(24405),
		124: uint16(38470),
		125: uint16(25134),
		126: uint16(39540),
		127: uint16(21525),
		128: uint16(38109),
		129: uint16(20387),
		130: uint16(26053),
		131: uint16(23653),
		132: uint16(23649),
		133: uint16(32533),
		134: uint16(34385),
		135: uint16(27695),
		136: uint16(24459),
		137: uint16(29575),
		138: uint16(28388),
		139: uint16(32511),
		140: uint16(23782),
		141: uint16(25371),
		142: uint16(23402),
		143: uint16(28390),
		144: uint16(21365),
		145: uint16(20081),
		146: uint16(25504),
		147: uint16(30053),
		148: uint16(25249),
		149: uint16(36718),
		150: uint16(20262),
		151: uint16(20177),
		152: uint16(27814),
		153: uint16(32438),
		154: uint16(35770),
		155: uint16(33821),
		156: uint16(34746),
		157: uint16(32599),
		158: uint16(36923),
		159: uint16(38179),
		160: uint16(31657),
		161: uint16(39585),
		162: uint16(35064),
		163: uint16(33853),
		164: uint16(27931),
		165: uint16(39558),
		166: uint16(32476),
		167: uint16(22920),
		168: uint16(40635),
		169: uint16(29595),
		170: uint16(30721),
		171: uint16(34434),
		172: uint16(39532),
		173: uint16(39554),
		174: uint16(22043),
		175: uint16(21527),
		176: uint16(22475),
		177: uint16(20080),
		178: uint16(40614),
		179: uint16(21334),
		180: uint16(36808),
		181: uint16(33033),
		182: uint16(30610),
		183: uint16(39314),
		184: uint16(34542),
		185: uint16(28385),
		186: uint16(34067),
		187: uint16(26364),
		188: uint16(24930),
		189: uint16(28459),
	},
	66: {
		0:   uint16(32894),
		1:   uint16(32897),
		2:   uint16(32898),
		3:   uint16(32901),
		4:   uint16(32904),
		5:   uint16(32906),
		6:   uint16(32909),
		7:   uint16(32910),
		8:   uint16(32911),
		9:   uint16(32912),
		10:  uint16(32913),
		11:  uint16(32914),
		12:  uint16(32916),
		13:  uint16(32917),
		14:  uint16(32919),
		15:  uint16(32921),
		16:  uint16(32926),
		17:  uint16(32931),
		18:  uint16(32934),
		19:  uint16(32935),
		20:  uint16(32936),
		21:  uint16(32940),
		22:  uint16(32944),
		23:  uint16(32947),
		24:  uint16(32949),
		25:  uint16(32950),
		26:  uint16(32952),
		27:  uint16(32953),
		28:  uint16(32955),
		29:  uint16(32965),
		30:  uint16(32967),
		31:  uint16(32968),
		32:  uint16(32969),
		33:  uint16(32970),
		34:  uint16(32971),
		35:  uint16(32975),
		36:  uint16(32976),
		37:  uint16(32977),
		38:  uint16(32978),
		39:  uint16(32979),
		40:  uint16(32980),
		41:  uint16(32981),
		42:  uint16(32984),
		43:  uint16(32991),
		44:  uint16(32992),
		45:  uint16(32994),
		46:  uint16(32995),
		47:  uint16(32998),
		48:  uint16(33006),
		49:  uint16(33013),
		50:  uint16(33015),
		51:  uint16(33017),
		52:  uint16(33019),
		53:  uint16(33022),
		54:  uint16(33023),
		55:  uint16(33024),
		56:  uint16(33025),
		57:  uint16(33027),
		58:  uint16(33028),
		59:  uint16(33029),
		60:  uint16(33031),
		61:  uint16(33032),
		62:  uint16(33035),
		63:  uint16(33036),
		64:  uint16(33045),
		65:  uint16(33047),
		66:  uint16(33049),
		67:  uint16(33051),
		68:  uint16(33052),
		69:  uint16(33053),
		70:  uint16(33055),
		71:  uint16(33056),
		72:  uint16(33057),
		73:  uint16(33058),
		74:  uint16(33059),
		75:  uint16(33060),
		76:  uint16(33061),
		77:  uint16(33062),
		78:  uint16(33063),
		79:  uint16(33064),
		80:  uint16(33065),
		81:  uint16(33066),
		82:  uint16(33067),
		83:  uint16(33069),
		84:  uint16(33070),
		85:  uint16(33072),
		86:  uint16(33075),
		87:  uint16(33076),
		88:  uint16(33077),
		89:  uint16(33079),
		90:  uint16(33081),
		91:  uint16(33082),
		92:  uint16(33083),
		93:  uint16(33084),
		94:  uint16(33085),
		95:  uint16(33087),
		96:  uint16(35881),
		97:  uint16(33426),
		98:  uint16(33579),
		99:  uint16(30450),
		100: uint16(27667),
		101: uint16(24537),
		102: uint16(33725),
		103: uint16(29483),
		104: uint16(33541),
		105: uint16(38170),
		106: uint16(27611),
		107: uint16(30683),
		108: uint16(38086),
		109: uint16(21359),
		110: uint16(33538),
		111: uint16(20882),
		112: uint16(24125),
		113: uint16(35980),
		114: uint16(36152),
		115: uint16(20040),
		116: uint16(29611),
		117: uint16(26522),
		118: uint16(26757),
		119: uint16(37238),
		120: uint16(38665),
		121: uint16(29028),
		122: uint16(27809),
		123: uint16(30473),
		124: uint16(23186),
		125: uint16(38209),
		126: uint16(27599),
		127: uint16(32654),
		128: uint16(26151),
		129: uint16(23504),
		130: uint16(22969),
		131: uint16(23194),
		132: uint16(38376),
		133: uint16(38391),
		134: uint16(20204),
		135: uint16(33804),
		136: uint16(33945),
		137: uint16(27308),
		138: uint16(30431),
		139: uint16(38192),
		140: uint16(29467),
		141: uint16(26790),
		142: uint16(23391),
		143: uint16(30511),
		144: uint16(37274),
		145: uint16(38753),
		146: uint16(31964),
		147: uint16(36855),
		148: uint16(35868),
		149: uint16(24357),
		150: uint16(31859),
		151: uint16(31192),
		152: uint16(35269),
		153: uint16(27852),
		154: uint16(34588),
		155: uint16(23494),
		156: uint16(24130),
		157: uint16(26825),
		158: uint16(30496),
		159: uint16(32501),
		160: uint16(20885),
		161: uint16(20813),
		162: uint16(21193),
		163: uint16(23081),
		164: uint16(32517),
		165: uint16(38754),
		166: uint16(33495),
		167: uint16(25551),
		168: uint16(30596),
		169: uint16(34256),
		170: uint16(31186),
		171: uint16(28218),
		172: uint16(24217),
		173: uint16(22937),
		174: uint16(34065),
		175: uint16(28781),
		176: uint16(27665),
		177: uint16(25279),
		178: uint16(30399),
		179: uint16(25935),
		180: uint16(24751),
		181: uint16(38397),
		182: uint16(26126),
		183: uint16(34719),
		184: uint16(40483),
		185: uint16(38125),
		186: uint16(21517),
		187: uint16(21629),
		188: uint16(35884),
		189: uint16(25720),
	},
	67: {
		0:   uint16(33088),
		1:   uint16(33089),
		2:   uint16(33090),
		3:   uint16(33091),
		4:   uint16(33092),
		5:   uint16(33093),
		6:   uint16(33095),
		7:   uint16(33097),
		8:   uint16(33101),
		9:   uint16(33102),
		10:  uint16(33103),
		11:  uint16(33106),
		12:  uint16(33110),
		13:  uint16(33111),
		14:  uint16(33112),
		15:  uint16(33115),
		16:  uint16(33116),
		17:  uint16(33117),
		18:  uint16(33118),
		19:  uint16(33119),
		20:  uint16(33121),
		21:  uint16(33122),
		22:  uint16(33123),
		23:  uint16(33124),
		24:  uint16(33126),
		25:  uint16(33128),
		26:  uint16(33130),
		27:  uint16(33131),
		28:  uint16(33132),
		29:  uint16(33135),
		30:  uint16(33138),
		31:  uint16(33139),
		32:  uint16(33141),
		33:  uint16(33142),
		34:  uint16(33143),
		35:  uint16(33144),
		36:  uint16(33153),
		37:  uint16(33155),
		38:  uint16(33156),
		39:  uint16(33157),
		40:  uint16(33158),
		41:  uint16(33159),
		42:  uint16(33161),
		43:  uint16(33163),
		44:  uint16(33164),
		45:  uint16(33165),
		46:  uint16(33166),
		47:  uint16(33168),
		48:  uint16(33170),
		49:  uint16(33171),
		50:  uint16(33172),
		51:  uint16(33173),
		52:  uint16(33174),
		53:  uint16(33175),
		54:  uint16(33177),
		55:  uint16(33178),
		56:  uint16(33182),
		57:  uint16(33183),
		58:  uint16(33184),
		59:  uint16(33185),
		60:  uint16(33186),
		61:  uint16(33188),
		62:  uint16(33189),
		63:  uint16(33191),
		64:  uint16(33193),
		65:  uint16(33195),
		66:  uint16(33196),
		67:  uint16(33197),
		68:  uint16(33198),
		69:  uint16(33199),
		70:  uint16(33200),
		71:  uint16(33201),
		72:  uint16(33202),
		73:  uint16(33204),
		74:  uint16(33205),
		75:  uint16(33206),
		76:  uint16(33207),
		77:  uint16(33208),
		78:  uint16(33209),
		79:  uint16(33212),
		80:  uint16(33213),
		81:  uint16(33214),
		82:  uint16(33215),
		83:  uint16(33220),
		84:  uint16(33221),
		85:  uint16(33223),
		86:  uint16(33224),
		87:  uint16(33225),
		88:  uint16(33227),
		89:  uint16(33229),
		90:  uint16(33230),
		91:  uint16(33231),
		92:  uint16(33232),
		93:  uint16(33233),
		94:  uint16(33234),
		95:  uint16(33235),
		96:  uint16(25721),
		97:  uint16(34321),
		98:  uint16(27169),
		99:  uint16(33180),
		100: uint16(30952),
		101: uint16(25705),
		102: uint16(39764),
		103: uint16(25273),
		104: uint16(26411),
		105: uint16(33707),
		106: uint16(22696),
		107: uint16(40664),
		108: uint16(27819),
		109: uint16(28448),
		110: uint16(23518),
		111: uint16(38476),
		112: uint16(35851),
		113: uint16(29279),
		114: uint16(26576),
		115: uint16(25287),
		116: uint16(29281),
		117: uint16(20137),
		118: uint16(22982),
		119: uint16(27597),
		120: uint16(22675),
		121: uint16(26286),
		122: uint16(24149),
		123: uint16(21215),
		124: uint16(24917),
		125: uint16(26408),
		126: uint16(30446),
		127: uint16(30566),
		128: uint16(29287),
		129: uint16(31302),
		130: uint16(25343),
		131: uint16(21738),
		132: uint16(21584),
		133: uint16(38048),
		134: uint16(37027),
		135: uint16(23068),
		136: uint16(32435),
		137: uint16(27670),
		138: uint16(20035),
		139: uint16(22902),
		140: uint16(32784),
		141: uint16(22856),
		142: uint16(21335),
		143: uint16(30007),
		144: uint16(38590),
		145: uint16(22218),
		146: uint16(25376),
		147: uint16(33041),
		148: uint16(24700),
		149: uint16(38393),
		150: uint16(28118),
		151: uint16(21602),
		152: uint16(39297),
		153: uint16(20869),
		154: uint16(23273),
		155: uint16(33021),
		156: uint16(22958),
		157: uint16(38675),
		158: uint16(20522),
		159: uint16(27877),
		160: uint16(23612),
		161: uint16(25311),
		162: uint16(20320),
		163: uint16(21311),
		164: uint16(33147),
		165: uint16(36870),
		166: uint16(28346),
		167: uint16(34091),
		168: uint16(25288),
		169: uint16(24180),
		170: uint16(30910),
		171: uint16(25781),
		172: uint16(25467),
		173: uint16(24565),
		174: uint16(23064),
		175: uint16(37247),
		176: uint16(40479),
		177: uint16(23615),
		178: uint16(25423),
		179: uint16(32834),
		180: uint16(23421),
		181: uint16(21870),
		182: uint16(38218),
		183: uint16(38221),
		184: uint16(28037),
		185: uint16(24744),
		186: uint16(26592),
		187: uint16(29406),
		188: uint16(20957),
		189: uint16(23425),
	},
	68: {
		0:   uint16(33236),
		1:   uint16(33237),
		2:   uint16(33238),
		3:   uint16(33239),
		4:   uint16(33240),
		5:   uint16(33241),
		6:   uint16(33242),
		7:   uint16(33243),
		8:   uint16(33244),
		9:   uint16(33245),
		10:  uint16(33246),
		11:  uint16(33247),
		12:  uint16(33248),
		13:  uint16(33249),
		14:  uint16(33250),
		15:  uint16(33252),
		16:  uint16(33253),
		17:  uint16(33254),
		18:  uint16(33256),
		19:  uint16(33257),
		20:  uint16(33259),
		21:  uint16(33262),
		22:  uint16(33263),
		23:  uint16(33264),
		24:  uint16(33265),
		25:  uint16(33266),
		26:  uint16(33269),
		27:  uint16(33270),
		28:  uint16(33271),
		29:  uint16(33272),
		30:  uint16(33273),
		31:  uint16(33274),
		32:  uint16(33277),
		33:  uint16(33279),
		34:  uint16(33283),
		35:  uint16(33287),
		36:  uint16(33288),
		37:  uint16(33289),
		38:  uint16(33290),
		39:  uint16(33291),
		40:  uint16(33294),
		41:  uint16(33295),
		42:  uint16(33297),
		43:  uint16(33299),
		44:  uint16(33301),
		45:  uint16(33302),
		46:  uint16(33303),
		47:  uint16(33304),
		48:  uint16(33305),
		49:  uint16(33306),
		50:  uint16(33309),
		51:  uint16(33312),
		52:  uint16(33316),
		53:  uint16(33317),
		54:  uint16(33318),
		55:  uint16(33319),
		56:  uint16(33321),
		57:  uint16(33326),
		58:  uint16(33330),
		59:  uint16(33338),
		60:  uint16(33340),
		61:  uint16(33341),
		62:  uint16(33343),
		63:  uint16(33344),
		64:  uint16(33345),
		65:  uint16(33346),
		66:  uint16(33347),
		67:  uint16(33349),
		68:  uint16(33350),
		69:  uint16(33352),
		70:  uint16(33354),
		71:  uint16(33356),
		72:  uint16(33357),
		73:  uint16(33358),
		74:  uint16(33360),
		75:  uint16(33361),
		76:  uint16(33362),
		77:  uint16(33363),
		78:  uint16(33364),
		79:  uint16(33365),
		80:  uint16(33366),
		81:  uint16(33367),
		82:  uint16(33369),
		83:  uint16(33371),
		84:  uint16(33372),
		85:  uint16(33373),
		86:  uint16(33374),
		87:  uint16(33376),
		88:  uint16(33377),
		89:  uint16(33378),
		90:  uint16(33379),
		91:  uint16(33380),
		92:  uint16(33381),
		93:  uint16(33382),
		94:  uint16(33383),
		95:  uint16(33385),
		96:  uint16(25319),
		97:  uint16(27870),
		98:  uint16(29275),
		99:  uint16(25197),
		100: uint16(38062),
		101: uint16(32445),
		102: uint16(33043),
		103: uint16(27987),
		104: uint16(20892),
		105: uint16(24324),
		106: uint16(22900),
		107: uint16(21162),
		108: uint16(24594),
		109: uint16(22899),
		110: uint16(26262),
		111: uint16(34384),
		112: uint16(30111),
		113: uint16(25386),
		114: uint16(25062),
		115: uint16(31983),
		116: uint16(35834),
		117: uint16(21734),
		118: uint16(27431),
		119: uint16(40485),
		120: uint16(27572),
		121: uint16(34261),
		122: uint16(21589),
		123: uint16(20598),
		124: uint16(27812),
		125: uint16(21866),
		126: uint16(36276),
		127: uint16(29228),
		128: uint16(24085),
		129: uint16(24597),
		130: uint16(29750),
		131: uint16(25293),
		132: uint16(25490),
		133: uint16(29260),
		134: uint16(24472),
		135: uint16(28227),
		136: uint16(27966),
		137: uint16(25856),
		138: uint16(28504),
		139: uint16(30424),
		140: uint16(30928),
		141: uint16(30460),
		142: uint16(30036),
		143: uint16(21028),
		144: uint16(21467),
		145: uint16(20051),
		146: uint16(24222),
		147: uint16(26049),
		148: uint16(32810),
		149: uint16(32982),
		150: uint16(25243),
		151: uint16(21638),
		152: uint16(21032),
		153: uint16(28846),
		154: uint16(34957),
		155: uint16(36305),
		156: uint16(27873),
		157: uint16(21624),
		158: uint16(32986),
		159: uint16(22521),
		160: uint16(35060),
		161: uint16(36180),
		162: uint16(38506),
		163: uint16(37197),
		164: uint16(20329),
		165: uint16(27803),
		166: uint16(21943),
		167: uint16(30406),
		168: uint16(30768),
		169: uint16(25256),
		170: uint16(28921),
		171: uint16(28558),
		172: uint16(24429),
		173: uint16(34028),
		174: uint16(26842),
		175: uint16(30844),
		176: uint16(31735),
		177: uint16(33192),
		178: uint16(26379),
		179: uint16(40527),
		180: uint16(25447),
		181: uint16(30896),
		182: uint16(22383),
		183: uint16(30738),
		184: uint16(38713),
		185: uint16(25209),
		186: uint16(25259),
		187: uint16(21128),
		188: uint16(29749),
		189: uint16(27607),
	},
	69: {
		0:   uint16(33386),
		1:   uint16(33387),
		2:   uint16(33388),
		3:   uint16(33389),
		4:   uint16(33393),
		5:   uint16(33397),
		6:   uint16(33398),
		7:   uint16(33399),
		8:   uint16(33400),
		9:   uint16(33403),
		10:  uint16(33404),
		11:  uint16(33408),
		12:  uint16(33409),
		13:  uint16(33411),
		14:  uint16(33413),
		15:  uint16(33414),
		16:  uint16(33415),
		17:  uint16(33417),
		18:  uint16(33420),
		19:  uint16(33424),
		20:  uint16(33427),
		21:  uint16(33428),
		22:  uint16(33429),
		23:  uint16(33430),
		24:  uint16(33434),
		25:  uint16(33435),
		26:  uint16(33438),
		27:  uint16(33440),
		28:  uint16(33442),
		29:  uint16(33443),
		30:  uint16(33447),
		31:  uint16(33458),
		32:  uint16(33461),
		33:  uint16(33462),
		34:  uint16(33466),
		35:  uint16(33467),
		36:  uint16(33468),
		37:  uint16(33471),
		38:  uint16(33472),
		39:  uint16(33474),
		40:  uint16(33475),
		41:  uint16(33477),
		42:  uint16(33478),
		43:  uint16(33481),
		44:  uint16(33488),
		45:  uint16(33494),
		46:  uint16(33497),
		47:  uint16(33498),
		48:  uint16(33501),
		49:  uint16(33506),
		50:  uint16(33511),
		51:  uint16(33512),
		52:  uint16(33513),
		53:  uint16(33514),
		54:  uint16(33516),
		55:  uint16(33517),
		56:  uint16(33518),
		57:  uint16(33520),
		58:  uint16(33522),
		59:  uint16(33523),
		60:  uint16(33525),
		61:  uint16(33526),
		62:  uint16(33528),
		63:  uint16(33530),
		64:  uint16(33532),
		65:  uint16(33533),
		66:  uint16(33534),
		67:  uint16(33535),
		68:  uint16(33536),
		69:  uint16(33546),
		70:  uint16(33547),
		71:  uint16(33549),
		72:  uint16(33552),
		73:  uint16(33554),
		74:  uint16(33555),
		75:  uint16(33558),
		76:  uint16(33560),
		77:  uint16(33561),
		78:  uint16(33565),
		79:  uint16(33566),
		80:  uint16(33567),
		81:  uint16(33568),
		82:  uint16(33569),
		83:  uint16(33570),
		84:  uint16(33571),
		85:  uint16(33572),
		86:  uint16(33573),
		87:  uint16(33574),
		88:  uint16(33577),
		89:  uint16(33578),
		90:  uint16(33582),
		91:  uint16(33584),
		92:  uint16(33586),
		93:  uint16(33591),
		94:  uint16(33595),
		95:  uint16(33597),
		96:  uint16(21860),
		97:  uint16(33086),
		98:  uint16(30130),
		99:  uint16(30382),
		100: uint16(21305),
		101: uint16(30174),
		102: uint16(20731),
		103: uint16(23617),
		104: uint16(35692),
		105: uint16(31687),
		106: uint16(20559),
		107: uint16(29255),
		108: uint16(39575),
		109: uint16(39128),
		110: uint16(28418),
		111: uint16(29922),
		112: uint16(31080),
		113: uint16(25735),
		114: uint16(30629),
		115: uint16(25340),
		116: uint16(39057),
		117: uint16(36139),
		118: uint16(21697),
		119: uint16(32856),
		120: uint16(20050),
		121: uint16(22378),
		122: uint16(33529),
		123: uint16(33805),
		124: uint16(24179),
		125: uint16(20973),
		126: uint16(29942),
		127: uint16(35780),
		128: uint16(23631),
		129: uint16(22369),
		130: uint16(27900),
		131: uint16(39047),
		132: uint16(23110),
		133: uint16(30772),
		134: uint16(39748),
		135: uint16(36843),
		136: uint16(31893),
		137: uint16(21078),
		138: uint16(25169),
		139: uint16(38138),
		140: uint16(20166),
		141: uint16(33670),
		142: uint16(33889),
		143: uint16(33769),
		144: uint16(33970),
		145: uint16(22484),
		146: uint16(26420),
		147: uint16(22275),
		148: uint16(26222),
		149: uint16(28006),
		150: uint16(35889),
		151: uint16(26333),
		152: uint16(28689),
		153: uint16(26399),
		154: uint16(27450),
		155: uint16(26646),
		156: uint16(25114),
		157: uint16(22971),
		158: uint16(19971),
		159: uint16(20932),
		160: uint16(28422),
		161: uint16(26578),
		162: uint16(27791),
		163: uint16(20854),
		164: uint16(26827),
		165: uint16(22855),
		166: uint16(27495),
		167: uint16(30054),
		168: uint16(23822),
		169: uint16(33040),
		170: uint16(40784),
		171: uint16(26071),
		172: uint16(31048),
		173: uint16(31041),
		174: uint16(39569),
		175: uint16(36215),
		176: uint16(23682),
		177: uint16(20062),
		178: uint16(20225),
		179: uint16(21551),
		180: uint16(22865),
		181: uint16(30732),
		182: uint16(22120),
		183: uint16(27668),
		184: uint16(36804),
		185: uint16(24323),
		186: uint16(27773),
		187: uint16(27875),
		188: uint16(35755),
		189: uint16(25488),
	},
	70: {
		0:   uint16(33598),
		1:   uint16(33599),
		2:   uint16(33601),
		3:   uint16(33602),
		4:   uint16(33604),
		5:   uint16(33605),
		6:   uint16(33608),
		7:   uint16(33610),
		8:   uint16(33611),
		9:   uint16(33612),
		10:  uint16(33613),
		11:  uint16(33614),
		12:  uint16(33619),
		13:  uint16(33621),
		14:  uint16(33622),
		15:  uint16(33623),
		16:  uint16(33624),
		17:  uint16(33625),
		18:  uint16(33629),
		19:  uint16(33634),
		20:  uint16(33648),
		21:  uint16(33649),
		22:  uint16(33650),
		23:  uint16(33651),
		24:  uint16(33652),
		25:  uint16(33653),
		26:  uint16(33654),
		27:  uint16(33657),
		28:  uint16(33658),
		29:  uint16(33662),
		30:  uint16(33663),
		31:  uint16(33664),
		32:  uint16(33665),
		33:  uint16(33666),
		34:  uint16(33667),
		35:  uint16(33668),
		36:  uint16(33671),
		37:  uint16(33672),
		38:  uint16(33674),
		39:  uint16(33675),
		40:  uint16(33676),
		41:  uint16(33677),
		42:  uint16(33679),
		43:  uint16(33680),
		44:  uint16(33681),
		45:  uint16(33684),
		46:  uint16(33685),
		47:  uint16(33686),
		48:  uint16(33687),
		49:  uint16(33689),
		50:  uint16(33690),
		51:  uint16(33693),
		52:  uint16(33695),
		53:  uint16(33697),
		54:  uint16(33698),
		55:  uint16(33699),
		56:  uint16(33700),
		57:  uint16(33701),
		58:  uint16(33702),
		59:  uint16(33703),
		60:  uint16(33708),
		61:  uint16(33709),
		62:  uint16(33710),
		63:  uint16(33711),
		64:  uint16(33717),
		65:  uint16(33723),
		66:  uint16(33726),
		67:  uint16(33727),
		68:  uint16(33730),
		69:  uint16(33731),
		70:  uint16(33732),
		71:  uint16(33734),
		72:  uint16(33736),
		73:  uint16(33737),
		74:  uint16(33739),
		75:  uint16(33741),
		76:  uint16(33742),
		77:  uint16(33744),
		78:  uint16(33745),
		79:  uint16(33746),
		80:  uint16(33747),
		81:  uint16(33749),
		82:  uint16(33751),
		83:  uint16(33753),
		84:  uint16(33754),
		85:  uint16(33755),
		86:  uint16(33758),
		87:  uint16(33762),
		88:  uint16(33763),
		89:  uint16(33764),
		90:  uint16(33766),
		91:  uint16(33767),
		92:  uint16(33768),
		93:  uint16(33771),
		94:  uint16(33772),
		95:  uint16(33773),
		96:  uint16(24688),
		97:  uint16(27965),
		98:  uint16(29301),
		99:  uint16(25190),
		100: uint16(38030),
		101: uint16(38085),
		102: uint16(21315),
		103: uint16(36801),
		104: uint16(31614),
		105: uint16(20191),
		106: uint16(35878),
		107: uint16(20094),
		108: uint16(40660),
		109: uint16(38065),
		110: uint16(38067),
		111: uint16(21069),
		112: uint16(28508),
		113: uint16(36963),
		114: uint16(27973),
		115: uint16(35892),
		116: uint16(22545),
		117: uint16(23884),
		118: uint16(27424),
		119: uint16(27465),
		120: uint16(26538),
		121: uint16(21595),
		122: uint16(33108),
		123: uint16(32652),
		124: uint16(22681),
		125: uint16(34103),
		126: uint16(24378),
		127: uint16(25250),
		128: uint16(27207),
		129: uint16(38201),
		130: uint16(25970),
		131: uint16(24708),
		132: uint16(26725),
		133: uint16(30631),
		134: uint16(20052),
		135: uint16(20392),
		136: uint16(24039),
		137: uint16(38808),
		138: uint16(25772),
		139: uint16(32728),
		140: uint16(23789),
		141: uint16(20431),
		142: uint16(31373),
		143: uint16(20999),
		144: uint16(33540),
		145: uint16(19988),
		146: uint16(24623),
		147: uint16(31363),
		148: uint16(38054),
		149: uint16(20405),
		150: uint16(20146),
		151: uint16(31206),
		152: uint16(29748),
		153: uint16(21220),
		154: uint16(33465),
		155: uint16(25810),
		156: uint16(31165),
		157: uint16(23517),
		158: uint16(27777),
		159: uint16(38738),
		160: uint16(36731),
		161: uint16(27682),
		162: uint16(20542),
		163: uint16(21375),
		164: uint16(28165),
		165: uint16(25806),
		166: uint16(26228),
		167: uint16(27696),
		168: uint16(24773),
		169: uint16(39031),
		170: uint16(35831),
		171: uint16(24198),
		172: uint16(29756),
		173: uint16(31351),
		174: uint16(31179),
		175: uint16(19992),
		176: uint16(37041),
		177: uint16(29699),
		178: uint16(27714),
		179: uint16(22234),
		180: uint16(37195),
		181: uint16(27845),
		182: uint16(36235),
		183: uint16(21306),
		184: uint16(34502),
		185: uint16(26354),
		186: uint16(36527),
		187: uint16(23624),
		188: uint16(39537),
		189: uint16(28192),
	},
	71: {
		0:   uint16(33774),
		1:   uint16(33775),
		2:   uint16(33779),
		3:   uint16(33780),
		4:   uint16(33781),
		5:   uint16(33782),
		6:   uint16(33783),
		7:   uint16(33786),
		8:   uint16(33787),
		9:   uint16(33788),
		10:  uint16(33790),
		11:  uint16(33791),
		12:  uint16(33792),
		13:  uint16(33794),
		14:  uint16(33797),
		15:  uint16(33799),
		16:  uint16(33800),
		17:  uint16(33801),
		18:  uint16(33802),
		19:  uint16(33808),
		20:  uint16(33810),
		21:  uint16(33811),
		22:  uint16(33812),
		23:  uint16(33813),
		24:  uint16(33814),
		25:  uint16(33815),
		26:  uint16(33817),
		27:  uint16(33818),
		28:  uint16(33819),
		29:  uint16(33822),
		30:  uint16(33823),
		31:  uint16(33824),
		32:  uint16(33825),
		33:  uint16(33826),
		34:  uint16(33827),
		35:  uint16(33833),
		36:  uint16(33834),
		37:  uint16(33835),
		38:  uint16(33836),
		39:  uint16(33837),
		40:  uint16(33838),
		41:  uint16(33839),
		42:  uint16(33840),
		43:  uint16(33842),
		44:  uint16(33843),
		45:  uint16(33844),
		46:  uint16(33845),
		47:  uint16(33846),
		48:  uint16(33847),
		49:  uint16(33849),
		50:  uint16(33850),
		51:  uint16(33851),
		52:  uint16(33854),
		53:  uint16(33855),
		54:  uint16(33856),
		55:  uint16(33857),
		56:  uint16(33858),
		57:  uint16(33859),
		58:  uint16(33860),
		59:  uint16(33861),
		60:  uint16(33863),
		61:  uint16(33864),
		62:  uint16(33865),
		63:  uint16(33866),
		64:  uint16(33867),
		65:  uint16(33868),
		66:  uint16(33869),
		67:  uint16(33870),
		68:  uint16(33871),
		69:  uint16(33872),
		70:  uint16(33874),
		71:  uint16(33875),
		72:  uint16(33876),
		73:  uint16(33877),
		74:  uint16(33878),
		75:  uint16(33880),
		76:  uint16(33885),
		77:  uint16(33886),
		78:  uint16(33887),
		79:  uint16(33888),
		80:  uint16(33890),
		81:  uint16(33892),
		82:  uint16(33893),
		83:  uint16(33894),
		84:  uint16(33895),
		85:  uint16(33896),
		86:  uint16(33898),
		87:  uint16(33902),
		88:  uint16(33903),
		89:  uint16(33904),
		90:  uint16(33906),
		91:  uint16(33908),
		92:  uint16(33911),
		93:  uint16(33913),
		94:  uint16(33915),
		95:  uint16(33916),
		96:  uint16(21462),
		97:  uint16(23094),
		98:  uint16(40843),
		99:  uint16(36259),
		100: uint16(21435),
		101: uint16(22280),
		102: uint16(39079),
		103: uint16(26435),
		104: uint16(37275),
		105: uint16(27849),
		106: uint16(20840),
		107: uint16(30154),
		108: uint16(25331),
		109: uint16(29356),
		110: uint16(21048),
		111: uint16(21149),
		112: uint16(32570),
		113: uint16(28820),
		114: uint16(30264),
		115: uint16(21364),
		116: uint16(40522),
		117: uint16(27063),
		118: uint16(30830),
		119: uint16(38592),
		120: uint16(35033),
		121: uint16(32676),
		122: uint16(28982),
		123: uint16(29123),
		124: uint16(20873),
		125: uint16(26579),
		126: uint16(29924),
		127: uint16(22756),
		128: uint16(25880),
		129: uint16(22199),
		130: uint16(35753),
		131: uint16(39286),
		132: uint16(25200),
		133: uint16(32469),
		134: uint16(24825),
		135: uint16(28909),
		136: uint16(22764),
		137: uint16(20161),
		138: uint16(20154),
		139: uint16(24525),
		140: uint16(38887),
		141: uint16(20219),
		142: uint16(35748),
		143: uint16(20995),
		144: uint16(22922),
		145: uint16(32427),
		146: uint16(25172),
		147: uint16(20173),
		148: uint16(26085),
		149: uint16(25102),
		150: uint16(33592),
		151: uint16(33993),
		152: uint16(33635),
		153: uint16(34701),
		154: uint16(29076),
		155: uint16(28342),
		156: uint16(23481),
		157: uint16(32466),
		158: uint16(20887),
		159: uint16(25545),
		160: uint16(26580),
		161: uint16(32905),
		162: uint16(33593),
		163: uint16(34837),
		164: uint16(20754),
		165: uint16(23418),
		166: uint16(22914),
		167: uint16(36785),
		168: uint16(20083),
		169: uint16(27741),
		170: uint16(20837),
		171: uint16(35109),
		172: uint16(36719),
		173: uint16(38446),
		174: uint16(34122),
		175: uint16(29790),
		176: uint16(38160),
		177: uint16(38384),
		178: uint16(28070),
		179: uint16(33509),
		180: uint16(24369),
		181: uint16(25746),
		182: uint16(27922),
		183: uint16(33832),
		184: uint16(33134),
		185: uint16(40131),
		186: uint16(22622),
		187: uint16(36187),
		188: uint16(19977),
		189: uint16(21441),
	},
	72: {
		0:   uint16(33917),
		1:   uint16(33918),
		2:   uint16(33919),
		3:   uint16(33920),
		4:   uint16(33921),
		5:   uint16(33923),
		6:   uint16(33924),
		7:   uint16(33925),
		8:   uint16(33926),
		9:   uint16(33930),
		10:  uint16(33933),
		11:  uint16(33935),
		12:  uint16(33936),
		13:  uint16(33937),
		14:  uint16(33938),
		15:  uint16(33939),
		16:  uint16(33940),
		17:  uint16(33941),
		18:  uint16(33942),
		19:  uint16(33944),
		20:  uint16(33946),
		21:  uint16(33947),
		22:  uint16(33949),
		23:  uint16(33950),
		24:  uint16(33951),
		25:  uint16(33952),
		26:  uint16(33954),
		27:  uint16(33955),
		28:  uint16(33956),
		29:  uint16(33957),
		30:  uint16(33958),
		31:  uint16(33959),
		32:  uint16(33960),
		33:  uint16(33961),
		34:  uint16(33962),
		35:  uint16(33963),
		36:  uint16(33964),
		37:  uint16(33965),
		38:  uint16(33966),
		39:  uint16(33968),
		40:  uint16(33969),
		41:  uint16(33971),
		42:  uint16(33973),
		43:  uint16(33974),
		44:  uint16(33975),
		45:  uint16(33979),
		46:  uint16(33980),
		47:  uint16(33982),
		48:  uint16(33984),
		49:  uint16(33986),
		50:  uint16(33987),
		51:  uint16(33989),
		52:  uint16(33990),
		53:  uint16(33991),
		54:  uint16(33992),
		55:  uint16(33995),
		56:  uint16(33996),
		57:  uint16(33998),
		58:  uint16(33999),
		59:  uint16(34002),
		60:  uint16(34004),
		61:  uint16(34005),
		62:  uint16(34007),
		63:  uint16(34008),
		64:  uint16(34009),
		65:  uint16(34010),
		66:  uint16(34011),
		67:  uint16(34012),
		68:  uint16(34014),
		69:  uint16(34017),
		70:  uint16(34018),
		71:  uint16(34020),
		72:  uint16(34023),
		73:  uint16(34024),
		74:  uint16(34025),
		75:  uint16(34026),
		76:  uint16(34027),
		77:  uint16(34029),
		78:  uint16(34030),
		79:  uint16(34031),
		80:  uint16(34033),
		81:  uint16(34034),
		82:  uint16(34035),
		83:  uint16(34036),
		84:  uint16(34037),
		85:  uint16(34038),
		86:  uint16(34039),
		87:  uint16(34040),
		88:  uint16(34041),
		89:  uint16(34042),
		90:  uint16(34043),
		91:  uint16(34045),
		92:  uint16(34046),
		93:  uint16(34048),
		94:  uint16(34049),
		95:  uint16(34050),
		96:  uint16(20254),
		97:  uint16(25955),
		98:  uint16(26705),
		99:  uint16(21971),
		100: uint16(20007),
		101: uint16(25620),
		102: uint16(39578),
		103: uint16(25195),
		104: uint16(23234),
		105: uint16(29791),
		106: uint16(33394),
		107: uint16(28073),
		108: uint16(26862),
		109: uint16(20711),
		110: uint16(33678),
		111: uint16(30722),
		112: uint16(26432),
		113: uint16(21049),
		114: uint16(27801),
		115: uint16(32433),
		116: uint16(20667),
		117: uint16(21861),
		118: uint16(29022),
		119: uint16(31579),
		120: uint16(26194),
		121: uint16(29642),
		122: uint16(33515),
		123: uint16(26441),
		124: uint16(23665),
		125: uint16(21024),
		126: uint16(29053),
		127: uint16(34923),
		128: uint16(38378),
		129: uint16(38485),
		130: uint16(25797),
		131: uint16(36193),
		132: uint16(33203),
		133: uint16(21892),
		134: uint16(27733),
		135: uint16(25159),
		136: uint16(32558),
		137: uint16(22674),
		138: uint16(20260),
		139: uint16(21830),
		140: uint16(36175),
		141: uint16(26188),
		142: uint16(19978),
		143: uint16(23578),
		144: uint16(35059),
		145: uint16(26786),
		146: uint16(25422),
		147: uint16(31245),
		148: uint16(28903),
		149: uint16(33421),
		150: uint16(21242),
		151: uint16(38902),
		152: uint16(23569),
		153: uint16(21736),
		154: uint16(37045),
		155: uint16(32461),
		156: uint16(22882),
		157: uint16(36170),
		158: uint16(34503),
		159: uint16(33292),
		160: uint16(33293),
		161: uint16(36198),
		162: uint16(25668),
		163: uint16(23556),
		164: uint16(24913),
		165: uint16(28041),
		166: uint16(31038),
		167: uint16(35774),
		168: uint16(30775),
		169: uint16(30003),
		170: uint16(21627),
		171: uint16(20280),
		172: uint16(36523),
		173: uint16(28145),
		174: uint16(23072),
		175: uint16(32453),
		176: uint16(31070),
		177: uint16(27784),
		178: uint16(23457),
		179: uint16(23158),
		180: uint16(29978),
		181: uint16(32958),
		182: uint16(24910),
		183: uint16(28183),
		184: uint16(22768),
		185: uint16(29983),
		186: uint16(29989),
		187: uint16(29298),
		188: uint16(21319),
		189: uint16(32499),
	},
	73: {
		0:   uint16(34051),
		1:   uint16(34052),
		2:   uint16(34053),
		3:   uint16(34054),
		4:   uint16(34055),
		5:   uint16(34056),
		6:   uint16(34057),
		7:   uint16(34058),
		8:   uint16(34059),
		9:   uint16(34061),
		10:  uint16(34062),
		11:  uint16(34063),
		12:  uint16(34064),
		13:  uint16(34066),
		14:  uint16(34068),
		15:  uint16(34069),
		16:  uint16(34070),
		17:  uint16(34072),
		18:  uint16(34073),
		19:  uint16(34075),
		20:  uint16(34076),
		21:  uint16(34077),
		22:  uint16(34078),
		23:  uint16(34080),
		24:  uint16(34082),
		25:  uint16(34083),
		26:  uint16(34084),
		27:  uint16(34085),
		28:  uint16(34086),
		29:  uint16(34087),
		30:  uint16(34088),
		31:  uint16(34089),
		32:  uint16(34090),
		33:  uint16(34093),
		34:  uint16(34094),
		35:  uint16(34095),
		36:  uint16(34096),
		37:  uint16(34097),
		38:  uint16(34098),
		39:  uint16(34099),
		40:  uint16(34100),
		41:  uint16(34101),
		42:  uint16(34102),
		43:  uint16(34110),
		44:  uint16(34111),
		45:  uint16(34112),
		46:  uint16(34113),
		47:  uint16(34114),
		48:  uint16(34116),
		49:  uint16(34117),
		50:  uint16(34118),
		51:  uint16(34119),
		52:  uint16(34123),
		53:  uint16(34124),
		54:  uint16(34125),
		55:  uint16(34126),
		56:  uint16(34127),
		57:  uint16(34128),
		58:  uint16(34129),
		59:  uint16(34130),
		60:  uint16(34131),
		61:  uint16(34132),
		62:  uint16(34133),
		63:  uint16(34135),
		64:  uint16(34136),
		65:  uint16(34138),
		66:  uint16(34139),
		67:  uint16(34140),
		68:  uint16(34141),
		69:  uint16(34143),
		70:  uint16(34144),
		71:  uint16(34145),
		72:  uint16(34146),
		73:  uint16(34147),
		74:  uint16(34149),
		75:  uint16(34150),
		76:  uint16(34151),
		77:  uint16(34153),
		78:  uint16(34154),
		79:  uint16(34155),
		80:  uint16(34156),
		81:  uint16(34157),
		82:  uint16(34158),
		83:  uint16(34159),
		84:  uint16(34160),
		85:  uint16(34161),
		86:  uint16(34163),
		87:  uint16(34165),
		88:  uint16(34166),
		89:  uint16(34167),
		90:  uint16(34168),
		91:  uint16(34172),
		92:  uint16(34173),
		93:  uint16(34175),
		94:  uint16(34176),
		95:  uint16(34177),
		96:  uint16(30465),
		97:  uint16(30427),
		98:  uint16(21097),
		99:  uint16(32988),
		100: uint16(22307),
		101: uint16(24072),
		102: uint16(22833),
		103: uint16(29422),
		104: uint16(26045),
		105: uint16(28287),
		106: uint16(35799),
		107: uint16(23608),
		108: uint16(34417),
		109: uint16(21313),
		110: uint16(30707),
		111: uint16(25342),
		112: uint16(26102),
		113: uint16(20160),
		114: uint16(39135),
		115: uint16(34432),
		116: uint16(23454),
		117: uint16(35782),
		118: uint16(21490),
		119: uint16(30690),
		120: uint16(20351),
		121: uint16(23630),
		122: uint16(39542),
		123: uint16(22987),
		124: uint16(24335),
		125: uint16(31034),
		126: uint16(22763),
		127: uint16(19990),
		128: uint16(26623),
		129: uint16(20107),
		130: uint16(25325),
		131: uint16(35475),
		132: uint16(36893),
		133: uint16(21183),
		134: uint16(26159),
		135: uint16(21980),
		136: uint16(22124),
		137: uint16(36866),
		138: uint16(20181),
		139: uint16(20365),
		140: uint16(37322),
		141: uint16(39280),
		142: uint16(27663),
		143: uint16(24066),
		144: uint16(24643),
		145: uint16(23460),
		146: uint16(35270),
		147: uint16(35797),
		148: uint16(25910),
		149: uint16(25163),
		150: uint16(39318),
		151: uint16(23432),
		152: uint16(23551),
		153: uint16(25480),
		154: uint16(21806),
		155: uint16(21463),
		156: uint16(30246),
		157: uint16(20861),
		158: uint16(34092),
		159: uint16(26530),
		160: uint16(26803),
		161: uint16(27530),
		162: uint16(25234),
		163: uint16(36755),
		164: uint16(21460),
		165: uint16(33298),
		166: uint16(28113),
		167: uint16(30095),
		168: uint16(20070),
		169: uint16(36174),
		170: uint16(23408),
		171: uint16(29087),
		172: uint16(34223),
		173: uint16(26257),
		174: uint16(26329),
		175: uint16(32626),
		176: uint16(34560),
		177: uint16(40653),
		178: uint16(40736),
		179: uint16(23646),
		180: uint16(26415),
		181: uint16(36848),
		182: uint16(26641),
		183: uint16(26463),
		184: uint16(25101),
		185: uint16(31446),
		186: uint16(22661),
		187: uint16(24246),
		188: uint16(25968),
		189: uint16(28465),
	},
	74: {
		0:   uint16(34178),
		1:   uint16(34179),
		2:   uint16(34182),
		3:   uint16(34184),
		4:   uint16(34185),
		5:   uint16(34186),
		6:   uint16(34187),
		7:   uint16(34188),
		8:   uint16(34189),
		9:   uint16(34190),
		10:  uint16(34192),
		11:  uint16(34193),
		12:  uint16(34194),
		13:  uint16(34195),
		14:  uint16(34196),
		15:  uint16(34197),
		16:  uint16(34198),
		17:  uint16(34199),
		18:  uint16(34200),
		19:  uint16(34201),
		20:  uint16(34202),
		21:  uint16(34205),
		22:  uint16(34206),
		23:  uint16(34207),
		24:  uint16(34208),
		25:  uint16(34209),
		26:  uint16(34210),
		27:  uint16(34211),
		28:  uint16(34213),
		29:  uint16(34214),
		30:  uint16(34215),
		31:  uint16(34217),
		32:  uint16(34219),
		33:  uint16(34220),
		34:  uint16(34221),
		35:  uint16(34225),
		36:  uint16(34226),
		37:  uint16(34227),
		38:  uint16(34228),
		39:  uint16(34229),
		40:  uint16(34230),
		41:  uint16(34232),
		42:  uint16(34234),
		43:  uint16(34235),
		44:  uint16(34236),
		45:  uint16(34237),
		46:  uint16(34238),
		47:  uint16(34239),
		48:  uint16(34240),
		49:  uint16(34242),
		50:  uint16(34243),
		51:  uint16(34244),
		52:  uint16(34245),
		53:  uint16(34246),
		54:  uint16(34247),
		55:  uint16(34248),
		56:  uint16(34250),
		57:  uint16(34251),
		58:  uint16(34252),
		59:  uint16(34253),
		60:  uint16(34254),
		61:  uint16(34257),
		62:  uint16(34258),
		63:  uint16(34260),
		64:  uint16(34262),
		65:  uint16(34263),
		66:  uint16(34264),
		67:  uint16(34265),
		68:  uint16(34266),
		69:  uint16(34267),
		70:  uint16(34269),
		71:  uint16(34270),
		72:  uint16(34271),
		73:  uint16(34272),
		74:  uint16(34273),
		75:  uint16(34274),
		76:  uint16(34275),
		77:  uint16(34277),
		78:  uint16(34278),
		79:  uint16(34279),
		80:  uint16(34280),
		81:  uint16(34282),
		82:  uint16(34283),
		83:  uint16(34284),
		84:  uint16(34285),
		85:  uint16(34286),
		86:  uint16(34287),
		87:  uint16(34288),
		88:  uint16(34289),
		89:  uint16(34290),
		90:  uint16(34291),
		91:  uint16(34292),
		92:  uint16(34293),
		93:  uint16(34294),
		94:  uint16(34295),
		95:  uint16(34296),
		96:  uint16(24661),
		97:  uint16(21047),
		98:  uint16(32781),
		99:  uint16(25684),
		100: uint16(34928),
		101: uint16(29993),
		102: uint16(24069),
		103: uint16(26643),
		104: uint16(25332),
		105: uint16(38684),
		106: uint16(21452),
		107: uint16(29245),
		108: uint16(35841),
		109: uint16(27700),
		110: uint16(30561),
		111: uint16(31246),
		112: uint16(21550),
		113: uint16(30636),
		114: uint16(39034),
		115: uint16(33308),
		116: uint16(35828),
		117: uint16(30805),
		118: uint16(26388),
		119: uint16(28865),
		120: uint16(26031),
		121: uint16(25749),
		122: uint16(22070),
		123: uint16(24605),
		124: uint16(31169),
		125: uint16(21496),
		126: uint16(19997),
		127: uint16(27515),
		128: uint16(32902),
		129: uint16(23546),
		130: uint16(21987),
		131: uint16(22235),
		132: uint16(20282),
		133: uint16(20284),
		134: uint16(39282),
		135: uint16(24051),
		136: uint16(26494),
		137: uint16(32824),
		138: uint16(24578),
		139: uint16(39042),
		140: uint16(36865),
		141: uint16(23435),
		142: uint16(35772),
		143: uint16(35829),
		144: uint16(25628),
		145: uint16(33368),
		146: uint16(25822),
		147: uint16(22013),
		148: uint16(33487),
		149: uint16(37221),
		150: uint16(20439),
		151: uint16(32032),
		152: uint16(36895),
		153: uint16(31903),
		154: uint16(20723),
		155: uint16(22609),
		156: uint16(28335),
		157: uint16(23487),
		158: uint16(35785),
		159: uint16(32899),
		160: uint16(37240),
		161: uint16(33948),
		162: uint16(31639),
		163: uint16(34429),
		164: uint16(38539),
		165: uint16(38543),
		166: uint16(32485),
		167: uint16(39635),
		168: uint16(30862),
		169: uint16(23681),
		170: uint16(31319),
		171: uint16(36930),
		172: uint16(38567),
		173: uint16(31071),
		174: uint16(23385),
		175: uint16(25439),
		176: uint16(31499),
		177: uint16(34001),
		178: uint16(26797),
		179: uint16(21766),
		180: uint16(32553),
		181: uint16(29712),
		182: uint16(32034),
		183: uint16(38145),
		184: uint16(25152),
		185: uint16(22604),
		186: uint16(20182),
		187: uint16(23427),
		188: uint16(22905),
		189: uint16(22612),
	},
	75: {
		0:   uint16(34297),
		1:   uint16(34298),
		2:   uint16(34300),
		3:   uint16(34301),
		4:   uint16(34302),
		5:   uint16(34304),
		6:   uint16(34305),
		7:   uint16(34306),
		8:   uint16(34307),
		9:   uint16(34308),
		10:  uint16(34310),
		11:  uint16(34311),
		12:  uint16(34312),
		13:  uint16(34313),
		14:  uint16(34314),
		15:  uint16(34315),
		16:  uint16(34316),
		17:  uint16(34317),
		18:  uint16(34318),
		19:  uint16(34319),
		20:  uint16(34320),
		21:  uint16(34322),
		22:  uint16(34323),
		23:  uint16(34324),
		24:  uint16(34325),
		25:  uint16(34327),
		26:  uint16(34328),
		27:  uint16(34329),
		28:  uint16(34330),
		29:  uint16(34331),
		30:  uint16(34332),
		31:  uint16(34333),
		32:  uint16(34334),
		33:  uint16(34335),
		34:  uint16(34336),
		35:  uint16(34337),
		36:  uint16(34338),
		37:  uint16(34339),
		38:  uint16(34340),
		39:  uint16(34341),
		40:  uint16(34342),
		41:  uint16(34344),
		42:  uint16(34346),
		43:  uint16(34347),
		44:  uint16(34348),
		45:  uint16(34349),
		46:  uint16(34350),
		47:  uint16(34351),
		48:  uint16(34352),
		49:  uint16(34353),
		50:  uint16(34354),
		51:  uint16(34355),
		52:  uint16(34356),
		53:  uint16(34357),
		54:  uint16(34358),
		55:  uint16(34359),
		56:  uint16(34361),
		57:  uint16(34362),
		58:  uint16(34363),
		59:  uint16(34365),
		60:  uint16(34366),
		61:  uint16(34367),
		62:  uint16(34368),
		63:  uint16(34369),
		64:  uint16(34370),
		65:  uint16(34371),
		66:  uint16(34372),
		67:  uint16(34373),
		68:  uint16(34374),
		69:  uint16(34375),
		70:  uint16(34376),
		71:  uint16(34377),
		72:  uint16(34378),
		73:  uint16(34379),
		74:  uint16(34380),
		75:  uint16(34386),
		76:  uint16(34387),
		77:  uint16(34389),
		78:  uint16(34390),
		79:  uint16(34391),
		80:  uint16(34392),
		81:  uint16(34393),
		82:  uint16(34395),
		83:  uint16(34396),
		84:  uint16(34397),
		85:  uint16(34399),
		86:  uint16(34400),
		87:  uint16(34401),
		88:  uint16(34403),
		89:  uint16(34404),
		90:  uint16(34405),
		91:  uint16(34406),
		92:  uint16(34407),
		93:  uint16(34408),
		94:  uint16(34409),
		95:  uint16(34410),
		96:  uint16(29549),
		97:  uint16(25374),
		98:  uint16(36427),
		99:  uint16(36367),
		100: uint16(32974),
		101: uint16(33492),
		102: uint16(25260),
		103: uint16(21488),
		104: uint16(27888),
		105: uint16(37214),
		106: uint16(22826),
		107: uint16(24577),
		108: uint16(27760),
		109: uint16(22349),
		110: uint16(25674),
		111: uint16(36138),
		112: uint16(30251),
		113: uint16(28393),
		114: uint16(22363),
		115: uint16(27264),
		116: uint16(30192),
		117: uint16(28525),
		118: uint16(35885),
		119: uint16(35848),
		120: uint16(22374),
		121: uint16(27631),
		122: uint16(34962),
		123: uint16(30899),
		124: uint16(25506),
		125: uint16(21497),
		126: uint16(28845),
		127: uint16(27748),
		128: uint16(22616),
		129: uint16(25642),
		130: uint16(22530),
		131: uint16(26848),
		132: uint16(33179),
		133: uint16(21776),
		134: uint16(31958),
		135: uint16(20504),
		136: uint16(36538),
		137: uint16(28108),
		138: uint16(36255),
		139: uint16(28907),
		140: uint16(25487),
		141: uint16(28059),
		142: uint16(28372),
		143: uint16(32486),
		144: uint16(33796),
		145: uint16(26691),
		146: uint16(36867),
		147: uint16(28120),
		148: uint16(38518),
		149: uint16(35752),
		150: uint16(22871),
		151: uint16(29305),
		152: uint16(34276),
		153: uint16(33150),
		154: uint16(30140),
		155: uint16(35466),
		156: uint16(26799),
		157: uint16(21076),
		158: uint16(36386),
		159: uint16(38161),
		160: uint16(25552),
		161: uint16(39064),
		162: uint16(36420),
		163: uint16(21884),
		164: uint16(20307),
		165: uint16(26367),
		166: uint16(22159),
		167: uint16(24789),
		168: uint16(28053),
		169: uint16(21059),
		170: uint16(23625),
		171: uint16(22825),
		172: uint16(28155),
		173: uint16(22635),
		174: uint16(30000),
		175: uint16(29980),
		176: uint16(24684),
		177: uint16(33300),
		178: uint16(33094),
		179: uint16(25361),
		180: uint16(26465),
		181: uint16(36834),
		182: uint16(30522),
		183: uint16(36339),
		184: uint16(36148),
		185: uint16(38081),
		186: uint16(24086),
		187: uint16(21381),
		188: uint16(21548),
		189: uint16(28867),
	},
	76: {
		0:   uint16(34413),
		1:   uint16(34415),
		2:   uint16(34416),
		3:   uint16(34418),
		4:   uint16(34419),
		5:   uint16(34420),
		6:   uint16(34421),
		7:   uint16(34422),
		8:   uint16(34423),
		9:   uint16(34424),
		10:  uint16(34435),
		11:  uint16(34436),
		12:  uint16(34437),
		13:  uint16(34438),
		14:  uint16(34439),
		15:  uint16(34440),
		16:  uint16(34441),
		17:  uint16(34446),
		18:  uint16(34447),
		19:  uint16(34448),
		20:  uint16(34449),
		21:  uint16(34450),
		22:  uint16(34452),
		23:  uint16(34454),
		24:  uint16(34455),
		25:  uint16(34456),
		26:  uint16(34457),
		27:  uint16(34458),
		28:  uint16(34459),
		29:  uint16(34462),
		30:  uint16(34463),
		31:  uint16(34464),
		32:  uint16(34465),
		33:  uint16(34466),
		34:  uint16(34469),
		35:  uint16(34470),
		36:  uint16(34475),
		37:  uint16(34477),
		38:  uint16(34478),
		39:  uint16(34482),
		40:  uint16(34483),
		41:  uint16(34487),
		42:  uint16(34488),
		43:  uint16(34489),
		44:  uint16(34491),
		45:  uint16(34492),
		46:  uint16(34493),
		47:  uint16(34494),
		48:  uint16(34495),
		49:  uint16(34497),
		50:  uint16(34498),
		51:  uint16(34499),
		52:  uint16(34501),
		53:  uint16(34504),
		54:  uint16(34508),
		55:  uint16(34509),
		56:  uint16(34514),
		57:  uint16(34515),
		58:  uint16(34517),
		59:  uint16(34518),
		60:  uint16(34519),
		61:  uint16(34522),
		62:  uint16(34524),
		63:  uint16(34525),
		64:  uint16(34528),
		65:  uint16(34529),
		66:  uint16(34530),
		67:  uint16(34531),
		68:  uint16(34533),
		69:  uint16(34534),
		70:  uint16(34535),
		71:  uint16(34536),
		72:  uint16(34538),
		73:  uint16(34539),
		74:  uint16(34540),
		75:  uint16(34543),
		76:  uint16(34549),
		77:  uint16(34550),
		78:  uint16(34551),
		79:  uint16(34554),
		80:  uint16(34555),
		81:  uint16(34556),
		82:  uint16(34557),
		83:  uint16(34559),
		84:  uint16(34561),
		85:  uint16(34564),
		86:  uint16(34565),
		87:  uint16(34566),
		88:  uint16(34571),
		89:  uint16(34572),
		90:  uint16(34574),
		91:  uint16(34575),
		92:  uint16(34576),
		93:  uint16(34577),
		94:  uint16(34580),
		95:  uint16(34582),
		96:  uint16(27712),
		97:  uint16(24311),
		98:  uint16(20572),
		99:  uint16(20141),
		100: uint16(24237),
		101: uint16(25402),
		102: uint16(33351),
		103: uint16(36890),
		104: uint16(26704),
		105: uint16(37230),
		106: uint16(30643),
		107: uint16(21516),
		108: uint16(38108),
		109: uint16(24420),
		110: uint16(31461),
		111: uint16(26742),
		112: uint16(25413),
		113: uint16(31570),
		114: uint16(32479),
		115: uint16(30171),
		116: uint16(20599),
		117: uint16(25237),
		118: uint16(22836),
		119: uint16(36879),
		120: uint16(20984),
		121: uint16(31171),
		122: uint16(31361),
		123: uint16(22270),
		124: uint16(24466),
		125: uint16(36884),
		126: uint16(28034),
		127: uint16(23648),
		128: uint16(22303),
		129: uint16(21520),
		130: uint16(20820),
		131: uint16(28237),
		132: uint16(22242),
		133: uint16(25512),
		134: uint16(39059),
		135: uint16(33151),
		136: uint16(34581),
		137: uint16(35114),
		138: uint16(36864),
		139: uint16(21534),
		140: uint16(23663),
		141: uint16(33216),
		142: uint16(25302),
		143: uint16(25176),
		144: uint16(33073),
		145: uint16(40501),
		146: uint16(38464),
		147: uint16(39534),
		148: uint16(39548),
		149: uint16(26925),
		150: uint16(22949),
		151: uint16(25299),
		152: uint16(21822),
		153: uint16(25366),
		154: uint16(21703),
		155: uint16(34521),
		156: uint16(27964),
		157: uint16(23043),
		158: uint16(29926),
		159: uint16(34972),
		160: uint16(27498),
		161: uint16(22806),
		162: uint16(35916),
		163: uint16(24367),
		164: uint16(28286),
		165: uint16(29609),
		166: uint16(39037),
		167: uint16(20024),
		168: uint16(28919),
		169: uint16(23436),
		170: uint16(30871),
		171: uint16(25405),
		172: uint16(26202),
		173: uint16(30358),
		174: uint16(24779),
		175: uint16(23451),
		176: uint16(23113),
		177: uint16(19975),
		178: uint16(33109),
		179: uint16(27754),
		180: uint16(29579),
		181: uint16(20129),
		182: uint16(26505),
		183: uint16(32593),
		184: uint16(24448),
		185: uint16(26106),
		186: uint16(26395),
		187: uint16(24536),
		188: uint16(22916),
		189: uint16(23041),
	},
	77: {
		0:   uint16(34585),
		1:   uint16(34587),
		2:   uint16(34589),
		3:   uint16(34591),
		4:   uint16(34592),
		5:   uint16(34596),
		6:   uint16(34598),
		7:   uint16(34599),
		8:   uint16(34600),
		9:   uint16(34602),
		10:  uint16(34603),
		11:  uint16(34604),
		12:  uint16(34605),
		13:  uint16(34607),
		14:  uint16(34608),
		15:  uint16(34610),
		16:  uint16(34611),
		17:  uint16(34613),
		18:  uint16(34614),
		19:  uint16(34616),
		20:  uint16(34617),
		21:  uint16(34618),
		22:  uint16(34620),
		23:  uint16(34621),
		24:  uint16(34624),
		25:  uint16(34625),
		26:  uint16(34626),
		27:  uint16(34627),
		28:  uint16(34628),
		29:  uint16(34629),
		30:  uint16(34630),
		31:  uint16(34634),
		32:  uint16(34635),
		33:  uint16(34637),
		34:  uint16(34639),
		35:  uint16(34640),
		36:  uint16(34641),
		37:  uint16(34642),
		38:  uint16(34644),
		39:  uint16(34645),
		40:  uint16(34646),
		41:  uint16(34648),
		42:  uint16(34650),
		43:  uint16(34651),
		44:  uint16(34652),
		45:  uint16(34653),
		46:  uint16(34654),
		47:  uint16(34655),
		48:  uint16(34657),
		49:  uint16(34658),
		50:  uint16(34662),
		51:  uint16(34663),
		52:  uint16(34664),
		53:  uint16(34665),
		54:  uint16(34666),
		55:  uint16(34667),
		56:  uint16(34668),
		57:  uint16(34669),
		58:  uint16(34671),
		59:  uint16(34673),
		60:  uint16(34674),
		61:  uint16(34675),
		62:  uint16(34677),
		63:  uint16(34679),
		64:  uint16(34680),
		65:  uint16(34681),
		66:  uint16(34682),
		67:  uint16(34687),
		68:  uint16(34688),
		69:  uint16(34689),
		70:  uint16(34692),
		71:  uint16(34694),
		72:  uint16(34695),
		73:  uint16(34697),
		74:  uint16(34698),
		75:  uint16(34700),
		76:  uint16(34702),
		77:  uint16(34703),
		78:  uint16(34704),
		79:  uint16(34705),
		80:  uint16(34706),
		81:  uint16(34708),
		82:  uint16(34709),
		83:  uint16(34710),
		84:  uint16(34712),
		85:  uint16(34713),
		86:  uint16(34714),
		87:  uint16(34715),
		88:  uint16(34716),
		89:  uint16(34717),
		90:  uint16(34718),
		91:  uint16(34720),
		92:  uint16(34721),
		93:  uint16(34722),
		94:  uint16(34723),
		95:  uint16(34724),
		96:  uint16(24013),
		97:  uint16(24494),
		98:  uint16(21361),
		99:  uint16(38886),
		100: uint16(36829),
		101: uint16(26693),
		102: uint16(22260),
		103: uint16(21807),
		104: uint16(24799),
		105: uint16(20026),
		106: uint16(28493),
		107: uint16(32500),
		108: uint16(33479),
		109: uint16(33806),
		110: uint16(22996),
		111: uint16(20255),
		112: uint16(20266),
		113: uint16(23614),
		114: uint16(32428),
		115: uint16(26410),
		116: uint16(34074),
		117: uint16(21619),
		118: uint16(30031),
		119: uint16(32963),
		120: uint16(21890),
		121: uint16(39759),
		122: uint16(20301),
		123: uint16(28205),
		124: uint16(35859),
		125: uint16(23561),
		126: uint16(24944),
		127: uint16(21355),
		128: uint16(30239),
		129: uint16(28201),
		130: uint16(34442),
		131: uint16(25991),
		132: uint16(38395),
		133: uint16(32441),
		134: uint16(21563),
		135: uint16(31283),
		136: uint16(32010),
		137: uint16(38382),
		138: uint16(21985),
		139: uint16(32705),
		140: uint16(29934),
		141: uint16(25373),
		142: uint16(34583),
		143: uint16(28065),
		144: uint16(31389),
		145: uint16(25105),
		146: uint16(26017),
		147: uint16(21351),
		148: uint16(25569),
		149: uint16(27779),
		150: uint16(24043),
		151: uint16(21596),
		152: uint16(38056),
		153: uint16(20044),
		154: uint16(27745),
		155: uint16(35820),
		156: uint16(23627),
		157: uint16(26080),
		158: uint16(33436),
		159: uint16(26791),
		160: uint16(21566),
		161: uint16(21556),
		162: uint16(27595),
		163: uint16(27494),
		164: uint16(20116),
		165: uint16(25410),
		166: uint16(21320),
		167: uint16(33310),
		168: uint16(20237),
		169: uint16(20398),
		170: uint16(22366),
		171: uint16(25098),
		172: uint16(38654),
		173: uint16(26212),
		174: uint16(29289),
		175: uint16(21247),
		176: uint16(21153),
		177: uint16(24735),
		178: uint16(35823),
		179: uint16(26132),
		180: uint16(29081),
		181: uint16(26512),
		182: uint16(35199),
		183: uint16(30802),
		184: uint16(30717),
		185: uint16(26224),
		186: uint16(22075),
		187: uint16(21560),
		188: uint16(38177),
		189: uint16(29306),
	},
	78: {
		0:   uint16(34725),
		1:   uint16(34726),
		2:   uint16(34727),
		3:   uint16(34729),
		4:   uint16(34730),
		5:   uint16(34734),
		6:   uint16(34736),
		7:   uint16(34737),
		8:   uint16(34738),
		9:   uint16(34740),
		10:  uint16(34742),
		11:  uint16(34743),
		12:  uint16(34744),
		13:  uint16(34745),
		14:  uint16(34747),
		15:  uint16(34748),
		16:  uint16(34750),
		17:  uint16(34751),
		18:  uint16(34753),
		19:  uint16(34754),
		20:  uint16(34755),
		21:  uint16(34756),
		22:  uint16(34757),
		23:  uint16(34759),
		24:  uint16(34760),
		25:  uint16(34761),
		26:  uint16(34764),
		27:  uint16(34765),
		28:  uint16(34766),
		29:  uint16(34767),
		30:  uint16(34768),
		31:  uint16(34772),
		32:  uint16(34773),
		33:  uint16(34774),
		34:  uint16(34775),
		35:  uint16(34776),
		36:  uint16(34777),
		37:  uint16(34778),
		38:  uint16(34780),
		39:  uint16(34781),
		40:  uint16(34782),
		41:  uint16(34783),
		42:  uint16(34785),
		43:  uint16(34786),
		44:  uint16(34787),
		45:  uint16(34788),
		46:  uint16(34790),
		47:  uint16(34791),
		48:  uint16(34792),
		49:  uint16(34793),
		50:  uint16(34795),
		51:  uint16(34796),
		52:  uint16(34797),
		53:  uint16(34799),
		54:  uint16(34800),
		55:  uint16(34801),
		56:  uint16(34802),
		57:  uint16(34803),
		58:  uint16(34804),
		59:  uint16(34805),
		60:  uint16(34806),
		61:  uint16(34807),
		62:  uint16(34808),
		63:  uint16(34810),
		64:  uint16(34811),
		65:  uint16(34812),
		66:  uint16(34813),
		67:  uint16(34815),
		68:  uint16(34816),
		69:  uint16(34817),
		70:  uint16(34818),
		71:  uint16(34820),
		72:  uint16(34821),
		73:  uint16(34822),
		74:  uint16(34823),
		75:  uint16(34824),
		76:  uint16(34825),
		77:  uint16(34827),
		78:  uint16(34828),
		79:  uint16(34829),
		80:  uint16(34830),
		81:  uint16(34831),
		82:  uint16(34832),
		83:  uint16(34833),
		84:  uint16(34834),
		85:  uint16(34836),
		86:  uint16(34839),
		87:  uint16(34840),
		88:  uint16(34841),
		89:  uint16(34842),
		90:  uint16(34844),
		91:  uint16(34845),
		92:  uint16(34846),
		93:  uint16(34847),
		94:  uint16(34848),
		95:  uint16(34851),
		96:  uint16(31232),
		97:  uint16(24687),
		98:  uint16(24076),
		99:  uint16(24713),
		100: uint16(33181),
		101: uint16(22805),
		102: uint16(24796),
		103: uint16(29060),
		104: uint16(28911),
		105: uint16(28330),
		106: uint16(27728),
		107: uint16(29312),
		108: uint16(27268),
		109: uint16(34989),
		110: uint16(24109),
		111: uint16(20064),
		112: uint16(23219),
		113: uint16(21916),
		114: uint16(38115),
		115: uint16(27927),
		116: uint16(31995),
		117: uint16(38553),
		118: uint16(25103),
		119: uint16(32454),
		120: uint16(30606),
		121: uint16(34430),
		122: uint16(21283),
		123: uint16(38686),
		124: uint16(36758),
		125: uint16(26247),
		126: uint16(23777),
		127: uint16(20384),
		128: uint16(29421),
		129: uint16(19979),
		130: uint16(21414),
		131: uint16(22799),
		132: uint16(21523),
		133: uint16(25472),
		134: uint16(38184),
		135: uint16(20808),
		136: uint16(20185),
		137: uint16(40092),
		138: uint16(32420),
		139: uint16(21688),
		140: uint16(36132),
		141: uint16(34900),
		142: uint16(33335),
		143: uint16(38386),
		144: uint16(28046),
		145: uint16(24358),
		146: uint16(23244),
		147: uint16(26174),
		148: uint16(38505),
		149: uint16(29616),
		150: uint16(29486),
		151: uint16(21439),
		152: uint16(33146),
		153: uint16(39301),
		154: uint16(32673),
		155: uint16(23466),
		156: uint16(38519),
		157: uint16(38480),
		158: uint16(32447),
		159: uint16(30456),
		160: uint16(21410),
		161: uint16(38262),
		162: uint16(39321),
		163: uint16(31665),
		164: uint16(35140),
		165: uint16(28248),
		166: uint16(20065),
		167: uint16(32724),
		168: uint16(31077),
		169: uint16(35814),
		170: uint16(24819),
		171: uint16(21709),
		172: uint16(20139),
		173: uint16(39033),
		174: uint16(24055),
		175: uint16(27233),
		176: uint16(20687),
		177: uint16(21521),
		178: uint16(35937),
		179: uint16(33831),
		180: uint16(30813),
		181: uint16(38660),
		182: uint16(21066),
		183: uint16(21742),
		184: uint16(22179),
		185: uint16(38144),
		186: uint16(28040),
		187: uint16(23477),
		188: uint16(28102),
		189: uint16(26195),
	},
	79: {
		0:   uint16(34852),
		1:   uint16(34853),
		2:   uint16(34854),
		3:   uint16(34855),
		4:   uint16(34856),
		5:   uint16(34857),
		6:   uint16(34858),
		7:   uint16(34859),
		8:   uint16(34860),
		9:   uint16(34861),
		10:  uint16(34862),
		11:  uint16(34863),
		12:  uint16(34864),
		13:  uint16(34865),
		14:  uint16(34867),
		15:  uint16(34868),
		16:  uint16(34869),
		17:  uint16(34870),
		18:  uint16(34871),
		19:  uint16(34872),
		20:  uint16(34874),
		21:  uint16(34875),
		22:  uint16(34877),
		23:  uint16(34878),
		24:  uint16(34879),
		25:  uint16(34881),
		26:  uint16(34882),
		27:  uint16(34883),
		28:  uint16(34886),
		29:  uint16(34887),
		30:  uint16(34888),
		31:  uint16(34889),
		32:  uint16(34890),
		33:  uint16(34891),
		34:  uint16(34894),
		35:  uint16(34895),
		36:  uint16(34896),
		37:  uint16(34897),
		38:  uint16(34898),
		39:  uint16(34899),
		40:  uint16(34901),
		41:  uint16(34902),
		42:  uint16(34904),
		43:  uint16(34906),
		44:  uint16(34907),
		45:  uint16(34908),
		46:  uint16(34909),
		47:  uint16(34910),
		48:  uint16(34911),
		49:  uint16(34912),
		50:  uint16(34918),
		51:  uint16(34919),
		52:  uint16(34922),
		53:  uint16(34925),
		54:  uint16(34927),
		55:  uint16(34929),
		56:  uint16(34931),
		57:  uint16(34932),
		58:  uint16(34933),
		59:  uint16(34934),
		60:  uint16(34936),
		61:  uint16(34937),
		62:  uint16(34938),
		63:  uint16(34939),
		64:  uint16(34940),
		65:  uint16(34944),
		66:  uint16(34947),
		67:  uint16(34950),
		68:  uint16(34951),
		69:  uint16(34953),
		70:  uint16(34954),
		71:  uint16(34956),
		72:  uint16(34958),
		73:  uint16(34959),
		74:  uint16(34960),
		75:  uint16(34961),
		76:  uint16(34963),
		77:  uint16(34964),
		78:  uint16(34965),
		79:  uint16(34967),
		80:  uint16(34968),
		81:  uint16(34969),
		82:  uint16(34970),
		83:  uint16(34971),
		84:  uint16(34973),
		85:  uint16(34974),
		86:  uint16(34975),
		87:  uint16(34976),
		88:  uint16(34977),
		89:  uint16(34979),
		90:  uint16(34981),
		91:  uint16(34982),
		92:  uint16(34983),
		93:  uint16(34984),
		94:  uint16(34985),
		95:  uint16(34986),
		96:  uint16(23567),
		97:  uint16(23389),
		98:  uint16(26657),
		99:  uint16(32918),
		100: uint16(21880),
		101: uint16(31505),
		102: uint16(25928),
		103: uint16(26964),
		104: uint16(20123),
		105: uint16(27463),
		106: uint16(34638),
		107: uint16(38795),
		108: uint16(21327),
		109: uint16(25375),
		110: uint16(25658),
		111: uint16(37034),
		112: uint16(26012),
		113: uint16(32961),
		114: uint16(35856),
		115: uint16(20889),
		116: uint16(26800),
		117: uint16(21368),
		118: uint16(34809),
		119: uint16(25032),
		120: uint16(27844),
		121: uint16(27899),
		122: uint16(35874),
		123: uint16(23633),
		124: uint16(34218),
		125: uint16(33455),
		126: uint16(38156),
		127: uint16(27427),
		128: uint16(36763),
		129: uint16(26032),
		130: uint16(24571),
		131: uint16(24515),
		132: uint16(20449),
		133: uint16(34885),
		134: uint16(26143),
		135: uint16(33125),
		136: uint16(29481),
		137: uint16(24826),
		138: uint16(20852),
		139: uint16(21009),
		140: uint16(22411),
		141: uint16(24418),
		142: uint16(37026),
		143: uint16(34892),
		144: uint16(37266),
		145: uint16(24184),
		146: uint16(26447),
		147: uint16(24615),
		148: uint16(22995),
		149: uint16(20804),
		150: uint16(20982),
		151: uint16(33016),
		152: uint16(21256),
		153: uint16(27769),
		154: uint16(38596),
		155: uint16(29066),
		156: uint16(20241),
		157: uint16(20462),
		158: uint16(32670),
		159: uint16(26429),
		160: uint16(21957),
		161: uint16(38152),
		162: uint16(31168),
		163: uint16(34966),
		164: uint16(32483),
		165: uint16(22687),
		166: uint16(25100),
		167: uint16(38656),
		168: uint16(34394),
		169: uint16(22040),
		170: uint16(39035),
		171: uint16(24464),
		172: uint16(35768),
		173: uint16(33988),
		174: uint16(37207),
		175: uint16(21465),
		176: uint16(26093),
		177: uint16(24207),
		178: uint16(30044),
		179: uint16(24676),
		180: uint16(32110),
		181: uint16(23167),
		182: uint16(32490),
		183: uint16(32493),
		184: uint16(36713),
		185: uint16(21927),
		186: uint16(23459),
		187: uint16(24748),
		188: uint16(26059),
		189: uint16(29572),
	},
	80: {
		0:   uint16(34988),
		1:   uint16(34990),
		2:   uint16(34991),
		3:   uint16(34992),
		4:   uint16(34994),
		5:   uint16(34995),
		6:   uint16(34996),
		7:   uint16(34997),
		8:   uint16(34998),
		9:   uint16(35000),
		10:  uint16(35001),
		11:  uint16(35002),
		12:  uint16(35003),
		13:  uint16(35005),
		14:  uint16(35006),
		15:  uint16(35007),
		16:  uint16(35008),
		17:  uint16(35011),
		18:  uint16(35012),
		19:  uint16(35015),
		20:  uint16(35016),
		21:  uint16(35018),
		22:  uint16(35019),
		23:  uint16(35020),
		24:  uint16(35021),
		25:  uint16(35023),
		26:  uint16(35024),
		27:  uint16(35025),
		28:  uint16(35027),
		29:  uint16(35030),
		30:  uint16(35031),
		31:  uint16(35034),
		32:  uint16(35035),
		33:  uint16(35036),
		34:  uint16(35037),
		35:  uint16(35038),
		36:  uint16(35040),
		37:  uint16(35041),
		38:  uint16(35046),
		39:  uint16(35047),
		40:  uint16(35049),
		41:  uint16(35050),
		42:  uint16(35051),
		43:  uint16(35052),
		44:  uint16(35053),
		45:  uint16(35054),
		46:  uint16(35055),
		47:  uint16(35058),
		48:  uint16(35061),
		49:  uint16(35062),
		50:  uint16(35063),
		51:  uint16(35066),
		52:  uint16(35067),
		53:  uint16(35069),
		54:  uint16(35071),
		55:  uint16(35072),
		56:  uint16(35073),
		57:  uint16(35075),
		58:  uint16(35076),
		59:  uint16(35077),
		60:  uint16(35078),
		61:  uint16(35079),
		62:  uint16(35080),
		63:  uint16(35081),
		64:  uint16(35083),
		65:  uint16(35084),
		66:  uint16(35085),
		67:  uint16(35086),
		68:  uint16(35087),
		69:  uint16(35089),
		70:  uint16(35092),
		71:  uint16(35093),
		72:  uint16(35094),
		73:  uint16(35095),
		74:  uint16(35096),
		75:  uint16(35100),
		76:  uint16(35101),
		77:  uint16(35102),
		78:  uint16(35103),
		79:  uint16(35104),
		80:  uint16(35106),
		81:  uint16(35107),
		82:  uint16(35108),
		83:  uint16(35110),
		84:  uint16(35111),
		85:  uint16(35112),
		86:  uint16(35113),
		87:  uint16(35116),
		88:  uint16(35117),
		89:  uint16(35118),
		90:  uint16(35119),
		91:  uint16(35121),
		92:  uint16(35122),
		93:  uint16(35123),
		94:  uint16(35125),
		95:  uint16(35127),
		96:  uint16(36873),
		97:  uint16(30307),
		98:  uint16(30505),
		99:  uint16(32474),
		100: uint16(38772),
		101: uint16(34203),
		102: uint16(23398),
		103: uint16(31348),
		104: uint16(38634),
		105: uint16(34880),
		106: uint16(21195),
		107: uint16(29071),
		108: uint16(24490),
		109: uint16(26092),
		110: uint16(35810),
		111: uint16(23547),
		112: uint16(39535),
		113: uint16(24033),
		114: uint16(27529),
		115: uint16(27739),
		116: uint16(35757),
		117: uint16(35759),
		118: uint16(36874),
		119: uint16(36805),
		120: uint16(21387),
		121: uint16(25276),
		122: uint16(40486),
		123: uint16(40493),
		124: uint16(21568),
		125: uint16(20011),
		126: uint16(33469),
		127: uint16(29273),
		128: uint16(34460),
		129: uint16(23830),
		130: uint16(34905),
		131: uint16(28079),
		132: uint16(38597),
		133: uint16(21713),
		134: uint16(20122),
		135: uint16(35766),
		136: uint16(28937),
		137: uint16(21693),
		138: uint16(38409),
		139: uint16(28895),
		140: uint16(28153),
		141: uint16(30416),
		142: uint16(20005),
		143: uint16(30740),
		144: uint16(34578),
		145: uint16(23721),
		146: uint16(24310),
		147: uint16(35328),
		148: uint16(39068),
		149: uint16(38414),
		150: uint16(28814),
		151: uint16(27839),
		152: uint16(22852),
		153: uint16(25513),
		154: uint16(30524),
		155: uint16(34893),
		156: uint16(28436),
		157: uint16(33395),
		158: uint16(22576),
		159: uint16(29141),
		160: uint16(21388),
		161: uint16(30746),
		162: uint16(38593),
		163: uint16(21761),
		164: uint16(24422),
		165: uint16(28976),
		166: uint16(23476),
		167: uint16(35866),
		168: uint16(39564),
		169: uint16(27523),
		170: uint16(22830),
		171: uint16(40495),
		172: uint16(31207),
		173: uint16(26472),
		174: uint16(25196),
		175: uint16(20335),
		176: uint16(30113),
		177: uint16(32650),
		178: uint16(27915),
		179: uint16(38451),
		180: uint16(27687),
		181: uint16(20208),
		182: uint16(30162),
		183: uint16(20859),
		184: uint16(26679),
		185: uint16(28478),
		186: uint16(36992),
		187: uint16(33136),
		188: uint16(22934),
		189: uint16(29814),
	},
	81: {
		0:   uint16(35128),
		1:   uint16(35129),
		2:   uint16(35130),
		3:   uint16(35131),
		4:   uint16(35132),
		5:   uint16(35133),
		6:   uint16(35134),
		7:   uint16(35135),
		8:   uint16(35136),
		9:   uint16(35138),
		10:  uint16(35139),
		11:  uint16(35141),
		12:  uint16(35142),
		13:  uint16(35143),
		14:  uint16(35144),
		15:  uint16(35145),
		16:  uint16(35146),
		17:  uint16(35147),
		18:  uint16(35148),
		19:  uint16(35149),
		20:  uint16(35150),
		21:  uint16(35151),
		22:  uint16(35152),
		23:  uint16(35153),
		24:  uint16(35154),
		25:  uint16(35155),
		26:  uint16(35156),
		27:  uint16(35157),
		28:  uint16(35158),
		29:  uint16(35159),
		30:  uint16(35160),
		31:  uint16(35161),
		32:  uint16(35162),
		33:  uint16(35163),
		34:  uint16(35164),
		35:  uint16(35165),
		36:  uint16(35168),
		37:  uint16(35169),
		38:  uint16(35170),
		39:  uint16(35171),
		40:  uint16(35172),
		41:  uint16(35173),
		42:  uint16(35175),
		43:  uint16(35176),
		44:  uint16(35177),
		45:  uint16(35178),
		46:  uint16(35179),
		47:  uint16(35180),
		48:  uint16(35181),
		49:  uint16(35182),
		50:  uint16(35183),
		51:  uint16(35184),
		52:  uint16(35185),
		53:  uint16(35186),
		54:  uint16(35187),
		55:  uint16(35188),
		56:  uint16(35189),
		57:  uint16(35190),
		58:  uint16(35191),
		59:  uint16(35192),
		60:  uint16(35193),
		61:  uint16(35194),
		62:  uint16(35196),
		63:  uint16(35197),
		64:  uint16(35198),
		65:  uint16(35200),
		66:  uint16(35202),
		67:  uint16(35204),
		68:  uint16(35205),
		69:  uint16(35207),
		70:  uint16(35208),
		71:  uint16(35209),
		72:  uint16(35210),
		73:  uint16(35211),
		74:  uint16(35212),
		75:  uint16(35213),
		76:  uint16(35214),
		77:  uint16(35215),
		78:  uint16(35216),
		79:  uint16(35217),
		80:  uint16(35218),
		81:  uint16(35219),
		82:  uint16(35220),
		83:  uint16(35221),
		84:  uint16(35222),
		85:  uint16(35223),
		86:  uint16(35224),
		87:  uint16(35225),
		88:  uint16(35226),
		89:  uint16(35227),
		90:  uint16(35228),
		91:  uint16(35229),
		92:  uint16(35230),
		93:  uint16(35231),
		94:  uint16(35232),
		95:  uint16(35233),
		96:  uint16(25671),
		97:  uint16(23591),
		98:  uint16(36965),
		99:  uint16(31377),
		100: uint16(35875),
		101: uint16(23002),
		102: uint16(21676),
		103: uint16(33280),
		104: uint16(33647),
		105: uint16(35201),
		106: uint16(32768),
		107: uint16(26928),
		108: uint16(22094),
		109: uint16(32822),
		110: uint16(29239),
		111: uint16(37326),
		112: uint16(20918),
		113: uint16(20063),
		114: uint16(39029),
		115: uint16(25494),
		116: uint16(19994),
		117: uint16(21494),
		118: uint16(26355),
		119: uint16(33099),
		120: uint16(22812),
		121: uint16(28082),
		122: uint16(19968),
		123: uint16(22777),
		124: uint16(21307),
		125: uint16(25558),
		126: uint16(38129),
		127: uint16(20381),
		128: uint16(20234),
		129: uint16(34915),
		130: uint16(39056),
		131: uint16(22839),
		132: uint16(36951),
		133: uint16(31227),
		134: uint16(20202),
		135: uint16(33008),
		136: uint16(30097),
		137: uint16(27778),
		138: uint16(23452),
		139: uint16(23016),
		140: uint16(24413),
		141: uint16(26885),
		142: uint16(34433),
		143: uint16(20506),
		144: uint16(24050),
		145: uint16(20057),
		146: uint16(30691),
		147: uint16(20197),
		148: uint16(33402),
		149: uint16(25233),
		150: uint16(26131),
		151: uint16(37009),
		152: uint16(23673),
		153: uint16(20159),
		154: uint16(24441),
		155: uint16(33222),
		156: uint16(36920),
		157: uint16(32900),
		158: uint16(30123),
		159: uint16(20134),
		160: uint16(35028),
		161: uint16(24847),
		162: uint16(27589),
		163: uint16(24518),
		164: uint16(20041),
		165: uint16(30410),
		166: uint16(28322),
		167: uint16(35811),
		168: uint16(35758),
		169: uint16(35850),
		170: uint16(35793),
		171: uint16(24322),
		172: uint16(32764),
		173: uint16(32716),
		174: uint16(32462),
		175: uint16(33589),
		176: uint16(33643),
		177: uint16(22240),
		178: uint16(27575),
		179: uint16(38899),
		180: uint16(38452),
		181: uint16(23035),
		182: uint16(21535),
		183: uint16(38134),
		184: uint16(28139),
		185: uint16(23493),
		186: uint16(39278),
		187: uint16(23609),
		188: uint16(24341),
		189: uint16(38544),
	},
	82: {
		0:   uint16(35234),
		1:   uint16(35235),
		2:   uint16(35236),
		3:   uint16(35237),
		4:   uint16(35238),
		5:   uint16(35239),
		6:   uint16(35240),
		7:   uint16(35241),
		8:   uint16(35242),
		9:   uint16(35243),
		10:  uint16(35244),
		11:  uint16(35245),
		12:  uint16(35246),
		13:  uint16(35247),
		14:  uint16(35248),
		15:  uint16(35249),
		16:  uint16(35250),
		17:  uint16(35251),
		18:  uint16(35252),
		19:  uint16(35253),
		20:  uint16(35254),
		21:  uint16(35255),
		22:  uint16(35256),
		23:  uint16(35257),
		24:  uint16(35258),
		25:  uint16(35259),
		26:  uint16(35260),
		27:  uint16(35261),
		28:  uint16(35262),
		29:  uint16(35263),
		30:  uint16(35264),
		31:  uint16(35267),
		32:  uint16(35277),
		33:  uint16(35283),
		34:  uint16(35284),
		35:  uint16(35285),
		36:  uint16(35287),
		37:  uint16(35288),
		38:  uint16(35289),
		39:  uint16(35291),
		40:  uint16(35293),
		41:  uint16(35295),
		42:  uint16(35296),
		43:  uint16(35297),
		44:  uint16(35298),
		45:  uint16(35300),
		46:  uint16(35303),
		47:  uint16(35304),
		48:  uint16(35305),
		49:  uint16(35306),
		50:  uint16(35308),
		51:  uint16(35309),
		52:  uint16(35310),
		53:  uint16(35312),
		54:  uint16(35313),
		55:  uint16(35314),
		56:  uint16(35316),
		57:  uint16(35317),
		58:  uint16(35318),
		59:  uint16(35319),
		60:  uint16(35320),
		61:  uint16(35321),
		62:  uint16(35322),
		63:  uint16(35323),
		64:  uint16(35324),
		65:  uint16(35325),
		66:  uint16(35326),
		67:  uint16(35327),
		68:  uint16(35329),
		69:  uint16(35330),
		70:  uint16(35331),
		71:  uint16(35332),
		72:  uint16(35333),
		73:  uint16(35334),
		74:  uint16(35336),
		75:  uint16(35337),
		76:  uint16(35338),
		77:  uint16(35339),
		78:  uint16(35340),
		79:  uint16(35341),
		80:  uint16(35342),
		81:  uint16(35343),
		82:  uint16(35344),
		83:  uint16(35345),
		84:  uint16(35346),
		85:  uint16(35347),
		86:  uint16(35348),
		87:  uint16(35349),
		88:  uint16(35350),
		89:  uint16(35351),
		90:  uint16(35352),
		91:  uint16(35353),
		92:  uint16(35354),
		93:  uint16(35355),
		94:  uint16(35356),
		95:  uint16(35357),
		96:  uint16(21360),
		97:  uint16(33521),
		98:  uint16(27185),
		99:  uint16(23156),
		100: uint16(40560),
		101: uint16(24212),
		102: uint16(32552),
		103: uint16(33721),
		104: uint16(33828),
		105: uint16(33829),
		106: uint16(33639),
		107: uint16(34631),
		108: uint16(36814),
		109: uint16(36194),
		110: uint16(30408),
		111: uint16(24433),
		112: uint16(39062),
		113: uint16(30828),
		114: uint16(26144),
		115: uint16(21727),
		116: uint16(25317),
		117: uint16(20323),
		118: uint16(33219),
		119: uint16(30152),
		120: uint16(24248),
		121: uint16(38605),
		122: uint16(36362),
		123: uint16(34553),
		124: uint16(21647),
		125: uint16(27891),
		126: uint16(28044),
		127: uint16(27704),
		128: uint16(24703),
		129: uint16(21191),
		130: uint16(29992),
		131: uint16(24189),
		132: uint16(20248),
		133: uint16(24736),
		134: uint16(24551),
		135: uint16(23588),
		136: uint16(30001),
		137: uint16(37038),
		138: uint16(38080),
		139: uint16(29369),
		140: uint16(27833),
		141: uint16(28216),
		142: uint16(37193),
		143: uint16(26377),
		144: uint16(21451),
		145: uint16(21491),
		146: uint16(20305),
		147: uint16(37321),
		148: uint16(35825),
		149: uint16(21448),
		150: uint16(24188),
		151: uint16(36802),
		152: uint16(28132),
		153: uint16(20110),
		154: uint16(30402),
		155: uint16(27014),
		156: uint16(34398),
		157: uint16(24858),
		158: uint16(33286),
		159: uint16(20313),
		160: uint16(20446),
		161: uint16(36926),
		162: uint16(40060),
		163: uint16(24841),
		164: uint16(28189),
		165: uint16(28180),
		166: uint16(38533),
		167: uint16(20104),
		168: uint16(23089),
		169: uint16(38632),
		170: uint16(19982),
		171: uint16(23679),
		172: uint16(31161),
		173: uint16(23431),
		174: uint16(35821),
		175: uint16(32701),
		176: uint16(29577),
		177: uint16(22495),
		178: uint16(33419),
		179: uint16(37057),
		180: uint16(21505),
		181: uint16(36935),
		182: uint16(21947),
		183: uint16(23786),
		184: uint16(24481),
		185: uint16(24840),
		186: uint16(27442),
		187: uint16(29425),
		188: uint16(32946),
		189: uint16(35465),
	},
	83: {
		0:   uint16(35358),
		1:   uint16(35359),
		2:   uint16(35360),
		3:   uint16(35361),
		4:   uint16(35362),
		5:   uint16(35363),
		6:   uint16(35364),
		7:   uint16(35365),
		8:   uint16(35366),
		9:   uint16(35367),
		10:  uint16(35368),
		11:  uint16(35369),
		12:  uint16(35370),
		13:  uint16(35371),
		14:  uint16(35372),
		15:  uint16(35373),
		16:  uint16(35374),
		17:  uint16(35375),
		18:  uint16(35376),
		19:  uint16(35377),
		20:  uint16(35378),
		21:  uint16(35379),
		22:  uint16(35380),
		23:  uint16(35381),
		24:  uint16(35382),
		25:  uint16(35383),
		26:  uint16(35384),
		27:  uint16(35385),
		28:  uint16(35386),
		29:  uint16(35387),
		30:  uint16(35388),
		31:  uint16(35389),
		32:  uint16(35391),
		33:  uint16(35392),
		34:  uint16(35393),
		35:  uint16(35394),
		36:  uint16(35395),
		37:  uint16(35396),
		38:  uint16(35397),
		39:  uint16(35398),
		40:  uint16(35399),
		41:  uint16(35401),
		42:  uint16(35402),
		43:  uint16(35403),
		44:  uint16(35404),
		45:  uint16(35405),
		46:  uint16(35406),
		47:  uint16(35407),
		48:  uint16(35408),
		49:  uint16(35409),
		50:  uint16(35410),
		51:  uint16(35411),
		52:  uint16(35412),
		53:  uint16(35413),
		54:  uint16(35414),
		55:  uint16(35415),
		56:  uint16(35416),
		57:  uint16(35417),
		58:  uint16(35418),
		59:  uint16(35419),
		60:  uint16(35420),
		61:  uint16(35421),
		62:  uint16(35422),
		63:  uint16(35423),
		64:  uint16(35424),
		65:  uint16(35425),
		66:  uint16(35426),
		67:  uint16(35427),
		68:  uint16(35428),
		69:  uint16(35429),
		70:  uint16(35430),
		71:  uint16(35431),
		72:  uint16(35432),
		73:  uint16(35433),
		74:  uint16(35434),
		75:  uint16(35435),
		76:  uint16(35436),
		77:  uint16(35437),
		78:  uint16(35438),
		79:  uint16(35439),
		80:  uint16(35440),
		81:  uint16(35441),
		82:  uint16(35442),
		83:  uint16(35443),
		84:  uint16(35444),
		85:  uint16(35445),
		86:  uint16(35446),
		87:  uint16(35447),
		88:  uint16(35448),
		89:  uint16(35450),
		90:  uint16(35451),
		91:  uint16(35452),
		92:  uint16(35453),
		93:  uint16(35454),
		94:  uint16(35455),
		95:  uint16(35456),
		96:  uint16(28020),
		97:  uint16(23507),
		98:  uint16(35029),
		99:  uint16(39044),
		100: uint16(35947),
		101: uint16(39533),
		102: uint16(40499),
		103: uint16(28170),
		104: uint16(20900),
		105: uint16(20803),
		106: uint16(22435),
		107: uint16(34945),
		108: uint16(21407),
		109: uint16(25588),
		110: uint16(36757),
		111: uint16(22253),
		112: uint16(21592),
		113: uint16(22278),
		114: uint16(29503),
		115: uint16(28304),
		116: uint16(32536),
		117: uint16(36828),
		118: uint16(33489),
		119: uint16(24895),
		120: uint16(24616),
		121: uint16(38498),
		122: uint16(26352),
		123: uint16(32422),
		124: uint16(36234),
		125: uint16(36291),
		126: uint16(38053),
		127: uint16(23731),
		128: uint16(31908),
		129: uint16(26376),
		130: uint16(24742),
		131: uint16(38405),
		132: uint16(32792),
		133: uint16(20113),
		134: uint16(37095),
		135: uint16(21248),
		136: uint16(38504),
		137: uint16(20801),
		138: uint16(36816),
		139: uint16(34164),
		140: uint16(37213),
		141: uint16(26197),
		142: uint16(38901),
		143: uint16(23381),
		144: uint16(21277),
		145: uint16(30776),
		146: uint16(26434),
		147: uint16(26685),
		148: uint16(21705),
		149: uint16(28798),
		150: uint16(23472),
		151: uint16(36733),
		152: uint16(20877),
		153: uint16(22312),
		154: uint16(21681),
		155: uint16(25874),
		156: uint16(26242),
		157: uint16(36190),
		158: uint16(36163),
		159: uint16(33039),
		160: uint16(33900),
		161: uint16(36973),
		162: uint16(31967),
		163: uint16(20991),
		164: uint16(34299),
		165: uint16(26531),
		166: uint16(26089),
		167: uint16(28577),
		168: uint16(34468),
		169: uint16(36481),
		170: uint16(22122),
		171: uint16(36896),
		172: uint16(30338),
		173: uint16(28790),
		174: uint16(29157),
		175: uint16(36131),
		176: uint16(25321),
		177: uint16(21017),
		178: uint16(27901),
		179: uint16(36156),
		180: uint16(24590),
		181: uint16(22686),
		182: uint16(24974),
		183: uint16(26366),
		184: uint16(36192),
		185: uint16(25166),
		186: uint16(21939),
		187: uint16(28195),
		188: uint16(26413),
		189: uint16(36711),
	},
	84: {
		0:   uint16(35457),
		1:   uint16(35458),
		2:   uint16(35459),
		3:   uint16(35460),
		4:   uint16(35461),
		5:   uint16(35462),
		6:   uint16(35463),
		7:   uint16(35464),
		8:   uint16(35467),
		9:   uint16(35468),
		10:  uint16(35469),
		11:  uint16(35470),
		12:  uint16(35471),
		13:  uint16(35472),
		14:  uint16(35473),
		15:  uint16(35474),
		16:  uint16(35476),
		17:  uint16(35477),
		18:  uint16(35478),
		19:  uint16(35479),
		20:  uint16(35480),
		21:  uint16(35481),
		22:  uint16(35482),
		23:  uint16(35483),
		24:  uint16(35484),
		25:  uint16(35485),
		26:  uint16(35486),
		27:  uint16(35487),
		28:  uint16(35488),
		29:  uint16(35489),
		30:  uint16(35490),
		31:  uint16(35491),
		32:  uint16(35492),
		33:  uint16(35493),
		34:  uint16(35494),
		35:  uint16(35495),
		36:  uint16(35496),
		37:  uint16(35497),
		38:  uint16(35498),
		39:  uint16(35499),
		40:  uint16(35500),
		41:  uint16(35501),
		42:  uint16(35502),
		43:  uint16(35503),
		44:  uint16(35504),
		45:  uint16(35505),
		46:  uint16(35506),
		47:  uint16(35507),
		48:  uint16(35508),
		49:  uint16(35509),
		50:  uint16(35510),
		51:  uint16(35511),
		52:  uint16(35512),
		53:  uint16(35513),
		54:  uint16(35514),
		55:  uint16(35515),
		56:  uint16(35516),
		57:  uint16(35517),
		58:  uint16(35518),
		59:  uint16(35519),
		60:  uint16(35520),
		61:  uint16(35521),
		62:  uint16(35522),
		63:  uint16(35523),
		64:  uint16(35524),
		65:  uint16(35525),
		66:  uint16(35526),
		67:  uint16(35527),
		68:  uint16(35528),
		69:  uint16(35529),
		70:  uint16(35530),
		71:  uint16(35531),
		72:  uint16(35532),
		73:  uint16(35533),
		74:  uint16(35534),
		75:  uint16(35535),
		76:  uint16(35536),
		77:  uint16(35537),
		78:  uint16(35538),
		79:  uint16(35539),
		80:  uint16(35540),
		81:  uint16(35541),
		82:  uint16(35542),
		83:  uint16(35543),
		84:  uint16(35544),
		85:  uint16(35545),
		86:  uint16(35546),
		87:  uint16(35547),
		88:  uint16(35548),
		89:  uint16(35549),
		90:  uint16(35550),
		91:  uint16(35551),
		92:  uint16(35552),
		93:  uint16(35553),
		94:  uint16(35554),
		95:  uint16(35555),
		96:  uint16(38113),
		97:  uint16(38392),
		98:  uint16(30504),
		99:  uint16(26629),
		100: uint16(27048),
		101: uint16(21643),
		102: uint16(20045),
		103: uint16(28856),
		104: uint16(35784),
		105: uint16(25688),
		106: uint16(25995),
		107: uint16(23429),
		108: uint16(31364),
		109: uint16(20538),
		110: uint16(23528),
		111: uint16(30651),
		112: uint16(27617),
		113: uint16(35449),
		114: uint16(31896),
		115: uint16(27838),
		116: uint16(30415),
		117: uint16(26025),
		118: uint16(36759),
		119: uint16(23853),
		120: uint16(23637),
		121: uint16(34360),
		122: uint16(26632),
		123: uint16(21344),
		124: uint16(25112),
		125: uint16(31449),
		126: uint16(28251),
		127: uint16(32509),
		128: uint16(27167),
		129: uint16(31456),
		130: uint16(24432),
		131: uint16(28467),
		132: uint16(24352),
		133: uint16(25484),
		134: uint16(28072),
		135: uint16(26454),
		136: uint16(19976),
		137: uint16(24080),
		138: uint16(36134),
		139: uint16(20183),
		140: uint16(32960),
		141: uint16(30260),
		142: uint16(38556),
		143: uint16(25307),
		144: uint16(26157),
		145: uint16(25214),
		146: uint16(27836),
		147: uint16(36213),
		148: uint16(29031),
		149: uint16(32617),
		150: uint16(20806),
		151: uint16(32903),
		152: uint16(21484),
		153: uint16(36974),
		154: uint16(25240),
		155: uint16(21746),
		156: uint16(34544),
		157: uint16(36761),
		158: uint16(32773),
		159: uint16(38167),
		160: uint16(34071),
		161: uint16(36825),
		162: uint16(27993),
		163: uint16(29645),
		164: uint16(26015),
		165: uint16(30495),
		166: uint16(29956),
		167: uint16(30759),
		168: uint16(33275),
		169: uint16(36126),
		170: uint16(38024),
		171: uint16(20390),
		172: uint16(26517),
		173: uint16(30137),
		174: uint16(35786),
		175: uint16(38663),
		176: uint16(25391),
		177: uint16(38215),
		178: uint16(38453),
		179: uint16(33976),
		180: uint16(25379),
		181: uint16(30529),
		182: uint16(24449),
		183: uint16(29424),
		184: uint16(20105),
		185: uint16(24596),
		186: uint16(25972),
		187: uint16(25327),
		188: uint16(27491),
		189: uint16(25919),
	},
	85: {
		0:   uint16(35556),
		1:   uint16(35557),
		2:   uint16(35558),
		3:   uint16(35559),
		4:   uint16(35560),
		5:   uint16(35561),
		6:   uint16(35562),
		7:   uint16(35563),
		8:   uint16(35564),
		9:   uint16(35565),
		10:  uint16(35566),
		11:  uint16(35567),
		12:  uint16(35568),
		13:  uint16(35569),
		14:  uint16(35570),
		15:  uint16(35571),
		16:  uint16(35572),
		17:  uint16(35573),
		18:  uint16(35574),
		19:  uint16(35575),
		20:  uint16(35576),
		21:  uint16(35577),
		22:  uint16(35578),
		23:  uint16(35579),
		24:  uint16(35580),
		25:  uint16(35581),
		26:  uint16(35582),
		27:  uint16(35583),
		28:  uint16(35584),
		29:  uint16(35585),
		30:  uint16(35586),
		31:  uint16(35587),
		32:  uint16(35588),
		33:  uint16(35589),
		34:  uint16(35590),
		35:  uint16(35592),
		36:  uint16(35593),
		37:  uint16(35594),
		38:  uint16(35595),
		39:  uint16(35596),
		40:  uint16(35597),
		41:  uint16(35598),
		42:  uint16(35599),
		43:  uint16(35600),
		44:  uint16(35601),
		45:  uint16(35602),
		46:  uint16(35603),
		47:  uint16(35604),
		48:  uint16(35605),
		49:  uint16(35606),
		50:  uint16(35607),
		51:  uint16(35608),
		52:  uint16(35609),
		53:  uint16(35610),
		54:  uint16(35611),
		55:  uint16(35612),
		56:  uint16(35613),
		57:  uint16(35614),
		58:  uint16(35615),
		59:  uint16(35616),
		60:  uint16(35617),
		61:  uint16(35618),
		62:  uint16(35619),
		63:  uint16(35620),
		64:  uint16(35621),
		65:  uint16(35623),
		66:  uint16(35624),
		67:  uint16(35625),
		68:  uint16(35626),
		69:  uint16(35627),
		70:  uint16(35628),
		71:  uint16(35629),
		72:  uint16(35630),
		73:  uint16(35631),
		74:  uint16(35632),
		75:  uint16(35633),
		76:  uint16(35634),
		77:  uint16(35635),
		78:  uint16(35636),
		79:  uint16(35637),
		80:  uint16(35638),
		81:  uint16(35639),
		82:  uint16(35640),
		83:  uint16(35641),
		84:  uint16(35642),
		85:  uint16(35643),
		86:  uint16(35644),
		87:  uint16(35645),
		88:  uint16(35646),
		89:  uint16(35647),
		90:  uint16(35648),
		91:  uint16(35649),
		92:  uint16(35650),
		93:  uint16(35651),
		94:  uint16(35652),
		95:  uint16(35653),
		96:  uint16(24103),
		97:  uint16(30151),
		98:  uint16(37073),
		99:  uint16(35777),
		100: uint16(33437),
		101: uint16(26525),
		102: uint16(25903),
		103: uint16(21553),
		104: uint16(34584),
		105: uint16(30693),
		106: uint16(32930),
		107: uint16(33026),
		108: uint16(27713),
		109: uint16(20043),
		110: uint16(32455),
		111: uint16(32844),
		112: uint16(30452),
		113: uint16(26893),
		114: uint16(27542),
		115: uint16(25191),
		116: uint16(20540),
		117: uint16(20356),
		118: uint16(22336),
		119: uint16(25351),
		120: uint16(27490),
		121: uint16(36286),
		122: uint16(21482),
		123: uint16(26088),
		124: uint16(32440),
		125: uint16(24535),
		126: uint16(25370),
		127: uint16(25527),
		128: uint16(33267),
		129: uint16(33268),
		130: uint16(32622),
		131: uint16(24092),
		132: uint16(23769),
		133: uint16(21046),
		134: uint16(26234),
		135: uint16(31209),
		136: uint16(31258),
		137: uint16(36136),
		138: uint16(28825),
		139: uint16(30164),
		140: uint16(28382),
		141: uint16(27835),
		142: uint16(31378),
		143: uint16(20013),
		144: uint16(30405),
		145: uint16(24544),
		146: uint16(38047),
		147: uint16(34935),
		148: uint16(32456),
		149: uint16(31181),
		150: uint16(32959),
		151: uint16(37325),
		152: uint16(20210),
		153: uint16(20247),
		154: uint16(33311),
		155: uint16(21608),
		156: uint16(24030),
		157: uint16(27954),
		158: uint16(35788),
		159: uint16(31909),
		160: uint16(36724),
		161: uint16(32920),
		162: uint16(24090),
		163: uint16(21650),
		164: uint16(30385),
		165: uint16(23449),
		166: uint16(26172),
		167: uint16(39588),
		168: uint16(29664),
		169: uint16(26666),
		170: uint16(34523),
		171: uint16(26417),
		172: uint16(29482),
		173: uint16(35832),
		174: uint16(35803),
		175: uint16(36880),
		176: uint16(31481),
		177: uint16(28891),
		178: uint16(29038),
		179: uint16(25284),
		180: uint16(30633),
		181: uint16(22065),
		182: uint16(20027),
		183: uint16(33879),
		184: uint16(26609),
		185: uint16(21161),
		186: uint16(34496),
		187: uint16(36142),
		188: uint16(38136),
		189: uint16(31569),
	},
	86: {
		0:   uint16(35654),
		1:   uint16(35655),
		2:   uint16(35656),
		3:   uint16(35657),
		4:   uint16(35658),
		5:   uint16(35659),
		6:   uint16(35660),
		7:   uint16(35661),
		8:   uint16(35662),
		9:   uint16(35663),
		10:  uint16(35664),
		11:  uint16(35665),
		12:  uint16(35666),
		13:  uint16(35667),
		14:  uint16(35668),
		15:  uint16(35669),
		16:  uint16(35670),
		17:  uint16(35671),
		18:  uint16(35672),
		19:  uint16(35673),
		20:  uint16(35674),
		21:  uint16(35675),
		22:  uint16(35676),
		23:  uint16(35677),
		24:  uint16(35678),
		25:  uint16(35679),
		26:  uint16(35680),
		27:  uint16(35681),
		28:  uint16(35682),
		29:  uint16(35683),
		30:  uint16(35684),
		31:  uint16(35685),
		32:  uint16(35687),
		33:  uint16(35688),
		34:  uint16(35689),
		35:  uint16(35690),
		36:  uint16(35691),
		37:  uint16(35693),
		38:  uint16(35694),
		39:  uint16(35695),
		40:  uint16(35696),
		41:  uint16(35697),
		42:  uint16(35698),
		43:  uint16(35699),
		44:  uint16(35700),
		45:  uint16(35701),
		46:  uint16(35702),
		47:  uint16(35703),
		48:  uint16(35704),
		49:  uint16(35705),
		50:  uint16(35706),
		51:  uint16(35707),
		52:  uint16(35708),
		53:  uint16(35709),
		54:  uint16(35710),
		55:  uint16(35711),
		56:  uint16(35712),
		57:  uint16(35713),
		58:  uint16(35714),
		59:  uint16(35715),
		60:  uint16(35716),
		61:  uint16(35717),
		62:  uint16(35718),
		63:  uint16(35719),
		64:  uint16(35720),
		65:  uint16(35721),
		66:  uint16(35722),
		67:  uint16(35723),
		68:  uint16(35724),
		69:  uint16(35725),
		70:  uint16(35726),
		71:  uint16(35727),
		72:  uint16(35728),
		73:  uint16(35729),
		74:  uint16(35730),
		75:  uint16(35731),
		76:  uint16(35732),
		77:  uint16(35733),
		78:  uint16(35734),
		79:  uint16(35735),
		80:  uint16(35736),
		81:  uint16(35737),
		82:  uint16(35738),
		83:  uint16(35739),
		84:  uint16(35740),
		85:  uint16(35741),
		86:  uint16(35742),
		87:  uint16(35743),
		88:  uint16(35756),
		89:  uint16(35761),
		90:  uint16(35771),
		91:  uint16(35783),
		92:  uint16(35792),
		93:  uint16(35818),
		94:  uint16(35849),
		95:  uint16(35870),
		96:  uint16(20303),
		97:  uint16(27880),
		98:  uint16(31069),
		99:  uint16(39547),
		100: uint16(25235),
		101: uint16(29226),
		102: uint16(25341),
		103: uint16(19987),
		104: uint16(30742),
		105: uint16(36716),
		106: uint16(25776),
		107: uint16(36186),
		108: uint16(31686),
		109: uint16(26729),
		110: uint16(24196),
		111: uint16(35013),
		112: uint16(22918),
		113: uint16(25758),
		114: uint16(22766),
		115: uint16(29366),
		116: uint16(26894),
		117: uint16(38181),
		118: uint16(36861),
		119: uint16(36184),
		120: uint16(22368),
		121: uint16(32512),
		122: uint16(35846),
		123: uint16(20934),
		124: uint16(25417),
		125: uint16(25305),
		126: uint16(21331),
		127: uint16(26700),
		128: uint16(29730),
		129: uint16(33537),
		130: uint16(37196),
		131: uint16(21828),
		132: uint16(30528),
		133: uint16(28796),
		134: uint16(27978),
		135: uint16(20857),
		136: uint16(21672),
		137: uint16(36164),
		138: uint16(23039),
		139: uint16(28363),
		140: uint16(28100),
		141: uint16(23388),
		142: uint16(32043),
		143: uint16(20180),
		144: uint16(31869),
		145: uint16(28371),
		146: uint16(23376),
		147: uint16(33258),
		148: uint16(28173),
		149: uint16(23383),
		150: uint16(39683),
		151: uint16(26837),
		152: uint16(36394),
		153: uint16(23447),
		154: uint16(32508),
		155: uint16(24635),
		156: uint16(32437),
		157: uint16(37049),
		158: uint16(36208),
		159: uint16(22863),
		160: uint16(25549),
		161: uint16(31199),
		162: uint16(36275),
		163: uint16(21330),
		164: uint16(26063),
		165: uint16(31062),
		166: uint16(35781),
		167: uint16(38459),
		168: uint16(32452),
		169: uint16(38075),
		170: uint16(32386),
		171: uint16(22068),
		172: uint16(37257),
		173: uint16(26368),
		174: uint16(32618),
		175: uint16(23562),
		176: uint16(36981),
		177: uint16(26152),
		178: uint16(24038),
		179: uint16(20304),
		180: uint16(26590),
		181: uint16(20570),
		182: uint16(20316),
		183: uint16(22352),
		184: uint16(24231),
		185: uint16(59408),
		186: uint16(59409),
		187: uint16(59410),
		188: uint16(59411),
		189: uint16(59412),
	},
	87: {
		0:   uint16(35896),
		1:   uint16(35897),
		2:   uint16(35898),
		3:   uint16(35899),
		4:   uint16(35900),
		5:   uint16(35901),
		6:   uint16(35902),
		7:   uint16(35903),
		8:   uint16(35904),
		9:   uint16(35906),
		10:  uint16(35907),
		11:  uint16(35908),
		12:  uint16(35909),
		13:  uint16(35912),
		14:  uint16(35914),
		15:  uint16(35915),
		16:  uint16(35917),
		17:  uint16(35918),
		18:  uint16(35919),
		19:  uint16(35920),
		20:  uint16(35921),
		21:  uint16(35922),
		22:  uint16(35923),
		23:  uint16(35924),
		24:  uint16(35926),
		25:  uint16(35927),
		26:  uint16(35928),
		27:  uint16(35929),
		28:  uint16(35931),
		29:  uint16(35932),
		30:  uint16(35933),
		31:  uint16(35934),
		32:  uint16(35935),
		33:  uint16(35936),
		34:  uint16(35939),
		35:  uint16(35940),
		36:  uint16(35941),
		37:  uint16(35942),
		38:  uint16(35943),
		39:  uint16(35944),
		40:  uint16(35945),
		41:  uint16(35948),
		42:  uint16(35949),
		43:  uint16(35950),
		44:  uint16(35951),
		45:  uint16(35952),
		46:  uint16(35953),
		47:  uint16(35954),
		48:  uint16(35956),
		49:  uint16(35957),
		50:  uint16(35958),
		51:  uint16(35959),
		52:  uint16(35963),
		53:  uint16(35964),
		54:  uint16(35965),
		55:  uint16(35966),
		56:  uint16(35967),
		57:  uint16(35968),
		58:  uint16(35969),
		59:  uint16(35971),
		60:  uint16(35972),
		61:  uint16(35974),
		62:  uint16(35975),
		63:  uint16(35976),
		64:  uint16(35979),
		65:  uint16(35981),
		66:  uint16(35982),
		67:  uint16(35983),
		68:  uint16(35984),
		69:  uint16(35985),
		70:  uint16(35986),
		71:  uint16(35987),
		72:  uint16(35989),
		73:  uint16(35990),
		74:  uint16(35991),
		75:  uint16(35993),
		76:  uint16(35994),
		77:  uint16(35995),
		78:  uint16(35996),
		79:  uint16(35997),
		80:  uint16(35998),
		81:  uint16(35999),
		82:  uint16(36000),
		83:  uint16(36001),
		84:  uint16(36002),
		85:  uint16(36003),
		86:  uint16(36004),
		87:  uint16(36005),
		88:  uint16(36006),
		89:  uint16(36007),
		90:  uint16(36008),
		91:  uint16(36009),
		92:  uint16(36010),
		93:  uint16(36011),
		94:  uint16(36012),
		95:  uint16(36013),
		96:  uint16(20109),
		97:  uint16(19980),
		98:  uint16(20800),
		99:  uint16(19984),
		100: uint16(24319),
		101: uint16(21317),
		102: uint16(19989),
		103: uint16(20120),
		104: uint16(19998),
		105: uint16(39730),
		106: uint16(23404),
		107: uint16(22121),
		108: uint16(20008),
		109: uint16(31162),
		110: uint16(20031),
		111: uint16(21269),
		112: uint16(20039),
		113: uint16(22829),
		114: uint16(29243),
		115: uint16(21358),
		116: uint16(27664),
		117: uint16(22239),
		118: uint16(32996),
		119: uint16(39319),
		120: uint16(27603),
		121: uint16(30590),
		122: uint16(40727),
		123: uint16(20022),
		124: uint16(20127),
		125: uint16(40720),
		126: uint16(20060),
		127: uint16(20073),
		128: uint16(20115),
		129: uint16(33416),
		130: uint16(23387),
		131: uint16(21868),
		132: uint16(22031),
		133: uint16(20164),
		134: uint16(21389),
		135: uint16(21405),
		136: uint16(21411),
		137: uint16(21413),
		138: uint16(21422),
		139: uint16(38757),
		140: uint16(36189),
		141: uint16(21274),
		142: uint16(21493),
		143: uint16(21286),
		144: uint16(21294),
		145: uint16(21310),
		146: uint16(36188),
		147: uint16(21350),
		148: uint16(21347),
		149: uint16(20994),
		150: uint16(21000),
		151: uint16(21006),
		152: uint16(21037),
		153: uint16(21043),
		154: uint16(21055),
		155: uint16(21056),
		156: uint16(21068),
		157: uint16(21086),
		158: uint16(21089),
		159: uint16(21084),
		160: uint16(33967),
		161: uint16(21117),
		162: uint16(21122),
		163: uint16(21121),
		164: uint16(21136),
		165: uint16(21139),
		166: uint16(20866),
		167: uint16(32596),
		168: uint16(20155),
		169: uint16(20163),
		170: uint16(20169),
		171: uint16(20162),
		172: uint16(20200),
		173: uint16(20193),
		174: uint16(20203),
		175: uint16(20190),
		176: uint16(20251),
		177: uint16(20211),
		178: uint16(20258),
		179: uint16(20324),
		180: uint16(20213),
		181: uint16(20261),
		182: uint16(20263),
		183: uint16(20233),
		184: uint16(20267),
		185: uint16(20318),
		186: uint16(20327),
		187: uint16(25912),
		188: uint16(20314),
		189: uint16(20317),
	},
	88: {
		0:   uint16(36014),
		1:   uint16(36015),
		2:   uint16(36016),
		3:   uint16(36017),
		4:   uint16(36018),
		5:   uint16(36019),
		6:   uint16(36020),
		7:   uint16(36021),
		8:   uint16(36022),
		9:   uint16(36023),
		10:  uint16(36024),
		11:  uint16(36025),
		12:  uint16(36026),
		13:  uint16(36027),
		14:  uint16(36028),
		15:  uint16(36029),
		16:  uint16(36030),
		17:  uint16(36031),
		18:  uint16(36032),
		19:  uint16(36033),
		20:  uint16(36034),
		21:  uint16(36035),
		22:  uint16(36036),
		23:  uint16(36037),
		24:  uint16(36038),
		25:  uint16(36039),
		26:  uint16(36040),
		27:  uint16(36041),
		28:  uint16(36042),
		29:  uint16(36043),
		30:  uint16(36044),
		31:  uint16(36045),
		32:  uint16(36046),
		33:  uint16(36047),
		34:  uint16(36048),
		35:  uint16(36049),
		36:  uint16(36050),
		37:  uint16(36051),
		38:  uint16(36052),
		39:  uint16(36053),
		40:  uint16(36054),
		41:  uint16(36055),
		42:  uint16(36056),
		43:  uint16(36057),
		44:  uint16(36058),
		45:  uint16(36059),
		46:  uint16(36060),
		47:  uint16(36061),
		48:  uint16(36062),
		49:  uint16(36063),
		50:  uint16(36064),
		51:  uint16(36065),
		52:  uint16(36066),
		53:  uint16(36067),
		54:  uint16(36068),
		55:  uint16(36069),
		56:  uint16(36070),
		57:  uint16(36071),
		58:  uint16(36072),
		59:  uint16(36073),
		60:  uint16(36074),
		61:  uint16(36075),
		62:  uint16(36076),
		63:  uint16(36077),
		64:  uint16(36078),
		65:  uint16(36079),
		66:  uint16(36080),
		67:  uint16(36081),
		68:  uint16(36082),
		69:  uint16(36083),
		70:  uint16(36084),
		71:  uint16(36085),
		72:  uint16(36086),
		73:  uint16(36087),
		74:  uint16(36088),
		75:  uint16(36089),
		76:  uint16(36090),
		77:  uint16(36091),
		78:  uint16(36092),
		79:  uint16(36093),
		80:  uint16(36094),
		81:  uint16(36095),
		82:  uint16(36096),
		83:  uint16(36097),
		84:  uint16(36098),
		85:  uint16(36099),
		86:  uint16(36100),
		87:  uint16(36101),
		88:  uint16(36102),
		89:  uint16(36103),
		90:  uint16(36104),
		91:  uint16(36105),
		92:  uint16(36106),
		93:  uint16(36107),
		94:  uint16(36108),
		95:  uint16(36109),
		96:  uint16(20319),
		97:  uint16(20311),
		98:  uint16(20274),
		99:  uint16(20285),
		100: uint16(20342),
		101: uint16(20340),
		102: uint16(20369),
		103: uint16(20361),
		104: uint16(20355),
		105: uint16(20367),
		106: uint16(20350),
		107: uint16(20347),
		108: uint16(20394),
		109: uint16(20348),
		110: uint16(20396),
		111: uint16(20372),
		112: uint16(20454),
		113: uint16(20456),
		114: uint16(20458),
		115: uint16(20421),
		116: uint16(20442),
		117: uint16(20451),
		118: uint16(20444),
		119: uint16(20433),
		120: uint16(20447),
		121: uint16(20472),
		122: uint16(20521),
		123: uint16(20556),
		124: uint16(20467),
		125: uint16(20524),
		126: uint16(20495),
		127: uint16(20526),
		128: uint16(20525),
		129: uint16(20478),
		130: uint16(20508),
		131: uint16(20492),
		132: uint16(20517),
		133: uint16(20520),
		134: uint16(20606),
		135: uint16(20547),
		136: uint16(20565),
		137: uint16(20552),
		138: uint16(20558),
		139: uint16(20588),
		140: uint16(20603),
		141: uint16(20645),
		142: uint16(20647),
		143: uint16(20649),
		144: uint16(20666),
		145: uint16(20694),
		146: uint16(20742),
		147: uint16(20717),
		148: uint16(20716),
		149: uint16(20710),
		150: uint16(20718),
		151: uint16(20743),
		152: uint16(20747),
		153: uint16(20189),
		154: uint16(27709),
		155: uint16(20312),
		156: uint16(20325),
		157: uint16(20430),
		158: uint16(40864),
		159: uint16(27718),
		160: uint16(31860),
		161: uint16(20846),
		162: uint16(24061),
		163: uint16(40649),
		164: uint16(39320),
		165: uint16(20865),
		166: uint16(22804),
		167: uint16(21241),
		168: uint16(21261),
		169: uint16(35335),
		170: uint16(21264),
		171: uint16(20971),
		172: uint16(22809),
		173: uint16(20821),
		174: uint16(20128),
		175: uint16(20822),
		176: uint16(20147),
		177: uint16(34926),
		178: uint16(34980),
		179: uint16(20149),
		180: uint16(33044),
		181: uint16(35026),
		182: uint16(31104),
		183: uint16(23348),
		184: uint16(34819),
		185: uint16(32696),
		186: uint16(20907),
		187: uint16(20913),
		188: uint16(20925),
		189: uint16(20924),
	},
	89: {
		0:   uint16(36110),
		1:   uint16(36111),
		2:   uint16(36112),
		3:   uint16(36113),
		4:   uint16(36114),
		5:   uint16(36115),
		6:   uint16(36116),
		7:   uint16(36117),
		8:   uint16(36118),
		9:   uint16(36119),
		10:  uint16(36120),
		11:  uint16(36121),
		12:  uint16(36122),
		13:  uint16(36123),
		14:  uint16(36124),
		15:  uint16(36128),
		16:  uint16(36177),
		17:  uint16(36178),
		18:  uint16(36183),
		19:  uint16(36191),
		20:  uint16(36197),
		21:  uint16(36200),
		22:  uint16(36201),
		23:  uint16(36202),
		24:  uint16(36204),
		25:  uint16(36206),
		26:  uint16(36207),
		27:  uint16(36209),
		28:  uint16(36210),
		29:  uint16(36216),
		30:  uint16(36217),
		31:  uint16(36218),
		32:  uint16(36219),
		33:  uint16(36220),
		34:  uint16(36221),
		35:  uint16(36222),
		36:  uint16(36223),
		37:  uint16(36224),
		38:  uint16(36226),
		39:  uint16(36227),
		40:  uint16(36230),
		41:  uint16(36231),
		42:  uint16(36232),
		43:  uint16(36233),
		44:  uint16(36236),
		45:  uint16(36237),
		46:  uint16(36238),
		47:  uint16(36239),
		48:  uint16(36240),
		49:  uint16(36242),
		50:  uint16(36243),
		51:  uint16(36245),
		52:  uint16(36246),
		53:  uint16(36247),
		54:  uint16(36248),
		55:  uint16(36249),
		56:  uint16(36250),
		57:  uint16(36251),
		58:  uint16(36252),
		59:  uint16(36253),
		60:  uint16(36254),
		61:  uint16(36256),
		62:  uint16(36257),
		63:  uint16(36258),
		64:  uint16(36260),
		65:  uint16(36261),
		66:  uint16(36262),
		67:  uint16(36263),
		68:  uint16(36264),
		69:  uint16(36265),
		70:  uint16(36266),
		71:  uint16(36267),
		72:  uint16(36268),
		73:  uint16(36269),
		74:  uint16(36270),
		75:  uint16(36271),
		76:  uint16(36272),
		77:  uint16(36274),
		78:  uint16(36278),
		79:  uint16(36279),
		80:  uint16(36281),
		81:  uint16(36283),
		82:  uint16(36285),
		83:  uint16(36288),
		84:  uint16(36289),
		85:  uint16(36290),
		86:  uint16(36293),
		87:  uint16(36295),
		88:  uint16(36296),
		89:  uint16(36297),
		90:  uint16(36298),
		91:  uint16(36301),
		92:  uint16(36304),
		93:  uint16(36306),
		94:  uint16(36307),
		95:  uint16(36308),
		96:  uint16(20935),
		97:  uint16(20886),
		98:  uint16(20898),
		99:  uint16(20901),
		100: uint16(35744),
		101: uint16(35750),
		102: uint16(35751),
		103: uint16(35754),
		104: uint16(35764),
		105: uint16(35765),
		106: uint16(35767),
		107: uint16(35778),
		108: uint16(35779),
		109: uint16(35787),
		110: uint16(35791),
		111: uint16(35790),
		112: uint16(35794),
		113: uint16(35795),
		114: uint16(35796),
		115: uint16(35798),
		116: uint16(35800),
		117: uint16(35801),
		118: uint16(35804),
		119: uint16(35807),
		120: uint16(35808),
		121: uint16(35812),
		122: uint16(35816),
		123: uint16(35817),
		124: uint16(35822),
		125: uint16(35824),
		126: uint16(35827),
		127: uint16(35830),
		128: uint16(35833),
		129: uint16(35836),
		130: uint16(35839),
		131: uint16(35840),
		132: uint16(35842),
		133: uint16(35844),
		134: uint16(35847),
		135: uint16(35852),
		136: uint16(35855),
		137: uint16(35857),
		138: uint16(35858),
		139: uint16(35860),
		140: uint16(35861),
		141: uint16(35862),
		142: uint16(35865),
		143: uint16(35867),
		144: uint16(35864),
		145: uint16(35869),
		146: uint16(35871),
		147: uint16(35872),
		148: uint16(35873),
		149: uint16(35877),
		150: uint16(35879),
		151: uint16(35882),
		152: uint16(35883),
		153: uint16(35886),
		154: uint16(35887),
		155: uint16(35890),
		156: uint16(35891),
		157: uint16(35893),
		158: uint16(35894),
		159: uint16(21353),
		160: uint16(21370),
		161: uint16(38429),
		162: uint16(38434),
		163: uint16(38433),
		164: uint16(38449),
		165: uint16(38442),
		166: uint16(38461),
		167: uint16(38460),
		168: uint16(38466),
		169: uint16(38473),
		170: uint16(38484),
		171: uint16(38495),
		172: uint16(38503),
		173: uint16(38508),
		174: uint16(38514),
		175: uint16(38516),
		176: uint16(38536),
		177: uint16(38541),
		178: uint16(38551),
		179: uint16(38576),
		180: uint16(37015),
		181: uint16(37019),
		182: uint16(37021),
		183: uint16(37017),
		184: uint16(37036),
		185: uint16(37025),
		186: uint16(37044),
		187: uint16(37043),
		188: uint16(37046),
		189: uint16(37050),
	},
	90: {
		0:   uint16(36309),
		1:   uint16(36312),
		2:   uint16(36313),
		3:   uint16(36316),
		4:   uint16(36320),
		5:   uint16(36321),
		6:   uint16(36322),
		7:   uint16(36325),
		8:   uint16(36326),
		9:   uint16(36327),
		10:  uint16(36329),
		11:  uint16(36333),
		12:  uint16(36334),
		13:  uint16(36336),
		14:  uint16(36337),
		15:  uint16(36338),
		16:  uint16(36340),
		17:  uint16(36342),
		18:  uint16(36348),
		19:  uint16(36350),
		20:  uint16(36351),
		21:  uint16(36352),
		22:  uint16(36353),
		23:  uint16(36354),
		24:  uint16(36355),
		25:  uint16(36356),
		26:  uint16(36358),
		27:  uint16(36359),
		28:  uint16(36360),
		29:  uint16(36363),
		30:  uint16(36365),
		31:  uint16(36366),
		32:  uint16(36368),
		33:  uint16(36369),
		34:  uint16(36370),
		35:  uint16(36371),
		36:  uint16(36373),
		37:  uint16(36374),
		38:  uint16(36375),
		39:  uint16(36376),
		40:  uint16(36377),
		41:  uint16(36378),
		42:  uint16(36379),
		43:  uint16(36380),
		44:  uint16(36384),
		45:  uint16(36385),
		46:  uint16(36388),
		47:  uint16(36389),
		48:  uint16(36390),
		49:  uint16(36391),
		50:  uint16(36392),
		51:  uint16(36395),
		52:  uint16(36397),
		53:  uint16(36400),
		54:  uint16(36402),
		55:  uint16(36403),
		56:  uint16(36404),
		57:  uint16(36406),
		58:  uint16(36407),
		59:  uint16(36408),
		60:  uint16(36411),
		61:  uint16(36412),
		62:  uint16(36414),
		63:  uint16(36415),
		64:  uint16(36419),
		65:  uint16(36421),
		66:  uint16(36422),
		67:  uint16(36428),
		68:  uint16(36429),
		69:  uint16(36430),
		70:  uint16(36431),
		71:  uint16(36432),
		72:  uint16(36435),
		73:  uint16(36436),
		74:  uint16(36437),
		75:  uint16(36438),
		76:  uint16(36439),
		77:  uint16(36440),
		78:  uint16(36442),
		79:  uint16(36443),
		80:  uint16(36444),
		81:  uint16(36445),
		82:  uint16(36446),
		83:  uint16(36447),
		84:  uint16(36448),
		85:  uint16(36449),
		86:  uint16(36450),
		87:  uint16(36451),
		88:  uint16(36452),
		89:  uint16(36453),
		90:  uint16(36455),
		91:  uint16(36456),
		92:  uint16(36458),
		93:  uint16(36459),
		94:  uint16(36462),
		95:  uint16(36465),
		96:  uint16(37048),
		97:  uint16(37040),
		98:  uint16(37071),
		99:  uint16(37061),
		100: uint16(37054),
		101: uint16(37072),
		102: uint16(37060),
		103: uint16(37063),
		104: uint16(37075),
		105: uint16(37094),
		106: uint16(37090),
		107: uint16(37084),
		108: uint16(37079),
		109: uint16(37083),
		110: uint16(37099),
		111: uint16(37103),
		112: uint16(37118),
		113: uint16(37124),
		114: uint16(37154),
		115: uint16(37150),
		116: uint16(37155),
		117: uint16(37169),
		118: uint16(37167),
		119: uint16(37177),
		120: uint16(37187),
		121: uint16(37190),
		122: uint16(21005),
		123: uint16(22850),
		124: uint16(21154),
		125: uint16(21164),
		126: uint16(21165),
		127: uint16(21182),
		128: uint16(21759),
		129: uint16(21200),
		130: uint16(21206),
		131: uint16(21232),
		132: uint16(21471),
		133: uint16(29166),
		134: uint16(30669),
		135: uint16(24308),
		136: uint16(20981),
		137: uint16(20988),
		138: uint16(39727),
		139: uint16(21430),
		140: uint16(24321),
		141: uint16(30042),
		142: uint16(24047),
		143: uint16(22348),
		144: uint16(22441),
		145: uint16(22433),
		146: uint16(22654),
		147: uint16(22716),
		148: uint16(22725),
		149: uint16(22737),
		150: uint16(22313),
		151: uint16(22316),
		152: uint16(22314),
		153: uint16(22323),
		154: uint16(22329),
		155: uint16(22318),
		156: uint16(22319),
		157: uint16(22364),
		158: uint16(22331),
		159: uint16(22338),
		160: uint16(22377),
		161: uint16(22405),
		162: uint16(22379),
		163: uint16(22406),
		164: uint16(22396),
		165: uint16(22395),
		166: uint16(22376),
		167: uint16(22381),
		168: uint16(22390),
		169: uint16(22387),
		170: uint16(22445),
		171: uint16(22436),
		172: uint16(22412),
		173: uint16(22450),
		174: uint16(22479),
		175: uint16(22439),
		176: uint16(22452),
		177: uint16(22419),
		178: uint16(22432),
		179: uint16(22485),
		180: uint16(22488),
		181: uint16(22490),
		182: uint16(22489),
		183: uint16(22482),
		184: uint16(22456),
		185: uint16(22516),
		186: uint16(22511),
		187: uint16(22520),
		188: uint16(22500),
		189: uint16(22493),
	},
	91: {
		0:   uint16(36467),
		1:   uint16(36469),
		2:   uint16(36471),
		3:   uint16(36472),
		4:   uint16(36473),
		5:   uint16(36474),
		6:   uint16(36475),
		7:   uint16(36477),
		8:   uint16(36478),
		9:   uint16(36480),
		10:  uint16(36482),
		11:  uint16(36483),
		12:  uint16(36484),
		13:  uint16(36486),
		14:  uint16(36488),
		15:  uint16(36489),
		16:  uint16(36490),
		17:  uint16(36491),
		18:  uint16(36492),
		19:  uint16(36493),
		20:  uint16(36494),
		21:  uint16(36497),
		22:  uint16(36498),
		23:  uint16(36499),
		24:  uint16(36501),
		25:  uint16(36502),
		26:  uint16(36503),
		27:  uint16(36504),
		28:  uint16(36505),
		29:  uint16(36506),
		30:  uint16(36507),
		31:  uint16(36509),
		32:  uint16(36511),
		33:  uint16(36512),
		34:  uint16(36513),
		35:  uint16(36514),
		36:  uint16(36515),
		37:  uint16(36516),
		38:  uint16(36517),
		39:  uint16(36518),
		40:  uint16(36519),
		41:  uint16(36520),
		42:  uint16(36521),
		43:  uint16(36522),
		44:  uint16(36525),
		45:  uint16(36526),
		46:  uint16(36528),
		47:  uint16(36529),
		48:  uint16(36531),
		49:  uint16(36532),
		50:  uint16(36533),
		51:  uint16(36534),
		52:  uint16(36535),
		53:  uint16(36536),
		54:  uint16(36537),
		55:  uint16(36539),
		56:  uint16(36540),
		57:  uint16(36541),
		58:  uint16(36542),
		59:  uint16(36543),
		60:  uint16(36544),
		61:  uint16(36545),
		62:  uint16(36546),
		63:  uint16(36547),
		64:  uint16(36548),
		65:  uint16(36549),
		66:  uint16(36550),
		67:  uint16(36551),
		68:  uint16(36552),
		69:  uint16(36553),
		70:  uint16(36554),
		71:  uint16(36555),
		72:  uint16(36556),
		73:  uint16(36557),
		74:  uint16(36559),
		75:  uint16(36560),
		76:  uint16(36561),
		77:  uint16(36562),
		78:  uint16(36563),
		79:  uint16(36564),
		80:  uint16(36565),
		81:  uint16(36566),
		82:  uint16(36567),
		83:  uint16(36568),
		84:  uint16(36569),
		85:  uint16(36570),
		86:  uint16(36571),
		87:  uint16(36572),
		88:  uint16(36573),
		89:  uint16(36574),
		90:  uint16(36575),
		91:  uint16(36576),
		92:  uint16(36577),
		93:  uint16(36578),
		94:  uint16(36579),
		95:  uint16(36580),
		96:  uint16(22539),
		97:  uint16(22541),
		98:  uint16(22525),
		99:  uint16(22509),
		100: uint16(22528),
		101: uint16(22558),
		102: uint16(22553),
		103: uint16(22596),
		104: uint16(22560),
		105: uint16(22629),
		106: uint16(22636),
		107: uint16(22657),
		108: uint16(22665),
		109: uint16(22682),
		110: uint16(22656),
		111: uint16(39336),
		112: uint16(40729),
		113: uint16(25087),
		114: uint16(33401),
		115: uint16(33405),
		116: uint16(33407),
		117: uint16(33423),
		118: uint16(33418),
		119: uint16(33448),
		120: uint16(33412),
		121: uint16(33422),
		122: uint16(33425),
		123: uint16(33431),
		124: uint16(33433),
		125: uint16(33451),
		126: uint16(33464),
		127: uint16(33470),
		128: uint16(33456),
		129: uint16(33480),
		130: uint16(33482),
		131: uint16(33507),
		132: uint16(33432),
		133: uint16(33463),
		134: uint16(33454),
		135: uint16(33483),
		136: uint16(33484),
		137: uint16(33473),
		138: uint16(33449),
		139: uint16(33460),
		140: uint16(33441),
		141: uint16(33450),
		142: uint16(33439),
		143: uint16(33476),
		144: uint16(33486),
		145: uint16(33444),
		146: uint16(33505),
		147: uint16(33545),
		148: uint16(33527),
		149: uint16(33508),
		150: uint16(33551),
		151: uint16(33543),
		152: uint16(33500),
		153: uint16(33524),
		154: uint16(33490),
		155: uint16(33496),
		156: uint16(33548),
		157: uint16(33531),
		158: uint16(33491),
		159: uint16(33553),
		160: uint16(33562),
		161: uint16(33542),
		162: uint16(33556),
		163: uint16(33557),
		164: uint16(33504),
		165: uint16(33493),
		166: uint16(33564),
		167: uint16(33617),
		168: uint16(33627),
		169: uint16(33628),
		170: uint16(33544),
		171: uint16(33682),
		172: uint16(33596),
		173: uint16(33588),
		174: uint16(33585),
		175: uint16(33691),
		176: uint16(33630),
		177: uint16(33583),
		178: uint16(33615),
		179: uint16(33607),
		180: uint16(33603),
		181: uint16(33631),
		182: uint16(33600),
		183: uint16(33559),
		184: uint16(33632),
		185: uint16(33581),
		186: uint16(33594),
		187: uint16(33587),
		188: uint16(33638),
		189: uint16(33637),
	},
	92: {
		0:   uint16(36581),
		1:   uint16(36582),
		2:   uint16(36583),
		3:   uint16(36584),
		4:   uint16(36585),
		5:   uint16(36586),
		6:   uint16(36587),
		7:   uint16(36588),
		8:   uint16(36589),
		9:   uint16(36590),
		10:  uint16(36591),
		11:  uint16(36592),
		12:  uint16(36593),
		13:  uint16(36594),
		14:  uint16(36595),
		15:  uint16(36596),
		16:  uint16(36597),
		17:  uint16(36598),
		18:  uint16(36599),
		19:  uint16(36600),
		20:  uint16(36601),
		21:  uint16(36602),
		22:  uint16(36603),
		23:  uint16(36604),
		24:  uint16(36605),
		25:  uint16(36606),
		26:  uint16(36607),
		27:  uint16(36608),
		28:  uint16(36609),
		29:  uint16(36610),
		30:  uint16(36611),
		31:  uint16(36612),
		32:  uint16(36613),
		33:  uint16(36614),
		34:  uint16(36615),
		35:  uint16(36616),
		36:  uint16(36617),
		37:  uint16(36618),
		38:  uint16(36619),
		39:  uint16(36620),
		40:  uint16(36621),
		41:  uint16(36622),
		42:  uint16(36623),
		43:  uint16(36624),
		44:  uint16(36625),
		45:  uint16(36626),
		46:  uint16(36627),
		47:  uint16(36628),
		48:  uint16(36629),
		49:  uint16(36630),
		50:  uint16(36631),
		51:  uint16(36632),
		52:  uint16(36633),
		53:  uint16(36634),
		54:  uint16(36635),
		55:  uint16(36636),
		56:  uint16(36637),
		57:  uint16(36638),
		58:  uint16(36639),
		59:  uint16(36640),
		60:  uint16(36641),
		61:  uint16(36642),
		62:  uint16(36643),
		63:  uint16(36644),
		64:  uint16(36645),
		65:  uint16(36646),
		66:  uint16(36647),
		67:  uint16(36648),
		68:  uint16(36649),
		69:  uint16(36650),
		70:  uint16(36651),
		71:  uint16(36652),
		72:  uint16(36653),
		73:  uint16(36654),
		74:  uint16(36655),
		75:  uint16(36656),
		76:  uint16(36657),
		77:  uint16(36658),
		78:  uint16(36659),
		79:  uint16(36660),
		80:  uint16(36661),
		81:  uint16(36662),
		82:  uint16(36663),
		83:  uint16(36664),
		84:  uint16(36665),
		85:  uint16(36666),
		86:  uint16(36667),
		87:  uint16(36668),
		88:  uint16(36669),
		89:  uint16(36670),
		90:  uint16(36671),
		91:  uint16(36672),
		92:  uint16(36673),
		93:  uint16(36674),
		94:  uint16(36675),
		95:  uint16(36676),
		96:  uint16(33640),
		97:  uint16(33563),
		98:  uint16(33641),
		99:  uint16(33644),
		100: uint16(33642),
		101: uint16(33645),
		102: uint16(33646),
		103: uint16(33712),
		104: uint16(33656),
		105: uint16(33715),
		106: uint16(33716),
		107: uint16(33696),
		108: uint16(33706),
		109: uint16(33683),
		110: uint16(33692),
		111: uint16(33669),
		112: uint16(33660),
		113: uint16(33718),
		114: uint16(33705),
		115: uint16(33661),
		116: uint16(33720),
		117: uint16(33659),
		118: uint16(33688),
		119: uint16(33694),
		120: uint16(33704),
		121: uint16(33722),
		122: uint16(33724),
		123: uint16(33729),
		124: uint16(33793),
		125: uint16(33765),
		126: uint16(33752),
		127: uint16(22535),
		128: uint16(33816),
		129: uint16(33803),
		130: uint16(33757),
		131: uint16(33789),
		132: uint16(33750),
		133: uint16(33820),
		134: uint16(33848),
		135: uint16(33809),
		136: uint16(33798),
		137: uint16(33748),
		138: uint16(33759),
		139: uint16(33807),
		140: uint16(33795),
		141: uint16(33784),
		142: uint16(33785),
		143: uint16(33770),
		144: uint16(33733),
		145: uint16(33728),
		146: uint16(33830),
		147: uint16(33776),
		148: uint16(33761),
		149: uint16(33884),
		150: uint16(33873),
		151: uint16(33882),
		152: uint16(33881),
		153: uint16(33907),
		154: uint16(33927),
		155: uint16(33928),
		156: uint16(33914),
		157: uint16(33929),
		158: uint16(33912),
		159: uint16(33852),
		160: uint16(33862),
		161: uint16(33897),
		162: uint16(33910),
		163: uint16(33932),
		164: uint16(33934),
		165: uint16(33841),
		166: uint16(33901),
		167: uint16(33985),
		168: uint16(33997),
		169: uint16(34000),
		170: uint16(34022),
		171: uint16(33981),
		172: uint16(34003),
		173: uint16(33994),
		174: uint16(33983),
		175: uint16(33978),
		176: uint16(34016),
		177: uint16(33953),
		178: uint16(33977),
		179: uint16(33972),
		180: uint16(33943),
		181: uint16(34021),
		182: uint16(34019),
		183: uint16(34060),
		184: uint16(29965),
		185: uint16(34104),
		186: uint16(34032),
		187: uint16(34105),
		188: uint16(34079),
		189: uint16(34106),
	},
	93: {
		0:   uint16(36677),
		1:   uint16(36678),
		2:   uint16(36679),
		3:   uint16(36680),
		4:   uint16(36681),
		5:   uint16(36682),
		6:   uint16(36683),
		7:   uint16(36684),
		8:   uint16(36685),
		9:   uint16(36686),
		10:  uint16(36687),
		11:  uint16(36688),
		12:  uint16(36689),
		13:  uint16(36690),
		14:  uint16(36691),
		15:  uint16(36692),
		16:  uint16(36693),
		17:  uint16(36694),
		18:  uint16(36695),
		19:  uint16(36696),
		20:  uint16(36697),
		21:  uint16(36698),
		22:  uint16(36699),
		23:  uint16(36700),
		24:  uint16(36701),
		25:  uint16(36702),
		26:  uint16(36703),
		27:  uint16(36704),
		28:  uint16(36705),
		29:  uint16(36706),
		30:  uint16(36707),
		31:  uint16(36708),
		32:  uint16(36709),
		33:  uint16(36714),
		34:  uint16(36736),
		35:  uint16(36748),
		36:  uint16(36754),
		37:  uint16(36765),
		38:  uint16(36768),
		39:  uint16(36769),
		40:  uint16(36770),
		41:  uint16(36772),
		42:  uint16(36773),
		43:  uint16(36774),
		44:  uint16(36775),
		45:  uint16(36778),
		46:  uint16(36780),
		47:  uint16(36781),
		48:  uint16(36782),
		49:  uint16(36783),
		50:  uint16(36786),
		51:  uint16(36787),
		52:  uint16(36788),
		53:  uint16(36789),
		54:  uint16(36791),
		55:  uint16(36792),
		56:  uint16(36794),
		57:  uint16(36795),
		58:  uint16(36796),
		59:  uint16(36799),
		60:  uint16(36800),
		61:  uint16(36803),
		62:  uint16(36806),
		63:  uint16(36809),
		64:  uint16(36810),
		65:  uint16(36811),
		66:  uint16(36812),
		67:  uint16(36813),
		68:  uint16(36815),
		69:  uint16(36818),
		70:  uint16(36822),
		71:  uint16(36823),
		72:  uint16(36826),
		73:  uint16(36832),
		74:  uint16(36833),
		75:  uint16(36835),
		76:  uint16(36839),
		77:  uint16(36844),
		78:  uint16(36847),
		79:  uint16(36849),
		80:  uint16(36850),
		81:  uint16(36852),
		82:  uint16(36853),
		83:  uint16(36854),
		84:  uint16(36858),
		85:  uint16(36859),
		86:  uint16(36860),
		87:  uint16(36862),
		88:  uint16(36863),
		89:  uint16(36871),
		90:  uint16(36872),
		91:  uint16(36876),
		92:  uint16(36878),
		93:  uint16(36883),
		94:  uint16(36885),
		95:  uint16(36888),
		96:  uint16(34134),
		97:  uint16(34107),
		98:  uint16(34047),
		99:  uint16(34044),
		100: uint16(34137),
		101: uint16(34120),
		102: uint16(34152),
		103: uint16(34148),
		104: uint16(34142),
		105: uint16(34170),
		106: uint16(30626),
		107: uint16(34115),
		108: uint16(34162),
		109: uint16(34171),
		110: uint16(34212),
		111: uint16(34216),
		112: uint16(34183),
		113: uint16(34191),
		114: uint16(34169),
		115: uint16(34222),
		116: uint16(34204),
		117: uint16(34181),
		118: uint16(34233),
		119: uint16(34231),
		120: uint16(34224),
		121: uint16(34259),
		122: uint16(34241),
		123: uint16(34268),
		124: uint16(34303),
		125: uint16(34343),
		126: uint16(34309),
		127: uint16(34345),
		128: uint16(34326),
		129: uint16(34364),
		130: uint16(24318),
		131: uint16(24328),
		132: uint16(22844),
		133: uint16(22849),
		134: uint16(32823),
		135: uint16(22869),
		136: uint16(22874),
		137: uint16(22872),
		138: uint16(21263),
		139: uint16(23586),
		140: uint16(23589),
		141: uint16(23596),
		142: uint16(23604),
		143: uint16(25164),
		144: uint16(25194),
		145: uint16(25247),
		146: uint16(25275),
		147: uint16(25290),
		148: uint16(25306),
		149: uint16(25303),
		150: uint16(25326),
		151: uint16(25378),
		152: uint16(25334),
		153: uint16(25401),
		154: uint16(25419),
		155: uint16(25411),
		156: uint16(25517),
		157: uint16(25590),
		158: uint16(25457),
		159: uint16(25466),
		160: uint16(25486),
		161: uint16(25524),
		162: uint16(25453),
		163: uint16(25516),
		164: uint16(25482),
		165: uint16(25449),
		166: uint16(25518),
		167: uint16(25532),
		168: uint16(25586),
		169: uint16(25592),
		170: uint16(25568),
		171: uint16(25599),
		172: uint16(25540),
		173: uint16(25566),
		174: uint16(25550),
		175: uint16(25682),
		176: uint16(25542),
		177: uint16(25534),
		178: uint16(25669),
		179: uint16(25665),
		180: uint16(25611),
		181: uint16(25627),
		182: uint16(25632),
		183: uint16(25612),
		184: uint16(25638),
		185: uint16(25633),
		186: uint16(25694),
		187: uint16(25732),
		188: uint16(25709),
		189: uint16(25750),
	},
	94: {
		0:   uint16(36889),
		1:   uint16(36892),
		2:   uint16(36899),
		3:   uint16(36900),
		4:   uint16(36901),
		5:   uint16(36903),
		6:   uint16(36904),
		7:   uint16(36905),
		8:   uint16(36906),
		9:   uint16(36907),
		10:  uint16(36908),
		11:  uint16(36912),
		12:  uint16(36913),
		13:  uint16(36914),
		14:  uint16(36915),
		15:  uint16(36916),
		16:  uint16(36919),
		17:  uint16(36921),
		18:  uint16(36922),
		19:  uint16(36925),
		20:  uint16(36927),
		21:  uint16(36928),
		22:  uint16(36931),
		23:  uint16(36933),
		24:  uint16(36934),
		25:  uint16(36936),
		26:  uint16(36937),
		27:  uint16(36938),
		28:  uint16(36939),
		29:  uint16(36940),
		30:  uint16(36942),
		31:  uint16(36948),
		32:  uint16(36949),
		33:  uint16(36950),
		34:  uint16(36953),
		35:  uint16(36954),
		36:  uint16(36956),
		37:  uint16(36957),
		38:  uint16(36958),
		39:  uint16(36959),
		40:  uint16(36960),
		41:  uint16(36961),
		42:  uint16(36964),
		43:  uint16(36966),
		44:  uint16(36967),
		45:  uint16(36969),
		46:  uint16(36970),
		47:  uint16(36971),
		48:  uint16(36972),
		49:  uint16(36975),
		50:  uint16(36976),
		51:  uint16(36977),
		52:  uint16(36978),
		53:  uint16(36979),
		54:  uint16(36982),
		55:  uint16(36983),
		56:  uint16(36984),
		57:  uint16(36985),
		58:  uint16(36986),
		59:  uint16(36987),
		60:  uint16(36988),
		61:  uint16(36990),
		62:  uint16(36993),
		63:  uint16(36996),
		64:  uint16(36997),
		65:  uint16(36998),
		66:  uint16(36999),
		67:  uint16(37001),
		68:  uint16(37002),
		69:  uint16(37004),
		70:  uint16(37005),
		71:  uint16(37006),
		72:  uint16(37007),
		73:  uint16(37008),
		74:  uint16(37010),
		75:  uint16(37012),
		76:  uint16(37014),
		77:  uint16(37016),
		78:  uint16(37018),
		79:  uint16(37020),
		80:  uint16(37022),
		81:  uint16(37023),
		82:  uint16(37024),
		83:  uint16(37028),
		84:  uint16(37029),
		85:  uint16(37031),
		86:  uint16(37032),
		87:  uint16(37033),
		88:  uint16(37035),
		89:  uint16(37037),
		90:  uint16(37042),
		91:  uint16(37047),
		92:  uint16(37052),
		93:  uint16(37053),
		94:  uint16(37055),
		95:  uint16(37056),
		96:  uint16(25722),
		97:  uint16(25783),
		98:  uint16(25784),
		99:  uint16(25753),
		100: uint16(25786),
		101: uint16(25792),
		102: uint16(25808),
		103: uint16(25815),
		104: uint16(25828),
		105: uint16(25826),
		106: uint16(25865),
		107: uint16(25893),
		108: uint16(25902),
		109: uint16(24331),
		110: uint16(24530),
		111: uint16(29977),
		112: uint16(24337),
		113: uint16(21343),
		114: uint16(21489),
		115: uint16(21501),
		116: uint16(21481),
		117: uint16(21480),
		118: uint16(21499),
		119: uint16(21522),
		120: uint16(21526),
		121: uint16(21510),
		122: uint16(21579),
		123: uint16(21586),
		124: uint16(21587),
		125: uint16(21588),
		126: uint16(21590),
		127: uint16(21571),
		128: uint16(21537),
		129: uint16(21591),
		130: uint16(21593),
		131: uint16(21539),
		132: uint16(21554),
		133: uint16(21634),
		134: uint16(21652),
		135: uint16(21623),
		136: uint16(21617),
		137: uint16(21604),
		138: uint16(21658),
		139: uint16(21659),
		140: uint16(21636),
		141: uint16(21622),
		142: uint16(21606),
		143: uint16(21661),
		144: uint16(21712),
		145: uint16(21677),
		146: uint16(21698),
		147: uint16(21684),
		148: uint16(21714),
		149: uint16(21671),
		150: uint16(21670),
		151: uint16(21715),
		152: uint16(21716),
		153: uint16(21618),
		154: uint16(21667),
		155: uint16(21717),
		156: uint16(21691),
		157: uint16(21695),
		158: uint16(21708),
		159: uint16(21721),
		160: uint16(21722),
		161: uint16(21724),
		162: uint16(21673),
		163: uint16(21674),
		164: uint16(21668),
		165: uint16(21725),
		166: uint16(21711),
		167: uint16(21726),
		168: uint16(21787),
		169: uint16(21735),
		170: uint16(21792),
		171: uint16(21757),
		172: uint16(21780),
		173: uint16(21747),
		174: uint16(21794),
		175: uint16(21795),
		176: uint16(21775),
		177: uint16(21777),
		178: uint16(21799),
		179: uint16(21802),
		180: uint16(21863),
		181: uint16(21903),
		182: uint16(21941),
		183: uint16(21833),
		184: uint16(21869),
		185: uint16(21825),
		186: uint16(21845),
		187: uint16(21823),
		188: uint16(21840),
		189: uint16(21820),
	},
	95: {
		0:   uint16(37058),
		1:   uint16(37059),
		2:   uint16(37062),
		3:   uint16(37064),
		4:   uint16(37065),
		5:   uint16(37067),
		6:   uint16(37068),
		7:   uint16(37069),
		8:   uint16(37074),
		9:   uint16(37076),
		10:  uint16(37077),
		11:  uint16(37078),
		12:  uint16(37080),
		13:  uint16(37081),
		14:  uint16(37082),
		15:  uint16(37086),
		16:  uint16(37087),
		17:  uint16(37088),
		18:  uint16(37091),
		19:  uint16(37092),
		20:  uint16(37093),
		21:  uint16(37097),
		22:  uint16(37098),
		23:  uint16(37100),
		24:  uint16(37102),
		25:  uint16(37104),
		26:  uint16(37105),
		27:  uint16(37106),
		28:  uint16(37107),
		29:  uint16(37109),
		30:  uint16(37110),
		31:  uint16(37111),
		32:  uint16(37113),
		33:  uint16(37114),
		34:  uint16(37115),
		35:  uint16(37116),
		36:  uint16(37119),
		37:  uint16(37120),
		38:  uint16(37121),
		39:  uint16(37123),
		40:  uint16(37125),
		41:  uint16(37126),
		42:  uint16(37127),
		43:  uint16(37128),
		44:  uint16(37129),
		45:  uint16(37130),
		46:  uint16(37131),
		47:  uint16(37132),
		48:  uint16(37133),
		49:  uint16(37134),
		50:  uint16(37135),
		51:  uint16(37136),
		52:  uint16(37137),
		53:  uint16(37138),
		54:  uint16(37139),
		55:  uint16(37140),
		56:  uint16(37141),
		57:  uint16(37142),
		58:  uint16(37143),
		59:  uint16(37144),
		60:  uint16(37146),
		61:  uint16(37147),
		62:  uint16(37148),
		63:  uint16(37149),
		64:  uint16(37151),
		65:  uint16(37152),
		66:  uint16(37153),
		67:  uint16(37156),
		68:  uint16(37157),
		69:  uint16(37158),
		70:  uint16(37159),
		71:  uint16(37160),
		72:  uint16(37161),
		73:  uint16(37162),
		74:  uint16(37163),
		75:  uint16(37164),
		76:  uint16(37165),
		77:  uint16(37166),
		78:  uint16(37168),
		79:  uint16(37170),
		80:  uint16(37171),
		81:  uint16(37172),
		82:  uint16(37173),
		83:  uint16(37174),
		84:  uint16(37175),
		85:  uint16(37176),
		86:  uint16(37178),
		87:  uint16(37179),
		88:  uint16(37180),
		89:  uint16(37181),
		90:  uint16(37182),
		91:  uint16(37183),
		92:  uint16(37184),
		93:  uint16(37185),
		94:  uint16(37186),
		95:  uint16(37188),
		96:  uint16(21815),
		97:  uint16(21846),
		98:  uint16(21877),
		99:  uint16(21878),
		100: uint16(21879),
		101: uint16(21811),
		102: uint16(21808),
		103: uint16(21852),
		104: uint16(21899),
		105: uint16(21970),
		106: uint16(21891),
		107: uint16(21937),
		108: uint16(21945),
		109: uint16(21896),
		110: uint16(21889),
		111: uint16(21919),
		112: uint16(21886),
		113: uint16(21974),
		114: uint16(21905),
		115: uint16(21883),
		116: uint16(21983),
		117: uint16(21949),
		118: uint16(21950),
		119: uint16(21908),
		120: uint16(21913),
		121: uint16(21994),
		122: uint16(22007),
		123: uint16(21961),
		124: uint16(22047),
		125: uint16(21969),
		126: uint16(21995),
		127: uint16(21996),
		128: uint16(21972),
		129: uint16(21990),
		130: uint16(21981),
		131: uint16(21956),
		132: uint16(21999),
		133: uint16(21989),
		134: uint16(22002),
		135: uint16(22003),
		136: uint16(21964),
		137: uint16(21965),
		138: uint16(21992),
		139: uint16(22005),
		140: uint16(21988),
		141: uint16(36756),
		142: uint16(22046),
		143: uint16(22024),
		144: uint16(22028),
		145: uint16(22017),
		146: uint16(22052),
		147: uint16(22051),
		148: uint16(22014),
		149: uint16(22016),
		150: uint16(22055),
		151: uint16(22061),
		152: uint16(22104),
		153: uint16(22073),
		154: uint16(22103),
		155: uint16(22060),
		156: uint16(22093),
		157: uint16(22114),
		158: uint16(22105),
		159: uint16(22108),
		160: uint16(22092),
		161: uint16(22100),
		162: uint16(22150),
		163: uint16(22116),
		164: uint16(22129),
		165: uint16(22123),
		166: uint16(22139),
		167: uint16(22140),
		168: uint16(22149),
		169: uint16(22163),
		170: uint16(22191),
		171: uint16(22228),
		172: uint16(22231),
		173: uint16(22237),
		174: uint16(22241),
		175: uint16(22261),
		176: uint16(22251),
		177: uint16(22265),
		178: uint16(22271),
		179: uint16(22276),
		180: uint16(22282),
		181: uint16(22281),
		182: uint16(22300),
		183: uint16(24079),
		184: uint16(24089),
		185: uint16(24084),
		186: uint16(24081),
		187: uint16(24113),
		188: uint16(24123),
		189: uint16(24124),
	},
	96: {
		0:   uint16(37189),
		1:   uint16(37191),
		2:   uint16(37192),
		3:   uint16(37201),
		4:   uint16(37203),
		5:   uint16(37204),
		6:   uint16(37205),
		7:   uint16(37206),
		8:   uint16(37208),
		9:   uint16(37209),
		10:  uint16(37211),
		11:  uint16(37212),
		12:  uint16(37215),
		13:  uint16(37216),
		14:  uint16(37222),
		15:  uint16(37223),
		16:  uint16(37224),
		17:  uint16(37227),
		18:  uint16(37229),
		19:  uint16(37235),
		20:  uint16(37242),
		21:  uint16(37243),
		22:  uint16(37244),
		23:  uint16(37248),
		24:  uint16(37249),
		25:  uint16(37250),
		26:  uint16(37251),
		27:  uint16(37252),
		28:  uint16(37254),
		29:  uint16(37256),
		30:  uint16(37258),
		31:  uint16(37262),
		32:  uint16(37263),
		33:  uint16(37267),
		34:  uint16(37268),
		35:  uint16(37269),
		36:  uint16(37270),
		37:  uint16(37271),
		38:  uint16(37272),
		39:  uint16(37273),
		40:  uint16(37276),
		41:  uint16(37277),
		42:  uint16(37278),
		43:  uint16(37279),
		44:  uint16(37280),
		45:  uint16(37281),
		46:  uint16(37284),
		47:  uint16(37285),
		48:  uint16(37286),
		49:  uint16(37287),
		50:  uint16(37288),
		51:  uint16(37289),
		52:  uint16(37291),
		53:  uint16(37292),
		54:  uint16(37296),
		55:  uint16(37297),
		56:  uint16(37298),
		57:  uint16(37299),
		58:  uint16(37302),
		59:  uint16(37303),
		60:  uint16(37304),
		61:  uint16(37305),
		62:  uint16(37307),
		63:  uint16(37308),
		64:  uint16(37309),
		65:  uint16(37310),
		66:  uint16(37311),
		67:  uint16(37312),
		68:  uint16(37313),
		69:  uint16(37314),
		70:  uint16(37315),
		71:  uint16(37316),
		72:  uint16(37317),
		73:  uint16(37318),
		74:  uint16(37320),
		75:  uint16(37323),
		76:  uint16(37328),
		77:  uint16(37330),
		78:  uint16(37331),
		79:  uint16(37332),
		80:  uint16(37333),
		81:  uint16(37334),
		82:  uint16(37335),
		83:  uint16(37336),
		84:  uint16(37337),
		85:  uint16(37338),
		86:  uint16(37339),
		87:  uint16(37341),
		88:  uint16(37342),
		89:  uint16(37343),
		90:  uint16(37344),
		91:  uint16(37345),
		92:  uint16(37346),
		93:  uint16(37347),
		94:  uint16(37348),
		95:  uint16(37349),
		96:  uint16(24119),
		97:  uint16(24132),
		98:  uint16(24148),
		99:  uint16(24155),
		100: uint16(24158),
		101: uint16(24161),
		102: uint16(23692),
		103: uint16(23674),
		104: uint16(23693),
		105: uint16(23696),
		106: uint16(23702),
		107: uint16(23688),
		108: uint16(23704),
		109: uint16(23705),
		110: uint16(23697),
		111: uint16(23706),
		112: uint16(23708),
		113: uint16(23733),
		114: uint16(23714),
		115: uint16(23741),
		116: uint16(23724),
		117: uint16(23723),
		118: uint16(23729),
		119: uint16(23715),
		120: uint16(23745),
		121: uint16(23735),
		122: uint16(23748),
		123: uint16(23762),
		124: uint16(23780),
		125: uint16(23755),
		126: uint16(23781),
		127: uint16(23810),
		128: uint16(23811),
		129: uint16(23847),
		130: uint16(23846),
		131: uint16(23854),
		132: uint16(23844),
		133: uint16(23838),
		134: uint16(23814),
		135: uint16(23835),
		136: uint16(23896),
		137: uint16(23870),
		138: uint16(23860),
		139: uint16(23869),
		140: uint16(23916),
		141: uint16(23899),
		142: uint16(23919),
		143: uint16(23901),
		144: uint16(23915),
		145: uint16(23883),
		146: uint16(23882),
		147: uint16(23913),
		148: uint16(23924),
		149: uint16(23938),
		150: uint16(23961),
		151: uint16(23965),
		152: uint16(35955),
		153: uint16(23991),
		154: uint16(24005),
		155: uint16(24435),
		156: uint16(24439),
		157: uint16(24450),
		158: uint16(24455),
		159: uint16(24457),
		160: uint16(24460),
		161: uint16(24469),
		162: uint16(24473),
		163: uint16(24476),
		164: uint16(24488),
		165: uint16(24493),
		166: uint16(24501),
		167: uint16(24508),
		168: uint16(34914),
		169: uint16(24417),
		170: uint16(29357),
		171: uint16(29360),
		172: uint16(29364),
		173: uint16(29367),
		174: uint16(29368),
		175: uint16(29379),
		176: uint16(29377),
		177: uint16(29390),
		178: uint16(29389),
		179: uint16(29394),
		180: uint16(29416),
		181: uint16(29423),
		182: uint16(29417),
		183: uint16(29426),
		184: uint16(29428),
		185: uint16(29431),
		186: uint16(29441),
		187: uint16(29427),
		188: uint16(29443),
		189: uint16(29434),
	},
	97: {
		0:   uint16(37350),
		1:   uint16(37351),
		2:   uint16(37352),
		3:   uint16(37353),
		4:   uint16(37354),
		5:   uint16(37355),
		6:   uint16(37356),
		7:   uint16(37357),
		8:   uint16(37358),
		9:   uint16(37359),
		10:  uint16(37360),
		11:  uint16(37361),
		12:  uint16(37362),
		13:  uint16(37363),
		14:  uint16(37364),
		15:  uint16(37365),
		16:  uint16(37366),
		17:  uint16(37367),
		18:  uint16(37368),
		19:  uint16(37369),
		20:  uint16(37370),
		21:  uint16(37371),
		22:  uint16(37372),
		23:  uint16(37373),
		24:  uint16(37374),
		25:  uint16(37375),
		26:  uint16(37376),
		27:  uint16(37377),
		28:  uint16(37378),
		29:  uint16(37379),
		30:  uint16(37380),
		31:  uint16(37381),
		32:  uint16(37382),
		33:  uint16(37383),
		34:  uint16(37384),
		35:  uint16(37385),
		36:  uint16(37386),
		37:  uint16(37387),
		38:  uint16(37388),
		39:  uint16(37389),
		40:  uint16(37390),
		41:  uint16(37391),
		42:  uint16(37392),
		43:  uint16(37393),
		44:  uint16(37394),
		45:  uint16(37395),
		46:  uint16(37396),
		47:  uint16(37397),
		48:  uint16(37398),
		49:  uint16(37399),
		50:  uint16(37400),
		51:  uint16(37401),
		52:  uint16(37402),
		53:  uint16(37403),
		54:  uint16(37404),
		55:  uint16(37405),
		56:  uint16(37406),
		57:  uint16(37407),
		58:  uint16(37408),
		59:  uint16(37409),
		60:  uint16(37410),
		61:  uint16(37411),
		62:  uint16(37412),
		63:  uint16(37413),
		64:  uint16(37414),
		65:  uint16(37415),
		66:  uint16(37416),
		67:  uint16(37417),
		68:  uint16(37418),
		69:  uint16(37419),
		70:  uint16(37420),
		71:  uint16(37421),
		72:  uint16(37422),
		73:  uint16(37423),
		74:  uint16(37424),
		75:  uint16(37425),
		76:  uint16(37426),
		77:  uint16(37427),
		78:  uint16(37428),
		79:  uint16(37429),
		80:  uint16(37430),
		81:  uint16(37431),
		82:  uint16(37432),
		83:  uint16(37433),
		84:  uint16(37434),
		85:  uint16(37435),
		86:  uint16(37436),
		87:  uint16(37437),
		88:  uint16(37438),
		89:  uint16(37439),
		90:  uint16(37440),
		91:  uint16(37441),
		92:  uint16(37442),
		93:  uint16(37443),
		94:  uint16(37444),
		95:  uint16(37445),
		96:  uint16(29435),
		97:  uint16(29463),
		98:  uint16(29459),
		99:  uint16(29473),
		100: uint16(29450),
		101: uint16(29470),
		102: uint16(29469),
		103: uint16(29461),
		104: uint16(29474),
		105: uint16(29497),
		106: uint16(29477),
		107: uint16(29484),
		108: uint16(29496),
		109: uint16(29489),
		110: uint16(29520),
		111: uint16(29517),
		112: uint16(29527),
		113: uint16(29536),
		114: uint16(29548),
		115: uint16(29551),
		116: uint16(29566),
		117: uint16(33307),
		118: uint16(22821),
		119: uint16(39143),
		120: uint16(22820),
		121: uint16(22786),
		122: uint16(39267),
		123: uint16(39271),
		124: uint16(39272),
		125: uint16(39273),
		126: uint16(39274),
		127: uint16(39275),
		128: uint16(39276),
		129: uint16(39284),
		130: uint16(39287),
		131: uint16(39293),
		132: uint16(39296),
		133: uint16(39300),
		134: uint16(39303),
		135: uint16(39306),
		136: uint16(39309),
		137: uint16(39312),
		138: uint16(39313),
		139: uint16(39315),
		140: uint16(39316),
		141: uint16(39317),
		142: uint16(24192),
		143: uint16(24209),
		144: uint16(24203),
		145: uint16(24214),
		146: uint16(24229),
		147: uint16(24224),
		148: uint16(24249),
		149: uint16(24245),
		150: uint16(24254),
		151: uint16(24243),
		152: uint16(36179),
		153: uint16(24274),
		154: uint16(24273),
		155: uint16(24283),
		156: uint16(24296),
		157: uint16(24298),
		158: uint16(33210),
		159: uint16(24516),
		160: uint16(24521),
		161: uint16(24534),
		162: uint16(24527),
		163: uint16(24579),
		164: uint16(24558),
		165: uint16(24580),
		166: uint16(24545),
		167: uint16(24548),
		168: uint16(24574),
		169: uint16(24581),
		170: uint16(24582),
		171: uint16(24554),
		172: uint16(24557),
		173: uint16(24568),
		174: uint16(24601),
		175: uint16(24629),
		176: uint16(24614),
		177: uint16(24603),
		178: uint16(24591),
		179: uint16(24589),
		180: uint16(24617),
		181: uint16(24619),
		182: uint16(24586),
		183: uint16(24639),
		184: uint16(24609),
		185: uint16(24696),
		186: uint16(24697),
		187: uint16(24699),
		188: uint16(24698),
		189: uint16(24642),
	},
	98: {
		0:   uint16(37446),
		1:   uint16(37447),
		2:   uint16(37448),
		3:   uint16(37449),
		4:   uint16(37450),
		5:   uint16(37451),
		6:   uint16(37452),
		7:   uint16(37453),
		8:   uint16(37454),
		9:   uint16(37455),
		10:  uint16(37456),
		11:  uint16(37457),
		12:  uint16(37458),
		13:  uint16(37459),
		14:  uint16(37460),
		15:  uint16(37461),
		16:  uint16(37462),
		17:  uint16(37463),
		18:  uint16(37464),
		19:  uint16(37465),
		20:  uint16(37466),
		21:  uint16(37467),
		22:  uint16(37468),
		23:  uint16(37469),
		24:  uint16(37470),
		25:  uint16(37471),
		26:  uint16(37472),
		27:  uint16(37473),
		28:  uint16(37474),
		29:  uint16(37475),
		30:  uint16(37476),
		31:  uint16(37477),
		32:  uint16(37478),
		33:  uint16(37479),
		34:  uint16(37480),
		35:  uint16(37481),
		36:  uint16(37482),
		37:  uint16(37483),
		38:  uint16(37484),
		39:  uint16(37485),
		40:  uint16(37486),
		41:  uint16(37487),
		42:  uint16(37488),
		43:  uint16(37489),
		44:  uint16(37490),
		45:  uint16(37491),
		46:  uint16(37493),
		47:  uint16(37494),
		48:  uint16(37495),
		49:  uint16(37496),
		50:  uint16(37497),
		51:  uint16(37498),
		52:  uint16(37499),
		53:  uint16(37500),
		54:  uint16(37501),
		55:  uint16(37502),
		56:  uint16(37503),
		57:  uint16(37504),
		58:  uint16(37505),
		59:  uint16(37506),
		60:  uint16(37507),
		61:  uint16(37508),
		62:  uint16(37509),
		63:  uint16(37510),
		64:  uint16(37511),
		65:  uint16(37512),
		66:  uint16(37513),
		67:  uint16(37514),
		68:  uint16(37515),
		69:  uint16(37516),
		70:  uint16(37517),
		71:  uint16(37519),
		72:  uint16(37520),
		73:  uint16(37521),
		74:  uint16(37522),
		75:  uint16(37523),
		76:  uint16(37524),
		77:  uint16(37525),
		78:  uint16(37526),
		79:  uint16(37527),
		80:  uint16(37528),
		81:  uint16(37529),
		82:  uint16(37530),
		83:  uint16(37531),
		84:  uint16(37532),
		85:  uint16(37533),
		86:  uint16(37534),
		87:  uint16(37535),
		88:  uint16(37536),
		89:  uint16(37537),
		90:  uint16(37538),
		91:  uint16(37539),
		92:  uint16(37540),
		93:  uint16(37541),
		94:  uint16(37542),
		95:  uint16(37543),
		96:  uint16(24682),
		97:  uint16(24701),
		98:  uint16(24726),
		99:  uint16(24730),
		100: uint16(24749),
		101: uint16(24733),
		102: uint16(24707),
		103: uint16(24722),
		104: uint16(24716),
		105: uint16(24731),
		106: uint16(24812),
		107: uint16(24763),
		108: uint16(24753),
		109: uint16(24797),
		110: uint16(24792),
		111: uint16(24774),
		112: uint16(24794),
		113: uint16(24756),
		114: uint16(24864),
		115: uint16(24870),
		116: uint16(24853),
		117: uint16(24867),
		118: uint16(24820),
		119: uint16(24832),
		120: uint16(24846),
		121: uint16(24875),
		122: uint16(24906),
		123: uint16(24949),
		124: uint16(25004),
		125: uint16(24980),
		126: uint16(24999),
		127: uint16(25015),
		128: uint16(25044),
		129: uint16(25077),
		130: uint16(24541),
		131: uint16(38579),
		132: uint16(38377),
		133: uint16(38379),
		134: uint16(38385),
		135: uint16(38387),
		136: uint16(38389),
		137: uint16(38390),
		138: uint16(38396),
		139: uint16(38398),
		140: uint16(38403),
		141: uint16(38404),
		142: uint16(38406),
		143: uint16(38408),
		144: uint16(38410),
		145: uint16(38411),
		146: uint16(38412),
		147: uint16(38413),
		148: uint16(38415),
		149: uint16(38418),
		150: uint16(38421),
		151: uint16(38422),
		152: uint16(38423),
		153: uint16(38425),
		154: uint16(38426),
		155: uint16(20012),
		156: uint16(29247),
		157: uint16(25109),
		158: uint16(27701),
		159: uint16(27732),
		160: uint16(27740),
		161: uint16(27722),
		162: uint16(27811),
		163: uint16(27781),
		164: uint16(27792),
		165: uint16(27796),
		166: uint16(27788),
		167: uint16(27752),
		168: uint16(27753),
		169: uint16(27764),
		170: uint16(27766),
		171: uint16(27782),
		172: uint16(27817),
		173: uint16(27856),
		174: uint16(27860),
		175: uint16(27821),
		176: uint16(27895),
		177: uint16(27896),
		178: uint16(27889),
		179: uint16(27863),
		180: uint16(27826),
		181: uint16(27872),
		182: uint16(27862),
		183: uint16(27898),
		184: uint16(27883),
		185: uint16(27886),
		186: uint16(27825),
		187: uint16(27859),
		188: uint16(27887),
		189: uint16(27902),
	},
	99: {
		0:   uint16(37544),
		1:   uint16(37545),
		2:   uint16(37546),
		3:   uint16(37547),
		4:   uint16(37548),
		5:   uint16(37549),
		6:   uint16(37551),
		7:   uint16(37552),
		8:   uint16(37553),
		9:   uint16(37554),
		10:  uint16(37555),
		11:  uint16(37556),
		12:  uint16(37557),
		13:  uint16(37558),
		14:  uint16(37559),
		15:  uint16(37560),
		16:  uint16(37561),
		17:  uint16(37562),
		18:  uint16(37563),
		19:  uint16(37564),
		20:  uint16(37565),
		21:  uint16(37566),
		22:  uint16(37567),
		23:  uint16(37568),
		24:  uint16(37569),
		25:  uint16(37570),
		26:  uint16(37571),
		27:  uint16(37572),
		28:  uint16(37573),
		29:  uint16(37574),
		30:  uint16(37575),
		31:  uint16(37577),
		32:  uint16(37578),
		33:  uint16(37579),
		34:  uint16(37580),
		35:  uint16(37581),
		36:  uint16(37582),
		37:  uint16(37583),
		38:  uint16(37584),
		39:  uint16(37585),
		40:  uint16(37586),
		41:  uint16(37587),
		42:  uint16(37588),
		43:  uint16(37589),
		44:  uint16(37590),
		45:  uint16(37591),
		46:  uint16(37592),
		47:  uint16(37593),
		48:  uint16(37594),
		49:  uint16(37595),
		50:  uint16(37596),
		51:  uint16(37597),
		52:  uint16(37598),
		53:  uint16(37599),
		54:  uint16(37600),
		55:  uint16(37601),
		56:  uint16(37602),
		57:  uint16(37603),
		58:  uint16(37604),
		59:  uint16(37605),
		60:  uint16(37606),
		61:  uint16(37607),
		62:  uint16(37608),
		63:  uint16(37609),
		64:  uint16(37610),
		65:  uint16(37611),
		66:  uint16(37612),
		67:  uint16(37613),
		68:  uint16(37614),
		69:  uint16(37615),
		70:  uint16(37616),
		71:  uint16(37617),
		72:  uint16(37618),
		73:  uint16(37619),
		74:  uint16(37620),
		75:  uint16(37621),
		76:  uint16(37622),
		77:  uint16(37623),
		78:  uint16(37624),
		79:  uint16(37625),
		80:  uint16(37626),
		81:  uint16(37627),
		82:  uint16(37628),
		83:  uint16(37629),
		84:  uint16(37630),
		85:  uint16(37631),
		86:  uint16(37632),
		87:  uint16(37633),
		88:  uint16(37634),
		89:  uint16(37635),
		90:  uint16(37636),
		91:  uint16(37637),
		92:  uint16(37638),
		93:  uint16(37639),
		94:  uint16(37640),
		95:  uint16(37641),
		96:  uint16(27961),
		97:  uint16(27943),
		98:  uint16(27916),
		99:  uint16(27971),
		100: uint16(27976),
		101: uint16(27911),
		102: uint16(27908),
		103: uint16(27929),
		104: uint16(27918),
		105: uint16(27947),
		106: uint16(27981),
		107: uint16(27950),
		108: uint16(27957),
		109: uint16(27930),
		110: uint16(27983),
		111: uint16(27986),
		112: uint16(27988),
		113: uint16(27955),
		114: uint16(28049),
		115: uint16(28015),
		116: uint16(28062),
		117: uint16(28064),
		118: uint16(27998),
		119: uint16(28051),
		120: uint16(28052),
		121: uint16(27996),
		122: uint16(28000),
		123: uint16(28028),
		124: uint16(28003),
		125: uint16(28186),
		126: uint16(28103),
		127: uint16(28101),
		128: uint16(28126),
		129: uint16(28174),
		130: uint16(28095),
		131: uint16(28128),
		132: uint16(28177),
		133: uint16(28134),
		134: uint16(28125),
		135: uint16(28121),
		136: uint16(28182),
		137: uint16(28075),
		138: uint16(28172),
		139: uint16(28078),
		140: uint16(28203),
		141: uint16(28270),
		142: uint16(28238),
		143: uint16(28267),
		144: uint16(28338),
		145: uint16(28255),
		146: uint16(28294),
		147: uint16(28243),
		148: uint16(28244),
		149: uint16(28210),
		150: uint16(28197),
		151: uint16(28228),
		152: uint16(28383),
		153: uint16(28337),
		154: uint16(28312),
		155: uint16(28384),
		156: uint16(28461),
		157: uint16(28386),
		158: uint16(28325),
		159: uint16(28327),
		160: uint16(28349),
		161: uint16(28347),
		162: uint16(28343),
		163: uint16(28375),
		164: uint16(28340),
		165: uint16(28367),
		166: uint16(28303),
		167: uint16(28354),
		168: uint16(28319),
		169: uint16(28514),
		170: uint16(28486),
		171: uint16(28487),
		172: uint16(28452),
		173: uint16(28437),
		174: uint16(28409),
		175: uint16(28463),
		176: uint16(28470),
		177: uint16(28491),
		178: uint16(28532),
		179: uint16(28458),
		180: uint16(28425),
		181: uint16(28457),
		182: uint16(28553),
		183: uint16(28557),
		184: uint16(28556),
		185: uint16(28536),
		186: uint16(28530),
		187: uint16(28540),
		188: uint16(28538),
		189: uint16(28625),
	},
	100: {
		0:   uint16(37642),
		1:   uint16(37643),
		2:   uint16(37644),
		3:   uint16(37645),
		4:   uint16(37646),
		5:   uint16(37647),
		6:   uint16(37648),
		7:   uint16(37649),
		8:   uint16(37650),
		9:   uint16(37651),
		10:  uint16(37652),
		11:  uint16(37653),
		12:  uint16(37654),
		13:  uint16(37655),
		14:  uint16(37656),
		15:  uint16(37657),
		16:  uint16(37658),
		17:  uint16(37659),
		18:  uint16(37660),
		19:  uint16(37661),
		20:  uint16(37662),
		21:  uint16(37663),
		22:  uint16(37664),
		23:  uint16(37665),
		24:  uint16(37666),
		25:  uint16(37667),
		26:  uint16(37668),
		27:  uint16(37669),
		28:  uint16(37670),
		29:  uint16(37671),
		30:  uint16(37672),
		31:  uint16(37673),
		32:  uint16(37674),
		33:  uint16(37675),
		34:  uint16(37676),
		35:  uint16(37677),
		36:  uint16(37678),
		37:  uint16(37679),
		38:  uint16(37680),
		39:  uint16(37681),
		40:  uint16(37682),
		41:  uint16(37683),
		42:  uint16(37684),
		43:  uint16(37685),
		44:  uint16(37686),
		45:  uint16(37687),
		46:  uint16(37688),
		47:  uint16(37689),
		48:  uint16(37690),
		49:  uint16(37691),
		50:  uint16(37692),
		51:  uint16(37693),
		52:  uint16(37695),
		53:  uint16(37696),
		54:  uint16(37697),
		55:  uint16(37698),
		56:  uint16(37699),
		57:  uint16(37700),
		58:  uint16(37701),
		59:  uint16(37702),
		60:  uint16(37703),
		61:  uint16(37704),
		62:  uint16(37705),
		63:  uint16(37706),
		64:  uint16(37707),
		65:  uint16(37708),
		66:  uint16(37709),
		67:  uint16(37710),
		68:  uint16(37711),
		69:  uint16(37712),
		70:  uint16(37713),
		71:  uint16(37714),
		72:  uint16(37715),
		73:  uint16(37716),
		74:  uint16(37717),
		75:  uint16(37718),
		76:  uint16(37719),
		77:  uint16(37720),
		78:  uint16(37721),
		79:  uint16(37722),
		80:  uint16(37723),
		81:  uint16(37724),
		82:  uint16(37725),
		83:  uint16(37726),
		84:  uint16(37727),
		85:  uint16(37728),
		86:  uint16(37729),
		87:  uint16(37730),
		88:  uint16(37731),
		89:  uint16(37732),
		90:  uint16(37733),
		91:  uint16(37734),
		92:  uint16(37735),
		93:  uint16(37736),
		94:  uint16(37737),
		95:  uint16(37739),
		96:  uint16(28617),
		97:  uint16(28583),
		98:  uint16(28601),
		99:  uint16(28598),
		100: uint16(28610),
		101: uint16(28641),
		102: uint16(28654),
		103: uint16(28638),
		104: uint16(28640),
		105: uint16(28655),
		106: uint16(28698),
		107: uint16(28707),
		108: uint16(28699),
		109: uint16(28729),
		110: uint16(28725),
		111: uint16(28751),
		112: uint16(28766),
		113: uint16(23424),
		114: uint16(23428),
		115: uint16(23445),
		116: uint16(23443),
		117: uint16(23461),
		118: uint16(23480),
		119: uint16(29999),
		120: uint16(39582),
		121: uint16(25652),
		122: uint16(23524),
		123: uint16(23534),
		124: uint16(35120),
		125: uint16(23536),
		126: uint16(36423),
		127: uint16(35591),
		128: uint16(36790),
		129: uint16(36819),
		130: uint16(36821),
		131: uint16(36837),
		132: uint16(36846),
		133: uint16(36836),
		134: uint16(36841),
		135: uint16(36838),
		136: uint16(36851),
		137: uint16(36840),
		138: uint16(36869),
		139: uint16(36868),
		140: uint16(36875),
		141: uint16(36902),
		142: uint16(36881),
		143: uint16(36877),
		144: uint16(36886),
		145: uint16(36897),
		146: uint16(36917),
		147: uint16(36918),
		148: uint16(36909),
		149: uint16(36911),
		150: uint16(36932),
		151: uint16(36945),
		152: uint16(36946),
		153: uint16(36944),
		154: uint16(36968),
		155: uint16(36952),
		156: uint16(36962),
		157: uint16(36955),
		158: uint16(26297),
		159: uint16(36980),
		160: uint16(36989),
		161: uint16(36994),
		162: uint16(37000),
		163: uint16(36995),
		164: uint16(37003),
		165: uint16(24400),
		166: uint16(24407),
		167: uint16(24406),
		168: uint16(24408),
		169: uint16(23611),
		170: uint16(21675),
		171: uint16(23632),
		172: uint16(23641),
		173: uint16(23409),
		174: uint16(23651),
		175: uint16(23654),
		176: uint16(32700),
		177: uint16(24362),
		178: uint16(24361),
		179: uint16(24365),
		180: uint16(33396),
		181: uint16(24380),
		182: uint16(39739),
		183: uint16(23662),
		184: uint16(22913),
		185: uint16(22915),
		186: uint16(22925),
		187: uint16(22953),
		188: uint16(22954),
		189: uint16(22947),
	},
	101: {
		0:   uint16(37740),
		1:   uint16(37741),
		2:   uint16(37742),
		3:   uint16(37743),
		4:   uint16(37744),
		5:   uint16(37745),
		6:   uint16(37746),
		7:   uint16(37747),
		8:   uint16(37748),
		9:   uint16(37749),
		10:  uint16(37750),
		11:  uint16(37751),
		12:  uint16(37752),
		13:  uint16(37753),
		14:  uint16(37754),
		15:  uint16(37755),
		16:  uint16(37756),
		17:  uint16(37757),
		18:  uint16(37758),
		19:  uint16(37759),
		20:  uint16(37760),
		21:  uint16(37761),
		22:  uint16(37762),
		23:  uint16(37763),
		24:  uint16(37764),
		25:  uint16(37765),
		26:  uint16(37766),
		27:  uint16(37767),
		28:  uint16(37768),
		29:  uint16(37769),
		30:  uint16(37770),
		31:  uint16(37771),
		32:  uint16(37772),
		33:  uint16(37773),
		34:  uint16(37774),
		35:  uint16(37776),
		36:  uint16(37777),
		37:  uint16(37778),
		38:  uint16(37779),
		39:  uint16(37780),
		40:  uint16(37781),
		41:  uint16(37782),
		42:  uint16(37783),
		43:  uint16(37784),
		44:  uint16(37785),
		45:  uint16(37786),
		46:  uint16(37787),
		47:  uint16(37788),
		48:  uint16(37789),
		49:  uint16(37790),
		50:  uint16(37791),
		51:  uint16(37792),
		52:  uint16(37793),
		53:  uint16(37794),
		54:  uint16(37795),
		55:  uint16(37796),
		56:  uint16(37797),
		57:  uint16(37798),
		58:  uint16(37799),
		59:  uint16(37800),
		60:  uint16(37801),
		61:  uint16(37802),
		62:  uint16(37803),
		63:  uint16(37804),
		64:  uint16(37805),
		65:  uint16(37806),
		66:  uint16(37807),
		67:  uint16(37808),
		68:  uint16(37809),
		69:  uint16(37810),
		70:  uint16(37811),
		71:  uint16(37812),
		72:  uint16(37813),
		73:  uint16(37814),
		74:  uint16(37815),
		75:  uint16(37816),
		76:  uint16(37817),
		77:  uint16(37818),
		78:  uint16(37819),
		79:  uint16(37820),
		80:  uint16(37821),
		81:  uint16(37822),
		82:  uint16(37823),
		83:  uint16(37824),
		84:  uint16(37825),
		85:  uint16(37826),
		86:  uint16(37827),
		87:  uint16(37828),
		88:  uint16(37829),
		89:  uint16(37830),
		90:  uint16(37831),
		91:  uint16(37832),
		92:  uint16(37833),
		93:  uint16(37835),
		94:  uint16(37836),
		95:  uint16(37837),
		96:  uint16(22935),
		97:  uint16(22986),
		98:  uint16(22955),
		99:  uint16(22942),
		100: uint16(22948),
		101: uint16(22994),
		102: uint16(22962),
		103: uint16(22959),
		104: uint16(22999),
		105: uint16(22974),
		106: uint16(23045),
		107: uint16(23046),
		108: uint16(23005),
		109: uint16(23048),
		110: uint16(23011),
		111: uint16(23000),
		112: uint16(23033),
		113: uint16(23052),
		114: uint16(23049),
		115: uint16(23090),
		116: uint16(23092),
		117: uint16(23057),
		118: uint16(23075),
		119: uint16(23059),
		120: uint16(23104),
		121: uint16(23143),
		122: uint16(23114),
		123: uint16(23125),
		124: uint16(23100),
		125: uint16(23138),
		126: uint16(23157),
		127: uint16(33004),
		128: uint16(23210),
		129: uint16(23195),
		130: uint16(23159),
		131: uint16(23162),
		132: uint16(23230),
		133: uint16(23275),
		134: uint16(23218),
		135: uint16(23250),
		136: uint16(23252),
		137: uint16(23224),
		138: uint16(23264),
		139: uint16(23267),
		140: uint16(23281),
		141: uint16(23254),
		142: uint16(23270),
		143: uint16(23256),
		144: uint16(23260),
		145: uint16(23305),
		146: uint16(23319),
		147: uint16(23318),
		148: uint16(23346),
		149: uint16(23351),
		150: uint16(23360),
		151: uint16(23573),
		152: uint16(23580),
		153: uint16(23386),
		154: uint16(23397),
		155: uint16(23411),
		156: uint16(23377),
		157: uint16(23379),
		158: uint16(23394),
		159: uint16(39541),
		160: uint16(39543),
		161: uint16(39544),
		162: uint16(39546),
		163: uint16(39551),
		164: uint16(39549),
		165: uint16(39552),
		166: uint16(39553),
		167: uint16(39557),
		168: uint16(39560),
		169: uint16(39562),
		170: uint16(39568),
		171: uint16(39570),
		172: uint16(39571),
		173: uint16(39574),
		174: uint16(39576),
		175: uint16(39579),
		176: uint16(39580),
		177: uint16(39581),
		178: uint16(39583),
		179: uint16(39584),
		180: uint16(39586),
		181: uint16(39587),
		182: uint16(39589),
		183: uint16(39591),
		184: uint16(32415),
		185: uint16(32417),
		186: uint16(32419),
		187: uint16(32421),
		188: uint16(32424),
		189: uint16(32425),
	},
	102: {
		0:   uint16(37838),
		1:   uint16(37839),
		2:   uint16(37840),
		3:   uint16(37841),
		4:   uint16(37842),
		5:   uint16(37843),
		6:   uint16(37844),
		7:   uint16(37845),
		8:   uint16(37847),
		9:   uint16(37848),
		10:  uint16(37849),
		11:  uint16(37850),
		12:  uint16(37851),
		13:  uint16(37852),
		14:  uint16(37853),
		15:  uint16(37854),
		16:  uint16(37855),
		17:  uint16(37856),
		18:  uint16(37857),
		19:  uint16(37858),
		20:  uint16(37859),
		21:  uint16(37860),
		22:  uint16(37861),
		23:  uint16(37862),
		24:  uint16(37863),
		25:  uint16(37864),
		26:  uint16(37865),
		27:  uint16(37866),
		28:  uint16(37867),
		29:  uint16(37868),
		30:  uint16(37869),
		31:  uint16(37870),
		32:  uint16(37871),
		33:  uint16(37872),
		34:  uint16(37873),
		35:  uint16(37874),
		36:  uint16(37875),
		37:  uint16(37876),
		38:  uint16(37877),
		39:  uint16(37878),
		40:  uint16(37879),
		41:  uint16(37880),
		42:  uint16(37881),
		43:  uint16(37882),
		44:  uint16(37883),
		45:  uint16(37884),
		46:  uint16(37885),
		47:  uint16(37886),
		48:  uint16(37887),
		49:  uint16(37888),
		50:  uint16(37889),
		51:  uint16(37890),
		52:  uint16(37891),
		53:  uint16(37892),
		54:  uint16(37893),
		55:  uint16(37894),
		56:  uint16(37895),
		57:  uint16(37896),
		58:  uint16(37897),
		59:  uint16(37898),
		60:  uint16(37899),
		61:  uint16(37900),
		62:  uint16(37901),
		63:  uint16(37902),
		64:  uint16(37903),
		65:  uint16(37904),
		66:  uint16(37905),
		67:  uint16(37906),
		68:  uint16(37907),
		69:  uint16(37908),
		70:  uint16(37909),
		71:  uint16(37910),
		72:  uint16(37911),
		73:  uint16(37912),
		74:  uint16(37913),
		75:  uint16(37914),
		76:  uint16(37915),
		77:  uint16(37916),
		78:  uint16(37917),
		79:  uint16(37918),
		80:  uint16(37919),
		81:  uint16(37920),
		82:  uint16(37921),
		83:  uint16(37922),
		84:  uint16(37923),
		85:  uint16(37924),
		86:  uint16(37925),
		87:  uint16(37926),
		88:  uint16(37927),
		89:  uint16(37928),
		90:  uint16(37929),
		91:  uint16(37930),
		92:  uint16(37931),
		93:  uint16(37932),
		94:  uint16(37933),
		95:  uint16(37934),
		96:  uint16(32429),
		97:  uint16(32432),
		98:  uint16(32446),
		99:  uint16(32448),
		100: uint16(32449),
		101: uint16(32450),
		102: uint16(32457),
		103: uint16(32459),
		104: uint16(32460),
		105: uint16(32464),
		106: uint16(32468),
		107: uint16(32471),
		108: uint16(32475),
		109: uint16(32480),
		110: uint16(32481),
		111: uint16(32488),
		112: uint16(32491),
		113: uint16(32494),
		114: uint16(32495),
		115: uint16(32497),
		116: uint16(32498),
		117: uint16(32525),
		118: uint16(32502),
		119: uint16(32506),
		120: uint16(32507),
		121: uint16(32510),
		122: uint16(32513),
		123: uint16(32514),
		124: uint16(32515),
		125: uint16(32519),
		126: uint16(32520),
		127: uint16(32523),
		128: uint16(32524),
		129: uint16(32527),
		130: uint16(32529),
		131: uint16(32530),
		132: uint16(32535),
		133: uint16(32537),
		134: uint16(32540),
		135: uint16(32539),
		136: uint16(32543),
		137: uint16(32545),
		138: uint16(32546),
		139: uint16(32547),
		140: uint16(32548),
		141: uint16(32549),
		142: uint16(32550),
		143: uint16(32551),
		144: uint16(32554),
		145: uint16(32555),
		146: uint16(32556),
		147: uint16(32557),
		148: uint16(32559),
		149: uint16(32560),
		150: uint16(32561),
		151: uint16(32562),
		152: uint16(32563),
		153: uint16(32565),
		154: uint16(24186),
		155: uint16(30079),
		156: uint16(24027),
		157: uint16(30014),
		158: uint16(37013),
		159: uint16(29582),
		160: uint16(29585),
		161: uint16(29614),
		162: uint16(29602),
		163: uint16(29599),
		164: uint16(29647),
		165: uint16(29634),
		166: uint16(29649),
		167: uint16(29623),
		168: uint16(29619),
		169: uint16(29632),
		170: uint16(29641),
		171: uint16(29640),
		172: uint16(29669),
		173: uint16(29657),
		174: uint16(39036),
		175: uint16(29706),
		176: uint16(29673),
		177: uint16(29671),
		178: uint16(29662),
		179: uint16(29626),
		180: uint16(29682),
		181: uint16(29711),
		182: uint16(29738),
		183: uint16(29787),
		184: uint16(29734),
		185: uint16(29733),
		186: uint16(29736),
		187: uint16(29744),
		188: uint16(29742),
		189: uint16(29740),
	},
	103: {
		0:   uint16(37935),
		1:   uint16(37936),
		2:   uint16(37937),
		3:   uint16(37938),
		4:   uint16(37939),
		5:   uint16(37940),
		6:   uint16(37941),
		7:   uint16(37942),
		8:   uint16(37943),
		9:   uint16(37944),
		10:  uint16(37945),
		11:  uint16(37946),
		12:  uint16(37947),
		13:  uint16(37948),
		14:  uint16(37949),
		15:  uint16(37951),
		16:  uint16(37952),
		17:  uint16(37953),
		18:  uint16(37954),
		19:  uint16(37955),
		20:  uint16(37956),
		21:  uint16(37957),
		22:  uint16(37958),
		23:  uint16(37959),
		24:  uint16(37960),
		25:  uint16(37961),
		26:  uint16(37962),
		27:  uint16(37963),
		28:  uint16(37964),
		29:  uint16(37965),
		30:  uint16(37966),
		31:  uint16(37967),
		32:  uint16(37968),
		33:  uint16(37969),
		34:  uint16(37970),
		35:  uint16(37971),
		36:  uint16(37972),
		37:  uint16(37973),
		38:  uint16(37974),
		39:  uint16(37975),
		40:  uint16(37976),
		41:  uint16(37977),
		42:  uint16(37978),
		43:  uint16(37979),
		44:  uint16(37980),
		45:  uint16(37981),
		46:  uint16(37982),
		47:  uint16(37983),
		48:  uint16(37984),
		49:  uint16(37985),
		50:  uint16(37986),
		51:  uint16(37987),
		52:  uint16(37988),
		53:  uint16(37989),
		54:  uint16(37990),
		55:  uint16(37991),
		56:  uint16(37992),
		57:  uint16(37993),
		58:  uint16(37994),
		59:  uint16(37996),
		60:  uint16(37997),
		61:  uint16(37998),
		62:  uint16(37999),
		63:  uint16(38000),
		64:  uint16(38001),
		65:  uint16(38002),
		66:  uint16(38003),
		67:  uint16(38004),
		68:  uint16(38005),
		69:  uint16(38006),
		70:  uint16(38007),
		71:  uint16(38008),
		72:  uint16(38009),
		73:  uint16(38010),
		74:  uint16(38011),
		75:  uint16(38012),
		76:  uint16(38013),
		77:  uint16(38014),
		78:  uint16(38015),
		79:  uint16(38016),
		80:  uint16(38017),
		81:  uint16(38018),
		82:  uint16(38019),
		83:  uint16(38020),
		84:  uint16(38033),
		85:  uint16(38038),
		86:  uint16(38040),
		87:  uint16(38087),
		88:  uint16(38095),
		89:  uint16(38099),
		90:  uint16(38100),
		91:  uint16(38106),
		92:  uint16(38118),
		93:  uint16(38139),
		94:  uint16(38172),
		95:  uint16(38176),
		96:  uint16(29723),
		97:  uint16(29722),
		98:  uint16(29761),
		99:  uint16(29788),
		100: uint16(29783),
		101: uint16(29781),
		102: uint16(29785),
		103: uint16(29815),
		104: uint16(29805),
		105: uint16(29822),
		106: uint16(29852),
		107: uint16(29838),
		108: uint16(29824),
		109: uint16(29825),
		110: uint16(29831),
		111: uint16(29835),
		112: uint16(29854),
		113: uint16(29864),
		114: uint16(29865),
		115: uint16(29840),
		116: uint16(29863),
		117: uint16(29906),
		118: uint16(29882),
		119: uint16(38890),
		120: uint16(38891),
		121: uint16(38892),
		122: uint16(26444),
		123: uint16(26451),
		124: uint16(26462),
		125: uint16(26440),
		126: uint16(26473),
		127: uint16(26533),
		128: uint16(26503),
		129: uint16(26474),
		130: uint16(26483),
		131: uint16(26520),
		132: uint16(26535),
		133: uint16(26485),
		134: uint16(26536),
		135: uint16(26526),
		136: uint16(26541),
		137: uint16(26507),
		138: uint16(26487),
		139: uint16(26492),
		140: uint16(26608),
		141: uint16(26633),
		142: uint16(26584),
		143: uint16(26634),
		144: uint16(26601),
		145: uint16(26544),
		146: uint16(26636),
		147: uint16(26585),
		148: uint16(26549),
		149: uint16(26586),
		150: uint16(26547),
		151: uint16(26589),
		152: uint16(26624),
		153: uint16(26563),
		154: uint16(26552),
		155: uint16(26594),
		156: uint16(26638),
		157: uint16(26561),
		158: uint16(26621),
		159: uint16(26674),
		160: uint16(26675),
		161: uint16(26720),
		162: uint16(26721),
		163: uint16(26702),
		164: uint16(26722),
		165: uint16(26692),
		166: uint16(26724),
		167: uint16(26755),
		168: uint16(26653),
		169: uint16(26709),
		170: uint16(26726),
		171: uint16(26689),
		172: uint16(26727),
		173: uint16(26688),
		174: uint16(26686),
		175: uint16(26698),
		176: uint16(26697),
		177: uint16(26665),
		178: uint16(26805),
		179: uint16(26767),
		180: uint16(26740),
		181: uint16(26743),
		182: uint16(26771),
		183: uint16(26731),
		184: uint16(26818),
		185: uint16(26990),
		186: uint16(26876),
		187: uint16(26911),
		188: uint16(26912),
		189: uint16(26873),
	},
	104: {
		0:   uint16(38183),
		1:   uint16(38195),
		2:   uint16(38205),
		3:   uint16(38211),
		4:   uint16(38216),
		5:   uint16(38219),
		6:   uint16(38229),
		7:   uint16(38234),
		8:   uint16(38240),
		9:   uint16(38254),
		10:  uint16(38260),
		11:  uint16(38261),
		12:  uint16(38263),
		13:  uint16(38264),
		14:  uint16(38265),
		15:  uint16(38266),
		16:  uint16(38267),
		17:  uint16(38268),
		18:  uint16(38269),
		19:  uint16(38270),
		20:  uint16(38272),
		21:  uint16(38273),
		22:  uint16(38274),
		23:  uint16(38275),
		24:  uint16(38276),
		25:  uint16(38277),
		26:  uint16(38278),
		27:  uint16(38279),
		28:  uint16(38280),
		29:  uint16(38281),
		30:  uint16(38282),
		31:  uint16(38283),
		32:  uint16(38284),
		33:  uint16(38285),
		34:  uint16(38286),
		35:  uint16(38287),
		36:  uint16(38288),
		37:  uint16(38289),
		38:  uint16(38290),
		39:  uint16(38291),
		40:  uint16(38292),
		41:  uint16(38293),
		42:  uint16(38294),
		43:  uint16(38295),
		44:  uint16(38296),
		45:  uint16(38297),
		46:  uint16(38298),
		47:  uint16(38299),
		48:  uint16(38300),
		49:  uint16(38301),
		50:  uint16(38302),
		51:  uint16(38303),
		52:  uint16(38304),
		53:  uint16(38305),
		54:  uint16(38306),
		55:  uint16(38307),
		56:  uint16(38308),
		57:  uint16(38309),
		58:  uint16(38310),
		59:  uint16(38311),
		60:  uint16(38312),
		61:  uint16(38313),
		62:  uint16(38314),
		63:  uint16(38315),
		64:  uint16(38316),
		65:  uint16(38317),
		66:  uint16(38318),
		67:  uint16(38319),
		68:  uint16(38320),
		69:  uint16(38321),
		70:  uint16(38322),
		71:  uint16(38323),
		72:  uint16(38324),
		73:  uint16(38325),
		74:  uint16(38326),
		75:  uint16(38327),
		76:  uint16(38328),
		77:  uint16(38329),
		78:  uint16(38330),
		79:  uint16(38331),
		80:  uint16(38332),
		81:  uint16(38333),
		82:  uint16(38334),
		83:  uint16(38335),
		84:  uint16(38336),
		85:  uint16(38337),
		86:  uint16(38338),
		87:  uint16(38339),
		88:  uint16(38340),
		89:  uint16(38341),
		90:  uint16(38342),
		91:  uint16(38343),
		92:  uint16(38344),
		93:  uint16(38345),
		94:  uint16(38346),
		95:  uint16(38347),
		96:  uint16(26916),
		97:  uint16(26864),
		98:  uint16(26891),
		99:  uint16(26881),
		100: uint16(26967),
		101: uint16(26851),
		102: uint16(26896),
		103: uint16(26993),
		104: uint16(26937),
		105: uint16(26976),
		106: uint16(26946),
		107: uint16(26973),
		108: uint16(27012),
		109: uint16(26987),
		110: uint16(27008),
		111: uint16(27032),
		112: uint16(27000),
		113: uint16(26932),
		114: uint16(27084),
		115: uint16(27015),
		116: uint16(27016),
		117: uint16(27086),
		118: uint16(27017),
		119: uint16(26982),
		120: uint16(26979),
		121: uint16(27001),
		122: uint16(27035),
		123: uint16(27047),
		124: uint16(27067),
		125: uint16(27051),
		126: uint16(27053),
		127: uint16(27092),
		128: uint16(27057),
		129: uint16(27073),
		130: uint16(27082),
		131: uint16(27103),
		132: uint16(27029),
		133: uint16(27104),
		134: uint16(27021),
		135: uint16(27135),
		136: uint16(27183),
		137: uint16(27117),
		138: uint16(27159),
		139: uint16(27160),
		140: uint16(27237),
		141: uint16(27122),
		142: uint16(27204),
		143: uint16(27198),
		144: uint16(27296),
		145: uint16(27216),
		146: uint16(27227),
		147: uint16(27189),
		148: uint16(27278),
		149: uint16(27257),
		150: uint16(27197),
		151: uint16(27176),
		152: uint16(27224),
		153: uint16(27260),
		154: uint16(27281),
		155: uint16(27280),
		156: uint16(27305),
		157: uint16(27287),
		158: uint16(27307),
		159: uint16(29495),
		160: uint16(29522),
		161: uint16(27521),
		162: uint16(27522),
		163: uint16(27527),
		164: uint16(27524),
		165: uint16(27538),
		166: uint16(27539),
		167: uint16(27533),
		168: uint16(27546),
		169: uint16(27547),
		170: uint16(27553),
		171: uint16(27562),
		172: uint16(36715),
		173: uint16(36717),
		174: uint16(36721),
		175: uint16(36722),
		176: uint16(36723),
		177: uint16(36725),
		178: uint16(36726),
		179: uint16(36728),
		180: uint16(36727),
		181: uint16(36729),
		182: uint16(36730),
		183: uint16(36732),
		184: uint16(36734),
		185: uint16(36737),
		186: uint16(36738),
		187: uint16(36740),
		188: uint16(36743),
		189: uint16(36747),
	},
	105: {
		0:   uint16(38348),
		1:   uint16(38349),
		2:   uint16(38350),
		3:   uint16(38351),
		4:   uint16(38352),
		5:   uint16(38353),
		6:   uint16(38354),
		7:   uint16(38355),
		8:   uint16(38356),
		9:   uint16(38357),
		10:  uint16(38358),
		11:  uint16(38359),
		12:  uint16(38360),
		13:  uint16(38361),
		14:  uint16(38362),
		15:  uint16(38363),
		16:  uint16(38364),
		17:  uint16(38365),
		18:  uint16(38366),
		19:  uint16(38367),
		20:  uint16(38368),
		21:  uint16(38369),
		22:  uint16(38370),
		23:  uint16(38371),
		24:  uint16(38372),
		25:  uint16(38373),
		26:  uint16(38374),
		27:  uint16(38375),
		28:  uint16(38380),
		29:  uint16(38399),
		30:  uint16(38407),
		31:  uint16(38419),
		32:  uint16(38424),
		33:  uint16(38427),
		34:  uint16(38430),
		35:  uint16(38432),
		36:  uint16(38435),
		37:  uint16(38436),
		38:  uint16(38437),
		39:  uint16(38438),
		40:  uint16(38439),
		41:  uint16(38440),
		42:  uint16(38441),
		43:  uint16(38443),
		44:  uint16(38444),
		45:  uint16(38445),
		46:  uint16(38447),
		47:  uint16(38448),
		48:  uint16(38455),
		49:  uint16(38456),
		50:  uint16(38457),
		51:  uint16(38458),
		52:  uint16(38462),
		53:  uint16(38465),
		54:  uint16(38467),
		55:  uint16(38474),
		56:  uint16(38478),
		57:  uint16(38479),
		58:  uint16(38481),
		59:  uint16(38482),
		60:  uint16(38483),
		61:  uint16(38486),
		62:  uint16(38487),
		63:  uint16(38488),
		64:  uint16(38489),
		65:  uint16(38490),
		66:  uint16(38492),
		67:  uint16(38493),
		68:  uint16(38494),
		69:  uint16(38496),
		70:  uint16(38499),
		71:  uint16(38501),
		72:  uint16(38502),
		73:  uint16(38507),
		74:  uint16(38509),
		75:  uint16(38510),
		76:  uint16(38511),
		77:  uint16(38512),
		78:  uint16(38513),
		79:  uint16(38515),
		80:  uint16(38520),
		81:  uint16(38521),
		82:  uint16(38522),
		83:  uint16(38523),
		84:  uint16(38524),
		85:  uint16(38525),
		86:  uint16(38526),
		87:  uint16(38527),
		88:  uint16(38528),
		89:  uint16(38529),
		90:  uint16(38530),
		91:  uint16(38531),
		92:  uint16(38532),
		93:  uint16(38535),
		94:  uint16(38537),
		95:  uint16(38538),
		96:  uint16(36749),
		97:  uint16(36750),
		98:  uint16(36751),
		99:  uint16(36760),
		100: uint16(36762),
		101: uint16(36558),
		102: uint16(25099),
		103: uint16(25111),
		104: uint16(25115),
		105: uint16(25119),
		106: uint16(25122),
		107: uint16(25121),
		108: uint16(25125),
		109: uint16(25124),
		110: uint16(25132),
		111: uint16(33255),
		112: uint16(29935),
		113: uint16(29940),
		114: uint16(29951),
		115: uint16(29967),
		116: uint16(29969),
		117: uint16(29971),
		118: uint16(25908),
		119: uint16(26094),
		120: uint16(26095),
		121: uint16(26096),
		122: uint16(26122),
		123: uint16(26137),
		124: uint16(26482),
		125: uint16(26115),
		126: uint16(26133),
		127: uint16(26112),
		128: uint16(28805),
		129: uint16(26359),
		130: uint16(26141),
		131: uint16(26164),
		132: uint16(26161),
		133: uint16(26166),
		134: uint16(26165),
		135: uint16(32774),
		136: uint16(26207),
		137: uint16(26196),
		138: uint16(26177),
		139: uint16(26191),
		140: uint16(26198),
		141: uint16(26209),
		142: uint16(26199),
		143: uint16(26231),
		144: uint16(26244),
		145: uint16(26252),
		146: uint16(26279),
		147: uint16(26269),
		148: uint16(26302),
		149: uint16(26331),
		150: uint16(26332),
		151: uint16(26342),
		152: uint16(26345),
		153: uint16(36146),
		154: uint16(36147),
		155: uint16(36150),
		156: uint16(36155),
		157: uint16(36157),
		158: uint16(36160),
		159: uint16(36165),
		160: uint16(36166),
		161: uint16(36168),
		162: uint16(36169),
		163: uint16(36167),
		164: uint16(36173),
		165: uint16(36181),
		166: uint16(36185),
		167: uint16(35271),
		168: uint16(35274),
		169: uint16(35275),
		170: uint16(35276),
		171: uint16(35278),
		172: uint16(35279),
		173: uint16(35280),
		174: uint16(35281),
		175: uint16(29294),
		176: uint16(29343),
		177: uint16(29277),
		178: uint16(29286),
		179: uint16(29295),
		180: uint16(29310),
		181: uint16(29311),
		182: uint16(29316),
		183: uint16(29323),
		184: uint16(29325),
		185: uint16(29327),
		186: uint16(29330),
		187: uint16(25352),
		188: uint16(25394),
		189: uint16(25520),
	},
	106: {
		0:   uint16(38540),
		1:   uint16(38542),
		2:   uint16(38545),
		3:   uint16(38546),
		4:   uint16(38547),
		5:   uint16(38549),
		6:   uint16(38550),
		7:   uint16(38554),
		8:   uint16(38555),
		9:   uint16(38557),
		10:  uint16(38558),
		11:  uint16(38559),
		12:  uint16(38560),
		13:  uint16(38561),
		14:  uint16(38562),
		15:  uint16(38563),
		16:  uint16(38564),
		17:  uint16(38565),
		18:  uint16(38566),
		19:  uint16(38568),
		20:  uint16(38569),
		21:  uint16(38570),
		22:  uint16(38571),
		23:  uint16(38572),
		24:  uint16(38573),
		25:  uint16(38574),
		26:  uint16(38575),
		27:  uint16(38577),
		28:  uint16(38578),
		29:  uint16(38580),
		30:  uint16(38581),
		31:  uint16(38583),
		32:  uint16(38584),
		33:  uint16(38586),
		34:  uint16(38587),
		35:  uint16(38591),
		36:  uint16(38594),
		37:  uint16(38595),
		38:  uint16(38600),
		39:  uint16(38602),
		40:  uint16(38603),
		41:  uint16(38608),
		42:  uint16(38609),
		43:  uint16(38611),
		44:  uint16(38612),
		45:  uint16(38614),
		46:  uint16(38615),
		47:  uint16(38616),
		48:  uint16(38617),
		49:  uint16(38618),
		50:  uint16(38619),
		51:  uint16(38620),
		52:  uint16(38621),
		53:  uint16(38622),
		54:  uint16(38623),
		55:  uint16(38625),
		56:  uint16(38626),
		57:  uint16(38627),
		58:  uint16(38628),
		59:  uint16(38629),
		60:  uint16(38630),
		61:  uint16(38631),
		62:  uint16(38635),
		63:  uint16(38636),
		64:  uint16(38637),
		65:  uint16(38638),
		66:  uint16(38640),
		67:  uint16(38641),
		68:  uint16(38642),
		69:  uint16(38644),
		70:  uint16(38645),
		71:  uint16(38648),
		72:  uint16(38650),
		73:  uint16(38651),
		74:  uint16(38652),
		75:  uint16(38653),
		76:  uint16(38655),
		77:  uint16(38658),
		78:  uint16(38659),
		79:  uint16(38661),
		80:  uint16(38666),
		81:  uint16(38667),
		82:  uint16(38668),
		83:  uint16(38672),
		84:  uint16(38673),
		85:  uint16(38674),
		86:  uint16(38676),
		87:  uint16(38677),
		88:  uint16(38679),
		89:  uint16(38680),
		90:  uint16(38681),
		91:  uint16(38682),
		92:  uint16(38683),
		93:  uint16(38685),
		94:  uint16(38687),
		95:  uint16(38688),
		96:  uint16(25663),
		97:  uint16(25816),
		98:  uint16(32772),
		99:  uint16(27626),
		100: uint16(27635),
		101: uint16(27645),
		102: uint16(27637),
		103: uint16(27641),
		104: uint16(27653),
		105: uint16(27655),
		106: uint16(27654),
		107: uint16(27661),
		108: uint16(27669),
		109: uint16(27672),
		110: uint16(27673),
		111: uint16(27674),
		112: uint16(27681),
		113: uint16(27689),
		114: uint16(27684),
		115: uint16(27690),
		116: uint16(27698),
		117: uint16(25909),
		118: uint16(25941),
		119: uint16(25963),
		120: uint16(29261),
		121: uint16(29266),
		122: uint16(29270),
		123: uint16(29232),
		124: uint16(34402),
		125: uint16(21014),
		126: uint16(32927),
		127: uint16(32924),
		128: uint16(32915),
		129: uint16(32956),
		130: uint16(26378),
		131: uint16(32957),
		132: uint16(32945),
		133: uint16(32939),
		134: uint16(32941),
		135: uint16(32948),
		136: uint16(32951),
		137: uint16(32999),
		138: uint16(33000),
		139: uint16(33001),
		140: uint16(33002),
		141: uint16(32987),
		142: uint16(32962),
		143: uint16(32964),
		144: uint16(32985),
		145: uint16(32973),
		146: uint16(32983),
		147: uint16(26384),
		148: uint16(32989),
		149: uint16(33003),
		150: uint16(33009),
		151: uint16(33012),
		152: uint16(33005),
		153: uint16(33037),
		154: uint16(33038),
		155: uint16(33010),
		156: uint16(33020),
		157: uint16(26389),
		158: uint16(33042),
		159: uint16(35930),
		160: uint16(33078),
		161: uint16(33054),
		162: uint16(33068),
		163: uint16(33048),
		164: uint16(33074),
		165: uint16(33096),
		166: uint16(33100),
		167: uint16(33107),
		168: uint16(33140),
		169: uint16(33113),
		170: uint16(33114),
		171: uint16(33137),
		172: uint16(33120),
		173: uint16(33129),
		174: uint16(33148),
		175: uint16(33149),
		176: uint16(33133),
		177: uint16(33127),
		178: uint16(22605),
		179: uint16(23221),
		180: uint16(33160),
		181: uint16(33154),
		182: uint16(33169),
		183: uint16(28373),
		184: uint16(33187),
		185: uint16(33194),
		186: uint16(33228),
		187: uint16(26406),
		188: uint16(33226),
		189: uint16(33211),
	},
	107: {
		0:   uint16(38689),
		1:   uint16(38690),
		2:   uint16(38691),
		3:   uint16(38692),
		4:   uint16(38693),
		5:   uint16(38694),
		6:   uint16(38695),
		7:   uint16(38696),
		8:   uint16(38697),
		9:   uint16(38699),
		10:  uint16(38700),
		11:  uint16(38702),
		12:  uint16(38703),
		13:  uint16(38705),
		14:  uint16(38707),
		15:  uint16(38708),
		16:  uint16(38709),
		17:  uint16(38710),
		18:  uint16(38711),
		19:  uint16(38714),
		20:  uint16(38715),
		21:  uint16(38716),
		22:  uint16(38717),
		23:  uint16(38719),
		24:  uint16(38720),
		25:  uint16(38721),
		26:  uint16(38722),
		27:  uint16(38723),
		28:  uint16(38724),
		29:  uint16(38725),
		30:  uint16(38726),
		31:  uint16(38727),
		32:  uint16(38728),
		33:  uint16(38729),
		34:  uint16(38730),
		35:  uint16(38731),
		36:  uint16(38732),
		37:  uint16(38733),
		38:  uint16(38734),
		39:  uint16(38735),
		40:  uint16(38736),
		41:  uint16(38737),
		42:  uint16(38740),
		43:  uint16(38741),
		44:  uint16(38743),
		45:  uint16(38744),
		46:  uint16(38746),
		47:  uint16(38748),
		48:  uint16(38749),
		49:  uint16(38751),
		50:  uint16(38755),
		51:  uint16(38756),
		52:  uint16(38758),
		53:  uint16(38759),
		54:  uint16(38760),
		55:  uint16(38762),
		56:  uint16(38763),
		57:  uint16(38764),
		58:  uint16(38765),
		59:  uint16(38766),
		60:  uint16(38767),
		61:  uint16(38768),
		62:  uint16(38769),
		63:  uint16(38770),
		64:  uint16(38773),
		65:  uint16(38775),
		66:  uint16(38776),
		67:  uint16(38777),
		68:  uint16(38778),
		69:  uint16(38779),
		70:  uint16(38781),
		71:  uint16(38782),
		72:  uint16(38783),
		73:  uint16(38784),
		74:  uint16(38785),
		75:  uint16(38786),
		76:  uint16(38787),
		77:  uint16(38788),
		78:  uint16(38790),
		79:  uint16(38791),
		80:  uint16(38792),
		81:  uint16(38793),
		82:  uint16(38794),
		83:  uint16(38796),
		84:  uint16(38798),
		85:  uint16(38799),
		86:  uint16(38800),
		87:  uint16(38803),
		88:  uint16(38805),
		89:  uint16(38806),
		90:  uint16(38807),
		91:  uint16(38809),
		92:  uint16(38810),
		93:  uint16(38811),
		94:  uint16(38812),
		95:  uint16(38813),
		96:  uint16(33217),
		97:  uint16(33190),
		98:  uint16(27428),
		99:  uint16(27447),
		100: uint16(27449),
		101: uint16(27459),
		102: uint16(27462),
		103: uint16(27481),
		104: uint16(39121),
		105: uint16(39122),
		106: uint16(39123),
		107: uint16(39125),
		108: uint16(39129),
		109: uint16(39130),
		110: uint16(27571),
		111: uint16(24384),
		112: uint16(27586),
		113: uint16(35315),
		114: uint16(26000),
		115: uint16(40785),
		116: uint16(26003),
		117: uint16(26044),
		118: uint16(26054),
		119: uint16(26052),
		120: uint16(26051),
		121: uint16(26060),
		122: uint16(26062),
		123: uint16(26066),
		124: uint16(26070),
		125: uint16(28800),
		126: uint16(28828),
		127: uint16(28822),
		128: uint16(28829),
		129: uint16(28859),
		130: uint16(28864),
		131: uint16(28855),
		132: uint16(28843),
		133: uint16(28849),
		134: uint16(28904),
		135: uint16(28874),
		136: uint16(28944),
		137: uint16(28947),
		138: uint16(28950),
		139: uint16(28975),
		140: uint16(28977),
		141: uint16(29043),
		142: uint16(29020),
		143: uint16(29032),
		144: uint16(28997),
		145: uint16(29042),
		146: uint16(29002),
		147: uint16(29048),
		148: uint16(29050),
		149: uint16(29080),
		150: uint16(29107),
		151: uint16(29109),
		152: uint16(29096),
		153: uint16(29088),
		154: uint16(29152),
		155: uint16(29140),
		156: uint16(29159),
		157: uint16(29177),
		158: uint16(29213),
		159: uint16(29224),
		160: uint16(28780),
		161: uint16(28952),
		162: uint16(29030),
		163: uint16(29113),
		164: uint16(25150),
		165: uint16(25149),
		166: uint16(25155),
		167: uint16(25160),
		168: uint16(25161),
		169: uint16(31035),
		170: uint16(31040),
		171: uint16(31046),
		172: uint16(31049),
		173: uint16(31067),
		174: uint16(31068),
		175: uint16(31059),
		176: uint16(31066),
		177: uint16(31074),
		178: uint16(31063),
		179: uint16(31072),
		180: uint16(31087),
		181: uint16(31079),
		182: uint16(31098),
		183: uint16(31109),
		184: uint16(31114),
		185: uint16(31130),
		186: uint16(31143),
		187: uint16(31155),
		188: uint16(24529),
		189: uint16(24528),
	},
	108: {
		0:   uint16(38814),
		1:   uint16(38815),
		2:   uint16(38817),
		3:   uint16(38818),
		4:   uint16(38820),
		5:   uint16(38821),
		6:   uint16(38822),
		7:   uint16(38823),
		8:   uint16(38824),
		9:   uint16(38825),
		10:  uint16(38826),
		11:  uint16(38828),
		12:  uint16(38830),
		13:  uint16(38832),
		14:  uint16(38833),
		15:  uint16(38835),
		16:  uint16(38837),
		17:  uint16(38838),
		18:  uint16(38839),
		19:  uint16(38840),
		20:  uint16(38841),
		21:  uint16(38842),
		22:  uint16(38843),
		23:  uint16(38844),
		24:  uint16(38845),
		25:  uint16(38846),
		26:  uint16(38847),
		27:  uint16(38848),
		28:  uint16(38849),
		29:  uint16(38850),
		30:  uint16(38851),
		31:  uint16(38852),
		32:  uint16(38853),
		33:  uint16(38854),
		34:  uint16(38855),
		35:  uint16(38856),
		36:  uint16(38857),
		37:  uint16(38858),
		38:  uint16(38859),
		39:  uint16(38860),
		40:  uint16(38861),
		41:  uint16(38862),
		42:  uint16(38863),
		43:  uint16(38864),
		44:  uint16(38865),
		45:  uint16(38866),
		46:  uint16(38867),
		47:  uint16(38868),
		48:  uint16(38869),
		49:  uint16(38870),
		50:  uint16(38871),
		51:  uint16(38872),
		52:  uint16(38873),
		53:  uint16(38874),
		54:  uint16(38875),
		55:  uint16(38876),
		56:  uint16(38877),
		57:  uint16(38878),
		58:  uint16(38879),
		59:  uint16(38880),
		60:  uint16(38881),
		61:  uint16(38882),
		62:  uint16(38883),
		63:  uint16(38884),
		64:  uint16(38885),
		65:  uint16(38888),
		66:  uint16(38894),
		67:  uint16(38895),
		68:  uint16(38896),
		69:  uint16(38897),
		70:  uint16(38898),
		71:  uint16(38900),
		72:  uint16(38903),
		73:  uint16(38904),
		74:  uint16(38905),
		75:  uint16(38906),
		76:  uint16(38907),
		77:  uint16(38908),
		78:  uint16(38909),
		79:  uint16(38910),
		80:  uint16(38911),
		81:  uint16(38912),
		82:  uint16(38913),
		83:  uint16(38914),
		84:  uint16(38915),
		85:  uint16(38916),
		86:  uint16(38917),
		87:  uint16(38918),
		88:  uint16(38919),
		89:  uint16(38920),
		90:  uint16(38921),
		91:  uint16(38922),
		92:  uint16(38923),
		93:  uint16(38924),
		94:  uint16(38925),
		95:  uint16(38926),
		96:  uint16(24636),
		97:  uint16(24669),
		98:  uint16(24666),
		99:  uint16(24679),
		100: uint16(24641),
		101: uint16(24665),
		102: uint16(24675),
		103: uint16(24747),
		104: uint16(24838),
		105: uint16(24845),
		106: uint16(24925),
		107: uint16(25001),
		108: uint16(24989),
		109: uint16(25035),
		110: uint16(25041),
		111: uint16(25094),
		112: uint16(32896),
		113: uint16(32895),
		114: uint16(27795),
		115: uint16(27894),
		116: uint16(28156),
		117: uint16(30710),
		118: uint16(30712),
		119: uint16(30720),
		120: uint16(30729),
		121: uint16(30743),
		122: uint16(30744),
		123: uint16(30737),
		124: uint16(26027),
		125: uint16(30765),
		126: uint16(30748),
		127: uint16(30749),
		128: uint16(30777),
		129: uint16(30778),
		130: uint16(30779),
		131: uint16(30751),
		132: uint16(30780),
		133: uint16(30757),
		134: uint16(30764),
		135: uint16(30755),
		136: uint16(30761),
		137: uint16(30798),
		138: uint16(30829),
		139: uint16(30806),
		140: uint16(30807),
		141: uint16(30758),
		142: uint16(30800),
		143: uint16(30791),
		144: uint16(30796),
		145: uint16(30826),
		146: uint16(30875),
		147: uint16(30867),
		148: uint16(30874),
		149: uint16(30855),
		150: uint16(30876),
		151: uint16(30881),
		152: uint16(30883),
		153: uint16(30898),
		154: uint16(30905),
		155: uint16(30885),
		156: uint16(30932),
		157: uint16(30937),
		158: uint16(30921),
		159: uint16(30956),
		160: uint16(30962),
		161: uint16(30981),
		162: uint16(30964),
		163: uint16(30995),
		164: uint16(31012),
		165: uint16(31006),
		166: uint16(31028),
		167: uint16(40859),
		168: uint16(40697),
		169: uint16(40699),
		170: uint16(40700),
		171: uint16(30449),
		172: uint16(30468),
		173: uint16(30477),
		174: uint16(30457),
		175: uint16(30471),
		176: uint16(30472),
		177: uint16(30490),
		178: uint16(30498),
		179: uint16(30489),
		180: uint16(30509),
		181: uint16(30502),
		182: uint16(30517),
		183: uint16(30520),
		184: uint16(30544),
		185: uint16(30545),
		186: uint16(30535),
		187: uint16(30531),
		188: uint16(30554),
		189: uint16(30568),
	},
	109: {
		0:   uint16(38927),
		1:   uint16(38928),
		2:   uint16(38929),
		3:   uint16(38930),
		4:   uint16(38931),
		5:   uint16(38932),
		6:   uint16(38933),
		7:   uint16(38934),
		8:   uint16(38935),
		9:   uint16(38936),
		10:  uint16(38937),
		11:  uint16(38938),
		12:  uint16(38939),
		13:  uint16(38940),
		14:  uint16(38941),
		15:  uint16(38942),
		16:  uint16(38943),
		17:  uint16(38944),
		18:  uint16(38945),
		19:  uint16(38946),
		20:  uint16(38947),
		21:  uint16(38948),
		22:  uint16(38949),
		23:  uint16(38950),
		24:  uint16(38951),
		25:  uint16(38952),
		26:  uint16(38953),
		27:  uint16(38954),
		28:  uint16(38955),
		29:  uint16(38956),
		30:  uint16(38957),
		31:  uint16(38958),
		32:  uint16(38959),
		33:  uint16(38960),
		34:  uint16(38961),
		35:  uint16(38962),
		36:  uint16(38963),
		37:  uint16(38964),
		38:  uint16(38965),
		39:  uint16(38966),
		40:  uint16(38967),
		41:  uint16(38968),
		42:  uint16(38969),
		43:  uint16(38970),
		44:  uint16(38971),
		45:  uint16(38972),
		46:  uint16(38973),
		47:  uint16(38974),
		48:  uint16(38975),
		49:  uint16(38976),
		50:  uint16(38977),
		51:  uint16(38978),
		52:  uint16(38979),
		53:  uint16(38980),
		54:  uint16(38981),
		55:  uint16(38982),
		56:  uint16(38983),
		57:  uint16(38984),
		58:  uint16(38985),
		59:  uint16(38986),
		60:  uint16(38987),
		61:  uint16(38988),
		62:  uint16(38989),
		63:  uint16(38990),
		64:  uint16(38991),
		65:  uint16(38992),
		66:  uint16(38993),
		67:  uint16(38994),
		68:  uint16(38995),
		69:  uint16(38996),
		70:  uint16(38997),
		71:  uint16(38998),
		72:  uint16(38999),
		73:  uint16(39000),
		74:  uint16(39001),
		75:  uint16(39002),
		76:  uint16(39003),
		77:  uint16(39004),
		78:  uint16(39005),
		79:  uint16(39006),
		80:  uint16(39007),
		81:  uint16(39008),
		82:  uint16(39009),
		83:  uint16(39010),
		84:  uint16(39011),
		85:  uint16(39012),
		86:  uint16(39013),
		87:  uint16(39014),
		88:  uint16(39015),
		89:  uint16(39016),
		90:  uint16(39017),
		91:  uint16(39018),
		92:  uint16(39019),
		93:  uint16(39020),
		94:  uint16(39021),
		95:  uint16(39022),
		96:  uint16(30562),
		97:  uint16(30565),
		98:  uint16(30591),
		99:  uint16(30605),
		100: uint16(30589),
		101: uint16(30592),
		102: uint16(30604),
		103: uint16(30609),
		104: uint16(30623),
		105: uint16(30624),
		106: uint16(30640),
		107: uint16(30645),
		108: uint16(30653),
		109: uint16(30010),
		110: uint16(30016),
		111: uint16(30030),
		112: uint16(30027),
		113: uint16(30024),
		114: uint16(30043),
		115: uint16(30066),
		116: uint16(30073),
		117: uint16(30083),
		118: uint16(32600),
		119: uint16(32609),
		120: uint16(32607),
		121: uint16(35400),
		122: uint16(32616),
		123: uint16(32628),
		124: uint16(32625),
		125: uint16(32633),
		126: uint16(32641),
		127: uint16(32638),
		128: uint16(30413),
		129: uint16(30437),
		130: uint16(34866),
		131: uint16(38021),
		132: uint16(38022),
		133: uint16(38023),
		134: uint16(38027),
		135: uint16(38026),
		136: uint16(38028),
		137: uint16(38029),
		138: uint16(38031),
		139: uint16(38032),
		140: uint16(38036),
		141: uint16(38039),
		142: uint16(38037),
		143: uint16(38042),
		144: uint16(38043),
		145: uint16(38044),
		146: uint16(38051),
		147: uint16(38052),
		148: uint16(38059),
		149: uint16(38058),
		150: uint16(38061),
		151: uint16(38060),
		152: uint16(38063),
		153: uint16(38064),
		154: uint16(38066),
		155: uint16(38068),
		156: uint16(38070),
		157: uint16(38071),
		158: uint16(38072),
		159: uint16(38073),
		160: uint16(38074),
		161: uint16(38076),
		162: uint16(38077),
		163: uint16(38079),
		164: uint16(38084),
		165: uint16(38088),
		166: uint16(38089),
		167: uint16(38090),
		168: uint16(38091),
		169: uint16(38092),
		170: uint16(38093),
		171: uint16(38094),
		172: uint16(38096),
		173: uint16(38097),
		174: uint16(38098),
		175: uint16(38101),
		176: uint16(38102),
		177: uint16(38103),
		178: uint16(38105),
		179: uint16(38104),
		180: uint16(38107),
		181: uint16(38110),
		182: uint16(38111),
		183: uint16(38112),
		184: uint16(38114),
		185: uint16(38116),
		186: uint16(38117),
		187: uint16(38119),
		188: uint16(38120),
		189: uint16(38122),
	},
	110: {
		0:   uint16(39023),
		1:   uint16(39024),
		2:   uint16(39025),
		3:   uint16(39026),
		4:   uint16(39027),
		5:   uint16(39028),
		6:   uint16(39051),
		7:   uint16(39054),
		8:   uint16(39058),
		9:   uint16(39061),
		10:  uint16(39065),
		11:  uint16(39075),
		12:  uint16(39080),
		13:  uint16(39081),
		14:  uint16(39082),
		15:  uint16(39083),
		16:  uint16(39084),
		17:  uint16(39085),
		18:  uint16(39086),
		19:  uint16(39087),
		20:  uint16(39088),
		21:  uint16(39089),
		22:  uint16(39090),
		23:  uint16(39091),
		24:  uint16(39092),
		25:  uint16(39093),
		26:  uint16(39094),
		27:  uint16(39095),
		28:  uint16(39096),
		29:  uint16(39097),
		30:  uint16(39098),
		31:  uint16(39099),
		32:  uint16(39100),
		33:  uint16(39101),
		34:  uint16(39102),
		35:  uint16(39103),
		36:  uint16(39104),
		37:  uint16(39105),
		38:  uint16(39106),
		39:  uint16(39107),
		40:  uint16(39108),
		41:  uint16(39109),
		42:  uint16(39110),
		43:  uint16(39111),
		44:  uint16(39112),
		45:  uint16(39113),
		46:  uint16(39114),
		47:  uint16(39115),
		48:  uint16(39116),
		49:  uint16(39117),
		50:  uint16(39119),
		51:  uint16(39120),
		52:  uint16(39124),
		53:  uint16(39126),
		54:  uint16(39127),
		55:  uint16(39131),
		56:  uint16(39132),
		57:  uint16(39133),
		58:  uint16(39136),
		59:  uint16(39137),
		60:  uint16(39138),
		61:  uint16(39139),
		62:  uint16(39140),
		63:  uint16(39141),
		64:  uint16(39142),
		65:  uint16(39145),
		66:  uint16(39146),
		67:  uint16(39147),
		68:  uint16(39148),
		69:  uint16(39149),
		70:  uint16(39150),
		71:  uint16(39151),
		72:  uint16(39152),
		73:  uint16(39153),
		74:  uint16(39154),
		75:  uint16(39155),
		76:  uint16(39156),
		77:  uint16(39157),
		78:  uint16(39158),
		79:  uint16(39159),
		80:  uint16(39160),
		81:  uint16(39161),
		82:  uint16(39162),
		83:  uint16(39163),
		84:  uint16(39164),
		85:  uint16(39165),
		86:  uint16(39166),
		87:  uint16(39167),
		88:  uint16(39168),
		89:  uint16(39169),
		90:  uint16(39170),
		91:  uint16(39171),
		92:  uint16(39172),
		93:  uint16(39173),
		94:  uint16(39174),
		95:  uint16(39175),
		96:  uint16(38121),
		97:  uint16(38123),
		98:  uint16(38126),
		99:  uint16(38127),
		100: uint16(38131),
		101: uint16(38132),
		102: uint16(38133),
		103: uint16(38135),
		104: uint16(38137),
		105: uint16(38140),
		106: uint16(38141),
		107: uint16(38143),
		108: uint16(38147),
		109: uint16(38146),
		110: uint16(38150),
		111: uint16(38151),
		112: uint16(38153),
		113: uint16(38154),
		114: uint16(38157),
		115: uint16(38158),
		116: uint16(38159),
		117: uint16(38162),
		118: uint16(38163),
		119: uint16(38164),
		120: uint16(38165),
		121: uint16(38166),
		122: uint16(38168),
		123: uint16(38171),
		124: uint16(38173),
		125: uint16(38174),
		126: uint16(38175),
		127: uint16(38178),
		128: uint16(38186),
		129: uint16(38187),
		130: uint16(38185),
		131: uint16(38188),
		132: uint16(38193),
		133: uint16(38194),
		134: uint16(38196),
		135: uint16(38198),
		136: uint16(38199),
		137: uint16(38200),
		138: uint16(38204),
		139: uint16(38206),
		140: uint16(38207),
		141: uint16(38210),
		142: uint16(38197),
		143: uint16(38212),
		144: uint16(38213),
		145: uint16(38214),
		146: uint16(38217),
		147: uint16(38220),
		148: uint16(38222),
		149: uint16(38223),
		150: uint16(38226),
		151: uint16(38227),
		152: uint16(38228),
		153: uint16(38230),
		154: uint16(38231),
		155: uint16(38232),
		156: uint16(38233),
		157: uint16(38235),
		158: uint16(38238),
		159: uint16(38239),
		160: uint16(38237),
		161: uint16(38241),
		162: uint16(38242),
		163: uint16(38244),
		164: uint16(38245),
		165: uint16(38246),
		166: uint16(38247),
		167: uint16(38248),
		168: uint16(38249),
		169: uint16(38250),
		170: uint16(38251),
		171: uint16(38252),
		172: uint16(38255),
		173: uint16(38257),
		174: uint16(38258),
		175: uint16(38259),
		176: uint16(38202),
		177: uint16(30695),
		178: uint16(30700),
		179: uint16(38601),
		180: uint16(31189),
		181: uint16(31213),
		182: uint16(31203),
		183: uint16(31211),
		184: uint16(31238),
		185: uint16(23879),
		186: uint16(31235),
		187: uint16(31234),
		188: uint16(31262),
		189: uint16(31252),
	},
	111: {
		0:   uint16(39176),
		1:   uint16(39177),
		2:   uint16(39178),
		3:   uint16(39179),
		4:   uint16(39180),
		5:   uint16(39182),
		6:   uint16(39183),
		7:   uint16(39185),
		8:   uint16(39186),
		9:   uint16(39187),
		10:  uint16(39188),
		11:  uint16(39189),
		12:  uint16(39190),
		13:  uint16(39191),
		14:  uint16(39192),
		15:  uint16(39193),
		16:  uint16(39194),
		17:  uint16(39195),
		18:  uint16(39196),
		19:  uint16(39197),
		20:  uint16(39198),
		21:  uint16(39199),
		22:  uint16(39200),
		23:  uint16(39201),
		24:  uint16(39202),
		25:  uint16(39203),
		26:  uint16(39204),
		27:  uint16(39205),
		28:  uint16(39206),
		29:  uint16(39207),
		30:  uint16(39208),
		31:  uint16(39209),
		32:  uint16(39210),
		33:  uint16(39211),
		34:  uint16(39212),
		35:  uint16(39213),
		36:  uint16(39215),
		37:  uint16(39216),
		38:  uint16(39217),
		39:  uint16(39218),
		40:  uint16(39219),
		41:  uint16(39220),
		42:  uint16(39221),
		43:  uint16(39222),
		44:  uint16(39223),
		45:  uint16(39224),
		46:  uint16(39225),
		47:  uint16(39226),
		48:  uint16(39227),
		49:  uint16(39228),
		50:  uint16(39229),
		51:  uint16(39230),
		52:  uint16(39231),
		53:  uint16(39232),
		54:  uint16(39233),
		55:  uint16(39234),
		56:  uint16(39235),
		57:  uint16(39236),
		58:  uint16(39237),
		59:  uint16(39238),
		60:  uint16(39239),
		61:  uint16(39240),
		62:  uint16(39241),
		63:  uint16(39242),
		64:  uint16(39243),
		65:  uint16(39244),
		66:  uint16(39245),
		67:  uint16(39246),
		68:  uint16(39247),
		69:  uint16(39248),
		70:  uint16(39249),
		71:  uint16(39250),
		72:  uint16(39251),
		73:  uint16(39254),
		74:  uint16(39255),
		75:  uint16(39256),
		76:  uint16(39257),
		77:  uint16(39258),
		78:  uint16(39259),
		79:  uint16(39260),
		80:  uint16(39261),
		81:  uint16(39262),
		82:  uint16(39263),
		83:  uint16(39264),
		84:  uint16(39265),
		85:  uint16(39266),
		86:  uint16(39268),
		87:  uint16(39270),
		88:  uint16(39283),
		89:  uint16(39288),
		90:  uint16(39289),
		91:  uint16(39291),
		92:  uint16(39294),
		93:  uint16(39298),
		94:  uint16(39299),
		95:  uint16(39305),
		96:  uint16(31289),
		97:  uint16(31287),
		98:  uint16(31313),
		99:  uint16(40655),
		100: uint16(39333),
		101: uint16(31344),
		102: uint16(30344),
		103: uint16(30350),
		104: uint16(30355),
		105: uint16(30361),
		106: uint16(30372),
		107: uint16(29918),
		108: uint16(29920),
		109: uint16(29996),
		110: uint16(40480),
		111: uint16(40482),
		112: uint16(40488),
		113: uint16(40489),
		114: uint16(40490),
		115: uint16(40491),
		116: uint16(40492),
		117: uint16(40498),
		118: uint16(40497),
		119: uint16(40502),
		120: uint16(40504),
		121: uint16(40503),
		122: uint16(40505),
		123: uint16(40506),
		124: uint16(40510),
		125: uint16(40513),
		126: uint16(40514),
		127: uint16(40516),
		128: uint16(40518),
		129: uint16(40519),
		130: uint16(40520),
		131: uint16(40521),
		132: uint16(40523),
		133: uint16(40524),
		134: uint16(40526),
		135: uint16(40529),
		136: uint16(40533),
		137: uint16(40535),
		138: uint16(40538),
		139: uint16(40539),
		140: uint16(40540),
		141: uint16(40542),
		142: uint16(40547),
		143: uint16(40550),
		144: uint16(40551),
		145: uint16(40552),
		146: uint16(40553),
		147: uint16(40554),
		148: uint16(40555),
		149: uint16(40556),
		150: uint16(40561),
		151: uint16(40557),
		152: uint16(40563),
		153: uint16(30098),
		154: uint16(30100),
		155: uint16(30102),
		156: uint16(30112),
		157: uint16(30109),
		158: uint16(30124),
		159: uint16(30115),
		160: uint16(30131),
		161: uint16(30132),
		162: uint16(30136),
		163: uint16(30148),
		164: uint16(30129),
		165: uint16(30128),
		166: uint16(30147),
		167: uint16(30146),
		168: uint16(30166),
		169: uint16(30157),
		170: uint16(30179),
		171: uint16(30184),
		172: uint16(30182),
		173: uint16(30180),
		174: uint16(30187),
		175: uint16(30183),
		176: uint16(30211),
		177: uint16(30193),
		178: uint16(30204),
		179: uint16(30207),
		180: uint16(30224),
		181: uint16(30208),
		182: uint16(30213),
		183: uint16(30220),
		184: uint16(30231),
		185: uint16(30218),
		186: uint16(30245),
		187: uint16(30232),
		188: uint16(30229),
		189: uint16(30233),
	},
	112: {
		0:   uint16(39308),
		1:   uint16(39310),
		2:   uint16(39322),
		3:   uint16(39323),
		4:   uint16(39324),
		5:   uint16(39325),
		6:   uint16(39326),
		7:   uint16(39327),
		8:   uint16(39328),
		9:   uint16(39329),
		10:  uint16(39330),
		11:  uint16(39331),
		12:  uint16(39332),
		13:  uint16(39334),
		14:  uint16(39335),
		15:  uint16(39337),
		16:  uint16(39338),
		17:  uint16(39339),
		18:  uint16(39340),
		19:  uint16(39341),
		20:  uint16(39342),
		21:  uint16(39343),
		22:  uint16(39344),
		23:  uint16(39345),
		24:  uint16(39346),
		25:  uint16(39347),
		26:  uint16(39348),
		27:  uint16(39349),
		28:  uint16(39350),
		29:  uint16(39351),
		30:  uint16(39352),
		31:  uint16(39353),
		32:  uint16(39354),
		33:  uint16(39355),
		34:  uint16(39356),
		35:  uint16(39357),
		36:  uint16(39358),
		37:  uint16(39359),
		38:  uint16(39360),
		39:  uint16(39361),
		40:  uint16(39362),
		41:  uint16(39363),
		42:  uint16(39364),
		43:  uint16(39365),
		44:  uint16(39366),
		45:  uint16(39367),
		46:  uint16(39368),
		47:  uint16(39369),
		48:  uint16(39370),
		49:  uint16(39371),
		50:  uint16(39372),
		51:  uint16(39373),
		52:  uint16(39374),
		53:  uint16(39375),
		54:  uint16(39376),
		55:  uint16(39377),
		56:  uint16(39378),
		57:  uint16(39379),
		58:  uint16(39380),
		59:  uint16(39381),
		60:  uint16(39382),
		61:  uint16(39383),
		62:  uint16(39384),
		63:  uint16(39385),
		64:  uint16(39386),
		65:  uint16(39387),
		66:  uint16(39388),
		67:  uint16(39389),
		68:  uint16(39390),
		69:  uint16(39391),
		70:  uint16(39392),
		71:  uint16(39393),
		72:  uint16(39394),
		73:  uint16(39395),
		74:  uint16(39396),
		75:  uint16(39397),
		76:  uint16(39398),
		77:  uint16(39399),
		78:  uint16(39400),
		79:  uint16(39401),
		80:  uint16(39402),
		81:  uint16(39403),
		82:  uint16(39404),
		83:  uint16(39405),
		84:  uint16(39406),
		85:  uint16(39407),
		86:  uint16(39408),
		87:  uint16(39409),
		88:  uint16(39410),
		89:  uint16(39411),
		90:  uint16(39412),
		91:  uint16(39413),
		92:  uint16(39414),
		93:  uint16(39415),
		94:  uint16(39416),
		95:  uint16(39417),
		96:  uint16(30235),
		97:  uint16(30268),
		98:  uint16(30242),
		99:  uint16(30240),
		100: uint16(30272),
		101: uint16(30253),
		102: uint16(30256),
		103: uint16(30271),
		104: uint16(30261),
		105: uint16(30275),
		106: uint16(30270),
		107: uint16(30259),
		108: uint16(30285),
		109: uint16(30302),
		110: uint16(30292),
		111: uint16(30300),
		112: uint16(30294),
		113: uint16(30315),
		114: uint16(30319),
		115: uint16(32714),
		116: uint16(31462),
		117: uint16(31352),
		118: uint16(31353),
		119: uint16(31360),
		120: uint16(31366),
		121: uint16(31368),
		122: uint16(31381),
		123: uint16(31398),
		124: uint16(31392),
		125: uint16(31404),
		126: uint16(31400),
		127: uint16(31405),
		128: uint16(31411),
		129: uint16(34916),
		130: uint16(34921),
		131: uint16(34930),
		132: uint16(34941),
		133: uint16(34943),
		134: uint16(34946),
		135: uint16(34978),
		136: uint16(35014),
		137: uint16(34999),
		138: uint16(35004),
		139: uint16(35017),
		140: uint16(35042),
		141: uint16(35022),
		142: uint16(35043),
		143: uint16(35045),
		144: uint16(35057),
		145: uint16(35098),
		146: uint16(35068),
		147: uint16(35048),
		148: uint16(35070),
		149: uint16(35056),
		150: uint16(35105),
		151: uint16(35097),
		152: uint16(35091),
		153: uint16(35099),
		154: uint16(35082),
		155: uint16(35124),
		156: uint16(35115),
		157: uint16(35126),
		158: uint16(35137),
		159: uint16(35174),
		160: uint16(35195),
		161: uint16(30091),
		162: uint16(32997),
		163: uint16(30386),
		164: uint16(30388),
		165: uint16(30684),
		166: uint16(32786),
		167: uint16(32788),
		168: uint16(32790),
		169: uint16(32796),
		170: uint16(32800),
		171: uint16(32802),
		172: uint16(32805),
		173: uint16(32806),
		174: uint16(32807),
		175: uint16(32809),
		176: uint16(32808),
		177: uint16(32817),
		178: uint16(32779),
		179: uint16(32821),
		180: uint16(32835),
		181: uint16(32838),
		182: uint16(32845),
		183: uint16(32850),
		184: uint16(32873),
		185: uint16(32881),
		186: uint16(35203),
		187: uint16(39032),
		188: uint16(39040),
		189: uint16(39043),
	},
	113: {
		0:   uint16(39418),
		1:   uint16(39419),
		2:   uint16(39420),
		3:   uint16(39421),
		4:   uint16(39422),
		5:   uint16(39423),
		6:   uint16(39424),
		7:   uint16(39425),
		8:   uint16(39426),
		9:   uint16(39427),
		10:  uint16(39428),
		11:  uint16(39429),
		12:  uint16(39430),
		13:  uint16(39431),
		14:  uint16(39432),
		15:  uint16(39433),
		16:  uint16(39434),
		17:  uint16(39435),
		18:  uint16(39436),
		19:  uint16(39437),
		20:  uint16(39438),
		21:  uint16(39439),
		22:  uint16(39440),
		23:  uint16(39441),
		24:  uint16(39442),
		25:  uint16(39443),
		26:  uint16(39444),
		27:  uint16(39445),
		28:  uint16(39446),
		29:  uint16(39447),
		30:  uint16(39448),
		31:  uint16(39449),
		32:  uint16(39450),
		33:  uint16(39451),
		34:  uint16(39452),
		35:  uint16(39453),
		36:  uint16(39454),
		37:  uint16(39455),
		38:  uint16(39456),
		39:  uint16(39457),
		40:  uint16(39458),
		41:  uint16(39459),
		42:  uint16(39460),
		43:  uint16(39461),
		44:  uint16(39462),
		45:  uint16(39463),
		46:  uint16(39464),
		47:  uint16(39465),
		48:  uint16(39466),
		49:  uint16(39467),
		50:  uint16(39468),
		51:  uint16(39469),
		52:  uint16(39470),
		53:  uint16(39471),
		54:  uint16(39472),
		55:  uint16(39473),
		56:  uint16(39474),
		57:  uint16(39475),
		58:  uint16(39476),
		59:  uint16(39477),
		60:  uint16(39478),
		61:  uint16(39479),
		62:  uint16(39480),
		63:  uint16(39481),
		64:  uint16(39482),
		65:  uint16(39483),
		66:  uint16(39484),
		67:  uint16(39485),
		68:  uint16(39486),
		69:  uint16(39487),
		70:  uint16(39488),
		71:  uint16(39489),
		72:  uint16(39490),
		73:  uint16(39491),
		74:  uint16(39492),
		75:  uint16(39493),
		76:  uint16(39494),
		77:  uint16(39495),
		78:  uint16(39496),
		79:  uint16(39497),
		80:  uint16(39498),
		81:  uint16(39499),
		82:  uint16(39500),
		83:  uint16(39501),
		84:  uint16(39502),
		85:  uint16(39503),
		86:  uint16(39504),
		87:  uint16(39505),
		88:  uint16(39506),
		89:  uint16(39507),
		90:  uint16(39508),
		91:  uint16(39509),
		92:  uint16(39510),
		93:  uint16(39511),
		94:  uint16(39512),
		95:  uint16(39513),
		96:  uint16(39049),
		97:  uint16(39052),
		98:  uint16(39053),
		99:  uint16(39055),
		100: uint16(39060),
		101: uint16(39066),
		102: uint16(39067),
		103: uint16(39070),
		104: uint16(39071),
		105: uint16(39073),
		106: uint16(39074),
		107: uint16(39077),
		108: uint16(39078),
		109: uint16(34381),
		110: uint16(34388),
		111: uint16(34412),
		112: uint16(34414),
		113: uint16(34431),
		114: uint16(34426),
		115: uint16(34428),
		116: uint16(34427),
		117: uint16(34472),
		118: uint16(34445),
		119: uint16(34443),
		120: uint16(34476),
		121: uint16(34461),
		122: uint16(34471),
		123: uint16(34467),
		124: uint16(34474),
		125: uint16(34451),
		126: uint16(34473),
		127: uint16(34486),
		128: uint16(34500),
		129: uint16(34485),
		130: uint16(34510),
		131: uint16(34480),
		132: uint16(34490),
		133: uint16(34481),
		134: uint16(34479),
		135: uint16(34505),
		136: uint16(34511),
		137: uint16(34484),
		138: uint16(34537),
		139: uint16(34545),
		140: uint16(34546),
		141: uint16(34541),
		142: uint16(34547),
		143: uint16(34512),
		144: uint16(34579),
		145: uint16(34526),
		146: uint16(34548),
		147: uint16(34527),
		148: uint16(34520),
		149: uint16(34513),
		150: uint16(34563),
		151: uint16(34567),
		152: uint16(34552),
		153: uint16(34568),
		154: uint16(34570),
		155: uint16(34573),
		156: uint16(34569),
		157: uint16(34595),
		158: uint16(34619),
		159: uint16(34590),
		160: uint16(34597),
		161: uint16(34606),
		162: uint16(34586),
		163: uint16(34622),
		164: uint16(34632),
		165: uint16(34612),
		166: uint16(34609),
		167: uint16(34601),
		168: uint16(34615),
		169: uint16(34623),
		170: uint16(34690),
		171: uint16(34594),
		172: uint16(34685),
		173: uint16(34686),
		174: uint16(34683),
		175: uint16(34656),
		176: uint16(34672),
		177: uint16(34636),
		178: uint16(34670),
		179: uint16(34699),
		180: uint16(34643),
		181: uint16(34659),
		182: uint16(34684),
		183: uint16(34660),
		184: uint16(34649),
		185: uint16(34661),
		186: uint16(34707),
		187: uint16(34735),
		188: uint16(34728),
		189: uint16(34770),
	},
	114: {
		0:   uint16(39514),
		1:   uint16(39515),
		2:   uint16(39516),
		3:   uint16(39517),
		4:   uint16(39518),
		5:   uint16(39519),
		6:   uint16(39520),
		7:   uint16(39521),
		8:   uint16(39522),
		9:   uint16(39523),
		10:  uint16(39524),
		11:  uint16(39525),
		12:  uint16(39526),
		13:  uint16(39527),
		14:  uint16(39528),
		15:  uint16(39529),
		16:  uint16(39530),
		17:  uint16(39531),
		18:  uint16(39538),
		19:  uint16(39555),
		20:  uint16(39561),
		21:  uint16(39565),
		22:  uint16(39566),
		23:  uint16(39572),
		24:  uint16(39573),
		25:  uint16(39577),
		26:  uint16(39590),
		27:  uint16(39593),
		28:  uint16(39594),
		29:  uint16(39595),
		30:  uint16(39596),
		31:  uint16(39597),
		32:  uint16(39598),
		33:  uint16(39599),
		34:  uint16(39602),
		35:  uint16(39603),
		36:  uint16(39604),
		37:  uint16(39605),
		38:  uint16(39609),
		39:  uint16(39611),
		40:  uint16(39613),
		41:  uint16(39614),
		42:  uint16(39615),
		43:  uint16(39619),
		44:  uint16(39620),
		45:  uint16(39622),
		46:  uint16(39623),
		47:  uint16(39624),
		48:  uint16(39625),
		49:  uint16(39626),
		50:  uint16(39629),
		51:  uint16(39630),
		52:  uint16(39631),
		53:  uint16(39632),
		54:  uint16(39634),
		55:  uint16(39636),
		56:  uint16(39637),
		57:  uint16(39638),
		58:  uint16(39639),
		59:  uint16(39641),
		60:  uint16(39642),
		61:  uint16(39643),
		62:  uint16(39644),
		63:  uint16(39645),
		64:  uint16(39646),
		65:  uint16(39648),
		66:  uint16(39650),
		67:  uint16(39651),
		68:  uint16(39652),
		69:  uint16(39653),
		70:  uint16(39655),
		71:  uint16(39656),
		72:  uint16(39657),
		73:  uint16(39658),
		74:  uint16(39660),
		75:  uint16(39662),
		76:  uint16(39664),
		77:  uint16(39665),
		78:  uint16(39666),
		79:  uint16(39667),
		80:  uint16(39668),
		81:  uint16(39669),
		82:  uint16(39670),
		83:  uint16(39671),
		84:  uint16(39672),
		85:  uint16(39674),
		86:  uint16(39676),
		87:  uint16(39677),
		88:  uint16(39678),
		89:  uint16(39679),
		90:  uint16(39680),
		91:  uint16(39681),
		92:  uint16(39682),
		93:  uint16(39684),
		94:  uint16(39685),
		95:  uint16(39686),
		96:  uint16(34758),
		97:  uint16(34696),
		98:  uint16(34693),
		99:  uint16(34733),
		100: uint16(34711),
		101: uint16(34691),
		102: uint16(34731),
		103: uint16(34789),
		104: uint16(34732),
		105: uint16(34741),
		106: uint16(34739),
		107: uint16(34763),
		108: uint16(34771),
		109: uint16(34749),
		110: uint16(34769),
		111: uint16(34752),
		112: uint16(34762),
		113: uint16(34779),
		114: uint16(34794),
		115: uint16(34784),
		116: uint16(34798),
		117: uint16(34838),
		118: uint16(34835),
		119: uint16(34814),
		120: uint16(34826),
		121: uint16(34843),
		122: uint16(34849),
		123: uint16(34873),
		124: uint16(34876),
		125: uint16(32566),
		126: uint16(32578),
		127: uint16(32580),
		128: uint16(32581),
		129: uint16(33296),
		130: uint16(31482),
		131: uint16(31485),
		132: uint16(31496),
		133: uint16(31491),
		134: uint16(31492),
		135: uint16(31509),
		136: uint16(31498),
		137: uint16(31531),
		138: uint16(31503),
		139: uint16(31559),
		140: uint16(31544),
		141: uint16(31530),
		142: uint16(31513),
		143: uint16(31534),
		144: uint16(31537),
		145: uint16(31520),
		146: uint16(31525),
		147: uint16(31524),
		148: uint16(31539),
		149: uint16(31550),
		150: uint16(31518),
		151: uint16(31576),
		152: uint16(31578),
		153: uint16(31557),
		154: uint16(31605),
		155: uint16(31564),
		156: uint16(31581),
		157: uint16(31584),
		158: uint16(31598),
		159: uint16(31611),
		160: uint16(31586),
		161: uint16(31602),
		162: uint16(31601),
		163: uint16(31632),
		164: uint16(31654),
		165: uint16(31655),
		166: uint16(31672),
		167: uint16(31660),
		168: uint16(31645),
		169: uint16(31656),
		170: uint16(31621),
		171: uint16(31658),
		172: uint16(31644),
		173: uint16(31650),
		174: uint16(31659),
		175: uint16(31668),
		176: uint16(31697),
		177: uint16(31681),
		178: uint16(31692),
		179: uint16(31709),
		180: uint16(31706),
		181: uint16(31717),
		182: uint16(31718),
		183: uint16(31722),
		184: uint16(31756),
		185: uint16(31742),
		186: uint16(31740),
		187: uint16(31759),
		188: uint16(31766),
		189: uint16(31755),
	},
	115: {
		0:   uint16(39687),
		1:   uint16(39689),
		2:   uint16(39690),
		3:   uint16(39691),
		4:   uint16(39692),
		5:   uint16(39693),
		6:   uint16(39694),
		7:   uint16(39696),
		8:   uint16(39697),
		9:   uint16(39698),
		10:  uint16(39700),
		11:  uint16(39701),
		12:  uint16(39702),
		13:  uint16(39703),
		14:  uint16(39704),
		15:  uint16(39705),
		16:  uint16(39706),
		17:  uint16(39707),
		18:  uint16(39708),
		19:  uint16(39709),
		20:  uint16(39710),
		21:  uint16(39712),
		22:  uint16(39713),
		23:  uint16(39714),
		24:  uint16(39716),
		25:  uint16(39717),
		26:  uint16(39718),
		27:  uint16(39719),
		28:  uint16(39720),
		29:  uint16(39721),
		30:  uint16(39722),
		31:  uint16(39723),
		32:  uint16(39724),
		33:  uint16(39725),
		34:  uint16(39726),
		35:  uint16(39728),
		36:  uint16(39729),
		37:  uint16(39731),
		38:  uint16(39732),
		39:  uint16(39733),
		40:  uint16(39734),
		41:  uint16(39735),
		42:  uint16(39736),
		43:  uint16(39737),
		44:  uint16(39738),
		45:  uint16(39741),
		46:  uint16(39742),
		47:  uint16(39743),
		48:  uint16(39744),
		49:  uint16(39750),
		50:  uint16(39754),
		51:  uint16(39755),
		52:  uint16(39756),
		53:  uint16(39758),
		54:  uint16(39760),
		55:  uint16(39762),
		56:  uint16(39763),
		57:  uint16(39765),
		58:  uint16(39766),
		59:  uint16(39767),
		60:  uint16(39768),
		61:  uint16(39769),
		62:  uint16(39770),
		63:  uint16(39771),
		64:  uint16(39772),
		65:  uint16(39773),
		66:  uint16(39774),
		67:  uint16(39775),
		68:  uint16(39776),
		69:  uint16(39777),
		70:  uint16(39778),
		71:  uint16(39779),
		72:  uint16(39780),
		73:  uint16(39781),
		74:  uint16(39782),
		75:  uint16(39783),
		76:  uint16(39784),
		77:  uint16(39785),
		78:  uint16(39786),
		79:  uint16(39787),
		80:  uint16(39788),
		81:  uint16(39789),
		82:  uint16(39790),
		83:  uint16(39791),
		84:  uint16(39792),
		85:  uint16(39793),
		86:  uint16(39794),
		87:  uint16(39795),
		88:  uint16(39796),
		89:  uint16(39797),
		90:  uint16(39798),
		91:  uint16(39799),
		92:  uint16(39800),
		93:  uint16(39801),
		94:  uint16(39802),
		95:  uint16(39803),
		96:  uint16(31775),
		97:  uint16(31786),
		98:  uint16(31782),
		99:  uint16(31800),
		100: uint16(31809),
		101: uint16(31808),
		102: uint16(33278),
		103: uint16(33281),
		104: uint16(33282),
		105: uint16(33284),
		106: uint16(33260),
		107: uint16(34884),
		108: uint16(33313),
		109: uint16(33314),
		110: uint16(33315),
		111: uint16(33325),
		112: uint16(33327),
		113: uint16(33320),
		114: uint16(33323),
		115: uint16(33336),
		116: uint16(33339),
		117: uint16(33331),
		118: uint16(33332),
		119: uint16(33342),
		120: uint16(33348),
		121: uint16(33353),
		122: uint16(33355),
		123: uint16(33359),
		124: uint16(33370),
		125: uint16(33375),
		126: uint16(33384),
		127: uint16(34942),
		128: uint16(34949),
		129: uint16(34952),
		130: uint16(35032),
		131: uint16(35039),
		132: uint16(35166),
		133: uint16(32669),
		134: uint16(32671),
		135: uint16(32679),
		136: uint16(32687),
		137: uint16(32688),
		138: uint16(32690),
		139: uint16(31868),
		140: uint16(25929),
		141: uint16(31889),
		142: uint16(31901),
		143: uint16(31900),
		144: uint16(31902),
		145: uint16(31906),
		146: uint16(31922),
		147: uint16(31932),
		148: uint16(31933),
		149: uint16(31937),
		150: uint16(31943),
		151: uint16(31948),
		152: uint16(31949),
		153: uint16(31944),
		154: uint16(31941),
		155: uint16(31959),
		156: uint16(31976),
		157: uint16(33390),
		158: uint16(26280),
		159: uint16(32703),
		160: uint16(32718),
		161: uint16(32725),
		162: uint16(32741),
		163: uint16(32737),
		164: uint16(32742),
		165: uint16(32745),
		166: uint16(32750),
		167: uint16(32755),
		168: uint16(31992),
		169: uint16(32119),
		170: uint16(32166),
		171: uint16(32174),
		172: uint16(32327),
		173: uint16(32411),
		174: uint16(40632),
		175: uint16(40628),
		176: uint16(36211),
		177: uint16(36228),
		178: uint16(36244),
		179: uint16(36241),
		180: uint16(36273),
		181: uint16(36199),
		182: uint16(36205),
		183: uint16(35911),
		184: uint16(35913),
		185: uint16(37194),
		186: uint16(37200),
		187: uint16(37198),
		188: uint16(37199),
		189: uint16(37220),
	},
	116: {
		0:   uint16(39804),
		1:   uint16(39805),
		2:   uint16(39806),
		3:   uint16(39807),
		4:   uint16(39808),
		5:   uint16(39809),
		6:   uint16(39810),
		7:   uint16(39811),
		8:   uint16(39812),
		9:   uint16(39813),
		10:  uint16(39814),
		11:  uint16(39815),
		12:  uint16(39816),
		13:  uint16(39817),
		14:  uint16(39818),
		15:  uint16(39819),
		16:  uint16(39820),
		17:  uint16(39821),
		18:  uint16(39822),
		19:  uint16(39823),
		20:  uint16(39824),
		21:  uint16(39825),
		22:  uint16(39826),
		23:  uint16(39827),
		24:  uint16(39828),
		25:  uint16(39829),
		26:  uint16(39830),
		27:  uint16(39831),
		28:  uint16(39832),
		29:  uint16(39833),
		30:  uint16(39834),
		31:  uint16(39835),
		32:  uint16(39836),
		33:  uint16(39837),
		34:  uint16(39838),
		35:  uint16(39839),
		36:  uint16(39840),
		37:  uint16(39841),
		38:  uint16(39842),
		39:  uint16(39843),
		40:  uint16(39844),
		41:  uint16(39845),
		42:  uint16(39846),
		43:  uint16(39847),
		44:  uint16(39848),
		45:  uint16(39849),
		46:  uint16(39850),
		47:  uint16(39851),
		48:  uint16(39852),
		49:  uint16(39853),
		50:  uint16(39854),
		51:  uint16(39855),
		52:  uint16(39856),
		53:  uint16(39857),
		54:  uint16(39858),
		55:  uint16(39859),
		56:  uint16(39860),
		57:  uint16(39861),
		58:  uint16(39862),
		59:  uint16(39863),
		60:  uint16(39864),
		61:  uint16(39865),
		62:  uint16(39866),
		63:  uint16(39867),
		64:  uint16(39868),
		65:  uint16(39869),
		66:  uint16(39870),
		67:  uint16(39871),
		68:  uint16(39872),
		69:  uint16(39873),
		70:  uint16(39874),
		71:  uint16(39875),
		72:  uint16(39876),
		73:  uint16(39877),
		74:  uint16(39878),
		75:  uint16(39879),
		76:  uint16(39880),
		77:  uint16(39881),
		78:  uint16(39882),
		79:  uint16(39883),
		80:  uint16(39884),
		81:  uint16(39885),
		82:  uint16(39886),
		83:  uint16(39887),
		84:  uint16(39888),
		85:  uint16(39889),
		86:  uint16(39890),
		87:  uint16(39891),
		88:  uint16(39892),
		89:  uint16(39893),
		90:  uint16(39894),
		91:  uint16(39895),
		92:  uint16(39896),
		93:  uint16(39897),
		94:  uint16(39898),
		95:  uint16(39899),
		96:  uint16(37218),
		97:  uint16(37217),
		98:  uint16(37232),
		99:  uint16(37225),
		100: uint16(37231),
		101: uint16(37245),
		102: uint16(37246),
		103: uint16(37234),
		104: uint16(37236),
		105: uint16(37241),
		106: uint16(37260),
		107: uint16(37253),
		108: uint16(37264),
		109: uint16(37261),
		110: uint16(37265),
		111: uint16(37282),
		112: uint16(37283),
		113: uint16(37290),
		114: uint16(37293),
		115: uint16(37294),
		116: uint16(37295),
		117: uint16(37301),
		118: uint16(37300),
		119: uint16(37306),
		120: uint16(35925),
		121: uint16(40574),
		122: uint16(36280),
		123: uint16(36331),
		124: uint16(36357),
		125: uint16(36441),
		126: uint16(36457),
		127: uint16(36277),
		128: uint16(36287),
		129: uint16(36284),
		130: uint16(36282),
		131: uint16(36292),
		132: uint16(36310),
		133: uint16(36311),
		134: uint16(36314),
		135: uint16(36318),
		136: uint16(36302),
		137: uint16(36303),
		138: uint16(36315),
		139: uint16(36294),
		140: uint16(36332),
		141: uint16(36343),
		142: uint16(36344),
		143: uint16(36323),
		144: uint16(36345),
		145: uint16(36347),
		146: uint16(36324),
		147: uint16(36361),
		148: uint16(36349),
		149: uint16(36372),
		150: uint16(36381),
		151: uint16(36383),
		152: uint16(36396),
		153: uint16(36398),
		154: uint16(36387),
		155: uint16(36399),
		156: uint16(36410),
		157: uint16(36416),
		158: uint16(36409),
		159: uint16(36405),
		160: uint16(36413),
		161: uint16(36401),
		162: uint16(36425),
		163: uint16(36417),
		164: uint16(36418),
		165: uint16(36433),
		166: uint16(36434),
		167: uint16(36426),
		168: uint16(36464),
		169: uint16(36470),
		170: uint16(36476),
		171: uint16(36463),
		172: uint16(36468),
		173: uint16(36485),
		174: uint16(36495),
		175: uint16(36500),
		176: uint16(36496),
		177: uint16(36508),
		178: uint16(36510),
		179: uint16(35960),
		180: uint16(35970),
		181: uint16(35978),
		182: uint16(35973),
		183: uint16(35992),
		184: uint16(35988),
		185: uint16(26011),
		186: uint16(35286),
		187: uint16(35294),
		188: uint16(35290),
		189: uint16(35292),
	},
	117: {
		0:   uint16(39900),
		1:   uint16(39901),
		2:   uint16(39902),
		3:   uint16(39903),
		4:   uint16(39904),
		5:   uint16(39905),
		6:   uint16(39906),
		7:   uint16(39907),
		8:   uint16(39908),
		9:   uint16(39909),
		10:  uint16(39910),
		11:  uint16(39911),
		12:  uint16(39912),
		13:  uint16(39913),
		14:  uint16(39914),
		15:  uint16(39915),
		16:  uint16(39916),
		17:  uint16(39917),
		18:  uint16(39918),
		19:  uint16(39919),
		20:  uint16(39920),
		21:  uint16(39921),
		22:  uint16(39922),
		23:  uint16(39923),
		24:  uint16(39924),
		25:  uint16(39925),
		26:  uint16(39926),
		27:  uint16(39927),
		28:  uint16(39928),
		29:  uint16(39929),
		30:  uint16(39930),
		31:  uint16(39931),
		32:  uint16(39932),
		33:  uint16(39933),
		34:  uint16(39934),
		35:  uint16(39935),
		36:  uint16(39936),
		37:  uint16(39937),
		38:  uint16(39938),
		39:  uint16(39939),
		40:  uint16(39940),
		41:  uint16(39941),
		42:  uint16(39942),
		43:  uint16(39943),
		44:  uint16(39944),
		45:  uint16(39945),
		46:  uint16(39946),
		47:  uint16(39947),
		48:  uint16(39948),
		49:  uint16(39949),
		50:  uint16(39950),
		51:  uint16(39951),
		52:  uint16(39952),
		53:  uint16(39953),
		54:  uint16(39954),
		55:  uint16(39955),
		56:  uint16(39956),
		57:  uint16(39957),
		58:  uint16(39958),
		59:  uint16(39959),
		60:  uint16(39960),
		61:  uint16(39961),
		62:  uint16(39962),
		63:  uint16(39963),
		64:  uint16(39964),
		65:  uint16(39965),
		66:  uint16(39966),
		67:  uint16(39967),
		68:  uint16(39968),
		69:  uint16(39969),
		70:  uint16(39970),
		71:  uint16(39971),
		72:  uint16(39972),
		73:  uint16(39973),
		74:  uint16(39974),
		75:  uint16(39975),
		76:  uint16(39976),
		77:  uint16(39977),
		78:  uint16(39978),
		79:  uint16(39979),
		80:  uint16(39980),
		81:  uint16(39981),
		82:  uint16(39982),
		83:  uint16(39983),
		84:  uint16(39984),
		85:  uint16(39985),
		86:  uint16(39986),
		87:  uint16(39987),
		88:  uint16(39988),
		89:  uint16(39989),
		90:  uint16(39990),
		91:  uint16(39991),
		92:  uint16(39992),
		93:  uint16(39993),
		94:  uint16(39994),
		95:  uint16(39995),
		96:  uint16(35301),
		97:  uint16(35307),
		98:  uint16(35311),
		99:  uint16(35390),
		100: uint16(35622),
		101: uint16(38739),
		102: uint16(38633),
		103: uint16(38643),
		104: uint16(38639),
		105: uint16(38662),
		106: uint16(38657),
		107: uint16(38664),
		108: uint16(38671),
		109: uint16(38670),
		110: uint16(38698),
		111: uint16(38701),
		112: uint16(38704),
		113: uint16(38718),
		114: uint16(40832),
		115: uint16(40835),
		116: uint16(40837),
		117: uint16(40838),
		118: uint16(40839),
		119: uint16(40840),
		120: uint16(40841),
		121: uint16(40842),
		122: uint16(40844),
		123: uint16(40702),
		124: uint16(40715),
		125: uint16(40717),
		126: uint16(38585),
		127: uint16(38588),
		128: uint16(38589),
		129: uint16(38606),
		130: uint16(38610),
		131: uint16(30655),
		132: uint16(38624),
		133: uint16(37518),
		134: uint16(37550),
		135: uint16(37576),
		136: uint16(37694),
		137: uint16(37738),
		138: uint16(37834),
		139: uint16(37775),
		140: uint16(37950),
		141: uint16(37995),
		142: uint16(40063),
		143: uint16(40066),
		144: uint16(40069),
		145: uint16(40070),
		146: uint16(40071),
		147: uint16(40072),
		148: uint16(31267),
		149: uint16(40075),
		150: uint16(40078),
		151: uint16(40080),
		152: uint16(40081),
		153: uint16(40082),
		154: uint16(40084),
		155: uint16(40085),
		156: uint16(40090),
		157: uint16(40091),
		158: uint16(40094),
		159: uint16(40095),
		160: uint16(40096),
		161: uint16(40097),
		162: uint16(40098),
		163: uint16(40099),
		164: uint16(40101),
		165: uint16(40102),
		166: uint16(40103),
		167: uint16(40104),
		168: uint16(40105),
		169: uint16(40107),
		170: uint16(40109),
		171: uint16(40110),
		172: uint16(40112),
		173: uint16(40113),
		174: uint16(40114),
		175: uint16(40115),
		176: uint16(40116),
		177: uint16(40117),
		178: uint16(40118),
		179: uint16(40119),
		180: uint16(40122),
		181: uint16(40123),
		182: uint16(40124),
		183: uint16(40125),
		184: uint16(40132),
		185: uint16(40133),
		186: uint16(40134),
		187: uint16(40135),
		188: uint16(40138),
		189: uint16(40139),
	},
	118: {
		0:   uint16(39996),
		1:   uint16(39997),
		2:   uint16(39998),
		3:   uint16(39999),
		4:   uint16(40000),
		5:   uint16(40001),
		6:   uint16(40002),
		7:   uint16(40003),
		8:   uint16(40004),
		9:   uint16(40005),
		10:  uint16(40006),
		11:  uint16(40007),
		12:  uint16(40008),
		13:  uint16(40009),
		14:  uint16(40010),
		15:  uint16(40011),
		16:  uint16(40012),
		17:  uint16(40013),
		18:  uint16(40014),
		19:  uint16(40015),
		20:  uint16(40016),
		21:  uint16(40017),
		22:  uint16(40018),
		23:  uint16(40019),
		24:  uint16(40020),
		25:  uint16(40021),
		26:  uint16(40022),
		27:  uint16(40023),
		28:  uint16(40024),
		29:  uint16(40025),
		30:  uint16(40026),
		31:  uint16(40027),
		32:  uint16(40028),
		33:  uint16(40029),
		34:  uint16(40030),
		35:  uint16(40031),
		36:  uint16(40032),
		37:  uint16(40033),
		38:  uint16(40034),
		39:  uint16(40035),
		40:  uint16(40036),
		41:  uint16(40037),
		42:  uint16(40038),
		43:  uint16(40039),
		44:  uint16(40040),
		45:  uint16(40041),
		46:  uint16(40042),
		47:  uint16(40043),
		48:  uint16(40044),
		49:  uint16(40045),
		50:  uint16(40046),
		51:  uint16(40047),
		52:  uint16(40048),
		53:  uint16(40049),
		54:  uint16(40050),
		55:  uint16(40051),
		56:  uint16(40052),
		57:  uint16(40053),
		58:  uint16(40054),
		59:  uint16(40055),
		60:  uint16(40056),
		61:  uint16(40057),
		62:  uint16(40058),
		63:  uint16(40059),
		64:  uint16(40061),
		65:  uint16(40062),
		66:  uint16(40064),
		67:  uint16(40067),
		68:  uint16(40068),
		69:  uint16(40073),
		70:  uint16(40074),
		71:  uint16(40076),
		72:  uint16(40079),
		73:  uint16(40083),
		74:  uint16(40086),
		75:  uint16(40087),
		76:  uint16(40088),
		77:  uint16(40089),
		78:  uint16(40093),
		79:  uint16(40106),
		80:  uint16(40108),
		81:  uint16(40111),
		82:  uint16(40121),
		83:  uint16(40126),
		84:  uint16(40127),
		85:  uint16(40128),
		86:  uint16(40129),
		87:  uint16(40130),
		88:  uint16(40136),
		89:  uint16(40137),
		90:  uint16(40145),
		91:  uint16(40146),
		92:  uint16(40154),
		93:  uint16(40155),
		94:  uint16(40160),
		95:  uint16(40161),
		96:  uint16(40140),
		97:  uint16(40141),
		98:  uint16(40142),
		99:  uint16(40143),
		100: uint16(40144),
		101: uint16(40147),
		102: uint16(40148),
		103: uint16(40149),
		104: uint16(40151),
		105: uint16(40152),
		106: uint16(40153),
		107: uint16(40156),
		108: uint16(40157),
		109: uint16(40159),
		110: uint16(40162),
		111: uint16(38780),
		112: uint16(38789),
		113: uint16(38801),
		114: uint16(38802),
		115: uint16(38804),
		116: uint16(38831),
		117: uint16(38827),
		118: uint16(38819),
		119: uint16(38834),
		120: uint16(38836),
		121: uint16(39601),
		122: uint16(39600),
		123: uint16(39607),
		124: uint16(40536),
		125: uint16(39606),
		126: uint16(39610),
		127: uint16(39612),
		128: uint16(39617),
		129: uint16(39616),
		130: uint16(39621),
		131: uint16(39618),
		132: uint16(39627),
		133: uint16(39628),
		134: uint16(39633),
		135: uint16(39749),
		136: uint16(39747),
		137: uint16(39751),
		138: uint16(39753),
		139: uint16(39752),
		140: uint16(39757),
		141: uint16(39761),
		142: uint16(39144),
		143: uint16(39181),
		144: uint16(39214),
		145: uint16(39253),
		146: uint16(39252),
		147: uint16(39647),
		148: uint16(39649),
		149: uint16(39654),
		150: uint16(39663),
		151: uint16(39659),
		152: uint16(39675),
		153: uint16(39661),
		154: uint16(39673),
		155: uint16(39688),
		156: uint16(39695),
		157: uint16(39699),
		158: uint16(39711),
		159: uint16(39715),
		160: uint16(40637),
		161: uint16(40638),
		162: uint16(32315),
		163: uint16(40578),
		164: uint16(40583),
		165: uint16(40584),
		166: uint16(40587),
		167: uint16(40594),
		168: uint16(37846),
		169: uint16(40605),
		170: uint16(40607),
		171: uint16(40667),
		172: uint16(40668),
		173: uint16(40669),
		174: uint16(40672),
		175: uint16(40671),
		176: uint16(40674),
		177: uint16(40681),
		178: uint16(40679),
		179: uint16(40677),
		180: uint16(40682),
		181: uint16(40687),
		182: uint16(40738),
		183: uint16(40748),
		184: uint16(40751),
		185: uint16(40761),
		186: uint16(40759),
		187: uint16(40765),
		188: uint16(40766),
		189: uint16(40772),
	},
	119: {
		0:   uint16(40163),
		1:   uint16(40164),
		2:   uint16(40165),
		3:   uint16(40166),
		4:   uint16(40167),
		5:   uint16(40168),
		6:   uint16(40169),
		7:   uint16(40170),
		8:   uint16(40171),
		9:   uint16(40172),
		10:  uint16(40173),
		11:  uint16(40174),
		12:  uint16(40175),
		13:  uint16(40176),
		14:  uint16(40177),
		15:  uint16(40178),
		16:  uint16(40179),
		17:  uint16(40180),
		18:  uint16(40181),
		19:  uint16(40182),
		20:  uint16(40183),
		21:  uint16(40184),
		22:  uint16(40185),
		23:  uint16(40186),
		24:  uint16(40187),
		25:  uint16(40188),
		26:  uint16(40189),
		27:  uint16(40190),
		28:  uint16(40191),
		29:  uint16(40192),
		30:  uint16(40193),
		31:  uint16(40194),
		32:  uint16(40195),
		33:  uint16(40196),
		34:  uint16(40197),
		35:  uint16(40198),
		36:  uint16(40199),
		37:  uint16(40200),
		38:  uint16(40201),
		39:  uint16(40202),
		40:  uint16(40203),
		41:  uint16(40204),
		42:  uint16(40205),
		43:  uint16(40206),
		44:  uint16(40207),
		45:  uint16(40208),
		46:  uint16(40209),
		47:  uint16(40210),
		48:  uint16(40211),
		49:  uint16(40212),
		50:  uint16(40213),
		51:  uint16(40214),
		52:  uint16(40215),
		53:  uint16(40216),
		54:  uint16(40217),
		55:  uint16(40218),
		56:  uint16(40219),
		57:  uint16(40220),
		58:  uint16(40221),
		59:  uint16(40222),
		60:  uint16(40223),
		61:  uint16(40224),
		62:  uint16(40225),
		63:  uint16(40226),
		64:  uint16(40227),
		65:  uint16(40228),
		66:  uint16(40229),
		67:  uint16(40230),
		68:  uint16(40231),
		69:  uint16(40232),
		70:  uint16(40233),
		71:  uint16(40234),
		72:  uint16(40235),
		73:  uint16(40236),
		74:  uint16(40237),
		75:  uint16(40238),
		76:  uint16(40239),
		77:  uint16(40240),
		78:  uint16(40241),
		79:  uint16(40242),
		80:  uint16(40243),
		81:  uint16(40244),
		82:  uint16(40245),
		83:  uint16(40246),
		84:  uint16(40247),
		85:  uint16(40248),
		86:  uint16(40249),
		87:  uint16(40250),
		88:  uint16(40251),
		89:  uint16(40252),
		90:  uint16(40253),
		91:  uint16(40254),
		92:  uint16(40255),
		93:  uint16(40256),
		94:  uint16(40257),
		95:  uint16(40258),
		96:  uint16(57908),
		97:  uint16(57909),
		98:  uint16(57910),
		99:  uint16(57911),
		100: uint16(57912),
		101: uint16(57913),
		102: uint16(57914),
		103: uint16(57915),
		104: uint16(57916),
		105: uint16(57917),
		106: uint16(57918),
		107: uint16(57919),
		108: uint16(57920),
		109: uint16(57921),
		110: uint16(57922),
		111: uint16(57923),
		112: uint16(57924),
		113: uint16(57925),
		114: uint16(57926),
		115: uint16(57927),
		116: uint16(57928),
		117: uint16(57929),
		118: uint16(57930),
		119: uint16(57931),
		120: uint16(57932),
		121: uint16(57933),
		122: uint16(57934),
		123: uint16(57935),
		124: uint16(57936),
		125: uint16(57937),
		126: uint16(57938),
		127: uint16(57939),
		128: uint16(57940),
		129: uint16(57941),
		130: uint16(57942),
		131: uint16(57943),
		132: uint16(57944),
		133: uint16(57945),
		134: uint16(57946),
		135: uint16(57947),
		136: uint16(57948),
		137: uint16(57949),
		138: uint16(57950),
		139: uint16(57951),
		140: uint16(57952),
		141: uint16(57953),
		142: uint16(57954),
		143: uint16(57955),
		144: uint16(57956),
		145: uint16(57957),
		146: uint16(57958),
		147: uint16(57959),
		148: uint16(57960),
		149: uint16(57961),
		150: uint16(57962),
		151: uint16(57963),
		152: uint16(57964),
		153: uint16(57965),
		154: uint16(57966),
		155: uint16(57967),
		156: uint16(57968),
		157: uint16(57969),
		158: uint16(57970),
		159: uint16(57971),
		160: uint16(57972),
		161: uint16(57973),
		162: uint16(57974),
		163: uint16(57975),
		164: uint16(57976),
		165: uint16(57977),
		166: uint16(57978),
		167: uint16(57979),
		168: uint16(57980),
		169: uint16(57981),
		170: uint16(57982),
		171: uint16(57983),
		172: uint16(57984),
		173: uint16(57985),
		174: uint16(57986),
		175: uint16(57987),
		176: uint16(57988),
		177: uint16(57989),
		178: uint16(57990),
		179: uint16(57991),
		180: uint16(57992),
		181: uint16(57993),
		182: uint16(57994),
		183: uint16(57995),
		184: uint16(57996),
		185: uint16(57997),
		186: uint16(57998),
		187: uint16(57999),
		188: uint16(58000),
		189: uint16(58001),
	},
	120: {
		0:   uint16(40259),
		1:   uint16(40260),
		2:   uint16(40261),
		3:   uint16(40262),
		4:   uint16(40263),
		5:   uint16(40264),
		6:   uint16(40265),
		7:   uint16(40266),
		8:   uint16(40267),
		9:   uint16(40268),
		10:  uint16(40269),
		11:  uint16(40270),
		12:  uint16(40271),
		13:  uint16(40272),
		14:  uint16(40273),
		15:  uint16(40274),
		16:  uint16(40275),
		17:  uint16(40276),
		18:  uint16(40277),
		19:  uint16(40278),
		20:  uint16(40279),
		21:  uint16(40280),
		22:  uint16(40281),
		23:  uint16(40282),
		24:  uint16(40283),
		25:  uint16(40284),
		26:  uint16(40285),
		27:  uint16(40286),
		28:  uint16(40287),
		29:  uint16(40288),
		30:  uint16(40289),
		31:  uint16(40290),
		32:  uint16(40291),
		33:  uint16(40292),
		34:  uint16(40293),
		35:  uint16(40294),
		36:  uint16(40295),
		37:  uint16(40296),
		38:  uint16(40297),
		39:  uint16(40298),
		40:  uint16(40299),
		41:  uint16(40300),
		42:  uint16(40301),
		43:  uint16(40302),
		44:  uint16(40303),
		45:  uint16(40304),
		46:  uint16(40305),
		47:  uint16(40306),
		48:  uint16(40307),
		49:  uint16(40308),
		50:  uint16(40309),
		51:  uint16(40310),
		52:  uint16(40311),
		53:  uint16(40312),
		54:  uint16(40313),
		55:  uint16(40314),
		56:  uint16(40315),
		57:  uint16(40316),
		58:  uint16(40317),
		59:  uint16(40318),
		60:  uint16(40319),
		61:  uint16(40320),
		62:  uint16(40321),
		63:  uint16(40322),
		64:  uint16(40323),
		65:  uint16(40324),
		66:  uint16(40325),
		67:  uint16(40326),
		68:  uint16(40327),
		69:  uint16(40328),
		70:  uint16(40329),
		71:  uint16(40330),
		72:  uint16(40331),
		73:  uint16(40332),
		74:  uint16(40333),
		75:  uint16(40334),
		76:  uint16(40335),
		77:  uint16(40336),
		78:  uint16(40337),
		79:  uint16(40338),
		80:  uint16(40339),
		81:  uint16(40340),
		82:  uint16(40341),
		83:  uint16(40342),
		84:  uint16(40343),
		85:  uint16(40344),
		86:  uint16(40345),
		87:  uint16(40346),
		88:  uint16(40347),
		89:  uint16(40348),
		90:  uint16(40349),
		91:  uint16(40350),
		92:  uint16(40351),
		93:  uint16(40352),
		94:  uint16(40353),
		95:  uint16(40354),
		96:  uint16(58002),
		97:  uint16(58003),
		98:  uint16(58004),
		99:  uint16(58005),
		100: uint16(58006),
		101: uint16(58007),
		102: uint16(58008),
		103: uint16(58009),
		104: uint16(58010),
		105: uint16(58011),
		106: uint16(58012),
		107: uint16(58013),
		108: uint16(58014),
		109: uint16(58015),
		110: uint16(58016),
		111: uint16(58017),
		112: uint16(58018),
		113: uint16(58019),
		114: uint16(58020),
		115: uint16(58021),
		116: uint16(58022),
		117: uint16(58023),
		118: uint16(58024),
		119: uint16(58025),
		120: uint16(58026),
		121: uint16(58027),
		122: uint16(58028),
		123: uint16(58029),
		124: uint16(58030),
		125: uint16(58031),
		126: uint16(58032),
		127: uint16(58033),
		128: uint16(58034),
		129: uint16(58035),
		130: uint16(58036),
		131: uint16(58037),
		132: uint16(58038),
		133: uint16(58039),
		134: uint16(58040),
		135: uint16(58041),
		136: uint16(58042),
		137: uint16(58043),
		138: uint16(58044),
		139: uint16(58045),
		140: uint16(58046),
		141: uint16(58047),
		142: uint16(58048),
		143: uint16(58049),
		144: uint16(58050),
		145: uint16(58051),
		146: uint16(58052),
		147: uint16(58053),
		148: uint16(58054),
		149: uint16(58055),
		150: uint16(58056),
		151: uint16(58057),
		152: uint16(58058),
		153: uint16(58059),
		154: uint16(58060),
		155: uint16(58061),
		156: uint16(58062),
		157: uint16(58063),
		158: uint16(58064),
		159: uint16(58065),
		160: uint16(58066),
		161: uint16(58067),
		162: uint16(58068),
		163: uint16(58069),
		164: uint16(58070),
		165: uint16(58071),
		166: uint16(58072),
		167: uint16(58073),
		168: uint16(58074),
		169: uint16(58075),
		170: uint16(58076),
		171: uint16(58077),
		172: uint16(58078),
		173: uint16(58079),
		174: uint16(58080),
		175: uint16(58081),
		176: uint16(58082),
		177: uint16(58083),
		178: uint16(58084),
		179: uint16(58085),
		180: uint16(58086),
		181: uint16(58087),
		182: uint16(58088),
		183: uint16(58089),
		184: uint16(58090),
		185: uint16(58091),
		186: uint16(58092),
		187: uint16(58093),
		188: uint16(58094),
		189: uint16(58095),
	},
	121: {
		0:   uint16(40355),
		1:   uint16(40356),
		2:   uint16(40357),
		3:   uint16(40358),
		4:   uint16(40359),
		5:   uint16(40360),
		6:   uint16(40361),
		7:   uint16(40362),
		8:   uint16(40363),
		9:   uint16(40364),
		10:  uint16(40365),
		11:  uint16(40366),
		12:  uint16(40367),
		13:  uint16(40368),
		14:  uint16(40369),
		15:  uint16(40370),
		16:  uint16(40371),
		17:  uint16(40372),
		18:  uint16(40373),
		19:  uint16(40374),
		20:  uint16(40375),
		21:  uint16(40376),
		22:  uint16(40377),
		23:  uint16(40378),
		24:  uint16(40379),
		25:  uint16(40380),
		26:  uint16(40381),
		27:  uint16(40382),
		28:  uint16(40383),
		29:  uint16(40384),
		30:  uint16(40385),
		31:  uint16(40386),
		32:  uint16(40387),
		33:  uint16(40388),
		34:  uint16(40389),
		35:  uint16(40390),
		36:  uint16(40391),
		37:  uint16(40392),
		38:  uint16(40393),
		39:  uint16(40394),
		40:  uint16(40395),
		41:  uint16(40396),
		42:  uint16(40397),
		43:  uint16(40398),
		44:  uint16(40399),
		45:  uint16(40400),
		46:  uint16(40401),
		47:  uint16(40402),
		48:  uint16(40403),
		49:  uint16(40404),
		50:  uint16(40405),
		51:  uint16(40406),
		52:  uint16(40407),
		53:  uint16(40408),
		54:  uint16(40409),
		55:  uint16(40410),
		56:  uint16(40411),
		57:  uint16(40412),
		58:  uint16(40413),
		59:  uint16(40414),
		60:  uint16(40415),
		61:  uint16(40416),
		62:  uint16(40417),
		63:  uint16(40418),
		64:  uint16(40419),
		65:  uint16(40420),
		66:  uint16(40421),
		67:  uint16(40422),
		68:  uint16(40423),
		69:  uint16(40424),
		70:  uint16(40425),
		71:  uint16(40426),
		72:  uint16(40427),
		73:  uint16(40428),
		74:  uint16(40429),
		75:  uint16(40430),
		76:  uint16(40431),
		77:  uint16(40432),
		78:  uint16(40433),
		79:  uint16(40434),
		80:  uint16(40435),
		81:  uint16(40436),
		82:  uint16(40437),
		83:  uint16(40438),
		84:  uint16(40439),
		85:  uint16(40440),
		86:  uint16(40441),
		87:  uint16(40442),
		88:  uint16(40443),
		89:  uint16(40444),
		90:  uint16(40445),
		91:  uint16(40446),
		92:  uint16(40447),
		93:  uint16(40448),
		94:  uint16(40449),
		95:  uint16(40450),
		96:  uint16(58096),
		97:  uint16(58097),
		98:  uint16(58098),
		99:  uint16(58099),
		100: uint16(58100),
		101: uint16(58101),
		102: uint16(58102),
		103: uint16(58103),
		104: uint16(58104),
		105: uint16(58105),
		106: uint16(58106),
		107: uint16(58107),
		108: uint16(58108),
		109: uint16(58109),
		110: uint16(58110),
		111: uint16(58111),
		112: uint16(58112),
		113: uint16(58113),
		114: uint16(58114),
		115: uint16(58115),
		116: uint16(58116),
		117: uint16(58117),
		118: uint16(58118),
		119: uint16(58119),
		120: uint16(58120),
		121: uint16(58121),
		122: uint16(58122),
		123: uint16(58123),
		124: uint16(58124),
		125: uint16(58125),
		126: uint16(58126),
		127: uint16(58127),
		128: uint16(58128),
		129: uint16(58129),
		130: uint16(58130),
		131: uint16(58131),
		132: uint16(58132),
		133: uint16(58133),
		134: uint16(58134),
		135: uint16(58135),
		136: uint16(58136),
		137: uint16(58137),
		138: uint16(58138),
		139: uint16(58139),
		140: uint16(58140),
		141: uint16(58141),
		142: uint16(58142),
		143: uint16(58143),
		144: uint16(58144),
		145: uint16(58145),
		146: uint16(58146),
		147: uint16(58147),
		148: uint16(58148),
		149: uint16(58149),
		150: uint16(58150),
		151: uint16(58151),
		152: uint16(58152),
		153: uint16(58153),
		154: uint16(58154),
		155: uint16(58155),
		156: uint16(58156),
		157: uint16(58157),
		158: uint16(58158),
		159: uint16(58159),
		160: uint16(58160),
		161: uint16(58161),
		162: uint16(58162),
		163: uint16(58163),
		164: uint16(58164),
		165: uint16(58165),
		166: uint16(58166),
		167: uint16(58167),
		168: uint16(58168),
		169: uint16(58169),
		170: uint16(58170),
		171: uint16(58171),
		172: uint16(58172),
		173: uint16(58173),
		174: uint16(58174),
		175: uint16(58175),
		176: uint16(58176),
		177: uint16(58177),
		178: uint16(58178),
		179: uint16(58179),
		180: uint16(58180),
		181: uint16(58181),
		182: uint16(58182),
		183: uint16(58183),
		184: uint16(58184),
		185: uint16(58185),
		186: uint16(58186),
		187: uint16(58187),
		188: uint16(58188),
		189: uint16(58189),
	},
	122: {
		0:   uint16(40451),
		1:   uint16(40452),
		2:   uint16(40453),
		3:   uint16(40454),
		4:   uint16(40455),
		5:   uint16(40456),
		6:   uint16(40457),
		7:   uint16(40458),
		8:   uint16(40459),
		9:   uint16(40460),
		10:  uint16(40461),
		11:  uint16(40462),
		12:  uint16(40463),
		13:  uint16(40464),
		14:  uint16(40465),
		15:  uint16(40466),
		16:  uint16(40467),
		17:  uint16(40468),
		18:  uint16(40469),
		19:  uint16(40470),
		20:  uint16(40471),
		21:  uint16(40472),
		22:  uint16(40473),
		23:  uint16(40474),
		24:  uint16(40475),
		25:  uint16(40476),
		26:  uint16(40477),
		27:  uint16(40478),
		28:  uint16(40484),
		29:  uint16(40487),
		30:  uint16(40494),
		31:  uint16(40496),
		32:  uint16(40500),
		33:  uint16(40507),
		34:  uint16(40508),
		35:  uint16(40512),
		36:  uint16(40525),
		37:  uint16(40528),
		38:  uint16(40530),
		39:  uint16(40531),
		40:  uint16(40532),
		41:  uint16(40534),
		42:  uint16(40537),
		43:  uint16(40541),
		44:  uint16(40543),
		45:  uint16(40544),
		46:  uint16(40545),
		47:  uint16(40546),
		48:  uint16(40549),
		49:  uint16(40558),
		50:  uint16(40559),
		51:  uint16(40562),
		52:  uint16(40564),
		53:  uint16(40565),
		54:  uint16(40566),
		55:  uint16(40567),
		56:  uint16(40568),
		57:  uint16(40569),
		58:  uint16(40570),
		59:  uint16(40571),
		60:  uint16(40572),
		61:  uint16(40573),
		62:  uint16(40576),
		63:  uint16(40577),
		64:  uint16(40579),
		65:  uint16(40580),
		66:  uint16(40581),
		67:  uint16(40582),
		68:  uint16(40585),
		69:  uint16(40586),
		70:  uint16(40588),
		71:  uint16(40589),
		72:  uint16(40590),
		73:  uint16(40591),
		74:  uint16(40592),
		75:  uint16(40593),
		76:  uint16(40596),
		77:  uint16(40597),
		78:  uint16(40598),
		79:  uint16(40599),
		80:  uint16(40600),
		81:  uint16(40601),
		82:  uint16(40602),
		83:  uint16(40603),
		84:  uint16(40604),
		85:  uint16(40606),
		86:  uint16(40608),
		87:  uint16(40609),
		88:  uint16(40610),
		89:  uint16(40611),
		90:  uint16(40612),
		91:  uint16(40613),
		92:  uint16(40615),
		93:  uint16(40616),
		94:  uint16(40617),
		95:  uint16(40618),
		96:  uint16(58190),
		97:  uint16(58191),
		98:  uint16(58192),
		99:  uint16(58193),
		100: uint16(58194),
		101: uint16(58195),
		102: uint16(58196),
		103: uint16(58197),
		104: uint16(58198),
		105: uint16(58199),
		106: uint16(58200),
		107: uint16(58201),
		108: uint16(58202),
		109: uint16(58203),
		110: uint16(58204),
		111: uint16(58205),
		112: uint16(58206),
		113: uint16(58207),
		114: uint16(58208),
		115: uint16(58209),
		116: uint16(58210),
		117: uint16(58211),
		118: uint16(58212),
		119: uint16(58213),
		120: uint16(58214),
		121: uint16(58215),
		122: uint16(58216),
		123: uint16(58217),
		124: uint16(58218),
		125: uint16(58219),
		126: uint16(58220),
		127: uint16(58221),
		128: uint16(58222),
		129: uint16(58223),
		130: uint16(58224),
		131: uint16(58225),
		132: uint16(58226),
		133: uint16(58227),
		134: uint16(58228),
		135: uint16(58229),
		136: uint16(58230),
		137: uint16(58231),
		138: uint16(58232),
		139: uint16(58233),
		140: uint16(58234),
		141: uint16(58235),
		142: uint16(58236),
		143: uint16(58237),
		144: uint16(58238),
		145: uint16(58239),
		146: uint16(58240),
		147: uint16(58241),
		148: uint16(58242),
		149: uint16(58243),
		150: uint16(58244),
		151: uint16(58245),
		152: uint16(58246),
		153: uint16(58247),
		154: uint16(58248),
		155: uint16(58249),
		156: uint16(58250),
		157: uint16(58251),
		158: uint16(58252),
		159: uint16(58253),
		160: uint16(58254),
		161: uint16(58255),
		162: uint16(58256),
		163: uint16(58257),
		164: uint16(58258),
		165: uint16(58259),
		166: uint16(58260),
		167: uint16(58261),
		168: uint16(58262),
		169: uint16(58263),
		170: uint16(58264),
		171: uint16(58265),
		172: uint16(58266),
		173: uint16(58267),
		174: uint16(58268),
		175: uint16(58269),
		176: uint16(58270),
		177: uint16(58271),
		178: uint16(58272),
		179: uint16(58273),
		180: uint16(58274),
		181: uint16(58275),
		182: uint16(58276),
		183: uint16(58277),
		184: uint16(58278),
		185: uint16(58279),
		186: uint16(58280),
		187: uint16(58281),
		188: uint16(58282),
		189: uint16(58283),
	},
	123: {
		0:   uint16(40619),
		1:   uint16(40620),
		2:   uint16(40621),
		3:   uint16(40622),
		4:   uint16(40623),
		5:   uint16(40624),
		6:   uint16(40625),
		7:   uint16(40626),
		8:   uint16(40627),
		9:   uint16(40629),
		10:  uint16(40630),
		11:  uint16(40631),
		12:  uint16(40633),
		13:  uint16(40634),
		14:  uint16(40636),
		15:  uint16(40639),
		16:  uint16(40640),
		17:  uint16(40641),
		18:  uint16(40642),
		19:  uint16(40643),
		20:  uint16(40645),
		21:  uint16(40646),
		22:  uint16(40647),
		23:  uint16(40648),
		24:  uint16(40650),
		25:  uint16(40651),
		26:  uint16(40652),
		27:  uint16(40656),
		28:  uint16(40658),
		29:  uint16(40659),
		30:  uint16(40661),
		31:  uint16(40662),
		32:  uint16(40663),
		33:  uint16(40665),
		34:  uint16(40666),
		35:  uint16(40670),
		36:  uint16(40673),
		37:  uint16(40675),
		38:  uint16(40676),
		39:  uint16(40678),
		40:  uint16(40680),
		41:  uint16(40683),
		42:  uint16(40684),
		43:  uint16(40685),
		44:  uint16(40686),
		45:  uint16(40688),
		46:  uint16(40689),
		47:  uint16(40690),
		48:  uint16(40691),
		49:  uint16(40692),
		50:  uint16(40693),
		51:  uint16(40694),
		52:  uint16(40695),
		53:  uint16(40696),
		54:  uint16(40698),
		55:  uint16(40701),
		56:  uint16(40703),
		57:  uint16(40704),
		58:  uint16(40705),
		59:  uint16(40706),
		60:  uint16(40707),
		61:  uint16(40708),
		62:  uint16(40709),
		63:  uint16(40710),
		64:  uint16(40711),
		65:  uint16(40712),
		66:  uint16(40713),
		67:  uint16(40714),
		68:  uint16(40716),
		69:  uint16(40719),
		70:  uint16(40721),
		71:  uint16(40722),
		72:  uint16(40724),
		73:  uint16(40725),
		74:  uint16(40726),
		75:  uint16(40728),
		76:  uint16(40730),
		77:  uint16(40731),
		78:  uint16(40732),
		79:  uint16(40733),
		80:  uint16(40734),
		81:  uint16(40735),
		82:  uint16(40737),
		83:  uint16(40739),
		84:  uint16(40740),
		85:  uint16(40741),
		86:  uint16(40742),
		87:  uint16(40743),
		88:  uint16(40744),
		89:  uint16(40745),
		90:  uint16(40746),
		91:  uint16(40747),
		92:  uint16(40749),
		93:  uint16(40750),
		94:  uint16(40752),
		95:  uint16(40753),
		96:  uint16(58284),
		97:  uint16(58285),
		98:  uint16(58286),
		99:  uint16(58287),
		100: uint16(58288),
		101: uint16(58289),
		102: uint16(58290),
		103: uint16(58291),
		104: uint16(58292),
		105: uint16(58293),
		106: uint16(58294),
		107: uint16(58295),
		108: uint16(58296),
		109: uint16(58297),
		110: uint16(58298),
		111: uint16(58299),
		112: uint16(58300),
		113: uint16(58301),
		114: uint16(58302),
		115: uint16(58303),
		116: uint16(58304),
		117: uint16(58305),
		118: uint16(58306),
		119: uint16(58307),
		120: uint16(58308),
		121: uint16(58309),
		122: uint16(58310),
		123: uint16(58311),
		124: uint16(58312),
		125: uint16(58313),
		126: uint16(58314),
		127: uint16(58315),
		128: uint16(58316),
		129: uint16(58317),
		130: uint16(58318),
		131: uint16(58319),
		132: uint16(58320),
		133: uint16(58321),
		134: uint16(58322),
		135: uint16(58323),
		136: uint16(58324),
		137: uint16(58325),
		138: uint16(58326),
		139: uint16(58327),
		140: uint16(58328),
		141: uint16(58329),
		142: uint16(58330),
		143: uint16(58331),
		144: uint16(58332),
		145: uint16(58333),
		146: uint16(58334),
		147: uint16(58335),
		148: uint16(58336),
		149: uint16(58337),
		150: uint16(58338),
		151: uint16(58339),
		152: uint16(58340),
		153: uint16(58341),
		154: uint16(58342),
		155: uint16(58343),
		156: uint16(58344),
		157: uint16(58345),
		158: uint16(58346),
		159: uint16(58347),
		160: uint16(58348),
		161: uint16(58349),
		162: uint16(58350),
		163: uint16(58351),
		164: uint16(58352),
		165: uint16(58353),
		166: uint16(58354),
		167: uint16(58355),
		168: uint16(58356),
		169: uint16(58357),
		170: uint16(58358),
		171: uint16(58359),
		172: uint16(58360),
		173: uint16(58361),
		174: uint16(58362),
		175: uint16(58363),
		176: uint16(58364),
		177: uint16(58365),
		178: uint16(58366),
		179: uint16(58367),
		180: uint16(58368),
		181: uint16(58369),
		182: uint16(58370),
		183: uint16(58371),
		184: uint16(58372),
		185: uint16(58373),
		186: uint16(58374),
		187: uint16(58375),
		188: uint16(58376),
		189: uint16(58377),
	},
	124: {
		0:   uint16(40754),
		1:   uint16(40755),
		2:   uint16(40756),
		3:   uint16(40757),
		4:   uint16(40758),
		5:   uint16(40760),
		6:   uint16(40762),
		7:   uint16(40764),
		8:   uint16(40767),
		9:   uint16(40768),
		10:  uint16(40769),
		11:  uint16(40770),
		12:  uint16(40771),
		13:  uint16(40773),
		14:  uint16(40774),
		15:  uint16(40775),
		16:  uint16(40776),
		17:  uint16(40777),
		18:  uint16(40778),
		19:  uint16(40779),
		20:  uint16(40780),
		21:  uint16(40781),
		22:  uint16(40782),
		23:  uint16(40783),
		24:  uint16(40786),
		25:  uint16(40787),
		26:  uint16(40788),
		27:  uint16(40789),
		28:  uint16(40790),
		29:  uint16(40791),
		30:  uint16(40792),
		31:  uint16(40793),
		32:  uint16(40794),
		33:  uint16(40795),
		34:  uint16(40796),
		35:  uint16(40797),
		36:  uint16(40798),
		37:  uint16(40799),
		38:  uint16(40800),
		39:  uint16(40801),
		40:  uint16(40802),
		41:  uint16(40803),
		42:  uint16(40804),
		43:  uint16(40805),
		44:  uint16(40806),
		45:  uint16(40807),
		46:  uint16(40808),
		47:  uint16(40809),
		48:  uint16(40810),
		49:  uint16(40811),
		50:  uint16(40812),
		51:  uint16(40813),
		52:  uint16(40814),
		53:  uint16(40815),
		54:  uint16(40816),
		55:  uint16(40817),
		56:  uint16(40818),
		57:  uint16(40819),
		58:  uint16(40820),
		59:  uint16(40821),
		60:  uint16(40822),
		61:  uint16(40823),
		62:  uint16(40824),
		63:  uint16(40825),
		64:  uint16(40826),
		65:  uint16(40827),
		66:  uint16(40828),
		67:  uint16(40829),
		68:  uint16(40830),
		69:  uint16(40833),
		70:  uint16(40834),
		71:  uint16(40845),
		72:  uint16(40846),
		73:  uint16(40847),
		74:  uint16(40848),
		75:  uint16(40849),
		76:  uint16(40850),
		77:  uint16(40851),
		78:  uint16(40852),
		79:  uint16(40853),
		80:  uint16(40854),
		81:  uint16(40855),
		82:  uint16(40856),
		83:  uint16(40860),
		84:  uint16(40861),
		85:  uint16(40862),
		86:  uint16(40865),
		87:  uint16(40866),
		88:  uint16(40867),
		89:  uint16(40868),
		90:  uint16(40869),
		91:  uint16(63788),
		92:  uint16(63865),
		93:  uint16(63893),
		94:  uint16(63975),
		95:  uint16(63985),
		96:  uint16(58378),
		97:  uint16(58379),
		98:  uint16(58380),
		99:  uint16(58381),
		100: uint16(58382),
		101: uint16(58383),
		102: uint16(58384),
		103: uint16(58385),
		104: uint16(58386),
		105: uint16(58387),
		106: uint16(58388),
		107: uint16(58389),
		108: uint16(58390),
		109: uint16(58391),
		110: uint16(58392),
		111: uint16(58393),
		112: uint16(58394),
		113: uint16(58395),
		114: uint16(58396),
		115: uint16(58397),
		116: uint16(58398),
		117: uint16(58399),
		118: uint16(58400),
		119: uint16(58401),
		120: uint16(58402),
		121: uint16(58403),
		122: uint16(58404),
		123: uint16(58405),
		124: uint16(58406),
		125: uint16(58407),
		126: uint16(58408),
		127: uint16(58409),
		128: uint16(58410),
		129: uint16(58411),
		130: uint16(58412),
		131: uint16(58413),
		132: uint16(58414),
		133: uint16(58415),
		134: uint16(58416),
		135: uint16(58417),
		136: uint16(58418),
		137: uint16(58419),
		138: uint16(58420),
		139: uint16(58421),
		140: uint16(58422),
		141: uint16(58423),
		142: uint16(58424),
		143: uint16(58425),
		144: uint16(58426),
		145: uint16(58427),
		146: uint16(58428),
		147: uint16(58429),
		148: uint16(58430),
		149: uint16(58431),
		150: uint16(58432),
		151: uint16(58433),
		152: uint16(58434),
		153: uint16(58435),
		154: uint16(58436),
		155: uint16(58437),
		156: uint16(58438),
		157: uint16(58439),
		158: uint16(58440),
		159: uint16(58441),
		160: uint16(58442),
		161: uint16(58443),
		162: uint16(58444),
		163: uint16(58445),
		164: uint16(58446),
		165: uint16(58447),
		166: uint16(58448),
		167: uint16(58449),
		168: uint16(58450),
		169: uint16(58451),
		170: uint16(58452),
		171: uint16(58453),
		172: uint16(58454),
		173: uint16(58455),
		174: uint16(58456),
		175: uint16(58457),
		176: uint16(58458),
		177: uint16(58459),
		178: uint16(58460),
		179: uint16(58461),
		180: uint16(58462),
		181: uint16(58463),
		182: uint16(58464),
		183: uint16(58465),
		184: uint16(58466),
		185: uint16(58467),
		186: uint16(58468),
		187: uint16(58469),
		188: uint16(58470),
		189: uint16(58471),
	},
	125: {
		0:   uint16(64012),
		1:   uint16(64013),
		2:   uint16(64014),
		3:   uint16(64015),
		4:   uint16(64017),
		5:   uint16(64019),
		6:   uint16(64020),
		7:   uint16(64024),
		8:   uint16(64031),
		9:   uint16(64032),
		10:  uint16(64033),
		11:  uint16(64035),
		12:  uint16(64036),
		13:  uint16(64039),
		14:  uint16(64040),
		15:  uint16(64041),
		16:  uint16(11905),
		17:  uint16(59414),
		18:  uint16(59415),
		19:  uint16(59416),
		20:  uint16(11908),
		21:  uint16(13427),
		22:  uint16(13383),
		23:  uint16(11912),
		24:  uint16(11915),
		25:  uint16(59422),
		26:  uint16(13726),
		27:  uint16(13850),
		28:  uint16(13838),
		29:  uint16(11916),
		30:  uint16(11927),
		31:  uint16(14702),
		32:  uint16(14616),
		33:  uint16(59430),
		34:  uint16(14799),
		35:  uint16(14815),
		36:  uint16(14963),
		37:  uint16(14800),
		38:  uint16(59435),
		39:  uint16(59436),
		40:  uint16(15182),
		41:  uint16(15470),
		42:  uint16(15584),
		43:  uint16(11943),
		44:  uint16(59441),
		45:  uint16(59442),
		46:  uint16(11946),
		47:  uint16(16470),
		48:  uint16(16735),
		49:  uint16(11950),
		50:  uint16(17207),
		51:  uint16(11955),
		52:  uint16(11958),
		53:  uint16(11959),
		54:  uint16(59451),
		55:  uint16(17329),
		56:  uint16(17324),
		57:  uint16(11963),
		58:  uint16(17373),
		59:  uint16(17622),
		60:  uint16(18017),
		61:  uint16(17996),
		62:  uint16(59459),
		63:  uint16(18211),
		64:  uint16(18217),
		65:  uint16(18300),
		66:  uint16(18317),
		67:  uint16(11978),
		68:  uint16(18759),
		69:  uint16(18810),
		70:  uint16(18813),
		71:  uint16(18818),
		72:  uint16(18819),
		73:  uint16(18821),
		74:  uint16(18822),
		75:  uint16(18847),
		76:  uint16(18843),
		77:  uint16(18871),
		78:  uint16(18870),
		79:  uint16(59476),
		80:  uint16(59477),
		81:  uint16(19619),
		82:  uint16(19615),
		83:  uint16(19616),
		84:  uint16(19617),
		85:  uint16(19575),
		86:  uint16(19618),
		87:  uint16(19731),
		88:  uint16(19732),
		89:  uint16(19733),
		90:  uint16(19734),
		91:  uint16(19735),
		92:  uint16(19736),
		93:  uint16(19737),
		94:  uint16(19886),
		95:  uint16(59492),
		96:  uint16(58472),
		97:  uint16(58473),
		98:  uint16(58474),
		99:  uint16(58475),
		100: uint16(58476),
		101: uint16(58477),
		102: uint16(58478),
		103: uint16(58479),
		104: uint16(58480),
		105: uint16(58481),
		106: uint16(58482),
		107: uint16(58483),
		108: uint16(58484),
		109: uint16(58485),
		110: uint16(58486),
		111: uint16(58487),
		112: uint16(58488),
		113: uint16(58489),
		114: uint16(58490),
		115: uint16(58491),
		116: uint16(58492),
		117: uint16(58493),
		118: uint16(58494),
		119: uint16(58495),
		120: uint16(58496),
		121: uint16(58497),
		122: uint16(58498),
		123: uint16(58499),
		124: uint16(58500),
		125: uint16(58501),
		126: uint16(58502),
		127: uint16(58503),
		128: uint16(58504),
		129: uint16(58505),
		130: uint16(58506),
		131: uint16(58507),
		132: uint16(58508),
		133: uint16(58509),
		134: uint16(58510),
		135: uint16(58511),
		136: uint16(58512),
		137: uint16(58513),
		138: uint16(58514),
		139: uint16(58515),
		140: uint16(58516),
		141: uint16(58517),
		142: uint16(58518),
		143: uint16(58519),
		144: uint16(58520),
		145: uint16(58521),
		146: uint16(58522),
		147: uint16(58523),
		148: uint16(58524),
		149: uint16(58525),
		150: uint16(58526),
		151: uint16(58527),
		152: uint16(58528),
		153: uint16(58529),
		154: uint16(58530),
		155: uint16(58531),
		156: uint16(58532),
		157: uint16(58533),
		158: uint16(58534),
		159: uint16(58535),
		160: uint16(58536),
		161: uint16(58537),
		162: uint16(58538),
		163: uint16(58539),
		164: uint16(58540),
		165: uint16(58541),
		166: uint16(58542),
		167: uint16(58543),
		168: uint16(58544),
		169: uint16(58545),
		170: uint16(58546),
		171: uint16(58547),
		172: uint16(58548),
		173: uint16(58549),
		174: uint16(58550),
		175: uint16(58551),
		176: uint16(58552),
		177: uint16(58553),
		178: uint16(58554),
		179: uint16(58555),
		180: uint16(58556),
		181: uint16(58557),
		182: uint16(58558),
		183: uint16(58559),
		184: uint16(58560),
		185: uint16(58561),
		186: uint16(58562),
		187: uint16(58563),
		188: uint16(58564),
		189: uint16(58565),
	},
}

var _big5 = [89][157]uint16{
	0: {
		0:   uint16(12288),
		1:   uint16(65292),
		2:   uint16(12289),
		3:   uint16(12290),
		4:   uint16(65294),
		5:   uint16(8231),
		6:   uint16(65307),
		7:   uint16(65306),
		8:   uint16(65311),
		9:   uint16(65281),
		10:  uint16(65072),
		11:  uint16(8230),
		12:  uint16(8229),
		13:  uint16(65104),
		14:  uint16(65105),
		15:  uint16(65106),
		16:  uint16(183),
		17:  uint16(65108),
		18:  uint16(65109),
		19:  uint16(65110),
		20:  uint16(65111),
		21:  uint16(65372),
		22:  uint16(8211),
		23:  uint16(65073),
		24:  uint16(8212),
		25:  uint16(65075),
		26:  uint16(9588),
		27:  uint16(65076),
		28:  uint16(65103),
		29:  uint16(65288),
		30:  uint16(65289),
		31:  uint16(65077),
		32:  uint16(65078),
		33:  uint16(65371),
		34:  uint16(65373),
		35:  uint16(65079),
		36:  uint16(65080),
		37:  uint16(12308),
		38:  uint16(12309),
		39:  uint16(65081),
		40:  uint16(65082),
		41:  uint16(12304),
		42:  uint16(12305),
		43:  uint16(65083),
		44:  uint16(65084),
		45:  uint16(12298),
		46:  uint16(12299),
		47:  uint16(65085),
		48:  uint16(65086),
		49:  uint16(12296),
		50:  uint16(12297),
		51:  uint16(65087),
		52:  uint16(65088),
		53:  uint16(12300),
		54:  uint16(12301),
		55:  uint16(65089),
		56:  uint16(65090),
		57:  uint16(12302),
		58:  uint16(12303),
		59:  uint16(65091),
		60:  uint16(65092),
		61:  uint16(65113),
		62:  uint16(65114),
		63:  uint16(65115),
		64:  uint16(65116),
		65:  uint16(65117),
		66:  uint16(65118),
		67:  uint16(8216),
		68:  uint16(8217),
		69:  uint16(8220),
		70:  uint16(8221),
		71:  uint16(12317),
		72:  uint16(12318),
		73:  uint16(8245),
		74:  uint16(8242),
		75:  uint16(65283),
		76:  uint16(65286),
		77:  uint16(65290),
		78:  uint16(8251),
		79:  uint16(167),
		80:  uint16(12291),
		81:  uint16(9675),
		82:  uint16(9679),
		83:  uint16(9651),
		84:  uint16(9650),
		85:  uint16(9678),
		86:  uint16(9734),
		87:  uint16(9733),
		88:  uint16(9671),
		89:  uint16(9670),
		90:  uint16(9633),
		91:  uint16(9632),
		92:  uint16(9661),
		93:  uint16(9660),
		94:  uint16(12963),
		95:  uint16(8453),
		96:  uint16(175),
		97:  uint16(65507),
		98:  uint16(65343),
		99:  uint16(717),
		100: uint16(65097),
		101: uint16(65098),
		102: uint16(65101),
		103: uint16(65102),
		104: uint16(65099),
		105: uint16(65100),
		106: uint16(65119),
		107: uint16(65120),
		108: uint16(65121),
		109: uint16(65291),
		110: uint16(65293),
		111: uint16(215),
		112: uint16(247),
		113: uint16(177),
		114: uint16(8730),
		115: uint16(65308),
		116: uint16(65310),
		117: uint16(65309),
		118: uint16(8806),
		119: uint16(8807),
		120: uint16(8800),
		121: uint16(8734),
		122: uint16(8786),
		123: uint16(8801),
		124: uint16(65122),
		125: uint16(65123),
		126: uint16(65124),
		127: uint16(65125),
		128: uint16(65126),
		129: uint16(65374),
		130: uint16(8745),
		131: uint16(8746),
		132: uint16(8869),
		133: uint16(8736),
		134: uint16(8735),
		135: uint16(8895),
		136: uint16(13266),
		137: uint16(13265),
		138: uint16(8747),
		139: uint16(8750),
		140: uint16(8757),
		141: uint16(8756),
		142: uint16(9792),
		143: uint16(9794),
		144: uint16(8853),
		145: uint16(8857),
		146: uint16(8593),
		147: uint16(8595),
		148: uint16(8592),
		149: uint16(8594),
		150: uint16(8598),
		151: uint16(8599),
		152: uint16(8601),
		153: uint16(8600),
		154: uint16(8741),
		155: uint16(8739),
		156: uint16(65295),
	},
	1: {
		0:   uint16(65340),
		1:   uint16(8725),
		2:   uint16(65128),
		3:   uint16(65284),
		4:   uint16(65509),
		5:   uint16(12306),
		6:   uint16(65504),
		7:   uint16(65505),
		8:   uint16(65285),
		9:   uint16(65312),
		10:  uint16(8451),
		11:  uint16(8457),
		12:  uint16(65129),
		13:  uint16(65130),
		14:  uint16(65131),
		15:  uint16(13269),
		16:  uint16(13212),
		17:  uint16(13213),
		18:  uint16(13214),
		19:  uint16(13262),
		20:  uint16(13217),
		21:  uint16(13198),
		22:  uint16(13199),
		23:  uint16(13252),
		24:  uint16(176),
		25:  uint16(20825),
		26:  uint16(20827),
		27:  uint16(20830),
		28:  uint16(20829),
		29:  uint16(20833),
		30:  uint16(20835),
		31:  uint16(21991),
		32:  uint16(29929),
		33:  uint16(31950),
		34:  uint16(9601),
		35:  uint16(9602),
		36:  uint16(9603),
		37:  uint16(9604),
		38:  uint16(9605),
		39:  uint16(9606),
		40:  uint16(9607),
		41:  uint16(9608),
		42:  uint16(9615),
		43:  uint16(9614),
		44:  uint16(9613),
		45:  uint16(9612),
		46:  uint16(9611),
		47:  uint16(9610),
		48:  uint16(9609),
		49:  uint16(9532),
		50:  uint16(9524),
		51:  uint16(9516),
		52:  uint16(9508),
		53:  uint16(9500),
		54:  uint16(9620),
		55:  uint16(9472),
		56:  uint16(9474),
		57:  uint16(9621),
		58:  uint16(9484),
		59:  uint16(9488),
		60:  uint16(9492),
		61:  uint16(9496),
		62:  uint16(9581),
		63:  uint16(9582),
		64:  uint16(9584),
		65:  uint16(9583),
		66:  uint16(9552),
		67:  uint16(9566),
		68:  uint16(9578),
		69:  uint16(9569),
		70:  uint16(9698),
		71:  uint16(9699),
		72:  uint16(9701),
		73:  uint16(9700),
		74:  uint16(9585),
		75:  uint16(9586),
		76:  uint16(9587),
		77:  uint16(65296),
		78:  uint16(65297),
		79:  uint16(65298),
		80:  uint16(65299),
		81:  uint16(65300),
		82:  uint16(65301),
		83:  uint16(65302),
		84:  uint16(65303),
		85:  uint16(65304),
		86:  uint16(65305),
		87:  uint16(8544),
		88:  uint16(8545),
		89:  uint16(8546),
		90:  uint16(8547),
		91:  uint16(8548),
		92:  uint16(8549),
		93:  uint16(8550),
		94:  uint16(8551),
		95:  uint16(8552),
		96:  uint16(8553),
		97:  uint16(12321),
		98:  uint16(12322),
		99:  uint16(12323),
		100: uint16(12324),
		101: uint16(12325),
		102: uint16(12326),
		103: uint16(12327),
		104: uint16(12328),
		105: uint16(12329),
		106: uint16(21313),
		107: uint16(21316),
		108: uint16(21317),
		109: uint16(65313),
		110: uint16(65314),
		111: uint16(65315),
		112: uint16(65316),
		113: uint16(65317),
		114: uint16(65318),
		115: uint16(65319),
		116: uint16(65320),
		117: uint16(65321),
		118: uint16(65322),
		119: uint16(65323),
		120: uint16(65324),
		121: uint16(65325),
		122: uint16(65326),
		123: uint16(65327),
		124: uint16(65328),
		125: uint16(65329),
		126: uint16(65330),
		127: uint16(65331),
		128: uint16(65332),
		129: uint16(65333),
		130: uint16(65334),
		131: uint16(65335),
		132: uint16(65336),
		133: uint16(65337),
		134: uint16(65338),
		135: uint16(65345),
		136: uint16(65346),
		137: uint16(65347),
		138: uint16(65348),
		139: uint16(65349),
		140: uint16(65350),
		141: uint16(65351),
		142: uint16(65352),
		143: uint16(65353),
		144: uint16(65354),
		145: uint16(65355),
		146: uint16(65356),
		147: uint16(65357),
		148: uint16(65358),
		149: uint16(65359),
		150: uint16(65360),
		151: uint16(65361),
		152: uint16(65362),
		153: uint16(65363),
		154: uint16(65364),
		155: uint16(65365),
		156: uint16(65366),
	},
	2: {
		0:   uint16(65367),
		1:   uint16(65368),
		2:   uint16(65369),
		3:   uint16(65370),
		4:   uint16(913),
		5:   uint16(914),
		6:   uint16(915),
		7:   uint16(916),
		8:   uint16(917),
		9:   uint16(918),
		10:  uint16(919),
		11:  uint16(920),
		12:  uint16(921),
		13:  uint16(922),
		14:  uint16(923),
		15:  uint16(924),
		16:  uint16(925),
		17:  uint16(926),
		18:  uint16(927),
		19:  uint16(928),
		20:  uint16(929),
		21:  uint16(931),
		22:  uint16(932),
		23:  uint16(933),
		24:  uint16(934),
		25:  uint16(935),
		26:  uint16(936),
		27:  uint16(937),
		28:  uint16(945),
		29:  uint16(946),
		30:  uint16(947),
		31:  uint16(948),
		32:  uint16(949),
		33:  uint16(950),
		34:  uint16(951),
		35:  uint16(952),
		36:  uint16(953),
		37:  uint16(954),
		38:  uint16(955),
		39:  uint16(956),
		40:  uint16(957),
		41:  uint16(958),
		42:  uint16(959),
		43:  uint16(960),
		44:  uint16(961),
		45:  uint16(963),
		46:  uint16(964),
		47:  uint16(965),
		48:  uint16(966),
		49:  uint16(967),
		50:  uint16(968),
		51:  uint16(969),
		52:  uint16(12549),
		53:  uint16(12550),
		54:  uint16(12551),
		55:  uint16(12552),
		56:  uint16(12553),
		57:  uint16(12554),
		58:  uint16(12555),
		59:  uint16(12556),
		60:  uint16(12557),
		61:  uint16(12558),
		62:  uint16(12559),
		63:  uint16(12560),
		64:  uint16(12561),
		65:  uint16(12562),
		66:  uint16(12563),
		67:  uint16(12564),
		68:  uint16(12565),
		69:  uint16(12566),
		70:  uint16(12567),
		71:  uint16(12568),
		72:  uint16(12569),
		73:  uint16(12570),
		74:  uint16(12571),
		75:  uint16(12572),
		76:  uint16(12573),
		77:  uint16(12574),
		78:  uint16(12575),
		79:  uint16(12576),
		80:  uint16(12577),
		81:  uint16(12578),
		82:  uint16(12579),
		83:  uint16(12580),
		84:  uint16(12581),
		85:  uint16(12582),
		86:  uint16(12583),
		87:  uint16(12584),
		88:  uint16(12585),
		89:  uint16(729),
		90:  uint16(713),
		91:  uint16(714),
		92:  uint16(711),
		93:  uint16(715),
		94:  uint16(9216),
		95:  uint16(9217),
		96:  uint16(9218),
		97:  uint16(9219),
		98:  uint16(9220),
		99:  uint16(9221),
		100: uint16(9222),
		101: uint16(9223),
		102: uint16(9224),
		103: uint16(9225),
		104: uint16(9226),
		105: uint16(9227),
		106: uint16(9228),
		107: uint16(9229),
		108: uint16(9230),
		109: uint16(9231),
		110: uint16(9232),
		111: uint16(9233),
		112: uint16(9234),
		113: uint16(9235),
		114: uint16(9236),
		115: uint16(9237),
		116: uint16(9238),
		117: uint16(9239),
		118: uint16(9240),
		119: uint16(9241),
		120: uint16(9242),
		121: uint16(9243),
		122: uint16(9244),
		123: uint16(9245),
		124: uint16(9246),
		125: uint16(9247),
		126: uint16(9249),
		127: uint16(8364),
	},
	3: {
		0:   uint16(19968),
		1:   uint16(20057),
		2:   uint16(19969),
		3:   uint16(19971),
		4:   uint16(20035),
		5:   uint16(20061),
		6:   uint16(20102),
		7:   uint16(20108),
		8:   uint16(20154),
		9:   uint16(20799),
		10:  uint16(20837),
		11:  uint16(20843),
		12:  uint16(20960),
		13:  uint16(20992),
		14:  uint16(20993),
		15:  uint16(21147),
		16:  uint16(21269),
		17:  uint16(21313),
		18:  uint16(21340),
		19:  uint16(21448),
		20:  uint16(19977),
		21:  uint16(19979),
		22:  uint16(19976),
		23:  uint16(19978),
		24:  uint16(20011),
		25:  uint16(20024),
		26:  uint16(20961),
		27:  uint16(20037),
		28:  uint16(20040),
		29:  uint16(20063),
		30:  uint16(20062),
		31:  uint16(20110),
		32:  uint16(20129),
		33:  uint16(20800),
		34:  uint16(20995),
		35:  uint16(21242),
		36:  uint16(21315),
		37:  uint16(21449),
		38:  uint16(21475),
		39:  uint16(22303),
		40:  uint16(22763),
		41:  uint16(22805),
		42:  uint16(22823),
		43:  uint16(22899),
		44:  uint16(23376),
		45:  uint16(23377),
		46:  uint16(23379),
		47:  uint16(23544),
		48:  uint16(23567),
		49:  uint16(23586),
		50:  uint16(23608),
		51:  uint16(23665),
		52:  uint16(24029),
		53:  uint16(24037),
		54:  uint16(24049),
		55:  uint16(24050),
		56:  uint16(24051),
		57:  uint16(24062),
		58:  uint16(24178),
		59:  uint16(24318),
		60:  uint16(24331),
		61:  uint16(24339),
		62:  uint16(25165),
		63:  uint16(19985),
		64:  uint16(19984),
		65:  uint16(19981),
		66:  uint16(20013),
		67:  uint16(20016),
		68:  uint16(20025),
		69:  uint16(20043),
		70:  uint16(23609),
		71:  uint16(20104),
		72:  uint16(20113),
		73:  uint16(20117),
		74:  uint16(20114),
		75:  uint16(20116),
		76:  uint16(20130),
		77:  uint16(20161),
		78:  uint16(20160),
		79:  uint16(20163),
		80:  uint16(20166),
		81:  uint16(20167),
		82:  uint16(20173),
		83:  uint16(20170),
		84:  uint16(20171),
		85:  uint16(20164),
		86:  uint16(20803),
		87:  uint16(20801),
		88:  uint16(20839),
		89:  uint16(20845),
		90:  uint16(20846),
		91:  uint16(20844),
		92:  uint16(20887),
		93:  uint16(20982),
		94:  uint16(20998),
		95:  uint16(20999),
		96:  uint16(21000),
		97:  uint16(21243),
		98:  uint16(21246),
		99:  uint16(21247),
		100: uint16(21270),
		101: uint16(21305),
		102: uint16(21320),
		103: uint16(21319),
		104: uint16(21317),
		105: uint16(21342),
		106: uint16(21380),
		107: uint16(21451),
		108: uint16(21450),
		109: uint16(21453),
		110: uint16(22764),
		111: uint16(22825),
		112: uint16(22827),
		113: uint16(22826),
		114: uint16(22829),
		115: uint16(23380),
		116: uint16(23569),
		117: uint16(23588),
		118: uint16(23610),
		119: uint16(23663),
		120: uint16(24052),
		121: uint16(24187),
		122: uint16(24319),
		123: uint16(24340),
		124: uint16(24341),
		125: uint16(24515),
		126: uint16(25096),
		127: uint16(25142),
		128: uint16(25163),
		129: uint16(25166),
		130: uint16(25903),
		131: uint16(25991),
		132: uint16(26007),
		133: uint16(26020),
		134: uint16(26041),
		135: uint16(26085),
		136: uint16(26352),
		137: uint16(26376),
		138: uint16(26408),
		139: uint16(27424),
		140: uint16(27490),
		141: uint16(27513),
		142: uint16(27595),
		143: uint16(27604),
		144: uint16(27611),
		145: uint16(27663),
		146: uint16(27700),
		147: uint16(28779),
		148: uint16(29226),
		149: uint16(29238),
		150: uint16(29243),
		151: uint16(29255),
		152: uint16(29273),
		153: uint16(29275),
		154: uint16(29356),
		155: uint16(29579),
		156: uint16(19993),
	},
	4: {
		0:   uint16(19990),
		1:   uint16(19989),
		2:   uint16(19988),
		3:   uint16(19992),
		4:   uint16(20027),
		5:   uint16(20045),
		6:   uint16(20047),
		7:   uint16(20046),
		8:   uint16(20197),
		9:   uint16(20184),
		10:  uint16(20180),
		11:  uint16(20181),
		12:  uint16(20182),
		13:  uint16(20183),
		14:  uint16(20195),
		15:  uint16(20196),
		16:  uint16(20185),
		17:  uint16(20190),
		18:  uint16(20805),
		19:  uint16(20804),
		20:  uint16(20873),
		21:  uint16(20874),
		22:  uint16(20908),
		23:  uint16(20985),
		24:  uint16(20986),
		25:  uint16(20984),
		26:  uint16(21002),
		27:  uint16(21152),
		28:  uint16(21151),
		29:  uint16(21253),
		30:  uint16(21254),
		31:  uint16(21271),
		32:  uint16(21277),
		33:  uint16(20191),
		34:  uint16(21322),
		35:  uint16(21321),
		36:  uint16(21345),
		37:  uint16(21344),
		38:  uint16(21359),
		39:  uint16(21358),
		40:  uint16(21435),
		41:  uint16(21487),
		42:  uint16(21476),
		43:  uint16(21491),
		44:  uint16(21484),
		45:  uint16(21486),
		46:  uint16(21481),
		47:  uint16(21480),
		48:  uint16(21500),
		49:  uint16(21496),
		50:  uint16(21493),
		51:  uint16(21483),
		52:  uint16(21478),
		53:  uint16(21482),
		54:  uint16(21490),
		55:  uint16(21489),
		56:  uint16(21488),
		57:  uint16(21477),
		58:  uint16(21485),
		59:  uint16(21499),
		60:  uint16(22235),
		61:  uint16(22234),
		62:  uint16(22806),
		63:  uint16(22830),
		64:  uint16(22833),
		65:  uint16(22900),
		66:  uint16(22902),
		67:  uint16(23381),
		68:  uint16(23427),
		69:  uint16(23612),
		70:  uint16(24040),
		71:  uint16(24039),
		72:  uint16(24038),
		73:  uint16(24066),
		74:  uint16(24067),
		75:  uint16(24179),
		76:  uint16(24188),
		77:  uint16(24321),
		78:  uint16(24344),
		79:  uint16(24343),
		80:  uint16(24517),
		81:  uint16(25098),
		82:  uint16(25171),
		83:  uint16(25172),
		84:  uint16(25170),
		85:  uint16(25169),
		86:  uint16(26021),
		87:  uint16(26086),
		88:  uint16(26414),
		89:  uint16(26412),
		90:  uint16(26410),
		91:  uint16(26411),
		92:  uint16(26413),
		93:  uint16(27491),
		94:  uint16(27597),
		95:  uint16(27665),
		96:  uint16(27664),
		97:  uint16(27704),
		98:  uint16(27713),
		99:  uint16(27712),
		100: uint16(27710),
		101: uint16(29359),
		102: uint16(29572),
		103: uint16(29577),
		104: uint16(29916),
		105: uint16(29926),
		106: uint16(29976),
		107: uint16(29983),
		108: uint16(29992),
		109: uint16(29993),
		110: uint16(30000),
		111: uint16(30001),
		112: uint16(30002),
		113: uint16(30003),
		114: uint16(30091),
		115: uint16(30333),
		116: uint16(30382),
		117: uint16(30399),
		118: uint16(30446),
		119: uint16(30683),
		120: uint16(30690),
		121: uint16(30707),
		122: uint16(31034),
		123: uint16(31166),
		124: uint16(31348),
		125: uint16(31435),
		126: uint16(19998),
		127: uint16(19999),
		128: uint16(20050),
		129: uint16(20051),
		130: uint16(20073),
		131: uint16(20121),
		132: uint16(20132),
		133: uint16(20134),
		134: uint16(20133),
		135: uint16(20223),
		136: uint16(20233),
		137: uint16(20249),
		138: uint16(20234),
		139: uint16(20245),
		140: uint16(20237),
		141: uint16(20240),
		142: uint16(20241),
		143: uint16(20239),
		144: uint16(20210),
		145: uint16(20214),
		146: uint16(20219),
		147: uint16(20208),
		148: uint16(20211),
		149: uint16(20221),
		150: uint16(20225),
		151: uint16(20235),
		152: uint16(20809),
		153: uint16(20807),
		154: uint16(20806),
		155: uint16(20808),
		156: uint16(20840),
	},
	5: {
		0:   uint16(20849),
		1:   uint16(20877),
		2:   uint16(20912),
		3:   uint16(21015),
		4:   uint16(21009),
		5:   uint16(21010),
		6:   uint16(21006),
		7:   uint16(21014),
		8:   uint16(21155),
		9:   uint16(21256),
		10:  uint16(21281),
		11:  uint16(21280),
		12:  uint16(21360),
		13:  uint16(21361),
		14:  uint16(21513),
		15:  uint16(21519),
		16:  uint16(21516),
		17:  uint16(21514),
		18:  uint16(21520),
		19:  uint16(21505),
		20:  uint16(21515),
		21:  uint16(21508),
		22:  uint16(21521),
		23:  uint16(21517),
		24:  uint16(21512),
		25:  uint16(21507),
		26:  uint16(21518),
		27:  uint16(21510),
		28:  uint16(21522),
		29:  uint16(22240),
		30:  uint16(22238),
		31:  uint16(22237),
		32:  uint16(22323),
		33:  uint16(22320),
		34:  uint16(22312),
		35:  uint16(22317),
		36:  uint16(22316),
		37:  uint16(22319),
		38:  uint16(22313),
		39:  uint16(22809),
		40:  uint16(22810),
		41:  uint16(22839),
		42:  uint16(22840),
		43:  uint16(22916),
		44:  uint16(22904),
		45:  uint16(22915),
		46:  uint16(22909),
		47:  uint16(22905),
		48:  uint16(22914),
		49:  uint16(22913),
		50:  uint16(23383),
		51:  uint16(23384),
		52:  uint16(23431),
		53:  uint16(23432),
		54:  uint16(23429),
		55:  uint16(23433),
		56:  uint16(23546),
		57:  uint16(23574),
		58:  uint16(23673),
		59:  uint16(24030),
		60:  uint16(24070),
		61:  uint16(24182),
		62:  uint16(24180),
		63:  uint16(24335),
		64:  uint16(24347),
		65:  uint16(24537),
		66:  uint16(24534),
		67:  uint16(25102),
		68:  uint16(25100),
		69:  uint16(25101),
		70:  uint16(25104),
		71:  uint16(25187),
		72:  uint16(25179),
		73:  uint16(25176),
		74:  uint16(25910),
		75:  uint16(26089),
		76:  uint16(26088),
		77:  uint16(26092),
		78:  uint16(26093),
		79:  uint16(26354),
		80:  uint16(26355),
		81:  uint16(26377),
		82:  uint16(26429),
		83:  uint16(26420),
		84:  uint16(26417),
		85:  uint16(26421),
		86:  uint16(27425),
		87:  uint16(27492),
		88:  uint16(27515),
		89:  uint16(27670),
		90:  uint16(27741),
		91:  uint16(27735),
		92:  uint16(27737),
		93:  uint16(27743),
		94:  uint16(27744),
		95:  uint16(27728),
		96:  uint16(27733),
		97:  uint16(27745),
		98:  uint16(27739),
		99:  uint16(27725),
		100: uint16(27726),
		101: uint16(28784),
		102: uint16(29279),
		103: uint16(29277),
		104: uint16(30334),
		105: uint16(31481),
		106: uint16(31859),
		107: uint16(31992),
		108: uint16(32566),
		109: uint16(32650),
		110: uint16(32701),
		111: uint16(32769),
		112: uint16(32771),
		113: uint16(32780),
		114: uint16(32786),
		115: uint16(32819),
		116: uint16(32895),
		117: uint16(32905),
		118: uint16(32907),
		119: uint16(32908),
		120: uint16(33251),
		121: uint16(33258),
		122: uint16(33267),
		123: uint16(33276),
		124: uint16(33292),
		125: uint16(33307),
		126: uint16(33311),
		127: uint16(33390),
		128: uint16(33394),
		129: uint16(33406),
		130: uint16(34411),
		131: uint16(34880),
		132: uint16(34892),
		133: uint16(34915),
		134: uint16(35199),
		135: uint16(38433),
		136: uint16(20018),
		137: uint16(20136),
		138: uint16(20301),
		139: uint16(20303),
		140: uint16(20295),
		141: uint16(20311),
		142: uint16(20318),
		143: uint16(20276),
		144: uint16(20315),
		145: uint16(20309),
		146: uint16(20272),
		147: uint16(20304),
		148: uint16(20305),
		149: uint16(20285),
		150: uint16(20282),
		151: uint16(20280),
		152: uint16(20291),
		153: uint16(20308),
		154: uint16(20284),
		155: uint16(20294),
		156: uint16(20323),
	},
	6: {
		0:   uint16(20316),
		1:   uint16(20320),
		2:   uint16(20271),
		3:   uint16(20302),
		4:   uint16(20278),
		5:   uint16(20313),
		6:   uint16(20317),
		7:   uint16(20296),
		8:   uint16(20314),
		9:   uint16(20812),
		10:  uint16(20811),
		11:  uint16(20813),
		12:  uint16(20853),
		13:  uint16(20918),
		14:  uint16(20919),
		15:  uint16(21029),
		16:  uint16(21028),
		17:  uint16(21033),
		18:  uint16(21034),
		19:  uint16(21032),
		20:  uint16(21163),
		21:  uint16(21161),
		22:  uint16(21162),
		23:  uint16(21164),
		24:  uint16(21283),
		25:  uint16(21363),
		26:  uint16(21365),
		27:  uint16(21533),
		28:  uint16(21549),
		29:  uint16(21534),
		30:  uint16(21566),
		31:  uint16(21542),
		32:  uint16(21582),
		33:  uint16(21543),
		34:  uint16(21574),
		35:  uint16(21571),
		36:  uint16(21555),
		37:  uint16(21576),
		38:  uint16(21570),
		39:  uint16(21531),
		40:  uint16(21545),
		41:  uint16(21578),
		42:  uint16(21561),
		43:  uint16(21563),
		44:  uint16(21560),
		45:  uint16(21550),
		46:  uint16(21557),
		47:  uint16(21558),
		48:  uint16(21536),
		49:  uint16(21564),
		50:  uint16(21568),
		51:  uint16(21553),
		52:  uint16(21547),
		53:  uint16(21535),
		54:  uint16(21548),
		55:  uint16(22250),
		56:  uint16(22256),
		57:  uint16(22244),
		58:  uint16(22251),
		59:  uint16(22346),
		60:  uint16(22353),
		61:  uint16(22336),
		62:  uint16(22349),
		63:  uint16(22343),
		64:  uint16(22350),
		65:  uint16(22334),
		66:  uint16(22352),
		67:  uint16(22351),
		68:  uint16(22331),
		69:  uint16(22767),
		70:  uint16(22846),
		71:  uint16(22941),
		72:  uint16(22930),
		73:  uint16(22952),
		74:  uint16(22942),
		75:  uint16(22947),
		76:  uint16(22937),
		77:  uint16(22934),
		78:  uint16(22925),
		79:  uint16(22948),
		80:  uint16(22931),
		81:  uint16(22922),
		82:  uint16(22949),
		83:  uint16(23389),
		84:  uint16(23388),
		85:  uint16(23386),
		86:  uint16(23387),
		87:  uint16(23436),
		88:  uint16(23435),
		89:  uint16(23439),
		90:  uint16(23596),
		91:  uint16(23616),
		92:  uint16(23617),
		93:  uint16(23615),
		94:  uint16(23614),
		95:  uint16(23696),
		96:  uint16(23697),
		97:  uint16(23700),
		98:  uint16(23692),
		99:  uint16(24043),
		100: uint16(24076),
		101: uint16(24207),
		102: uint16(24199),
		103: uint16(24202),
		104: uint16(24311),
		105: uint16(24324),
		106: uint16(24351),
		107: uint16(24420),
		108: uint16(24418),
		109: uint16(24439),
		110: uint16(24441),
		111: uint16(24536),
		112: uint16(24524),
		113: uint16(24535),
		114: uint16(24525),
		115: uint16(24561),
		116: uint16(24555),
		117: uint16(24568),
		118: uint16(24554),
		119: uint16(25106),
		120: uint16(25105),
		121: uint16(25220),
		122: uint16(25239),
		123: uint16(25238),
		124: uint16(25216),
		125: uint16(25206),
		126: uint16(25225),
		127: uint16(25197),
		128: uint16(25226),
		129: uint16(25212),
		130: uint16(25214),
		131: uint16(25209),
		132: uint16(25203),
		133: uint16(25234),
		134: uint16(25199),
		135: uint16(25240),
		136: uint16(25198),
		137: uint16(25237),
		138: uint16(25235),
		139: uint16(25233),
		140: uint16(25222),
		141: uint16(25913),
		142: uint16(25915),
		143: uint16(25912),
		144: uint16(26097),
		145: uint16(26356),
		146: uint16(26463),
		147: uint16(26446),
		148: uint16(26447),
		149: uint16(26448),
		150: uint16(26449),
		151: uint16(26460),
		152: uint16(26454),
		153: uint16(26462),
		154: uint16(26441),
		155: uint16(26438),
		156: uint16(26464),
	},
	7: {
		0:   uint16(26451),
		1:   uint16(26455),
		2:   uint16(27493),
		3:   uint16(27599),
		4:   uint16(27714),
		5:   uint16(27742),
		6:   uint16(27801),
		7:   uint16(27777),
		8:   uint16(27784),
		9:   uint16(27785),
		10:  uint16(27781),
		11:  uint16(27803),
		12:  uint16(27754),
		13:  uint16(27770),
		14:  uint16(27792),
		15:  uint16(27760),
		16:  uint16(27788),
		17:  uint16(27752),
		18:  uint16(27798),
		19:  uint16(27794),
		20:  uint16(27773),
		21:  uint16(27779),
		22:  uint16(27762),
		23:  uint16(27774),
		24:  uint16(27764),
		25:  uint16(27782),
		26:  uint16(27766),
		27:  uint16(27789),
		28:  uint16(27796),
		29:  uint16(27800),
		30:  uint16(27778),
		31:  uint16(28790),
		32:  uint16(28796),
		33:  uint16(28797),
		34:  uint16(28792),
		35:  uint16(29282),
		36:  uint16(29281),
		37:  uint16(29280),
		38:  uint16(29380),
		39:  uint16(29378),
		40:  uint16(29590),
		41:  uint16(29996),
		42:  uint16(29995),
		43:  uint16(30007),
		44:  uint16(30008),
		45:  uint16(30338),
		46:  uint16(30447),
		47:  uint16(30691),
		48:  uint16(31169),
		49:  uint16(31168),
		50:  uint16(31167),
		51:  uint16(31350),
		52:  uint16(31995),
		53:  uint16(32597),
		54:  uint16(32918),
		55:  uint16(32915),
		56:  uint16(32925),
		57:  uint16(32920),
		58:  uint16(32923),
		59:  uint16(32922),
		60:  uint16(32946),
		61:  uint16(33391),
		62:  uint16(33426),
		63:  uint16(33419),
		64:  uint16(33421),
		65:  uint16(35211),
		66:  uint16(35282),
		67:  uint16(35328),
		68:  uint16(35895),
		69:  uint16(35910),
		70:  uint16(35925),
		71:  uint16(35997),
		72:  uint16(36196),
		73:  uint16(36208),
		74:  uint16(36275),
		75:  uint16(36523),
		76:  uint16(36554),
		77:  uint16(36763),
		78:  uint16(36784),
		79:  uint16(36802),
		80:  uint16(36806),
		81:  uint16(36805),
		82:  uint16(36804),
		83:  uint16(24033),
		84:  uint16(37009),
		85:  uint16(37026),
		86:  uint16(37034),
		87:  uint16(37030),
		88:  uint16(37027),
		89:  uint16(37193),
		90:  uint16(37318),
		91:  uint16(37324),
		92:  uint16(38450),
		93:  uint16(38446),
		94:  uint16(38449),
		95:  uint16(38442),
		96:  uint16(38444),
		97:  uint16(20006),
		98:  uint16(20054),
		99:  uint16(20083),
		100: uint16(20107),
		101: uint16(20123),
		102: uint16(20126),
		103: uint16(20139),
		104: uint16(20140),
		105: uint16(20335),
		106: uint16(20381),
		107: uint16(20365),
		108: uint16(20339),
		109: uint16(20351),
		110: uint16(20332),
		111: uint16(20379),
		112: uint16(20363),
		113: uint16(20358),
		114: uint16(20355),
		115: uint16(20336),
		116: uint16(20341),
		117: uint16(20360),
		118: uint16(20329),
		119: uint16(20347),
		120: uint16(20374),
		121: uint16(20350),
		122: uint16(20367),
		123: uint16(20369),
		124: uint16(20346),
		125: uint16(20820),
		126: uint16(20818),
		127: uint16(20821),
		128: uint16(20841),
		129: uint16(20855),
		130: uint16(20854),
		131: uint16(20856),
		132: uint16(20925),
		133: uint16(20989),
		134: uint16(21051),
		135: uint16(21048),
		136: uint16(21047),
		137: uint16(21050),
		138: uint16(21040),
		139: uint16(21038),
		140: uint16(21046),
		141: uint16(21057),
		142: uint16(21182),
		143: uint16(21179),
		144: uint16(21330),
		145: uint16(21332),
		146: uint16(21331),
		147: uint16(21329),
		148: uint16(21350),
		149: uint16(21367),
		150: uint16(21368),
		151: uint16(21369),
		152: uint16(21462),
		153: uint16(21460),
		154: uint16(21463),
		155: uint16(21619),
		156: uint16(21621),
	},
	8: {
		0:   uint16(21654),
		1:   uint16(21624),
		2:   uint16(21653),
		3:   uint16(21632),
		4:   uint16(21627),
		5:   uint16(21623),
		6:   uint16(21636),
		7:   uint16(21650),
		8:   uint16(21638),
		9:   uint16(21628),
		10:  uint16(21648),
		11:  uint16(21617),
		12:  uint16(21622),
		13:  uint16(21644),
		14:  uint16(21658),
		15:  uint16(21602),
		16:  uint16(21608),
		17:  uint16(21643),
		18:  uint16(21629),
		19:  uint16(21646),
		20:  uint16(22266),
		21:  uint16(22403),
		22:  uint16(22391),
		23:  uint16(22378),
		24:  uint16(22377),
		25:  uint16(22369),
		26:  uint16(22374),
		27:  uint16(22372),
		28:  uint16(22396),
		29:  uint16(22812),
		30:  uint16(22857),
		31:  uint16(22855),
		32:  uint16(22856),
		33:  uint16(22852),
		34:  uint16(22868),
		35:  uint16(22974),
		36:  uint16(22971),
		37:  uint16(22996),
		38:  uint16(22969),
		39:  uint16(22958),
		40:  uint16(22993),
		41:  uint16(22982),
		42:  uint16(22992),
		43:  uint16(22989),
		44:  uint16(22987),
		45:  uint16(22995),
		46:  uint16(22986),
		47:  uint16(22959),
		48:  uint16(22963),
		49:  uint16(22994),
		50:  uint16(22981),
		51:  uint16(23391),
		52:  uint16(23396),
		53:  uint16(23395),
		54:  uint16(23447),
		55:  uint16(23450),
		56:  uint16(23448),
		57:  uint16(23452),
		58:  uint16(23449),
		59:  uint16(23451),
		60:  uint16(23578),
		61:  uint16(23624),
		62:  uint16(23621),
		63:  uint16(23622),
		64:  uint16(23735),
		65:  uint16(23713),
		66:  uint16(23736),
		67:  uint16(23721),
		68:  uint16(23723),
		69:  uint16(23729),
		70:  uint16(23731),
		71:  uint16(24088),
		72:  uint16(24090),
		73:  uint16(24086),
		74:  uint16(24085),
		75:  uint16(24091),
		76:  uint16(24081),
		77:  uint16(24184),
		78:  uint16(24218),
		79:  uint16(24215),
		80:  uint16(24220),
		81:  uint16(24213),
		82:  uint16(24214),
		83:  uint16(24310),
		84:  uint16(24358),
		85:  uint16(24359),
		86:  uint16(24361),
		87:  uint16(24448),
		88:  uint16(24449),
		89:  uint16(24447),
		90:  uint16(24444),
		91:  uint16(24541),
		92:  uint16(24544),
		93:  uint16(24573),
		94:  uint16(24565),
		95:  uint16(24575),
		96:  uint16(24591),
		97:  uint16(24596),
		98:  uint16(24623),
		99:  uint16(24629),
		100: uint16(24598),
		101: uint16(24618),
		102: uint16(24597),
		103: uint16(24609),
		104: uint16(24615),
		105: uint16(24617),
		106: uint16(24619),
		107: uint16(24603),
		108: uint16(25110),
		109: uint16(25109),
		110: uint16(25151),
		111: uint16(25150),
		112: uint16(25152),
		113: uint16(25215),
		114: uint16(25289),
		115: uint16(25292),
		116: uint16(25284),
		117: uint16(25279),
		118: uint16(25282),
		119: uint16(25273),
		120: uint16(25298),
		121: uint16(25307),
		122: uint16(25259),
		123: uint16(25299),
		124: uint16(25300),
		125: uint16(25291),
		126: uint16(25288),
		127: uint16(25256),
		128: uint16(25277),
		129: uint16(25276),
		130: uint16(25296),
		131: uint16(25305),
		132: uint16(25287),
		133: uint16(25293),
		134: uint16(25269),
		135: uint16(25306),
		136: uint16(25265),
		137: uint16(25304),
		138: uint16(25302),
		139: uint16(25303),
		140: uint16(25286),
		141: uint16(25260),
		142: uint16(25294),
		143: uint16(25918),
		144: uint16(26023),
		145: uint16(26044),
		146: uint16(26106),
		147: uint16(26132),
		148: uint16(26131),
		149: uint16(26124),
		150: uint16(26118),
		151: uint16(26114),
		152: uint16(26126),
		153: uint16(26112),
		154: uint16(26127),
		155: uint16(26133),
		156: uint16(26122),
	},
	9: {
		0:   uint16(26119),
		1:   uint16(26381),
		2:   uint16(26379),
		3:   uint16(26477),
		4:   uint16(26507),
		5:   uint16(26517),
		6:   uint16(26481),
		7:   uint16(26524),
		8:   uint16(26483),
		9:   uint16(26487),
		10:  uint16(26503),
		11:  uint16(26525),
		12:  uint16(26519),
		13:  uint16(26479),
		14:  uint16(26480),
		15:  uint16(26495),
		16:  uint16(26505),
		17:  uint16(26494),
		18:  uint16(26512),
		19:  uint16(26485),
		20:  uint16(26522),
		21:  uint16(26515),
		22:  uint16(26492),
		23:  uint16(26474),
		24:  uint16(26482),
		25:  uint16(27427),
		26:  uint16(27494),
		27:  uint16(27495),
		28:  uint16(27519),
		29:  uint16(27667),
		30:  uint16(27675),
		31:  uint16(27875),
		32:  uint16(27880),
		33:  uint16(27891),
		34:  uint16(27825),
		35:  uint16(27852),
		36:  uint16(27877),
		37:  uint16(27827),
		38:  uint16(27837),
		39:  uint16(27838),
		40:  uint16(27836),
		41:  uint16(27874),
		42:  uint16(27819),
		43:  uint16(27861),
		44:  uint16(27859),
		45:  uint16(27832),
		46:  uint16(27844),
		47:  uint16(27833),
		48:  uint16(27841),
		49:  uint16(27822),
		50:  uint16(27863),
		51:  uint16(27845),
		52:  uint16(27889),
		53:  uint16(27839),
		54:  uint16(27835),
		55:  uint16(27873),
		56:  uint16(27867),
		57:  uint16(27850),
		58:  uint16(27820),
		59:  uint16(27887),
		60:  uint16(27868),
		61:  uint16(27862),
		62:  uint16(27872),
		63:  uint16(28821),
		64:  uint16(28814),
		65:  uint16(28818),
		66:  uint16(28810),
		67:  uint16(28825),
		68:  uint16(29228),
		69:  uint16(29229),
		70:  uint16(29240),
		71:  uint16(29256),
		72:  uint16(29287),
		73:  uint16(29289),
		74:  uint16(29376),
		75:  uint16(29390),
		76:  uint16(29401),
		77:  uint16(29399),
		78:  uint16(29392),
		79:  uint16(29609),
		80:  uint16(29608),
		81:  uint16(29599),
		82:  uint16(29611),
		83:  uint16(29605),
		84:  uint16(30013),
		85:  uint16(30109),
		86:  uint16(30105),
		87:  uint16(30106),
		88:  uint16(30340),
		89:  uint16(30402),
		90:  uint16(30450),
		91:  uint16(30452),
		92:  uint16(30693),
		93:  uint16(30717),
		94:  uint16(31038),
		95:  uint16(31040),
		96:  uint16(31041),
		97:  uint16(31177),
		98:  uint16(31176),
		99:  uint16(31354),
		100: uint16(31353),
		101: uint16(31482),
		102: uint16(31998),
		103: uint16(32596),
		104: uint16(32652),
		105: uint16(32651),
		106: uint16(32773),
		107: uint16(32954),
		108: uint16(32933),
		109: uint16(32930),
		110: uint16(32945),
		111: uint16(32929),
		112: uint16(32939),
		113: uint16(32937),
		114: uint16(32948),
		115: uint16(32938),
		116: uint16(32943),
		117: uint16(33253),
		118: uint16(33278),
		119: uint16(33293),
		120: uint16(33459),
		121: uint16(33437),
		122: uint16(33433),
		123: uint16(33453),
		124: uint16(33469),
		125: uint16(33439),
		126: uint16(33465),
		127: uint16(33457),
		128: uint16(33452),
		129: uint16(33445),
		130: uint16(33455),
		131: uint16(33464),
		132: uint16(33443),
		133: uint16(33456),
		134: uint16(33470),
		135: uint16(33463),
		136: uint16(34382),
		137: uint16(34417),
		138: uint16(21021),
		139: uint16(34920),
		140: uint16(36555),
		141: uint16(36814),
		142: uint16(36820),
		143: uint16(36817),
		144: uint16(37045),
		145: uint16(37048),
		146: uint16(37041),
		147: uint16(37046),
		148: uint16(37319),
		149: uint16(37329),
		150: uint16(38263),
		151: uint16(38272),
		152: uint16(38428),
		153: uint16(38464),
		154: uint16(38463),
		155: uint16(38459),
		156: uint16(38468),
	},
	10: {
		0:   uint16(38466),
		1:   uint16(38585),
		2:   uint16(38632),
		3:   uint16(38738),
		4:   uint16(38750),
		5:   uint16(20127),
		6:   uint16(20141),
		7:   uint16(20142),
		8:   uint16(20449),
		9:   uint16(20405),
		10:  uint16(20399),
		11:  uint16(20415),
		12:  uint16(20448),
		13:  uint16(20433),
		14:  uint16(20431),
		15:  uint16(20445),
		16:  uint16(20419),
		17:  uint16(20406),
		18:  uint16(20440),
		19:  uint16(20447),
		20:  uint16(20426),
		21:  uint16(20439),
		22:  uint16(20398),
		23:  uint16(20432),
		24:  uint16(20420),
		25:  uint16(20418),
		26:  uint16(20442),
		27:  uint16(20430),
		28:  uint16(20446),
		29:  uint16(20407),
		30:  uint16(20823),
		31:  uint16(20882),
		32:  uint16(20881),
		33:  uint16(20896),
		34:  uint16(21070),
		35:  uint16(21059),
		36:  uint16(21066),
		37:  uint16(21069),
		38:  uint16(21068),
		39:  uint16(21067),
		40:  uint16(21063),
		41:  uint16(21191),
		42:  uint16(21193),
		43:  uint16(21187),
		44:  uint16(21185),
		45:  uint16(21261),
		46:  uint16(21335),
		47:  uint16(21371),
		48:  uint16(21402),
		49:  uint16(21467),
		50:  uint16(21676),
		51:  uint16(21696),
		52:  uint16(21672),
		53:  uint16(21710),
		54:  uint16(21705),
		55:  uint16(21688),
		56:  uint16(21670),
		57:  uint16(21683),
		58:  uint16(21703),
		59:  uint16(21698),
		60:  uint16(21693),
		61:  uint16(21674),
		62:  uint16(21697),
		63:  uint16(21700),
		64:  uint16(21704),
		65:  uint16(21679),
		66:  uint16(21675),
		67:  uint16(21681),
		68:  uint16(21691),
		69:  uint16(21673),
		70:  uint16(21671),
		71:  uint16(21695),
		72:  uint16(22271),
		73:  uint16(22402),
		74:  uint16(22411),
		75:  uint16(22432),
		76:  uint16(22435),
		77:  uint16(22434),
		78:  uint16(22478),
		79:  uint16(22446),
		80:  uint16(22419),
		81:  uint16(22869),
		82:  uint16(22865),
		83:  uint16(22863),
		84:  uint16(22862),
		85:  uint16(22864),
		86:  uint16(23004),
		87:  uint16(23000),
		88:  uint16(23039),
		89:  uint16(23011),
		90:  uint16(23016),
		91:  uint16(23043),
		92:  uint16(23013),
		93:  uint16(23018),
		94:  uint16(23002),
		95:  uint16(23014),
		96:  uint16(23041),
		97:  uint16(23035),
		98:  uint16(23401),
		99:  uint16(23459),
		100: uint16(23462),
		101: uint16(23460),
		102: uint16(23458),
		103: uint16(23461),
		104: uint16(23553),
		105: uint16(23630),
		106: uint16(23631),
		107: uint16(23629),
		108: uint16(23627),
		109: uint16(23769),
		110: uint16(23762),
		111: uint16(24055),
		112: uint16(24093),
		113: uint16(24101),
		114: uint16(24095),
		115: uint16(24189),
		116: uint16(24224),
		117: uint16(24230),
		118: uint16(24314),
		119: uint16(24328),
		120: uint16(24365),
		121: uint16(24421),
		122: uint16(24456),
		123: uint16(24453),
		124: uint16(24458),
		125: uint16(24459),
		126: uint16(24455),
		127: uint16(24460),
		128: uint16(24457),
		129: uint16(24594),
		130: uint16(24605),
		131: uint16(24608),
		132: uint16(24613),
		133: uint16(24590),
		134: uint16(24616),
		135: uint16(24653),
		136: uint16(24688),
		137: uint16(24680),
		138: uint16(24674),
		139: uint16(24646),
		140: uint16(24643),
		141: uint16(24684),
		142: uint16(24683),
		143: uint16(24682),
		144: uint16(24676),
		145: uint16(25153),
		146: uint16(25308),
		147: uint16(25366),
		148: uint16(25353),
		149: uint16(25340),
		150: uint16(25325),
		151: uint16(25345),
		152: uint16(25326),
		153: uint16(25341),
		154: uint16(25351),
		155: uint16(25329),
		156: uint16(25335),
	},
	11: {
		0:   uint16(25327),
		1:   uint16(25324),
		2:   uint16(25342),
		3:   uint16(25332),
		4:   uint16(25361),
		5:   uint16(25346),
		6:   uint16(25919),
		7:   uint16(25925),
		8:   uint16(26027),
		9:   uint16(26045),
		10:  uint16(26082),
		11:  uint16(26149),
		12:  uint16(26157),
		13:  uint16(26144),
		14:  uint16(26151),
		15:  uint16(26159),
		16:  uint16(26143),
		17:  uint16(26152),
		18:  uint16(26161),
		19:  uint16(26148),
		20:  uint16(26359),
		21:  uint16(26623),
		22:  uint16(26579),
		23:  uint16(26609),
		24:  uint16(26580),
		25:  uint16(26576),
		26:  uint16(26604),
		27:  uint16(26550),
		28:  uint16(26543),
		29:  uint16(26613),
		30:  uint16(26601),
		31:  uint16(26607),
		32:  uint16(26564),
		33:  uint16(26577),
		34:  uint16(26548),
		35:  uint16(26586),
		36:  uint16(26597),
		37:  uint16(26552),
		38:  uint16(26575),
		39:  uint16(26590),
		40:  uint16(26611),
		41:  uint16(26544),
		42:  uint16(26585),
		43:  uint16(26594),
		44:  uint16(26589),
		45:  uint16(26578),
		46:  uint16(27498),
		47:  uint16(27523),
		48:  uint16(27526),
		49:  uint16(27573),
		50:  uint16(27602),
		51:  uint16(27607),
		52:  uint16(27679),
		53:  uint16(27849),
		54:  uint16(27915),
		55:  uint16(27954),
		56:  uint16(27946),
		57:  uint16(27969),
		58:  uint16(27941),
		59:  uint16(27916),
		60:  uint16(27953),
		61:  uint16(27934),
		62:  uint16(27927),
		63:  uint16(27963),
		64:  uint16(27965),
		65:  uint16(27966),
		66:  uint16(27958),
		67:  uint16(27931),
		68:  uint16(27893),
		69:  uint16(27961),
		70:  uint16(27943),
		71:  uint16(27960),
		72:  uint16(27945),
		73:  uint16(27950),
		74:  uint16(27957),
		75:  uint16(27918),
		76:  uint16(27947),
		77:  uint16(28843),
		78:  uint16(28858),
		79:  uint16(28851),
		80:  uint16(28844),
		81:  uint16(28847),
		82:  uint16(28845),
		83:  uint16(28856),
		84:  uint16(28846),
		85:  uint16(28836),
		86:  uint16(29232),
		87:  uint16(29298),
		88:  uint16(29295),
		89:  uint16(29300),
		90:  uint16(29417),
		91:  uint16(29408),
		92:  uint16(29409),
		93:  uint16(29623),
		94:  uint16(29642),
		95:  uint16(29627),
		96:  uint16(29618),
		97:  uint16(29645),
		98:  uint16(29632),
		99:  uint16(29619),
		100: uint16(29978),
		101: uint16(29997),
		102: uint16(30031),
		103: uint16(30028),
		104: uint16(30030),
		105: uint16(30027),
		106: uint16(30123),
		107: uint16(30116),
		108: uint16(30117),
		109: uint16(30114),
		110: uint16(30115),
		111: uint16(30328),
		112: uint16(30342),
		113: uint16(30343),
		114: uint16(30344),
		115: uint16(30408),
		116: uint16(30406),
		117: uint16(30403),
		118: uint16(30405),
		119: uint16(30465),
		120: uint16(30457),
		121: uint16(30456),
		122: uint16(30473),
		123: uint16(30475),
		124: uint16(30462),
		125: uint16(30460),
		126: uint16(30471),
		127: uint16(30684),
		128: uint16(30722),
		129: uint16(30740),
		130: uint16(30732),
		131: uint16(30733),
		132: uint16(31046),
		133: uint16(31049),
		134: uint16(31048),
		135: uint16(31047),
		136: uint16(31161),
		137: uint16(31162),
		138: uint16(31185),
		139: uint16(31186),
		140: uint16(31179),
		141: uint16(31359),
		142: uint16(31361),
		143: uint16(31487),
		144: uint16(31485),
		145: uint16(31869),
		146: uint16(32002),
		147: uint16(32005),
		148: uint16(32000),
		149: uint16(32009),
		150: uint16(32007),
		151: uint16(32004),
		152: uint16(32006),
		153: uint16(32568),
		154: uint16(32654),
		155: uint16(32703),
		156: uint16(32772),
	},
	12: {
		0:   uint16(32784),
		1:   uint16(32781),
		2:   uint16(32785),
		3:   uint16(32822),
		4:   uint16(32982),
		5:   uint16(32997),
		6:   uint16(32986),
		7:   uint16(32963),
		8:   uint16(32964),
		9:   uint16(32972),
		10:  uint16(32993),
		11:  uint16(32987),
		12:  uint16(32974),
		13:  uint16(32990),
		14:  uint16(32996),
		15:  uint16(32989),
		16:  uint16(33268),
		17:  uint16(33314),
		18:  uint16(33511),
		19:  uint16(33539),
		20:  uint16(33541),
		21:  uint16(33507),
		22:  uint16(33499),
		23:  uint16(33510),
		24:  uint16(33540),
		25:  uint16(33509),
		26:  uint16(33538),
		27:  uint16(33545),
		28:  uint16(33490),
		29:  uint16(33495),
		30:  uint16(33521),
		31:  uint16(33537),
		32:  uint16(33500),
		33:  uint16(33492),
		34:  uint16(33489),
		35:  uint16(33502),
		36:  uint16(33491),
		37:  uint16(33503),
		38:  uint16(33519),
		39:  uint16(33542),
		40:  uint16(34384),
		41:  uint16(34425),
		42:  uint16(34427),
		43:  uint16(34426),
		44:  uint16(34893),
		45:  uint16(34923),
		46:  uint16(35201),
		47:  uint16(35284),
		48:  uint16(35336),
		49:  uint16(35330),
		50:  uint16(35331),
		51:  uint16(35998),
		52:  uint16(36000),
		53:  uint16(36212),
		54:  uint16(36211),
		55:  uint16(36276),
		56:  uint16(36557),
		57:  uint16(36556),
		58:  uint16(36848),
		59:  uint16(36838),
		60:  uint16(36834),
		61:  uint16(36842),
		62:  uint16(36837),
		63:  uint16(36845),
		64:  uint16(36843),
		65:  uint16(36836),
		66:  uint16(36840),
		67:  uint16(37066),
		68:  uint16(37070),
		69:  uint16(37057),
		70:  uint16(37059),
		71:  uint16(37195),
		72:  uint16(37194),
		73:  uint16(37325),
		74:  uint16(38274),
		75:  uint16(38480),
		76:  uint16(38475),
		77:  uint16(38476),
		78:  uint16(38477),
		79:  uint16(38754),
		80:  uint16(38761),
		81:  uint16(38859),
		82:  uint16(38893),
		83:  uint16(38899),
		84:  uint16(38913),
		85:  uint16(39080),
		86:  uint16(39131),
		87:  uint16(39135),
		88:  uint16(39318),
		89:  uint16(39321),
		90:  uint16(20056),
		91:  uint16(20147),
		92:  uint16(20492),
		93:  uint16(20493),
		94:  uint16(20515),
		95:  uint16(20463),
		96:  uint16(20518),
		97:  uint16(20517),
		98:  uint16(20472),
		99:  uint16(20521),
		100: uint16(20502),
		101: uint16(20486),
		102: uint16(20540),
		103: uint16(20511),
		104: uint16(20506),
		105: uint16(20498),
		106: uint16(20497),
		107: uint16(20474),
		108: uint16(20480),
		109: uint16(20500),
		110: uint16(20520),
		111: uint16(20465),
		112: uint16(20513),
		113: uint16(20491),
		114: uint16(20505),
		115: uint16(20504),
		116: uint16(20467),
		117: uint16(20462),
		118: uint16(20525),
		119: uint16(20522),
		120: uint16(20478),
		121: uint16(20523),
		122: uint16(20489),
		123: uint16(20860),
		124: uint16(20900),
		125: uint16(20901),
		126: uint16(20898),
		127: uint16(20941),
		128: uint16(20940),
		129: uint16(20934),
		130: uint16(20939),
		131: uint16(21078),
		132: uint16(21084),
		133: uint16(21076),
		134: uint16(21083),
		135: uint16(21085),
		136: uint16(21290),
		137: uint16(21375),
		138: uint16(21407),
		139: uint16(21405),
		140: uint16(21471),
		141: uint16(21736),
		142: uint16(21776),
		143: uint16(21761),
		144: uint16(21815),
		145: uint16(21756),
		146: uint16(21733),
		147: uint16(21746),
		148: uint16(21766),
		149: uint16(21754),
		150: uint16(21780),
		151: uint16(21737),
		152: uint16(21741),
		153: uint16(21729),
		154: uint16(21769),
		155: uint16(21742),
		156: uint16(21738),
	},
	13: {
		0:   uint16(21734),
		1:   uint16(21799),
		2:   uint16(21767),
		3:   uint16(21757),
		4:   uint16(21775),
		5:   uint16(22275),
		6:   uint16(22276),
		7:   uint16(22466),
		8:   uint16(22484),
		9:   uint16(22475),
		10:  uint16(22467),
		11:  uint16(22537),
		12:  uint16(22799),
		13:  uint16(22871),
		14:  uint16(22872),
		15:  uint16(22874),
		16:  uint16(23057),
		17:  uint16(23064),
		18:  uint16(23068),
		19:  uint16(23071),
		20:  uint16(23067),
		21:  uint16(23059),
		22:  uint16(23020),
		23:  uint16(23072),
		24:  uint16(23075),
		25:  uint16(23081),
		26:  uint16(23077),
		27:  uint16(23052),
		28:  uint16(23049),
		29:  uint16(23403),
		30:  uint16(23640),
		31:  uint16(23472),
		32:  uint16(23475),
		33:  uint16(23478),
		34:  uint16(23476),
		35:  uint16(23470),
		36:  uint16(23477),
		37:  uint16(23481),
		38:  uint16(23480),
		39:  uint16(23556),
		40:  uint16(23633),
		41:  uint16(23637),
		42:  uint16(23632),
		43:  uint16(23789),
		44:  uint16(23805),
		45:  uint16(23803),
		46:  uint16(23786),
		47:  uint16(23784),
		48:  uint16(23792),
		49:  uint16(23798),
		50:  uint16(23809),
		51:  uint16(23796),
		52:  uint16(24046),
		53:  uint16(24109),
		54:  uint16(24107),
		55:  uint16(24235),
		56:  uint16(24237),
		57:  uint16(24231),
		58:  uint16(24369),
		59:  uint16(24466),
		60:  uint16(24465),
		61:  uint16(24464),
		62:  uint16(24665),
		63:  uint16(24675),
		64:  uint16(24677),
		65:  uint16(24656),
		66:  uint16(24661),
		67:  uint16(24685),
		68:  uint16(24681),
		69:  uint16(24687),
		70:  uint16(24708),
		71:  uint16(24735),
		72:  uint16(24730),
		73:  uint16(24717),
		74:  uint16(24724),
		75:  uint16(24716),
		76:  uint16(24709),
		77:  uint16(24726),
		78:  uint16(25159),
		79:  uint16(25331),
		80:  uint16(25352),
		81:  uint16(25343),
		82:  uint16(25422),
		83:  uint16(25406),
		84:  uint16(25391),
		85:  uint16(25429),
		86:  uint16(25410),
		87:  uint16(25414),
		88:  uint16(25423),
		89:  uint16(25417),
		90:  uint16(25402),
		91:  uint16(25424),
		92:  uint16(25405),
		93:  uint16(25386),
		94:  uint16(25387),
		95:  uint16(25384),
		96:  uint16(25421),
		97:  uint16(25420),
		98:  uint16(25928),
		99:  uint16(25929),
		100: uint16(26009),
		101: uint16(26049),
		102: uint16(26053),
		103: uint16(26178),
		104: uint16(26185),
		105: uint16(26191),
		106: uint16(26179),
		107: uint16(26194),
		108: uint16(26188),
		109: uint16(26181),
		110: uint16(26177),
		111: uint16(26360),
		112: uint16(26388),
		113: uint16(26389),
		114: uint16(26391),
		115: uint16(26657),
		116: uint16(26680),
		117: uint16(26696),
		118: uint16(26694),
		119: uint16(26707),
		120: uint16(26681),
		121: uint16(26690),
		122: uint16(26708),
		123: uint16(26665),
		124: uint16(26803),
		125: uint16(26647),
		126: uint16(26700),
		127: uint16(26705),
		128: uint16(26685),
		129: uint16(26612),
		130: uint16(26704),
		131: uint16(26688),
		132: uint16(26684),
		133: uint16(26691),
		134: uint16(26666),
		135: uint16(26693),
		136: uint16(26643),
		137: uint16(26648),
		138: uint16(26689),
		139: uint16(27530),
		140: uint16(27529),
		141: uint16(27575),
		142: uint16(27683),
		143: uint16(27687),
		144: uint16(27688),
		145: uint16(27686),
		146: uint16(27684),
		147: uint16(27888),
		148: uint16(28010),
		149: uint16(28053),
		150: uint16(28040),
		151: uint16(28039),
		152: uint16(28006),
		153: uint16(28024),
		154: uint16(28023),
		155: uint16(27993),
		156: uint16(28051),
	},
	14: {
		0:   uint16(28012),
		1:   uint16(28041),
		2:   uint16(28014),
		3:   uint16(27994),
		4:   uint16(28020),
		5:   uint16(28009),
		6:   uint16(28044),
		7:   uint16(28042),
		8:   uint16(28025),
		9:   uint16(28037),
		10:  uint16(28005),
		11:  uint16(28052),
		12:  uint16(28874),
		13:  uint16(28888),
		14:  uint16(28900),
		15:  uint16(28889),
		16:  uint16(28872),
		17:  uint16(28879),
		18:  uint16(29241),
		19:  uint16(29305),
		20:  uint16(29436),
		21:  uint16(29433),
		22:  uint16(29437),
		23:  uint16(29432),
		24:  uint16(29431),
		25:  uint16(29574),
		26:  uint16(29677),
		27:  uint16(29705),
		28:  uint16(29678),
		29:  uint16(29664),
		30:  uint16(29674),
		31:  uint16(29662),
		32:  uint16(30036),
		33:  uint16(30045),
		34:  uint16(30044),
		35:  uint16(30042),
		36:  uint16(30041),
		37:  uint16(30142),
		38:  uint16(30149),
		39:  uint16(30151),
		40:  uint16(30130),
		41:  uint16(30131),
		42:  uint16(30141),
		43:  uint16(30140),
		44:  uint16(30137),
		45:  uint16(30146),
		46:  uint16(30136),
		47:  uint16(30347),
		48:  uint16(30384),
		49:  uint16(30410),
		50:  uint16(30413),
		51:  uint16(30414),
		52:  uint16(30505),
		53:  uint16(30495),
		54:  uint16(30496),
		55:  uint16(30504),
		56:  uint16(30697),
		57:  uint16(30768),
		58:  uint16(30759),
		59:  uint16(30776),
		60:  uint16(30749),
		61:  uint16(30772),
		62:  uint16(30775),
		63:  uint16(30757),
		64:  uint16(30765),
		65:  uint16(30752),
		66:  uint16(30751),
		67:  uint16(30770),
		68:  uint16(31061),
		69:  uint16(31056),
		70:  uint16(31072),
		71:  uint16(31071),
		72:  uint16(31062),
		73:  uint16(31070),
		74:  uint16(31069),
		75:  uint16(31063),
		76:  uint16(31066),
		77:  uint16(31204),
		78:  uint16(31203),
		79:  uint16(31207),
		80:  uint16(31199),
		81:  uint16(31206),
		82:  uint16(31209),
		83:  uint16(31192),
		84:  uint16(31364),
		85:  uint16(31368),
		86:  uint16(31449),
		87:  uint16(31494),
		88:  uint16(31505),
		89:  uint16(31881),
		90:  uint16(32033),
		91:  uint16(32023),
		92:  uint16(32011),
		93:  uint16(32010),
		94:  uint16(32032),
		95:  uint16(32034),
		96:  uint16(32020),
		97:  uint16(32016),
		98:  uint16(32021),
		99:  uint16(32026),
		100: uint16(32028),
		101: uint16(32013),
		102: uint16(32025),
		103: uint16(32027),
		104: uint16(32570),
		105: uint16(32607),
		106: uint16(32660),
		107: uint16(32709),
		108: uint16(32705),
		109: uint16(32774),
		110: uint16(32792),
		111: uint16(32789),
		112: uint16(32793),
		113: uint16(32791),
		114: uint16(32829),
		115: uint16(32831),
		116: uint16(33009),
		117: uint16(33026),
		118: uint16(33008),
		119: uint16(33029),
		120: uint16(33005),
		121: uint16(33012),
		122: uint16(33030),
		123: uint16(33016),
		124: uint16(33011),
		125: uint16(33032),
		126: uint16(33021),
		127: uint16(33034),
		128: uint16(33020),
		129: uint16(33007),
		130: uint16(33261),
		131: uint16(33260),
		132: uint16(33280),
		133: uint16(33296),
		134: uint16(33322),
		135: uint16(33323),
		136: uint16(33320),
		137: uint16(33324),
		138: uint16(33467),
		139: uint16(33579),
		140: uint16(33618),
		141: uint16(33620),
		142: uint16(33610),
		143: uint16(33592),
		144: uint16(33616),
		145: uint16(33609),
		146: uint16(33589),
		147: uint16(33588),
		148: uint16(33615),
		149: uint16(33586),
		150: uint16(33593),
		151: uint16(33590),
		152: uint16(33559),
		153: uint16(33600),
		154: uint16(33585),
		155: uint16(33576),
		156: uint16(33603),
	},
	15: {
		0:   uint16(34388),
		1:   uint16(34442),
		2:   uint16(34474),
		3:   uint16(34451),
		4:   uint16(34468),
		5:   uint16(34473),
		6:   uint16(34444),
		7:   uint16(34467),
		8:   uint16(34460),
		9:   uint16(34928),
		10:  uint16(34935),
		11:  uint16(34945),
		12:  uint16(34946),
		13:  uint16(34941),
		14:  uint16(34937),
		15:  uint16(35352),
		16:  uint16(35344),
		17:  uint16(35342),
		18:  uint16(35340),
		19:  uint16(35349),
		20:  uint16(35338),
		21:  uint16(35351),
		22:  uint16(35347),
		23:  uint16(35350),
		24:  uint16(35343),
		25:  uint16(35345),
		26:  uint16(35912),
		27:  uint16(35962),
		28:  uint16(35961),
		29:  uint16(36001),
		30:  uint16(36002),
		31:  uint16(36215),
		32:  uint16(36524),
		33:  uint16(36562),
		34:  uint16(36564),
		35:  uint16(36559),
		36:  uint16(36785),
		37:  uint16(36865),
		38:  uint16(36870),
		39:  uint16(36855),
		40:  uint16(36864),
		41:  uint16(36858),
		42:  uint16(36852),
		43:  uint16(36867),
		44:  uint16(36861),
		45:  uint16(36869),
		46:  uint16(36856),
		47:  uint16(37013),
		48:  uint16(37089),
		49:  uint16(37085),
		50:  uint16(37090),
		51:  uint16(37202),
		52:  uint16(37197),
		53:  uint16(37196),
		54:  uint16(37336),
		55:  uint16(37341),
		56:  uint16(37335),
		57:  uint16(37340),
		58:  uint16(37337),
		59:  uint16(38275),
		60:  uint16(38498),
		61:  uint16(38499),
		62:  uint16(38497),
		63:  uint16(38491),
		64:  uint16(38493),
		65:  uint16(38500),
		66:  uint16(38488),
		67:  uint16(38494),
		68:  uint16(38587),
		69:  uint16(39138),
		70:  uint16(39340),
		71:  uint16(39592),
		72:  uint16(39640),
		73:  uint16(39717),
		74:  uint16(39730),
		75:  uint16(39740),
		76:  uint16(20094),
		77:  uint16(20602),
		78:  uint16(20605),
		79:  uint16(20572),
		80:  uint16(20551),
		81:  uint16(20547),
		82:  uint16(20556),
		83:  uint16(20570),
		84:  uint16(20553),
		85:  uint16(20581),
		86:  uint16(20598),
		87:  uint16(20558),
		88:  uint16(20565),
		89:  uint16(20597),
		90:  uint16(20596),
		91:  uint16(20599),
		92:  uint16(20559),
		93:  uint16(20495),
		94:  uint16(20591),
		95:  uint16(20589),
		96:  uint16(20828),
		97:  uint16(20885),
		98:  uint16(20976),
		99:  uint16(21098),
		100: uint16(21103),
		101: uint16(21202),
		102: uint16(21209),
		103: uint16(21208),
		104: uint16(21205),
		105: uint16(21264),
		106: uint16(21263),
		107: uint16(21273),
		108: uint16(21311),
		109: uint16(21312),
		110: uint16(21310),
		111: uint16(21443),
		112: uint16(26364),
		113: uint16(21830),
		114: uint16(21866),
		115: uint16(21862),
		116: uint16(21828),
		117: uint16(21854),
		118: uint16(21857),
		119: uint16(21827),
		120: uint16(21834),
		121: uint16(21809),
		122: uint16(21846),
		123: uint16(21839),
		124: uint16(21845),
		125: uint16(21807),
		126: uint16(21860),
		127: uint16(21816),
		128: uint16(21806),
		129: uint16(21852),
		130: uint16(21804),
		131: uint16(21859),
		132: uint16(21811),
		133: uint16(21825),
		134: uint16(21847),
		135: uint16(22280),
		136: uint16(22283),
		137: uint16(22281),
		138: uint16(22495),
		139: uint16(22533),
		140: uint16(22538),
		141: uint16(22534),
		142: uint16(22496),
		143: uint16(22500),
		144: uint16(22522),
		145: uint16(22530),
		146: uint16(22581),
		147: uint16(22519),
		148: uint16(22521),
		149: uint16(22816),
		150: uint16(22882),
		151: uint16(23094),
		152: uint16(23105),
		153: uint16(23113),
		154: uint16(23142),
		155: uint16(23146),
		156: uint16(23104),
	},
	16: {
		0:   uint16(23100),
		1:   uint16(23138),
		2:   uint16(23130),
		3:   uint16(23110),
		4:   uint16(23114),
		5:   uint16(23408),
		6:   uint16(23495),
		7:   uint16(23493),
		8:   uint16(23492),
		9:   uint16(23490),
		10:  uint16(23487),
		11:  uint16(23494),
		12:  uint16(23561),
		13:  uint16(23560),
		14:  uint16(23559),
		15:  uint16(23648),
		16:  uint16(23644),
		17:  uint16(23645),
		18:  uint16(23815),
		19:  uint16(23814),
		20:  uint16(23822),
		21:  uint16(23835),
		22:  uint16(23830),
		23:  uint16(23842),
		24:  uint16(23825),
		25:  uint16(23849),
		26:  uint16(23828),
		27:  uint16(23833),
		28:  uint16(23844),
		29:  uint16(23847),
		30:  uint16(23831),
		31:  uint16(24034),
		32:  uint16(24120),
		33:  uint16(24118),
		34:  uint16(24115),
		35:  uint16(24119),
		36:  uint16(24247),
		37:  uint16(24248),
		38:  uint16(24246),
		39:  uint16(24245),
		40:  uint16(24254),
		41:  uint16(24373),
		42:  uint16(24375),
		43:  uint16(24407),
		44:  uint16(24428),
		45:  uint16(24425),
		46:  uint16(24427),
		47:  uint16(24471),
		48:  uint16(24473),
		49:  uint16(24478),
		50:  uint16(24472),
		51:  uint16(24481),
		52:  uint16(24480),
		53:  uint16(24476),
		54:  uint16(24703),
		55:  uint16(24739),
		56:  uint16(24713),
		57:  uint16(24736),
		58:  uint16(24744),
		59:  uint16(24779),
		60:  uint16(24756),
		61:  uint16(24806),
		62:  uint16(24765),
		63:  uint16(24773),
		64:  uint16(24763),
		65:  uint16(24757),
		66:  uint16(24796),
		67:  uint16(24764),
		68:  uint16(24792),
		69:  uint16(24789),
		70:  uint16(24774),
		71:  uint16(24799),
		72:  uint16(24760),
		73:  uint16(24794),
		74:  uint16(24775),
		75:  uint16(25114),
		76:  uint16(25115),
		77:  uint16(25160),
		78:  uint16(25504),
		79:  uint16(25511),
		80:  uint16(25458),
		81:  uint16(25494),
		82:  uint16(25506),
		83:  uint16(25509),
		84:  uint16(25463),
		85:  uint16(25447),
		86:  uint16(25496),
		87:  uint16(25514),
		88:  uint16(25457),
		89:  uint16(25513),
		90:  uint16(25481),
		91:  uint16(25475),
		92:  uint16(25499),
		93:  uint16(25451),
		94:  uint16(25512),
		95:  uint16(25476),
		96:  uint16(25480),
		97:  uint16(25497),
		98:  uint16(25505),
		99:  uint16(25516),
		100: uint16(25490),
		101: uint16(25487),
		102: uint16(25472),
		103: uint16(25467),
		104: uint16(25449),
		105: uint16(25448),
		106: uint16(25466),
		107: uint16(25949),
		108: uint16(25942),
		109: uint16(25937),
		110: uint16(25945),
		111: uint16(25943),
		112: uint16(21855),
		113: uint16(25935),
		114: uint16(25944),
		115: uint16(25941),
		116: uint16(25940),
		117: uint16(26012),
		118: uint16(26011),
		119: uint16(26028),
		120: uint16(26063),
		121: uint16(26059),
		122: uint16(26060),
		123: uint16(26062),
		124: uint16(26205),
		125: uint16(26202),
		126: uint16(26212),
		127: uint16(26216),
		128: uint16(26214),
		129: uint16(26206),
		130: uint16(26361),
		131: uint16(21207),
		132: uint16(26395),
		133: uint16(26753),
		134: uint16(26799),
		135: uint16(26786),
		136: uint16(26771),
		137: uint16(26805),
		138: uint16(26751),
		139: uint16(26742),
		140: uint16(26801),
		141: uint16(26791),
		142: uint16(26775),
		143: uint16(26800),
		144: uint16(26755),
		145: uint16(26820),
		146: uint16(26797),
		147: uint16(26758),
		148: uint16(26757),
		149: uint16(26772),
		150: uint16(26781),
		151: uint16(26792),
		152: uint16(26783),
		153: uint16(26785),
		154: uint16(26754),
		155: uint16(27442),
		156: uint16(27578),
	},
	17: {
		0:   uint16(27627),
		1:   uint16(27628),
		2:   uint16(27691),
		3:   uint16(28046),
		4:   uint16(28092),
		5:   uint16(28147),
		6:   uint16(28121),
		7:   uint16(28082),
		8:   uint16(28129),
		9:   uint16(28108),
		10:  uint16(28132),
		11:  uint16(28155),
		12:  uint16(28154),
		13:  uint16(28165),
		14:  uint16(28103),
		15:  uint16(28107),
		16:  uint16(28079),
		17:  uint16(28113),
		18:  uint16(28078),
		19:  uint16(28126),
		20:  uint16(28153),
		21:  uint16(28088),
		22:  uint16(28151),
		23:  uint16(28149),
		24:  uint16(28101),
		25:  uint16(28114),
		26:  uint16(28186),
		27:  uint16(28085),
		28:  uint16(28122),
		29:  uint16(28139),
		30:  uint16(28120),
		31:  uint16(28138),
		32:  uint16(28145),
		33:  uint16(28142),
		34:  uint16(28136),
		35:  uint16(28102),
		36:  uint16(28100),
		37:  uint16(28074),
		38:  uint16(28140),
		39:  uint16(28095),
		40:  uint16(28134),
		41:  uint16(28921),
		42:  uint16(28937),
		43:  uint16(28938),
		44:  uint16(28925),
		45:  uint16(28911),
		46:  uint16(29245),
		47:  uint16(29309),
		48:  uint16(29313),
		49:  uint16(29468),
		50:  uint16(29467),
		51:  uint16(29462),
		52:  uint16(29459),
		53:  uint16(29465),
		54:  uint16(29575),
		55:  uint16(29701),
		56:  uint16(29706),
		57:  uint16(29699),
		58:  uint16(29702),
		59:  uint16(29694),
		60:  uint16(29709),
		61:  uint16(29920),
		62:  uint16(29942),
		63:  uint16(29943),
		64:  uint16(29980),
		65:  uint16(29986),
		66:  uint16(30053),
		67:  uint16(30054),
		68:  uint16(30050),
		69:  uint16(30064),
		70:  uint16(30095),
		71:  uint16(30164),
		72:  uint16(30165),
		73:  uint16(30133),
		74:  uint16(30154),
		75:  uint16(30157),
		76:  uint16(30350),
		77:  uint16(30420),
		78:  uint16(30418),
		79:  uint16(30427),
		80:  uint16(30519),
		81:  uint16(30526),
		82:  uint16(30524),
		83:  uint16(30518),
		84:  uint16(30520),
		85:  uint16(30522),
		86:  uint16(30827),
		87:  uint16(30787),
		88:  uint16(30798),
		89:  uint16(31077),
		90:  uint16(31080),
		91:  uint16(31085),
		92:  uint16(31227),
		93:  uint16(31378),
		94:  uint16(31381),
		95:  uint16(31520),
		96:  uint16(31528),
		97:  uint16(31515),
		98:  uint16(31532),
		99:  uint16(31526),
		100: uint16(31513),
		101: uint16(31518),
		102: uint16(31534),
		103: uint16(31890),
		104: uint16(31895),
		105: uint16(31893),
		106: uint16(32070),
		107: uint16(32067),
		108: uint16(32113),
		109: uint16(32046),
		110: uint16(32057),
		111: uint16(32060),
		112: uint16(32064),
		113: uint16(32048),
		114: uint16(32051),
		115: uint16(32068),
		116: uint16(32047),
		117: uint16(32066),
		118: uint16(32050),
		119: uint16(32049),
		120: uint16(32573),
		121: uint16(32670),
		122: uint16(32666),
		123: uint16(32716),
		124: uint16(32718),
		125: uint16(32722),
		126: uint16(32796),
		127: uint16(32842),
		128: uint16(32838),
		129: uint16(33071),
		130: uint16(33046),
		131: uint16(33059),
		132: uint16(33067),
		133: uint16(33065),
		134: uint16(33072),
		135: uint16(33060),
		136: uint16(33282),
		137: uint16(33333),
		138: uint16(33335),
		139: uint16(33334),
		140: uint16(33337),
		141: uint16(33678),
		142: uint16(33694),
		143: uint16(33688),
		144: uint16(33656),
		145: uint16(33698),
		146: uint16(33686),
		147: uint16(33725),
		148: uint16(33707),
		149: uint16(33682),
		150: uint16(33674),
		151: uint16(33683),
		152: uint16(33673),
		153: uint16(33696),
		154: uint16(33655),
		155: uint16(33659),
		156: uint16(33660),
	},
	18: {
		0:   uint16(33670),
		1:   uint16(33703),
		2:   uint16(34389),
		3:   uint16(24426),
		4:   uint16(34503),
		5:   uint16(34496),
		6:   uint16(34486),
		7:   uint16(34500),
		8:   uint16(34485),
		9:   uint16(34502),
		10:  uint16(34507),
		11:  uint16(34481),
		12:  uint16(34479),
		13:  uint16(34505),
		14:  uint16(34899),
		15:  uint16(34974),
		16:  uint16(34952),
		17:  uint16(34987),
		18:  uint16(34962),
		19:  uint16(34966),
		20:  uint16(34957),
		21:  uint16(34955),
		22:  uint16(35219),
		23:  uint16(35215),
		24:  uint16(35370),
		25:  uint16(35357),
		26:  uint16(35363),
		27:  uint16(35365),
		28:  uint16(35377),
		29:  uint16(35373),
		30:  uint16(35359),
		31:  uint16(35355),
		32:  uint16(35362),
		33:  uint16(35913),
		34:  uint16(35930),
		35:  uint16(36009),
		36:  uint16(36012),
		37:  uint16(36011),
		38:  uint16(36008),
		39:  uint16(36010),
		40:  uint16(36007),
		41:  uint16(36199),
		42:  uint16(36198),
		43:  uint16(36286),
		44:  uint16(36282),
		45:  uint16(36571),
		46:  uint16(36575),
		47:  uint16(36889),
		48:  uint16(36877),
		49:  uint16(36890),
		50:  uint16(36887),
		51:  uint16(36899),
		52:  uint16(36895),
		53:  uint16(36893),
		54:  uint16(36880),
		55:  uint16(36885),
		56:  uint16(36894),
		57:  uint16(36896),
		58:  uint16(36879),
		59:  uint16(36898),
		60:  uint16(36886),
		61:  uint16(36891),
		62:  uint16(36884),
		63:  uint16(37096),
		64:  uint16(37101),
		65:  uint16(37117),
		66:  uint16(37207),
		67:  uint16(37326),
		68:  uint16(37365),
		69:  uint16(37350),
		70:  uint16(37347),
		71:  uint16(37351),
		72:  uint16(37357),
		73:  uint16(37353),
		74:  uint16(38281),
		75:  uint16(38506),
		76:  uint16(38517),
		77:  uint16(38515),
		78:  uint16(38520),
		79:  uint16(38512),
		80:  uint16(38516),
		81:  uint16(38518),
		82:  uint16(38519),
		83:  uint16(38508),
		84:  uint16(38592),
		85:  uint16(38634),
		86:  uint16(38633),
		87:  uint16(31456),
		88:  uint16(31455),
		89:  uint16(38914),
		90:  uint16(38915),
		91:  uint16(39770),
		92:  uint16(40165),
		93:  uint16(40565),
		94:  uint16(40575),
		95:  uint16(40613),
		96:  uint16(40635),
		97:  uint16(20642),
		98:  uint16(20621),
		99:  uint16(20613),
		100: uint16(20633),
		101: uint16(20625),
		102: uint16(20608),
		103: uint16(20630),
		104: uint16(20632),
		105: uint16(20634),
		106: uint16(26368),
		107: uint16(20977),
		108: uint16(21106),
		109: uint16(21108),
		110: uint16(21109),
		111: uint16(21097),
		112: uint16(21214),
		113: uint16(21213),
		114: uint16(21211),
		115: uint16(21338),
		116: uint16(21413),
		117: uint16(21883),
		118: uint16(21888),
		119: uint16(21927),
		120: uint16(21884),
		121: uint16(21898),
		122: uint16(21917),
		123: uint16(21912),
		124: uint16(21890),
		125: uint16(21916),
		126: uint16(21930),
		127: uint16(21908),
		128: uint16(21895),
		129: uint16(21899),
		130: uint16(21891),
		131: uint16(21939),
		132: uint16(21934),
		133: uint16(21919),
		134: uint16(21822),
		135: uint16(21938),
		136: uint16(21914),
		137: uint16(21947),
		138: uint16(21932),
		139: uint16(21937),
		140: uint16(21886),
		141: uint16(21897),
		142: uint16(21931),
		143: uint16(21913),
		144: uint16(22285),
		145: uint16(22575),
		146: uint16(22570),
		147: uint16(22580),
		148: uint16(22564),
		149: uint16(22576),
		150: uint16(22577),
		151: uint16(22561),
		152: uint16(22557),
		153: uint16(22560),
		154: uint16(22777),
		155: uint16(22778),
		156: uint16(22880),
	},
	19: {
		0:   uint16(23159),
		1:   uint16(23194),
		2:   uint16(23167),
		3:   uint16(23186),
		4:   uint16(23195),
		5:   uint16(23207),
		6:   uint16(23411),
		7:   uint16(23409),
		8:   uint16(23506),
		9:   uint16(23500),
		10:  uint16(23507),
		11:  uint16(23504),
		12:  uint16(23562),
		13:  uint16(23563),
		14:  uint16(23601),
		15:  uint16(23884),
		16:  uint16(23888),
		17:  uint16(23860),
		18:  uint16(23879),
		19:  uint16(24061),
		20:  uint16(24133),
		21:  uint16(24125),
		22:  uint16(24128),
		23:  uint16(24131),
		24:  uint16(24190),
		25:  uint16(24266),
		26:  uint16(24257),
		27:  uint16(24258),
		28:  uint16(24260),
		29:  uint16(24380),
		30:  uint16(24429),
		31:  uint16(24489),
		32:  uint16(24490),
		33:  uint16(24488),
		34:  uint16(24785),
		35:  uint16(24801),
		36:  uint16(24754),
		37:  uint16(24758),
		38:  uint16(24800),
		39:  uint16(24860),
		40:  uint16(24867),
		41:  uint16(24826),
		42:  uint16(24853),
		43:  uint16(24816),
		44:  uint16(24827),
		45:  uint16(24820),
		46:  uint16(24936),
		47:  uint16(24817),
		48:  uint16(24846),
		49:  uint16(24822),
		50:  uint16(24841),
		51:  uint16(24832),
		52:  uint16(24850),
		53:  uint16(25119),
		54:  uint16(25161),
		55:  uint16(25507),
		56:  uint16(25484),
		57:  uint16(25551),
		58:  uint16(25536),
		59:  uint16(25577),
		60:  uint16(25545),
		61:  uint16(25542),
		62:  uint16(25549),
		63:  uint16(25554),
		64:  uint16(25571),
		65:  uint16(25552),
		66:  uint16(25569),
		67:  uint16(25558),
		68:  uint16(25581),
		69:  uint16(25582),
		70:  uint16(25462),
		71:  uint16(25588),
		72:  uint16(25578),
		73:  uint16(25563),
		74:  uint16(25682),
		75:  uint16(25562),
		76:  uint16(25593),
		77:  uint16(25950),
		78:  uint16(25958),
		79:  uint16(25954),
		80:  uint16(25955),
		81:  uint16(26001),
		82:  uint16(26000),
		83:  uint16(26031),
		84:  uint16(26222),
		85:  uint16(26224),
		86:  uint16(26228),
		87:  uint16(26230),
		88:  uint16(26223),
		89:  uint16(26257),
		90:  uint16(26234),
		91:  uint16(26238),
		92:  uint16(26231),
		93:  uint16(26366),
		94:  uint16(26367),
		95:  uint16(26399),
		96:  uint16(26397),
		97:  uint16(26874),
		98:  uint16(26837),
		99:  uint16(26848),
		100: uint16(26840),
		101: uint16(26839),
		102: uint16(26885),
		103: uint16(26847),
		104: uint16(26869),
		105: uint16(26862),
		106: uint16(26855),
		107: uint16(26873),
		108: uint16(26834),
		109: uint16(26866),
		110: uint16(26851),
		111: uint16(26827),
		112: uint16(26829),
		113: uint16(26893),
		114: uint16(26898),
		115: uint16(26894),
		116: uint16(26825),
		117: uint16(26842),
		118: uint16(26990),
		119: uint16(26875),
		120: uint16(27454),
		121: uint16(27450),
		122: uint16(27453),
		123: uint16(27544),
		124: uint16(27542),
		125: uint16(27580),
		126: uint16(27631),
		127: uint16(27694),
		128: uint16(27695),
		129: uint16(27692),
		130: uint16(28207),
		131: uint16(28216),
		132: uint16(28244),
		133: uint16(28193),
		134: uint16(28210),
		135: uint16(28263),
		136: uint16(28234),
		137: uint16(28192),
		138: uint16(28197),
		139: uint16(28195),
		140: uint16(28187),
		141: uint16(28251),
		142: uint16(28248),
		143: uint16(28196),
		144: uint16(28246),
		145: uint16(28270),
		146: uint16(28205),
		147: uint16(28198),
		148: uint16(28271),
		149: uint16(28212),
		150: uint16(28237),
		151: uint16(28218),
		152: uint16(28204),
		153: uint16(28227),
		154: uint16(28189),
		155: uint16(28222),
		156: uint16(28363),
	},
	20: {
		0:   uint16(28297),
		1:   uint16(28185),
		2:   uint16(28238),
		3:   uint16(28259),
		4:   uint16(28228),
		5:   uint16(28274),
		6:   uint16(28265),
		7:   uint16(28255),
		8:   uint16(28953),
		9:   uint16(28954),
		10:  uint16(28966),
		11:  uint16(28976),
		12:  uint16(28961),
		13:  uint16(28982),
		14:  uint16(29038),
		15:  uint16(28956),
		16:  uint16(29260),
		17:  uint16(29316),
		18:  uint16(29312),
		19:  uint16(29494),
		20:  uint16(29477),
		21:  uint16(29492),
		22:  uint16(29481),
		23:  uint16(29754),
		24:  uint16(29738),
		25:  uint16(29747),
		26:  uint16(29730),
		27:  uint16(29733),
		28:  uint16(29749),
		29:  uint16(29750),
		30:  uint16(29748),
		31:  uint16(29743),
		32:  uint16(29723),
		33:  uint16(29734),
		34:  uint16(29736),
		35:  uint16(29989),
		36:  uint16(29990),
		37:  uint16(30059),
		38:  uint16(30058),
		39:  uint16(30178),
		40:  uint16(30171),
		41:  uint16(30179),
		42:  uint16(30169),
		43:  uint16(30168),
		44:  uint16(30174),
		45:  uint16(30176),
		46:  uint16(30331),
		47:  uint16(30332),
		48:  uint16(30358),
		49:  uint16(30355),
		50:  uint16(30388),
		51:  uint16(30428),
		52:  uint16(30543),
		53:  uint16(30701),
		54:  uint16(30813),
		55:  uint16(30828),
		56:  uint16(30831),
		57:  uint16(31245),
		58:  uint16(31240),
		59:  uint16(31243),
		60:  uint16(31237),
		61:  uint16(31232),
		62:  uint16(31384),
		63:  uint16(31383),
		64:  uint16(31382),
		65:  uint16(31461),
		66:  uint16(31459),
		67:  uint16(31561),
		68:  uint16(31574),
		69:  uint16(31558),
		70:  uint16(31568),
		71:  uint16(31570),
		72:  uint16(31572),
		73:  uint16(31565),
		74:  uint16(31563),
		75:  uint16(31567),
		76:  uint16(31569),
		77:  uint16(31903),
		78:  uint16(31909),
		79:  uint16(32094),
		80:  uint16(32080),
		81:  uint16(32104),
		82:  uint16(32085),
		83:  uint16(32043),
		84:  uint16(32110),
		85:  uint16(32114),
		86:  uint16(32097),
		87:  uint16(32102),
		88:  uint16(32098),
		89:  uint16(32112),
		90:  uint16(32115),
		91:  uint16(21892),
		92:  uint16(32724),
		93:  uint16(32725),
		94:  uint16(32779),
		95:  uint16(32850),
		96:  uint16(32901),
		97:  uint16(33109),
		98:  uint16(33108),
		99:  uint16(33099),
		100: uint16(33105),
		101: uint16(33102),
		102: uint16(33081),
		103: uint16(33094),
		104: uint16(33086),
		105: uint16(33100),
		106: uint16(33107),
		107: uint16(33140),
		108: uint16(33298),
		109: uint16(33308),
		110: uint16(33769),
		111: uint16(33795),
		112: uint16(33784),
		113: uint16(33805),
		114: uint16(33760),
		115: uint16(33733),
		116: uint16(33803),
		117: uint16(33729),
		118: uint16(33775),
		119: uint16(33777),
		120: uint16(33780),
		121: uint16(33879),
		122: uint16(33802),
		123: uint16(33776),
		124: uint16(33804),
		125: uint16(33740),
		126: uint16(33789),
		127: uint16(33778),
		128: uint16(33738),
		129: uint16(33848),
		130: uint16(33806),
		131: uint16(33796),
		132: uint16(33756),
		133: uint16(33799),
		134: uint16(33748),
		135: uint16(33759),
		136: uint16(34395),
		137: uint16(34527),
		138: uint16(34521),
		139: uint16(34541),
		140: uint16(34516),
		141: uint16(34523),
		142: uint16(34532),
		143: uint16(34512),
		144: uint16(34526),
		145: uint16(34903),
		146: uint16(35009),
		147: uint16(35010),
		148: uint16(34993),
		149: uint16(35203),
		150: uint16(35222),
		151: uint16(35387),
		152: uint16(35424),
		153: uint16(35413),
		154: uint16(35422),
		155: uint16(35388),
		156: uint16(35393),
	},
	21: {
		0:   uint16(35412),
		1:   uint16(35419),
		2:   uint16(35408),
		3:   uint16(35398),
		4:   uint16(35380),
		5:   uint16(35386),
		6:   uint16(35382),
		7:   uint16(35414),
		8:   uint16(35937),
		9:   uint16(35970),
		10:  uint16(36015),
		11:  uint16(36028),
		12:  uint16(36019),
		13:  uint16(36029),
		14:  uint16(36033),
		15:  uint16(36027),
		16:  uint16(36032),
		17:  uint16(36020),
		18:  uint16(36023),
		19:  uint16(36022),
		20:  uint16(36031),
		21:  uint16(36024),
		22:  uint16(36234),
		23:  uint16(36229),
		24:  uint16(36225),
		25:  uint16(36302),
		26:  uint16(36317),
		27:  uint16(36299),
		28:  uint16(36314),
		29:  uint16(36305),
		30:  uint16(36300),
		31:  uint16(36315),
		32:  uint16(36294),
		33:  uint16(36603),
		34:  uint16(36600),
		35:  uint16(36604),
		36:  uint16(36764),
		37:  uint16(36910),
		38:  uint16(36917),
		39:  uint16(36913),
		40:  uint16(36920),
		41:  uint16(36914),
		42:  uint16(36918),
		43:  uint16(37122),
		44:  uint16(37109),
		45:  uint16(37129),
		46:  uint16(37118),
		47:  uint16(37219),
		48:  uint16(37221),
		49:  uint16(37327),
		50:  uint16(37396),
		51:  uint16(37397),
		52:  uint16(37411),
		53:  uint16(37385),
		54:  uint16(37406),
		55:  uint16(37389),
		56:  uint16(37392),
		57:  uint16(37383),
		58:  uint16(37393),
		59:  uint16(38292),
		60:  uint16(38287),
		61:  uint16(38283),
		62:  uint16(38289),
		63:  uint16(38291),
		64:  uint16(38290),
		65:  uint16(38286),
		66:  uint16(38538),
		67:  uint16(38542),
		68:  uint16(38539),
		69:  uint16(38525),
		70:  uint16(38533),
		71:  uint16(38534),
		72:  uint16(38541),
		73:  uint16(38514),
		74:  uint16(38532),
		75:  uint16(38593),
		76:  uint16(38597),
		77:  uint16(38596),
		78:  uint16(38598),
		79:  uint16(38599),
		80:  uint16(38639),
		81:  uint16(38642),
		82:  uint16(38860),
		83:  uint16(38917),
		84:  uint16(38918),
		85:  uint16(38920),
		86:  uint16(39143),
		87:  uint16(39146),
		88:  uint16(39151),
		89:  uint16(39145),
		90:  uint16(39154),
		91:  uint16(39149),
		92:  uint16(39342),
		93:  uint16(39341),
		94:  uint16(40643),
		95:  uint16(40653),
		96:  uint16(40657),
		97:  uint16(20098),
		98:  uint16(20653),
		99:  uint16(20661),
		100: uint16(20658),
		101: uint16(20659),
		102: uint16(20677),
		103: uint16(20670),
		104: uint16(20652),
		105: uint16(20663),
		106: uint16(20667),
		107: uint16(20655),
		108: uint16(20679),
		109: uint16(21119),
		110: uint16(21111),
		111: uint16(21117),
		112: uint16(21215),
		113: uint16(21222),
		114: uint16(21220),
		115: uint16(21218),
		116: uint16(21219),
		117: uint16(21295),
		118: uint16(21983),
		119: uint16(21992),
		120: uint16(21971),
		121: uint16(21990),
		122: uint16(21966),
		123: uint16(21980),
		124: uint16(21959),
		125: uint16(21969),
		126: uint16(21987),
		127: uint16(21988),
		128: uint16(21999),
		129: uint16(21978),
		130: uint16(21985),
		131: uint16(21957),
		132: uint16(21958),
		133: uint16(21989),
		134: uint16(21961),
		135: uint16(22290),
		136: uint16(22291),
		137: uint16(22622),
		138: uint16(22609),
		139: uint16(22616),
		140: uint16(22615),
		141: uint16(22618),
		142: uint16(22612),
		143: uint16(22635),
		144: uint16(22604),
		145: uint16(22637),
		146: uint16(22602),
		147: uint16(22626),
		148: uint16(22610),
		149: uint16(22603),
		150: uint16(22887),
		151: uint16(23233),
		152: uint16(23241),
		153: uint16(23244),
		154: uint16(23230),
		155: uint16(23229),
		156: uint16(23228),
	},
	22: {
		0:   uint16(23219),
		1:   uint16(23234),
		2:   uint16(23218),
		3:   uint16(23913),
		4:   uint16(23919),
		5:   uint16(24140),
		6:   uint16(24185),
		7:   uint16(24265),
		8:   uint16(24264),
		9:   uint16(24338),
		10:  uint16(24409),
		11:  uint16(24492),
		12:  uint16(24494),
		13:  uint16(24858),
		14:  uint16(24847),
		15:  uint16(24904),
		16:  uint16(24863),
		17:  uint16(24819),
		18:  uint16(24859),
		19:  uint16(24825),
		20:  uint16(24833),
		21:  uint16(24840),
		22:  uint16(24910),
		23:  uint16(24908),
		24:  uint16(24900),
		25:  uint16(24909),
		26:  uint16(24894),
		27:  uint16(24884),
		28:  uint16(24871),
		29:  uint16(24845),
		30:  uint16(24838),
		31:  uint16(24887),
		32:  uint16(25121),
		33:  uint16(25122),
		34:  uint16(25619),
		35:  uint16(25662),
		36:  uint16(25630),
		37:  uint16(25642),
		38:  uint16(25645),
		39:  uint16(25661),
		40:  uint16(25644),
		41:  uint16(25615),
		42:  uint16(25628),
		43:  uint16(25620),
		44:  uint16(25613),
		45:  uint16(25654),
		46:  uint16(25622),
		47:  uint16(25623),
		48:  uint16(25606),
		49:  uint16(25964),
		50:  uint16(26015),
		51:  uint16(26032),
		52:  uint16(26263),
		53:  uint16(26249),
		54:  uint16(26247),
		55:  uint16(26248),
		56:  uint16(26262),
		57:  uint16(26244),
		58:  uint16(26264),
		59:  uint16(26253),
		60:  uint16(26371),
		61:  uint16(27028),
		62:  uint16(26989),
		63:  uint16(26970),
		64:  uint16(26999),
		65:  uint16(26976),
		66:  uint16(26964),
		67:  uint16(26997),
		68:  uint16(26928),
		69:  uint16(27010),
		70:  uint16(26954),
		71:  uint16(26984),
		72:  uint16(26987),
		73:  uint16(26974),
		74:  uint16(26963),
		75:  uint16(27001),
		76:  uint16(27014),
		77:  uint16(26973),
		78:  uint16(26979),
		79:  uint16(26971),
		80:  uint16(27463),
		81:  uint16(27506),
		82:  uint16(27584),
		83:  uint16(27583),
		84:  uint16(27603),
		85:  uint16(27645),
		86:  uint16(28322),
		87:  uint16(28335),
		88:  uint16(28371),
		89:  uint16(28342),
		90:  uint16(28354),
		91:  uint16(28304),
		92:  uint16(28317),
		93:  uint16(28359),
		94:  uint16(28357),
		95:  uint16(28325),
		96:  uint16(28312),
		97:  uint16(28348),
		98:  uint16(28346),
		99:  uint16(28331),
		100: uint16(28369),
		101: uint16(28310),
		102: uint16(28316),
		103: uint16(28356),
		104: uint16(28372),
		105: uint16(28330),
		106: uint16(28327),
		107: uint16(28340),
		108: uint16(29006),
		109: uint16(29017),
		110: uint16(29033),
		111: uint16(29028),
		112: uint16(29001),
		113: uint16(29031),
		114: uint16(29020),
		115: uint16(29036),
		116: uint16(29030),
		117: uint16(29004),
		118: uint16(29029),
		119: uint16(29022),
		120: uint16(28998),
		121: uint16(29032),
		122: uint16(29014),
		123: uint16(29242),
		124: uint16(29266),
		125: uint16(29495),
		126: uint16(29509),
		127: uint16(29503),
		128: uint16(29502),
		129: uint16(29807),
		130: uint16(29786),
		131: uint16(29781),
		132: uint16(29791),
		133: uint16(29790),
		134: uint16(29761),
		135: uint16(29759),
		136: uint16(29785),
		137: uint16(29787),
		138: uint16(29788),
		139: uint16(30070),
		140: uint16(30072),
		141: uint16(30208),
		142: uint16(30192),
		143: uint16(30209),
		144: uint16(30194),
		145: uint16(30193),
		146: uint16(30202),
		147: uint16(30207),
		148: uint16(30196),
		149: uint16(30195),
		150: uint16(30430),
		151: uint16(30431),
		152: uint16(30555),
		153: uint16(30571),
		154: uint16(30566),
		155: uint16(30558),
		156: uint16(30563),
	},
	23: {
		0:   uint16(30585),
		1:   uint16(30570),
		2:   uint16(30572),
		3:   uint16(30556),
		4:   uint16(30565),
		5:   uint16(30568),
		6:   uint16(30562),
		7:   uint16(30702),
		8:   uint16(30862),
		9:   uint16(30896),
		10:  uint16(30871),
		11:  uint16(30872),
		12:  uint16(30860),
		13:  uint16(30857),
		14:  uint16(30844),
		15:  uint16(30865),
		16:  uint16(30867),
		17:  uint16(30847),
		18:  uint16(31098),
		19:  uint16(31103),
		20:  uint16(31105),
		21:  uint16(33836),
		22:  uint16(31165),
		23:  uint16(31260),
		24:  uint16(31258),
		25:  uint16(31264),
		26:  uint16(31252),
		27:  uint16(31263),
		28:  uint16(31262),
		29:  uint16(31391),
		30:  uint16(31392),
		31:  uint16(31607),
		32:  uint16(31680),
		33:  uint16(31584),
		34:  uint16(31598),
		35:  uint16(31591),
		36:  uint16(31921),
		37:  uint16(31923),
		38:  uint16(31925),
		39:  uint16(32147),
		40:  uint16(32121),
		41:  uint16(32145),
		42:  uint16(32129),
		43:  uint16(32143),
		44:  uint16(32091),
		45:  uint16(32622),
		46:  uint16(32617),
		47:  uint16(32618),
		48:  uint16(32626),
		49:  uint16(32681),
		50:  uint16(32680),
		51:  uint16(32676),
		52:  uint16(32854),
		53:  uint16(32856),
		54:  uint16(32902),
		55:  uint16(32900),
		56:  uint16(33137),
		57:  uint16(33136),
		58:  uint16(33144),
		59:  uint16(33125),
		60:  uint16(33134),
		61:  uint16(33139),
		62:  uint16(33131),
		63:  uint16(33145),
		64:  uint16(33146),
		65:  uint16(33126),
		66:  uint16(33285),
		67:  uint16(33351),
		68:  uint16(33922),
		69:  uint16(33911),
		70:  uint16(33853),
		71:  uint16(33841),
		72:  uint16(33909),
		73:  uint16(33894),
		74:  uint16(33899),
		75:  uint16(33865),
		76:  uint16(33900),
		77:  uint16(33883),
		78:  uint16(33852),
		79:  uint16(33845),
		80:  uint16(33889),
		81:  uint16(33891),
		82:  uint16(33897),
		83:  uint16(33901),
		84:  uint16(33862),
		85:  uint16(34398),
		86:  uint16(34396),
		87:  uint16(34399),
		88:  uint16(34553),
		89:  uint16(34579),
		90:  uint16(34568),
		91:  uint16(34567),
		92:  uint16(34560),
		93:  uint16(34558),
		94:  uint16(34555),
		95:  uint16(34562),
		96:  uint16(34563),
		97:  uint16(34566),
		98:  uint16(34570),
		99:  uint16(34905),
		100: uint16(35039),
		101: uint16(35028),
		102: uint16(35033),
		103: uint16(35036),
		104: uint16(35032),
		105: uint16(35037),
		106: uint16(35041),
		107: uint16(35018),
		108: uint16(35029),
		109: uint16(35026),
		110: uint16(35228),
		111: uint16(35299),
		112: uint16(35435),
		113: uint16(35442),
		114: uint16(35443),
		115: uint16(35430),
		116: uint16(35433),
		117: uint16(35440),
		118: uint16(35463),
		119: uint16(35452),
		120: uint16(35427),
		121: uint16(35488),
		122: uint16(35441),
		123: uint16(35461),
		124: uint16(35437),
		125: uint16(35426),
		126: uint16(35438),
		127: uint16(35436),
		128: uint16(35449),
		129: uint16(35451),
		130: uint16(35390),
		131: uint16(35432),
		132: uint16(35938),
		133: uint16(35978),
		134: uint16(35977),
		135: uint16(36042),
		136: uint16(36039),
		137: uint16(36040),
		138: uint16(36036),
		139: uint16(36018),
		140: uint16(36035),
		141: uint16(36034),
		142: uint16(36037),
		143: uint16(36321),
		144: uint16(36319),
		145: uint16(36328),
		146: uint16(36335),
		147: uint16(36339),
		148: uint16(36346),
		149: uint16(36330),
		150: uint16(36324),
		151: uint16(36326),
		152: uint16(36530),
		153: uint16(36611),
		154: uint16(36617),
		155: uint16(36606),
		156: uint16(36618),
	},
	24: {
		0:   uint16(36767),
		1:   uint16(36786),
		2:   uint16(36939),
		3:   uint16(36938),
		4:   uint16(36947),
		5:   uint16(36930),
		6:   uint16(36948),
		7:   uint16(36924),
		8:   uint16(36949),
		9:   uint16(36944),
		10:  uint16(36935),
		11:  uint16(36943),
		12:  uint16(36942),
		13:  uint16(36941),
		14:  uint16(36945),
		15:  uint16(36926),
		16:  uint16(36929),
		17:  uint16(37138),
		18:  uint16(37143),
		19:  uint16(37228),
		20:  uint16(37226),
		21:  uint16(37225),
		22:  uint16(37321),
		23:  uint16(37431),
		24:  uint16(37463),
		25:  uint16(37432),
		26:  uint16(37437),
		27:  uint16(37440),
		28:  uint16(37438),
		29:  uint16(37467),
		30:  uint16(37451),
		31:  uint16(37476),
		32:  uint16(37457),
		33:  uint16(37428),
		34:  uint16(37449),
		35:  uint16(37453),
		36:  uint16(37445),
		37:  uint16(37433),
		38:  uint16(37439),
		39:  uint16(37466),
		40:  uint16(38296),
		41:  uint16(38552),
		42:  uint16(38548),
		43:  uint16(38549),
		44:  uint16(38605),
		45:  uint16(38603),
		46:  uint16(38601),
		47:  uint16(38602),
		48:  uint16(38647),
		49:  uint16(38651),
		50:  uint16(38649),
		51:  uint16(38646),
		52:  uint16(38742),
		53:  uint16(38772),
		54:  uint16(38774),
		55:  uint16(38928),
		56:  uint16(38929),
		57:  uint16(38931),
		58:  uint16(38922),
		59:  uint16(38930),
		60:  uint16(38924),
		61:  uint16(39164),
		62:  uint16(39156),
		63:  uint16(39165),
		64:  uint16(39166),
		65:  uint16(39347),
		66:  uint16(39345),
		67:  uint16(39348),
		68:  uint16(39649),
		69:  uint16(40169),
		70:  uint16(40578),
		71:  uint16(40718),
		72:  uint16(40723),
		73:  uint16(40736),
		74:  uint16(20711),
		75:  uint16(20718),
		76:  uint16(20709),
		77:  uint16(20694),
		78:  uint16(20717),
		79:  uint16(20698),
		80:  uint16(20693),
		81:  uint16(20687),
		82:  uint16(20689),
		83:  uint16(20721),
		84:  uint16(20686),
		85:  uint16(20713),
		86:  uint16(20834),
		87:  uint16(20979),
		88:  uint16(21123),
		89:  uint16(21122),
		90:  uint16(21297),
		91:  uint16(21421),
		92:  uint16(22014),
		93:  uint16(22016),
		94:  uint16(22043),
		95:  uint16(22039),
		96:  uint16(22013),
		97:  uint16(22036),
		98:  uint16(22022),
		99:  uint16(22025),
		100: uint16(22029),
		101: uint16(22030),
		102: uint16(22007),
		103: uint16(22038),
		104: uint16(22047),
		105: uint16(22024),
		106: uint16(22032),
		107: uint16(22006),
		108: uint16(22296),
		109: uint16(22294),
		110: uint16(22645),
		111: uint16(22654),
		112: uint16(22659),
		113: uint16(22675),
		114: uint16(22666),
		115: uint16(22649),
		116: uint16(22661),
		117: uint16(22653),
		118: uint16(22781),
		119: uint16(22821),
		120: uint16(22818),
		121: uint16(22820),
		122: uint16(22890),
		123: uint16(22889),
		124: uint16(23265),
		125: uint16(23270),
		126: uint16(23273),
		127: uint16(23255),
		128: uint16(23254),
		129: uint16(23256),
		130: uint16(23267),
		131: uint16(23413),
		132: uint16(23518),
		133: uint16(23527),
		134: uint16(23521),
		135: uint16(23525),
		136: uint16(23526),
		137: uint16(23528),
		138: uint16(23522),
		139: uint16(23524),
		140: uint16(23519),
		141: uint16(23565),
		142: uint16(23650),
		143: uint16(23940),
		144: uint16(23943),
		145: uint16(24155),
		146: uint16(24163),
		147: uint16(24149),
		148: uint16(24151),
		149: uint16(24148),
		150: uint16(24275),
		151: uint16(24278),
		152: uint16(24330),
		153: uint16(24390),
		154: uint16(24432),
		155: uint16(24505),
		156: uint16(24903),
	},
	25: {
		0:   uint16(24895),
		1:   uint16(24907),
		2:   uint16(24951),
		3:   uint16(24930),
		4:   uint16(24931),
		5:   uint16(24927),
		6:   uint16(24922),
		7:   uint16(24920),
		8:   uint16(24949),
		9:   uint16(25130),
		10:  uint16(25735),
		11:  uint16(25688),
		12:  uint16(25684),
		13:  uint16(25764),
		14:  uint16(25720),
		15:  uint16(25695),
		16:  uint16(25722),
		17:  uint16(25681),
		18:  uint16(25703),
		19:  uint16(25652),
		20:  uint16(25709),
		21:  uint16(25723),
		22:  uint16(25970),
		23:  uint16(26017),
		24:  uint16(26071),
		25:  uint16(26070),
		26:  uint16(26274),
		27:  uint16(26280),
		28:  uint16(26269),
		29:  uint16(27036),
		30:  uint16(27048),
		31:  uint16(27029),
		32:  uint16(27073),
		33:  uint16(27054),
		34:  uint16(27091),
		35:  uint16(27083),
		36:  uint16(27035),
		37:  uint16(27063),
		38:  uint16(27067),
		39:  uint16(27051),
		40:  uint16(27060),
		41:  uint16(27088),
		42:  uint16(27085),
		43:  uint16(27053),
		44:  uint16(27084),
		45:  uint16(27046),
		46:  uint16(27075),
		47:  uint16(27043),
		48:  uint16(27465),
		49:  uint16(27468),
		50:  uint16(27699),
		51:  uint16(28467),
		52:  uint16(28436),
		53:  uint16(28414),
		54:  uint16(28435),
		55:  uint16(28404),
		56:  uint16(28457),
		57:  uint16(28478),
		58:  uint16(28448),
		59:  uint16(28460),
		60:  uint16(28431),
		61:  uint16(28418),
		62:  uint16(28450),
		63:  uint16(28415),
		64:  uint16(28399),
		65:  uint16(28422),
		66:  uint16(28465),
		67:  uint16(28472),
		68:  uint16(28466),
		69:  uint16(28451),
		70:  uint16(28437),
		71:  uint16(28459),
		72:  uint16(28463),
		73:  uint16(28552),
		74:  uint16(28458),
		75:  uint16(28396),
		76:  uint16(28417),
		77:  uint16(28402),
		78:  uint16(28364),
		79:  uint16(28407),
		80:  uint16(29076),
		81:  uint16(29081),
		82:  uint16(29053),
		83:  uint16(29066),
		84:  uint16(29060),
		85:  uint16(29074),
		86:  uint16(29246),
		87:  uint16(29330),
		88:  uint16(29334),
		89:  uint16(29508),
		90:  uint16(29520),
		91:  uint16(29796),
		92:  uint16(29795),
		93:  uint16(29802),
		94:  uint16(29808),
		95:  uint16(29805),
		96:  uint16(29956),
		97:  uint16(30097),
		98:  uint16(30247),
		99:  uint16(30221),
		100: uint16(30219),
		101: uint16(30217),
		102: uint16(30227),
		103: uint16(30433),
		104: uint16(30435),
		105: uint16(30596),
		106: uint16(30589),
		107: uint16(30591),
		108: uint16(30561),
		109: uint16(30913),
		110: uint16(30879),
		111: uint16(30887),
		112: uint16(30899),
		113: uint16(30889),
		114: uint16(30883),
		115: uint16(31118),
		116: uint16(31119),
		117: uint16(31117),
		118: uint16(31278),
		119: uint16(31281),
		120: uint16(31402),
		121: uint16(31401),
		122: uint16(31469),
		123: uint16(31471),
		124: uint16(31649),
		125: uint16(31637),
		126: uint16(31627),
		127: uint16(31605),
		128: uint16(31639),
		129: uint16(31645),
		130: uint16(31636),
		131: uint16(31631),
		132: uint16(31672),
		133: uint16(31623),
		134: uint16(31620),
		135: uint16(31929),
		136: uint16(31933),
		137: uint16(31934),
		138: uint16(32187),
		139: uint16(32176),
		140: uint16(32156),
		141: uint16(32189),
		142: uint16(32190),
		143: uint16(32160),
		144: uint16(32202),
		145: uint16(32180),
		146: uint16(32178),
		147: uint16(32177),
		148: uint16(32186),
		149: uint16(32162),
		150: uint16(32191),
		151: uint16(32181),
		152: uint16(32184),
		153: uint16(32173),
		154: uint16(32210),
		155: uint16(32199),
		156: uint16(32172),
	},
	26: {
		0:   uint16(32624),
		1:   uint16(32736),
		2:   uint16(32737),
		3:   uint16(32735),
		4:   uint16(32862),
		5:   uint16(32858),
		6:   uint16(32903),
		7:   uint16(33104),
		8:   uint16(33152),
		9:   uint16(33167),
		10:  uint16(33160),
		11:  uint16(33162),
		12:  uint16(33151),
		13:  uint16(33154),
		14:  uint16(33255),
		15:  uint16(33274),
		16:  uint16(33287),
		17:  uint16(33300),
		18:  uint16(33310),
		19:  uint16(33355),
		20:  uint16(33993),
		21:  uint16(33983),
		22:  uint16(33990),
		23:  uint16(33988),
		24:  uint16(33945),
		25:  uint16(33950),
		26:  uint16(33970),
		27:  uint16(33948),
		28:  uint16(33995),
		29:  uint16(33976),
		30:  uint16(33984),
		31:  uint16(34003),
		32:  uint16(33936),
		33:  uint16(33980),
		34:  uint16(34001),
		35:  uint16(33994),
		36:  uint16(34623),
		37:  uint16(34588),
		38:  uint16(34619),
		39:  uint16(34594),
		40:  uint16(34597),
		41:  uint16(34612),
		42:  uint16(34584),
		43:  uint16(34645),
		44:  uint16(34615),
		45:  uint16(34601),
		46:  uint16(35059),
		47:  uint16(35074),
		48:  uint16(35060),
		49:  uint16(35065),
		50:  uint16(35064),
		51:  uint16(35069),
		52:  uint16(35048),
		53:  uint16(35098),
		54:  uint16(35055),
		55:  uint16(35494),
		56:  uint16(35468),
		57:  uint16(35486),
		58:  uint16(35491),
		59:  uint16(35469),
		60:  uint16(35489),
		61:  uint16(35475),
		62:  uint16(35492),
		63:  uint16(35498),
		64:  uint16(35493),
		65:  uint16(35496),
		66:  uint16(35480),
		67:  uint16(35473),
		68:  uint16(35482),
		69:  uint16(35495),
		70:  uint16(35946),
		71:  uint16(35981),
		72:  uint16(35980),
		73:  uint16(36051),
		74:  uint16(36049),
		75:  uint16(36050),
		76:  uint16(36203),
		77:  uint16(36249),
		78:  uint16(36245),
		79:  uint16(36348),
		80:  uint16(36628),
		81:  uint16(36626),
		82:  uint16(36629),
		83:  uint16(36627),
		84:  uint16(36771),
		85:  uint16(36960),
		86:  uint16(36952),
		87:  uint16(36956),
		88:  uint16(36963),
		89:  uint16(36953),
		90:  uint16(36958),
		91:  uint16(36962),
		92:  uint16(36957),
		93:  uint16(36955),
		94:  uint16(37145),
		95:  uint16(37144),
		96:  uint16(37150),
		97:  uint16(37237),
		98:  uint16(37240),
		99:  uint16(37239),
		100: uint16(37236),
		101: uint16(37496),
		102: uint16(37504),
		103: uint16(37509),
		104: uint16(37528),
		105: uint16(37526),
		106: uint16(37499),
		107: uint16(37523),
		108: uint16(37532),
		109: uint16(37544),
		110: uint16(37500),
		111: uint16(37521),
		112: uint16(38305),
		113: uint16(38312),
		114: uint16(38313),
		115: uint16(38307),
		116: uint16(38309),
		117: uint16(38308),
		118: uint16(38553),
		119: uint16(38556),
		120: uint16(38555),
		121: uint16(38604),
		122: uint16(38610),
		123: uint16(38656),
		124: uint16(38780),
		125: uint16(38789),
		126: uint16(38902),
		127: uint16(38935),
		128: uint16(38936),
		129: uint16(39087),
		130: uint16(39089),
		131: uint16(39171),
		132: uint16(39173),
		133: uint16(39180),
		134: uint16(39177),
		135: uint16(39361),
		136: uint16(39599),
		137: uint16(39600),
		138: uint16(39654),
		139: uint16(39745),
		140: uint16(39746),
		141: uint16(40180),
		142: uint16(40182),
		143: uint16(40179),
		144: uint16(40636),
		145: uint16(40763),
		146: uint16(40778),
		147: uint16(20740),
		148: uint16(20736),
		149: uint16(20731),
		150: uint16(20725),
		151: uint16(20729),
		152: uint16(20738),
		153: uint16(20744),
		154: uint16(20745),
		155: uint16(20741),
		156: uint16(20956),
	},
	27: {
		0:   uint16(21127),
		1:   uint16(21128),
		2:   uint16(21129),
		3:   uint16(21133),
		4:   uint16(21130),
		5:   uint16(21232),
		6:   uint16(21426),
		7:   uint16(22062),
		8:   uint16(22075),
		9:   uint16(22073),
		10:  uint16(22066),
		11:  uint16(22079),
		12:  uint16(22068),
		13:  uint16(22057),
		14:  uint16(22099),
		15:  uint16(22094),
		16:  uint16(22103),
		17:  uint16(22132),
		18:  uint16(22070),
		19:  uint16(22063),
		20:  uint16(22064),
		21:  uint16(22656),
		22:  uint16(22687),
		23:  uint16(22686),
		24:  uint16(22707),
		25:  uint16(22684),
		26:  uint16(22702),
		27:  uint16(22697),
		28:  uint16(22694),
		29:  uint16(22893),
		30:  uint16(23305),
		31:  uint16(23291),
		32:  uint16(23307),
		33:  uint16(23285),
		34:  uint16(23308),
		35:  uint16(23304),
		36:  uint16(23534),
		37:  uint16(23532),
		38:  uint16(23529),
		39:  uint16(23531),
		40:  uint16(23652),
		41:  uint16(23653),
		42:  uint16(23965),
		43:  uint16(23956),
		44:  uint16(24162),
		45:  uint16(24159),
		46:  uint16(24161),
		47:  uint16(24290),
		48:  uint16(24282),
		49:  uint16(24287),
		50:  uint16(24285),
		51:  uint16(24291),
		52:  uint16(24288),
		53:  uint16(24392),
		54:  uint16(24433),
		55:  uint16(24503),
		56:  uint16(24501),
		57:  uint16(24950),
		58:  uint16(24935),
		59:  uint16(24942),
		60:  uint16(24925),
		61:  uint16(24917),
		62:  uint16(24962),
		63:  uint16(24956),
		64:  uint16(24944),
		65:  uint16(24939),
		66:  uint16(24958),
		67:  uint16(24999),
		68:  uint16(24976),
		69:  uint16(25003),
		70:  uint16(24974),
		71:  uint16(25004),
		72:  uint16(24986),
		73:  uint16(24996),
		74:  uint16(24980),
		75:  uint16(25006),
		76:  uint16(25134),
		77:  uint16(25705),
		78:  uint16(25711),
		79:  uint16(25721),
		80:  uint16(25758),
		81:  uint16(25778),
		82:  uint16(25736),
		83:  uint16(25744),
		84:  uint16(25776),
		85:  uint16(25765),
		86:  uint16(25747),
		87:  uint16(25749),
		88:  uint16(25769),
		89:  uint16(25746),
		90:  uint16(25774),
		91:  uint16(25773),
		92:  uint16(25771),
		93:  uint16(25754),
		94:  uint16(25772),
		95:  uint16(25753),
		96:  uint16(25762),
		97:  uint16(25779),
		98:  uint16(25973),
		99:  uint16(25975),
		100: uint16(25976),
		101: uint16(26286),
		102: uint16(26283),
		103: uint16(26292),
		104: uint16(26289),
		105: uint16(27171),
		106: uint16(27167),
		107: uint16(27112),
		108: uint16(27137),
		109: uint16(27166),
		110: uint16(27161),
		111: uint16(27133),
		112: uint16(27169),
		113: uint16(27155),
		114: uint16(27146),
		115: uint16(27123),
		116: uint16(27138),
		117: uint16(27141),
		118: uint16(27117),
		119: uint16(27153),
		120: uint16(27472),
		121: uint16(27470),
		122: uint16(27556),
		123: uint16(27589),
		124: uint16(27590),
		125: uint16(28479),
		126: uint16(28540),
		127: uint16(28548),
		128: uint16(28497),
		129: uint16(28518),
		130: uint16(28500),
		131: uint16(28550),
		132: uint16(28525),
		133: uint16(28507),
		134: uint16(28536),
		135: uint16(28526),
		136: uint16(28558),
		137: uint16(28538),
		138: uint16(28528),
		139: uint16(28516),
		140: uint16(28567),
		141: uint16(28504),
		142: uint16(28373),
		143: uint16(28527),
		144: uint16(28512),
		145: uint16(28511),
		146: uint16(29087),
		147: uint16(29100),
		148: uint16(29105),
		149: uint16(29096),
		150: uint16(29270),
		151: uint16(29339),
		152: uint16(29518),
		153: uint16(29527),
		154: uint16(29801),
		155: uint16(29835),
		156: uint16(29827),
	},
	28: {
		0:   uint16(29822),
		1:   uint16(29824),
		2:   uint16(30079),
		3:   uint16(30240),
		4:   uint16(30249),
		5:   uint16(30239),
		6:   uint16(30244),
		7:   uint16(30246),
		8:   uint16(30241),
		9:   uint16(30242),
		10:  uint16(30362),
		11:  uint16(30394),
		12:  uint16(30436),
		13:  uint16(30606),
		14:  uint16(30599),
		15:  uint16(30604),
		16:  uint16(30609),
		17:  uint16(30603),
		18:  uint16(30923),
		19:  uint16(30917),
		20:  uint16(30906),
		21:  uint16(30922),
		22:  uint16(30910),
		23:  uint16(30933),
		24:  uint16(30908),
		25:  uint16(30928),
		26:  uint16(31295),
		27:  uint16(31292),
		28:  uint16(31296),
		29:  uint16(31293),
		30:  uint16(31287),
		31:  uint16(31291),
		32:  uint16(31407),
		33:  uint16(31406),
		34:  uint16(31661),
		35:  uint16(31665),
		36:  uint16(31684),
		37:  uint16(31668),
		38:  uint16(31686),
		39:  uint16(31687),
		40:  uint16(31681),
		41:  uint16(31648),
		42:  uint16(31692),
		43:  uint16(31946),
		44:  uint16(32224),
		45:  uint16(32244),
		46:  uint16(32239),
		47:  uint16(32251),
		48:  uint16(32216),
		49:  uint16(32236),
		50:  uint16(32221),
		51:  uint16(32232),
		52:  uint16(32227),
		53:  uint16(32218),
		54:  uint16(32222),
		55:  uint16(32233),
		56:  uint16(32158),
		57:  uint16(32217),
		58:  uint16(32242),
		59:  uint16(32249),
		60:  uint16(32629),
		61:  uint16(32631),
		62:  uint16(32687),
		63:  uint16(32745),
		64:  uint16(32806),
		65:  uint16(33179),
		66:  uint16(33180),
		67:  uint16(33181),
		68:  uint16(33184),
		69:  uint16(33178),
		70:  uint16(33176),
		71:  uint16(34071),
		72:  uint16(34109),
		73:  uint16(34074),
		74:  uint16(34030),
		75:  uint16(34092),
		76:  uint16(34093),
		77:  uint16(34067),
		78:  uint16(34065),
		79:  uint16(34083),
		80:  uint16(34081),
		81:  uint16(34068),
		82:  uint16(34028),
		83:  uint16(34085),
		84:  uint16(34047),
		85:  uint16(34054),
		86:  uint16(34690),
		87:  uint16(34676),
		88:  uint16(34678),
		89:  uint16(34656),
		90:  uint16(34662),
		91:  uint16(34680),
		92:  uint16(34664),
		93:  uint16(34649),
		94:  uint16(34647),
		95:  uint16(34636),
		96:  uint16(34643),
		97:  uint16(34907),
		98:  uint16(34909),
		99:  uint16(35088),
		100: uint16(35079),
		101: uint16(35090),
		102: uint16(35091),
		103: uint16(35093),
		104: uint16(35082),
		105: uint16(35516),
		106: uint16(35538),
		107: uint16(35527),
		108: uint16(35524),
		109: uint16(35477),
		110: uint16(35531),
		111: uint16(35576),
		112: uint16(35506),
		113: uint16(35529),
		114: uint16(35522),
		115: uint16(35519),
		116: uint16(35504),
		117: uint16(35542),
		118: uint16(35533),
		119: uint16(35510),
		120: uint16(35513),
		121: uint16(35547),
		122: uint16(35916),
		123: uint16(35918),
		124: uint16(35948),
		125: uint16(36064),
		126: uint16(36062),
		127: uint16(36070),
		128: uint16(36068),
		129: uint16(36076),
		130: uint16(36077),
		131: uint16(36066),
		132: uint16(36067),
		133: uint16(36060),
		134: uint16(36074),
		135: uint16(36065),
		136: uint16(36205),
		137: uint16(36255),
		138: uint16(36259),
		139: uint16(36395),
		140: uint16(36368),
		141: uint16(36381),
		142: uint16(36386),
		143: uint16(36367),
		144: uint16(36393),
		145: uint16(36383),
		146: uint16(36385),
		147: uint16(36382),
		148: uint16(36538),
		149: uint16(36637),
		150: uint16(36635),
		151: uint16(36639),
		152: uint16(36649),
		153: uint16(36646),
		154: uint16(36650),
		155: uint16(36636),
		156: uint16(36638),
	},
	29: {
		0:   uint16(36645),
		1:   uint16(36969),
		2:   uint16(36974),
		3:   uint16(36968),
		4:   uint16(36973),
		5:   uint16(36983),
		6:   uint16(37168),
		7:   uint16(37165),
		8:   uint16(37159),
		9:   uint16(37169),
		10:  uint16(37255),
		11:  uint16(37257),
		12:  uint16(37259),
		13:  uint16(37251),
		14:  uint16(37573),
		15:  uint16(37563),
		16:  uint16(37559),
		17:  uint16(37610),
		18:  uint16(37548),
		19:  uint16(37604),
		20:  uint16(37569),
		21:  uint16(37555),
		22:  uint16(37564),
		23:  uint16(37586),
		24:  uint16(37575),
		25:  uint16(37616),
		26:  uint16(37554),
		27:  uint16(38317),
		28:  uint16(38321),
		29:  uint16(38660),
		30:  uint16(38662),
		31:  uint16(38663),
		32:  uint16(38665),
		33:  uint16(38752),
		34:  uint16(38797),
		35:  uint16(38795),
		36:  uint16(38799),
		37:  uint16(38945),
		38:  uint16(38955),
		39:  uint16(38940),
		40:  uint16(39091),
		41:  uint16(39178),
		42:  uint16(39187),
		43:  uint16(39186),
		44:  uint16(39192),
		45:  uint16(39389),
		46:  uint16(39376),
		47:  uint16(39391),
		48:  uint16(39387),
		49:  uint16(39377),
		50:  uint16(39381),
		51:  uint16(39378),
		52:  uint16(39385),
		53:  uint16(39607),
		54:  uint16(39662),
		55:  uint16(39663),
		56:  uint16(39719),
		57:  uint16(39749),
		58:  uint16(39748),
		59:  uint16(39799),
		60:  uint16(39791),
		61:  uint16(40198),
		62:  uint16(40201),
		63:  uint16(40195),
		64:  uint16(40617),
		65:  uint16(40638),
		66:  uint16(40654),
		67:  uint16(22696),
		68:  uint16(40786),
		69:  uint16(20754),
		70:  uint16(20760),
		71:  uint16(20756),
		72:  uint16(20752),
		73:  uint16(20757),
		74:  uint16(20864),
		75:  uint16(20906),
		76:  uint16(20957),
		77:  uint16(21137),
		78:  uint16(21139),
		79:  uint16(21235),
		80:  uint16(22105),
		81:  uint16(22123),
		82:  uint16(22137),
		83:  uint16(22121),
		84:  uint16(22116),
		85:  uint16(22136),
		86:  uint16(22122),
		87:  uint16(22120),
		88:  uint16(22117),
		89:  uint16(22129),
		90:  uint16(22127),
		91:  uint16(22124),
		92:  uint16(22114),
		93:  uint16(22134),
		94:  uint16(22721),
		95:  uint16(22718),
		96:  uint16(22727),
		97:  uint16(22725),
		98:  uint16(22894),
		99:  uint16(23325),
		100: uint16(23348),
		101: uint16(23416),
		102: uint16(23536),
		103: uint16(23566),
		104: uint16(24394),
		105: uint16(25010),
		106: uint16(24977),
		107: uint16(25001),
		108: uint16(24970),
		109: uint16(25037),
		110: uint16(25014),
		111: uint16(25022),
		112: uint16(25034),
		113: uint16(25032),
		114: uint16(25136),
		115: uint16(25797),
		116: uint16(25793),
		117: uint16(25803),
		118: uint16(25787),
		119: uint16(25788),
		120: uint16(25818),
		121: uint16(25796),
		122: uint16(25799),
		123: uint16(25794),
		124: uint16(25805),
		125: uint16(25791),
		126: uint16(25810),
		127: uint16(25812),
		128: uint16(25790),
		129: uint16(25972),
		130: uint16(26310),
		131: uint16(26313),
		132: uint16(26297),
		133: uint16(26308),
		134: uint16(26311),
		135: uint16(26296),
		136: uint16(27197),
		137: uint16(27192),
		138: uint16(27194),
		139: uint16(27225),
		140: uint16(27243),
		141: uint16(27224),
		142: uint16(27193),
		143: uint16(27204),
		144: uint16(27234),
		145: uint16(27233),
		146: uint16(27211),
		147: uint16(27207),
		148: uint16(27189),
		149: uint16(27231),
		150: uint16(27208),
		151: uint16(27481),
		152: uint16(27511),
		153: uint16(27653),
		154: uint16(28610),
		155: uint16(28593),
		156: uint16(28577),
	},
	30: {
		0:   uint16(28611),
		1:   uint16(28580),
		2:   uint16(28609),
		3:   uint16(28583),
		4:   uint16(28595),
		5:   uint16(28608),
		6:   uint16(28601),
		7:   uint16(28598),
		8:   uint16(28582),
		9:   uint16(28576),
		10:  uint16(28596),
		11:  uint16(29118),
		12:  uint16(29129),
		13:  uint16(29136),
		14:  uint16(29138),
		15:  uint16(29128),
		16:  uint16(29141),
		17:  uint16(29113),
		18:  uint16(29134),
		19:  uint16(29145),
		20:  uint16(29148),
		21:  uint16(29123),
		22:  uint16(29124),
		23:  uint16(29544),
		24:  uint16(29852),
		25:  uint16(29859),
		26:  uint16(29848),
		27:  uint16(29855),
		28:  uint16(29854),
		29:  uint16(29922),
		30:  uint16(29964),
		31:  uint16(29965),
		32:  uint16(30260),
		33:  uint16(30264),
		34:  uint16(30266),
		35:  uint16(30439),
		36:  uint16(30437),
		37:  uint16(30624),
		38:  uint16(30622),
		39:  uint16(30623),
		40:  uint16(30629),
		41:  uint16(30952),
		42:  uint16(30938),
		43:  uint16(30956),
		44:  uint16(30951),
		45:  uint16(31142),
		46:  uint16(31309),
		47:  uint16(31310),
		48:  uint16(31302),
		49:  uint16(31308),
		50:  uint16(31307),
		51:  uint16(31418),
		52:  uint16(31705),
		53:  uint16(31761),
		54:  uint16(31689),
		55:  uint16(31716),
		56:  uint16(31707),
		57:  uint16(31713),
		58:  uint16(31721),
		59:  uint16(31718),
		60:  uint16(31957),
		61:  uint16(31958),
		62:  uint16(32266),
		63:  uint16(32273),
		64:  uint16(32264),
		65:  uint16(32283),
		66:  uint16(32291),
		67:  uint16(32286),
		68:  uint16(32285),
		69:  uint16(32265),
		70:  uint16(32272),
		71:  uint16(32633),
		72:  uint16(32690),
		73:  uint16(32752),
		74:  uint16(32753),
		75:  uint16(32750),
		76:  uint16(32808),
		77:  uint16(33203),
		78:  uint16(33193),
		79:  uint16(33192),
		80:  uint16(33275),
		81:  uint16(33288),
		82:  uint16(33368),
		83:  uint16(33369),
		84:  uint16(34122),
		85:  uint16(34137),
		86:  uint16(34120),
		87:  uint16(34152),
		88:  uint16(34153),
		89:  uint16(34115),
		90:  uint16(34121),
		91:  uint16(34157),
		92:  uint16(34154),
		93:  uint16(34142),
		94:  uint16(34691),
		95:  uint16(34719),
		96:  uint16(34718),
		97:  uint16(34722),
		98:  uint16(34701),
		99:  uint16(34913),
		100: uint16(35114),
		101: uint16(35122),
		102: uint16(35109),
		103: uint16(35115),
		104: uint16(35105),
		105: uint16(35242),
		106: uint16(35238),
		107: uint16(35558),
		108: uint16(35578),
		109: uint16(35563),
		110: uint16(35569),
		111: uint16(35584),
		112: uint16(35548),
		113: uint16(35559),
		114: uint16(35566),
		115: uint16(35582),
		116: uint16(35585),
		117: uint16(35586),
		118: uint16(35575),
		119: uint16(35565),
		120: uint16(35571),
		121: uint16(35574),
		122: uint16(35580),
		123: uint16(35947),
		124: uint16(35949),
		125: uint16(35987),
		126: uint16(36084),
		127: uint16(36420),
		128: uint16(36401),
		129: uint16(36404),
		130: uint16(36418),
		131: uint16(36409),
		132: uint16(36405),
		133: uint16(36667),
		134: uint16(36655),
		135: uint16(36664),
		136: uint16(36659),
		137: uint16(36776),
		138: uint16(36774),
		139: uint16(36981),
		140: uint16(36980),
		141: uint16(36984),
		142: uint16(36978),
		143: uint16(36988),
		144: uint16(36986),
		145: uint16(37172),
		146: uint16(37266),
		147: uint16(37664),
		148: uint16(37686),
		149: uint16(37624),
		150: uint16(37683),
		151: uint16(37679),
		152: uint16(37666),
		153: uint16(37628),
		154: uint16(37675),
		155: uint16(37636),
		156: uint16(37658),
	},
	31: {
		0:   uint16(37648),
		1:   uint16(37670),
		2:   uint16(37665),
		3:   uint16(37653),
		4:   uint16(37678),
		5:   uint16(37657),
		6:   uint16(38331),
		7:   uint16(38567),
		8:   uint16(38568),
		9:   uint16(38570),
		10:  uint16(38613),
		11:  uint16(38670),
		12:  uint16(38673),
		13:  uint16(38678),
		14:  uint16(38669),
		15:  uint16(38675),
		16:  uint16(38671),
		17:  uint16(38747),
		18:  uint16(38748),
		19:  uint16(38758),
		20:  uint16(38808),
		21:  uint16(38960),
		22:  uint16(38968),
		23:  uint16(38971),
		24:  uint16(38967),
		25:  uint16(38957),
		26:  uint16(38969),
		27:  uint16(38948),
		28:  uint16(39184),
		29:  uint16(39208),
		30:  uint16(39198),
		31:  uint16(39195),
		32:  uint16(39201),
		33:  uint16(39194),
		34:  uint16(39405),
		35:  uint16(39394),
		36:  uint16(39409),
		37:  uint16(39608),
		38:  uint16(39612),
		39:  uint16(39675),
		40:  uint16(39661),
		41:  uint16(39720),
		42:  uint16(39825),
		43:  uint16(40213),
		44:  uint16(40227),
		45:  uint16(40230),
		46:  uint16(40232),
		47:  uint16(40210),
		48:  uint16(40219),
		49:  uint16(40664),
		50:  uint16(40660),
		51:  uint16(40845),
		52:  uint16(40860),
		53:  uint16(20778),
		54:  uint16(20767),
		55:  uint16(20769),
		56:  uint16(20786),
		57:  uint16(21237),
		58:  uint16(22158),
		59:  uint16(22144),
		60:  uint16(22160),
		61:  uint16(22149),
		62:  uint16(22151),
		63:  uint16(22159),
		64:  uint16(22741),
		65:  uint16(22739),
		66:  uint16(22737),
		67:  uint16(22734),
		68:  uint16(23344),
		69:  uint16(23338),
		70:  uint16(23332),
		71:  uint16(23418),
		72:  uint16(23607),
		73:  uint16(23656),
		74:  uint16(23996),
		75:  uint16(23994),
		76:  uint16(23997),
		77:  uint16(23992),
		78:  uint16(24171),
		79:  uint16(24396),
		80:  uint16(24509),
		81:  uint16(25033),
		82:  uint16(25026),
		83:  uint16(25031),
		84:  uint16(25062),
		85:  uint16(25035),
		86:  uint16(25138),
		87:  uint16(25140),
		88:  uint16(25806),
		89:  uint16(25802),
		90:  uint16(25816),
		91:  uint16(25824),
		92:  uint16(25840),
		93:  uint16(25830),
		94:  uint16(25836),
		95:  uint16(25841),
		96:  uint16(25826),
		97:  uint16(25837),
		98:  uint16(25986),
		99:  uint16(25987),
		100: uint16(26329),
		101: uint16(26326),
		102: uint16(27264),
		103: uint16(27284),
		104: uint16(27268),
		105: uint16(27298),
		106: uint16(27292),
		107: uint16(27355),
		108: uint16(27299),
		109: uint16(27262),
		110: uint16(27287),
		111: uint16(27280),
		112: uint16(27296),
		113: uint16(27484),
		114: uint16(27566),
		115: uint16(27610),
		116: uint16(27656),
		117: uint16(28632),
		118: uint16(28657),
		119: uint16(28639),
		120: uint16(28640),
		121: uint16(28635),
		122: uint16(28644),
		123: uint16(28651),
		124: uint16(28655),
		125: uint16(28544),
		126: uint16(28652),
		127: uint16(28641),
		128: uint16(28649),
		129: uint16(28629),
		130: uint16(28654),
		131: uint16(28656),
		132: uint16(29159),
		133: uint16(29151),
		134: uint16(29166),
		135: uint16(29158),
		136: uint16(29157),
		137: uint16(29165),
		138: uint16(29164),
		139: uint16(29172),
		140: uint16(29152),
		141: uint16(29237),
		142: uint16(29254),
		143: uint16(29552),
		144: uint16(29554),
		145: uint16(29865),
		146: uint16(29872),
		147: uint16(29862),
		148: uint16(29864),
		149: uint16(30278),
		150: uint16(30274),
		151: uint16(30284),
		152: uint16(30442),
		153: uint16(30643),
		154: uint16(30634),
		155: uint16(30640),
		156: uint16(30636),
	},
	32: {
		0:   uint16(30631),
		1:   uint16(30637),
		2:   uint16(30703),
		3:   uint16(30967),
		4:   uint16(30970),
		5:   uint16(30964),
		6:   uint16(30959),
		7:   uint16(30977),
		8:   uint16(31143),
		9:   uint16(31146),
		10:  uint16(31319),
		11:  uint16(31423),
		12:  uint16(31751),
		13:  uint16(31757),
		14:  uint16(31742),
		15:  uint16(31735),
		16:  uint16(31756),
		17:  uint16(31712),
		18:  uint16(31968),
		19:  uint16(31964),
		20:  uint16(31966),
		21:  uint16(31970),
		22:  uint16(31967),
		23:  uint16(31961),
		24:  uint16(31965),
		25:  uint16(32302),
		26:  uint16(32318),
		27:  uint16(32326),
		28:  uint16(32311),
		29:  uint16(32306),
		30:  uint16(32323),
		31:  uint16(32299),
		32:  uint16(32317),
		33:  uint16(32305),
		34:  uint16(32325),
		35:  uint16(32321),
		36:  uint16(32308),
		37:  uint16(32313),
		38:  uint16(32328),
		39:  uint16(32309),
		40:  uint16(32319),
		41:  uint16(32303),
		42:  uint16(32580),
		43:  uint16(32755),
		44:  uint16(32764),
		45:  uint16(32881),
		46:  uint16(32882),
		47:  uint16(32880),
		48:  uint16(32879),
		49:  uint16(32883),
		50:  uint16(33222),
		51:  uint16(33219),
		52:  uint16(33210),
		53:  uint16(33218),
		54:  uint16(33216),
		55:  uint16(33215),
		56:  uint16(33213),
		57:  uint16(33225),
		58:  uint16(33214),
		59:  uint16(33256),
		60:  uint16(33289),
		61:  uint16(33393),
		62:  uint16(34218),
		63:  uint16(34180),
		64:  uint16(34174),
		65:  uint16(34204),
		66:  uint16(34193),
		67:  uint16(34196),
		68:  uint16(34223),
		69:  uint16(34203),
		70:  uint16(34183),
		71:  uint16(34216),
		72:  uint16(34186),
		73:  uint16(34407),
		74:  uint16(34752),
		75:  uint16(34769),
		76:  uint16(34739),
		77:  uint16(34770),
		78:  uint16(34758),
		79:  uint16(34731),
		80:  uint16(34747),
		81:  uint16(34746),
		82:  uint16(34760),
		83:  uint16(34763),
		84:  uint16(35131),
		85:  uint16(35126),
		86:  uint16(35140),
		87:  uint16(35128),
		88:  uint16(35133),
		89:  uint16(35244),
		90:  uint16(35598),
		91:  uint16(35607),
		92:  uint16(35609),
		93:  uint16(35611),
		94:  uint16(35594),
		95:  uint16(35616),
		96:  uint16(35613),
		97:  uint16(35588),
		98:  uint16(35600),
		99:  uint16(35905),
		100: uint16(35903),
		101: uint16(35955),
		102: uint16(36090),
		103: uint16(36093),
		104: uint16(36092),
		105: uint16(36088),
		106: uint16(36091),
		107: uint16(36264),
		108: uint16(36425),
		109: uint16(36427),
		110: uint16(36424),
		111: uint16(36426),
		112: uint16(36676),
		113: uint16(36670),
		114: uint16(36674),
		115: uint16(36677),
		116: uint16(36671),
		117: uint16(36991),
		118: uint16(36989),
		119: uint16(36996),
		120: uint16(36993),
		121: uint16(36994),
		122: uint16(36992),
		123: uint16(37177),
		124: uint16(37283),
		125: uint16(37278),
		126: uint16(37276),
		127: uint16(37709),
		128: uint16(37762),
		129: uint16(37672),
		130: uint16(37749),
		131: uint16(37706),
		132: uint16(37733),
		133: uint16(37707),
		134: uint16(37656),
		135: uint16(37758),
		136: uint16(37740),
		137: uint16(37723),
		138: uint16(37744),
		139: uint16(37722),
		140: uint16(37716),
		141: uint16(38346),
		142: uint16(38347),
		143: uint16(38348),
		144: uint16(38344),
		145: uint16(38342),
		146: uint16(38577),
		147: uint16(38584),
		148: uint16(38614),
		149: uint16(38684),
		150: uint16(38686),
		151: uint16(38816),
		152: uint16(38867),
		153: uint16(38982),
		154: uint16(39094),
		155: uint16(39221),
		156: uint16(39425),
	},
	33: {
		0:   uint16(39423),
		1:   uint16(39854),
		2:   uint16(39851),
		3:   uint16(39850),
		4:   uint16(39853),
		5:   uint16(40251),
		6:   uint16(40255),
		7:   uint16(40587),
		8:   uint16(40655),
		9:   uint16(40670),
		10:  uint16(40668),
		11:  uint16(40669),
		12:  uint16(40667),
		13:  uint16(40766),
		14:  uint16(40779),
		15:  uint16(21474),
		16:  uint16(22165),
		17:  uint16(22190),
		18:  uint16(22745),
		19:  uint16(22744),
		20:  uint16(23352),
		21:  uint16(24413),
		22:  uint16(25059),
		23:  uint16(25139),
		24:  uint16(25844),
		25:  uint16(25842),
		26:  uint16(25854),
		27:  uint16(25862),
		28:  uint16(25850),
		29:  uint16(25851),
		30:  uint16(25847),
		31:  uint16(26039),
		32:  uint16(26332),
		33:  uint16(26406),
		34:  uint16(27315),
		35:  uint16(27308),
		36:  uint16(27331),
		37:  uint16(27323),
		38:  uint16(27320),
		39:  uint16(27330),
		40:  uint16(27310),
		41:  uint16(27311),
		42:  uint16(27487),
		43:  uint16(27512),
		44:  uint16(27567),
		45:  uint16(28681),
		46:  uint16(28683),
		47:  uint16(28670),
		48:  uint16(28678),
		49:  uint16(28666),
		50:  uint16(28689),
		51:  uint16(28687),
		52:  uint16(29179),
		53:  uint16(29180),
		54:  uint16(29182),
		55:  uint16(29176),
		56:  uint16(29559),
		57:  uint16(29557),
		58:  uint16(29863),
		59:  uint16(29887),
		60:  uint16(29973),
		61:  uint16(30294),
		62:  uint16(30296),
		63:  uint16(30290),
		64:  uint16(30653),
		65:  uint16(30655),
		66:  uint16(30651),
		67:  uint16(30652),
		68:  uint16(30990),
		69:  uint16(31150),
		70:  uint16(31329),
		71:  uint16(31330),
		72:  uint16(31328),
		73:  uint16(31428),
		74:  uint16(31429),
		75:  uint16(31787),
		76:  uint16(31783),
		77:  uint16(31786),
		78:  uint16(31774),
		79:  uint16(31779),
		80:  uint16(31777),
		81:  uint16(31975),
		82:  uint16(32340),
		83:  uint16(32341),
		84:  uint16(32350),
		85:  uint16(32346),
		86:  uint16(32353),
		87:  uint16(32338),
		88:  uint16(32345),
		89:  uint16(32584),
		90:  uint16(32761),
		91:  uint16(32763),
		92:  uint16(32887),
		93:  uint16(32886),
		94:  uint16(33229),
		95:  uint16(33231),
		96:  uint16(33290),
		97:  uint16(34255),
		98:  uint16(34217),
		99:  uint16(34253),
		100: uint16(34256),
		101: uint16(34249),
		102: uint16(34224),
		103: uint16(34234),
		104: uint16(34233),
		105: uint16(34214),
		106: uint16(34799),
		107: uint16(34796),
		108: uint16(34802),
		109: uint16(34784),
		110: uint16(35206),
		111: uint16(35250),
		112: uint16(35316),
		113: uint16(35624),
		114: uint16(35641),
		115: uint16(35628),
		116: uint16(35627),
		117: uint16(35920),
		118: uint16(36101),
		119: uint16(36441),
		120: uint16(36451),
		121: uint16(36454),
		122: uint16(36452),
		123: uint16(36447),
		124: uint16(36437),
		125: uint16(36544),
		126: uint16(36681),
		127: uint16(36685),
		128: uint16(36999),
		129: uint16(36995),
		130: uint16(37000),
		131: uint16(37291),
		132: uint16(37292),
		133: uint16(37328),
		134: uint16(37780),
		135: uint16(37770),
		136: uint16(37782),
		137: uint16(37794),
		138: uint16(37811),
		139: uint16(37806),
		140: uint16(37804),
		141: uint16(37808),
		142: uint16(37784),
		143: uint16(37786),
		144: uint16(37783),
		145: uint16(38356),
		146: uint16(38358),
		147: uint16(38352),
		148: uint16(38357),
		149: uint16(38626),
		150: uint16(38620),
		151: uint16(38617),
		152: uint16(38619),
		153: uint16(38622),
		154: uint16(38692),
		155: uint16(38819),
		156: uint16(38822),
	},
	34: {
		0:   uint16(38829),
		1:   uint16(38905),
		2:   uint16(38989),
		3:   uint16(38991),
		4:   uint16(38988),
		5:   uint16(38990),
		6:   uint16(38995),
		7:   uint16(39098),
		8:   uint16(39230),
		9:   uint16(39231),
		10:  uint16(39229),
		11:  uint16(39214),
		12:  uint16(39333),
		13:  uint16(39438),
		14:  uint16(39617),
		15:  uint16(39683),
		16:  uint16(39686),
		17:  uint16(39759),
		18:  uint16(39758),
		19:  uint16(39757),
		20:  uint16(39882),
		21:  uint16(39881),
		22:  uint16(39933),
		23:  uint16(39880),
		24:  uint16(39872),
		25:  uint16(40273),
		26:  uint16(40285),
		27:  uint16(40288),
		28:  uint16(40672),
		29:  uint16(40725),
		30:  uint16(40748),
		31:  uint16(20787),
		32:  uint16(22181),
		33:  uint16(22750),
		34:  uint16(22751),
		35:  uint16(22754),
		36:  uint16(23541),
		37:  uint16(40848),
		38:  uint16(24300),
		39:  uint16(25074),
		40:  uint16(25079),
		41:  uint16(25078),
		42:  uint16(25077),
		43:  uint16(25856),
		44:  uint16(25871),
		45:  uint16(26336),
		46:  uint16(26333),
		47:  uint16(27365),
		48:  uint16(27357),
		49:  uint16(27354),
		50:  uint16(27347),
		51:  uint16(28699),
		52:  uint16(28703),
		53:  uint16(28712),
		54:  uint16(28698),
		55:  uint16(28701),
		56:  uint16(28693),
		57:  uint16(28696),
		58:  uint16(29190),
		59:  uint16(29197),
		60:  uint16(29272),
		61:  uint16(29346),
		62:  uint16(29560),
		63:  uint16(29562),
		64:  uint16(29885),
		65:  uint16(29898),
		66:  uint16(29923),
		67:  uint16(30087),
		68:  uint16(30086),
		69:  uint16(30303),
		70:  uint16(30305),
		71:  uint16(30663),
		72:  uint16(31001),
		73:  uint16(31153),
		74:  uint16(31339),
		75:  uint16(31337),
		76:  uint16(31806),
		77:  uint16(31807),
		78:  uint16(31800),
		79:  uint16(31805),
		80:  uint16(31799),
		81:  uint16(31808),
		82:  uint16(32363),
		83:  uint16(32365),
		84:  uint16(32377),
		85:  uint16(32361),
		86:  uint16(32362),
		87:  uint16(32645),
		88:  uint16(32371),
		89:  uint16(32694),
		90:  uint16(32697),
		91:  uint16(32696),
		92:  uint16(33240),
		93:  uint16(34281),
		94:  uint16(34269),
		95:  uint16(34282),
		96:  uint16(34261),
		97:  uint16(34276),
		98:  uint16(34277),
		99:  uint16(34295),
		100: uint16(34811),
		101: uint16(34821),
		102: uint16(34829),
		103: uint16(34809),
		104: uint16(34814),
		105: uint16(35168),
		106: uint16(35167),
		107: uint16(35158),
		108: uint16(35166),
		109: uint16(35649),
		110: uint16(35676),
		111: uint16(35672),
		112: uint16(35657),
		113: uint16(35674),
		114: uint16(35662),
		115: uint16(35663),
		116: uint16(35654),
		117: uint16(35673),
		118: uint16(36104),
		119: uint16(36106),
		120: uint16(36476),
		121: uint16(36466),
		122: uint16(36487),
		123: uint16(36470),
		124: uint16(36460),
		125: uint16(36474),
		126: uint16(36468),
		127: uint16(36692),
		128: uint16(36686),
		129: uint16(36781),
		130: uint16(37002),
		131: uint16(37003),
		132: uint16(37297),
		133: uint16(37294),
		134: uint16(37857),
		135: uint16(37841),
		136: uint16(37855),
		137: uint16(37827),
		138: uint16(37832),
		139: uint16(37852),
		140: uint16(37853),
		141: uint16(37846),
		142: uint16(37858),
		143: uint16(37837),
		144: uint16(37848),
		145: uint16(37860),
		146: uint16(37847),
		147: uint16(37864),
		148: uint16(38364),
		149: uint16(38580),
		150: uint16(38627),
		151: uint16(38698),
		152: uint16(38695),
		153: uint16(38753),
		154: uint16(38876),
		155: uint16(38907),
		156: uint16(39006),
	},
	35: {
		0:   uint16(39000),
		1:   uint16(39003),
		2:   uint16(39100),
		3:   uint16(39237),
		4:   uint16(39241),
		5:   uint16(39446),
		6:   uint16(39449),
		7:   uint16(39693),
		8:   uint16(39912),
		9:   uint16(39911),
		10:  uint16(39894),
		11:  uint16(39899),
		12:  uint16(40329),
		13:  uint16(40289),
		14:  uint16(40306),
		15:  uint16(40298),
		16:  uint16(40300),
		17:  uint16(40594),
		18:  uint16(40599),
		19:  uint16(40595),
		20:  uint16(40628),
		21:  uint16(21240),
		22:  uint16(22184),
		23:  uint16(22199),
		24:  uint16(22198),
		25:  uint16(22196),
		26:  uint16(22204),
		27:  uint16(22756),
		28:  uint16(23360),
		29:  uint16(23363),
		30:  uint16(23421),
		31:  uint16(23542),
		32:  uint16(24009),
		33:  uint16(25080),
		34:  uint16(25082),
		35:  uint16(25880),
		36:  uint16(25876),
		37:  uint16(25881),
		38:  uint16(26342),
		39:  uint16(26407),
		40:  uint16(27372),
		41:  uint16(28734),
		42:  uint16(28720),
		43:  uint16(28722),
		44:  uint16(29200),
		45:  uint16(29563),
		46:  uint16(29903),
		47:  uint16(30306),
		48:  uint16(30309),
		49:  uint16(31014),
		50:  uint16(31018),
		51:  uint16(31020),
		52:  uint16(31019),
		53:  uint16(31431),
		54:  uint16(31478),
		55:  uint16(31820),
		56:  uint16(31811),
		57:  uint16(31821),
		58:  uint16(31983),
		59:  uint16(31984),
		60:  uint16(36782),
		61:  uint16(32381),
		62:  uint16(32380),
		63:  uint16(32386),
		64:  uint16(32588),
		65:  uint16(32768),
		66:  uint16(33242),
		67:  uint16(33382),
		68:  uint16(34299),
		69:  uint16(34297),
		70:  uint16(34321),
		71:  uint16(34298),
		72:  uint16(34310),
		73:  uint16(34315),
		74:  uint16(34311),
		75:  uint16(34314),
		76:  uint16(34836),
		77:  uint16(34837),
		78:  uint16(35172),
		79:  uint16(35258),
		80:  uint16(35320),
		81:  uint16(35696),
		82:  uint16(35692),
		83:  uint16(35686),
		84:  uint16(35695),
		85:  uint16(35679),
		86:  uint16(35691),
		87:  uint16(36111),
		88:  uint16(36109),
		89:  uint16(36489),
		90:  uint16(36481),
		91:  uint16(36485),
		92:  uint16(36482),
		93:  uint16(37300),
		94:  uint16(37323),
		95:  uint16(37912),
		96:  uint16(37891),
		97:  uint16(37885),
		98:  uint16(38369),
		99:  uint16(38704),
		100: uint16(39108),
		101: uint16(39250),
		102: uint16(39249),
		103: uint16(39336),
		104: uint16(39467),
		105: uint16(39472),
		106: uint16(39479),
		107: uint16(39477),
		108: uint16(39955),
		109: uint16(39949),
		110: uint16(40569),
		111: uint16(40629),
		112: uint16(40680),
		113: uint16(40751),
		114: uint16(40799),
		115: uint16(40803),
		116: uint16(40801),
		117: uint16(20791),
		118: uint16(20792),
		119: uint16(22209),
		120: uint16(22208),
		121: uint16(22210),
		122: uint16(22804),
		123: uint16(23660),
		124: uint16(24013),
		125: uint16(25084),
		126: uint16(25086),
		127: uint16(25885),
		128: uint16(25884),
		129: uint16(26005),
		130: uint16(26345),
		131: uint16(27387),
		132: uint16(27396),
		133: uint16(27386),
		134: uint16(27570),
		135: uint16(28748),
		136: uint16(29211),
		137: uint16(29351),
		138: uint16(29910),
		139: uint16(29908),
		140: uint16(30313),
		141: uint16(30675),
		142: uint16(31824),
		143: uint16(32399),
		144: uint16(32396),
		145: uint16(32700),
		146: uint16(34327),
		147: uint16(34349),
		148: uint16(34330),
		149: uint16(34851),
		150: uint16(34850),
		151: uint16(34849),
		152: uint16(34847),
		153: uint16(35178),
		154: uint16(35180),
		155: uint16(35261),
		156: uint16(35700),
	},
	36: {
		0:   uint16(35703),
		1:   uint16(35709),
		2:   uint16(36115),
		3:   uint16(36490),
		4:   uint16(36493),
		5:   uint16(36491),
		6:   uint16(36703),
		7:   uint16(36783),
		8:   uint16(37306),
		9:   uint16(37934),
		10:  uint16(37939),
		11:  uint16(37941),
		12:  uint16(37946),
		13:  uint16(37944),
		14:  uint16(37938),
		15:  uint16(37931),
		16:  uint16(38370),
		17:  uint16(38712),
		18:  uint16(38713),
		19:  uint16(38706),
		20:  uint16(38911),
		21:  uint16(39015),
		22:  uint16(39013),
		23:  uint16(39255),
		24:  uint16(39493),
		25:  uint16(39491),
		26:  uint16(39488),
		27:  uint16(39486),
		28:  uint16(39631),
		29:  uint16(39764),
		30:  uint16(39761),
		31:  uint16(39981),
		32:  uint16(39973),
		33:  uint16(40367),
		34:  uint16(40372),
		35:  uint16(40386),
		36:  uint16(40376),
		37:  uint16(40605),
		38:  uint16(40687),
		39:  uint16(40729),
		40:  uint16(40796),
		41:  uint16(40806),
		42:  uint16(40807),
		43:  uint16(20796),
		44:  uint16(20795),
		45:  uint16(22216),
		46:  uint16(22218),
		47:  uint16(22217),
		48:  uint16(23423),
		49:  uint16(24020),
		50:  uint16(24018),
		51:  uint16(24398),
		52:  uint16(25087),
		53:  uint16(25892),
		54:  uint16(27402),
		55:  uint16(27489),
		56:  uint16(28753),
		57:  uint16(28760),
		58:  uint16(29568),
		59:  uint16(29924),
		60:  uint16(30090),
		61:  uint16(30318),
		62:  uint16(30316),
		63:  uint16(31155),
		64:  uint16(31840),
		65:  uint16(31839),
		66:  uint16(32894),
		67:  uint16(32893),
		68:  uint16(33247),
		69:  uint16(35186),
		70:  uint16(35183),
		71:  uint16(35324),
		72:  uint16(35712),
		73:  uint16(36118),
		74:  uint16(36119),
		75:  uint16(36497),
		76:  uint16(36499),
		77:  uint16(36705),
		78:  uint16(37192),
		79:  uint16(37956),
		80:  uint16(37969),
		81:  uint16(37970),
		82:  uint16(38717),
		83:  uint16(38718),
		84:  uint16(38851),
		85:  uint16(38849),
		86:  uint16(39019),
		87:  uint16(39253),
		88:  uint16(39509),
		89:  uint16(39501),
		90:  uint16(39634),
		91:  uint16(39706),
		92:  uint16(40009),
		93:  uint16(39985),
		94:  uint16(39998),
		95:  uint16(39995),
		96:  uint16(40403),
		97:  uint16(40407),
		98:  uint16(40756),
		99:  uint16(40812),
		100: uint16(40810),
		101: uint16(40852),
		102: uint16(22220),
		103: uint16(24022),
		104: uint16(25088),
		105: uint16(25891),
		106: uint16(25899),
		107: uint16(25898),
		108: uint16(26348),
		109: uint16(27408),
		110: uint16(29914),
		111: uint16(31434),
		112: uint16(31844),
		113: uint16(31843),
		114: uint16(31845),
		115: uint16(32403),
		116: uint16(32406),
		117: uint16(32404),
		118: uint16(33250),
		119: uint16(34360),
		120: uint16(34367),
		121: uint16(34865),
		122: uint16(35722),
		123: uint16(37008),
		124: uint16(37007),
		125: uint16(37987),
		126: uint16(37984),
		127: uint16(37988),
		128: uint16(38760),
		129: uint16(39023),
		130: uint16(39260),
		131: uint16(39514),
		132: uint16(39515),
		133: uint16(39511),
		134: uint16(39635),
		135: uint16(39636),
		136: uint16(39633),
		137: uint16(40020),
		138: uint16(40023),
		139: uint16(40022),
		140: uint16(40421),
		141: uint16(40607),
		142: uint16(40692),
		143: uint16(22225),
		144: uint16(22761),
		145: uint16(25900),
		146: uint16(28766),
		147: uint16(30321),
		148: uint16(30322),
		149: uint16(30679),
		150: uint16(32592),
		151: uint16(32648),
		152: uint16(34870),
		153: uint16(34873),
		154: uint16(34914),
		155: uint16(35731),
		156: uint16(35730),
	},
	37: {
		0:   uint16(35734),
		1:   uint16(33399),
		2:   uint16(36123),
		3:   uint16(37312),
		4:   uint16(37994),
		5:   uint16(38722),
		6:   uint16(38728),
		7:   uint16(38724),
		8:   uint16(38854),
		9:   uint16(39024),
		10:  uint16(39519),
		11:  uint16(39714),
		12:  uint16(39768),
		13:  uint16(40031),
		14:  uint16(40441),
		15:  uint16(40442),
		16:  uint16(40572),
		17:  uint16(40573),
		18:  uint16(40711),
		19:  uint16(40823),
		20:  uint16(40818),
		21:  uint16(24307),
		22:  uint16(27414),
		23:  uint16(28771),
		24:  uint16(31852),
		25:  uint16(31854),
		26:  uint16(34875),
		27:  uint16(35264),
		28:  uint16(36513),
		29:  uint16(37313),
		30:  uint16(38002),
		31:  uint16(38000),
		32:  uint16(39025),
		33:  uint16(39262),
		34:  uint16(39638),
		35:  uint16(39715),
		36:  uint16(40652),
		37:  uint16(28772),
		38:  uint16(30682),
		39:  uint16(35738),
		40:  uint16(38007),
		41:  uint16(38857),
		42:  uint16(39522),
		43:  uint16(39525),
		44:  uint16(32412),
		45:  uint16(35740),
		46:  uint16(36522),
		47:  uint16(37317),
		48:  uint16(38013),
		49:  uint16(38014),
		50:  uint16(38012),
		51:  uint16(40055),
		52:  uint16(40056),
		53:  uint16(40695),
		54:  uint16(35924),
		55:  uint16(38015),
		56:  uint16(40474),
		57:  uint16(29224),
		58:  uint16(39530),
		59:  uint16(39729),
		60:  uint16(40475),
		61:  uint16(40478),
		62:  uint16(31858),
		63:  uint16(9312),
		64:  uint16(9313),
		65:  uint16(9314),
		66:  uint16(9315),
		67:  uint16(9316),
		68:  uint16(9317),
		69:  uint16(9318),
		70:  uint16(9319),
		71:  uint16(9320),
		72:  uint16(9321),
		73:  uint16(9332),
		74:  uint16(9333),
		75:  uint16(9334),
		76:  uint16(9335),
		77:  uint16(9336),
		78:  uint16(9337),
		79:  uint16(9338),
		80:  uint16(9339),
		81:  uint16(9340),
		82:  uint16(9341),
		83:  uint16(8560),
		84:  uint16(8561),
		85:  uint16(8562),
		86:  uint16(8563),
		87:  uint16(8564),
		88:  uint16(8565),
		89:  uint16(8566),
		90:  uint16(8567),
		91:  uint16(8568),
		92:  uint16(8569),
		93:  uint16(20022),
		94:  uint16(20031),
		95:  uint16(20101),
		96:  uint16(20128),
		97:  uint16(20866),
		98:  uint16(20886),
		99:  uint16(20907),
		100: uint16(21241),
		101: uint16(21304),
		102: uint16(21353),
		103: uint16(21430),
		104: uint16(22794),
		105: uint16(23424),
		106: uint16(24027),
		107: uint16(24186),
		108: uint16(24191),
		109: uint16(24308),
		110: uint16(24400),
		111: uint16(24417),
		112: uint16(25908),
		113: uint16(26080),
		114: uint16(30098),
		115: uint16(30326),
		116: uint16(36789),
		117: uint16(38582),
		118: uint16(168),
		119: uint16(710),
		120: uint16(12541),
		121: uint16(12542),
		122: uint16(12445),
		123: uint16(12446),
		126: uint16(12293),
		127: uint16(12294),
		128: uint16(12295),
		129: uint16(12540),
		130: uint16(65339),
		131: uint16(65341),
		132: uint16(10045),
		133: uint16(12353),
		134: uint16(12354),
		135: uint16(12355),
		136: uint16(12356),
		137: uint16(12357),
		138: uint16(12358),
		139: uint16(12359),
		140: uint16(12360),
		141: uint16(12361),
		142: uint16(12362),
		143: uint16(12363),
		144: uint16(12364),
		145: uint16(12365),
		146: uint16(12366),
		147: uint16(12367),
		148: uint16(12368),
		149: uint16(12369),
		150: uint16(12370),
		151: uint16(12371),
		152: uint16(12372),
		153: uint16(12373),
		154: uint16(12374),
		155: uint16(12375),
		156: uint16(12376),
	},
	38: {
		0:   uint16(12377),
		1:   uint16(12378),
		2:   uint16(12379),
		3:   uint16(12380),
		4:   uint16(12381),
		5:   uint16(12382),
		6:   uint16(12383),
		7:   uint16(12384),
		8:   uint16(12385),
		9:   uint16(12386),
		10:  uint16(12387),
		11:  uint16(12388),
		12:  uint16(12389),
		13:  uint16(12390),
		14:  uint16(12391),
		15:  uint16(12392),
		16:  uint16(12393),
		17:  uint16(12394),
		18:  uint16(12395),
		19:  uint16(12396),
		20:  uint16(12397),
		21:  uint16(12398),
		22:  uint16(12399),
		23:  uint16(12400),
		24:  uint16(12401),
		25:  uint16(12402),
		26:  uint16(12403),
		27:  uint16(12404),
		28:  uint16(12405),
		29:  uint16(12406),
		30:  uint16(12407),
		31:  uint16(12408),
		32:  uint16(12409),
		33:  uint16(12410),
		34:  uint16(12411),
		35:  uint16(12412),
		36:  uint16(12413),
		37:  uint16(12414),
		38:  uint16(12415),
		39:  uint16(12416),
		40:  uint16(12417),
		41:  uint16(12418),
		42:  uint16(12419),
		43:  uint16(12420),
		44:  uint16(12421),
		45:  uint16(12422),
		46:  uint16(12423),
		47:  uint16(12424),
		48:  uint16(12425),
		49:  uint16(12426),
		50:  uint16(12427),
		51:  uint16(12428),
		52:  uint16(12429),
		53:  uint16(12430),
		54:  uint16(12431),
		55:  uint16(12432),
		56:  uint16(12433),
		57:  uint16(12434),
		58:  uint16(12435),
		59:  uint16(12449),
		60:  uint16(12450),
		61:  uint16(12451),
		62:  uint16(12452),
		63:  uint16(12453),
		64:  uint16(12454),
		65:  uint16(12455),
		66:  uint16(12456),
		67:  uint16(12457),
		68:  uint16(12458),
		69:  uint16(12459),
		70:  uint16(12460),
		71:  uint16(12461),
		72:  uint16(12462),
		73:  uint16(12463),
		74:  uint16(12464),
		75:  uint16(12465),
		76:  uint16(12466),
		77:  uint16(12467),
		78:  uint16(12468),
		79:  uint16(12469),
		80:  uint16(12470),
		81:  uint16(12471),
		82:  uint16(12472),
		83:  uint16(12473),
		84:  uint16(12474),
		85:  uint16(12475),
		86:  uint16(12476),
		87:  uint16(12477),
		88:  uint16(12478),
		89:  uint16(12479),
		90:  uint16(12480),
		91:  uint16(12481),
		92:  uint16(12482),
		93:  uint16(12483),
		94:  uint16(12484),
		95:  uint16(12485),
		96:  uint16(12486),
		97:  uint16(12487),
		98:  uint16(12488),
		99:  uint16(12489),
		100: uint16(12490),
		101: uint16(12491),
		102: uint16(12492),
		103: uint16(12493),
		104: uint16(12494),
		105: uint16(12495),
		106: uint16(12496),
		107: uint16(12497),
		108: uint16(12498),
		109: uint16(12499),
		110: uint16(12500),
		111: uint16(12501),
		112: uint16(12502),
		113: uint16(12503),
		114: uint16(12504),
		115: uint16(12505),
		116: uint16(12506),
		117: uint16(12507),
		118: uint16(12508),
		119: uint16(12509),
		120: uint16(12510),
		121: uint16(12511),
		122: uint16(12512),
		123: uint16(12513),
		124: uint16(12514),
		125: uint16(12515),
		126: uint16(12516),
		127: uint16(12517),
		128: uint16(12518),
		129: uint16(12519),
		130: uint16(12520),
		131: uint16(12521),
		132: uint16(12522),
		133: uint16(12523),
		134: uint16(12524),
		135: uint16(12525),
		136: uint16(12526),
		137: uint16(12527),
		138: uint16(12528),
		139: uint16(12529),
		140: uint16(12530),
		141: uint16(12531),
		142: uint16(12532),
		143: uint16(12533),
		144: uint16(12534),
		145: uint16(1040),
		146: uint16(1041),
		147: uint16(1042),
		148: uint16(1043),
		149: uint16(1044),
		150: uint16(1045),
		151: uint16(1025),
		152: uint16(1046),
		153: uint16(1047),
		154: uint16(1048),
		155: uint16(1049),
		156: uint16(1050),
	},
	39: {
		0:   uint16(1051),
		1:   uint16(1052),
		2:   uint16(1053),
		3:   uint16(1054),
		4:   uint16(1055),
		5:   uint16(1056),
		6:   uint16(1057),
		7:   uint16(1058),
		8:   uint16(1059),
		9:   uint16(1060),
		10:  uint16(1061),
		11:  uint16(1062),
		12:  uint16(1063),
		13:  uint16(1064),
		14:  uint16(1065),
		15:  uint16(1066),
		16:  uint16(1067),
		17:  uint16(1068),
		18:  uint16(1069),
		19:  uint16(1070),
		20:  uint16(1071),
		21:  uint16(1072),
		22:  uint16(1073),
		23:  uint16(1074),
		24:  uint16(1075),
		25:  uint16(1076),
		26:  uint16(1077),
		27:  uint16(1105),
		28:  uint16(1078),
		29:  uint16(1079),
		30:  uint16(1080),
		31:  uint16(1081),
		32:  uint16(1082),
		33:  uint16(1083),
		34:  uint16(1084),
		35:  uint16(1085),
		36:  uint16(1086),
		37:  uint16(1087),
		38:  uint16(1088),
		39:  uint16(1089),
		40:  uint16(1090),
		41:  uint16(1091),
		42:  uint16(1092),
		43:  uint16(1093),
		44:  uint16(1094),
		45:  uint16(1095),
		46:  uint16(1096),
		47:  uint16(1097),
		48:  uint16(1098),
		49:  uint16(1099),
		50:  uint16(1100),
		51:  uint16(1101),
		52:  uint16(1102),
		53:  uint16(1103),
		54:  uint16(8679),
		55:  uint16(8632),
		56:  uint16(8633),
		57:  uint16(12751),
		58:  uint16(204),
		59:  uint16(20058),
		60:  uint16(138),
		61:  uint16(20994),
		62:  uint16(17553),
		63:  uint16(40880),
		64:  uint16(20872),
		65:  uint16(40881),
		66:  uint16(30215),
		107: uint16(65506),
		108: uint16(65508),
		109: uint16(65287),
		110: uint16(65282),
		111: uint16(12849),
		112: uint16(8470),
		113: uint16(8481),
		114: uint16(12443),
		115: uint16(12444),
		116: uint16(11904),
		117: uint16(11908),
		118: uint16(11910),
		119: uint16(11911),
		120: uint16(11912),
		121: uint16(11914),
		122: uint16(11916),
		123: uint16(11917),
		124: uint16(11925),
		125: uint16(11932),
		126: uint16(11933),
		127: uint16(11941),
		128: uint16(11943),
		129: uint16(11946),
		130: uint16(11948),
		131: uint16(11950),
		132: uint16(11958),
		133: uint16(11964),
		134: uint16(11966),
		135: uint16(11974),
		136: uint16(11978),
		137: uint16(11980),
		138: uint16(11981),
		139: uint16(11983),
		140: uint16(11990),
		141: uint16(11991),
		142: uint16(11998),
		143: uint16(12003),
		147: uint16(643),
		148: uint16(592),
		149: uint16(603),
		150: uint16(596),
		151: uint16(629),
		152: uint16(339),
		153: uint16(248),
		154: uint16(331),
		155: uint16(650),
		156: uint16(618),
	},
	40: {
		0:   uint16(20034),
		1:   uint16(20060),
		2:   uint16(20981),
		3:   uint16(21274),
		4:   uint16(21378),
		5:   uint16(19975),
		6:   uint16(19980),
		7:   uint16(20039),
		8:   uint16(20109),
		9:   uint16(22231),
		10:  uint16(64012),
		11:  uint16(23662),
		12:  uint16(24435),
		13:  uint16(19983),
		14:  uint16(20871),
		15:  uint16(19982),
		16:  uint16(20014),
		17:  uint16(20115),
		18:  uint16(20162),
		19:  uint16(20169),
		20:  uint16(20168),
		21:  uint16(20888),
		22:  uint16(21244),
		23:  uint16(21356),
		24:  uint16(21433),
		25:  uint16(22304),
		26:  uint16(22787),
		27:  uint16(22828),
		28:  uint16(23568),
		29:  uint16(24063),
		30:  uint16(26081),
		31:  uint16(27571),
		32:  uint16(27596),
		33:  uint16(27668),
		34:  uint16(29247),
		35:  uint16(20017),
		36:  uint16(20028),
		37:  uint16(20200),
		38:  uint16(20188),
		39:  uint16(20201),
		40:  uint16(20193),
		41:  uint16(20189),
		42:  uint16(20186),
		43:  uint16(21004),
		44:  uint16(21276),
		45:  uint16(21324),
		46:  uint16(22306),
		47:  uint16(22307),
		48:  uint16(22807),
		49:  uint16(22831),
		50:  uint16(23425),
		51:  uint16(23428),
		52:  uint16(23570),
		53:  uint16(23611),
		54:  uint16(23668),
		55:  uint16(23667),
		56:  uint16(24068),
		57:  uint16(24192),
		58:  uint16(24194),
		59:  uint16(24521),
		60:  uint16(25097),
		61:  uint16(25168),
		62:  uint16(27669),
		63:  uint16(27702),
		64:  uint16(27715),
		65:  uint16(27711),
		66:  uint16(27707),
		67:  uint16(29358),
		68:  uint16(29360),
		69:  uint16(29578),
		70:  uint16(31160),
		71:  uint16(32906),
		72:  uint16(38430),
		73:  uint16(20238),
		74:  uint16(20248),
		75:  uint16(20268),
		76:  uint16(20213),
		77:  uint16(20244),
		78:  uint16(20209),
		79:  uint16(20224),
		80:  uint16(20215),
		81:  uint16(20232),
		82:  uint16(20253),
		83:  uint16(20226),
		84:  uint16(20229),
		85:  uint16(20258),
		86:  uint16(20243),
		87:  uint16(20228),
		88:  uint16(20212),
		89:  uint16(20242),
		90:  uint16(20913),
		91:  uint16(21011),
		92:  uint16(21001),
		93:  uint16(21008),
		94:  uint16(21158),
		95:  uint16(21282),
		96:  uint16(21279),
		97:  uint16(21325),
		98:  uint16(21386),
		99:  uint16(21511),
		100: uint16(22241),
		101: uint16(22239),
		102: uint16(22318),
		103: uint16(22314),
		104: uint16(22324),
		105: uint16(22844),
		106: uint16(22912),
		107: uint16(22908),
		108: uint16(22917),
		109: uint16(22907),
		110: uint16(22910),
		111: uint16(22903),
		112: uint16(22911),
		113: uint16(23382),
		114: uint16(23573),
		115: uint16(23589),
		116: uint16(23676),
		117: uint16(23674),
		118: uint16(23675),
		119: uint16(23678),
		120: uint16(24031),
		121: uint16(24181),
		122: uint16(24196),
		123: uint16(24322),
		124: uint16(24346),
		125: uint16(24436),
		126: uint16(24533),
		127: uint16(24532),
		128: uint16(24527),
		129: uint16(25180),
		130: uint16(25182),
		131: uint16(25188),
		132: uint16(25185),
		133: uint16(25190),
		134: uint16(25186),
		135: uint16(25177),
		136: uint16(25184),
		137: uint16(25178),
		138: uint16(25189),
		139: uint16(26095),
		140: uint16(26094),
		141: uint16(26430),
		142: uint16(26425),
		143: uint16(26424),
		144: uint16(26427),
		145: uint16(26426),
		146: uint16(26431),
		147: uint16(26428),
		148: uint16(26419),
		149: uint16(27672),
		150: uint16(27718),
		151: uint16(27730),
		152: uint16(27740),
		153: uint16(27727),
		154: uint16(27722),
		155: uint16(27732),
		156: uint16(27723),
	},
	41: {
		0:   uint16(27724),
		1:   uint16(28785),
		2:   uint16(29278),
		3:   uint16(29364),
		4:   uint16(29365),
		5:   uint16(29582),
		6:   uint16(29994),
		7:   uint16(30335),
		8:   uint16(31349),
		9:   uint16(32593),
		10:  uint16(33400),
		11:  uint16(33404),
		12:  uint16(33408),
		13:  uint16(33405),
		14:  uint16(33407),
		15:  uint16(34381),
		16:  uint16(35198),
		17:  uint16(37017),
		18:  uint16(37015),
		19:  uint16(37016),
		20:  uint16(37019),
		21:  uint16(37012),
		22:  uint16(38434),
		23:  uint16(38436),
		24:  uint16(38432),
		25:  uint16(38435),
		26:  uint16(20310),
		27:  uint16(20283),
		28:  uint16(20322),
		29:  uint16(20297),
		30:  uint16(20307),
		31:  uint16(20324),
		32:  uint16(20286),
		33:  uint16(20327),
		34:  uint16(20306),
		35:  uint16(20319),
		36:  uint16(20289),
		37:  uint16(20312),
		38:  uint16(20269),
		39:  uint16(20275),
		40:  uint16(20287),
		41:  uint16(20321),
		42:  uint16(20879),
		43:  uint16(20921),
		44:  uint16(21020),
		45:  uint16(21022),
		46:  uint16(21025),
		47:  uint16(21165),
		48:  uint16(21166),
		49:  uint16(21257),
		50:  uint16(21347),
		51:  uint16(21362),
		52:  uint16(21390),
		53:  uint16(21391),
		54:  uint16(21552),
		55:  uint16(21559),
		56:  uint16(21546),
		57:  uint16(21588),
		58:  uint16(21573),
		59:  uint16(21529),
		60:  uint16(21532),
		61:  uint16(21541),
		62:  uint16(21528),
		63:  uint16(21565),
		64:  uint16(21583),
		65:  uint16(21569),
		66:  uint16(21544),
		67:  uint16(21540),
		68:  uint16(21575),
		69:  uint16(22254),
		70:  uint16(22247),
		71:  uint16(22245),
		72:  uint16(22337),
		73:  uint16(22341),
		74:  uint16(22348),
		75:  uint16(22345),
		76:  uint16(22347),
		77:  uint16(22354),
		78:  uint16(22790),
		79:  uint16(22848),
		80:  uint16(22950),
		81:  uint16(22936),
		82:  uint16(22944),
		83:  uint16(22935),
		84:  uint16(22926),
		85:  uint16(22946),
		86:  uint16(22928),
		87:  uint16(22927),
		88:  uint16(22951),
		89:  uint16(22945),
		90:  uint16(23438),
		91:  uint16(23442),
		92:  uint16(23592),
		93:  uint16(23594),
		94:  uint16(23693),
		95:  uint16(23695),
		96:  uint16(23688),
		97:  uint16(23691),
		98:  uint16(23689),
		99:  uint16(23698),
		100: uint16(23690),
		101: uint16(23686),
		102: uint16(23699),
		103: uint16(23701),
		104: uint16(24032),
		105: uint16(24074),
		106: uint16(24078),
		107: uint16(24203),
		108: uint16(24201),
		109: uint16(24204),
		110: uint16(24200),
		111: uint16(24205),
		112: uint16(24325),
		113: uint16(24349),
		114: uint16(24440),
		115: uint16(24438),
		116: uint16(24530),
		117: uint16(24529),
		118: uint16(24528),
		119: uint16(24557),
		120: uint16(24552),
		121: uint16(24558),
		122: uint16(24563),
		123: uint16(24545),
		124: uint16(24548),
		125: uint16(24547),
		126: uint16(24570),
		127: uint16(24559),
		128: uint16(24567),
		129: uint16(24571),
		130: uint16(24576),
		131: uint16(24564),
		132: uint16(25146),
		133: uint16(25219),
		134: uint16(25228),
		135: uint16(25230),
		136: uint16(25231),
		137: uint16(25236),
		138: uint16(25223),
		139: uint16(25201),
		140: uint16(25211),
		141: uint16(25210),
		142: uint16(25200),
		143: uint16(25217),
		144: uint16(25224),
		145: uint16(25207),
		146: uint16(25213),
		147: uint16(25202),
		148: uint16(25204),
		149: uint16(25911),
		150: uint16(26096),
		151: uint16(26100),
		152: uint16(26099),
		153: uint16(26098),
		154: uint16(26101),
		155: uint16(26437),
		156: uint16(26439),
	},
	42: {
		0:   uint16(26457),
		1:   uint16(26453),
		2:   uint16(26444),
		3:   uint16(26440),
		4:   uint16(26461),
		5:   uint16(26445),
		6:   uint16(26458),
		7:   uint16(26443),
		8:   uint16(27600),
		9:   uint16(27673),
		10:  uint16(27674),
		11:  uint16(27768),
		12:  uint16(27751),
		13:  uint16(27755),
		14:  uint16(27780),
		15:  uint16(27787),
		16:  uint16(27791),
		17:  uint16(27761),
		18:  uint16(27759),
		19:  uint16(27753),
		20:  uint16(27802),
		21:  uint16(27757),
		22:  uint16(27783),
		23:  uint16(27797),
		24:  uint16(27804),
		25:  uint16(27750),
		26:  uint16(27763),
		27:  uint16(27749),
		28:  uint16(27771),
		29:  uint16(27790),
		30:  uint16(28788),
		31:  uint16(28794),
		32:  uint16(29283),
		33:  uint16(29375),
		34:  uint16(29373),
		35:  uint16(29379),
		36:  uint16(29382),
		37:  uint16(29377),
		38:  uint16(29370),
		39:  uint16(29381),
		40:  uint16(29589),
		41:  uint16(29591),
		42:  uint16(29587),
		43:  uint16(29588),
		44:  uint16(29586),
		45:  uint16(30010),
		46:  uint16(30009),
		47:  uint16(30100),
		48:  uint16(30101),
		49:  uint16(30337),
		50:  uint16(31037),
		51:  uint16(32820),
		52:  uint16(32917),
		53:  uint16(32921),
		54:  uint16(32912),
		55:  uint16(32914),
		56:  uint16(32924),
		57:  uint16(33424),
		58:  uint16(33423),
		59:  uint16(33413),
		60:  uint16(33422),
		61:  uint16(33425),
		62:  uint16(33427),
		63:  uint16(33418),
		64:  uint16(33411),
		65:  uint16(33412),
		66:  uint16(35960),
		67:  uint16(36809),
		68:  uint16(36799),
		69:  uint16(37023),
		70:  uint16(37025),
		71:  uint16(37029),
		72:  uint16(37022),
		73:  uint16(37031),
		74:  uint16(37024),
		75:  uint16(38448),
		76:  uint16(38440),
		77:  uint16(38447),
		78:  uint16(38445),
		79:  uint16(20019),
		80:  uint16(20376),
		81:  uint16(20348),
		82:  uint16(20357),
		83:  uint16(20349),
		84:  uint16(20352),
		85:  uint16(20359),
		86:  uint16(20342),
		87:  uint16(20340),
		88:  uint16(20361),
		89:  uint16(20356),
		90:  uint16(20343),
		91:  uint16(20300),
		92:  uint16(20375),
		93:  uint16(20330),
		94:  uint16(20378),
		95:  uint16(20345),
		96:  uint16(20353),
		97:  uint16(20344),
		98:  uint16(20368),
		99:  uint16(20380),
		100: uint16(20372),
		101: uint16(20382),
		102: uint16(20370),
		103: uint16(20354),
		104: uint16(20373),
		105: uint16(20331),
		106: uint16(20334),
		107: uint16(20894),
		108: uint16(20924),
		109: uint16(20926),
		110: uint16(21045),
		111: uint16(21042),
		112: uint16(21043),
		113: uint16(21062),
		114: uint16(21041),
		115: uint16(21180),
		116: uint16(21258),
		117: uint16(21259),
		118: uint16(21308),
		119: uint16(21394),
		120: uint16(21396),
		121: uint16(21639),
		122: uint16(21631),
		123: uint16(21633),
		124: uint16(21649),
		125: uint16(21634),
		126: uint16(21640),
		127: uint16(21611),
		128: uint16(21626),
		129: uint16(21630),
		130: uint16(21605),
		131: uint16(21612),
		132: uint16(21620),
		133: uint16(21606),
		134: uint16(21645),
		135: uint16(21615),
		136: uint16(21601),
		137: uint16(21600),
		138: uint16(21656),
		139: uint16(21603),
		140: uint16(21607),
		141: uint16(21604),
		142: uint16(22263),
		143: uint16(22265),
		144: uint16(22383),
		145: uint16(22386),
		146: uint16(22381),
		147: uint16(22379),
		148: uint16(22385),
		149: uint16(22384),
		150: uint16(22390),
		151: uint16(22400),
		152: uint16(22389),
		153: uint16(22395),
		154: uint16(22387),
		155: uint16(22388),
		156: uint16(22370),
	},
	43: {
		0:   uint16(22376),
		1:   uint16(22397),
		2:   uint16(22796),
		3:   uint16(22853),
		4:   uint16(22965),
		5:   uint16(22970),
		6:   uint16(22991),
		7:   uint16(22990),
		8:   uint16(22962),
		9:   uint16(22988),
		10:  uint16(22977),
		11:  uint16(22966),
		12:  uint16(22972),
		13:  uint16(22979),
		14:  uint16(22998),
		15:  uint16(22961),
		16:  uint16(22973),
		17:  uint16(22976),
		18:  uint16(22984),
		19:  uint16(22964),
		20:  uint16(22983),
		21:  uint16(23394),
		22:  uint16(23397),
		23:  uint16(23443),
		24:  uint16(23445),
		25:  uint16(23620),
		26:  uint16(23623),
		27:  uint16(23726),
		28:  uint16(23716),
		29:  uint16(23712),
		30:  uint16(23733),
		31:  uint16(23727),
		32:  uint16(23720),
		33:  uint16(23724),
		34:  uint16(23711),
		35:  uint16(23715),
		36:  uint16(23725),
		37:  uint16(23714),
		38:  uint16(23722),
		39:  uint16(23719),
		40:  uint16(23709),
		41:  uint16(23717),
		42:  uint16(23734),
		43:  uint16(23728),
		44:  uint16(23718),
		45:  uint16(24087),
		46:  uint16(24084),
		47:  uint16(24089),
		48:  uint16(24360),
		49:  uint16(24354),
		50:  uint16(24355),
		51:  uint16(24356),
		52:  uint16(24404),
		53:  uint16(24450),
		54:  uint16(24446),
		55:  uint16(24445),
		56:  uint16(24542),
		57:  uint16(24549),
		58:  uint16(24621),
		59:  uint16(24614),
		60:  uint16(24601),
		61:  uint16(24626),
		62:  uint16(24587),
		63:  uint16(24628),
		64:  uint16(24586),
		65:  uint16(24599),
		66:  uint16(24627),
		67:  uint16(24602),
		68:  uint16(24606),
		69:  uint16(24620),
		70:  uint16(24610),
		71:  uint16(24589),
		72:  uint16(24592),
		73:  uint16(24622),
		74:  uint16(24595),
		75:  uint16(24593),
		76:  uint16(24588),
		77:  uint16(24585),
		78:  uint16(24604),
		79:  uint16(25108),
		80:  uint16(25149),
		81:  uint16(25261),
		82:  uint16(25268),
		83:  uint16(25297),
		84:  uint16(25278),
		85:  uint16(25258),
		86:  uint16(25270),
		87:  uint16(25290),
		88:  uint16(25262),
		89:  uint16(25267),
		90:  uint16(25263),
		91:  uint16(25275),
		92:  uint16(25257),
		93:  uint16(25264),
		94:  uint16(25272),
		95:  uint16(25917),
		96:  uint16(26024),
		97:  uint16(26043),
		98:  uint16(26121),
		99:  uint16(26108),
		100: uint16(26116),
		101: uint16(26130),
		102: uint16(26120),
		103: uint16(26107),
		104: uint16(26115),
		105: uint16(26123),
		106: uint16(26125),
		107: uint16(26117),
		108: uint16(26109),
		109: uint16(26129),
		110: uint16(26128),
		111: uint16(26358),
		112: uint16(26378),
		113: uint16(26501),
		114: uint16(26476),
		115: uint16(26510),
		116: uint16(26514),
		117: uint16(26486),
		118: uint16(26491),
		119: uint16(26520),
		120: uint16(26502),
		121: uint16(26500),
		122: uint16(26484),
		123: uint16(26509),
		124: uint16(26508),
		125: uint16(26490),
		126: uint16(26527),
		127: uint16(26513),
		128: uint16(26521),
		129: uint16(26499),
		130: uint16(26493),
		131: uint16(26497),
		132: uint16(26488),
		133: uint16(26489),
		134: uint16(26516),
		135: uint16(27429),
		136: uint16(27520),
		137: uint16(27518),
		138: uint16(27614),
		139: uint16(27677),
		140: uint16(27795),
		141: uint16(27884),
		142: uint16(27883),
		143: uint16(27886),
		144: uint16(27865),
		145: uint16(27830),
		146: uint16(27860),
		147: uint16(27821),
		148: uint16(27879),
		149: uint16(27831),
		150: uint16(27856),
		151: uint16(27842),
		152: uint16(27834),
		153: uint16(27843),
		154: uint16(27846),
		155: uint16(27885),
		156: uint16(27890),
	},
	44: {
		0:   uint16(27858),
		1:   uint16(27869),
		2:   uint16(27828),
		3:   uint16(27786),
		4:   uint16(27805),
		5:   uint16(27776),
		6:   uint16(27870),
		7:   uint16(27840),
		8:   uint16(27952),
		9:   uint16(27853),
		10:  uint16(27847),
		11:  uint16(27824),
		12:  uint16(27897),
		13:  uint16(27855),
		14:  uint16(27881),
		15:  uint16(27857),
		16:  uint16(28820),
		17:  uint16(28824),
		18:  uint16(28805),
		19:  uint16(28819),
		20:  uint16(28806),
		21:  uint16(28804),
		22:  uint16(28817),
		23:  uint16(28822),
		24:  uint16(28802),
		25:  uint16(28826),
		26:  uint16(28803),
		27:  uint16(29290),
		28:  uint16(29398),
		29:  uint16(29387),
		30:  uint16(29400),
		31:  uint16(29385),
		32:  uint16(29404),
		33:  uint16(29394),
		34:  uint16(29396),
		35:  uint16(29402),
		36:  uint16(29388),
		37:  uint16(29393),
		38:  uint16(29604),
		39:  uint16(29601),
		40:  uint16(29613),
		41:  uint16(29606),
		42:  uint16(29602),
		43:  uint16(29600),
		44:  uint16(29612),
		45:  uint16(29597),
		46:  uint16(29917),
		47:  uint16(29928),
		48:  uint16(30015),
		49:  uint16(30016),
		50:  uint16(30014),
		51:  uint16(30092),
		52:  uint16(30104),
		53:  uint16(30383),
		54:  uint16(30451),
		55:  uint16(30449),
		56:  uint16(30448),
		57:  uint16(30453),
		58:  uint16(30712),
		59:  uint16(30716),
		60:  uint16(30713),
		61:  uint16(30715),
		62:  uint16(30714),
		63:  uint16(30711),
		64:  uint16(31042),
		65:  uint16(31039),
		66:  uint16(31173),
		67:  uint16(31352),
		68:  uint16(31355),
		69:  uint16(31483),
		70:  uint16(31861),
		71:  uint16(31997),
		72:  uint16(32821),
		73:  uint16(32911),
		74:  uint16(32942),
		75:  uint16(32931),
		76:  uint16(32952),
		77:  uint16(32949),
		78:  uint16(32941),
		79:  uint16(33312),
		80:  uint16(33440),
		81:  uint16(33472),
		82:  uint16(33451),
		83:  uint16(33434),
		84:  uint16(33432),
		85:  uint16(33435),
		86:  uint16(33461),
		87:  uint16(33447),
		88:  uint16(33454),
		89:  uint16(33468),
		90:  uint16(33438),
		91:  uint16(33466),
		92:  uint16(33460),
		93:  uint16(33448),
		94:  uint16(33441),
		95:  uint16(33449),
		96:  uint16(33474),
		97:  uint16(33444),
		98:  uint16(33475),
		99:  uint16(33462),
		100: uint16(33442),
		101: uint16(34416),
		102: uint16(34415),
		103: uint16(34413),
		104: uint16(34414),
		105: uint16(35926),
		106: uint16(36818),
		107: uint16(36811),
		108: uint16(36819),
		109: uint16(36813),
		110: uint16(36822),
		111: uint16(36821),
		112: uint16(36823),
		113: uint16(37042),
		114: uint16(37044),
		115: uint16(37039),
		116: uint16(37043),
		117: uint16(37040),
		118: uint16(38457),
		119: uint16(38461),
		120: uint16(38460),
		121: uint16(38458),
		122: uint16(38467),
		123: uint16(20429),
		124: uint16(20421),
		125: uint16(20435),
		126: uint16(20402),
		127: uint16(20425),
		128: uint16(20427),
		129: uint16(20417),
		130: uint16(20436),
		131: uint16(20444),
		132: uint16(20441),
		133: uint16(20411),
		134: uint16(20403),
		135: uint16(20443),
		136: uint16(20423),
		137: uint16(20438),
		138: uint16(20410),
		139: uint16(20416),
		140: uint16(20409),
		141: uint16(20460),
		142: uint16(21060),
		143: uint16(21065),
		144: uint16(21184),
		145: uint16(21186),
		146: uint16(21309),
		147: uint16(21372),
		148: uint16(21399),
		149: uint16(21398),
		150: uint16(21401),
		151: uint16(21400),
		152: uint16(21690),
		153: uint16(21665),
		154: uint16(21677),
		155: uint16(21669),
		156: uint16(21711),
	},
	45: {
		0:   uint16(21699),
		1:   uint16(33549),
		2:   uint16(21687),
		3:   uint16(21678),
		4:   uint16(21718),
		5:   uint16(21686),
		6:   uint16(21701),
		7:   uint16(21702),
		8:   uint16(21664),
		9:   uint16(21616),
		10:  uint16(21692),
		11:  uint16(21666),
		12:  uint16(21694),
		13:  uint16(21618),
		14:  uint16(21726),
		15:  uint16(21680),
		16:  uint16(22453),
		17:  uint16(22430),
		18:  uint16(22431),
		19:  uint16(22436),
		20:  uint16(22412),
		21:  uint16(22423),
		22:  uint16(22429),
		23:  uint16(22427),
		24:  uint16(22420),
		25:  uint16(22424),
		26:  uint16(22415),
		27:  uint16(22425),
		28:  uint16(22437),
		29:  uint16(22426),
		30:  uint16(22421),
		31:  uint16(22772),
		32:  uint16(22797),
		33:  uint16(22867),
		34:  uint16(23009),
		35:  uint16(23006),
		36:  uint16(23022),
		37:  uint16(23040),
		38:  uint16(23025),
		39:  uint16(23005),
		40:  uint16(23034),
		41:  uint16(23037),
		42:  uint16(23036),
		43:  uint16(23030),
		44:  uint16(23012),
		45:  uint16(23026),
		46:  uint16(23031),
		47:  uint16(23003),
		48:  uint16(23017),
		49:  uint16(23027),
		50:  uint16(23029),
		51:  uint16(23008),
		52:  uint16(23038),
		53:  uint16(23028),
		54:  uint16(23021),
		55:  uint16(23464),
		56:  uint16(23628),
		57:  uint16(23760),
		58:  uint16(23768),
		59:  uint16(23756),
		60:  uint16(23767),
		61:  uint16(23755),
		62:  uint16(23771),
		63:  uint16(23774),
		64:  uint16(23770),
		65:  uint16(23753),
		66:  uint16(23751),
		67:  uint16(23754),
		68:  uint16(23766),
		69:  uint16(23763),
		70:  uint16(23764),
		71:  uint16(23759),
		72:  uint16(23752),
		73:  uint16(23750),
		74:  uint16(23758),
		75:  uint16(23775),
		76:  uint16(23800),
		77:  uint16(24057),
		78:  uint16(24097),
		79:  uint16(24098),
		80:  uint16(24099),
		81:  uint16(24096),
		82:  uint16(24100),
		83:  uint16(24240),
		84:  uint16(24228),
		85:  uint16(24226),
		86:  uint16(24219),
		87:  uint16(24227),
		88:  uint16(24229),
		89:  uint16(24327),
		90:  uint16(24366),
		91:  uint16(24406),
		92:  uint16(24454),
		93:  uint16(24631),
		94:  uint16(24633),
		95:  uint16(24660),
		96:  uint16(24690),
		97:  uint16(24670),
		98:  uint16(24645),
		99:  uint16(24659),
		100: uint16(24647),
		101: uint16(24649),
		102: uint16(24667),
		103: uint16(24652),
		104: uint16(24640),
		105: uint16(24642),
		106: uint16(24671),
		107: uint16(24612),
		108: uint16(24644),
		109: uint16(24664),
		110: uint16(24678),
		111: uint16(24686),
		112: uint16(25154),
		113: uint16(25155),
		114: uint16(25295),
		115: uint16(25357),
		116: uint16(25355),
		117: uint16(25333),
		118: uint16(25358),
		119: uint16(25347),
		120: uint16(25323),
		121: uint16(25337),
		122: uint16(25359),
		123: uint16(25356),
		124: uint16(25336),
		125: uint16(25334),
		126: uint16(25344),
		127: uint16(25363),
		128: uint16(25364),
		129: uint16(25338),
		130: uint16(25365),
		131: uint16(25339),
		132: uint16(25328),
		133: uint16(25921),
		134: uint16(25923),
		135: uint16(26026),
		136: uint16(26047),
		137: uint16(26166),
		138: uint16(26145),
		139: uint16(26162),
		140: uint16(26165),
		141: uint16(26140),
		142: uint16(26150),
		143: uint16(26146),
		144: uint16(26163),
		145: uint16(26155),
		146: uint16(26170),
		147: uint16(26141),
		148: uint16(26164),
		149: uint16(26169),
		150: uint16(26158),
		151: uint16(26383),
		152: uint16(26384),
		153: uint16(26561),
		154: uint16(26610),
		155: uint16(26568),
		156: uint16(26554),
	},
	46: {
		0:   uint16(26588),
		1:   uint16(26555),
		2:   uint16(26616),
		3:   uint16(26584),
		4:   uint16(26560),
		5:   uint16(26551),
		6:   uint16(26565),
		7:   uint16(26603),
		8:   uint16(26596),
		9:   uint16(26591),
		10:  uint16(26549),
		11:  uint16(26573),
		12:  uint16(26547),
		13:  uint16(26615),
		14:  uint16(26614),
		15:  uint16(26606),
		16:  uint16(26595),
		17:  uint16(26562),
		18:  uint16(26553),
		19:  uint16(26574),
		20:  uint16(26599),
		21:  uint16(26608),
		22:  uint16(26546),
		23:  uint16(26620),
		24:  uint16(26566),
		25:  uint16(26605),
		26:  uint16(26572),
		27:  uint16(26542),
		28:  uint16(26598),
		29:  uint16(26587),
		30:  uint16(26618),
		31:  uint16(26569),
		32:  uint16(26570),
		33:  uint16(26563),
		34:  uint16(26602),
		35:  uint16(26571),
		36:  uint16(27432),
		37:  uint16(27522),
		38:  uint16(27524),
		39:  uint16(27574),
		40:  uint16(27606),
		41:  uint16(27608),
		42:  uint16(27616),
		43:  uint16(27680),
		44:  uint16(27681),
		45:  uint16(27944),
		46:  uint16(27956),
		47:  uint16(27949),
		48:  uint16(27935),
		49:  uint16(27964),
		50:  uint16(27967),
		51:  uint16(27922),
		52:  uint16(27914),
		53:  uint16(27866),
		54:  uint16(27955),
		55:  uint16(27908),
		56:  uint16(27929),
		57:  uint16(27962),
		58:  uint16(27930),
		59:  uint16(27921),
		60:  uint16(27904),
		61:  uint16(27933),
		62:  uint16(27970),
		63:  uint16(27905),
		64:  uint16(27928),
		65:  uint16(27959),
		66:  uint16(27907),
		67:  uint16(27919),
		68:  uint16(27968),
		69:  uint16(27911),
		70:  uint16(27936),
		71:  uint16(27948),
		72:  uint16(27912),
		73:  uint16(27938),
		74:  uint16(27913),
		75:  uint16(27920),
		76:  uint16(28855),
		77:  uint16(28831),
		78:  uint16(28862),
		79:  uint16(28849),
		80:  uint16(28848),
		81:  uint16(28833),
		82:  uint16(28852),
		83:  uint16(28853),
		84:  uint16(28841),
		85:  uint16(29249),
		86:  uint16(29257),
		87:  uint16(29258),
		88:  uint16(29292),
		89:  uint16(29296),
		90:  uint16(29299),
		91:  uint16(29294),
		92:  uint16(29386),
		93:  uint16(29412),
		94:  uint16(29416),
		95:  uint16(29419),
		96:  uint16(29407),
		97:  uint16(29418),
		98:  uint16(29414),
		99:  uint16(29411),
		100: uint16(29573),
		101: uint16(29644),
		102: uint16(29634),
		103: uint16(29640),
		104: uint16(29637),
		105: uint16(29625),
		106: uint16(29622),
		107: uint16(29621),
		108: uint16(29620),
		109: uint16(29675),
		110: uint16(29631),
		111: uint16(29639),
		112: uint16(29630),
		113: uint16(29635),
		114: uint16(29638),
		115: uint16(29624),
		116: uint16(29643),
		117: uint16(29932),
		118: uint16(29934),
		119: uint16(29998),
		120: uint16(30023),
		121: uint16(30024),
		122: uint16(30119),
		123: uint16(30122),
		124: uint16(30329),
		125: uint16(30404),
		126: uint16(30472),
		127: uint16(30467),
		128: uint16(30468),
		129: uint16(30469),
		130: uint16(30474),
		131: uint16(30455),
		132: uint16(30459),
		133: uint16(30458),
		134: uint16(30695),
		135: uint16(30696),
		136: uint16(30726),
		137: uint16(30737),
		138: uint16(30738),
		139: uint16(30725),
		140: uint16(30736),
		141: uint16(30735),
		142: uint16(30734),
		143: uint16(30729),
		144: uint16(30723),
		145: uint16(30739),
		146: uint16(31050),
		147: uint16(31052),
		148: uint16(31051),
		149: uint16(31045),
		150: uint16(31044),
		151: uint16(31189),
		152: uint16(31181),
		153: uint16(31183),
		154: uint16(31190),
		155: uint16(31182),
		156: uint16(31360),
	},
	47: {
		0:   uint16(31358),
		1:   uint16(31441),
		2:   uint16(31488),
		3:   uint16(31489),
		4:   uint16(31866),
		5:   uint16(31864),
		6:   uint16(31865),
		7:   uint16(31871),
		8:   uint16(31872),
		9:   uint16(31873),
		10:  uint16(32003),
		11:  uint16(32008),
		12:  uint16(32001),
		13:  uint16(32600),
		14:  uint16(32657),
		15:  uint16(32653),
		16:  uint16(32702),
		17:  uint16(32775),
		18:  uint16(32782),
		19:  uint16(32783),
		20:  uint16(32788),
		21:  uint16(32823),
		22:  uint16(32984),
		23:  uint16(32967),
		24:  uint16(32992),
		25:  uint16(32977),
		26:  uint16(32968),
		27:  uint16(32962),
		28:  uint16(32976),
		29:  uint16(32965),
		30:  uint16(32995),
		31:  uint16(32985),
		32:  uint16(32988),
		33:  uint16(32970),
		34:  uint16(32981),
		35:  uint16(32969),
		36:  uint16(32975),
		37:  uint16(32983),
		38:  uint16(32998),
		39:  uint16(32973),
		40:  uint16(33279),
		41:  uint16(33313),
		42:  uint16(33428),
		43:  uint16(33497),
		44:  uint16(33534),
		45:  uint16(33529),
		46:  uint16(33543),
		47:  uint16(33512),
		48:  uint16(33536),
		49:  uint16(33493),
		50:  uint16(33594),
		51:  uint16(33515),
		52:  uint16(33494),
		53:  uint16(33524),
		54:  uint16(33516),
		55:  uint16(33505),
		56:  uint16(33522),
		57:  uint16(33525),
		58:  uint16(33548),
		59:  uint16(33531),
		60:  uint16(33526),
		61:  uint16(33520),
		62:  uint16(33514),
		63:  uint16(33508),
		64:  uint16(33504),
		65:  uint16(33530),
		66:  uint16(33523),
		67:  uint16(33517),
		68:  uint16(34423),
		69:  uint16(34420),
		70:  uint16(34428),
		71:  uint16(34419),
		72:  uint16(34881),
		73:  uint16(34894),
		74:  uint16(34919),
		75:  uint16(34922),
		76:  uint16(34921),
		77:  uint16(35283),
		78:  uint16(35332),
		79:  uint16(35335),
		80:  uint16(36210),
		81:  uint16(36835),
		82:  uint16(36833),
		83:  uint16(36846),
		84:  uint16(36832),
		85:  uint16(37105),
		86:  uint16(37053),
		87:  uint16(37055),
		88:  uint16(37077),
		89:  uint16(37061),
		90:  uint16(37054),
		91:  uint16(37063),
		92:  uint16(37067),
		93:  uint16(37064),
		94:  uint16(37332),
		95:  uint16(37331),
		96:  uint16(38484),
		97:  uint16(38479),
		98:  uint16(38481),
		99:  uint16(38483),
		100: uint16(38474),
		101: uint16(38478),
		102: uint16(20510),
		103: uint16(20485),
		104: uint16(20487),
		105: uint16(20499),
		106: uint16(20514),
		107: uint16(20528),
		108: uint16(20507),
		109: uint16(20469),
		110: uint16(20468),
		111: uint16(20531),
		112: uint16(20535),
		113: uint16(20524),
		114: uint16(20470),
		115: uint16(20471),
		116: uint16(20503),
		117: uint16(20508),
		118: uint16(20512),
		119: uint16(20519),
		120: uint16(20533),
		121: uint16(20527),
		122: uint16(20529),
		123: uint16(20494),
		124: uint16(20826),
		125: uint16(20884),
		126: uint16(20883),
		127: uint16(20938),
		128: uint16(20932),
		129: uint16(20933),
		130: uint16(20936),
		131: uint16(20942),
		132: uint16(21089),
		133: uint16(21082),
		134: uint16(21074),
		135: uint16(21086),
		136: uint16(21087),
		137: uint16(21077),
		138: uint16(21090),
		139: uint16(21197),
		140: uint16(21262),
		141: uint16(21406),
		142: uint16(21798),
		143: uint16(21730),
		144: uint16(21783),
		145: uint16(21778),
		146: uint16(21735),
		147: uint16(21747),
		148: uint16(21732),
		149: uint16(21786),
		150: uint16(21759),
		151: uint16(21764),
		152: uint16(21768),
		153: uint16(21739),
		154: uint16(21777),
		155: uint16(21765),
		156: uint16(21745),
	},
	48: {
		0:   uint16(21770),
		1:   uint16(21755),
		2:   uint16(21751),
		3:   uint16(21752),
		4:   uint16(21728),
		5:   uint16(21774),
		6:   uint16(21763),
		7:   uint16(21771),
		8:   uint16(22273),
		9:   uint16(22274),
		10:  uint16(22476),
		11:  uint16(22578),
		12:  uint16(22485),
		13:  uint16(22482),
		14:  uint16(22458),
		15:  uint16(22470),
		16:  uint16(22461),
		17:  uint16(22460),
		18:  uint16(22456),
		19:  uint16(22454),
		20:  uint16(22463),
		21:  uint16(22471),
		22:  uint16(22480),
		23:  uint16(22457),
		24:  uint16(22465),
		25:  uint16(22798),
		26:  uint16(22858),
		27:  uint16(23065),
		28:  uint16(23062),
		29:  uint16(23085),
		30:  uint16(23086),
		31:  uint16(23061),
		32:  uint16(23055),
		33:  uint16(23063),
		34:  uint16(23050),
		35:  uint16(23070),
		36:  uint16(23091),
		37:  uint16(23404),
		38:  uint16(23463),
		39:  uint16(23469),
		40:  uint16(23468),
		41:  uint16(23555),
		42:  uint16(23638),
		43:  uint16(23636),
		44:  uint16(23788),
		45:  uint16(23807),
		46:  uint16(23790),
		47:  uint16(23793),
		48:  uint16(23799),
		49:  uint16(23808),
		50:  uint16(23801),
		51:  uint16(24105),
		52:  uint16(24104),
		53:  uint16(24232),
		54:  uint16(24238),
		55:  uint16(24234),
		56:  uint16(24236),
		57:  uint16(24371),
		58:  uint16(24368),
		59:  uint16(24423),
		60:  uint16(24669),
		61:  uint16(24666),
		62:  uint16(24679),
		63:  uint16(24641),
		64:  uint16(24738),
		65:  uint16(24712),
		66:  uint16(24704),
		67:  uint16(24722),
		68:  uint16(24705),
		69:  uint16(24733),
		70:  uint16(24707),
		71:  uint16(24725),
		72:  uint16(24731),
		73:  uint16(24727),
		74:  uint16(24711),
		75:  uint16(24732),
		76:  uint16(24718),
		77:  uint16(25113),
		78:  uint16(25158),
		79:  uint16(25330),
		80:  uint16(25360),
		81:  uint16(25430),
		82:  uint16(25388),
		83:  uint16(25412),
		84:  uint16(25413),
		85:  uint16(25398),
		86:  uint16(25411),
		87:  uint16(25572),
		88:  uint16(25401),
		89:  uint16(25419),
		90:  uint16(25418),
		91:  uint16(25404),
		92:  uint16(25385),
		93:  uint16(25409),
		94:  uint16(25396),
		95:  uint16(25432),
		96:  uint16(25428),
		97:  uint16(25433),
		98:  uint16(25389),
		99:  uint16(25415),
		100: uint16(25395),
		101: uint16(25434),
		102: uint16(25425),
		103: uint16(25400),
		104: uint16(25431),
		105: uint16(25408),
		106: uint16(25416),
		107: uint16(25930),
		108: uint16(25926),
		109: uint16(26054),
		110: uint16(26051),
		111: uint16(26052),
		112: uint16(26050),
		113: uint16(26186),
		114: uint16(26207),
		115: uint16(26183),
		116: uint16(26193),
		117: uint16(26386),
		118: uint16(26387),
		119: uint16(26655),
		120: uint16(26650),
		121: uint16(26697),
		122: uint16(26674),
		123: uint16(26675),
		124: uint16(26683),
		125: uint16(26699),
		126: uint16(26703),
		127: uint16(26646),
		128: uint16(26673),
		129: uint16(26652),
		130: uint16(26677),
		131: uint16(26667),
		132: uint16(26669),
		133: uint16(26671),
		134: uint16(26702),
		135: uint16(26692),
		136: uint16(26676),
		137: uint16(26653),
		138: uint16(26642),
		139: uint16(26644),
		140: uint16(26662),
		141: uint16(26664),
		142: uint16(26670),
		143: uint16(26701),
		144: uint16(26682),
		145: uint16(26661),
		146: uint16(26656),
		147: uint16(27436),
		148: uint16(27439),
		149: uint16(27437),
		150: uint16(27441),
		151: uint16(27444),
		152: uint16(27501),
		153: uint16(32898),
		154: uint16(27528),
		155: uint16(27622),
		156: uint16(27620),
	},
	49: {
		0:   uint16(27624),
		1:   uint16(27619),
		2:   uint16(27618),
		3:   uint16(27623),
		4:   uint16(27685),
		5:   uint16(28026),
		6:   uint16(28003),
		7:   uint16(28004),
		8:   uint16(28022),
		9:   uint16(27917),
		10:  uint16(28001),
		11:  uint16(28050),
		12:  uint16(27992),
		13:  uint16(28002),
		14:  uint16(28013),
		15:  uint16(28015),
		16:  uint16(28049),
		17:  uint16(28045),
		18:  uint16(28143),
		19:  uint16(28031),
		20:  uint16(28038),
		21:  uint16(27998),
		22:  uint16(28007),
		23:  uint16(28000),
		24:  uint16(28055),
		25:  uint16(28016),
		26:  uint16(28028),
		27:  uint16(27999),
		28:  uint16(28034),
		29:  uint16(28056),
		30:  uint16(27951),
		31:  uint16(28008),
		32:  uint16(28043),
		33:  uint16(28030),
		34:  uint16(28032),
		35:  uint16(28036),
		36:  uint16(27926),
		37:  uint16(28035),
		38:  uint16(28027),
		39:  uint16(28029),
		40:  uint16(28021),
		41:  uint16(28048),
		42:  uint16(28892),
		43:  uint16(28883),
		44:  uint16(28881),
		45:  uint16(28893),
		46:  uint16(28875),
		47:  uint16(32569),
		48:  uint16(28898),
		49:  uint16(28887),
		50:  uint16(28882),
		51:  uint16(28894),
		52:  uint16(28896),
		53:  uint16(28884),
		54:  uint16(28877),
		55:  uint16(28869),
		56:  uint16(28870),
		57:  uint16(28871),
		58:  uint16(28890),
		59:  uint16(28878),
		60:  uint16(28897),
		61:  uint16(29250),
		62:  uint16(29304),
		63:  uint16(29303),
		64:  uint16(29302),
		65:  uint16(29440),
		66:  uint16(29434),
		67:  uint16(29428),
		68:  uint16(29438),
		69:  uint16(29430),
		70:  uint16(29427),
		71:  uint16(29435),
		72:  uint16(29441),
		73:  uint16(29651),
		74:  uint16(29657),
		75:  uint16(29669),
		76:  uint16(29654),
		77:  uint16(29628),
		78:  uint16(29671),
		79:  uint16(29667),
		80:  uint16(29673),
		81:  uint16(29660),
		82:  uint16(29650),
		83:  uint16(29659),
		84:  uint16(29652),
		85:  uint16(29661),
		86:  uint16(29658),
		87:  uint16(29655),
		88:  uint16(29656),
		89:  uint16(29672),
		90:  uint16(29918),
		91:  uint16(29919),
		92:  uint16(29940),
		93:  uint16(29941),
		94:  uint16(29985),
		95:  uint16(30043),
		96:  uint16(30047),
		97:  uint16(30128),
		98:  uint16(30145),
		99:  uint16(30139),
		100: uint16(30148),
		101: uint16(30144),
		102: uint16(30143),
		103: uint16(30134),
		104: uint16(30138),
		105: uint16(30346),
		106: uint16(30409),
		107: uint16(30493),
		108: uint16(30491),
		109: uint16(30480),
		110: uint16(30483),
		111: uint16(30482),
		112: uint16(30499),
		113: uint16(30481),
		114: uint16(30485),
		115: uint16(30489),
		116: uint16(30490),
		117: uint16(30498),
		118: uint16(30503),
		119: uint16(30755),
		120: uint16(30764),
		121: uint16(30754),
		122: uint16(30773),
		123: uint16(30767),
		124: uint16(30760),
		125: uint16(30766),
		126: uint16(30763),
		127: uint16(30753),
		128: uint16(30761),
		129: uint16(30771),
		130: uint16(30762),
		131: uint16(30769),
		132: uint16(31060),
		133: uint16(31067),
		134: uint16(31055),
		135: uint16(31068),
		136: uint16(31059),
		137: uint16(31058),
		138: uint16(31057),
		139: uint16(31211),
		140: uint16(31212),
		141: uint16(31200),
		142: uint16(31214),
		143: uint16(31213),
		144: uint16(31210),
		145: uint16(31196),
		146: uint16(31198),
		147: uint16(31197),
		148: uint16(31366),
		149: uint16(31369),
		150: uint16(31365),
		151: uint16(31371),
		152: uint16(31372),
		153: uint16(31370),
		154: uint16(31367),
		155: uint16(31448),
		156: uint16(31504),
	},
	50: {
		0:   uint16(31492),
		1:   uint16(31507),
		2:   uint16(31493),
		3:   uint16(31503),
		4:   uint16(31496),
		5:   uint16(31498),
		6:   uint16(31502),
		7:   uint16(31497),
		8:   uint16(31506),
		9:   uint16(31876),
		10:  uint16(31889),
		11:  uint16(31882),
		12:  uint16(31884),
		13:  uint16(31880),
		14:  uint16(31885),
		15:  uint16(31877),
		16:  uint16(32030),
		17:  uint16(32029),
		18:  uint16(32017),
		19:  uint16(32014),
		20:  uint16(32024),
		21:  uint16(32022),
		22:  uint16(32019),
		23:  uint16(32031),
		24:  uint16(32018),
		25:  uint16(32015),
		26:  uint16(32012),
		27:  uint16(32604),
		28:  uint16(32609),
		29:  uint16(32606),
		30:  uint16(32608),
		31:  uint16(32605),
		32:  uint16(32603),
		33:  uint16(32662),
		34:  uint16(32658),
		35:  uint16(32707),
		36:  uint16(32706),
		37:  uint16(32704),
		38:  uint16(32790),
		39:  uint16(32830),
		40:  uint16(32825),
		41:  uint16(33018),
		42:  uint16(33010),
		43:  uint16(33017),
		44:  uint16(33013),
		45:  uint16(33025),
		46:  uint16(33019),
		47:  uint16(33024),
		48:  uint16(33281),
		49:  uint16(33327),
		50:  uint16(33317),
		51:  uint16(33587),
		52:  uint16(33581),
		53:  uint16(33604),
		54:  uint16(33561),
		55:  uint16(33617),
		56:  uint16(33573),
		57:  uint16(33622),
		58:  uint16(33599),
		59:  uint16(33601),
		60:  uint16(33574),
		61:  uint16(33564),
		62:  uint16(33570),
		63:  uint16(33602),
		64:  uint16(33614),
		65:  uint16(33563),
		66:  uint16(33578),
		67:  uint16(33544),
		68:  uint16(33596),
		69:  uint16(33613),
		70:  uint16(33558),
		71:  uint16(33572),
		72:  uint16(33568),
		73:  uint16(33591),
		74:  uint16(33583),
		75:  uint16(33577),
		76:  uint16(33607),
		77:  uint16(33605),
		78:  uint16(33612),
		79:  uint16(33619),
		80:  uint16(33566),
		81:  uint16(33580),
		82:  uint16(33611),
		83:  uint16(33575),
		84:  uint16(33608),
		85:  uint16(34387),
		86:  uint16(34386),
		87:  uint16(34466),
		88:  uint16(34472),
		89:  uint16(34454),
		90:  uint16(34445),
		91:  uint16(34449),
		92:  uint16(34462),
		93:  uint16(34439),
		94:  uint16(34455),
		95:  uint16(34438),
		96:  uint16(34443),
		97:  uint16(34458),
		98:  uint16(34437),
		99:  uint16(34469),
		100: uint16(34457),
		101: uint16(34465),
		102: uint16(34471),
		103: uint16(34453),
		104: uint16(34456),
		105: uint16(34446),
		106: uint16(34461),
		107: uint16(34448),
		108: uint16(34452),
		109: uint16(34883),
		110: uint16(34884),
		111: uint16(34925),
		112: uint16(34933),
		113: uint16(34934),
		114: uint16(34930),
		115: uint16(34944),
		116: uint16(34929),
		117: uint16(34943),
		118: uint16(34927),
		119: uint16(34947),
		120: uint16(34942),
		121: uint16(34932),
		122: uint16(34940),
		123: uint16(35346),
		124: uint16(35911),
		125: uint16(35927),
		126: uint16(35963),
		127: uint16(36004),
		128: uint16(36003),
		129: uint16(36214),
		130: uint16(36216),
		131: uint16(36277),
		132: uint16(36279),
		133: uint16(36278),
		134: uint16(36561),
		135: uint16(36563),
		136: uint16(36862),
		137: uint16(36853),
		138: uint16(36866),
		139: uint16(36863),
		140: uint16(36859),
		141: uint16(36868),
		142: uint16(36860),
		143: uint16(36854),
		144: uint16(37078),
		145: uint16(37088),
		146: uint16(37081),
		147: uint16(37082),
		148: uint16(37091),
		149: uint16(37087),
		150: uint16(37093),
		151: uint16(37080),
		152: uint16(37083),
		153: uint16(37079),
		154: uint16(37084),
		155: uint16(37092),
		156: uint16(37200),
	},
	51: {
		0:   uint16(37198),
		1:   uint16(37199),
		2:   uint16(37333),
		3:   uint16(37346),
		4:   uint16(37338),
		5:   uint16(38492),
		6:   uint16(38495),
		7:   uint16(38588),
		8:   uint16(39139),
		9:   uint16(39647),
		10:  uint16(39727),
		11:  uint16(20095),
		12:  uint16(20592),
		13:  uint16(20586),
		14:  uint16(20577),
		15:  uint16(20574),
		16:  uint16(20576),
		17:  uint16(20563),
		18:  uint16(20555),
		19:  uint16(20573),
		20:  uint16(20594),
		21:  uint16(20552),
		22:  uint16(20557),
		23:  uint16(20545),
		24:  uint16(20571),
		25:  uint16(20554),
		26:  uint16(20578),
		27:  uint16(20501),
		28:  uint16(20549),
		29:  uint16(20575),
		30:  uint16(20585),
		31:  uint16(20587),
		32:  uint16(20579),
		33:  uint16(20580),
		34:  uint16(20550),
		35:  uint16(20544),
		36:  uint16(20590),
		37:  uint16(20595),
		38:  uint16(20567),
		39:  uint16(20561),
		40:  uint16(20944),
		41:  uint16(21099),
		42:  uint16(21101),
		43:  uint16(21100),
		44:  uint16(21102),
		45:  uint16(21206),
		46:  uint16(21203),
		47:  uint16(21293),
		48:  uint16(21404),
		49:  uint16(21877),
		50:  uint16(21878),
		51:  uint16(21820),
		52:  uint16(21837),
		53:  uint16(21840),
		54:  uint16(21812),
		55:  uint16(21802),
		56:  uint16(21841),
		57:  uint16(21858),
		58:  uint16(21814),
		59:  uint16(21813),
		60:  uint16(21808),
		61:  uint16(21842),
		62:  uint16(21829),
		63:  uint16(21772),
		64:  uint16(21810),
		65:  uint16(21861),
		66:  uint16(21838),
		67:  uint16(21817),
		68:  uint16(21832),
		69:  uint16(21805),
		70:  uint16(21819),
		71:  uint16(21824),
		72:  uint16(21835),
		73:  uint16(22282),
		74:  uint16(22279),
		75:  uint16(22523),
		76:  uint16(22548),
		77:  uint16(22498),
		78:  uint16(22518),
		79:  uint16(22492),
		80:  uint16(22516),
		81:  uint16(22528),
		82:  uint16(22509),
		83:  uint16(22525),
		84:  uint16(22536),
		85:  uint16(22520),
		86:  uint16(22539),
		87:  uint16(22515),
		88:  uint16(22479),
		89:  uint16(22535),
		90:  uint16(22510),
		91:  uint16(22499),
		92:  uint16(22514),
		93:  uint16(22501),
		94:  uint16(22508),
		95:  uint16(22497),
		96:  uint16(22542),
		97:  uint16(22524),
		98:  uint16(22544),
		99:  uint16(22503),
		100: uint16(22529),
		101: uint16(22540),
		102: uint16(22513),
		103: uint16(22505),
		104: uint16(22512),
		105: uint16(22541),
		106: uint16(22532),
		107: uint16(22876),
		108: uint16(23136),
		109: uint16(23128),
		110: uint16(23125),
		111: uint16(23143),
		112: uint16(23134),
		113: uint16(23096),
		114: uint16(23093),
		115: uint16(23149),
		116: uint16(23120),
		117: uint16(23135),
		118: uint16(23141),
		119: uint16(23148),
		120: uint16(23123),
		121: uint16(23140),
		122: uint16(23127),
		123: uint16(23107),
		124: uint16(23133),
		125: uint16(23122),
		126: uint16(23108),
		127: uint16(23131),
		128: uint16(23112),
		129: uint16(23182),
		130: uint16(23102),
		131: uint16(23117),
		132: uint16(23097),
		133: uint16(23116),
		134: uint16(23152),
		135: uint16(23145),
		136: uint16(23111),
		137: uint16(23121),
		138: uint16(23126),
		139: uint16(23106),
		140: uint16(23132),
		141: uint16(23410),
		142: uint16(23406),
		143: uint16(23489),
		144: uint16(23488),
		145: uint16(23641),
		146: uint16(23838),
		147: uint16(23819),
		148: uint16(23837),
		149: uint16(23834),
		150: uint16(23840),
		151: uint16(23820),
		152: uint16(23848),
		153: uint16(23821),
		154: uint16(23846),
		155: uint16(23845),
		156: uint16(23823),
	},
	52: {
		0:   uint16(23856),
		1:   uint16(23826),
		2:   uint16(23843),
		3:   uint16(23839),
		4:   uint16(23854),
		5:   uint16(24126),
		6:   uint16(24116),
		7:   uint16(24241),
		8:   uint16(24244),
		9:   uint16(24249),
		10:  uint16(24242),
		11:  uint16(24243),
		12:  uint16(24374),
		13:  uint16(24376),
		14:  uint16(24475),
		15:  uint16(24470),
		16:  uint16(24479),
		17:  uint16(24714),
		18:  uint16(24720),
		19:  uint16(24710),
		20:  uint16(24766),
		21:  uint16(24752),
		22:  uint16(24762),
		23:  uint16(24787),
		24:  uint16(24788),
		25:  uint16(24783),
		26:  uint16(24804),
		27:  uint16(24793),
		28:  uint16(24797),
		29:  uint16(24776),
		30:  uint16(24753),
		31:  uint16(24795),
		32:  uint16(24759),
		33:  uint16(24778),
		34:  uint16(24767),
		35:  uint16(24771),
		36:  uint16(24781),
		37:  uint16(24768),
		38:  uint16(25394),
		39:  uint16(25445),
		40:  uint16(25482),
		41:  uint16(25474),
		42:  uint16(25469),
		43:  uint16(25533),
		44:  uint16(25502),
		45:  uint16(25517),
		46:  uint16(25501),
		47:  uint16(25495),
		48:  uint16(25515),
		49:  uint16(25486),
		50:  uint16(25455),
		51:  uint16(25479),
		52:  uint16(25488),
		53:  uint16(25454),
		54:  uint16(25519),
		55:  uint16(25461),
		56:  uint16(25500),
		57:  uint16(25453),
		58:  uint16(25518),
		59:  uint16(25468),
		60:  uint16(25508),
		61:  uint16(25403),
		62:  uint16(25503),
		63:  uint16(25464),
		64:  uint16(25477),
		65:  uint16(25473),
		66:  uint16(25489),
		67:  uint16(25485),
		68:  uint16(25456),
		69:  uint16(25939),
		70:  uint16(26061),
		71:  uint16(26213),
		72:  uint16(26209),
		73:  uint16(26203),
		74:  uint16(26201),
		75:  uint16(26204),
		76:  uint16(26210),
		77:  uint16(26392),
		78:  uint16(26745),
		79:  uint16(26759),
		80:  uint16(26768),
		81:  uint16(26780),
		82:  uint16(26733),
		83:  uint16(26734),
		84:  uint16(26798),
		85:  uint16(26795),
		86:  uint16(26966),
		87:  uint16(26735),
		88:  uint16(26787),
		89:  uint16(26796),
		90:  uint16(26793),
		91:  uint16(26741),
		92:  uint16(26740),
		93:  uint16(26802),
		94:  uint16(26767),
		95:  uint16(26743),
		96:  uint16(26770),
		97:  uint16(26748),
		98:  uint16(26731),
		99:  uint16(26738),
		100: uint16(26794),
		101: uint16(26752),
		102: uint16(26737),
		103: uint16(26750),
		104: uint16(26779),
		105: uint16(26774),
		106: uint16(26763),
		107: uint16(26784),
		108: uint16(26761),
		109: uint16(26788),
		110: uint16(26744),
		111: uint16(26747),
		112: uint16(26769),
		113: uint16(26764),
		114: uint16(26762),
		115: uint16(26749),
		116: uint16(27446),
		117: uint16(27443),
		118: uint16(27447),
		119: uint16(27448),
		120: uint16(27537),
		121: uint16(27535),
		122: uint16(27533),
		123: uint16(27534),
		124: uint16(27532),
		125: uint16(27690),
		126: uint16(28096),
		127: uint16(28075),
		128: uint16(28084),
		129: uint16(28083),
		130: uint16(28276),
		131: uint16(28076),
		132: uint16(28137),
		133: uint16(28130),
		134: uint16(28087),
		135: uint16(28150),
		136: uint16(28116),
		137: uint16(28160),
		138: uint16(28104),
		139: uint16(28128),
		140: uint16(28127),
		141: uint16(28118),
		142: uint16(28094),
		143: uint16(28133),
		144: uint16(28124),
		145: uint16(28125),
		146: uint16(28123),
		147: uint16(28148),
		148: uint16(28106),
		149: uint16(28093),
		150: uint16(28141),
		151: uint16(28144),
		152: uint16(28090),
		153: uint16(28117),
		154: uint16(28098),
		155: uint16(28111),
		156: uint16(28105),
	},
	53: {
		0:   uint16(28112),
		1:   uint16(28146),
		2:   uint16(28115),
		3:   uint16(28157),
		4:   uint16(28119),
		5:   uint16(28109),
		6:   uint16(28131),
		7:   uint16(28091),
		8:   uint16(28922),
		9:   uint16(28941),
		10:  uint16(28919),
		11:  uint16(28951),
		12:  uint16(28916),
		13:  uint16(28940),
		14:  uint16(28912),
		15:  uint16(28932),
		16:  uint16(28915),
		17:  uint16(28944),
		18:  uint16(28924),
		19:  uint16(28927),
		20:  uint16(28934),
		21:  uint16(28947),
		22:  uint16(28928),
		23:  uint16(28920),
		24:  uint16(28918),
		25:  uint16(28939),
		26:  uint16(28930),
		27:  uint16(28942),
		28:  uint16(29310),
		29:  uint16(29307),
		30:  uint16(29308),
		31:  uint16(29311),
		32:  uint16(29469),
		33:  uint16(29463),
		34:  uint16(29447),
		35:  uint16(29457),
		36:  uint16(29464),
		37:  uint16(29450),
		38:  uint16(29448),
		39:  uint16(29439),
		40:  uint16(29455),
		41:  uint16(29470),
		42:  uint16(29576),
		43:  uint16(29686),
		44:  uint16(29688),
		45:  uint16(29685),
		46:  uint16(29700),
		47:  uint16(29697),
		48:  uint16(29693),
		49:  uint16(29703),
		50:  uint16(29696),
		51:  uint16(29690),
		52:  uint16(29692),
		53:  uint16(29695),
		54:  uint16(29708),
		55:  uint16(29707),
		56:  uint16(29684),
		57:  uint16(29704),
		58:  uint16(30052),
		59:  uint16(30051),
		60:  uint16(30158),
		61:  uint16(30162),
		62:  uint16(30159),
		63:  uint16(30155),
		64:  uint16(30156),
		65:  uint16(30161),
		66:  uint16(30160),
		67:  uint16(30351),
		68:  uint16(30345),
		69:  uint16(30419),
		70:  uint16(30521),
		71:  uint16(30511),
		72:  uint16(30509),
		73:  uint16(30513),
		74:  uint16(30514),
		75:  uint16(30516),
		76:  uint16(30515),
		77:  uint16(30525),
		78:  uint16(30501),
		79:  uint16(30523),
		80:  uint16(30517),
		81:  uint16(30792),
		82:  uint16(30802),
		83:  uint16(30793),
		84:  uint16(30797),
		85:  uint16(30794),
		86:  uint16(30796),
		87:  uint16(30758),
		88:  uint16(30789),
		89:  uint16(30800),
		90:  uint16(31076),
		91:  uint16(31079),
		92:  uint16(31081),
		93:  uint16(31082),
		94:  uint16(31075),
		95:  uint16(31083),
		96:  uint16(31073),
		97:  uint16(31163),
		98:  uint16(31226),
		99:  uint16(31224),
		100: uint16(31222),
		101: uint16(31223),
		102: uint16(31375),
		103: uint16(31380),
		104: uint16(31376),
		105: uint16(31541),
		106: uint16(31559),
		107: uint16(31540),
		108: uint16(31525),
		109: uint16(31536),
		110: uint16(31522),
		111: uint16(31524),
		112: uint16(31539),
		113: uint16(31512),
		114: uint16(31530),
		115: uint16(31517),
		116: uint16(31537),
		117: uint16(31531),
		118: uint16(31533),
		119: uint16(31535),
		120: uint16(31538),
		121: uint16(31544),
		122: uint16(31514),
		123: uint16(31523),
		124: uint16(31892),
		125: uint16(31896),
		126: uint16(31894),
		127: uint16(31907),
		128: uint16(32053),
		129: uint16(32061),
		130: uint16(32056),
		131: uint16(32054),
		132: uint16(32058),
		133: uint16(32069),
		134: uint16(32044),
		135: uint16(32041),
		136: uint16(32065),
		137: uint16(32071),
		138: uint16(32062),
		139: uint16(32063),
		140: uint16(32074),
		141: uint16(32059),
		142: uint16(32040),
		143: uint16(32611),
		144: uint16(32661),
		145: uint16(32668),
		146: uint16(32669),
		147: uint16(32667),
		148: uint16(32714),
		149: uint16(32715),
		150: uint16(32717),
		151: uint16(32720),
		152: uint16(32721),
		153: uint16(32711),
		154: uint16(32719),
		155: uint16(32713),
		156: uint16(32799),
	},
	54: {
		0:   uint16(32798),
		1:   uint16(32795),
		2:   uint16(32839),
		3:   uint16(32835),
		4:   uint16(32840),
		5:   uint16(33048),
		6:   uint16(33061),
		7:   uint16(33049),
		8:   uint16(33051),
		9:   uint16(33069),
		10:  uint16(33055),
		11:  uint16(33068),
		12:  uint16(33054),
		13:  uint16(33057),
		14:  uint16(33045),
		15:  uint16(33063),
		16:  uint16(33053),
		17:  uint16(33058),
		18:  uint16(33297),
		19:  uint16(33336),
		20:  uint16(33331),
		21:  uint16(33338),
		22:  uint16(33332),
		23:  uint16(33330),
		24:  uint16(33396),
		25:  uint16(33680),
		26:  uint16(33699),
		27:  uint16(33704),
		28:  uint16(33677),
		29:  uint16(33658),
		30:  uint16(33651),
		31:  uint16(33700),
		32:  uint16(33652),
		33:  uint16(33679),
		34:  uint16(33665),
		35:  uint16(33685),
		36:  uint16(33689),
		37:  uint16(33653),
		38:  uint16(33684),
		39:  uint16(33705),
		40:  uint16(33661),
		41:  uint16(33667),
		42:  uint16(33676),
		43:  uint16(33693),
		44:  uint16(33691),
		45:  uint16(33706),
		46:  uint16(33675),
		47:  uint16(33662),
		48:  uint16(33701),
		49:  uint16(33711),
		50:  uint16(33672),
		51:  uint16(33687),
		52:  uint16(33712),
		53:  uint16(33663),
		54:  uint16(33702),
		55:  uint16(33671),
		56:  uint16(33710),
		57:  uint16(33654),
		58:  uint16(33690),
		59:  uint16(34393),
		60:  uint16(34390),
		61:  uint16(34495),
		62:  uint16(34487),
		63:  uint16(34498),
		64:  uint16(34497),
		65:  uint16(34501),
		66:  uint16(34490),
		67:  uint16(34480),
		68:  uint16(34504),
		69:  uint16(34489),
		70:  uint16(34483),
		71:  uint16(34488),
		72:  uint16(34508),
		73:  uint16(34484),
		74:  uint16(34491),
		75:  uint16(34492),
		76:  uint16(34499),
		77:  uint16(34493),
		78:  uint16(34494),
		79:  uint16(34898),
		80:  uint16(34953),
		81:  uint16(34965),
		82:  uint16(34984),
		83:  uint16(34978),
		84:  uint16(34986),
		85:  uint16(34970),
		86:  uint16(34961),
		87:  uint16(34977),
		88:  uint16(34975),
		89:  uint16(34968),
		90:  uint16(34983),
		91:  uint16(34969),
		92:  uint16(34971),
		93:  uint16(34967),
		94:  uint16(34980),
		95:  uint16(34988),
		96:  uint16(34956),
		97:  uint16(34963),
		98:  uint16(34958),
		99:  uint16(35202),
		100: uint16(35286),
		101: uint16(35289),
		102: uint16(35285),
		103: uint16(35376),
		104: uint16(35367),
		105: uint16(35372),
		106: uint16(35358),
		107: uint16(35897),
		108: uint16(35899),
		109: uint16(35932),
		110: uint16(35933),
		111: uint16(35965),
		112: uint16(36005),
		113: uint16(36221),
		114: uint16(36219),
		115: uint16(36217),
		116: uint16(36284),
		117: uint16(36290),
		118: uint16(36281),
		119: uint16(36287),
		120: uint16(36289),
		121: uint16(36568),
		122: uint16(36574),
		123: uint16(36573),
		124: uint16(36572),
		125: uint16(36567),
		126: uint16(36576),
		127: uint16(36577),
		128: uint16(36900),
		129: uint16(36875),
		130: uint16(36881),
		131: uint16(36892),
		132: uint16(36876),
		133: uint16(36897),
		134: uint16(37103),
		135: uint16(37098),
		136: uint16(37104),
		137: uint16(37108),
		138: uint16(37106),
		139: uint16(37107),
		140: uint16(37076),
		141: uint16(37099),
		142: uint16(37100),
		143: uint16(37097),
		144: uint16(37206),
		145: uint16(37208),
		146: uint16(37210),
		147: uint16(37203),
		148: uint16(37205),
		149: uint16(37356),
		150: uint16(37364),
		151: uint16(37361),
		152: uint16(37363),
		153: uint16(37368),
		154: uint16(37348),
		155: uint16(37369),
		156: uint16(37354),
	},
	55: {
		0:   uint16(37355),
		1:   uint16(37367),
		2:   uint16(37352),
		3:   uint16(37358),
		4:   uint16(38266),
		5:   uint16(38278),
		6:   uint16(38280),
		7:   uint16(38524),
		8:   uint16(38509),
		9:   uint16(38507),
		10:  uint16(38513),
		11:  uint16(38511),
		12:  uint16(38591),
		13:  uint16(38762),
		14:  uint16(38916),
		15:  uint16(39141),
		16:  uint16(39319),
		17:  uint16(20635),
		18:  uint16(20629),
		19:  uint16(20628),
		20:  uint16(20638),
		21:  uint16(20619),
		22:  uint16(20643),
		23:  uint16(20611),
		24:  uint16(20620),
		25:  uint16(20622),
		26:  uint16(20637),
		27:  uint16(20584),
		28:  uint16(20636),
		29:  uint16(20626),
		30:  uint16(20610),
		31:  uint16(20615),
		32:  uint16(20831),
		33:  uint16(20948),
		34:  uint16(21266),
		35:  uint16(21265),
		36:  uint16(21412),
		37:  uint16(21415),
		38:  uint16(21905),
		39:  uint16(21928),
		40:  uint16(21925),
		41:  uint16(21933),
		42:  uint16(21879),
		43:  uint16(22085),
		44:  uint16(21922),
		45:  uint16(21907),
		46:  uint16(21896),
		47:  uint16(21903),
		48:  uint16(21941),
		49:  uint16(21889),
		50:  uint16(21923),
		51:  uint16(21906),
		52:  uint16(21924),
		53:  uint16(21885),
		54:  uint16(21900),
		55:  uint16(21926),
		56:  uint16(21887),
		57:  uint16(21909),
		58:  uint16(21921),
		59:  uint16(21902),
		60:  uint16(22284),
		61:  uint16(22569),
		62:  uint16(22583),
		63:  uint16(22553),
		64:  uint16(22558),
		65:  uint16(22567),
		66:  uint16(22563),
		67:  uint16(22568),
		68:  uint16(22517),
		69:  uint16(22600),
		70:  uint16(22565),
		71:  uint16(22556),
		72:  uint16(22555),
		73:  uint16(22579),
		74:  uint16(22591),
		75:  uint16(22582),
		76:  uint16(22574),
		77:  uint16(22585),
		78:  uint16(22584),
		79:  uint16(22573),
		80:  uint16(22572),
		81:  uint16(22587),
		82:  uint16(22881),
		83:  uint16(23215),
		84:  uint16(23188),
		85:  uint16(23199),
		86:  uint16(23162),
		87:  uint16(23202),
		88:  uint16(23198),
		89:  uint16(23160),
		90:  uint16(23206),
		91:  uint16(23164),
		92:  uint16(23205),
		93:  uint16(23212),
		94:  uint16(23189),
		95:  uint16(23214),
		96:  uint16(23095),
		97:  uint16(23172),
		98:  uint16(23178),
		99:  uint16(23191),
		100: uint16(23171),
		101: uint16(23179),
		102: uint16(23209),
		103: uint16(23163),
		104: uint16(23165),
		105: uint16(23180),
		106: uint16(23196),
		107: uint16(23183),
		108: uint16(23187),
		109: uint16(23197),
		110: uint16(23530),
		111: uint16(23501),
		112: uint16(23499),
		113: uint16(23508),
		114: uint16(23505),
		115: uint16(23498),
		116: uint16(23502),
		117: uint16(23564),
		118: uint16(23600),
		119: uint16(23863),
		120: uint16(23875),
		121: uint16(23915),
		122: uint16(23873),
		123: uint16(23883),
		124: uint16(23871),
		125: uint16(23861),
		126: uint16(23889),
		127: uint16(23886),
		128: uint16(23893),
		129: uint16(23859),
		130: uint16(23866),
		131: uint16(23890),
		132: uint16(23869),
		133: uint16(23857),
		134: uint16(23897),
		135: uint16(23874),
		136: uint16(23865),
		137: uint16(23881),
		138: uint16(23864),
		139: uint16(23868),
		140: uint16(23858),
		141: uint16(23862),
		142: uint16(23872),
		143: uint16(23877),
		144: uint16(24132),
		145: uint16(24129),
		146: uint16(24408),
		147: uint16(24486),
		148: uint16(24485),
		149: uint16(24491),
		150: uint16(24777),
		151: uint16(24761),
		152: uint16(24780),
		153: uint16(24802),
		154: uint16(24782),
		155: uint16(24772),
		156: uint16(24852),
	},
	56: {
		0:   uint16(24818),
		1:   uint16(24842),
		2:   uint16(24854),
		3:   uint16(24837),
		4:   uint16(24821),
		5:   uint16(24851),
		6:   uint16(24824),
		7:   uint16(24828),
		8:   uint16(24830),
		9:   uint16(24769),
		10:  uint16(24835),
		11:  uint16(24856),
		12:  uint16(24861),
		13:  uint16(24848),
		14:  uint16(24831),
		15:  uint16(24836),
		16:  uint16(24843),
		17:  uint16(25162),
		18:  uint16(25492),
		19:  uint16(25521),
		20:  uint16(25520),
		21:  uint16(25550),
		22:  uint16(25573),
		23:  uint16(25576),
		24:  uint16(25583),
		25:  uint16(25539),
		26:  uint16(25757),
		27:  uint16(25587),
		28:  uint16(25546),
		29:  uint16(25568),
		30:  uint16(25590),
		31:  uint16(25557),
		32:  uint16(25586),
		33:  uint16(25589),
		34:  uint16(25697),
		35:  uint16(25567),
		36:  uint16(25534),
		37:  uint16(25565),
		38:  uint16(25564),
		39:  uint16(25540),
		40:  uint16(25560),
		41:  uint16(25555),
		42:  uint16(25538),
		43:  uint16(25543),
		44:  uint16(25548),
		45:  uint16(25547),
		46:  uint16(25544),
		47:  uint16(25584),
		48:  uint16(25559),
		49:  uint16(25561),
		50:  uint16(25906),
		51:  uint16(25959),
		52:  uint16(25962),
		53:  uint16(25956),
		54:  uint16(25948),
		55:  uint16(25960),
		56:  uint16(25957),
		57:  uint16(25996),
		58:  uint16(26013),
		59:  uint16(26014),
		60:  uint16(26030),
		61:  uint16(26064),
		62:  uint16(26066),
		63:  uint16(26236),
		64:  uint16(26220),
		65:  uint16(26235),
		66:  uint16(26240),
		67:  uint16(26225),
		68:  uint16(26233),
		69:  uint16(26218),
		70:  uint16(26226),
		71:  uint16(26369),
		72:  uint16(26892),
		73:  uint16(26835),
		74:  uint16(26884),
		75:  uint16(26844),
		76:  uint16(26922),
		77:  uint16(26860),
		78:  uint16(26858),
		79:  uint16(26865),
		80:  uint16(26895),
		81:  uint16(26838),
		82:  uint16(26871),
		83:  uint16(26859),
		84:  uint16(26852),
		85:  uint16(26870),
		86:  uint16(26899),
		87:  uint16(26896),
		88:  uint16(26867),
		89:  uint16(26849),
		90:  uint16(26887),
		91:  uint16(26828),
		92:  uint16(26888),
		93:  uint16(26992),
		94:  uint16(26804),
		95:  uint16(26897),
		96:  uint16(26863),
		97:  uint16(26822),
		98:  uint16(26900),
		99:  uint16(26872),
		100: uint16(26832),
		101: uint16(26877),
		102: uint16(26876),
		103: uint16(26856),
		104: uint16(26891),
		105: uint16(26890),
		106: uint16(26903),
		107: uint16(26830),
		108: uint16(26824),
		109: uint16(26845),
		110: uint16(26846),
		111: uint16(26854),
		112: uint16(26868),
		113: uint16(26833),
		114: uint16(26886),
		115: uint16(26836),
		116: uint16(26857),
		117: uint16(26901),
		118: uint16(26917),
		119: uint16(26823),
		120: uint16(27449),
		121: uint16(27451),
		122: uint16(27455),
		123: uint16(27452),
		124: uint16(27540),
		125: uint16(27543),
		126: uint16(27545),
		127: uint16(27541),
		128: uint16(27581),
		129: uint16(27632),
		130: uint16(27634),
		131: uint16(27635),
		132: uint16(27696),
		133: uint16(28156),
		134: uint16(28230),
		135: uint16(28231),
		136: uint16(28191),
		137: uint16(28233),
		138: uint16(28296),
		139: uint16(28220),
		140: uint16(28221),
		141: uint16(28229),
		142: uint16(28258),
		143: uint16(28203),
		144: uint16(28223),
		145: uint16(28225),
		146: uint16(28253),
		147: uint16(28275),
		148: uint16(28188),
		149: uint16(28211),
		150: uint16(28235),
		151: uint16(28224),
		152: uint16(28241),
		153: uint16(28219),
		154: uint16(28163),
		155: uint16(28206),
		156: uint16(28254),
	},
	57: {
		0:   uint16(28264),
		1:   uint16(28252),
		2:   uint16(28257),
		3:   uint16(28209),
		4:   uint16(28200),
		5:   uint16(28256),
		6:   uint16(28273),
		7:   uint16(28267),
		8:   uint16(28217),
		9:   uint16(28194),
		10:  uint16(28208),
		11:  uint16(28243),
		12:  uint16(28261),
		13:  uint16(28199),
		14:  uint16(28280),
		15:  uint16(28260),
		16:  uint16(28279),
		17:  uint16(28245),
		18:  uint16(28281),
		19:  uint16(28242),
		20:  uint16(28262),
		21:  uint16(28213),
		22:  uint16(28214),
		23:  uint16(28250),
		24:  uint16(28960),
		25:  uint16(28958),
		26:  uint16(28975),
		27:  uint16(28923),
		28:  uint16(28974),
		29:  uint16(28977),
		30:  uint16(28963),
		31:  uint16(28965),
		32:  uint16(28962),
		33:  uint16(28978),
		34:  uint16(28959),
		35:  uint16(28968),
		36:  uint16(28986),
		37:  uint16(28955),
		38:  uint16(29259),
		39:  uint16(29274),
		40:  uint16(29320),
		41:  uint16(29321),
		42:  uint16(29318),
		43:  uint16(29317),
		44:  uint16(29323),
		45:  uint16(29458),
		46:  uint16(29451),
		47:  uint16(29488),
		48:  uint16(29474),
		49:  uint16(29489),
		50:  uint16(29491),
		51:  uint16(29479),
		52:  uint16(29490),
		53:  uint16(29485),
		54:  uint16(29478),
		55:  uint16(29475),
		56:  uint16(29493),
		57:  uint16(29452),
		58:  uint16(29742),
		59:  uint16(29740),
		60:  uint16(29744),
		61:  uint16(29739),
		62:  uint16(29718),
		63:  uint16(29722),
		64:  uint16(29729),
		65:  uint16(29741),
		66:  uint16(29745),
		67:  uint16(29732),
		68:  uint16(29731),
		69:  uint16(29725),
		70:  uint16(29737),
		71:  uint16(29728),
		72:  uint16(29746),
		73:  uint16(29947),
		74:  uint16(29999),
		75:  uint16(30063),
		76:  uint16(30060),
		77:  uint16(30183),
		78:  uint16(30170),
		79:  uint16(30177),
		80:  uint16(30182),
		81:  uint16(30173),
		82:  uint16(30175),
		83:  uint16(30180),
		84:  uint16(30167),
		85:  uint16(30357),
		86:  uint16(30354),
		87:  uint16(30426),
		88:  uint16(30534),
		89:  uint16(30535),
		90:  uint16(30532),
		91:  uint16(30541),
		92:  uint16(30533),
		93:  uint16(30538),
		94:  uint16(30542),
		95:  uint16(30539),
		96:  uint16(30540),
		97:  uint16(30686),
		98:  uint16(30700),
		99:  uint16(30816),
		100: uint16(30820),
		101: uint16(30821),
		102: uint16(30812),
		103: uint16(30829),
		104: uint16(30833),
		105: uint16(30826),
		106: uint16(30830),
		107: uint16(30832),
		108: uint16(30825),
		109: uint16(30824),
		110: uint16(30814),
		111: uint16(30818),
		112: uint16(31092),
		113: uint16(31091),
		114: uint16(31090),
		115: uint16(31088),
		116: uint16(31234),
		117: uint16(31242),
		118: uint16(31235),
		119: uint16(31244),
		120: uint16(31236),
		121: uint16(31385),
		122: uint16(31462),
		123: uint16(31460),
		124: uint16(31562),
		125: uint16(31547),
		126: uint16(31556),
		127: uint16(31560),
		128: uint16(31564),
		129: uint16(31566),
		130: uint16(31552),
		131: uint16(31576),
		132: uint16(31557),
		133: uint16(31906),
		134: uint16(31902),
		135: uint16(31912),
		136: uint16(31905),
		137: uint16(32088),
		138: uint16(32111),
		139: uint16(32099),
		140: uint16(32083),
		141: uint16(32086),
		142: uint16(32103),
		143: uint16(32106),
		144: uint16(32079),
		145: uint16(32109),
		146: uint16(32092),
		147: uint16(32107),
		148: uint16(32082),
		149: uint16(32084),
		150: uint16(32105),
		151: uint16(32081),
		152: uint16(32095),
		153: uint16(32078),
		154: uint16(32574),
		155: uint16(32575),
		156: uint16(32613),
	},
	58: {
		0:   uint16(32614),
		1:   uint16(32674),
		2:   uint16(32672),
		3:   uint16(32673),
		4:   uint16(32727),
		5:   uint16(32849),
		6:   uint16(32847),
		7:   uint16(32848),
		8:   uint16(33022),
		9:   uint16(32980),
		10:  uint16(33091),
		11:  uint16(33098),
		12:  uint16(33106),
		13:  uint16(33103),
		14:  uint16(33095),
		15:  uint16(33085),
		16:  uint16(33101),
		17:  uint16(33082),
		18:  uint16(33254),
		19:  uint16(33262),
		20:  uint16(33271),
		21:  uint16(33272),
		22:  uint16(33273),
		23:  uint16(33284),
		24:  uint16(33340),
		25:  uint16(33341),
		26:  uint16(33343),
		27:  uint16(33397),
		28:  uint16(33595),
		29:  uint16(33743),
		30:  uint16(33785),
		31:  uint16(33827),
		32:  uint16(33728),
		33:  uint16(33768),
		34:  uint16(33810),
		35:  uint16(33767),
		36:  uint16(33764),
		37:  uint16(33788),
		38:  uint16(33782),
		39:  uint16(33808),
		40:  uint16(33734),
		41:  uint16(33736),
		42:  uint16(33771),
		43:  uint16(33763),
		44:  uint16(33727),
		45:  uint16(33793),
		46:  uint16(33757),
		47:  uint16(33765),
		48:  uint16(33752),
		49:  uint16(33791),
		50:  uint16(33761),
		51:  uint16(33739),
		52:  uint16(33742),
		53:  uint16(33750),
		54:  uint16(33781),
		55:  uint16(33737),
		56:  uint16(33801),
		57:  uint16(33807),
		58:  uint16(33758),
		59:  uint16(33809),
		60:  uint16(33798),
		61:  uint16(33730),
		62:  uint16(33779),
		63:  uint16(33749),
		64:  uint16(33786),
		65:  uint16(33735),
		66:  uint16(33745),
		67:  uint16(33770),
		68:  uint16(33811),
		69:  uint16(33731),
		70:  uint16(33772),
		71:  uint16(33774),
		72:  uint16(33732),
		73:  uint16(33787),
		74:  uint16(33751),
		75:  uint16(33762),
		76:  uint16(33819),
		77:  uint16(33755),
		78:  uint16(33790),
		79:  uint16(34520),
		80:  uint16(34530),
		81:  uint16(34534),
		82:  uint16(34515),
		83:  uint16(34531),
		84:  uint16(34522),
		85:  uint16(34538),
		86:  uint16(34525),
		87:  uint16(34539),
		88:  uint16(34524),
		89:  uint16(34540),
		90:  uint16(34537),
		91:  uint16(34519),
		92:  uint16(34536),
		93:  uint16(34513),
		94:  uint16(34888),
		95:  uint16(34902),
		96:  uint16(34901),
		97:  uint16(35002),
		98:  uint16(35031),
		99:  uint16(35001),
		100: uint16(35000),
		101: uint16(35008),
		102: uint16(35006),
		103: uint16(34998),
		104: uint16(35004),
		105: uint16(34999),
		106: uint16(35005),
		107: uint16(34994),
		108: uint16(35073),
		109: uint16(35017),
		110: uint16(35221),
		111: uint16(35224),
		112: uint16(35223),
		113: uint16(35293),
		114: uint16(35290),
		115: uint16(35291),
		116: uint16(35406),
		117: uint16(35405),
		118: uint16(35385),
		119: uint16(35417),
		120: uint16(35392),
		121: uint16(35415),
		122: uint16(35416),
		123: uint16(35396),
		124: uint16(35397),
		125: uint16(35410),
		126: uint16(35400),
		127: uint16(35409),
		128: uint16(35402),
		129: uint16(35404),
		130: uint16(35407),
		131: uint16(35935),
		132: uint16(35969),
		133: uint16(35968),
		134: uint16(36026),
		135: uint16(36030),
		136: uint16(36016),
		137: uint16(36025),
		138: uint16(36021),
		139: uint16(36228),
		140: uint16(36224),
		141: uint16(36233),
		142: uint16(36312),
		143: uint16(36307),
		144: uint16(36301),
		145: uint16(36295),
		146: uint16(36310),
		147: uint16(36316),
		148: uint16(36303),
		149: uint16(36309),
		150: uint16(36313),
		151: uint16(36296),
		152: uint16(36311),
		153: uint16(36293),
		154: uint16(36591),
		155: uint16(36599),
		156: uint16(36602),
	},
	59: {
		0:   uint16(36601),
		1:   uint16(36582),
		2:   uint16(36590),
		3:   uint16(36581),
		4:   uint16(36597),
		5:   uint16(36583),
		6:   uint16(36584),
		7:   uint16(36598),
		8:   uint16(36587),
		9:   uint16(36593),
		10:  uint16(36588),
		11:  uint16(36596),
		12:  uint16(36585),
		13:  uint16(36909),
		14:  uint16(36916),
		15:  uint16(36911),
		16:  uint16(37126),
		17:  uint16(37164),
		18:  uint16(37124),
		19:  uint16(37119),
		20:  uint16(37116),
		21:  uint16(37128),
		22:  uint16(37113),
		23:  uint16(37115),
		24:  uint16(37121),
		25:  uint16(37120),
		26:  uint16(37127),
		27:  uint16(37125),
		28:  uint16(37123),
		29:  uint16(37217),
		30:  uint16(37220),
		31:  uint16(37215),
		32:  uint16(37218),
		33:  uint16(37216),
		34:  uint16(37377),
		35:  uint16(37386),
		36:  uint16(37413),
		37:  uint16(37379),
		38:  uint16(37402),
		39:  uint16(37414),
		40:  uint16(37391),
		41:  uint16(37388),
		42:  uint16(37376),
		43:  uint16(37394),
		44:  uint16(37375),
		45:  uint16(37373),
		46:  uint16(37382),
		47:  uint16(37380),
		48:  uint16(37415),
		49:  uint16(37378),
		50:  uint16(37404),
		51:  uint16(37412),
		52:  uint16(37401),
		53:  uint16(37399),
		54:  uint16(37381),
		55:  uint16(37398),
		56:  uint16(38267),
		57:  uint16(38285),
		58:  uint16(38284),
		59:  uint16(38288),
		60:  uint16(38535),
		61:  uint16(38526),
		62:  uint16(38536),
		63:  uint16(38537),
		64:  uint16(38531),
		65:  uint16(38528),
		66:  uint16(38594),
		67:  uint16(38600),
		68:  uint16(38595),
		69:  uint16(38641),
		70:  uint16(38640),
		71:  uint16(38764),
		72:  uint16(38768),
		73:  uint16(38766),
		74:  uint16(38919),
		75:  uint16(39081),
		76:  uint16(39147),
		77:  uint16(40166),
		78:  uint16(40697),
		79:  uint16(20099),
		80:  uint16(20100),
		81:  uint16(20150),
		82:  uint16(20669),
		83:  uint16(20671),
		84:  uint16(20678),
		85:  uint16(20654),
		86:  uint16(20676),
		87:  uint16(20682),
		88:  uint16(20660),
		89:  uint16(20680),
		90:  uint16(20674),
		91:  uint16(20656),
		92:  uint16(20673),
		93:  uint16(20666),
		94:  uint16(20657),
		95:  uint16(20683),
		96:  uint16(20681),
		97:  uint16(20662),
		98:  uint16(20664),
		99:  uint16(20951),
		100: uint16(21114),
		101: uint16(21112),
		102: uint16(21115),
		103: uint16(21116),
		104: uint16(21955),
		105: uint16(21979),
		106: uint16(21964),
		107: uint16(21968),
		108: uint16(21963),
		109: uint16(21962),
		110: uint16(21981),
		111: uint16(21952),
		112: uint16(21972),
		113: uint16(21956),
		114: uint16(21993),
		115: uint16(21951),
		116: uint16(21970),
		117: uint16(21901),
		118: uint16(21967),
		119: uint16(21973),
		120: uint16(21986),
		121: uint16(21974),
		122: uint16(21960),
		123: uint16(22002),
		124: uint16(21965),
		125: uint16(21977),
		126: uint16(21954),
		127: uint16(22292),
		128: uint16(22611),
		129: uint16(22632),
		130: uint16(22628),
		131: uint16(22607),
		132: uint16(22605),
		133: uint16(22601),
		134: uint16(22639),
		135: uint16(22613),
		136: uint16(22606),
		137: uint16(22621),
		138: uint16(22617),
		139: uint16(22629),
		140: uint16(22619),
		141: uint16(22589),
		142: uint16(22627),
		143: uint16(22641),
		144: uint16(22780),
		145: uint16(23239),
		146: uint16(23236),
		147: uint16(23243),
		148: uint16(23226),
		149: uint16(23224),
		150: uint16(23217),
		151: uint16(23221),
		152: uint16(23216),
		153: uint16(23231),
		154: uint16(23240),
		155: uint16(23227),
		156: uint16(23238),
	},
	60: {
		0:   uint16(23223),
		1:   uint16(23232),
		2:   uint16(23242),
		3:   uint16(23220),
		4:   uint16(23222),
		5:   uint16(23245),
		6:   uint16(23225),
		7:   uint16(23184),
		8:   uint16(23510),
		9:   uint16(23512),
		10:  uint16(23513),
		11:  uint16(23583),
		12:  uint16(23603),
		13:  uint16(23921),
		14:  uint16(23907),
		15:  uint16(23882),
		16:  uint16(23909),
		17:  uint16(23922),
		18:  uint16(23916),
		19:  uint16(23902),
		20:  uint16(23912),
		21:  uint16(23911),
		22:  uint16(23906),
		23:  uint16(24048),
		24:  uint16(24143),
		25:  uint16(24142),
		26:  uint16(24138),
		27:  uint16(24141),
		28:  uint16(24139),
		29:  uint16(24261),
		30:  uint16(24268),
		31:  uint16(24262),
		32:  uint16(24267),
		33:  uint16(24263),
		34:  uint16(24384),
		35:  uint16(24495),
		36:  uint16(24493),
		37:  uint16(24823),
		38:  uint16(24905),
		39:  uint16(24906),
		40:  uint16(24875),
		41:  uint16(24901),
		42:  uint16(24886),
		43:  uint16(24882),
		44:  uint16(24878),
		45:  uint16(24902),
		46:  uint16(24879),
		47:  uint16(24911),
		48:  uint16(24873),
		49:  uint16(24896),
		50:  uint16(25120),
		51:  uint16(37224),
		52:  uint16(25123),
		53:  uint16(25125),
		54:  uint16(25124),
		55:  uint16(25541),
		56:  uint16(25585),
		57:  uint16(25579),
		58:  uint16(25616),
		59:  uint16(25618),
		60:  uint16(25609),
		61:  uint16(25632),
		62:  uint16(25636),
		63:  uint16(25651),
		64:  uint16(25667),
		65:  uint16(25631),
		66:  uint16(25621),
		67:  uint16(25624),
		68:  uint16(25657),
		69:  uint16(25655),
		70:  uint16(25634),
		71:  uint16(25635),
		72:  uint16(25612),
		73:  uint16(25638),
		74:  uint16(25648),
		75:  uint16(25640),
		76:  uint16(25665),
		77:  uint16(25653),
		78:  uint16(25647),
		79:  uint16(25610),
		80:  uint16(25626),
		81:  uint16(25664),
		82:  uint16(25637),
		83:  uint16(25639),
		84:  uint16(25611),
		85:  uint16(25575),
		86:  uint16(25627),
		87:  uint16(25646),
		88:  uint16(25633),
		89:  uint16(25614),
		90:  uint16(25967),
		91:  uint16(26002),
		92:  uint16(26067),
		93:  uint16(26246),
		94:  uint16(26252),
		95:  uint16(26261),
		96:  uint16(26256),
		97:  uint16(26251),
		98:  uint16(26250),
		99:  uint16(26265),
		100: uint16(26260),
		101: uint16(26232),
		102: uint16(26400),
		103: uint16(26982),
		104: uint16(26975),
		105: uint16(26936),
		106: uint16(26958),
		107: uint16(26978),
		108: uint16(26993),
		109: uint16(26943),
		110: uint16(26949),
		111: uint16(26986),
		112: uint16(26937),
		113: uint16(26946),
		114: uint16(26967),
		115: uint16(26969),
		116: uint16(27002),
		117: uint16(26952),
		118: uint16(26953),
		119: uint16(26933),
		120: uint16(26988),
		121: uint16(26931),
		122: uint16(26941),
		123: uint16(26981),
		124: uint16(26864),
		125: uint16(27000),
		126: uint16(26932),
		127: uint16(26985),
		128: uint16(26944),
		129: uint16(26991),
		130: uint16(26948),
		131: uint16(26998),
		132: uint16(26968),
		133: uint16(26945),
		134: uint16(26996),
		135: uint16(26956),
		136: uint16(26939),
		137: uint16(26955),
		138: uint16(26935),
		139: uint16(26972),
		140: uint16(26959),
		141: uint16(26961),
		142: uint16(26930),
		143: uint16(26962),
		144: uint16(26927),
		145: uint16(27003),
		146: uint16(26940),
		147: uint16(27462),
		148: uint16(27461),
		149: uint16(27459),
		150: uint16(27458),
		151: uint16(27464),
		152: uint16(27457),
		153: uint16(27547),
		154: uint16(64013),
		155: uint16(27643),
		156: uint16(27644),
	},
	61: {
		0:   uint16(27641),
		1:   uint16(27639),
		2:   uint16(27640),
		3:   uint16(28315),
		4:   uint16(28374),
		5:   uint16(28360),
		6:   uint16(28303),
		7:   uint16(28352),
		8:   uint16(28319),
		9:   uint16(28307),
		10:  uint16(28308),
		11:  uint16(28320),
		12:  uint16(28337),
		13:  uint16(28345),
		14:  uint16(28358),
		15:  uint16(28370),
		16:  uint16(28349),
		17:  uint16(28353),
		18:  uint16(28318),
		19:  uint16(28361),
		20:  uint16(28343),
		21:  uint16(28336),
		22:  uint16(28365),
		23:  uint16(28326),
		24:  uint16(28367),
		25:  uint16(28338),
		26:  uint16(28350),
		27:  uint16(28355),
		28:  uint16(28380),
		29:  uint16(28376),
		30:  uint16(28313),
		31:  uint16(28306),
		32:  uint16(28302),
		33:  uint16(28301),
		34:  uint16(28324),
		35:  uint16(28321),
		36:  uint16(28351),
		37:  uint16(28339),
		38:  uint16(28368),
		39:  uint16(28362),
		40:  uint16(28311),
		41:  uint16(28334),
		42:  uint16(28323),
		43:  uint16(28999),
		44:  uint16(29012),
		45:  uint16(29010),
		46:  uint16(29027),
		47:  uint16(29024),
		48:  uint16(28993),
		49:  uint16(29021),
		50:  uint16(29026),
		51:  uint16(29042),
		52:  uint16(29048),
		53:  uint16(29034),
		54:  uint16(29025),
		55:  uint16(28994),
		56:  uint16(29016),
		57:  uint16(28995),
		58:  uint16(29003),
		59:  uint16(29040),
		60:  uint16(29023),
		61:  uint16(29008),
		62:  uint16(29011),
		63:  uint16(28996),
		64:  uint16(29005),
		65:  uint16(29018),
		66:  uint16(29263),
		67:  uint16(29325),
		68:  uint16(29324),
		69:  uint16(29329),
		70:  uint16(29328),
		71:  uint16(29326),
		72:  uint16(29500),
		73:  uint16(29506),
		74:  uint16(29499),
		75:  uint16(29498),
		76:  uint16(29504),
		77:  uint16(29514),
		78:  uint16(29513),
		79:  uint16(29764),
		80:  uint16(29770),
		81:  uint16(29771),
		82:  uint16(29778),
		83:  uint16(29777),
		84:  uint16(29783),
		85:  uint16(29760),
		86:  uint16(29775),
		87:  uint16(29776),
		88:  uint16(29774),
		89:  uint16(29762),
		90:  uint16(29766),
		91:  uint16(29773),
		92:  uint16(29780),
		93:  uint16(29921),
		94:  uint16(29951),
		95:  uint16(29950),
		96:  uint16(29949),
		97:  uint16(29981),
		98:  uint16(30073),
		99:  uint16(30071),
		100: uint16(27011),
		101: uint16(30191),
		102: uint16(30223),
		103: uint16(30211),
		104: uint16(30199),
		105: uint16(30206),
		106: uint16(30204),
		107: uint16(30201),
		108: uint16(30200),
		109: uint16(30224),
		110: uint16(30203),
		111: uint16(30198),
		112: uint16(30189),
		113: uint16(30197),
		114: uint16(30205),
		115: uint16(30361),
		116: uint16(30389),
		117: uint16(30429),
		118: uint16(30549),
		119: uint16(30559),
		120: uint16(30560),
		121: uint16(30546),
		122: uint16(30550),
		123: uint16(30554),
		124: uint16(30569),
		125: uint16(30567),
		126: uint16(30548),
		127: uint16(30553),
		128: uint16(30573),
		129: uint16(30688),
		130: uint16(30855),
		131: uint16(30874),
		132: uint16(30868),
		133: uint16(30863),
		134: uint16(30852),
		135: uint16(30869),
		136: uint16(30853),
		137: uint16(30854),
		138: uint16(30881),
		139: uint16(30851),
		140: uint16(30841),
		141: uint16(30873),
		142: uint16(30848),
		143: uint16(30870),
		144: uint16(30843),
		145: uint16(31100),
		146: uint16(31106),
		147: uint16(31101),
		148: uint16(31097),
		149: uint16(31249),
		150: uint16(31256),
		151: uint16(31257),
		152: uint16(31250),
		153: uint16(31255),
		154: uint16(31253),
		155: uint16(31266),
		156: uint16(31251),
	},
	62: {
		0:   uint16(31259),
		1:   uint16(31248),
		2:   uint16(31395),
		3:   uint16(31394),
		4:   uint16(31390),
		5:   uint16(31467),
		6:   uint16(31590),
		7:   uint16(31588),
		8:   uint16(31597),
		9:   uint16(31604),
		10:  uint16(31593),
		11:  uint16(31602),
		12:  uint16(31589),
		13:  uint16(31603),
		14:  uint16(31601),
		15:  uint16(31600),
		16:  uint16(31585),
		17:  uint16(31608),
		18:  uint16(31606),
		19:  uint16(31587),
		20:  uint16(31922),
		21:  uint16(31924),
		22:  uint16(31919),
		23:  uint16(32136),
		24:  uint16(32134),
		25:  uint16(32128),
		26:  uint16(32141),
		27:  uint16(32127),
		28:  uint16(32133),
		29:  uint16(32122),
		30:  uint16(32142),
		31:  uint16(32123),
		32:  uint16(32131),
		33:  uint16(32124),
		34:  uint16(32140),
		35:  uint16(32148),
		36:  uint16(32132),
		37:  uint16(32125),
		38:  uint16(32146),
		39:  uint16(32621),
		40:  uint16(32619),
		41:  uint16(32615),
		42:  uint16(32616),
		43:  uint16(32620),
		44:  uint16(32678),
		45:  uint16(32677),
		46:  uint16(32679),
		47:  uint16(32731),
		48:  uint16(32732),
		49:  uint16(32801),
		50:  uint16(33124),
		51:  uint16(33120),
		52:  uint16(33143),
		53:  uint16(33116),
		54:  uint16(33129),
		55:  uint16(33115),
		56:  uint16(33122),
		57:  uint16(33138),
		58:  uint16(26401),
		59:  uint16(33118),
		60:  uint16(33142),
		61:  uint16(33127),
		62:  uint16(33135),
		63:  uint16(33092),
		64:  uint16(33121),
		65:  uint16(33309),
		66:  uint16(33353),
		67:  uint16(33348),
		68:  uint16(33344),
		69:  uint16(33346),
		70:  uint16(33349),
		71:  uint16(34033),
		72:  uint16(33855),
		73:  uint16(33878),
		74:  uint16(33910),
		75:  uint16(33913),
		76:  uint16(33935),
		77:  uint16(33933),
		78:  uint16(33893),
		79:  uint16(33873),
		80:  uint16(33856),
		81:  uint16(33926),
		82:  uint16(33895),
		83:  uint16(33840),
		84:  uint16(33869),
		85:  uint16(33917),
		86:  uint16(33882),
		87:  uint16(33881),
		88:  uint16(33908),
		89:  uint16(33907),
		90:  uint16(33885),
		91:  uint16(34055),
		92:  uint16(33886),
		93:  uint16(33847),
		94:  uint16(33850),
		95:  uint16(33844),
		96:  uint16(33914),
		97:  uint16(33859),
		98:  uint16(33912),
		99:  uint16(33842),
		100: uint16(33861),
		101: uint16(33833),
		102: uint16(33753),
		103: uint16(33867),
		104: uint16(33839),
		105: uint16(33858),
		106: uint16(33837),
		107: uint16(33887),
		108: uint16(33904),
		109: uint16(33849),
		110: uint16(33870),
		111: uint16(33868),
		112: uint16(33874),
		113: uint16(33903),
		114: uint16(33989),
		115: uint16(33934),
		116: uint16(33851),
		117: uint16(33863),
		118: uint16(33846),
		119: uint16(33843),
		120: uint16(33896),
		121: uint16(33918),
		122: uint16(33860),
		123: uint16(33835),
		124: uint16(33888),
		125: uint16(33876),
		126: uint16(33902),
		127: uint16(33872),
		128: uint16(34571),
		129: uint16(34564),
		130: uint16(34551),
		131: uint16(34572),
		132: uint16(34554),
		133: uint16(34518),
		134: uint16(34549),
		135: uint16(34637),
		136: uint16(34552),
		137: uint16(34574),
		138: uint16(34569),
		139: uint16(34561),
		140: uint16(34550),
		141: uint16(34573),
		142: uint16(34565),
		143: uint16(35030),
		144: uint16(35019),
		145: uint16(35021),
		146: uint16(35022),
		147: uint16(35038),
		148: uint16(35035),
		149: uint16(35034),
		150: uint16(35020),
		151: uint16(35024),
		152: uint16(35205),
		153: uint16(35227),
		154: uint16(35295),
		155: uint16(35301),
		156: uint16(35300),
	},
	63: {
		0:   uint16(35297),
		1:   uint16(35296),
		2:   uint16(35298),
		3:   uint16(35292),
		4:   uint16(35302),
		5:   uint16(35446),
		6:   uint16(35462),
		7:   uint16(35455),
		8:   uint16(35425),
		9:   uint16(35391),
		10:  uint16(35447),
		11:  uint16(35458),
		12:  uint16(35460),
		13:  uint16(35445),
		14:  uint16(35459),
		15:  uint16(35457),
		16:  uint16(35444),
		17:  uint16(35450),
		18:  uint16(35900),
		19:  uint16(35915),
		20:  uint16(35914),
		21:  uint16(35941),
		22:  uint16(35940),
		23:  uint16(35942),
		24:  uint16(35974),
		25:  uint16(35972),
		26:  uint16(35973),
		27:  uint16(36044),
		28:  uint16(36200),
		29:  uint16(36201),
		30:  uint16(36241),
		31:  uint16(36236),
		32:  uint16(36238),
		33:  uint16(36239),
		34:  uint16(36237),
		35:  uint16(36243),
		36:  uint16(36244),
		37:  uint16(36240),
		38:  uint16(36242),
		39:  uint16(36336),
		40:  uint16(36320),
		41:  uint16(36332),
		42:  uint16(36337),
		43:  uint16(36334),
		44:  uint16(36304),
		45:  uint16(36329),
		46:  uint16(36323),
		47:  uint16(36322),
		48:  uint16(36327),
		49:  uint16(36338),
		50:  uint16(36331),
		51:  uint16(36340),
		52:  uint16(36614),
		53:  uint16(36607),
		54:  uint16(36609),
		55:  uint16(36608),
		56:  uint16(36613),
		57:  uint16(36615),
		58:  uint16(36616),
		59:  uint16(36610),
		60:  uint16(36619),
		61:  uint16(36946),
		62:  uint16(36927),
		63:  uint16(36932),
		64:  uint16(36937),
		65:  uint16(36925),
		66:  uint16(37136),
		67:  uint16(37133),
		68:  uint16(37135),
		69:  uint16(37137),
		70:  uint16(37142),
		71:  uint16(37140),
		72:  uint16(37131),
		73:  uint16(37134),
		74:  uint16(37230),
		75:  uint16(37231),
		76:  uint16(37448),
		77:  uint16(37458),
		78:  uint16(37424),
		79:  uint16(37434),
		80:  uint16(37478),
		81:  uint16(37427),
		82:  uint16(37477),
		83:  uint16(37470),
		84:  uint16(37507),
		85:  uint16(37422),
		86:  uint16(37450),
		87:  uint16(37446),
		88:  uint16(37485),
		89:  uint16(37484),
		90:  uint16(37455),
		91:  uint16(37472),
		92:  uint16(37479),
		93:  uint16(37487),
		94:  uint16(37430),
		95:  uint16(37473),
		96:  uint16(37488),
		97:  uint16(37425),
		98:  uint16(37460),
		99:  uint16(37475),
		100: uint16(37456),
		101: uint16(37490),
		102: uint16(37454),
		103: uint16(37459),
		104: uint16(37452),
		105: uint16(37462),
		106: uint16(37426),
		107: uint16(38303),
		108: uint16(38300),
		109: uint16(38302),
		110: uint16(38299),
		111: uint16(38546),
		112: uint16(38547),
		113: uint16(38545),
		114: uint16(38551),
		115: uint16(38606),
		116: uint16(38650),
		117: uint16(38653),
		118: uint16(38648),
		119: uint16(38645),
		120: uint16(38771),
		121: uint16(38775),
		122: uint16(38776),
		123: uint16(38770),
		124: uint16(38927),
		125: uint16(38925),
		126: uint16(38926),
		127: uint16(39084),
		128: uint16(39158),
		129: uint16(39161),
		130: uint16(39343),
		131: uint16(39346),
		132: uint16(39344),
		133: uint16(39349),
		134: uint16(39597),
		135: uint16(39595),
		136: uint16(39771),
		137: uint16(40170),
		138: uint16(40173),
		139: uint16(40167),
		140: uint16(40576),
		141: uint16(40701),
		142: uint16(20710),
		143: uint16(20692),
		144: uint16(20695),
		145: uint16(20712),
		146: uint16(20723),
		147: uint16(20699),
		148: uint16(20714),
		149: uint16(20701),
		150: uint16(20708),
		151: uint16(20691),
		152: uint16(20716),
		153: uint16(20720),
		154: uint16(20719),
		155: uint16(20707),
		156: uint16(20704),
	},
	64: {
		0:   uint16(20952),
		1:   uint16(21120),
		2:   uint16(21121),
		3:   uint16(21225),
		4:   uint16(21227),
		5:   uint16(21296),
		6:   uint16(21420),
		7:   uint16(22055),
		8:   uint16(22037),
		9:   uint16(22028),
		10:  uint16(22034),
		11:  uint16(22012),
		12:  uint16(22031),
		13:  uint16(22044),
		14:  uint16(22017),
		15:  uint16(22035),
		16:  uint16(22018),
		17:  uint16(22010),
		18:  uint16(22045),
		19:  uint16(22020),
		20:  uint16(22015),
		21:  uint16(22009),
		22:  uint16(22665),
		23:  uint16(22652),
		24:  uint16(22672),
		25:  uint16(22680),
		26:  uint16(22662),
		27:  uint16(22657),
		28:  uint16(22655),
		29:  uint16(22644),
		30:  uint16(22667),
		31:  uint16(22650),
		32:  uint16(22663),
		33:  uint16(22673),
		34:  uint16(22670),
		35:  uint16(22646),
		36:  uint16(22658),
		37:  uint16(22664),
		38:  uint16(22651),
		39:  uint16(22676),
		40:  uint16(22671),
		41:  uint16(22782),
		42:  uint16(22891),
		43:  uint16(23260),
		44:  uint16(23278),
		45:  uint16(23269),
		46:  uint16(23253),
		47:  uint16(23274),
		48:  uint16(23258),
		49:  uint16(23277),
		50:  uint16(23275),
		51:  uint16(23283),
		52:  uint16(23266),
		53:  uint16(23264),
		54:  uint16(23259),
		55:  uint16(23276),
		56:  uint16(23262),
		57:  uint16(23261),
		58:  uint16(23257),
		59:  uint16(23272),
		60:  uint16(23263),
		61:  uint16(23415),
		62:  uint16(23520),
		63:  uint16(23523),
		64:  uint16(23651),
		65:  uint16(23938),
		66:  uint16(23936),
		67:  uint16(23933),
		68:  uint16(23942),
		69:  uint16(23930),
		70:  uint16(23937),
		71:  uint16(23927),
		72:  uint16(23946),
		73:  uint16(23945),
		74:  uint16(23944),
		75:  uint16(23934),
		76:  uint16(23932),
		77:  uint16(23949),
		78:  uint16(23929),
		79:  uint16(23935),
		80:  uint16(24152),
		81:  uint16(24153),
		82:  uint16(24147),
		83:  uint16(24280),
		84:  uint16(24273),
		85:  uint16(24279),
		86:  uint16(24270),
		87:  uint16(24284),
		88:  uint16(24277),
		89:  uint16(24281),
		90:  uint16(24274),
		91:  uint16(24276),
		92:  uint16(24388),
		93:  uint16(24387),
		94:  uint16(24431),
		95:  uint16(24502),
		96:  uint16(24876),
		97:  uint16(24872),
		98:  uint16(24897),
		99:  uint16(24926),
		100: uint16(24945),
		101: uint16(24947),
		102: uint16(24914),
		103: uint16(24915),
		104: uint16(24946),
		105: uint16(24940),
		106: uint16(24960),
		107: uint16(24948),
		108: uint16(24916),
		109: uint16(24954),
		110: uint16(24923),
		111: uint16(24933),
		112: uint16(24891),
		113: uint16(24938),
		114: uint16(24929),
		115: uint16(24918),
		116: uint16(25129),
		117: uint16(25127),
		118: uint16(25131),
		119: uint16(25643),
		120: uint16(25677),
		121: uint16(25691),
		122: uint16(25693),
		123: uint16(25716),
		124: uint16(25718),
		125: uint16(25714),
		126: uint16(25715),
		127: uint16(25725),
		128: uint16(25717),
		129: uint16(25702),
		130: uint16(25766),
		131: uint16(25678),
		132: uint16(25730),
		133: uint16(25694),
		134: uint16(25692),
		135: uint16(25675),
		136: uint16(25683),
		137: uint16(25696),
		138: uint16(25680),
		139: uint16(25727),
		140: uint16(25663),
		141: uint16(25708),
		142: uint16(25707),
		143: uint16(25689),
		144: uint16(25701),
		145: uint16(25719),
		146: uint16(25971),
		147: uint16(26016),
		148: uint16(26273),
		149: uint16(26272),
		150: uint16(26271),
		151: uint16(26373),
		152: uint16(26372),
		153: uint16(26402),
		154: uint16(27057),
		155: uint16(27062),
		156: uint16(27081),
	},
	65: {
		0:   uint16(27040),
		1:   uint16(27086),
		2:   uint16(27030),
		3:   uint16(27056),
		4:   uint16(27052),
		5:   uint16(27068),
		6:   uint16(27025),
		7:   uint16(27033),
		8:   uint16(27022),
		9:   uint16(27047),
		10:  uint16(27021),
		11:  uint16(27049),
		12:  uint16(27070),
		13:  uint16(27055),
		14:  uint16(27071),
		15:  uint16(27076),
		16:  uint16(27069),
		17:  uint16(27044),
		18:  uint16(27092),
		19:  uint16(27065),
		20:  uint16(27082),
		21:  uint16(27034),
		22:  uint16(27087),
		23:  uint16(27059),
		24:  uint16(27027),
		25:  uint16(27050),
		26:  uint16(27041),
		27:  uint16(27038),
		28:  uint16(27097),
		29:  uint16(27031),
		30:  uint16(27024),
		31:  uint16(27074),
		32:  uint16(27061),
		33:  uint16(27045),
		34:  uint16(27078),
		35:  uint16(27466),
		36:  uint16(27469),
		37:  uint16(27467),
		38:  uint16(27550),
		39:  uint16(27551),
		40:  uint16(27552),
		41:  uint16(27587),
		42:  uint16(27588),
		43:  uint16(27646),
		44:  uint16(28366),
		45:  uint16(28405),
		46:  uint16(28401),
		47:  uint16(28419),
		48:  uint16(28453),
		49:  uint16(28408),
		50:  uint16(28471),
		51:  uint16(28411),
		52:  uint16(28462),
		53:  uint16(28425),
		54:  uint16(28494),
		55:  uint16(28441),
		56:  uint16(28442),
		57:  uint16(28455),
		58:  uint16(28440),
		59:  uint16(28475),
		60:  uint16(28434),
		61:  uint16(28397),
		62:  uint16(28426),
		63:  uint16(28470),
		64:  uint16(28531),
		65:  uint16(28409),
		66:  uint16(28398),
		67:  uint16(28461),
		68:  uint16(28480),
		69:  uint16(28464),
		70:  uint16(28476),
		71:  uint16(28469),
		72:  uint16(28395),
		73:  uint16(28423),
		74:  uint16(28430),
		75:  uint16(28483),
		76:  uint16(28421),
		77:  uint16(28413),
		78:  uint16(28406),
		79:  uint16(28473),
		80:  uint16(28444),
		81:  uint16(28412),
		82:  uint16(28474),
		83:  uint16(28447),
		84:  uint16(28429),
		85:  uint16(28446),
		86:  uint16(28424),
		87:  uint16(28449),
		88:  uint16(29063),
		89:  uint16(29072),
		90:  uint16(29065),
		91:  uint16(29056),
		92:  uint16(29061),
		93:  uint16(29058),
		94:  uint16(29071),
		95:  uint16(29051),
		96:  uint16(29062),
		97:  uint16(29057),
		98:  uint16(29079),
		99:  uint16(29252),
		100: uint16(29267),
		101: uint16(29335),
		102: uint16(29333),
		103: uint16(29331),
		104: uint16(29507),
		105: uint16(29517),
		106: uint16(29521),
		107: uint16(29516),
		108: uint16(29794),
		109: uint16(29811),
		110: uint16(29809),
		111: uint16(29813),
		112: uint16(29810),
		113: uint16(29799),
		114: uint16(29806),
		115: uint16(29952),
		116: uint16(29954),
		117: uint16(29955),
		118: uint16(30077),
		119: uint16(30096),
		120: uint16(30230),
		121: uint16(30216),
		122: uint16(30220),
		123: uint16(30229),
		124: uint16(30225),
		125: uint16(30218),
		126: uint16(30228),
		127: uint16(30392),
		128: uint16(30593),
		129: uint16(30588),
		130: uint16(30597),
		131: uint16(30594),
		132: uint16(30574),
		133: uint16(30592),
		134: uint16(30575),
		135: uint16(30590),
		136: uint16(30595),
		137: uint16(30898),
		138: uint16(30890),
		139: uint16(30900),
		140: uint16(30893),
		141: uint16(30888),
		142: uint16(30846),
		143: uint16(30891),
		144: uint16(30878),
		145: uint16(30885),
		146: uint16(30880),
		147: uint16(30892),
		148: uint16(30882),
		149: uint16(30884),
		150: uint16(31128),
		151: uint16(31114),
		152: uint16(31115),
		153: uint16(31126),
		154: uint16(31125),
		155: uint16(31124),
		156: uint16(31123),
	},
	66: {
		0:   uint16(31127),
		1:   uint16(31112),
		2:   uint16(31122),
		3:   uint16(31120),
		4:   uint16(31275),
		5:   uint16(31306),
		6:   uint16(31280),
		7:   uint16(31279),
		8:   uint16(31272),
		9:   uint16(31270),
		10:  uint16(31400),
		11:  uint16(31403),
		12:  uint16(31404),
		13:  uint16(31470),
		14:  uint16(31624),
		15:  uint16(31644),
		16:  uint16(31626),
		17:  uint16(31633),
		18:  uint16(31632),
		19:  uint16(31638),
		20:  uint16(31629),
		21:  uint16(31628),
		22:  uint16(31643),
		23:  uint16(31630),
		24:  uint16(31621),
		25:  uint16(31640),
		26:  uint16(21124),
		27:  uint16(31641),
		28:  uint16(31652),
		29:  uint16(31618),
		30:  uint16(31931),
		31:  uint16(31935),
		32:  uint16(31932),
		33:  uint16(31930),
		34:  uint16(32167),
		35:  uint16(32183),
		36:  uint16(32194),
		37:  uint16(32163),
		38:  uint16(32170),
		39:  uint16(32193),
		40:  uint16(32192),
		41:  uint16(32197),
		42:  uint16(32157),
		43:  uint16(32206),
		44:  uint16(32196),
		45:  uint16(32198),
		46:  uint16(32203),
		47:  uint16(32204),
		48:  uint16(32175),
		49:  uint16(32185),
		50:  uint16(32150),
		51:  uint16(32188),
		52:  uint16(32159),
		53:  uint16(32166),
		54:  uint16(32174),
		55:  uint16(32169),
		56:  uint16(32161),
		57:  uint16(32201),
		58:  uint16(32627),
		59:  uint16(32738),
		60:  uint16(32739),
		61:  uint16(32741),
		62:  uint16(32734),
		63:  uint16(32804),
		64:  uint16(32861),
		65:  uint16(32860),
		66:  uint16(33161),
		67:  uint16(33158),
		68:  uint16(33155),
		69:  uint16(33159),
		70:  uint16(33165),
		71:  uint16(33164),
		72:  uint16(33163),
		73:  uint16(33301),
		74:  uint16(33943),
		75:  uint16(33956),
		76:  uint16(33953),
		77:  uint16(33951),
		78:  uint16(33978),
		79:  uint16(33998),
		80:  uint16(33986),
		81:  uint16(33964),
		82:  uint16(33966),
		83:  uint16(33963),
		84:  uint16(33977),
		85:  uint16(33972),
		86:  uint16(33985),
		87:  uint16(33997),
		88:  uint16(33962),
		89:  uint16(33946),
		90:  uint16(33969),
		91:  uint16(34000),
		92:  uint16(33949),
		93:  uint16(33959),
		94:  uint16(33979),
		95:  uint16(33954),
		96:  uint16(33940),
		97:  uint16(33991),
		98:  uint16(33996),
		99:  uint16(33947),
		100: uint16(33961),
		101: uint16(33967),
		102: uint16(33960),
		103: uint16(34006),
		104: uint16(33944),
		105: uint16(33974),
		106: uint16(33999),
		107: uint16(33952),
		108: uint16(34007),
		109: uint16(34004),
		110: uint16(34002),
		111: uint16(34011),
		112: uint16(33968),
		113: uint16(33937),
		114: uint16(34401),
		115: uint16(34611),
		116: uint16(34595),
		117: uint16(34600),
		118: uint16(34667),
		119: uint16(34624),
		120: uint16(34606),
		121: uint16(34590),
		122: uint16(34593),
		123: uint16(34585),
		124: uint16(34587),
		125: uint16(34627),
		126: uint16(34604),
		127: uint16(34625),
		128: uint16(34622),
		129: uint16(34630),
		130: uint16(34592),
		131: uint16(34610),
		132: uint16(34602),
		133: uint16(34605),
		134: uint16(34620),
		135: uint16(34578),
		136: uint16(34618),
		137: uint16(34609),
		138: uint16(34613),
		139: uint16(34626),
		140: uint16(34598),
		141: uint16(34599),
		142: uint16(34616),
		143: uint16(34596),
		144: uint16(34586),
		145: uint16(34608),
		146: uint16(34577),
		147: uint16(35063),
		148: uint16(35047),
		149: uint16(35057),
		150: uint16(35058),
		151: uint16(35066),
		152: uint16(35070),
		153: uint16(35054),
		154: uint16(35068),
		155: uint16(35062),
		156: uint16(35067),
	},
	67: {
		0:   uint16(35056),
		1:   uint16(35052),
		2:   uint16(35051),
		3:   uint16(35229),
		4:   uint16(35233),
		5:   uint16(35231),
		6:   uint16(35230),
		7:   uint16(35305),
		8:   uint16(35307),
		9:   uint16(35304),
		10:  uint16(35499),
		11:  uint16(35481),
		12:  uint16(35467),
		13:  uint16(35474),
		14:  uint16(35471),
		15:  uint16(35478),
		16:  uint16(35901),
		17:  uint16(35944),
		18:  uint16(35945),
		19:  uint16(36053),
		20:  uint16(36047),
		21:  uint16(36055),
		22:  uint16(36246),
		23:  uint16(36361),
		24:  uint16(36354),
		25:  uint16(36351),
		26:  uint16(36365),
		27:  uint16(36349),
		28:  uint16(36362),
		29:  uint16(36355),
		30:  uint16(36359),
		31:  uint16(36358),
		32:  uint16(36357),
		33:  uint16(36350),
		34:  uint16(36352),
		35:  uint16(36356),
		36:  uint16(36624),
		37:  uint16(36625),
		38:  uint16(36622),
		39:  uint16(36621),
		40:  uint16(37155),
		41:  uint16(37148),
		42:  uint16(37152),
		43:  uint16(37154),
		44:  uint16(37151),
		45:  uint16(37149),
		46:  uint16(37146),
		47:  uint16(37156),
		48:  uint16(37153),
		49:  uint16(37147),
		50:  uint16(37242),
		51:  uint16(37234),
		52:  uint16(37241),
		53:  uint16(37235),
		54:  uint16(37541),
		55:  uint16(37540),
		56:  uint16(37494),
		57:  uint16(37531),
		58:  uint16(37498),
		59:  uint16(37536),
		60:  uint16(37524),
		61:  uint16(37546),
		62:  uint16(37517),
		63:  uint16(37542),
		64:  uint16(37530),
		65:  uint16(37547),
		66:  uint16(37497),
		67:  uint16(37527),
		68:  uint16(37503),
		69:  uint16(37539),
		70:  uint16(37614),
		71:  uint16(37518),
		72:  uint16(37506),
		73:  uint16(37525),
		74:  uint16(37538),
		75:  uint16(37501),
		76:  uint16(37512),
		77:  uint16(37537),
		78:  uint16(37514),
		79:  uint16(37510),
		80:  uint16(37516),
		81:  uint16(37529),
		82:  uint16(37543),
		83:  uint16(37502),
		84:  uint16(37511),
		85:  uint16(37545),
		86:  uint16(37533),
		87:  uint16(37515),
		88:  uint16(37421),
		89:  uint16(38558),
		90:  uint16(38561),
		91:  uint16(38655),
		92:  uint16(38744),
		93:  uint16(38781),
		94:  uint16(38778),
		95:  uint16(38782),
		96:  uint16(38787),
		97:  uint16(38784),
		98:  uint16(38786),
		99:  uint16(38779),
		100: uint16(38788),
		101: uint16(38785),
		102: uint16(38783),
		103: uint16(38862),
		104: uint16(38861),
		105: uint16(38934),
		106: uint16(39085),
		107: uint16(39086),
		108: uint16(39170),
		109: uint16(39168),
		110: uint16(39175),
		111: uint16(39325),
		112: uint16(39324),
		113: uint16(39363),
		114: uint16(39353),
		115: uint16(39355),
		116: uint16(39354),
		117: uint16(39362),
		118: uint16(39357),
		119: uint16(39367),
		120: uint16(39601),
		121: uint16(39651),
		122: uint16(39655),
		123: uint16(39742),
		124: uint16(39743),
		125: uint16(39776),
		126: uint16(39777),
		127: uint16(39775),
		128: uint16(40177),
		129: uint16(40178),
		130: uint16(40181),
		131: uint16(40615),
		132: uint16(20735),
		133: uint16(20739),
		134: uint16(20784),
		135: uint16(20728),
		136: uint16(20742),
		137: uint16(20743),
		138: uint16(20726),
		139: uint16(20734),
		140: uint16(20747),
		141: uint16(20748),
		142: uint16(20733),
		143: uint16(20746),
		144: uint16(21131),
		145: uint16(21132),
		146: uint16(21233),
		147: uint16(21231),
		148: uint16(22088),
		149: uint16(22082),
		150: uint16(22092),
		151: uint16(22069),
		152: uint16(22081),
		153: uint16(22090),
		154: uint16(22089),
		155: uint16(22086),
		156: uint16(22104),
	},
	68: {
		0:   uint16(22106),
		1:   uint16(22080),
		2:   uint16(22067),
		3:   uint16(22077),
		4:   uint16(22060),
		5:   uint16(22078),
		6:   uint16(22072),
		7:   uint16(22058),
		8:   uint16(22074),
		9:   uint16(22298),
		10:  uint16(22699),
		11:  uint16(22685),
		12:  uint16(22705),
		13:  uint16(22688),
		14:  uint16(22691),
		15:  uint16(22703),
		16:  uint16(22700),
		17:  uint16(22693),
		18:  uint16(22689),
		19:  uint16(22783),
		20:  uint16(23295),
		21:  uint16(23284),
		22:  uint16(23293),
		23:  uint16(23287),
		24:  uint16(23286),
		25:  uint16(23299),
		26:  uint16(23288),
		27:  uint16(23298),
		28:  uint16(23289),
		29:  uint16(23297),
		30:  uint16(23303),
		31:  uint16(23301),
		32:  uint16(23311),
		33:  uint16(23655),
		34:  uint16(23961),
		35:  uint16(23959),
		36:  uint16(23967),
		37:  uint16(23954),
		38:  uint16(23970),
		39:  uint16(23955),
		40:  uint16(23957),
		41:  uint16(23968),
		42:  uint16(23964),
		43:  uint16(23969),
		44:  uint16(23962),
		45:  uint16(23966),
		46:  uint16(24169),
		47:  uint16(24157),
		48:  uint16(24160),
		49:  uint16(24156),
		50:  uint16(32243),
		51:  uint16(24283),
		52:  uint16(24286),
		53:  uint16(24289),
		54:  uint16(24393),
		55:  uint16(24498),
		56:  uint16(24971),
		57:  uint16(24963),
		58:  uint16(24953),
		59:  uint16(25009),
		60:  uint16(25008),
		61:  uint16(24994),
		62:  uint16(24969),
		63:  uint16(24987),
		64:  uint16(24979),
		65:  uint16(25007),
		66:  uint16(25005),
		67:  uint16(24991),
		68:  uint16(24978),
		69:  uint16(25002),
		70:  uint16(24993),
		71:  uint16(24973),
		72:  uint16(24934),
		73:  uint16(25011),
		74:  uint16(25133),
		75:  uint16(25710),
		76:  uint16(25712),
		77:  uint16(25750),
		78:  uint16(25760),
		79:  uint16(25733),
		80:  uint16(25751),
		81:  uint16(25756),
		82:  uint16(25743),
		83:  uint16(25739),
		84:  uint16(25738),
		85:  uint16(25740),
		86:  uint16(25763),
		87:  uint16(25759),
		88:  uint16(25704),
		89:  uint16(25777),
		90:  uint16(25752),
		91:  uint16(25974),
		92:  uint16(25978),
		93:  uint16(25977),
		94:  uint16(25979),
		95:  uint16(26034),
		96:  uint16(26035),
		97:  uint16(26293),
		98:  uint16(26288),
		99:  uint16(26281),
		100: uint16(26290),
		101: uint16(26295),
		102: uint16(26282),
		103: uint16(26287),
		104: uint16(27136),
		105: uint16(27142),
		106: uint16(27159),
		107: uint16(27109),
		108: uint16(27128),
		109: uint16(27157),
		110: uint16(27121),
		111: uint16(27108),
		112: uint16(27168),
		113: uint16(27135),
		114: uint16(27116),
		115: uint16(27106),
		116: uint16(27163),
		117: uint16(27165),
		118: uint16(27134),
		119: uint16(27175),
		120: uint16(27122),
		121: uint16(27118),
		122: uint16(27156),
		123: uint16(27127),
		124: uint16(27111),
		125: uint16(27200),
		126: uint16(27144),
		127: uint16(27110),
		128: uint16(27131),
		129: uint16(27149),
		130: uint16(27132),
		131: uint16(27115),
		132: uint16(27145),
		133: uint16(27140),
		134: uint16(27160),
		135: uint16(27173),
		136: uint16(27151),
		137: uint16(27126),
		138: uint16(27174),
		139: uint16(27143),
		140: uint16(27124),
		141: uint16(27158),
		142: uint16(27473),
		143: uint16(27557),
		144: uint16(27555),
		145: uint16(27554),
		146: uint16(27558),
		147: uint16(27649),
		148: uint16(27648),
		149: uint16(27647),
		150: uint16(27650),
		151: uint16(28481),
		152: uint16(28454),
		153: uint16(28542),
		154: uint16(28551),
		155: uint16(28614),
		156: uint16(28562),
	},
	69: {
		0:   uint16(28557),
		1:   uint16(28553),
		2:   uint16(28556),
		3:   uint16(28514),
		4:   uint16(28495),
		5:   uint16(28549),
		6:   uint16(28506),
		7:   uint16(28566),
		8:   uint16(28534),
		9:   uint16(28524),
		10:  uint16(28546),
		11:  uint16(28501),
		12:  uint16(28530),
		13:  uint16(28498),
		14:  uint16(28496),
		15:  uint16(28503),
		16:  uint16(28564),
		17:  uint16(28563),
		18:  uint16(28509),
		19:  uint16(28416),
		20:  uint16(28513),
		21:  uint16(28523),
		22:  uint16(28541),
		23:  uint16(28519),
		24:  uint16(28560),
		25:  uint16(28499),
		26:  uint16(28555),
		27:  uint16(28521),
		28:  uint16(28543),
		29:  uint16(28565),
		30:  uint16(28515),
		31:  uint16(28535),
		32:  uint16(28522),
		33:  uint16(28539),
		34:  uint16(29106),
		35:  uint16(29103),
		36:  uint16(29083),
		37:  uint16(29104),
		38:  uint16(29088),
		39:  uint16(29082),
		40:  uint16(29097),
		41:  uint16(29109),
		42:  uint16(29085),
		43:  uint16(29093),
		44:  uint16(29086),
		45:  uint16(29092),
		46:  uint16(29089),
		47:  uint16(29098),
		48:  uint16(29084),
		49:  uint16(29095),
		50:  uint16(29107),
		51:  uint16(29336),
		52:  uint16(29338),
		53:  uint16(29528),
		54:  uint16(29522),
		55:  uint16(29534),
		56:  uint16(29535),
		57:  uint16(29536),
		58:  uint16(29533),
		59:  uint16(29531),
		60:  uint16(29537),
		61:  uint16(29530),
		62:  uint16(29529),
		63:  uint16(29538),
		64:  uint16(29831),
		65:  uint16(29833),
		66:  uint16(29834),
		67:  uint16(29830),
		68:  uint16(29825),
		69:  uint16(29821),
		70:  uint16(29829),
		71:  uint16(29832),
		72:  uint16(29820),
		73:  uint16(29817),
		74:  uint16(29960),
		75:  uint16(29959),
		76:  uint16(30078),
		77:  uint16(30245),
		78:  uint16(30238),
		79:  uint16(30233),
		80:  uint16(30237),
		81:  uint16(30236),
		82:  uint16(30243),
		83:  uint16(30234),
		84:  uint16(30248),
		85:  uint16(30235),
		86:  uint16(30364),
		87:  uint16(30365),
		88:  uint16(30366),
		89:  uint16(30363),
		90:  uint16(30605),
		91:  uint16(30607),
		92:  uint16(30601),
		93:  uint16(30600),
		94:  uint16(30925),
		95:  uint16(30907),
		96:  uint16(30927),
		97:  uint16(30924),
		98:  uint16(30929),
		99:  uint16(30926),
		100: uint16(30932),
		101: uint16(30920),
		102: uint16(30915),
		103: uint16(30916),
		104: uint16(30921),
		105: uint16(31130),
		106: uint16(31137),
		107: uint16(31136),
		108: uint16(31132),
		109: uint16(31138),
		110: uint16(31131),
		111: uint16(27510),
		112: uint16(31289),
		113: uint16(31410),
		114: uint16(31412),
		115: uint16(31411),
		116: uint16(31671),
		117: uint16(31691),
		118: uint16(31678),
		119: uint16(31660),
		120: uint16(31694),
		121: uint16(31663),
		122: uint16(31673),
		123: uint16(31690),
		124: uint16(31669),
		125: uint16(31941),
		126: uint16(31944),
		127: uint16(31948),
		128: uint16(31947),
		129: uint16(32247),
		130: uint16(32219),
		131: uint16(32234),
		132: uint16(32231),
		133: uint16(32215),
		134: uint16(32225),
		135: uint16(32259),
		136: uint16(32250),
		137: uint16(32230),
		138: uint16(32246),
		139: uint16(32241),
		140: uint16(32240),
		141: uint16(32238),
		142: uint16(32223),
		143: uint16(32630),
		144: uint16(32684),
		145: uint16(32688),
		146: uint16(32685),
		147: uint16(32749),
		148: uint16(32747),
		149: uint16(32746),
		150: uint16(32748),
		151: uint16(32742),
		152: uint16(32744),
		153: uint16(32868),
		154: uint16(32871),
		155: uint16(33187),
		156: uint16(33183),
	},
	70: {
		0:   uint16(33182),
		1:   uint16(33173),
		2:   uint16(33186),
		3:   uint16(33177),
		4:   uint16(33175),
		5:   uint16(33302),
		6:   uint16(33359),
		7:   uint16(33363),
		8:   uint16(33362),
		9:   uint16(33360),
		10:  uint16(33358),
		11:  uint16(33361),
		12:  uint16(34084),
		13:  uint16(34107),
		14:  uint16(34063),
		15:  uint16(34048),
		16:  uint16(34089),
		17:  uint16(34062),
		18:  uint16(34057),
		19:  uint16(34061),
		20:  uint16(34079),
		21:  uint16(34058),
		22:  uint16(34087),
		23:  uint16(34076),
		24:  uint16(34043),
		25:  uint16(34091),
		26:  uint16(34042),
		27:  uint16(34056),
		28:  uint16(34060),
		29:  uint16(34036),
		30:  uint16(34090),
		31:  uint16(34034),
		32:  uint16(34069),
		33:  uint16(34039),
		34:  uint16(34027),
		35:  uint16(34035),
		36:  uint16(34044),
		37:  uint16(34066),
		38:  uint16(34026),
		39:  uint16(34025),
		40:  uint16(34070),
		41:  uint16(34046),
		42:  uint16(34088),
		43:  uint16(34077),
		44:  uint16(34094),
		45:  uint16(34050),
		46:  uint16(34045),
		47:  uint16(34078),
		48:  uint16(34038),
		49:  uint16(34097),
		50:  uint16(34086),
		51:  uint16(34023),
		52:  uint16(34024),
		53:  uint16(34032),
		54:  uint16(34031),
		55:  uint16(34041),
		56:  uint16(34072),
		57:  uint16(34080),
		58:  uint16(34096),
		59:  uint16(34059),
		60:  uint16(34073),
		61:  uint16(34095),
		62:  uint16(34402),
		63:  uint16(34646),
		64:  uint16(34659),
		65:  uint16(34660),
		66:  uint16(34679),
		67:  uint16(34785),
		68:  uint16(34675),
		69:  uint16(34648),
		70:  uint16(34644),
		71:  uint16(34651),
		72:  uint16(34642),
		73:  uint16(34657),
		74:  uint16(34650),
		75:  uint16(34641),
		76:  uint16(34654),
		77:  uint16(34669),
		78:  uint16(34666),
		79:  uint16(34640),
		80:  uint16(34638),
		81:  uint16(34655),
		82:  uint16(34653),
		83:  uint16(34671),
		84:  uint16(34668),
		85:  uint16(34682),
		86:  uint16(34670),
		87:  uint16(34652),
		88:  uint16(34661),
		89:  uint16(34639),
		90:  uint16(34683),
		91:  uint16(34677),
		92:  uint16(34658),
		93:  uint16(34663),
		94:  uint16(34665),
		95:  uint16(34906),
		96:  uint16(35077),
		97:  uint16(35084),
		98:  uint16(35092),
		99:  uint16(35083),
		100: uint16(35095),
		101: uint16(35096),
		102: uint16(35097),
		103: uint16(35078),
		104: uint16(35094),
		105: uint16(35089),
		106: uint16(35086),
		107: uint16(35081),
		108: uint16(35234),
		109: uint16(35236),
		110: uint16(35235),
		111: uint16(35309),
		112: uint16(35312),
		113: uint16(35308),
		114: uint16(35535),
		115: uint16(35526),
		116: uint16(35512),
		117: uint16(35539),
		118: uint16(35537),
		119: uint16(35540),
		120: uint16(35541),
		121: uint16(35515),
		122: uint16(35543),
		123: uint16(35518),
		124: uint16(35520),
		125: uint16(35525),
		126: uint16(35544),
		127: uint16(35523),
		128: uint16(35514),
		129: uint16(35517),
		130: uint16(35545),
		131: uint16(35902),
		132: uint16(35917),
		133: uint16(35983),
		134: uint16(36069),
		135: uint16(36063),
		136: uint16(36057),
		137: uint16(36072),
		138: uint16(36058),
		139: uint16(36061),
		140: uint16(36071),
		141: uint16(36256),
		142: uint16(36252),
		143: uint16(36257),
		144: uint16(36251),
		145: uint16(36384),
		146: uint16(36387),
		147: uint16(36389),
		148: uint16(36388),
		149: uint16(36398),
		150: uint16(36373),
		151: uint16(36379),
		152: uint16(36374),
		153: uint16(36369),
		154: uint16(36377),
		155: uint16(36390),
		156: uint16(36391),
	},
	71: {
		0:   uint16(36372),
		1:   uint16(36370),
		2:   uint16(36376),
		3:   uint16(36371),
		4:   uint16(36380),
		5:   uint16(36375),
		6:   uint16(36378),
		7:   uint16(36652),
		8:   uint16(36644),
		9:   uint16(36632),
		10:  uint16(36634),
		11:  uint16(36640),
		12:  uint16(36643),
		13:  uint16(36630),
		14:  uint16(36631),
		15:  uint16(36979),
		16:  uint16(36976),
		17:  uint16(36975),
		18:  uint16(36967),
		19:  uint16(36971),
		20:  uint16(37167),
		21:  uint16(37163),
		22:  uint16(37161),
		23:  uint16(37162),
		24:  uint16(37170),
		25:  uint16(37158),
		26:  uint16(37166),
		27:  uint16(37253),
		28:  uint16(37254),
		29:  uint16(37258),
		30:  uint16(37249),
		31:  uint16(37250),
		32:  uint16(37252),
		33:  uint16(37248),
		34:  uint16(37584),
		35:  uint16(37571),
		36:  uint16(37572),
		37:  uint16(37568),
		38:  uint16(37593),
		39:  uint16(37558),
		40:  uint16(37583),
		41:  uint16(37617),
		42:  uint16(37599),
		43:  uint16(37592),
		44:  uint16(37609),
		45:  uint16(37591),
		46:  uint16(37597),
		47:  uint16(37580),
		48:  uint16(37615),
		49:  uint16(37570),
		50:  uint16(37608),
		51:  uint16(37578),
		52:  uint16(37576),
		53:  uint16(37582),
		54:  uint16(37606),
		55:  uint16(37581),
		56:  uint16(37589),
		57:  uint16(37577),
		58:  uint16(37600),
		59:  uint16(37598),
		60:  uint16(37607),
		61:  uint16(37585),
		62:  uint16(37587),
		63:  uint16(37557),
		64:  uint16(37601),
		65:  uint16(37574),
		66:  uint16(37556),
		67:  uint16(38268),
		68:  uint16(38316),
		69:  uint16(38315),
		70:  uint16(38318),
		71:  uint16(38320),
		72:  uint16(38564),
		73:  uint16(38562),
		74:  uint16(38611),
		75:  uint16(38661),
		76:  uint16(38664),
		77:  uint16(38658),
		78:  uint16(38746),
		79:  uint16(38794),
		80:  uint16(38798),
		81:  uint16(38792),
		82:  uint16(38864),
		83:  uint16(38863),
		84:  uint16(38942),
		85:  uint16(38941),
		86:  uint16(38950),
		87:  uint16(38953),
		88:  uint16(38952),
		89:  uint16(38944),
		90:  uint16(38939),
		91:  uint16(38951),
		92:  uint16(39090),
		93:  uint16(39176),
		94:  uint16(39162),
		95:  uint16(39185),
		96:  uint16(39188),
		97:  uint16(39190),
		98:  uint16(39191),
		99:  uint16(39189),
		100: uint16(39388),
		101: uint16(39373),
		102: uint16(39375),
		103: uint16(39379),
		104: uint16(39380),
		105: uint16(39374),
		106: uint16(39369),
		107: uint16(39382),
		108: uint16(39384),
		109: uint16(39371),
		110: uint16(39383),
		111: uint16(39372),
		112: uint16(39603),
		113: uint16(39660),
		114: uint16(39659),
		115: uint16(39667),
		116: uint16(39666),
		117: uint16(39665),
		118: uint16(39750),
		119: uint16(39747),
		120: uint16(39783),
		121: uint16(39796),
		122: uint16(39793),
		123: uint16(39782),
		124: uint16(39798),
		125: uint16(39797),
		126: uint16(39792),
		127: uint16(39784),
		128: uint16(39780),
		129: uint16(39788),
		130: uint16(40188),
		131: uint16(40186),
		132: uint16(40189),
		133: uint16(40191),
		134: uint16(40183),
		135: uint16(40199),
		136: uint16(40192),
		137: uint16(40185),
		138: uint16(40187),
		139: uint16(40200),
		140: uint16(40197),
		141: uint16(40196),
		142: uint16(40579),
		143: uint16(40659),
		144: uint16(40719),
		145: uint16(40720),
		146: uint16(20764),
		147: uint16(20755),
		148: uint16(20759),
		149: uint16(20762),
		150: uint16(20753),
		151: uint16(20958),
		152: uint16(21300),
		153: uint16(21473),
		154: uint16(22128),
		155: uint16(22112),
		156: uint16(22126),
	},
	72: {
		0:   uint16(22131),
		1:   uint16(22118),
		2:   uint16(22115),
		3:   uint16(22125),
		4:   uint16(22130),
		5:   uint16(22110),
		6:   uint16(22135),
		7:   uint16(22300),
		8:   uint16(22299),
		9:   uint16(22728),
		10:  uint16(22717),
		11:  uint16(22729),
		12:  uint16(22719),
		13:  uint16(22714),
		14:  uint16(22722),
		15:  uint16(22716),
		16:  uint16(22726),
		17:  uint16(23319),
		18:  uint16(23321),
		19:  uint16(23323),
		20:  uint16(23329),
		21:  uint16(23316),
		22:  uint16(23315),
		23:  uint16(23312),
		24:  uint16(23318),
		25:  uint16(23336),
		26:  uint16(23322),
		27:  uint16(23328),
		28:  uint16(23326),
		29:  uint16(23535),
		30:  uint16(23980),
		31:  uint16(23985),
		32:  uint16(23977),
		33:  uint16(23975),
		34:  uint16(23989),
		35:  uint16(23984),
		36:  uint16(23982),
		37:  uint16(23978),
		38:  uint16(23976),
		39:  uint16(23986),
		40:  uint16(23981),
		41:  uint16(23983),
		42:  uint16(23988),
		43:  uint16(24167),
		44:  uint16(24168),
		45:  uint16(24166),
		46:  uint16(24175),
		47:  uint16(24297),
		48:  uint16(24295),
		49:  uint16(24294),
		50:  uint16(24296),
		51:  uint16(24293),
		52:  uint16(24395),
		53:  uint16(24508),
		54:  uint16(24989),
		55:  uint16(25000),
		56:  uint16(24982),
		57:  uint16(25029),
		58:  uint16(25012),
		59:  uint16(25030),
		60:  uint16(25025),
		61:  uint16(25036),
		62:  uint16(25018),
		63:  uint16(25023),
		64:  uint16(25016),
		65:  uint16(24972),
		66:  uint16(25815),
		67:  uint16(25814),
		68:  uint16(25808),
		69:  uint16(25807),
		70:  uint16(25801),
		71:  uint16(25789),
		72:  uint16(25737),
		73:  uint16(25795),
		74:  uint16(25819),
		75:  uint16(25843),
		76:  uint16(25817),
		77:  uint16(25907),
		78:  uint16(25983),
		79:  uint16(25980),
		80:  uint16(26018),
		81:  uint16(26312),
		82:  uint16(26302),
		83:  uint16(26304),
		84:  uint16(26314),
		85:  uint16(26315),
		86:  uint16(26319),
		87:  uint16(26301),
		88:  uint16(26299),
		89:  uint16(26298),
		90:  uint16(26316),
		91:  uint16(26403),
		92:  uint16(27188),
		93:  uint16(27238),
		94:  uint16(27209),
		95:  uint16(27239),
		96:  uint16(27186),
		97:  uint16(27240),
		98:  uint16(27198),
		99:  uint16(27229),
		100: uint16(27245),
		101: uint16(27254),
		102: uint16(27227),
		103: uint16(27217),
		104: uint16(27176),
		105: uint16(27226),
		106: uint16(27195),
		107: uint16(27199),
		108: uint16(27201),
		109: uint16(27242),
		110: uint16(27236),
		111: uint16(27216),
		112: uint16(27215),
		113: uint16(27220),
		114: uint16(27247),
		115: uint16(27241),
		116: uint16(27232),
		117: uint16(27196),
		118: uint16(27230),
		119: uint16(27222),
		120: uint16(27221),
		121: uint16(27213),
		122: uint16(27214),
		123: uint16(27206),
		124: uint16(27477),
		125: uint16(27476),
		126: uint16(27478),
		127: uint16(27559),
		128: uint16(27562),
		129: uint16(27563),
		130: uint16(27592),
		131: uint16(27591),
		132: uint16(27652),
		133: uint16(27651),
		134: uint16(27654),
		135: uint16(28589),
		136: uint16(28619),
		137: uint16(28579),
		138: uint16(28615),
		139: uint16(28604),
		140: uint16(28622),
		141: uint16(28616),
		142: uint16(28510),
		143: uint16(28612),
		144: uint16(28605),
		145: uint16(28574),
		146: uint16(28618),
		147: uint16(28584),
		148: uint16(28676),
		149: uint16(28581),
		150: uint16(28590),
		151: uint16(28602),
		152: uint16(28588),
		153: uint16(28586),
		154: uint16(28623),
		155: uint16(28607),
		156: uint16(28600),
	},
	73: {
		0:   uint16(28578),
		1:   uint16(28617),
		2:   uint16(28587),
		3:   uint16(28621),
		4:   uint16(28591),
		5:   uint16(28594),
		6:   uint16(28592),
		7:   uint16(29125),
		8:   uint16(29122),
		9:   uint16(29119),
		10:  uint16(29112),
		11:  uint16(29142),
		12:  uint16(29120),
		13:  uint16(29121),
		14:  uint16(29131),
		15:  uint16(29140),
		16:  uint16(29130),
		17:  uint16(29127),
		18:  uint16(29135),
		19:  uint16(29117),
		20:  uint16(29144),
		21:  uint16(29116),
		22:  uint16(29126),
		23:  uint16(29146),
		24:  uint16(29147),
		25:  uint16(29341),
		26:  uint16(29342),
		27:  uint16(29545),
		28:  uint16(29542),
		29:  uint16(29543),
		30:  uint16(29548),
		31:  uint16(29541),
		32:  uint16(29547),
		33:  uint16(29546),
		34:  uint16(29823),
		35:  uint16(29850),
		36:  uint16(29856),
		37:  uint16(29844),
		38:  uint16(29842),
		39:  uint16(29845),
		40:  uint16(29857),
		41:  uint16(29963),
		42:  uint16(30080),
		43:  uint16(30255),
		44:  uint16(30253),
		45:  uint16(30257),
		46:  uint16(30269),
		47:  uint16(30259),
		48:  uint16(30268),
		49:  uint16(30261),
		50:  uint16(30258),
		51:  uint16(30256),
		52:  uint16(30395),
		53:  uint16(30438),
		54:  uint16(30618),
		55:  uint16(30621),
		56:  uint16(30625),
		57:  uint16(30620),
		58:  uint16(30619),
		59:  uint16(30626),
		60:  uint16(30627),
		61:  uint16(30613),
		62:  uint16(30617),
		63:  uint16(30615),
		64:  uint16(30941),
		65:  uint16(30953),
		66:  uint16(30949),
		67:  uint16(30954),
		68:  uint16(30942),
		69:  uint16(30947),
		70:  uint16(30939),
		71:  uint16(30945),
		72:  uint16(30946),
		73:  uint16(30957),
		74:  uint16(30943),
		75:  uint16(30944),
		76:  uint16(31140),
		77:  uint16(31300),
		78:  uint16(31304),
		79:  uint16(31303),
		80:  uint16(31414),
		81:  uint16(31416),
		82:  uint16(31413),
		83:  uint16(31409),
		84:  uint16(31415),
		85:  uint16(31710),
		86:  uint16(31715),
		87:  uint16(31719),
		88:  uint16(31709),
		89:  uint16(31701),
		90:  uint16(31717),
		91:  uint16(31706),
		92:  uint16(31720),
		93:  uint16(31737),
		94:  uint16(31700),
		95:  uint16(31722),
		96:  uint16(31714),
		97:  uint16(31708),
		98:  uint16(31723),
		99:  uint16(31704),
		100: uint16(31711),
		101: uint16(31954),
		102: uint16(31956),
		103: uint16(31959),
		104: uint16(31952),
		105: uint16(31953),
		106: uint16(32274),
		107: uint16(32289),
		108: uint16(32279),
		109: uint16(32268),
		110: uint16(32287),
		111: uint16(32288),
		112: uint16(32275),
		113: uint16(32270),
		114: uint16(32284),
		115: uint16(32277),
		116: uint16(32282),
		117: uint16(32290),
		118: uint16(32267),
		119: uint16(32271),
		120: uint16(32278),
		121: uint16(32269),
		122: uint16(32276),
		123: uint16(32293),
		124: uint16(32292),
		125: uint16(32579),
		126: uint16(32635),
		127: uint16(32636),
		128: uint16(32634),
		129: uint16(32689),
		130: uint16(32751),
		131: uint16(32810),
		132: uint16(32809),
		133: uint16(32876),
		134: uint16(33201),
		135: uint16(33190),
		136: uint16(33198),
		137: uint16(33209),
		138: uint16(33205),
		139: uint16(33195),
		140: uint16(33200),
		141: uint16(33196),
		142: uint16(33204),
		143: uint16(33202),
		144: uint16(33207),
		145: uint16(33191),
		146: uint16(33266),
		147: uint16(33365),
		148: uint16(33366),
		149: uint16(33367),
		150: uint16(34134),
		151: uint16(34117),
		152: uint16(34155),
		153: uint16(34125),
		154: uint16(34131),
		155: uint16(34145),
		156: uint16(34136),
	},
	74: {
		0:   uint16(34112),
		1:   uint16(34118),
		2:   uint16(34148),
		3:   uint16(34113),
		4:   uint16(34146),
		5:   uint16(34116),
		6:   uint16(34129),
		7:   uint16(34119),
		8:   uint16(34147),
		9:   uint16(34110),
		10:  uint16(34139),
		11:  uint16(34161),
		12:  uint16(34126),
		13:  uint16(34158),
		14:  uint16(34165),
		15:  uint16(34133),
		16:  uint16(34151),
		17:  uint16(34144),
		18:  uint16(34188),
		19:  uint16(34150),
		20:  uint16(34141),
		21:  uint16(34132),
		22:  uint16(34149),
		23:  uint16(34156),
		24:  uint16(34403),
		25:  uint16(34405),
		26:  uint16(34404),
		27:  uint16(34715),
		28:  uint16(34703),
		29:  uint16(34711),
		30:  uint16(34707),
		31:  uint16(34706),
		32:  uint16(34696),
		33:  uint16(34689),
		34:  uint16(34710),
		35:  uint16(34712),
		36:  uint16(34681),
		37:  uint16(34695),
		38:  uint16(34723),
		39:  uint16(34693),
		40:  uint16(34704),
		41:  uint16(34705),
		42:  uint16(34717),
		43:  uint16(34692),
		44:  uint16(34708),
		45:  uint16(34716),
		46:  uint16(34714),
		47:  uint16(34697),
		48:  uint16(35102),
		49:  uint16(35110),
		50:  uint16(35120),
		51:  uint16(35117),
		52:  uint16(35118),
		53:  uint16(35111),
		54:  uint16(35121),
		55:  uint16(35106),
		56:  uint16(35113),
		57:  uint16(35107),
		58:  uint16(35119),
		59:  uint16(35116),
		60:  uint16(35103),
		61:  uint16(35313),
		62:  uint16(35552),
		63:  uint16(35554),
		64:  uint16(35570),
		65:  uint16(35572),
		66:  uint16(35573),
		67:  uint16(35549),
		68:  uint16(35604),
		69:  uint16(35556),
		70:  uint16(35551),
		71:  uint16(35568),
		72:  uint16(35528),
		73:  uint16(35550),
		74:  uint16(35553),
		75:  uint16(35560),
		76:  uint16(35583),
		77:  uint16(35567),
		78:  uint16(35579),
		79:  uint16(35985),
		80:  uint16(35986),
		81:  uint16(35984),
		82:  uint16(36085),
		83:  uint16(36078),
		84:  uint16(36081),
		85:  uint16(36080),
		86:  uint16(36083),
		87:  uint16(36204),
		88:  uint16(36206),
		89:  uint16(36261),
		90:  uint16(36263),
		91:  uint16(36403),
		92:  uint16(36414),
		93:  uint16(36408),
		94:  uint16(36416),
		95:  uint16(36421),
		96:  uint16(36406),
		97:  uint16(36412),
		98:  uint16(36413),
		99:  uint16(36417),
		100: uint16(36400),
		101: uint16(36415),
		102: uint16(36541),
		103: uint16(36662),
		104: uint16(36654),
		105: uint16(36661),
		106: uint16(36658),
		107: uint16(36665),
		108: uint16(36663),
		109: uint16(36660),
		110: uint16(36982),
		111: uint16(36985),
		112: uint16(36987),
		113: uint16(36998),
		114: uint16(37114),
		115: uint16(37171),
		116: uint16(37173),
		117: uint16(37174),
		118: uint16(37267),
		119: uint16(37264),
		120: uint16(37265),
		121: uint16(37261),
		122: uint16(37263),
		123: uint16(37671),
		124: uint16(37662),
		125: uint16(37640),
		126: uint16(37663),
		127: uint16(37638),
		128: uint16(37647),
		129: uint16(37754),
		130: uint16(37688),
		131: uint16(37692),
		132: uint16(37659),
		133: uint16(37667),
		134: uint16(37650),
		135: uint16(37633),
		136: uint16(37702),
		137: uint16(37677),
		138: uint16(37646),
		139: uint16(37645),
		140: uint16(37579),
		141: uint16(37661),
		142: uint16(37626),
		143: uint16(37669),
		144: uint16(37651),
		145: uint16(37625),
		146: uint16(37623),
		147: uint16(37684),
		148: uint16(37634),
		149: uint16(37668),
		150: uint16(37631),
		151: uint16(37673),
		152: uint16(37689),
		153: uint16(37685),
		154: uint16(37674),
		155: uint16(37652),
		156: uint16(37644),
	},
	75: {
		0:   uint16(37643),
		1:   uint16(37630),
		2:   uint16(37641),
		3:   uint16(37632),
		4:   uint16(37627),
		5:   uint16(37654),
		6:   uint16(38332),
		7:   uint16(38349),
		8:   uint16(38334),
		9:   uint16(38329),
		10:  uint16(38330),
		11:  uint16(38326),
		12:  uint16(38335),
		13:  uint16(38325),
		14:  uint16(38333),
		15:  uint16(38569),
		16:  uint16(38612),
		17:  uint16(38667),
		18:  uint16(38674),
		19:  uint16(38672),
		20:  uint16(38809),
		21:  uint16(38807),
		22:  uint16(38804),
		23:  uint16(38896),
		24:  uint16(38904),
		25:  uint16(38965),
		26:  uint16(38959),
		27:  uint16(38962),
		28:  uint16(39204),
		29:  uint16(39199),
		30:  uint16(39207),
		31:  uint16(39209),
		32:  uint16(39326),
		33:  uint16(39406),
		34:  uint16(39404),
		35:  uint16(39397),
		36:  uint16(39396),
		37:  uint16(39408),
		38:  uint16(39395),
		39:  uint16(39402),
		40:  uint16(39401),
		41:  uint16(39399),
		42:  uint16(39609),
		43:  uint16(39615),
		44:  uint16(39604),
		45:  uint16(39611),
		46:  uint16(39670),
		47:  uint16(39674),
		48:  uint16(39673),
		49:  uint16(39671),
		50:  uint16(39731),
		51:  uint16(39808),
		52:  uint16(39813),
		53:  uint16(39815),
		54:  uint16(39804),
		55:  uint16(39806),
		56:  uint16(39803),
		57:  uint16(39810),
		58:  uint16(39827),
		59:  uint16(39826),
		60:  uint16(39824),
		61:  uint16(39802),
		62:  uint16(39829),
		63:  uint16(39805),
		64:  uint16(39816),
		65:  uint16(40229),
		66:  uint16(40215),
		67:  uint16(40224),
		68:  uint16(40222),
		69:  uint16(40212),
		70:  uint16(40233),
		71:  uint16(40221),
		72:  uint16(40216),
		73:  uint16(40226),
		74:  uint16(40208),
		75:  uint16(40217),
		76:  uint16(40223),
		77:  uint16(40584),
		78:  uint16(40582),
		79:  uint16(40583),
		80:  uint16(40622),
		81:  uint16(40621),
		82:  uint16(40661),
		83:  uint16(40662),
		84:  uint16(40698),
		85:  uint16(40722),
		86:  uint16(40765),
		87:  uint16(20774),
		88:  uint16(20773),
		89:  uint16(20770),
		90:  uint16(20772),
		91:  uint16(20768),
		92:  uint16(20777),
		93:  uint16(21236),
		94:  uint16(22163),
		95:  uint16(22156),
		96:  uint16(22157),
		97:  uint16(22150),
		98:  uint16(22148),
		99:  uint16(22147),
		100: uint16(22142),
		101: uint16(22146),
		102: uint16(22143),
		103: uint16(22145),
		104: uint16(22742),
		105: uint16(22740),
		106: uint16(22735),
		107: uint16(22738),
		108: uint16(23341),
		109: uint16(23333),
		110: uint16(23346),
		111: uint16(23331),
		112: uint16(23340),
		113: uint16(23335),
		114: uint16(23334),
		115: uint16(23343),
		116: uint16(23342),
		117: uint16(23419),
		118: uint16(23537),
		119: uint16(23538),
		120: uint16(23991),
		121: uint16(24172),
		122: uint16(24170),
		123: uint16(24510),
		124: uint16(24507),
		125: uint16(25027),
		126: uint16(25013),
		127: uint16(25020),
		128: uint16(25063),
		129: uint16(25056),
		130: uint16(25061),
		131: uint16(25060),
		132: uint16(25064),
		133: uint16(25054),
		134: uint16(25839),
		135: uint16(25833),
		136: uint16(25827),
		137: uint16(25835),
		138: uint16(25828),
		139: uint16(25832),
		140: uint16(25985),
		141: uint16(25984),
		142: uint16(26038),
		143: uint16(26074),
		144: uint16(26322),
		145: uint16(27277),
		146: uint16(27286),
		147: uint16(27265),
		148: uint16(27301),
		149: uint16(27273),
		150: uint16(27295),
		151: uint16(27291),
		152: uint16(27297),
		153: uint16(27294),
		154: uint16(27271),
		155: uint16(27283),
		156: uint16(27278),
	},
	76: {
		0:   uint16(27285),
		1:   uint16(27267),
		2:   uint16(27304),
		3:   uint16(27300),
		4:   uint16(27281),
		5:   uint16(27263),
		6:   uint16(27302),
		7:   uint16(27290),
		8:   uint16(27269),
		9:   uint16(27276),
		10:  uint16(27282),
		11:  uint16(27483),
		12:  uint16(27565),
		13:  uint16(27657),
		14:  uint16(28620),
		15:  uint16(28585),
		16:  uint16(28660),
		17:  uint16(28628),
		18:  uint16(28643),
		19:  uint16(28636),
		20:  uint16(28653),
		21:  uint16(28647),
		22:  uint16(28646),
		23:  uint16(28638),
		24:  uint16(28658),
		25:  uint16(28637),
		26:  uint16(28642),
		27:  uint16(28648),
		28:  uint16(29153),
		29:  uint16(29169),
		30:  uint16(29160),
		31:  uint16(29170),
		32:  uint16(29156),
		33:  uint16(29168),
		34:  uint16(29154),
		35:  uint16(29555),
		36:  uint16(29550),
		37:  uint16(29551),
		38:  uint16(29847),
		39:  uint16(29874),
		40:  uint16(29867),
		41:  uint16(29840),
		42:  uint16(29866),
		43:  uint16(29869),
		44:  uint16(29873),
		45:  uint16(29861),
		46:  uint16(29871),
		47:  uint16(29968),
		48:  uint16(29969),
		49:  uint16(29970),
		50:  uint16(29967),
		51:  uint16(30084),
		52:  uint16(30275),
		53:  uint16(30280),
		54:  uint16(30281),
		55:  uint16(30279),
		56:  uint16(30372),
		57:  uint16(30441),
		58:  uint16(30645),
		59:  uint16(30635),
		60:  uint16(30642),
		61:  uint16(30647),
		62:  uint16(30646),
		63:  uint16(30644),
		64:  uint16(30641),
		65:  uint16(30632),
		66:  uint16(30704),
		67:  uint16(30963),
		68:  uint16(30973),
		69:  uint16(30978),
		70:  uint16(30971),
		71:  uint16(30972),
		72:  uint16(30962),
		73:  uint16(30981),
		74:  uint16(30969),
		75:  uint16(30974),
		76:  uint16(30980),
		77:  uint16(31147),
		78:  uint16(31144),
		79:  uint16(31324),
		80:  uint16(31323),
		81:  uint16(31318),
		82:  uint16(31320),
		83:  uint16(31316),
		84:  uint16(31322),
		85:  uint16(31422),
		86:  uint16(31424),
		87:  uint16(31425),
		88:  uint16(31749),
		89:  uint16(31759),
		90:  uint16(31730),
		91:  uint16(31744),
		92:  uint16(31743),
		93:  uint16(31739),
		94:  uint16(31758),
		95:  uint16(31732),
		96:  uint16(31755),
		97:  uint16(31731),
		98:  uint16(31746),
		99:  uint16(31753),
		100: uint16(31747),
		101: uint16(31745),
		102: uint16(31736),
		103: uint16(31741),
		104: uint16(31750),
		105: uint16(31728),
		106: uint16(31729),
		107: uint16(31760),
		108: uint16(31754),
		109: uint16(31976),
		110: uint16(32301),
		111: uint16(32316),
		112: uint16(32322),
		113: uint16(32307),
		114: uint16(38984),
		115: uint16(32312),
		116: uint16(32298),
		117: uint16(32329),
		118: uint16(32320),
		119: uint16(32327),
		120: uint16(32297),
		121: uint16(32332),
		122: uint16(32304),
		123: uint16(32315),
		124: uint16(32310),
		125: uint16(32324),
		126: uint16(32314),
		127: uint16(32581),
		128: uint16(32639),
		129: uint16(32638),
		130: uint16(32637),
		131: uint16(32756),
		132: uint16(32754),
		133: uint16(32812),
		134: uint16(33211),
		135: uint16(33220),
		136: uint16(33228),
		137: uint16(33226),
		138: uint16(33221),
		139: uint16(33223),
		140: uint16(33212),
		141: uint16(33257),
		142: uint16(33371),
		143: uint16(33370),
		144: uint16(33372),
		145: uint16(34179),
		146: uint16(34176),
		147: uint16(34191),
		148: uint16(34215),
		149: uint16(34197),
		150: uint16(34208),
		151: uint16(34187),
		152: uint16(34211),
		153: uint16(34171),
		154: uint16(34212),
		155: uint16(34202),
		156: uint16(34206),
	},
	77: {
		0:   uint16(34167),
		1:   uint16(34172),
		2:   uint16(34185),
		3:   uint16(34209),
		4:   uint16(34170),
		5:   uint16(34168),
		6:   uint16(34135),
		7:   uint16(34190),
		8:   uint16(34198),
		9:   uint16(34182),
		10:  uint16(34189),
		11:  uint16(34201),
		12:  uint16(34205),
		13:  uint16(34177),
		14:  uint16(34210),
		15:  uint16(34178),
		16:  uint16(34184),
		17:  uint16(34181),
		18:  uint16(34169),
		19:  uint16(34166),
		20:  uint16(34200),
		21:  uint16(34192),
		22:  uint16(34207),
		23:  uint16(34408),
		24:  uint16(34750),
		25:  uint16(34730),
		26:  uint16(34733),
		27:  uint16(34757),
		28:  uint16(34736),
		29:  uint16(34732),
		30:  uint16(34745),
		31:  uint16(34741),
		32:  uint16(34748),
		33:  uint16(34734),
		34:  uint16(34761),
		35:  uint16(34755),
		36:  uint16(34754),
		37:  uint16(34764),
		38:  uint16(34743),
		39:  uint16(34735),
		40:  uint16(34756),
		41:  uint16(34762),
		42:  uint16(34740),
		43:  uint16(34742),
		44:  uint16(34751),
		45:  uint16(34744),
		46:  uint16(34749),
		47:  uint16(34782),
		48:  uint16(34738),
		49:  uint16(35125),
		50:  uint16(35123),
		51:  uint16(35132),
		52:  uint16(35134),
		53:  uint16(35137),
		54:  uint16(35154),
		55:  uint16(35127),
		56:  uint16(35138),
		57:  uint16(35245),
		58:  uint16(35247),
		59:  uint16(35246),
		60:  uint16(35314),
		61:  uint16(35315),
		62:  uint16(35614),
		63:  uint16(35608),
		64:  uint16(35606),
		65:  uint16(35601),
		66:  uint16(35589),
		67:  uint16(35595),
		68:  uint16(35618),
		69:  uint16(35599),
		70:  uint16(35602),
		71:  uint16(35605),
		72:  uint16(35591),
		73:  uint16(35597),
		74:  uint16(35592),
		75:  uint16(35590),
		76:  uint16(35612),
		77:  uint16(35603),
		78:  uint16(35610),
		79:  uint16(35919),
		80:  uint16(35952),
		81:  uint16(35954),
		82:  uint16(35953),
		83:  uint16(35951),
		84:  uint16(35989),
		85:  uint16(35988),
		86:  uint16(36089),
		87:  uint16(36207),
		88:  uint16(36430),
		89:  uint16(36429),
		90:  uint16(36435),
		91:  uint16(36432),
		92:  uint16(36428),
		93:  uint16(36423),
		94:  uint16(36675),
		95:  uint16(36672),
		96:  uint16(36997),
		97:  uint16(36990),
		98:  uint16(37176),
		99:  uint16(37274),
		100: uint16(37282),
		101: uint16(37275),
		102: uint16(37273),
		103: uint16(37279),
		104: uint16(37281),
		105: uint16(37277),
		106: uint16(37280),
		107: uint16(37793),
		108: uint16(37763),
		109: uint16(37807),
		110: uint16(37732),
		111: uint16(37718),
		112: uint16(37703),
		113: uint16(37756),
		114: uint16(37720),
		115: uint16(37724),
		116: uint16(37750),
		117: uint16(37705),
		118: uint16(37712),
		119: uint16(37713),
		120: uint16(37728),
		121: uint16(37741),
		122: uint16(37775),
		123: uint16(37708),
		124: uint16(37738),
		125: uint16(37753),
		126: uint16(37719),
		127: uint16(37717),
		128: uint16(37714),
		129: uint16(37711),
		130: uint16(37745),
		131: uint16(37751),
		132: uint16(37755),
		133: uint16(37729),
		134: uint16(37726),
		135: uint16(37731),
		136: uint16(37735),
		137: uint16(37760),
		138: uint16(37710),
		139: uint16(37721),
		140: uint16(38343),
		141: uint16(38336),
		142: uint16(38345),
		143: uint16(38339),
		144: uint16(38341),
		145: uint16(38327),
		146: uint16(38574),
		147: uint16(38576),
		148: uint16(38572),
		149: uint16(38688),
		150: uint16(38687),
		151: uint16(38680),
		152: uint16(38685),
		153: uint16(38681),
		154: uint16(38810),
		155: uint16(38817),
		156: uint16(38812),
	},
	78: {
		0:   uint16(38814),
		1:   uint16(38813),
		2:   uint16(38869),
		3:   uint16(38868),
		4:   uint16(38897),
		5:   uint16(38977),
		6:   uint16(38980),
		7:   uint16(38986),
		8:   uint16(38985),
		9:   uint16(38981),
		10:  uint16(38979),
		11:  uint16(39205),
		12:  uint16(39211),
		13:  uint16(39212),
		14:  uint16(39210),
		15:  uint16(39219),
		16:  uint16(39218),
		17:  uint16(39215),
		18:  uint16(39213),
		19:  uint16(39217),
		20:  uint16(39216),
		21:  uint16(39320),
		22:  uint16(39331),
		23:  uint16(39329),
		24:  uint16(39426),
		25:  uint16(39418),
		26:  uint16(39412),
		27:  uint16(39415),
		28:  uint16(39417),
		29:  uint16(39416),
		30:  uint16(39414),
		31:  uint16(39419),
		32:  uint16(39421),
		33:  uint16(39422),
		34:  uint16(39420),
		35:  uint16(39427),
		36:  uint16(39614),
		37:  uint16(39678),
		38:  uint16(39677),
		39:  uint16(39681),
		40:  uint16(39676),
		41:  uint16(39752),
		42:  uint16(39834),
		43:  uint16(39848),
		44:  uint16(39838),
		45:  uint16(39835),
		46:  uint16(39846),
		47:  uint16(39841),
		48:  uint16(39845),
		49:  uint16(39844),
		50:  uint16(39814),
		51:  uint16(39842),
		52:  uint16(39840),
		53:  uint16(39855),
		54:  uint16(40243),
		55:  uint16(40257),
		56:  uint16(40295),
		57:  uint16(40246),
		58:  uint16(40238),
		59:  uint16(40239),
		60:  uint16(40241),
		61:  uint16(40248),
		62:  uint16(40240),
		63:  uint16(40261),
		64:  uint16(40258),
		65:  uint16(40259),
		66:  uint16(40254),
		67:  uint16(40247),
		68:  uint16(40256),
		69:  uint16(40253),
		70:  uint16(32757),
		71:  uint16(40237),
		72:  uint16(40586),
		73:  uint16(40585),
		74:  uint16(40589),
		75:  uint16(40624),
		76:  uint16(40648),
		77:  uint16(40666),
		78:  uint16(40699),
		79:  uint16(40703),
		80:  uint16(40740),
		81:  uint16(40739),
		82:  uint16(40738),
		83:  uint16(40788),
		84:  uint16(40864),
		85:  uint16(20785),
		86:  uint16(20781),
		87:  uint16(20782),
		88:  uint16(22168),
		89:  uint16(22172),
		90:  uint16(22167),
		91:  uint16(22170),
		92:  uint16(22173),
		93:  uint16(22169),
		94:  uint16(22896),
		95:  uint16(23356),
		96:  uint16(23657),
		97:  uint16(23658),
		98:  uint16(24000),
		99:  uint16(24173),
		100: uint16(24174),
		101: uint16(25048),
		102: uint16(25055),
		103: uint16(25069),
		104: uint16(25070),
		105: uint16(25073),
		106: uint16(25066),
		107: uint16(25072),
		108: uint16(25067),
		109: uint16(25046),
		110: uint16(25065),
		111: uint16(25855),
		112: uint16(25860),
		113: uint16(25853),
		114: uint16(25848),
		115: uint16(25857),
		116: uint16(25859),
		117: uint16(25852),
		118: uint16(26004),
		119: uint16(26075),
		120: uint16(26330),
		121: uint16(26331),
		122: uint16(26328),
		123: uint16(27333),
		124: uint16(27321),
		125: uint16(27325),
		126: uint16(27361),
		127: uint16(27334),
		128: uint16(27322),
		129: uint16(27318),
		130: uint16(27319),
		131: uint16(27335),
		132: uint16(27316),
		133: uint16(27309),
		134: uint16(27486),
		135: uint16(27593),
		136: uint16(27659),
		137: uint16(28679),
		138: uint16(28684),
		139: uint16(28685),
		140: uint16(28673),
		141: uint16(28677),
		142: uint16(28692),
		143: uint16(28686),
		144: uint16(28671),
		145: uint16(28672),
		146: uint16(28667),
		147: uint16(28710),
		148: uint16(28668),
		149: uint16(28663),
		150: uint16(28682),
		151: uint16(29185),
		152: uint16(29183),
		153: uint16(29177),
		154: uint16(29187),
		155: uint16(29181),
		156: uint16(29558),
	},
	79: {
		0:   uint16(29880),
		1:   uint16(29888),
		2:   uint16(29877),
		3:   uint16(29889),
		4:   uint16(29886),
		5:   uint16(29878),
		6:   uint16(29883),
		7:   uint16(29890),
		8:   uint16(29972),
		9:   uint16(29971),
		10:  uint16(30300),
		11:  uint16(30308),
		12:  uint16(30297),
		13:  uint16(30288),
		14:  uint16(30291),
		15:  uint16(30295),
		16:  uint16(30298),
		17:  uint16(30374),
		18:  uint16(30397),
		19:  uint16(30444),
		20:  uint16(30658),
		21:  uint16(30650),
		22:  uint16(30975),
		23:  uint16(30988),
		24:  uint16(30995),
		25:  uint16(30996),
		26:  uint16(30985),
		27:  uint16(30992),
		28:  uint16(30994),
		29:  uint16(30993),
		30:  uint16(31149),
		31:  uint16(31148),
		32:  uint16(31327),
		33:  uint16(31772),
		34:  uint16(31785),
		35:  uint16(31769),
		36:  uint16(31776),
		37:  uint16(31775),
		38:  uint16(31789),
		39:  uint16(31773),
		40:  uint16(31782),
		41:  uint16(31784),
		42:  uint16(31778),
		43:  uint16(31781),
		44:  uint16(31792),
		45:  uint16(32348),
		46:  uint16(32336),
		47:  uint16(32342),
		48:  uint16(32355),
		49:  uint16(32344),
		50:  uint16(32354),
		51:  uint16(32351),
		52:  uint16(32337),
		53:  uint16(32352),
		54:  uint16(32343),
		55:  uint16(32339),
		56:  uint16(32693),
		57:  uint16(32691),
		58:  uint16(32759),
		59:  uint16(32760),
		60:  uint16(32885),
		61:  uint16(33233),
		62:  uint16(33234),
		63:  uint16(33232),
		64:  uint16(33375),
		65:  uint16(33374),
		66:  uint16(34228),
		67:  uint16(34246),
		68:  uint16(34240),
		69:  uint16(34243),
		70:  uint16(34242),
		71:  uint16(34227),
		72:  uint16(34229),
		73:  uint16(34237),
		74:  uint16(34247),
		75:  uint16(34244),
		76:  uint16(34239),
		77:  uint16(34251),
		78:  uint16(34254),
		79:  uint16(34248),
		80:  uint16(34245),
		81:  uint16(34225),
		82:  uint16(34230),
		83:  uint16(34258),
		84:  uint16(34340),
		85:  uint16(34232),
		86:  uint16(34231),
		87:  uint16(34238),
		88:  uint16(34409),
		89:  uint16(34791),
		90:  uint16(34790),
		91:  uint16(34786),
		92:  uint16(34779),
		93:  uint16(34795),
		94:  uint16(34794),
		95:  uint16(34789),
		96:  uint16(34783),
		97:  uint16(34803),
		98:  uint16(34788),
		99:  uint16(34772),
		100: uint16(34780),
		101: uint16(34771),
		102: uint16(34797),
		103: uint16(34776),
		104: uint16(34787),
		105: uint16(34724),
		106: uint16(34775),
		107: uint16(34777),
		108: uint16(34817),
		109: uint16(34804),
		110: uint16(34792),
		111: uint16(34781),
		112: uint16(35155),
		113: uint16(35147),
		114: uint16(35151),
		115: uint16(35148),
		116: uint16(35142),
		117: uint16(35152),
		118: uint16(35153),
		119: uint16(35145),
		120: uint16(35626),
		121: uint16(35623),
		122: uint16(35619),
		123: uint16(35635),
		124: uint16(35632),
		125: uint16(35637),
		126: uint16(35655),
		127: uint16(35631),
		128: uint16(35644),
		129: uint16(35646),
		130: uint16(35633),
		131: uint16(35621),
		132: uint16(35639),
		133: uint16(35622),
		134: uint16(35638),
		135: uint16(35630),
		136: uint16(35620),
		137: uint16(35643),
		138: uint16(35645),
		139: uint16(35642),
		140: uint16(35906),
		141: uint16(35957),
		142: uint16(35993),
		143: uint16(35992),
		144: uint16(35991),
		145: uint16(36094),
		146: uint16(36100),
		147: uint16(36098),
		148: uint16(36096),
		149: uint16(36444),
		150: uint16(36450),
		151: uint16(36448),
		152: uint16(36439),
		153: uint16(36438),
		154: uint16(36446),
		155: uint16(36453),
		156: uint16(36455),
	},
	80: {
		0:   uint16(36443),
		1:   uint16(36442),
		2:   uint16(36449),
		3:   uint16(36445),
		4:   uint16(36457),
		5:   uint16(36436),
		6:   uint16(36678),
		7:   uint16(36679),
		8:   uint16(36680),
		9:   uint16(36683),
		10:  uint16(37160),
		11:  uint16(37178),
		12:  uint16(37179),
		13:  uint16(37182),
		14:  uint16(37288),
		15:  uint16(37285),
		16:  uint16(37287),
		17:  uint16(37295),
		18:  uint16(37290),
		19:  uint16(37813),
		20:  uint16(37772),
		21:  uint16(37778),
		22:  uint16(37815),
		23:  uint16(37787),
		24:  uint16(37789),
		25:  uint16(37769),
		26:  uint16(37799),
		27:  uint16(37774),
		28:  uint16(37802),
		29:  uint16(37790),
		30:  uint16(37798),
		31:  uint16(37781),
		32:  uint16(37768),
		33:  uint16(37785),
		34:  uint16(37791),
		35:  uint16(37773),
		36:  uint16(37809),
		37:  uint16(37777),
		38:  uint16(37810),
		39:  uint16(37796),
		40:  uint16(37800),
		41:  uint16(37812),
		42:  uint16(37795),
		43:  uint16(37797),
		44:  uint16(38354),
		45:  uint16(38355),
		46:  uint16(38353),
		47:  uint16(38579),
		48:  uint16(38615),
		49:  uint16(38618),
		50:  uint16(24002),
		51:  uint16(38623),
		52:  uint16(38616),
		53:  uint16(38621),
		54:  uint16(38691),
		55:  uint16(38690),
		56:  uint16(38693),
		57:  uint16(38828),
		58:  uint16(38830),
		59:  uint16(38824),
		60:  uint16(38827),
		61:  uint16(38820),
		62:  uint16(38826),
		63:  uint16(38818),
		64:  uint16(38821),
		65:  uint16(38871),
		66:  uint16(38873),
		67:  uint16(38870),
		68:  uint16(38872),
		69:  uint16(38906),
		70:  uint16(38992),
		71:  uint16(38993),
		72:  uint16(38994),
		73:  uint16(39096),
		74:  uint16(39233),
		75:  uint16(39228),
		76:  uint16(39226),
		77:  uint16(39439),
		78:  uint16(39435),
		79:  uint16(39433),
		80:  uint16(39437),
		81:  uint16(39428),
		82:  uint16(39441),
		83:  uint16(39434),
		84:  uint16(39429),
		85:  uint16(39431),
		86:  uint16(39430),
		87:  uint16(39616),
		88:  uint16(39644),
		89:  uint16(39688),
		90:  uint16(39684),
		91:  uint16(39685),
		92:  uint16(39721),
		93:  uint16(39733),
		94:  uint16(39754),
		95:  uint16(39756),
		96:  uint16(39755),
		97:  uint16(39879),
		98:  uint16(39878),
		99:  uint16(39875),
		100: uint16(39871),
		101: uint16(39873),
		102: uint16(39861),
		103: uint16(39864),
		104: uint16(39891),
		105: uint16(39862),
		106: uint16(39876),
		107: uint16(39865),
		108: uint16(39869),
		109: uint16(40284),
		110: uint16(40275),
		111: uint16(40271),
		112: uint16(40266),
		113: uint16(40283),
		114: uint16(40267),
		115: uint16(40281),
		116: uint16(40278),
		117: uint16(40268),
		118: uint16(40279),
		119: uint16(40274),
		120: uint16(40276),
		121: uint16(40287),
		122: uint16(40280),
		123: uint16(40282),
		124: uint16(40590),
		125: uint16(40588),
		126: uint16(40671),
		127: uint16(40705),
		128: uint16(40704),
		129: uint16(40726),
		130: uint16(40741),
		131: uint16(40747),
		132: uint16(40746),
		133: uint16(40745),
		134: uint16(40744),
		135: uint16(40780),
		136: uint16(40789),
		137: uint16(20788),
		138: uint16(20789),
		139: uint16(21142),
		140: uint16(21239),
		141: uint16(21428),
		142: uint16(22187),
		143: uint16(22189),
		144: uint16(22182),
		145: uint16(22183),
		146: uint16(22186),
		147: uint16(22188),
		148: uint16(22746),
		149: uint16(22749),
		150: uint16(22747),
		151: uint16(22802),
		152: uint16(23357),
		153: uint16(23358),
		154: uint16(23359),
		155: uint16(24003),
		156: uint16(24176),
	},
	81: {
		0:   uint16(24511),
		1:   uint16(25083),
		2:   uint16(25863),
		3:   uint16(25872),
		4:   uint16(25869),
		5:   uint16(25865),
		6:   uint16(25868),
		7:   uint16(25870),
		8:   uint16(25988),
		9:   uint16(26078),
		10:  uint16(26077),
		11:  uint16(26334),
		12:  uint16(27367),
		13:  uint16(27360),
		14:  uint16(27340),
		15:  uint16(27345),
		16:  uint16(27353),
		17:  uint16(27339),
		18:  uint16(27359),
		19:  uint16(27356),
		20:  uint16(27344),
		21:  uint16(27371),
		22:  uint16(27343),
		23:  uint16(27341),
		24:  uint16(27358),
		25:  uint16(27488),
		26:  uint16(27568),
		27:  uint16(27660),
		28:  uint16(28697),
		29:  uint16(28711),
		30:  uint16(28704),
		31:  uint16(28694),
		32:  uint16(28715),
		33:  uint16(28705),
		34:  uint16(28706),
		35:  uint16(28707),
		36:  uint16(28713),
		37:  uint16(28695),
		38:  uint16(28708),
		39:  uint16(28700),
		40:  uint16(28714),
		41:  uint16(29196),
		42:  uint16(29194),
		43:  uint16(29191),
		44:  uint16(29186),
		45:  uint16(29189),
		46:  uint16(29349),
		47:  uint16(29350),
		48:  uint16(29348),
		49:  uint16(29347),
		50:  uint16(29345),
		51:  uint16(29899),
		52:  uint16(29893),
		53:  uint16(29879),
		54:  uint16(29891),
		55:  uint16(29974),
		56:  uint16(30304),
		57:  uint16(30665),
		58:  uint16(30666),
		59:  uint16(30660),
		60:  uint16(30705),
		61:  uint16(31005),
		62:  uint16(31003),
		63:  uint16(31009),
		64:  uint16(31004),
		65:  uint16(30999),
		66:  uint16(31006),
		67:  uint16(31152),
		68:  uint16(31335),
		69:  uint16(31336),
		70:  uint16(31795),
		71:  uint16(31804),
		72:  uint16(31801),
		73:  uint16(31788),
		74:  uint16(31803),
		75:  uint16(31980),
		76:  uint16(31978),
		77:  uint16(32374),
		78:  uint16(32373),
		79:  uint16(32376),
		80:  uint16(32368),
		81:  uint16(32375),
		82:  uint16(32367),
		83:  uint16(32378),
		84:  uint16(32370),
		85:  uint16(32372),
		86:  uint16(32360),
		87:  uint16(32587),
		88:  uint16(32586),
		89:  uint16(32643),
		90:  uint16(32646),
		91:  uint16(32695),
		92:  uint16(32765),
		93:  uint16(32766),
		94:  uint16(32888),
		95:  uint16(33239),
		96:  uint16(33237),
		97:  uint16(33380),
		98:  uint16(33377),
		99:  uint16(33379),
		100: uint16(34283),
		101: uint16(34289),
		102: uint16(34285),
		103: uint16(34265),
		104: uint16(34273),
		105: uint16(34280),
		106: uint16(34266),
		107: uint16(34263),
		108: uint16(34284),
		109: uint16(34290),
		110: uint16(34296),
		111: uint16(34264),
		112: uint16(34271),
		113: uint16(34275),
		114: uint16(34268),
		115: uint16(34257),
		116: uint16(34288),
		117: uint16(34278),
		118: uint16(34287),
		119: uint16(34270),
		120: uint16(34274),
		121: uint16(34816),
		122: uint16(34810),
		123: uint16(34819),
		124: uint16(34806),
		125: uint16(34807),
		126: uint16(34825),
		127: uint16(34828),
		128: uint16(34827),
		129: uint16(34822),
		130: uint16(34812),
		131: uint16(34824),
		132: uint16(34815),
		133: uint16(34826),
		134: uint16(34818),
		135: uint16(35170),
		136: uint16(35162),
		137: uint16(35163),
		138: uint16(35159),
		139: uint16(35169),
		140: uint16(35164),
		141: uint16(35160),
		142: uint16(35165),
		143: uint16(35161),
		144: uint16(35208),
		145: uint16(35255),
		146: uint16(35254),
		147: uint16(35318),
		148: uint16(35664),
		149: uint16(35656),
		150: uint16(35658),
		151: uint16(35648),
		152: uint16(35667),
		153: uint16(35670),
		154: uint16(35668),
		155: uint16(35659),
		156: uint16(35669),
	},
	82: {
		0:   uint16(35665),
		1:   uint16(35650),
		2:   uint16(35666),
		3:   uint16(35671),
		4:   uint16(35907),
		5:   uint16(35959),
		6:   uint16(35958),
		7:   uint16(35994),
		8:   uint16(36102),
		9:   uint16(36103),
		10:  uint16(36105),
		11:  uint16(36268),
		12:  uint16(36266),
		13:  uint16(36269),
		14:  uint16(36267),
		15:  uint16(36461),
		16:  uint16(36472),
		17:  uint16(36467),
		18:  uint16(36458),
		19:  uint16(36463),
		20:  uint16(36475),
		21:  uint16(36546),
		22:  uint16(36690),
		23:  uint16(36689),
		24:  uint16(36687),
		25:  uint16(36688),
		26:  uint16(36691),
		27:  uint16(36788),
		28:  uint16(37184),
		29:  uint16(37183),
		30:  uint16(37296),
		31:  uint16(37293),
		32:  uint16(37854),
		33:  uint16(37831),
		34:  uint16(37839),
		35:  uint16(37826),
		36:  uint16(37850),
		37:  uint16(37840),
		38:  uint16(37881),
		39:  uint16(37868),
		40:  uint16(37836),
		41:  uint16(37849),
		42:  uint16(37801),
		43:  uint16(37862),
		44:  uint16(37834),
		45:  uint16(37844),
		46:  uint16(37870),
		47:  uint16(37859),
		48:  uint16(37845),
		49:  uint16(37828),
		50:  uint16(37838),
		51:  uint16(37824),
		52:  uint16(37842),
		53:  uint16(37863),
		54:  uint16(38269),
		55:  uint16(38362),
		56:  uint16(38363),
		57:  uint16(38625),
		58:  uint16(38697),
		59:  uint16(38699),
		60:  uint16(38700),
		61:  uint16(38696),
		62:  uint16(38694),
		63:  uint16(38835),
		64:  uint16(38839),
		65:  uint16(38838),
		66:  uint16(38877),
		67:  uint16(38878),
		68:  uint16(38879),
		69:  uint16(39004),
		70:  uint16(39001),
		71:  uint16(39005),
		72:  uint16(38999),
		73:  uint16(39103),
		74:  uint16(39101),
		75:  uint16(39099),
		76:  uint16(39102),
		77:  uint16(39240),
		78:  uint16(39239),
		79:  uint16(39235),
		80:  uint16(39334),
		81:  uint16(39335),
		82:  uint16(39450),
		83:  uint16(39445),
		84:  uint16(39461),
		85:  uint16(39453),
		86:  uint16(39460),
		87:  uint16(39451),
		88:  uint16(39458),
		89:  uint16(39456),
		90:  uint16(39463),
		91:  uint16(39459),
		92:  uint16(39454),
		93:  uint16(39452),
		94:  uint16(39444),
		95:  uint16(39618),
		96:  uint16(39691),
		97:  uint16(39690),
		98:  uint16(39694),
		99:  uint16(39692),
		100: uint16(39735),
		101: uint16(39914),
		102: uint16(39915),
		103: uint16(39904),
		104: uint16(39902),
		105: uint16(39908),
		106: uint16(39910),
		107: uint16(39906),
		108: uint16(39920),
		109: uint16(39892),
		110: uint16(39895),
		111: uint16(39916),
		112: uint16(39900),
		113: uint16(39897),
		114: uint16(39909),
		115: uint16(39893),
		116: uint16(39905),
		117: uint16(39898),
		118: uint16(40311),
		119: uint16(40321),
		120: uint16(40330),
		121: uint16(40324),
		122: uint16(40328),
		123: uint16(40305),
		124: uint16(40320),
		125: uint16(40312),
		126: uint16(40326),
		127: uint16(40331),
		128: uint16(40332),
		129: uint16(40317),
		130: uint16(40299),
		131: uint16(40308),
		132: uint16(40309),
		133: uint16(40304),
		134: uint16(40297),
		135: uint16(40325),
		136: uint16(40307),
		137: uint16(40315),
		138: uint16(40322),
		139: uint16(40303),
		140: uint16(40313),
		141: uint16(40319),
		142: uint16(40327),
		143: uint16(40296),
		144: uint16(40596),
		145: uint16(40593),
		146: uint16(40640),
		147: uint16(40700),
		148: uint16(40749),
		149: uint16(40768),
		150: uint16(40769),
		151: uint16(40781),
		152: uint16(40790),
		153: uint16(40791),
		154: uint16(40792),
		155: uint16(21303),
		156: uint16(22194),
	},
	83: {
		0:   uint16(22197),
		1:   uint16(22195),
		2:   uint16(22755),
		3:   uint16(23365),
		4:   uint16(24006),
		5:   uint16(24007),
		6:   uint16(24302),
		7:   uint16(24303),
		8:   uint16(24512),
		9:   uint16(24513),
		10:  uint16(25081),
		11:  uint16(25879),
		12:  uint16(25878),
		13:  uint16(25877),
		14:  uint16(25875),
		15:  uint16(26079),
		16:  uint16(26344),
		17:  uint16(26339),
		18:  uint16(26340),
		19:  uint16(27379),
		20:  uint16(27376),
		21:  uint16(27370),
		22:  uint16(27368),
		23:  uint16(27385),
		24:  uint16(27377),
		25:  uint16(27374),
		26:  uint16(27375),
		27:  uint16(28732),
		28:  uint16(28725),
		29:  uint16(28719),
		30:  uint16(28727),
		31:  uint16(28724),
		32:  uint16(28721),
		33:  uint16(28738),
		34:  uint16(28728),
		35:  uint16(28735),
		36:  uint16(28730),
		37:  uint16(28729),
		38:  uint16(28736),
		39:  uint16(28731),
		40:  uint16(28723),
		41:  uint16(28737),
		42:  uint16(29203),
		43:  uint16(29204),
		44:  uint16(29352),
		45:  uint16(29565),
		46:  uint16(29564),
		47:  uint16(29882),
		48:  uint16(30379),
		49:  uint16(30378),
		50:  uint16(30398),
		51:  uint16(30445),
		52:  uint16(30668),
		53:  uint16(30670),
		54:  uint16(30671),
		55:  uint16(30669),
		56:  uint16(30706),
		57:  uint16(31013),
		58:  uint16(31011),
		59:  uint16(31015),
		60:  uint16(31016),
		61:  uint16(31012),
		62:  uint16(31017),
		63:  uint16(31154),
		64:  uint16(31342),
		65:  uint16(31340),
		66:  uint16(31341),
		67:  uint16(31479),
		68:  uint16(31817),
		69:  uint16(31816),
		70:  uint16(31818),
		71:  uint16(31815),
		72:  uint16(31813),
		73:  uint16(31982),
		74:  uint16(32379),
		75:  uint16(32382),
		76:  uint16(32385),
		77:  uint16(32384),
		78:  uint16(32698),
		79:  uint16(32767),
		80:  uint16(32889),
		81:  uint16(33243),
		82:  uint16(33241),
		83:  uint16(33291),
		84:  uint16(33384),
		85:  uint16(33385),
		86:  uint16(34338),
		87:  uint16(34303),
		88:  uint16(34305),
		89:  uint16(34302),
		90:  uint16(34331),
		91:  uint16(34304),
		92:  uint16(34294),
		93:  uint16(34308),
		94:  uint16(34313),
		95:  uint16(34309),
		96:  uint16(34316),
		97:  uint16(34301),
		98:  uint16(34841),
		99:  uint16(34832),
		100: uint16(34833),
		101: uint16(34839),
		102: uint16(34835),
		103: uint16(34838),
		104: uint16(35171),
		105: uint16(35174),
		106: uint16(35257),
		107: uint16(35319),
		108: uint16(35680),
		109: uint16(35690),
		110: uint16(35677),
		111: uint16(35688),
		112: uint16(35683),
		113: uint16(35685),
		114: uint16(35687),
		115: uint16(35693),
		116: uint16(36270),
		117: uint16(36486),
		118: uint16(36488),
		119: uint16(36484),
		120: uint16(36697),
		121: uint16(36694),
		122: uint16(36695),
		123: uint16(36693),
		124: uint16(36696),
		125: uint16(36698),
		126: uint16(37005),
		127: uint16(37187),
		128: uint16(37185),
		129: uint16(37303),
		130: uint16(37301),
		131: uint16(37298),
		132: uint16(37299),
		133: uint16(37899),
		134: uint16(37907),
		135: uint16(37883),
		136: uint16(37920),
		137: uint16(37903),
		138: uint16(37908),
		139: uint16(37886),
		140: uint16(37909),
		141: uint16(37904),
		142: uint16(37928),
		143: uint16(37913),
		144: uint16(37901),
		145: uint16(37877),
		146: uint16(37888),
		147: uint16(37879),
		148: uint16(37895),
		149: uint16(37902),
		150: uint16(37910),
		151: uint16(37906),
		152: uint16(37882),
		153: uint16(37897),
		154: uint16(37880),
		155: uint16(37898),
		156: uint16(37887),
	},
	84: {
		0:   uint16(37884),
		1:   uint16(37900),
		2:   uint16(37878),
		3:   uint16(37905),
		4:   uint16(37894),
		5:   uint16(38366),
		6:   uint16(38368),
		7:   uint16(38367),
		8:   uint16(38702),
		9:   uint16(38703),
		10:  uint16(38841),
		11:  uint16(38843),
		12:  uint16(38909),
		13:  uint16(38910),
		14:  uint16(39008),
		15:  uint16(39010),
		16:  uint16(39011),
		17:  uint16(39007),
		18:  uint16(39105),
		19:  uint16(39106),
		20:  uint16(39248),
		21:  uint16(39246),
		22:  uint16(39257),
		23:  uint16(39244),
		24:  uint16(39243),
		25:  uint16(39251),
		26:  uint16(39474),
		27:  uint16(39476),
		28:  uint16(39473),
		29:  uint16(39468),
		30:  uint16(39466),
		31:  uint16(39478),
		32:  uint16(39465),
		33:  uint16(39470),
		34:  uint16(39480),
		35:  uint16(39469),
		36:  uint16(39623),
		37:  uint16(39626),
		38:  uint16(39622),
		39:  uint16(39696),
		40:  uint16(39698),
		41:  uint16(39697),
		42:  uint16(39947),
		43:  uint16(39944),
		44:  uint16(39927),
		45:  uint16(39941),
		46:  uint16(39954),
		47:  uint16(39928),
		48:  uint16(40000),
		49:  uint16(39943),
		50:  uint16(39950),
		51:  uint16(39942),
		52:  uint16(39959),
		53:  uint16(39956),
		54:  uint16(39945),
		55:  uint16(40351),
		56:  uint16(40345),
		57:  uint16(40356),
		58:  uint16(40349),
		59:  uint16(40338),
		60:  uint16(40344),
		61:  uint16(40336),
		62:  uint16(40347),
		63:  uint16(40352),
		64:  uint16(40340),
		65:  uint16(40348),
		66:  uint16(40362),
		67:  uint16(40343),
		68:  uint16(40353),
		69:  uint16(40346),
		70:  uint16(40354),
		71:  uint16(40360),
		72:  uint16(40350),
		73:  uint16(40355),
		74:  uint16(40383),
		75:  uint16(40361),
		76:  uint16(40342),
		77:  uint16(40358),
		78:  uint16(40359),
		79:  uint16(40601),
		80:  uint16(40603),
		81:  uint16(40602),
		82:  uint16(40677),
		83:  uint16(40676),
		84:  uint16(40679),
		85:  uint16(40678),
		86:  uint16(40752),
		87:  uint16(40750),
		88:  uint16(40795),
		89:  uint16(40800),
		90:  uint16(40798),
		91:  uint16(40797),
		92:  uint16(40793),
		93:  uint16(40849),
		94:  uint16(20794),
		95:  uint16(20793),
		96:  uint16(21144),
		97:  uint16(21143),
		98:  uint16(22211),
		99:  uint16(22205),
		100: uint16(22206),
		101: uint16(23368),
		102: uint16(23367),
		103: uint16(24011),
		104: uint16(24015),
		105: uint16(24305),
		106: uint16(25085),
		107: uint16(25883),
		108: uint16(27394),
		109: uint16(27388),
		110: uint16(27395),
		111: uint16(27384),
		112: uint16(27392),
		113: uint16(28739),
		114: uint16(28740),
		115: uint16(28746),
		116: uint16(28744),
		117: uint16(28745),
		118: uint16(28741),
		119: uint16(28742),
		120: uint16(29213),
		121: uint16(29210),
		122: uint16(29209),
		123: uint16(29566),
		124: uint16(29975),
		125: uint16(30314),
		126: uint16(30672),
		127: uint16(31021),
		128: uint16(31025),
		129: uint16(31023),
		130: uint16(31828),
		131: uint16(31827),
		132: uint16(31986),
		133: uint16(32394),
		134: uint16(32391),
		135: uint16(32392),
		136: uint16(32395),
		137: uint16(32390),
		138: uint16(32397),
		139: uint16(32589),
		140: uint16(32699),
		141: uint16(32816),
		142: uint16(33245),
		143: uint16(34328),
		144: uint16(34346),
		145: uint16(34342),
		146: uint16(34335),
		147: uint16(34339),
		148: uint16(34332),
		149: uint16(34329),
		150: uint16(34343),
		151: uint16(34350),
		152: uint16(34337),
		153: uint16(34336),
		154: uint16(34345),
		155: uint16(34334),
		156: uint16(34341),
	},
	85: {
		0:   uint16(34857),
		1:   uint16(34845),
		2:   uint16(34843),
		3:   uint16(34848),
		4:   uint16(34852),
		5:   uint16(34844),
		6:   uint16(34859),
		7:   uint16(34890),
		8:   uint16(35181),
		9:   uint16(35177),
		10:  uint16(35182),
		11:  uint16(35179),
		12:  uint16(35322),
		13:  uint16(35705),
		14:  uint16(35704),
		15:  uint16(35653),
		16:  uint16(35706),
		17:  uint16(35707),
		18:  uint16(36112),
		19:  uint16(36116),
		20:  uint16(36271),
		21:  uint16(36494),
		22:  uint16(36492),
		23:  uint16(36702),
		24:  uint16(36699),
		25:  uint16(36701),
		26:  uint16(37190),
		27:  uint16(37188),
		28:  uint16(37189),
		29:  uint16(37305),
		30:  uint16(37951),
		31:  uint16(37947),
		32:  uint16(37942),
		33:  uint16(37929),
		34:  uint16(37949),
		35:  uint16(37948),
		36:  uint16(37936),
		37:  uint16(37945),
		38:  uint16(37930),
		39:  uint16(37943),
		40:  uint16(37932),
		41:  uint16(37952),
		42:  uint16(37937),
		43:  uint16(38373),
		44:  uint16(38372),
		45:  uint16(38371),
		46:  uint16(38709),
		47:  uint16(38714),
		48:  uint16(38847),
		49:  uint16(38881),
		50:  uint16(39012),
		51:  uint16(39113),
		52:  uint16(39110),
		53:  uint16(39104),
		54:  uint16(39256),
		55:  uint16(39254),
		56:  uint16(39481),
		57:  uint16(39485),
		58:  uint16(39494),
		59:  uint16(39492),
		60:  uint16(39490),
		61:  uint16(39489),
		62:  uint16(39482),
		63:  uint16(39487),
		64:  uint16(39629),
		65:  uint16(39701),
		66:  uint16(39703),
		67:  uint16(39704),
		68:  uint16(39702),
		69:  uint16(39738),
		70:  uint16(39762),
		71:  uint16(39979),
		72:  uint16(39965),
		73:  uint16(39964),
		74:  uint16(39980),
		75:  uint16(39971),
		76:  uint16(39976),
		77:  uint16(39977),
		78:  uint16(39972),
		79:  uint16(39969),
		80:  uint16(40375),
		81:  uint16(40374),
		82:  uint16(40380),
		83:  uint16(40385),
		84:  uint16(40391),
		85:  uint16(40394),
		86:  uint16(40399),
		87:  uint16(40382),
		88:  uint16(40389),
		89:  uint16(40387),
		90:  uint16(40379),
		91:  uint16(40373),
		92:  uint16(40398),
		93:  uint16(40377),
		94:  uint16(40378),
		95:  uint16(40364),
		96:  uint16(40392),
		97:  uint16(40369),
		98:  uint16(40365),
		99:  uint16(40396),
		100: uint16(40371),
		101: uint16(40397),
		102: uint16(40370),
		103: uint16(40570),
		104: uint16(40604),
		105: uint16(40683),
		106: uint16(40686),
		107: uint16(40685),
		108: uint16(40731),
		109: uint16(40728),
		110: uint16(40730),
		111: uint16(40753),
		112: uint16(40782),
		113: uint16(40805),
		114: uint16(40804),
		115: uint16(40850),
		116: uint16(20153),
		117: uint16(22214),
		118: uint16(22213),
		119: uint16(22219),
		120: uint16(22897),
		121: uint16(23371),
		122: uint16(23372),
		123: uint16(24021),
		124: uint16(24017),
		125: uint16(24306),
		126: uint16(25889),
		127: uint16(25888),
		128: uint16(25894),
		129: uint16(25890),
		130: uint16(27403),
		131: uint16(27400),
		132: uint16(27401),
		133: uint16(27661),
		134: uint16(28757),
		135: uint16(28758),
		136: uint16(28759),
		137: uint16(28754),
		138: uint16(29214),
		139: uint16(29215),
		140: uint16(29353),
		141: uint16(29567),
		142: uint16(29912),
		143: uint16(29909),
		144: uint16(29913),
		145: uint16(29911),
		146: uint16(30317),
		147: uint16(30381),
		148: uint16(31029),
		149: uint16(31156),
		150: uint16(31344),
		151: uint16(31345),
		152: uint16(31831),
		153: uint16(31836),
		154: uint16(31833),
		155: uint16(31835),
		156: uint16(31834),
	},
	86: {
		0:   uint16(31988),
		1:   uint16(31985),
		2:   uint16(32401),
		3:   uint16(32591),
		4:   uint16(32647),
		5:   uint16(33246),
		6:   uint16(33387),
		7:   uint16(34356),
		8:   uint16(34357),
		9:   uint16(34355),
		10:  uint16(34348),
		11:  uint16(34354),
		12:  uint16(34358),
		13:  uint16(34860),
		14:  uint16(34856),
		15:  uint16(34854),
		16:  uint16(34858),
		17:  uint16(34853),
		18:  uint16(35185),
		19:  uint16(35263),
		20:  uint16(35262),
		21:  uint16(35323),
		22:  uint16(35710),
		23:  uint16(35716),
		24:  uint16(35714),
		25:  uint16(35718),
		26:  uint16(35717),
		27:  uint16(35711),
		28:  uint16(36117),
		29:  uint16(36501),
		30:  uint16(36500),
		31:  uint16(36506),
		32:  uint16(36498),
		33:  uint16(36496),
		34:  uint16(36502),
		35:  uint16(36503),
		36:  uint16(36704),
		37:  uint16(36706),
		38:  uint16(37191),
		39:  uint16(37964),
		40:  uint16(37968),
		41:  uint16(37962),
		42:  uint16(37963),
		43:  uint16(37967),
		44:  uint16(37959),
		45:  uint16(37957),
		46:  uint16(37960),
		47:  uint16(37961),
		48:  uint16(37958),
		49:  uint16(38719),
		50:  uint16(38883),
		51:  uint16(39018),
		52:  uint16(39017),
		53:  uint16(39115),
		54:  uint16(39252),
		55:  uint16(39259),
		56:  uint16(39502),
		57:  uint16(39507),
		58:  uint16(39508),
		59:  uint16(39500),
		60:  uint16(39503),
		61:  uint16(39496),
		62:  uint16(39498),
		63:  uint16(39497),
		64:  uint16(39506),
		65:  uint16(39504),
		66:  uint16(39632),
		67:  uint16(39705),
		68:  uint16(39723),
		69:  uint16(39739),
		70:  uint16(39766),
		71:  uint16(39765),
		72:  uint16(40006),
		73:  uint16(40008),
		74:  uint16(39999),
		75:  uint16(40004),
		76:  uint16(39993),
		77:  uint16(39987),
		78:  uint16(40001),
		79:  uint16(39996),
		80:  uint16(39991),
		81:  uint16(39988),
		82:  uint16(39986),
		83:  uint16(39997),
		84:  uint16(39990),
		85:  uint16(40411),
		86:  uint16(40402),
		87:  uint16(40414),
		88:  uint16(40410),
		89:  uint16(40395),
		90:  uint16(40400),
		91:  uint16(40412),
		92:  uint16(40401),
		93:  uint16(40415),
		94:  uint16(40425),
		95:  uint16(40409),
		96:  uint16(40408),
		97:  uint16(40406),
		98:  uint16(40437),
		99:  uint16(40405),
		100: uint16(40413),
		101: uint16(40630),
		102: uint16(40688),
		103: uint16(40757),
		104: uint16(40755),
		105: uint16(40754),
		106: uint16(40770),
		107: uint16(40811),
		108: uint16(40853),
		109: uint16(40866),
		110: uint16(20797),
		111: uint16(21145),
		112: uint16(22760),
		113: uint16(22759),
		114: uint16(22898),
		115: uint16(23373),
		116: uint16(24024),
		117: uint16(34863),
		118: uint16(24399),
		119: uint16(25089),
		120: uint16(25091),
		121: uint16(25092),
		122: uint16(25897),
		123: uint16(25893),
		124: uint16(26006),
		125: uint16(26347),
		126: uint16(27409),
		127: uint16(27410),
		128: uint16(27407),
		129: uint16(27594),
		130: uint16(28763),
		131: uint16(28762),
		132: uint16(29218),
		133: uint16(29570),
		134: uint16(29569),
		135: uint16(29571),
		136: uint16(30320),
		137: uint16(30676),
		138: uint16(31847),
		139: uint16(31846),
		140: uint16(32405),
		141: uint16(33388),
		142: uint16(34362),
		143: uint16(34368),
		144: uint16(34361),
		145: uint16(34364),
		146: uint16(34353),
		147: uint16(34363),
		148: uint16(34366),
		149: uint16(34864),
		150: uint16(34866),
		151: uint16(34862),
		152: uint16(34867),
		153: uint16(35190),
		154: uint16(35188),
		155: uint16(35187),
		156: uint16(35326),
	},
	87: {
		0:   uint16(35724),
		1:   uint16(35726),
		2:   uint16(35723),
		3:   uint16(35720),
		4:   uint16(35909),
		5:   uint16(36121),
		6:   uint16(36504),
		7:   uint16(36708),
		8:   uint16(36707),
		9:   uint16(37308),
		10:  uint16(37986),
		11:  uint16(37973),
		12:  uint16(37981),
		13:  uint16(37975),
		14:  uint16(37982),
		15:  uint16(38852),
		16:  uint16(38853),
		17:  uint16(38912),
		18:  uint16(39510),
		19:  uint16(39513),
		20:  uint16(39710),
		21:  uint16(39711),
		22:  uint16(39712),
		23:  uint16(40018),
		24:  uint16(40024),
		25:  uint16(40016),
		26:  uint16(40010),
		27:  uint16(40013),
		28:  uint16(40011),
		29:  uint16(40021),
		30:  uint16(40025),
		31:  uint16(40012),
		32:  uint16(40014),
		33:  uint16(40443),
		34:  uint16(40439),
		35:  uint16(40431),
		36:  uint16(40419),
		37:  uint16(40427),
		38:  uint16(40440),
		39:  uint16(40420),
		40:  uint16(40438),
		41:  uint16(40417),
		42:  uint16(40430),
		43:  uint16(40422),
		44:  uint16(40434),
		45:  uint16(40432),
		46:  uint16(40418),
		47:  uint16(40428),
		48:  uint16(40436),
		49:  uint16(40435),
		50:  uint16(40424),
		51:  uint16(40429),
		52:  uint16(40642),
		53:  uint16(40656),
		54:  uint16(40690),
		55:  uint16(40691),
		56:  uint16(40710),
		57:  uint16(40732),
		58:  uint16(40760),
		59:  uint16(40759),
		60:  uint16(40758),
		61:  uint16(40771),
		62:  uint16(40783),
		63:  uint16(40817),
		64:  uint16(40816),
		65:  uint16(40814),
		66:  uint16(40815),
		67:  uint16(22227),
		68:  uint16(22221),
		69:  uint16(23374),
		70:  uint16(23661),
		71:  uint16(25901),
		72:  uint16(26349),
		73:  uint16(26350),
		74:  uint16(27411),
		75:  uint16(28767),
		76:  uint16(28769),
		77:  uint16(28765),
		78:  uint16(28768),
		79:  uint16(29219),
		80:  uint16(29915),
		81:  uint16(29925),
		82:  uint16(30677),
		83:  uint16(31032),
		84:  uint16(31159),
		85:  uint16(31158),
		86:  uint16(31850),
		87:  uint16(32407),
		88:  uint16(32649),
		89:  uint16(33389),
		90:  uint16(34371),
		91:  uint16(34872),
		92:  uint16(34871),
		93:  uint16(34869),
		94:  uint16(34891),
		95:  uint16(35732),
		96:  uint16(35733),
		97:  uint16(36510),
		98:  uint16(36511),
		99:  uint16(36512),
		100: uint16(36509),
		101: uint16(37310),
		102: uint16(37309),
		103: uint16(37314),
		104: uint16(37995),
		105: uint16(37992),
		106: uint16(37993),
		107: uint16(38629),
		108: uint16(38726),
		109: uint16(38723),
		110: uint16(38727),
		111: uint16(38855),
		112: uint16(38885),
		113: uint16(39518),
		114: uint16(39637),
		115: uint16(39769),
		116: uint16(40035),
		117: uint16(40039),
		118: uint16(40038),
		119: uint16(40034),
		120: uint16(40030),
		121: uint16(40032),
		122: uint16(40450),
		123: uint16(40446),
		124: uint16(40455),
		125: uint16(40451),
		126: uint16(40454),
		127: uint16(40453),
		128: uint16(40448),
		129: uint16(40449),
		130: uint16(40457),
		131: uint16(40447),
		132: uint16(40445),
		133: uint16(40452),
		134: uint16(40608),
		135: uint16(40734),
		136: uint16(40774),
		137: uint16(40820),
		138: uint16(40821),
		139: uint16(40822),
		140: uint16(22228),
		141: uint16(25902),
		142: uint16(26040),
		143: uint16(27416),
		144: uint16(27417),
		145: uint16(27415),
		146: uint16(27418),
		147: uint16(28770),
		148: uint16(29222),
		149: uint16(29354),
		150: uint16(30680),
		151: uint16(30681),
		152: uint16(31033),
		153: uint16(31849),
		154: uint16(31851),
		155: uint16(31990),
		156: uint16(32410),
	},
	88: {
		0:   uint16(32408),
		1:   uint16(32411),
		2:   uint16(32409),
		3:   uint16(33248),
		4:   uint16(33249),
		5:   uint16(34374),
		6:   uint16(34375),
		7:   uint16(34376),
		8:   uint16(35193),
		9:   uint16(35194),
		10:  uint16(35196),
		11:  uint16(35195),
		12:  uint16(35327),
		13:  uint16(35736),
		14:  uint16(35737),
		15:  uint16(36517),
		16:  uint16(36516),
		17:  uint16(36515),
		18:  uint16(37998),
		19:  uint16(37997),
		20:  uint16(37999),
		21:  uint16(38001),
		22:  uint16(38003),
		23:  uint16(38729),
		24:  uint16(39026),
		25:  uint16(39263),
		26:  uint16(40040),
		27:  uint16(40046),
		28:  uint16(40045),
		29:  uint16(40459),
		30:  uint16(40461),
		31:  uint16(40464),
		32:  uint16(40463),
		33:  uint16(40466),
		34:  uint16(40465),
		35:  uint16(40609),
		36:  uint16(40693),
		37:  uint16(40713),
		38:  uint16(40775),
		39:  uint16(40824),
		40:  uint16(40827),
		41:  uint16(40826),
		42:  uint16(40825),
		43:  uint16(22302),
		44:  uint16(28774),
		45:  uint16(31855),
		46:  uint16(34876),
		47:  uint16(36274),
		48:  uint16(36518),
		49:  uint16(37315),
		50:  uint16(38004),
		51:  uint16(38008),
		52:  uint16(38006),
		53:  uint16(38005),
		54:  uint16(39520),
		55:  uint16(40052),
		56:  uint16(40051),
		57:  uint16(40049),
		58:  uint16(40053),
		59:  uint16(40468),
		60:  uint16(40467),
		61:  uint16(40694),
		62:  uint16(40714),
		63:  uint16(40868),
		64:  uint16(28776),
		65:  uint16(28773),
		66:  uint16(31991),
		67:  uint16(34410),
		68:  uint16(34878),
		69:  uint16(34877),
		70:  uint16(34879),
		71:  uint16(35742),
		72:  uint16(35996),
		73:  uint16(36521),
		74:  uint16(36553),
		75:  uint16(38731),
		76:  uint16(39027),
		77:  uint16(39028),
		78:  uint16(39116),
		79:  uint16(39265),
		80:  uint16(39339),
		81:  uint16(39524),
		82:  uint16(39526),
		83:  uint16(39527),
		84:  uint16(39716),
		85:  uint16(40469),
		86:  uint16(40471),
		87:  uint16(40776),
		88:  uint16(25095),
		89:  uint16(27422),
		90:  uint16(29223),
		91:  uint16(34380),
		92:  uint16(36520),
		93:  uint16(38018),
		94:  uint16(38016),
		95:  uint16(38017),
		96:  uint16(39529),
		97:  uint16(39528),
		98:  uint16(39726),
		99:  uint16(40473),
		100: uint16(29225),
		101: uint16(34379),
		102: uint16(35743),
		103: uint16(38019),
		104: uint16(40057),
		105: uint16(40631),
		106: uint16(30325),
		107: uint16(39531),
		108: uint16(40058),
		109: uint16(40477),
		110: uint16(28777),
		111: uint16(28778),
		112: uint16(40612),
		113: uint16(40830),
		114: uint16(40777),
		115: uint16(40856),
		116: uint16(30849),
		117: uint16(37561),
		118: uint16(35023),
		119: uint16(22715),
		120: uint16(24658),
		121: uint16(31911),
		122: uint16(23290),
		123: uint16(9556),
		124: uint16(9574),
		125: uint16(9559),
		126: uint16(9568),
		127: uint16(9580),
		128: uint16(9571),
		129: uint16(9562),
		130: uint16(9577),
		131: uint16(9565),
		132: uint16(9554),
		133: uint16(9572),
		134: uint16(9557),
		135: uint16(9566),
		136: uint16(9578),
		137: uint16(9569),
		138: uint16(9560),
		139: uint16(9575),
		140: uint16(9563),
		141: uint16(9555),
		142: uint16(9573),
		143: uint16(9558),
		144: uint16(9567),
		145: uint16(9579),
		146: uint16(9570),
		147: uint16(9561),
		148: uint16(9576),
		149: uint16(9564),
		150: uint16(9553),
		151: uint16(9552),
		152: uint16(9581),
		153: uint16(9582),
		154: uint16(9584),
		155: uint16(9583),
		156: uint16(9619),
	},
}

var _hkscs = [5172]uint16{
	0:    uint16(17392),
	1:    uint16(19506),
	2:    uint16(17923),
	3:    uint16(17830),
	4:    uint16(17784),
	5:    uint16(29287),
	6:    uint16(19831),
	7:    uint16(17843),
	8:    uint16(31921),
	9:    uint16(19682),
	10:   uint16(31941),
	11:   uint16(15253),
	12:   uint16(18230),
	13:   uint16(18244),
	14:   uint16(19527),
	15:   uint16(19520),
	16:   uint16(17087),
	17:   uint16(13847),
	18:   uint16(29522),
	19:   uint16(28299),
	20:   uint16(28882),
	21:   uint16(19543),
	22:   uint16(41809),
	23:   uint16(18255),
	24:   uint16(17882),
	25:   uint16(19589),
	26:   uint16(31852),
	27:   uint16(19719),
	28:   uint16(19108),
	29:   uint16(18081),
	30:   uint16(27427),
	31:   uint16(29221),
	32:   uint16(23124),
	33:   uint16(6755),
	34:   uint16(15878),
	35:   uint16(16225),
	36:   uint16(26189),
	37:   uint16(22267),
	39:   uint16(32149),
	40:   uint16(22813),
	41:   uint16(35769),
	42:   uint16(15860),
	43:   uint16(38708),
	44:   uint16(31727),
	45:   uint16(23515),
	46:   uint16(7518),
	47:   uint16(23204),
	48:   uint16(13861),
	49:   uint16(40624),
	50:   uint16(23249),
	51:   uint16(23479),
	52:   uint16(23804),
	53:   uint16(26478),
	54:   uint16(34195),
	55:   uint16(39237),
	56:   uint16(29793),
	57:   uint16(29853),
	58:   uint16(14453),
	59:   uint16(7507),
	60:   uint16(13982),
	61:   uint16(24609),
	62:   uint16(16108),
	63:   uint16(22750),
	64:   uint16(15093),
	65:   uint16(31484),
	66:   uint16(40855),
	67:   uint16(16737),
	68:   uint16(35085),
	69:   uint16(12778),
	70:   uint16(2698),
	71:   uint16(12894),
	72:   uint16(17162),
	73:   uint16(33924),
	74:   uint16(40854),
	75:   uint16(37935),
	76:   uint16(18736),
	77:   uint16(34323),
	78:   uint16(22678),
	79:   uint16(38730),
	80:   uint16(37400),
	81:   uint16(31184),
	82:   uint16(31282),
	83:   uint16(26208),
	84:   uint16(27177),
	85:   uint16(34973),
	86:   uint16(29772),
	87:   uint16(31685),
	88:   uint16(26498),
	89:   uint16(31276),
	90:   uint16(21071),
	91:   uint16(36934),
	92:   uint16(13542),
	93:   uint16(29636),
	94:   uint16(23993),
	95:   uint16(29894),
	96:   uint16(40903),
	97:   uint16(22451),
	98:   uint16(18735),
	99:   uint16(21580),
	100:  uint16(16689),
	101:  uint16(13966),
	102:  uint16(22552),
	103:  uint16(31346),
	104:  uint16(31589),
	105:  uint16(35727),
	106:  uint16(18094),
	107:  uint16(28296),
	108:  uint16(16769),
	109:  uint16(23961),
	110:  uint16(31662),
	111:  uint16(9404),
	112:  uint16(40904),
	113:  uint16(9409),
	114:  uint16(9417),
	115:  uint16(9420),
	116:  uint16(40905),
	117:  uint16(34052),
	118:  uint16(13755),
	119:  uint16(16564),
	120:  uint16(40906),
	121:  uint16(17633),
	122:  uint16(44543),
	123:  uint16(25281),
	124:  uint16(28782),
	125:  uint16(40907),
	157:  uint16(12736),
	158:  uint16(12737),
	159:  uint16(12738),
	160:  uint16(12739),
	161:  uint16(12740),
	162:  uint16(268),
	163:  uint16(12741),
	164:  uint16(209),
	165:  uint16(205),
	166:  uint16(12742),
	167:  uint16(12743),
	168:  uint16(203),
	169:  uint16(8168),
	170:  uint16(12744),
	171:  uint16(202),
	172:  uint16(12745),
	173:  uint16(12746),
	174:  uint16(12747),
	175:  uint16(12748),
	176:  uint16(270),
	177:  uint16(12749),
	178:  uint16(12750),
	179:  uint16(256),
	180:  uint16(193),
	181:  uint16(461),
	182:  uint16(192),
	183:  uint16(274),
	184:  uint16(201),
	185:  uint16(282),
	186:  uint16(200),
	187:  uint16(332),
	188:  uint16(211),
	189:  uint16(465),
	190:  uint16(210),
	191:  uint16(56320),
	192:  uint16(7870),
	193:  uint16(56324),
	194:  uint16(7872),
	195:  uint16(202),
	196:  uint16(257),
	197:  uint16(225),
	198:  uint16(462),
	199:  uint16(224),
	200:  uint16(593),
	201:  uint16(275),
	202:  uint16(233),
	203:  uint16(283),
	204:  uint16(232),
	205:  uint16(299),
	206:  uint16(237),
	207:  uint16(464),
	208:  uint16(236),
	209:  uint16(333),
	210:  uint16(243),
	211:  uint16(466),
	212:  uint16(242),
	213:  uint16(363),
	214:  uint16(250),
	215:  uint16(468),
	216:  uint16(249),
	217:  uint16(470),
	218:  uint16(472),
	219:  uint16(474),
	220:  uint16(476),
	221:  uint16(252),
	222:  uint16(56328),
	223:  uint16(7871),
	224:  uint16(56332),
	225:  uint16(7873),
	226:  uint16(234),
	227:  uint16(609),
	228:  uint16(9178),
	229:  uint16(9179),
	314:  uint16(41897),
	315:  uint16(4421),
	317:  uint16(25866),
	320:  uint16(20029),
	321:  uint16(28381),
	322:  uint16(40270),
	323:  uint16(37343),
	326:  uint16(30517),
	327:  uint16(25745),
	328:  uint16(20250),
	329:  uint16(20264),
	330:  uint16(20392),
	331:  uint16(20822),
	332:  uint16(20852),
	333:  uint16(20892),
	334:  uint16(20964),
	335:  uint16(21153),
	336:  uint16(21160),
	337:  uint16(21307),
	338:  uint16(21326),
	339:  uint16(21457),
	340:  uint16(21464),
	341:  uint16(22242),
	342:  uint16(22768),
	343:  uint16(22788),
	344:  uint16(22791),
	345:  uint16(22834),
	346:  uint16(22836),
	347:  uint16(23398),
	348:  uint16(23454),
	349:  uint16(23455),
	350:  uint16(23706),
	351:  uint16(24198),
	352:  uint16(24635),
	353:  uint16(25993),
	354:  uint16(26622),
	355:  uint16(26628),
	356:  uint16(26725),
	357:  uint16(27982),
	358:  uint16(28860),
	359:  uint16(30005),
	360:  uint16(32420),
	361:  uint16(32428),
	362:  uint16(32442),
	363:  uint16(32455),
	364:  uint16(32463),
	365:  uint16(32479),
	366:  uint16(32518),
	367:  uint16(32567),
	368:  uint16(33402),
	369:  uint16(33487),
	370:  uint16(33647),
	371:  uint16(35270),
	372:  uint16(35774),
	373:  uint16(35810),
	374:  uint16(36710),
	375:  uint16(36711),
	376:  uint16(36718),
	377:  uint16(29713),
	378:  uint16(31996),
	379:  uint16(32205),
	380:  uint16(26950),
	381:  uint16(31433),
	382:  uint16(21031),
	387:  uint16(37260),
	388:  uint16(30904),
	389:  uint16(37214),
	390:  uint16(32956),
	392:  uint16(36107),
	393:  uint16(33014),
	394:  uint16(2535),
	397:  uint16(32927),
	398:  uint16(40647),
	399:  uint16(19661),
	400:  uint16(40393),
	401:  uint16(40460),
	402:  uint16(19518),
	403:  uint16(40438),
	404:  uint16(28686),
	405:  uint16(40458),
	406:  uint16(41267),
	407:  uint16(13761),
	409:  uint16(28314),
	410:  uint16(33342),
	411:  uint16(29977),
	413:  uint16(18705),
	414:  uint16(39532),
	415:  uint16(39567),
	416:  uint16(40857),
	417:  uint16(31111),
	418:  uint16(33900),
	419:  uint16(7626),
	420:  uint16(1488),
	421:  uint16(10982),
	422:  uint16(20004),
	423:  uint16(20097),
	424:  uint16(20096),
	425:  uint16(20103),
	426:  uint16(20159),
	427:  uint16(20203),
	428:  uint16(20279),
	429:  uint16(13388),
	430:  uint16(20413),
	431:  uint16(15944),
	432:  uint16(20483),
	433:  uint16(20616),
	434:  uint16(13437),
	435:  uint16(13459),
	436:  uint16(13477),
	437:  uint16(20870),
	438:  uint16(22789),
	439:  uint16(20955),
	440:  uint16(20988),
	441:  uint16(20997),
	442:  uint16(20105),
	443:  uint16(21113),
	444:  uint16(21136),
	445:  uint16(21287),
	446:  uint16(13767),
	447:  uint16(21417),
	448:  uint16(13649),
	449:  uint16(21424),
	450:  uint16(13651),
	451:  uint16(21442),
	452:  uint16(21539),
	453:  uint16(13677),
	454:  uint16(13682),
	455:  uint16(13953),
	456:  uint16(21651),
	457:  uint16(21667),
	458:  uint16(21684),
	459:  uint16(21689),
	460:  uint16(21712),
	461:  uint16(21743),
	462:  uint16(21784),
	463:  uint16(21795),
	464:  uint16(21800),
	465:  uint16(13720),
	466:  uint16(21823),
	467:  uint16(13733),
	468:  uint16(13759),
	469:  uint16(21975),
	470:  uint16(13765),
	471:  uint16(32132),
	472:  uint16(21797),
	474:  uint16(3138),
	475:  uint16(3349),
	476:  uint16(20779),
	477:  uint16(21904),
	478:  uint16(11462),
	479:  uint16(14828),
	480:  uint16(833),
	481:  uint16(36422),
	482:  uint16(19896),
	483:  uint16(38117),
	484:  uint16(16467),
	485:  uint16(32958),
	486:  uint16(30586),
	487:  uint16(11320),
	488:  uint16(14900),
	489:  uint16(18389),
	490:  uint16(33117),
	491:  uint16(27122),
	492:  uint16(19946),
	493:  uint16(25821),
	494:  uint16(3452),
	495:  uint16(4020),
	496:  uint16(3285),
	497:  uint16(4340),
	498:  uint16(25741),
	499:  uint16(36478),
	500:  uint16(3734),
	501:  uint16(3083),
	502:  uint16(3940),
	503:  uint16(11433),
	504:  uint16(33366),
	505:  uint16(17619),
	507:  uint16(3398),
	508:  uint16(39501),
	509:  uint16(33001),
	510:  uint16(18420),
	511:  uint16(20135),
	512:  uint16(11458),
	513:  uint16(39602),
	514:  uint16(14951),
	515:  uint16(38388),
	516:  uint16(16365),
	517:  uint16(13574),
	518:  uint16(21191),
	519:  uint16(38868),
	520:  uint16(30920),
	521:  uint16(11588),
	522:  uint16(40302),
	523:  uint16(38933),
	525:  uint16(17369),
	526:  uint16(24741),
	527:  uint16(25780),
	528:  uint16(21731),
	529:  uint16(11596),
	530:  uint16(11210),
	531:  uint16(4215),
	532:  uint16(14843),
	533:  uint16(4207),
	534:  uint16(26330),
	535:  uint16(26390),
	536:  uint16(31136),
	537:  uint16(25834),
	538:  uint16(20562),
	539:  uint16(3139),
	540:  uint16(36456),
	541:  uint16(8609),
	542:  uint16(35660),
	543:  uint16(1841),
	545:  uint16(18443),
	546:  uint16(425),
	547:  uint16(16378),
	548:  uint16(22643),
	549:  uint16(11661),
	551:  uint16(17864),
	552:  uint16(1276),
	553:  uint16(24727),
	554:  uint16(3916),
	555:  uint16(3478),
	556:  uint16(21881),
	557:  uint16(16571),
	558:  uint16(17338),
	560:  uint16(19124),
	561:  uint16(10854),
	562:  uint16(4253),
	563:  uint16(33194),
	564:  uint16(39157),
	565:  uint16(3484),
	566:  uint16(25465),
	567:  uint16(14846),
	568:  uint16(10101),
	569:  uint16(36288),
	570:  uint16(22177),
	571:  uint16(25724),
	572:  uint16(15939),
	574:  uint16(42497),
	575:  uint16(3593),
	576:  uint16(10959),
	577:  uint16(11465),
	579:  uint16(4296),
	580:  uint16(14786),
	581:  uint16(14738),
	582:  uint16(14854),
	583:  uint16(33435),
	584:  uint16(13688),
	585:  uint16(24137),
	586:  uint16(8391),
	587:  uint16(22098),
	588:  uint16(3889),
	589:  uint16(11442),
	590:  uint16(38688),
	591:  uint16(13500),
	592:  uint16(27709),
	593:  uint16(20027),
	596:  uint16(30068),
	597:  uint16(11915),
	598:  uint16(8712),
	599:  uint16(42587),
	600:  uint16(36045),
	601:  uint16(3706),
	602:  uint16(3124),
	603:  uint16(26652),
	604:  uint16(32659),
	605:  uint16(4303),
	606:  uint16(10243),
	607:  uint16(10553),
	608:  uint16(13819),
	609:  uint16(20963),
	610:  uint16(3724),
	611:  uint16(3981),
	612:  uint16(3754),
	613:  uint16(16275),
	614:  uint16(3888),
	615:  uint16(3399),
	616:  uint16(4431),
	617:  uint16(3660),
	619:  uint16(3755),
	620:  uint16(2985),
	621:  uint16(3400),
	622:  uint16(4288),
	623:  uint16(4413),
	624:  uint16(16377),
	625:  uint16(9878),
	626:  uint16(25650),
	627:  uint16(4013),
	628:  uint16(13300),
	629:  uint16(30265),
	630:  uint16(11214),
	631:  uint16(3454),
	632:  uint16(3455),
	633:  uint16(11345),
	634:  uint16(11349),
	635:  uint16(14872),
	636:  uint16(3736),
	637:  uint16(4295),
	638:  uint16(3886),
	639:  uint16(42546),
	640:  uint16(27472),
	641:  uint16(36050),
	642:  uint16(36249),
	643:  uint16(36042),
	644:  uint16(38314),
	645:  uint16(21708),
	646:  uint16(33476),
	647:  uint16(21945),
	649:  uint16(40643),
	650:  uint16(39974),
	651:  uint16(39606),
	652:  uint16(30558),
	653:  uint16(11758),
	654:  uint16(28992),
	655:  uint16(33133),
	656:  uint16(33004),
	657:  uint16(23580),
	658:  uint16(25970),
	659:  uint16(33076),
	660:  uint16(14231),
	661:  uint16(21343),
	662:  uint16(32957),
	663:  uint16(37302),
	664:  uint16(3834),
	665:  uint16(3599),
	666:  uint16(3703),
	667:  uint16(3835),
	668:  uint16(13789),
	669:  uint16(19947),
	670:  uint16(13833),
	671:  uint16(3286),
	672:  uint16(22191),
	673:  uint16(10165),
	674:  uint16(4297),
	675:  uint16(3600),
	676:  uint16(3704),
	677:  uint16(4216),
	678:  uint16(4424),
	679:  uint16(33287),
	680:  uint16(5205),
	681:  uint16(3705),
	682:  uint16(20048),
	683:  uint16(11684),
	684:  uint16(23124),
	685:  uint16(4125),
	686:  uint16(4126),
	687:  uint16(4341),
	688:  uint16(4342),
	689:  uint16(22428),
	690:  uint16(3601),
	691:  uint16(30356),
	692:  uint16(33485),
	693:  uint16(4021),
	694:  uint16(3707),
	695:  uint16(20862),
	696:  uint16(14083),
	697:  uint16(4022),
	698:  uint16(4480),
	699:  uint16(21208),
	700:  uint16(41661),
	701:  uint16(18906),
	702:  uint16(6202),
	703:  uint16(16759),
	704:  uint16(33404),
	705:  uint16(22681),
	706:  uint16(21096),
	707:  uint16(13850),
	708:  uint16(22333),
	709:  uint16(31666),
	710:  uint16(23400),
	711:  uint16(18432),
	712:  uint16(19244),
	713:  uint16(40743),
	714:  uint16(18919),
	715:  uint16(39967),
	716:  uint16(39821),
	717:  uint16(23412),
	718:  uint16(12605),
	719:  uint16(22011),
	720:  uint16(13810),
	721:  uint16(22153),
	722:  uint16(20008),
	723:  uint16(22786),
	724:  uint16(7105),
	725:  uint16(63608),
	726:  uint16(38737),
	727:  uint16(134),
	728:  uint16(20059),
	729:  uint16(20155),
	730:  uint16(13630),
	731:  uint16(23587),
	732:  uint16(24401),
	733:  uint16(24516),
	734:  uint16(14586),
	735:  uint16(25164),
	736:  uint16(25909),
	737:  uint16(27514),
	738:  uint16(27701),
	739:  uint16(27706),
	740:  uint16(28780),
	741:  uint16(29227),
	742:  uint16(20012),
	743:  uint16(29357),
	744:  uint16(18665),
	745:  uint16(32594),
	746:  uint16(31035),
	747:  uint16(31993),
	748:  uint16(32595),
	749:  uint16(25194),
	750:  uint16(13505),
	752:  uint16(25419),
	753:  uint16(32770),
	754:  uint16(32896),
	755:  uint16(26130),
	756:  uint16(26961),
	757:  uint16(21341),
	758:  uint16(34916),
	759:  uint16(35265),
	760:  uint16(30898),
	761:  uint16(35744),
	762:  uint16(36125),
	763:  uint16(38021),
	764:  uint16(38264),
	765:  uint16(38271),
	766:  uint16(38376),
	767:  uint16(36367),
	768:  uint16(38886),
	769:  uint16(39029),
	770:  uint16(39118),
	771:  uint16(39134),
	772:  uint16(39267),
	773:  uint16(38928),
	774:  uint16(40060),
	775:  uint16(40479),
	776:  uint16(40644),
	777:  uint16(27503),
	778:  uint16(63751),
	779:  uint16(20023),
	780:  uint16(135),
	781:  uint16(38429),
	782:  uint16(25143),
	783:  uint16(38050),
	785:  uint16(20539),
	786:  uint16(28158),
	787:  uint16(40051),
	788:  uint16(40870),
	789:  uint16(15817),
	790:  uint16(34959),
	791:  uint16(16718),
	792:  uint16(28791),
	793:  uint16(23797),
	794:  uint16(19232),
	795:  uint16(20941),
	796:  uint16(13657),
	797:  uint16(23856),
	798:  uint16(24866),
	799:  uint16(35378),
	800:  uint16(36775),
	801:  uint16(37366),
	802:  uint16(29073),
	803:  uint16(26393),
	804:  uint16(29626),
	805:  uint16(12929),
	806:  uint16(41223),
	807:  uint16(15499),
	808:  uint16(6528),
	809:  uint16(19216),
	810:  uint16(30948),
	811:  uint16(29698),
	812:  uint16(20910),
	813:  uint16(34575),
	814:  uint16(16393),
	815:  uint16(27235),
	816:  uint16(41658),
	817:  uint16(16931),
	818:  uint16(34319),
	819:  uint16(2671),
	820:  uint16(31274),
	821:  uint16(39239),
	822:  uint16(35562),
	823:  uint16(38741),
	824:  uint16(28749),
	825:  uint16(21284),
	826:  uint16(8318),
	827:  uint16(37876),
	828:  uint16(30425),
	829:  uint16(35299),
	830:  uint16(40871),
	831:  uint16(30685),
	832:  uint16(20131),
	833:  uint16(20464),
	834:  uint16(20668),
	835:  uint16(20015),
	836:  uint16(20247),
	837:  uint16(40872),
	838:  uint16(21556),
	839:  uint16(32139),
	840:  uint16(22674),
	841:  uint16(22736),
	842:  uint16(7606),
	843:  uint16(24210),
	844:  uint16(24217),
	845:  uint16(24514),
	846:  uint16(10002),
	847:  uint16(25995),
	848:  uint16(13305),
	849:  uint16(26905),
	850:  uint16(27203),
	851:  uint16(15459),
	852:  uint16(27903),
	854:  uint16(29184),
	855:  uint16(17669),
	856:  uint16(29580),
	857:  uint16(16091),
	858:  uint16(18963),
	859:  uint16(23317),
	860:  uint16(29881),
	861:  uint16(35715),
	862:  uint16(23716),
	863:  uint16(22165),
	864:  uint16(31379),
	865:  uint16(31724),
	866:  uint16(31939),
	867:  uint16(32364),
	868:  uint16(33528),
	869:  uint16(34199),
	870:  uint16(40873),
	871:  uint16(34960),
	872:  uint16(40874),
	873:  uint16(36537),
	874:  uint16(40875),
	875:  uint16(36815),
	876:  uint16(34143),
	877:  uint16(39392),
	878:  uint16(37409),
	879:  uint16(40876),
	880:  uint16(36281),
	881:  uint16(5183),
	882:  uint16(16497),
	883:  uint16(17058),
	884:  uint16(23066),
	888:  uint16(39016),
	889:  uint16(26475),
	890:  uint16(17014),
	891:  uint16(22333),
	893:  uint16(34262),
	894:  uint16(18811),
	895:  uint16(33471),
	896:  uint16(28941),
	897:  uint16(19585),
	898:  uint16(28020),
	899:  uint16(23931),
	900:  uint16(27413),
	901:  uint16(28606),
	902:  uint16(40877),
	903:  uint16(40878),
	904:  uint16(23446),
	905:  uint16(40879),
	906:  uint16(26343),
	907:  uint16(32347),
	908:  uint16(28247),
	909:  uint16(31178),
	910:  uint16(15752),
	911:  uint16(17603),
	912:  uint16(12886),
	913:  uint16(10134),
	914:  uint16(17306),
	915:  uint16(17718),
	917:  uint16(23765),
	918:  uint16(15130),
	919:  uint16(35577),
	920:  uint16(23672),
	921:  uint16(15634),
	922:  uint16(13649),
	923:  uint16(23928),
	924:  uint16(40882),
	925:  uint16(29015),
	926:  uint16(17752),
	927:  uint16(16620),
	928:  uint16(7715),
	929:  uint16(19575),
	930:  uint16(14712),
	931:  uint16(13386),
	932:  uint16(420),
	933:  uint16(27713),
	934:  uint16(35532),
	935:  uint16(20404),
	936:  uint16(569),
	937:  uint16(22975),
	938:  uint16(33132),
	939:  uint16(38998),
	940:  uint16(39162),
	941:  uint16(24379),
	942:  uint16(2975),
	944:  uint16(8641),
	945:  uint16(35181),
	946:  uint16(16642),
	947:  uint16(18107),
	948:  uint16(36985),
	949:  uint16(16135),
	950:  uint16(40883),
	951:  uint16(41397),
	952:  uint16(16632),
	953:  uint16(14294),
	954:  uint16(18167),
	955:  uint16(27718),
	956:  uint16(16764),
	957:  uint16(34482),
	958:  uint16(29695),
	959:  uint16(17773),
	960:  uint16(14548),
	961:  uint16(21658),
	962:  uint16(17761),
	963:  uint16(17691),
	964:  uint16(19849),
	965:  uint16(19579),
	966:  uint16(19830),
	967:  uint16(17898),
	968:  uint16(16328),
	969:  uint16(19215),
	970:  uint16(13921),
	971:  uint16(17630),
	972:  uint16(17597),
	973:  uint16(16877),
	974:  uint16(23870),
	975:  uint16(23880),
	976:  uint16(23894),
	977:  uint16(15868),
	978:  uint16(14351),
	979:  uint16(23972),
	980:  uint16(23993),
	981:  uint16(14368),
	982:  uint16(14392),
	983:  uint16(24130),
	984:  uint16(24253),
	985:  uint16(24357),
	986:  uint16(24451),
	987:  uint16(14600),
	988:  uint16(14612),
	989:  uint16(14655),
	990:  uint16(14669),
	991:  uint16(24791),
	992:  uint16(24893),
	993:  uint16(23781),
	994:  uint16(14729),
	995:  uint16(25015),
	996:  uint16(25017),
	997:  uint16(25039),
	998:  uint16(14776),
	999:  uint16(25132),
	1000: uint16(25232),
	1001: uint16(25317),
	1002: uint16(25368),
	1003: uint16(14840),
	1004: uint16(22193),
	1005: uint16(14851),
	1006: uint16(25570),
	1007: uint16(25595),
	1008: uint16(25607),
	1009: uint16(25690),
	1010: uint16(14923),
	1011: uint16(25792),
	1012: uint16(23829),
	1013: uint16(22049),
	1014: uint16(40863),
	1015: uint16(14999),
	1016: uint16(25990),
	1017: uint16(15037),
	1018: uint16(26111),
	1019: uint16(26195),
	1020: uint16(15090),
	1021: uint16(26258),
	1022: uint16(15138),
	1023: uint16(26390),
	1024: uint16(15170),
	1025: uint16(26532),
	1026: uint16(26624),
	1027: uint16(15192),
	1028: uint16(26698),
	1029: uint16(26756),
	1030: uint16(15218),
	1031: uint16(15217),
	1032: uint16(15227),
	1033: uint16(26889),
	1034: uint16(26947),
	1035: uint16(29276),
	1036: uint16(26980),
	1037: uint16(27039),
	1038: uint16(27013),
	1039: uint16(15292),
	1040: uint16(27094),
	1041: uint16(15325),
	1042: uint16(27237),
	1043: uint16(27252),
	1044: uint16(27249),
	1045: uint16(27266),
	1046: uint16(15340),
	1047: uint16(27289),
	1048: uint16(15346),
	1049: uint16(27307),
	1050: uint16(27317),
	1051: uint16(27348),
	1052: uint16(27382),
	1053: uint16(27521),
	1054: uint16(27585),
	1055: uint16(27626),
	1056: uint16(27765),
	1057: uint16(27818),
	1058: uint16(15563),
	1059: uint16(27906),
	1060: uint16(27910),
	1061: uint16(27942),
	1062: uint16(28033),
	1063: uint16(15599),
	1064: uint16(28068),
	1065: uint16(28081),
	1066: uint16(28181),
	1067: uint16(28184),
	1068: uint16(28201),
	1069: uint16(28294),
	1070: uint16(35264),
	1071: uint16(28347),
	1072: uint16(28386),
	1073: uint16(28378),
	1074: uint16(40831),
	1075: uint16(28392),
	1076: uint16(28393),
	1077: uint16(28452),
	1078: uint16(28468),
	1079: uint16(15686),
	1080: uint16(16193),
	1081: uint16(28545),
	1082: uint16(28606),
	1083: uint16(15722),
	1084: uint16(15733),
	1085: uint16(29111),
	1086: uint16(23705),
	1087: uint16(15754),
	1088: uint16(28716),
	1089: uint16(15761),
	1090: uint16(28752),
	1091: uint16(28756),
	1092: uint16(28783),
	1093: uint16(28799),
	1094: uint16(28809),
	1095: uint16(805),
	1096: uint16(17345),
	1097: uint16(13809),
	1098: uint16(3800),
	1099: uint16(16087),
	1100: uint16(22462),
	1101: uint16(28371),
	1102: uint16(28990),
	1103: uint16(22496),
	1104: uint16(13902),
	1105: uint16(27042),
	1106: uint16(35817),
	1107: uint16(23412),
	1108: uint16(31305),
	1109: uint16(22753),
	1110: uint16(38105),
	1111: uint16(31333),
	1112: uint16(31357),
	1113: uint16(22956),
	1114: uint16(31419),
	1115: uint16(31408),
	1116: uint16(31426),
	1117: uint16(31427),
	1118: uint16(29137),
	1119: uint16(25741),
	1120: uint16(16842),
	1121: uint16(31450),
	1122: uint16(31453),
	1123: uint16(31466),
	1124: uint16(16879),
	1125: uint16(21682),
	1126: uint16(23553),
	1127: uint16(31499),
	1128: uint16(31573),
	1129: uint16(31529),
	1130: uint16(21262),
	1131: uint16(23806),
	1132: uint16(31650),
	1133: uint16(31599),
	1134: uint16(33692),
	1135: uint16(23476),
	1136: uint16(27775),
	1137: uint16(31696),
	1138: uint16(33825),
	1139: uint16(31634),
	1141: uint16(23840),
	1142: uint16(15789),
	1143: uint16(23653),
	1144: uint16(33938),
	1145: uint16(31738),
	1147: uint16(31797),
	1148: uint16(23745),
	1149: uint16(31812),
	1150: uint16(31875),
	1151: uint16(18562),
	1152: uint16(31910),
	1153: uint16(26237),
	1154: uint16(17784),
	1155: uint16(31945),
	1156: uint16(31943),
	1157: uint16(31974),
	1158: uint16(31860),
	1159: uint16(31987),
	1160: uint16(31989),
	1162: uint16(32359),
	1163: uint16(17693),
	1164: uint16(28228),
	1165: uint16(32093),
	1166: uint16(28374),
	1167: uint16(29837),
	1168: uint16(32137),
	1169: uint16(32171),
	1170: uint16(28981),
	1171: uint16(32179),
	1173: uint16(16471),
	1174: uint16(24617),
	1175: uint16(32228),
	1176: uint16(15635),
	1177: uint16(32245),
	1178: uint16(6137),
	1179: uint16(32229),
	1180: uint16(33645),
	1182: uint16(24865),
	1183: uint16(24922),
	1184: uint16(32366),
	1185: uint16(32402),
	1186: uint16(17195),
	1187: uint16(37996),
	1188: uint16(32295),
	1189: uint16(32576),
	1190: uint16(32577),
	1191: uint16(32583),
	1192: uint16(31030),
	1193: uint16(25296),
	1194: uint16(39393),
	1195: uint16(32663),
	1196: uint16(25425),
	1197: uint16(32675),
	1198: uint16(5729),
	1199: uint16(104),
	1200: uint16(17756),
	1201: uint16(14182),
	1202: uint16(17667),
	1203: uint16(33594),
	1204: uint16(32762),
	1205: uint16(25737),
	1207: uint16(32776),
	1208: uint16(32797),
	1210: uint16(32815),
	1211: uint16(41095),
	1212: uint16(27843),
	1213: uint16(32827),
	1214: uint16(32828),
	1215: uint16(32865),
	1216: uint16(10004),
	1217: uint16(18825),
	1218: uint16(26150),
	1219: uint16(15843),
	1220: uint16(26344),
	1221: uint16(26405),
	1222: uint16(32935),
	1223: uint16(35400),
	1224: uint16(33031),
	1225: uint16(33050),
	1226: uint16(22704),
	1227: uint16(9974),
	1228: uint16(27775),
	1229: uint16(25752),
	1230: uint16(20408),
	1231: uint16(25831),
	1232: uint16(5258),
	1233: uint16(33304),
	1234: uint16(6238),
	1235: uint16(27219),
	1236: uint16(19045),
	1237: uint16(19093),
	1238: uint16(17530),
	1239: uint16(33321),
	1240: uint16(2829),
	1241: uint16(27218),
	1242: uint16(15742),
	1243: uint16(20473),
	1244: uint16(5373),
	1245: uint16(34018),
	1246: uint16(33634),
	1247: uint16(27402),
	1248: uint16(18855),
	1249: uint16(13616),
	1250: uint16(6003),
	1251: uint16(15864),
	1252: uint16(33450),
	1253: uint16(26907),
	1254: uint16(63892),
	1255: uint16(16859),
	1256: uint16(34123),
	1257: uint16(33488),
	1258: uint16(33562),
	1259: uint16(3606),
	1260: uint16(6068),
	1261: uint16(14017),
	1262: uint16(12669),
	1263: uint16(13658),
	1264: uint16(33403),
	1265: uint16(33506),
	1266: uint16(33560),
	1267: uint16(16011),
	1268: uint16(28067),
	1269: uint16(27397),
	1270: uint16(27543),
	1271: uint16(13774),
	1272: uint16(15807),
	1273: uint16(33565),
	1274: uint16(21996),
	1275: uint16(33669),
	1276: uint16(17675),
	1277: uint16(28069),
	1278: uint16(33708),
	1280: uint16(33747),
	1281: uint16(13438),
	1282: uint16(28372),
	1283: uint16(27223),
	1284: uint16(34138),
	1285: uint16(13462),
	1286: uint16(28226),
	1287: uint16(12015),
	1288: uint16(33880),
	1289: uint16(23524),
	1290: uint16(33905),
	1291: uint16(15827),
	1292: uint16(17636),
	1293: uint16(27303),
	1294: uint16(33866),
	1295: uint16(15541),
	1296: uint16(31064),
	1298: uint16(27542),
	1299: uint16(28279),
	1300: uint16(28227),
	1301: uint16(34014),
	1303: uint16(33681),
	1304: uint16(17568),
	1305: uint16(33939),
	1306: uint16(34020),
	1307: uint16(23697),
	1308: uint16(16960),
	1309: uint16(23744),
	1310: uint16(17731),
	1311: uint16(34100),
	1312: uint16(23282),
	1313: uint16(28313),
	1314: uint16(17703),
	1315: uint16(34163),
	1316: uint16(17686),
	1317: uint16(26559),
	1318: uint16(34326),
	1319: uint16(34341),
	1320: uint16(34363),
	1321: uint16(34241),
	1322: uint16(28808),
	1323: uint16(34306),
	1324: uint16(5506),
	1325: uint16(28877),
	1326: uint16(63922),
	1327: uint16(17770),
	1328: uint16(34344),
	1329: uint16(13896),
	1330: uint16(6306),
	1331: uint16(21495),
	1332: uint16(29594),
	1333: uint16(34430),
	1334: uint16(34673),
	1335: uint16(41208),
	1336: uint16(34798),
	1337: uint16(11303),
	1338: uint16(34737),
	1339: uint16(34778),
	1340: uint16(34831),
	1341: uint16(22113),
	1342: uint16(34412),
	1343: uint16(26710),
	1344: uint16(17935),
	1345: uint16(34885),
	1346: uint16(34886),
	1347: uint16(30176),
	1348: uint16(15801),
	1349: uint16(30180),
	1350: uint16(34910),
	1351: uint16(34972),
	1352: uint16(18011),
	1353: uint16(34996),
	1354: uint16(34997),
	1355: uint16(25537),
	1356: uint16(35013),
	1357: uint16(30583),
	1358: uint16(30479),
	1359: uint16(35207),
	1360: uint16(35210),
	1363: uint16(35239),
	1364: uint16(35260),
	1365: uint16(35365),
	1366: uint16(35303),
	1367: uint16(31012),
	1368: uint16(31421),
	1369: uint16(35484),
	1370: uint16(30611),
	1371: uint16(37374),
	1372: uint16(35472),
	1373: uint16(31321),
	1374: uint16(31465),
	1375: uint16(31546),
	1376: uint16(16271),
	1377: uint16(18195),
	1378: uint16(31544),
	1379: uint16(29052),
	1380: uint16(35596),
	1381: uint16(35615),
	1382: uint16(21552),
	1383: uint16(21861),
	1384: uint16(35647),
	1385: uint16(35660),
	1386: uint16(35661),
	1387: uint16(35497),
	1388: uint16(19066),
	1389: uint16(35728),
	1390: uint16(35739),
	1391: uint16(35503),
	1392: uint16(5855),
	1393: uint16(17941),
	1394: uint16(34895),
	1395: uint16(35995),
	1396: uint16(32084),
	1397: uint16(32143),
	1398: uint16(63956),
	1399: uint16(14117),
	1400: uint16(32083),
	1401: uint16(36054),
	1402: uint16(32152),
	1403: uint16(32189),
	1404: uint16(36114),
	1405: uint16(36099),
	1406: uint16(6416),
	1407: uint16(36059),
	1408: uint16(28764),
	1409: uint16(36113),
	1410: uint16(19657),
	1411: uint16(16080),
	1413: uint16(36265),
	1414: uint16(32770),
	1415: uint16(4116),
	1416: uint16(18826),
	1417: uint16(15228),
	1418: uint16(33212),
	1419: uint16(28940),
	1420: uint16(31463),
	1421: uint16(36525),
	1422: uint16(36534),
	1423: uint16(36547),
	1424: uint16(37588),
	1425: uint16(36633),
	1426: uint16(36653),
	1427: uint16(33637),
	1428: uint16(33810),
	1429: uint16(36773),
	1430: uint16(37635),
	1431: uint16(41631),
	1432: uint16(2640),
	1433: uint16(36787),
	1434: uint16(18730),
	1435: uint16(35294),
	1436: uint16(34109),
	1437: uint16(15803),
	1438: uint16(24312),
	1439: uint16(12898),
	1440: uint16(36857),
	1441: uint16(40980),
	1442: uint16(34492),
	1443: uint16(34049),
	1444: uint16(8997),
	1445: uint16(14720),
	1446: uint16(28375),
	1447: uint16(36919),
	1448: uint16(34108),
	1449: uint16(31422),
	1450: uint16(36961),
	1451: uint16(34156),
	1452: uint16(34315),
	1453: uint16(37032),
	1454: uint16(34579),
	1455: uint16(37060),
	1456: uint16(34534),
	1457: uint16(37038),
	1459: uint16(37223),
	1460: uint16(15088),
	1461: uint16(37289),
	1462: uint16(37316),
	1463: uint16(31916),
	1464: uint16(35123),
	1465: uint16(7817),
	1466: uint16(37390),
	1467: uint16(27807),
	1468: uint16(37441),
	1469: uint16(37474),
	1470: uint16(21945),
	1472: uint16(35526),
	1473: uint16(15515),
	1474: uint16(35596),
	1475: uint16(21979),
	1476: uint16(3377),
	1477: uint16(37676),
	1478: uint16(37739),
	1479: uint16(35553),
	1480: uint16(35819),
	1481: uint16(28815),
	1482: uint16(23235),
	1483: uint16(35554),
	1484: uint16(35557),
	1485: uint16(18789),
	1486: uint16(37444),
	1487: uint16(35820),
	1488: uint16(35897),
	1489: uint16(35839),
	1490: uint16(37747),
	1491: uint16(37979),
	1492: uint16(36540),
	1493: uint16(38277),
	1494: uint16(38310),
	1495: uint16(37926),
	1496: uint16(38304),
	1497: uint16(28662),
	1498: uint16(17081),
	1499: uint16(9850),
	1500: uint16(34520),
	1501: uint16(4732),
	1502: uint16(15918),
	1503: uint16(18911),
	1504: uint16(27676),
	1505: uint16(38523),
	1506: uint16(38550),
	1507: uint16(16748),
	1508: uint16(38563),
	1509: uint16(28373),
	1510: uint16(25050),
	1511: uint16(38582),
	1512: uint16(30965),
	1513: uint16(35552),
	1514: uint16(38589),
	1515: uint16(21452),
	1516: uint16(18849),
	1517: uint16(27832),
	1518: uint16(628),
	1519: uint16(25616),
	1520: uint16(37039),
	1521: uint16(37093),
	1522: uint16(19153),
	1523: uint16(6421),
	1524: uint16(13066),
	1525: uint16(38705),
	1526: uint16(34370),
	1527: uint16(38710),
	1528: uint16(18959),
	1529: uint16(17725),
	1530: uint16(17797),
	1531: uint16(19177),
	1532: uint16(28789),
	1533: uint16(23361),
	1534: uint16(38683),
	1536: uint16(37333),
	1537: uint16(38743),
	1538: uint16(23370),
	1539: uint16(37355),
	1540: uint16(38751),
	1541: uint16(37925),
	1542: uint16(20688),
	1543: uint16(12471),
	1544: uint16(12476),
	1545: uint16(38793),
	1546: uint16(38815),
	1547: uint16(38833),
	1548: uint16(38846),
	1549: uint16(38848),
	1550: uint16(38866),
	1551: uint16(38880),
	1552: uint16(21612),
	1553: uint16(38894),
	1554: uint16(29724),
	1555: uint16(37939),
	1557: uint16(38901),
	1558: uint16(37917),
	1559: uint16(31098),
	1560: uint16(19153),
	1561: uint16(38964),
	1562: uint16(38963),
	1563: uint16(38987),
	1564: uint16(39014),
	1565: uint16(15118),
	1566: uint16(29045),
	1567: uint16(15697),
	1568: uint16(1584),
	1569: uint16(16732),
	1570: uint16(22278),
	1571: uint16(39114),
	1572: uint16(39095),
	1573: uint16(39112),
	1574: uint16(39111),
	1575: uint16(19199),
	1576: uint16(27943),
	1577: uint16(5843),
	1578: uint16(21936),
	1579: uint16(39137),
	1580: uint16(39142),
	1581: uint16(39148),
	1582: uint16(37752),
	1583: uint16(39225),
	1584: uint16(18985),
	1585: uint16(19314),
	1586: uint16(38999),
	1587: uint16(39173),
	1588: uint16(39413),
	1589: uint16(39436),
	1590: uint16(39483),
	1591: uint16(39440),
	1592: uint16(39512),
	1593: uint16(22309),
	1594: uint16(14020),
	1595: uint16(37041),
	1596: uint16(39893),
	1597: uint16(39648),
	1598: uint16(39650),
	1599: uint16(39685),
	1600: uint16(39668),
	1601: uint16(19470),
	1602: uint16(39700),
	1603: uint16(39725),
	1604: uint16(34304),
	1605: uint16(20532),
	1606: uint16(39732),
	1607: uint16(27048),
	1608: uint16(14531),
	1609: uint16(12413),
	1610: uint16(39760),
	1611: uint16(39744),
	1612: uint16(40254),
	1613: uint16(23109),
	1614: uint16(6243),
	1615: uint16(39822),
	1616: uint16(16971),
	1617: uint16(39938),
	1618: uint16(39935),
	1619: uint16(39948),
	1620: uint16(40552),
	1621: uint16(40404),
	1622: uint16(40887),
	1623: uint16(41362),
	1624: uint16(41387),
	1625: uint16(41185),
	1626: uint16(41251),
	1627: uint16(41439),
	1628: uint16(40318),
	1629: uint16(40323),
	1630: uint16(41268),
	1631: uint16(40462),
	1632: uint16(26760),
	1633: uint16(40388),
	1634: uint16(8539),
	1635: uint16(41363),
	1636: uint16(41504),
	1637: uint16(6459),
	1638: uint16(41523),
	1639: uint16(40249),
	1640: uint16(41145),
	1641: uint16(41652),
	1642: uint16(40592),
	1643: uint16(40597),
	1644: uint16(40606),
	1645: uint16(40610),
	1646: uint16(19764),
	1647: uint16(40618),
	1648: uint16(40623),
	1649: uint16(17252),
	1650: uint16(40641),
	1651: uint16(15200),
	1652: uint16(14821),
	1653: uint16(15645),
	1654: uint16(20274),
	1655: uint16(14270),
	1656: uint16(35883),
	1657: uint16(40706),
	1658: uint16(40712),
	1659: uint16(19350),
	1660: uint16(37924),
	1661: uint16(28066),
	1662: uint16(40727),
	1664: uint16(40761),
	1665: uint16(22175),
	1666: uint16(22154),
	1667: uint16(40773),
	1668: uint16(39352),
	1669: uint16(37003),
	1670: uint16(38898),
	1671: uint16(33919),
	1672: uint16(40802),
	1673: uint16(40809),
	1674: uint16(31452),
	1675: uint16(40846),
	1676: uint16(29206),
	1677: uint16(19390),
	1678: uint16(18805),
	1679: uint16(18875),
	1680: uint16(29047),
	1681: uint16(18936),
	1682: uint16(17224),
	1683: uint16(19025),
	1684: uint16(29598),
	1685: uint16(35802),
	1686: uint16(6394),
	1687: uint16(31135),
	1688: uint16(35198),
	1689: uint16(36406),
	1690: uint16(37737),
	1691: uint16(37875),
	1692: uint16(35396),
	1693: uint16(37612),
	1694: uint16(37761),
	1695: uint16(37835),
	1696: uint16(35180),
	1697: uint16(17593),
	1698: uint16(29207),
	1699: uint16(16107),
	1700: uint16(30578),
	1701: uint16(31299),
	1702: uint16(28880),
	1703: uint16(17523),
	1704: uint16(17400),
	1705: uint16(29054),
	1706: uint16(6127),
	1707: uint16(28835),
	1708: uint16(6334),
	1709: uint16(13721),
	1710: uint16(16071),
	1711: uint16(6277),
	1712: uint16(21551),
	1713: uint16(6136),
	1714: uint16(14114),
	1715: uint16(5883),
	1716: uint16(6201),
	1717: uint16(14049),
	1718: uint16(6004),
	1719: uint16(6353),
	1720: uint16(24395),
	1721: uint16(14115),
	1722: uint16(5824),
	1723: uint16(22363),
	1724: uint16(18981),
	1725: uint16(5118),
	1726: uint16(4776),
	1727: uint16(5062),
	1728: uint16(5302),
	1729: uint16(34051),
	1730: uint16(13990),
	1732: uint16(33877),
	1733: uint16(18836),
	1734: uint16(29029),
	1735: uint16(15921),
	1736: uint16(21852),
	1737: uint16(16123),
	1738: uint16(28754),
	1739: uint16(17652),
	1740: uint16(14062),
	1741: uint16(39325),
	1742: uint16(28454),
	1743: uint16(26617),
	1744: uint16(14131),
	1745: uint16(15381),
	1746: uint16(15847),
	1747: uint16(22636),
	1748: uint16(6434),
	1749: uint16(26640),
	1750: uint16(16471),
	1751: uint16(14143),
	1752: uint16(16609),
	1753: uint16(16523),
	1754: uint16(16655),
	1755: uint16(27681),
	1756: uint16(21707),
	1757: uint16(22174),
	1758: uint16(26289),
	1759: uint16(22162),
	1760: uint16(4063),
	1761: uint16(2984),
	1762: uint16(3597),
	1763: uint16(37830),
	1764: uint16(35603),
	1765: uint16(37788),
	1766: uint16(20216),
	1767: uint16(20779),
	1768: uint16(14361),
	1769: uint16(17462),
	1770: uint16(20156),
	1771: uint16(1125),
	1772: uint16(895),
	1773: uint16(20299),
	1774: uint16(20362),
	1775: uint16(22097),
	1776: uint16(23144),
	1777: uint16(427),
	1778: uint16(971),
	1779: uint16(14745),
	1780: uint16(778),
	1781: uint16(1044),
	1782: uint16(13365),
	1783: uint16(20265),
	1784: uint16(704),
	1785: uint16(36531),
	1786: uint16(629),
	1787: uint16(35546),
	1788: uint16(524),
	1789: uint16(20120),
	1790: uint16(20685),
	1791: uint16(20749),
	1792: uint16(20386),
	1793: uint16(20227),
	1794: uint16(18958),
	1795: uint16(16010),
	1796: uint16(20290),
	1797: uint16(20526),
	1798: uint16(20588),
	1799: uint16(20609),
	1800: uint16(20428),
	1801: uint16(20453),
	1802: uint16(20568),
	1803: uint16(20732),
	1808: uint16(28278),
	1809: uint16(13717),
	1810: uint16(15929),
	1811: uint16(16063),
	1812: uint16(28018),
	1813: uint16(6276),
	1814: uint16(16009),
	1815: uint16(20904),
	1816: uint16(20931),
	1817: uint16(1504),
	1818: uint16(17629),
	1819: uint16(1187),
	1820: uint16(1170),
	1821: uint16(1169),
	1822: uint16(36218),
	1823: uint16(35484),
	1824: uint16(1806),
	1825: uint16(21081),
	1826: uint16(21156),
	1827: uint16(2163),
	1828: uint16(21217),
	1830: uint16(18042),
	1831: uint16(29068),
	1832: uint16(17292),
	1833: uint16(3104),
	1834: uint16(18860),
	1835: uint16(4324),
	1836: uint16(27089),
	1837: uint16(3613),
	1839: uint16(16094),
	1840: uint16(29849),
	1841: uint16(29716),
	1842: uint16(29782),
	1843: uint16(29592),
	1844: uint16(19342),
	1845: uint16(19132),
	1846: uint16(16525),
	1847: uint16(21456),
	1848: uint16(13700),
	1849: uint16(29199),
	1850: uint16(16585),
	1851: uint16(21940),
	1852: uint16(837),
	1853: uint16(21709),
	1854: uint16(3014),
	1855: uint16(22301),
	1856: uint16(37469),
	1857: uint16(38644),
	1858: uint16(37734),
	1859: uint16(22493),
	1860: uint16(22413),
	1861: uint16(22399),
	1862: uint16(13886),
	1863: uint16(22731),
	1864: uint16(23193),
	1865: uint16(35398),
	1866: uint16(5882),
	1867: uint16(5999),
	1868: uint16(5904),
	1869: uint16(23084),
	1870: uint16(22968),
	1871: uint16(37519),
	1872: uint16(23166),
	1873: uint16(23247),
	1874: uint16(23058),
	1875: uint16(22854),
	1876: uint16(6643),
	1877: uint16(6241),
	1878: uint16(17045),
	1879: uint16(14069),
	1880: uint16(27909),
	1881: uint16(29763),
	1882: uint16(23073),
	1883: uint16(24195),
	1884: uint16(23169),
	1885: uint16(35799),
	1886: uint16(1043),
	1887: uint16(37856),
	1888: uint16(29836),
	1889: uint16(4867),
	1890: uint16(28933),
	1891: uint16(18802),
	1892: uint16(37896),
	1893: uint16(35323),
	1894: uint16(37821),
	1895: uint16(14240),
	1896: uint16(23582),
	1897: uint16(23710),
	1898: uint16(24158),
	1899: uint16(24136),
	1900: uint16(6550),
	1901: uint16(6524),
	1902: uint16(15086),
	1903: uint16(24269),
	1904: uint16(23375),
	1905: uint16(6403),
	1906: uint16(6404),
	1907: uint16(14081),
	1908: uint16(6304),
	1909: uint16(14045),
	1910: uint16(5886),
	1911: uint16(14035),
	1912: uint16(33066),
	1913: uint16(35399),
	1914: uint16(7610),
	1915: uint16(13426),
	1916: uint16(35240),
	1917: uint16(24332),
	1918: uint16(24334),
	1919: uint16(6439),
	1920: uint16(6059),
	1921: uint16(23147),
	1922: uint16(5947),
	1923: uint16(23364),
	1924: uint16(34324),
	1925: uint16(30205),
	1926: uint16(34912),
	1927: uint16(24702),
	1928: uint16(10336),
	1929: uint16(9771),
	1930: uint16(24539),
	1931: uint16(16056),
	1932: uint16(9647),
	1933: uint16(9662),
	1934: uint16(37000),
	1935: uint16(28531),
	1936: uint16(25024),
	1937: uint16(62),
	1938: uint16(70),
	1939: uint16(9755),
	1940: uint16(24985),
	1941: uint16(24984),
	1942: uint16(24693),
	1943: uint16(11419),
	1944: uint16(11527),
	1945: uint16(18132),
	1946: uint16(37197),
	1947: uint16(25713),
	1948: uint16(18021),
	1949: uint16(11114),
	1950: uint16(14889),
	1951: uint16(11042),
	1952: uint16(13392),
	1953: uint16(39146),
	1954: uint16(11896),
	1955: uint16(25399),
	1956: uint16(42075),
	1957: uint16(25782),
	1958: uint16(25393),
	1959: uint16(25553),
	1960: uint16(18915),
	1961: uint16(11623),
	1962: uint16(25252),
	1963: uint16(11425),
	1964: uint16(25659),
	1965: uint16(25963),
	1966: uint16(26994),
	1967: uint16(15348),
	1968: uint16(12430),
	1969: uint16(12973),
	1970: uint16(18825),
	1971: uint16(12971),
	1972: uint16(21773),
	1973: uint16(13024),
	1974: uint16(6361),
	1975: uint16(37951),
	1976: uint16(26318),
	1977: uint16(12937),
	1978: uint16(12723),
	1979: uint16(15072),
	1980: uint16(16784),
	1981: uint16(21892),
	1982: uint16(35618),
	1983: uint16(21903),
	1984: uint16(5884),
	1985: uint16(21851),
	1986: uint16(21541),
	1987: uint16(30958),
	1988: uint16(12547),
	1989: uint16(6186),
	1990: uint16(12852),
	1991: uint16(13412),
	1992: uint16(12815),
	1993: uint16(12674),
	1994: uint16(17097),
	1995: uint16(26254),
	1996: uint16(27940),
	1997: uint16(26219),
	1998: uint16(19347),
	1999: uint16(26160),
	2000: uint16(30832),
	2001: uint16(7659),
	2002: uint16(26211),
	2003: uint16(13010),
	2004: uint16(13025),
	2005: uint16(26142),
	2006: uint16(22642),
	2007: uint16(14545),
	2008: uint16(14394),
	2009: uint16(14268),
	2010: uint16(15257),
	2011: uint16(14242),
	2012: uint16(13310),
	2013: uint16(29904),
	2014: uint16(15254),
	2015: uint16(26511),
	2016: uint16(17962),
	2017: uint16(26806),
	2018: uint16(26654),
	2019: uint16(15300),
	2020: uint16(27326),
	2021: uint16(14435),
	2022: uint16(14293),
	2023: uint16(17543),
	2024: uint16(27187),
	2025: uint16(27218),
	2026: uint16(27337),
	2027: uint16(27397),
	2028: uint16(6418),
	2029: uint16(25873),
	2030: uint16(26776),
	2031: uint16(27212),
	2032: uint16(15319),
	2033: uint16(27258),
	2034: uint16(27479),
	2035: uint16(16320),
	2036: uint16(15514),
	2037: uint16(37792),
	2038: uint16(37618),
	2039: uint16(35818),
	2040: uint16(35531),
	2041: uint16(37513),
	2042: uint16(32798),
	2043: uint16(35292),
	2044: uint16(37991),
	2045: uint16(28069),
	2046: uint16(28427),
	2047: uint16(18924),
	2049: uint16(16255),
	2050: uint16(15759),
	2051: uint16(28164),
	2052: uint16(16444),
	2053: uint16(23101),
	2054: uint16(28170),
	2055: uint16(22599),
	2056: uint16(27940),
	2057: uint16(30786),
	2058: uint16(28987),
	2059: uint16(17178),
	2060: uint16(17014),
	2061: uint16(28913),
	2062: uint16(29264),
	2063: uint16(29319),
	2064: uint16(29332),
	2065: uint16(18319),
	2066: uint16(18213),
	2067: uint16(20857),
	2068: uint16(19108),
	2069: uint16(1515),
	2070: uint16(29818),
	2071: uint16(16120),
	2072: uint16(13919),
	2073: uint16(19018),
	2074: uint16(18711),
	2075: uint16(24545),
	2076: uint16(16134),
	2077: uint16(16049),
	2078: uint16(19167),
	2079: uint16(35875),
	2080: uint16(16181),
	2081: uint16(24743),
	2082: uint16(16115),
	2083: uint16(29900),
	2084: uint16(29756),
	2085: uint16(37767),
	2086: uint16(29751),
	2087: uint16(17567),
	2088: uint16(28138),
	2089: uint16(17745),
	2090: uint16(30083),
	2091: uint16(16227),
	2092: uint16(19673),
	2093: uint16(19718),
	2094: uint16(16216),
	2095: uint16(30037),
	2096: uint16(30323),
	2097: uint16(42438),
	2098: uint16(15129),
	2099: uint16(29800),
	2100: uint16(35532),
	2101: uint16(18859),
	2102: uint16(18830),
	2103: uint16(15099),
	2104: uint16(15821),
	2105: uint16(19022),
	2106: uint16(16127),
	2107: uint16(18885),
	2108: uint16(18675),
	2109: uint16(37370),
	2110: uint16(22322),
	2111: uint16(37698),
	2112: uint16(35555),
	2113: uint16(6244),
	2114: uint16(20703),
	2115: uint16(21025),
	2116: uint16(20967),
	2117: uint16(30584),
	2118: uint16(12850),
	2119: uint16(30478),
	2120: uint16(30479),
	2121: uint16(30587),
	2122: uint16(18071),
	2123: uint16(14209),
	2124: uint16(14942),
	2125: uint16(18672),
	2126: uint16(29752),
	2127: uint16(29851),
	2128: uint16(16063),
	2129: uint16(19130),
	2130: uint16(19143),
	2131: uint16(16584),
	2132: uint16(19094),
	2133: uint16(25006),
	2134: uint16(37639),
	2135: uint16(21889),
	2136: uint16(30750),
	2137: uint16(30861),
	2138: uint16(30856),
	2139: uint16(30930),
	2140: uint16(29648),
	2141: uint16(31065),
	2142: uint16(30529),
	2143: uint16(22243),
	2144: uint16(16654),
	2146: uint16(33942),
	2147: uint16(31141),
	2148: uint16(27181),
	2149: uint16(16122),
	2150: uint16(31290),
	2151: uint16(31220),
	2152: uint16(16750),
	2153: uint16(5862),
	2154: uint16(16690),
	2155: uint16(37429),
	2156: uint16(31217),
	2157: uint16(3404),
	2158: uint16(18828),
	2159: uint16(665),
	2160: uint16(15802),
	2161: uint16(5998),
	2162: uint16(13719),
	2163: uint16(21867),
	2164: uint16(13680),
	2165: uint16(13994),
	2166: uint16(468),
	2167: uint16(3085),
	2168: uint16(31458),
	2169: uint16(23129),
	2170: uint16(9973),
	2171: uint16(23215),
	2172: uint16(23196),
	2173: uint16(23053),
	2174: uint16(603),
	2175: uint16(30960),
	2176: uint16(23082),
	2177: uint16(23494),
	2178: uint16(31486),
	2179: uint16(16889),
	2180: uint16(31837),
	2181: uint16(31853),
	2182: uint16(16913),
	2183: uint16(23475),
	2184: uint16(24252),
	2185: uint16(24230),
	2186: uint16(31949),
	2187: uint16(18937),
	2188: uint16(6064),
	2189: uint16(31886),
	2190: uint16(31868),
	2191: uint16(31918),
	2192: uint16(27314),
	2193: uint16(32220),
	2194: uint16(32263),
	2195: uint16(32211),
	2196: uint16(32590),
	2197: uint16(25185),
	2198: uint16(24924),
	2199: uint16(31560),
	2200: uint16(32151),
	2201: uint16(24194),
	2202: uint16(17002),
	2203: uint16(27509),
	2204: uint16(2326),
	2205: uint16(26582),
	2206: uint16(78),
	2207: uint16(13775),
	2208: uint16(22468),
	2209: uint16(25618),
	2210: uint16(25592),
	2211: uint16(18786),
	2212: uint16(32733),
	2213: uint16(31527),
	2214: uint16(2092),
	2215: uint16(23273),
	2216: uint16(23875),
	2217: uint16(31500),
	2218: uint16(24078),
	2219: uint16(39398),
	2220: uint16(34373),
	2221: uint16(39523),
	2222: uint16(27164),
	2223: uint16(13375),
	2224: uint16(14818),
	2225: uint16(18935),
	2226: uint16(26029),
	2227: uint16(39455),
	2228: uint16(26016),
	2229: uint16(33920),
	2230: uint16(28967),
	2231: uint16(27857),
	2232: uint16(17642),
	2233: uint16(33079),
	2234: uint16(17410),
	2235: uint16(32966),
	2236: uint16(33033),
	2237: uint16(33090),
	2238: uint16(26548),
	2239: uint16(39107),
	2240: uint16(27202),
	2241: uint16(33378),
	2242: uint16(33381),
	2243: uint16(27217),
	2244: uint16(33875),
	2245: uint16(28071),
	2246: uint16(34320),
	2247: uint16(29211),
	2248: uint16(23174),
	2249: uint16(16767),
	2250: uint16(6208),
	2251: uint16(23339),
	2252: uint16(6305),
	2253: uint16(23268),
	2254: uint16(6360),
	2255: uint16(34464),
	2256: uint16(63932),
	2257: uint16(15759),
	2258: uint16(34861),
	2259: uint16(29730),
	2260: uint16(23042),
	2261: uint16(34926),
	2262: uint16(20293),
	2263: uint16(34951),
	2264: uint16(35007),
	2265: uint16(35046),
	2266: uint16(35173),
	2267: uint16(35149),
	2268: uint16(22147),
	2269: uint16(35156),
	2270: uint16(30597),
	2271: uint16(30596),
	2272: uint16(35829),
	2273: uint16(35801),
	2274: uint16(35740),
	2275: uint16(35321),
	2276: uint16(16045),
	2277: uint16(33955),
	2278: uint16(18165),
	2279: uint16(18127),
	2280: uint16(14322),
	2281: uint16(35389),
	2282: uint16(35356),
	2283: uint16(37960),
	2284: uint16(24397),
	2285: uint16(37419),
	2286: uint16(17028),
	2287: uint16(26068),
	2288: uint16(28969),
	2289: uint16(28868),
	2290: uint16(6213),
	2291: uint16(40301),
	2292: uint16(35999),
	2293: uint16(36073),
	2294: uint16(32220),
	2295: uint16(22938),
	2296: uint16(30659),
	2297: uint16(23024),
	2298: uint16(17262),
	2299: uint16(14036),
	2300: uint16(36394),
	2301: uint16(36519),
	2302: uint16(19465),
	2303: uint16(36656),
	2304: uint16(36682),
	2305: uint16(17140),
	2306: uint16(27736),
	2307: uint16(28603),
	2308: uint16(8993),
	2309: uint16(18587),
	2310: uint16(28537),
	2311: uint16(28299),
	2312: uint16(6106),
	2313: uint16(39913),
	2314: uint16(14005),
	2315: uint16(18735),
	2316: uint16(37051),
	2318: uint16(21873),
	2319: uint16(18694),
	2320: uint16(37307),
	2321: uint16(37892),
	2322: uint16(35403),
	2323: uint16(16482),
	2324: uint16(35580),
	2325: uint16(37927),
	2326: uint16(35869),
	2327: uint16(35899),
	2328: uint16(34021),
	2329: uint16(35371),
	2330: uint16(38297),
	2331: uint16(38311),
	2332: uint16(38295),
	2333: uint16(38294),
	2334: uint16(36148),
	2335: uint16(29765),
	2336: uint16(16066),
	2337: uint16(18687),
	2338: uint16(19010),
	2339: uint16(17386),
	2340: uint16(16103),
	2341: uint16(12837),
	2342: uint16(38543),
	2343: uint16(36583),
	2344: uint16(36454),
	2345: uint16(36453),
	2346: uint16(16076),
	2347: uint16(18925),
	2348: uint16(19064),
	2349: uint16(16366),
	2350: uint16(29714),
	2351: uint16(29803),
	2352: uint16(16124),
	2353: uint16(38721),
	2354: uint16(37040),
	2355: uint16(26695),
	2356: uint16(18973),
	2357: uint16(37011),
	2358: uint16(22495),
	2360: uint16(37736),
	2361: uint16(35209),
	2362: uint16(35878),
	2363: uint16(35631),
	2364: uint16(25534),
	2365: uint16(37562),
	2366: uint16(23313),
	2367: uint16(35689),
	2368: uint16(18748),
	2369: uint16(29689),
	2370: uint16(16923),
	2371: uint16(38811),
	2372: uint16(38769),
	2373: uint16(39224),
	2374: uint16(3878),
	2375: uint16(24001),
	2376: uint16(35781),
	2377: uint16(19122),
	2378: uint16(38943),
	2379: uint16(38106),
	2380: uint16(37622),
	2381: uint16(38359),
	2382: uint16(37349),
	2383: uint16(17600),
	2384: uint16(35664),
	2385: uint16(19047),
	2386: uint16(35684),
	2387: uint16(39132),
	2388: uint16(35397),
	2389: uint16(16128),
	2390: uint16(37418),
	2391: uint16(18725),
	2392: uint16(33812),
	2393: uint16(39227),
	2394: uint16(39245),
	2395: uint16(31494),
	2396: uint16(15869),
	2397: uint16(39323),
	2398: uint16(19311),
	2399: uint16(39338),
	2400: uint16(39516),
	2401: uint16(35685),
	2402: uint16(22728),
	2403: uint16(27279),
	2404: uint16(39457),
	2405: uint16(23294),
	2406: uint16(39471),
	2407: uint16(39153),
	2408: uint16(19344),
	2409: uint16(39240),
	2410: uint16(39356),
	2411: uint16(19389),
	2412: uint16(19351),
	2413: uint16(37757),
	2414: uint16(22642),
	2415: uint16(4866),
	2416: uint16(22562),
	2417: uint16(18872),
	2418: uint16(5352),
	2419: uint16(30788),
	2420: uint16(10015),
	2421: uint16(15800),
	2422: uint16(26821),
	2423: uint16(15741),
	2424: uint16(37976),
	2425: uint16(14631),
	2426: uint16(24912),
	2427: uint16(10113),
	2428: uint16(10603),
	2429: uint16(24839),
	2430: uint16(40015),
	2431: uint16(40019),
	2432: uint16(40059),
	2433: uint16(39989),
	2434: uint16(39952),
	2435: uint16(39807),
	2436: uint16(39887),
	2437: uint16(40493),
	2438: uint16(39839),
	2439: uint16(41461),
	2440: uint16(41214),
	2441: uint16(40225),
	2442: uint16(19630),
	2443: uint16(16644),
	2444: uint16(40472),
	2445: uint16(19632),
	2446: uint16(40204),
	2447: uint16(41396),
	2448: uint16(41197),
	2449: uint16(41203),
	2450: uint16(39215),
	2451: uint16(40357),
	2452: uint16(33981),
	2453: uint16(28178),
	2454: uint16(28639),
	2455: uint16(27522),
	2456: uint16(34300),
	2457: uint16(17715),
	2458: uint16(28068),
	2459: uint16(28292),
	2460: uint16(28144),
	2461: uint16(33824),
	2462: uint16(34286),
	2463: uint16(28160),
	2464: uint16(14295),
	2465: uint16(24676),
	2466: uint16(31202),
	2467: uint16(13724),
	2468: uint16(13888),
	2469: uint16(18733),
	2470: uint16(18910),
	2471: uint16(15714),
	2472: uint16(37851),
	2473: uint16(37566),
	2474: uint16(37704),
	2475: uint16(703),
	2476: uint16(30905),
	2477: uint16(37495),
	2478: uint16(37965),
	2479: uint16(20452),
	2480: uint16(13376),
	2481: uint16(36964),
	2482: uint16(21853),
	2483: uint16(30781),
	2484: uint16(30804),
	2485: uint16(30902),
	2486: uint16(30795),
	2487: uint16(5975),
	2488: uint16(12745),
	2489: uint16(18753),
	2490: uint16(13978),
	2491: uint16(20338),
	2492: uint16(28634),
	2493: uint16(28633),
	2495: uint16(28702),
	2496: uint16(21524),
	2497: uint16(16821),
	2498: uint16(22459),
	2499: uint16(22771),
	2500: uint16(22410),
	2501: uint16(40214),
	2502: uint16(22487),
	2503: uint16(28980),
	2504: uint16(13487),
	2505: uint16(16812),
	2506: uint16(29163),
	2507: uint16(27712),
	2508: uint16(20375),
	2510: uint16(6069),
	2511: uint16(35401),
	2512: uint16(24844),
	2513: uint16(23246),
	2514: uint16(23051),
	2515: uint16(17084),
	2516: uint16(17544),
	2517: uint16(14124),
	2518: uint16(19323),
	2519: uint16(35324),
	2520: uint16(37819),
	2521: uint16(37816),
	2522: uint16(6358),
	2523: uint16(3869),
	2524: uint16(33906),
	2525: uint16(27840),
	2526: uint16(5139),
	2527: uint16(17146),
	2528: uint16(11302),
	2529: uint16(17345),
	2530: uint16(22932),
	2531: uint16(15799),
	2532: uint16(26433),
	2533: uint16(32168),
	2534: uint16(24923),
	2535: uint16(24740),
	2536: uint16(18873),
	2537: uint16(18827),
	2538: uint16(35322),
	2539: uint16(37605),
	2540: uint16(29666),
	2541: uint16(16105),
	2542: uint16(29876),
	2543: uint16(35683),
	2544: uint16(6303),
	2545: uint16(16097),
	2546: uint16(19123),
	2547: uint16(27352),
	2548: uint16(29683),
	2549: uint16(29691),
	2550: uint16(16086),
	2551: uint16(19006),
	2552: uint16(19092),
	2553: uint16(6105),
	2554: uint16(19046),
	2555: uint16(935),
	2556: uint16(5156),
	2557: uint16(18917),
	2558: uint16(29768),
	2559: uint16(18710),
	2560: uint16(28837),
	2561: uint16(18806),
	2562: uint16(37508),
	2563: uint16(29670),
	2564: uint16(37727),
	2565: uint16(1278),
	2566: uint16(37681),
	2567: uint16(35534),
	2568: uint16(35350),
	2569: uint16(37766),
	2570: uint16(35815),
	2571: uint16(21973),
	2572: uint16(18741),
	2573: uint16(35458),
	2574: uint16(29035),
	2575: uint16(18755),
	2576: uint16(3327),
	2577: uint16(22180),
	2578: uint16(1562),
	2579: uint16(3051),
	2580: uint16(3256),
	2581: uint16(21762),
	2582: uint16(31172),
	2583: uint16(6138),
	2584: uint16(32254),
	2585: uint16(5826),
	2586: uint16(19024),
	2587: uint16(6226),
	2588: uint16(17710),
	2589: uint16(37889),
	2590: uint16(14090),
	2591: uint16(35520),
	2592: uint16(18861),
	2593: uint16(22960),
	2594: uint16(6335),
	2595: uint16(6275),
	2596: uint16(29828),
	2597: uint16(23201),
	2598: uint16(14050),
	2599: uint16(15707),
	2600: uint16(14000),
	2601: uint16(37471),
	2602: uint16(23161),
	2603: uint16(35457),
	2604: uint16(6242),
	2605: uint16(37748),
	2606: uint16(15565),
	2607: uint16(2740),
	2608: uint16(19094),
	2609: uint16(14730),
	2610: uint16(20724),
	2611: uint16(15721),
	2612: uint16(15692),
	2613: uint16(5020),
	2614: uint16(29045),
	2615: uint16(17147),
	2616: uint16(33304),
	2617: uint16(28175),
	2618: uint16(37092),
	2619: uint16(17643),
	2620: uint16(27991),
	2621: uint16(32335),
	2622: uint16(28775),
	2623: uint16(27823),
	2624: uint16(15574),
	2625: uint16(16365),
	2626: uint16(15917),
	2627: uint16(28162),
	2628: uint16(28428),
	2629: uint16(15727),
	2630: uint16(1013),
	2631: uint16(30033),
	2632: uint16(14012),
	2633: uint16(13512),
	2634: uint16(18048),
	2635: uint16(16090),
	2636: uint16(18545),
	2637: uint16(22980),
	2638: uint16(37486),
	2639: uint16(18750),
	2640: uint16(36673),
	2641: uint16(35868),
	2642: uint16(27584),
	2643: uint16(22546),
	2644: uint16(22472),
	2645: uint16(14038),
	2646: uint16(5202),
	2647: uint16(28926),
	2648: uint16(17250),
	2649: uint16(19057),
	2650: uint16(12259),
	2651: uint16(4784),
	2652: uint16(9149),
	2653: uint16(26809),
	2654: uint16(26983),
	2655: uint16(5016),
	2656: uint16(13541),
	2657: uint16(31732),
	2658: uint16(14047),
	2659: uint16(35459),
	2660: uint16(14294),
	2661: uint16(13306),
	2662: uint16(19615),
	2663: uint16(27162),
	2664: uint16(13997),
	2665: uint16(27831),
	2666: uint16(33854),
	2667: uint16(17631),
	2668: uint16(17614),
	2669: uint16(27942),
	2670: uint16(27985),
	2671: uint16(27778),
	2672: uint16(28638),
	2673: uint16(28439),
	2674: uint16(28937),
	2675: uint16(33597),
	2676: uint16(5946),
	2677: uint16(33773),
	2678: uint16(27776),
	2679: uint16(28755),
	2680: uint16(6107),
	2681: uint16(22921),
	2682: uint16(23170),
	2683: uint16(6067),
	2684: uint16(23137),
	2685: uint16(23153),
	2686: uint16(6405),
	2687: uint16(16892),
	2688: uint16(14125),
	2689: uint16(23023),
	2690: uint16(5948),
	2691: uint16(14023),
	2692: uint16(29070),
	2693: uint16(37776),
	2694: uint16(26266),
	2695: uint16(17061),
	2696: uint16(23150),
	2697: uint16(23083),
	2698: uint16(17043),
	2699: uint16(27179),
	2700: uint16(16121),
	2701: uint16(30518),
	2702: uint16(17499),
	2703: uint16(17098),
	2704: uint16(28957),
	2705: uint16(16985),
	2706: uint16(35297),
	2707: uint16(20400),
	2708: uint16(27944),
	2709: uint16(23746),
	2710: uint16(17614),
	2711: uint16(32333),
	2712: uint16(17341),
	2713: uint16(27148),
	2714: uint16(16982),
	2715: uint16(4868),
	2716: uint16(28838),
	2717: uint16(28979),
	2718: uint16(17385),
	2719: uint16(15781),
	2720: uint16(27871),
	2721: uint16(63525),
	2722: uint16(19023),
	2723: uint16(32357),
	2724: uint16(23019),
	2725: uint16(23855),
	2726: uint16(15859),
	2727: uint16(24412),
	2728: uint16(19037),
	2729: uint16(6111),
	2730: uint16(32164),
	2731: uint16(33830),
	2732: uint16(21637),
	2733: uint16(15098),
	2734: uint16(13056),
	2735: uint16(532),
	2736: uint16(22398),
	2737: uint16(2261),
	2738: uint16(1561),
	2739: uint16(16357),
	2740: uint16(8094),
	2741: uint16(41654),
	2742: uint16(28675),
	2743: uint16(37211),
	2744: uint16(23920),
	2745: uint16(29583),
	2746: uint16(31955),
	2747: uint16(35417),
	2748: uint16(37920),
	2749: uint16(20424),
	2750: uint16(32743),
	2751: uint16(29389),
	2752: uint16(29456),
	2753: uint16(31476),
	2754: uint16(29496),
	2755: uint16(29497),
	2756: uint16(22262),
	2757: uint16(29505),
	2758: uint16(29512),
	2759: uint16(16041),
	2760: uint16(31512),
	2761: uint16(36972),
	2762: uint16(29173),
	2763: uint16(18674),
	2764: uint16(29665),
	2765: uint16(33270),
	2766: uint16(16074),
	2767: uint16(30476),
	2768: uint16(16081),
	2769: uint16(27810),
	2770: uint16(22269),
	2771: uint16(29721),
	2772: uint16(29726),
	2773: uint16(29727),
	2774: uint16(16098),
	2775: uint16(16112),
	2776: uint16(16116),
	2777: uint16(16122),
	2778: uint16(29907),
	2779: uint16(16142),
	2780: uint16(16211),
	2781: uint16(30018),
	2782: uint16(30061),
	2783: uint16(30066),
	2784: uint16(30093),
	2785: uint16(16252),
	2786: uint16(30152),
	2787: uint16(30172),
	2788: uint16(16320),
	2789: uint16(30285),
	2790: uint16(16343),
	2791: uint16(30324),
	2792: uint16(16348),
	2793: uint16(30330),
	2794: uint16(20316),
	2795: uint16(29064),
	2796: uint16(22051),
	2797: uint16(35200),
	2798: uint16(22633),
	2799: uint16(16413),
	2800: uint16(30531),
	2801: uint16(16441),
	2802: uint16(26465),
	2803: uint16(16453),
	2804: uint16(13787),
	2805: uint16(30616),
	2806: uint16(16490),
	2807: uint16(16495),
	2808: uint16(23646),
	2809: uint16(30654),
	2810: uint16(30667),
	2811: uint16(22770),
	2812: uint16(30744),
	2813: uint16(28857),
	2814: uint16(30748),
	2815: uint16(16552),
	2816: uint16(30777),
	2817: uint16(30791),
	2818: uint16(30801),
	2819: uint16(30822),
	2820: uint16(33864),
	2821: uint16(21813),
	2822: uint16(31027),
	2823: uint16(26627),
	2824: uint16(31026),
	2825: uint16(16643),
	2826: uint16(16649),
	2827: uint16(31121),
	2828: uint16(31129),
	2829: uint16(36795),
	2830: uint16(31238),
	2831: uint16(36796),
	2832: uint16(16743),
	2833: uint16(31377),
	2834: uint16(16818),
	2835: uint16(31420),
	2836: uint16(33401),
	2837: uint16(16836),
	2838: uint16(31439),
	2839: uint16(31451),
	2840: uint16(16847),
	2841: uint16(20001),
	2842: uint16(31586),
	2843: uint16(31596),
	2844: uint16(31611),
	2845: uint16(31762),
	2846: uint16(31771),
	2847: uint16(16992),
	2848: uint16(17018),
	2849: uint16(31867),
	2850: uint16(31900),
	2851: uint16(17036),
	2852: uint16(31928),
	2853: uint16(17044),
	2854: uint16(31981),
	2855: uint16(36755),
	2856: uint16(28864),
	2857: uint16(3279),
	2858: uint16(32207),
	2859: uint16(32212),
	2860: uint16(32208),
	2861: uint16(32253),
	2862: uint16(32686),
	2863: uint16(32692),
	2864: uint16(29343),
	2865: uint16(17303),
	2866: uint16(32800),
	2867: uint16(32805),
	2868: uint16(31545),
	2869: uint16(32814),
	2870: uint16(32817),
	2871: uint16(32852),
	2872: uint16(15820),
	2873: uint16(22452),
	2874: uint16(28832),
	2875: uint16(32951),
	2876: uint16(33001),
	2877: uint16(17389),
	2878: uint16(33036),
	2879: uint16(29482),
	2880: uint16(33038),
	2881: uint16(33042),
	2882: uint16(30048),
	2883: uint16(33044),
	2884: uint16(17409),
	2885: uint16(15161),
	2886: uint16(33110),
	2887: uint16(33113),
	2888: uint16(33114),
	2889: uint16(17427),
	2890: uint16(22586),
	2891: uint16(33148),
	2892: uint16(33156),
	2893: uint16(17445),
	2894: uint16(33171),
	2895: uint16(17453),
	2896: uint16(33189),
	2897: uint16(22511),
	2898: uint16(33217),
	2899: uint16(33252),
	2900: uint16(33364),
	2901: uint16(17551),
	2902: uint16(33446),
	2903: uint16(33398),
	2904: uint16(33482),
	2905: uint16(33496),
	2906: uint16(33535),
	2907: uint16(17584),
	2908: uint16(33623),
	2909: uint16(38505),
	2910: uint16(27018),
	2911: uint16(33797),
	2912: uint16(28917),
	2913: uint16(33892),
	2914: uint16(24803),
	2915: uint16(33928),
	2916: uint16(17668),
	2917: uint16(33982),
	2918: uint16(34017),
	2919: uint16(34040),
	2920: uint16(34064),
	2921: uint16(34104),
	2922: uint16(34130),
	2923: uint16(17723),
	2924: uint16(34159),
	2925: uint16(34160),
	2926: uint16(34272),
	2927: uint16(17783),
	2928: uint16(34418),
	2929: uint16(34450),
	2930: uint16(34482),
	2931: uint16(34543),
	2932: uint16(38469),
	2933: uint16(34699),
	2934: uint16(17926),
	2935: uint16(17943),
	2936: uint16(34990),
	2937: uint16(35071),
	2938: uint16(35108),
	2939: uint16(35143),
	2940: uint16(35217),
	2941: uint16(31079),
	2942: uint16(35369),
	2943: uint16(35384),
	2944: uint16(35476),
	2945: uint16(35508),
	2946: uint16(35921),
	2947: uint16(36052),
	2948: uint16(36082),
	2949: uint16(36124),
	2950: uint16(18328),
	2951: uint16(22623),
	2952: uint16(36291),
	2953: uint16(18413),
	2954: uint16(20206),
	2955: uint16(36410),
	2956: uint16(21976),
	2957: uint16(22356),
	2958: uint16(36465),
	2959: uint16(22005),
	2960: uint16(36528),
	2961: uint16(18487),
	2962: uint16(36558),
	2963: uint16(36578),
	2964: uint16(36580),
	2965: uint16(36589),
	2966: uint16(36594),
	2967: uint16(36791),
	2968: uint16(36801),
	2969: uint16(36810),
	2970: uint16(36812),
	2971: uint16(36915),
	2972: uint16(39364),
	2973: uint16(18605),
	2974: uint16(39136),
	2975: uint16(37395),
	2976: uint16(18718),
	2977: uint16(37416),
	2978: uint16(37464),
	2979: uint16(37483),
	2980: uint16(37553),
	2981: uint16(37550),
	2982: uint16(37567),
	2983: uint16(37603),
	2984: uint16(37611),
	2985: uint16(37619),
	2986: uint16(37620),
	2987: uint16(37629),
	2988: uint16(37699),
	2989: uint16(37764),
	2990: uint16(37805),
	2991: uint16(18757),
	2992: uint16(18769),
	2993: uint16(40639),
	2994: uint16(37911),
	2995: uint16(21249),
	2996: uint16(37917),
	2997: uint16(37933),
	2998: uint16(37950),
	2999: uint16(18794),
	3000: uint16(37972),
	3001: uint16(38009),
	3002: uint16(38189),
	3003: uint16(38306),
	3004: uint16(18855),
	3005: uint16(38388),
	3006: uint16(38451),
	3007: uint16(18917),
	3008: uint16(26528),
	3009: uint16(18980),
	3010: uint16(38720),
	3011: uint16(18997),
	3012: uint16(38834),
	3013: uint16(38850),
	3014: uint16(22100),
	3015: uint16(19172),
	3016: uint16(24808),
	3017: uint16(39097),
	3018: uint16(19225),
	3019: uint16(39153),
	3020: uint16(22596),
	3021: uint16(39182),
	3022: uint16(39193),
	3023: uint16(20916),
	3024: uint16(39196),
	3025: uint16(39223),
	3026: uint16(39234),
	3027: uint16(39261),
	3028: uint16(39266),
	3029: uint16(19312),
	3030: uint16(39365),
	3031: uint16(19357),
	3032: uint16(39484),
	3033: uint16(39695),
	3034: uint16(31363),
	3035: uint16(39785),
	3036: uint16(39809),
	3037: uint16(39901),
	3038: uint16(39921),
	3039: uint16(39924),
	3040: uint16(19565),
	3041: uint16(39968),
	3042: uint16(14191),
	3043: uint16(7106),
	3044: uint16(40265),
	3045: uint16(39994),
	3046: uint16(40702),
	3047: uint16(22096),
	3048: uint16(40339),
	3049: uint16(40381),
	3050: uint16(40384),
	3051: uint16(40444),
	3052: uint16(38134),
	3053: uint16(36790),
	3054: uint16(40571),
	3055: uint16(40620),
	3056: uint16(40625),
	3057: uint16(40637),
	3058: uint16(40646),
	3059: uint16(38108),
	3060: uint16(40674),
	3061: uint16(40689),
	3062: uint16(40696),
	3063: uint16(31432),
	3064: uint16(40772),
	3065: uint16(148),
	3066: uint16(695),
	3067: uint16(928),
	3068: uint16(26906),
	3069: uint16(38083),
	3070: uint16(22956),
	3071: uint16(1239),
	3072: uint16(22592),
	3073: uint16(38081),
	3074: uint16(14265),
	3075: uint16(1493),
	3076: uint16(1557),
	3077: uint16(1654),
	3078: uint16(5818),
	3079: uint16(22359),
	3080: uint16(29043),
	3081: uint16(2754),
	3082: uint16(2765),
	3083: uint16(3007),
	3084: uint16(21610),
	3085: uint16(63547),
	3086: uint16(3019),
	3087: uint16(21662),
	3088: uint16(3067),
	3089: uint16(3131),
	3090: uint16(3155),
	3091: uint16(3173),
	3092: uint16(3196),
	3093: uint16(24807),
	3094: uint16(3213),
	3095: uint16(22138),
	3096: uint16(3253),
	3097: uint16(3293),
	3098: uint16(3309),
	3099: uint16(3439),
	3100: uint16(3506),
	3101: uint16(3528),
	3102: uint16(26965),
	3103: uint16(39983),
	3104: uint16(34725),
	3105: uint16(3588),
	3106: uint16(3598),
	3107: uint16(3799),
	3108: uint16(3984),
	3109: uint16(3885),
	3110: uint16(3699),
	3111: uint16(23584),
	3112: uint16(4028),
	3113: uint16(24075),
	3114: uint16(4188),
	3115: uint16(4175),
	3116: uint16(4214),
	3117: uint16(26398),
	3118: uint16(4219),
	3119: uint16(4232),
	3120: uint16(4246),
	3121: uint16(13895),
	3122: uint16(4287),
	3123: uint16(4307),
	3124: uint16(4399),
	3125: uint16(4411),
	3126: uint16(21348),
	3127: uint16(33965),
	3128: uint16(4835),
	3129: uint16(4981),
	3130: uint16(4918),
	3131: uint16(35713),
	3132: uint16(5495),
	3133: uint16(5657),
	3134: uint16(6083),
	3135: uint16(6087),
	3136: uint16(20088),
	3137: uint16(28859),
	3138: uint16(6189),
	3139: uint16(6506),
	3140: uint16(6701),
	3141: uint16(6725),
	3142: uint16(7210),
	3143: uint16(7280),
	3144: uint16(7340),
	3145: uint16(7880),
	3146: uint16(25283),
	3147: uint16(7893),
	3148: uint16(7957),
	3149: uint16(29080),
	3150: uint16(26709),
	3151: uint16(8261),
	3152: uint16(27113),
	3153: uint16(14024),
	3154: uint16(8828),
	3155: uint16(9175),
	3156: uint16(9210),
	3157: uint16(10026),
	3158: uint16(10353),
	3159: uint16(10575),
	3160: uint16(33533),
	3161: uint16(10599),
	3162: uint16(10643),
	3163: uint16(10965),
	3164: uint16(35237),
	3165: uint16(10984),
	3166: uint16(36768),
	3167: uint16(11022),
	3168: uint16(38840),
	3169: uint16(11071),
	3170: uint16(38983),
	3171: uint16(39613),
	3172: uint16(11340),
	3174: uint16(11400),
	3175: uint16(11447),
	3176: uint16(23528),
	3177: uint16(11528),
	3178: uint16(11538),
	3179: uint16(11703),
	3180: uint16(11669),
	3181: uint16(11842),
	3182: uint16(12148),
	3183: uint16(12236),
	3184: uint16(12339),
	3185: uint16(12390),
	3186: uint16(13087),
	3187: uint16(13278),
	3188: uint16(24497),
	3189: uint16(26184),
	3190: uint16(26303),
	3191: uint16(31353),
	3192: uint16(13671),
	3193: uint16(13811),
	3195: uint16(18874),
	3197: uint16(13850),
	3198: uint16(14102),
	3200: uint16(838),
	3201: uint16(22709),
	3202: uint16(26382),
	3203: uint16(26904),
	3204: uint16(15015),
	3205: uint16(30295),
	3206: uint16(24546),
	3207: uint16(15889),
	3208: uint16(16057),
	3209: uint16(30206),
	3210: uint16(8346),
	3211: uint16(18640),
	3212: uint16(19128),
	3213: uint16(16665),
	3214: uint16(35482),
	3215: uint16(17134),
	3216: uint16(17165),
	3217: uint16(16443),
	3218: uint16(17204),
	3219: uint16(17302),
	3220: uint16(19013),
	3221: uint16(1482),
	3222: uint16(20946),
	3223: uint16(1553),
	3224: uint16(22943),
	3225: uint16(7848),
	3226: uint16(15294),
	3227: uint16(15615),
	3228: uint16(17412),
	3229: uint16(17622),
	3230: uint16(22408),
	3231: uint16(18036),
	3232: uint16(14747),
	3233: uint16(18223),
	3234: uint16(34280),
	3235: uint16(39369),
	3236: uint16(14178),
	3237: uint16(8643),
	3238: uint16(35678),
	3239: uint16(35662),
	3241: uint16(18450),
	3242: uint16(18683),
	3243: uint16(18965),
	3244: uint16(29193),
	3245: uint16(19136),
	3246: uint16(3192),
	3247: uint16(22885),
	3248: uint16(20133),
	3249: uint16(20358),
	3250: uint16(1913),
	3251: uint16(36570),
	3252: uint16(20524),
	3253: uint16(21135),
	3254: uint16(22335),
	3255: uint16(29041),
	3256: uint16(21145),
	3257: uint16(21529),
	3258: uint16(16202),
	3259: uint16(19111),
	3260: uint16(21948),
	3261: uint16(21574),
	3262: uint16(21614),
	3263: uint16(27474),
	3265: uint16(13427),
	3266: uint16(21823),
	3267: uint16(30258),
	3268: uint16(21854),
	3269: uint16(18200),
	3270: uint16(21858),
	3271: uint16(21862),
	3272: uint16(22471),
	3273: uint16(18751),
	3274: uint16(22621),
	3275: uint16(20582),
	3276: uint16(13563),
	3277: uint16(13260),
	3279: uint16(22787),
	3280: uint16(18300),
	3281: uint16(35144),
	3282: uint16(23214),
	3283: uint16(23433),
	3284: uint16(23558),
	3285: uint16(7568),
	3286: uint16(22433),
	3287: uint16(29009),
	3289: uint16(24834),
	3290: uint16(31762),
	3291: uint16(36950),
	3292: uint16(25010),
	3293: uint16(20378),
	3294: uint16(35682),
	3295: uint16(25602),
	3296: uint16(25674),
	3297: uint16(23899),
	3298: uint16(27639),
	3300: uint16(25732),
	3301: uint16(6428),
	3302: uint16(35562),
	3303: uint16(18934),
	3304: uint16(25736),
	3305: uint16(16367),
	3306: uint16(25874),
	3307: uint16(19392),
	3308: uint16(26047),
	3309: uint16(26293),
	3310: uint16(10011),
	3311: uint16(37989),
	3312: uint16(22497),
	3313: uint16(24981),
	3314: uint16(23079),
	3315: uint16(63693),
	3317: uint16(22201),
	3318: uint16(17697),
	3319: uint16(26364),
	3320: uint16(20074),
	3321: uint16(18740),
	3322: uint16(38486),
	3323: uint16(28047),
	3324: uint16(27837),
	3325: uint16(13848),
	3326: uint16(35191),
	3327: uint16(26521),
	3328: uint16(26734),
	3329: uint16(25617),
	3330: uint16(26718),
	3332: uint16(26823),
	3333: uint16(31554),
	3334: uint16(37056),
	3335: uint16(2577),
	3336: uint16(26918),
	3338: uint16(26937),
	3339: uint16(31301),
	3341: uint16(27130),
	3342: uint16(39462),
	3343: uint16(27181),
	3344: uint16(13919),
	3345: uint16(25705),
	3346: uint16(33),
	3347: uint16(31107),
	3348: uint16(27188),
	3349: uint16(27483),
	3350: uint16(23852),
	3351: uint16(13593),
	3353: uint16(27549),
	3354: uint16(18128),
	3355: uint16(27812),
	3356: uint16(30011),
	3357: uint16(34917),
	3358: uint16(28078),
	3359: uint16(22710),
	3360: uint16(14108),
	3361: uint16(9613),
	3362: uint16(28747),
	3363: uint16(29133),
	3364: uint16(15444),
	3365: uint16(29312),
	3366: uint16(29317),
	3367: uint16(37505),
	3368: uint16(8570),
	3369: uint16(29323),
	3370: uint16(37680),
	3371: uint16(29414),
	3372: uint16(18896),
	3373: uint16(27705),
	3374: uint16(38047),
	3375: uint16(29776),
	3376: uint16(3832),
	3377: uint16(34855),
	3378: uint16(35061),
	3379: uint16(10534),
	3380: uint16(33907),
	3381: uint16(6065),
	3382: uint16(28344),
	3383: uint16(18986),
	3384: uint16(6176),
	3385: uint16(14756),
	3386: uint16(14009),
	3389: uint16(17727),
	3390: uint16(26294),
	3391: uint16(40109),
	3392: uint16(39076),
	3393: uint16(35139),
	3394: uint16(30668),
	3395: uint16(30808),
	3396: uint16(22230),
	3397: uint16(16607),
	3398: uint16(5642),
	3399: uint16(14753),
	3400: uint16(14127),
	3401: uint16(33000),
	3402: uint16(5061),
	3403: uint16(29101),
	3404: uint16(33638),
	3405: uint16(31197),
	3406: uint16(37288),
	3408: uint16(19639),
	3409: uint16(28847),
	3410: uint16(35243),
	3411: uint16(31229),
	3412: uint16(31242),
	3413: uint16(31499),
	3414: uint16(32102),
	3415: uint16(16762),
	3416: uint16(31555),
	3417: uint16(31102),
	3418: uint16(32777),
	3419: uint16(28597),
	3420: uint16(41695),
	3421: uint16(27139),
	3422: uint16(33560),
	3423: uint16(21410),
	3424: uint16(28167),
	3425: uint16(37823),
	3426: uint16(26678),
	3427: uint16(38749),
	3428: uint16(33135),
	3429: uint16(32803),
	3430: uint16(27061),
	3431: uint16(5101),
	3432: uint16(12847),
	3433: uint16(32840),
	3434: uint16(23941),
	3435: uint16(35888),
	3436: uint16(32899),
	3437: uint16(22293),
	3438: uint16(38947),
	3439: uint16(35145),
	3440: uint16(23979),
	3441: uint16(18824),
	3442: uint16(26046),
	3443: uint16(27093),
	3444: uint16(21458),
	3445: uint16(19109),
	3446: uint16(16257),
	3447: uint16(15377),
	3448: uint16(26422),
	3449: uint16(32912),
	3450: uint16(33012),
	3451: uint16(33070),
	3452: uint16(8097),
	3453: uint16(33103),
	3454: uint16(33161),
	3455: uint16(33199),
	3456: uint16(33306),
	3457: uint16(33542),
	3458: uint16(33583),
	3459: uint16(33674),
	3460: uint16(13770),
	3461: uint16(33896),
	3462: uint16(34474),
	3463: uint16(18682),
	3464: uint16(25574),
	3465: uint16(35158),
	3466: uint16(30728),
	3467: uint16(37461),
	3468: uint16(35256),
	3469: uint16(17394),
	3470: uint16(35303),
	3471: uint16(17375),
	3472: uint16(35304),
	3473: uint16(35654),
	3474: uint16(35796),
	3475: uint16(23032),
	3476: uint16(35849),
	3478: uint16(36805),
	3479: uint16(37100),
	3481: uint16(37136),
	3482: uint16(37180),
	3483: uint16(15863),
	3484: uint16(37214),
	3485: uint16(19146),
	3486: uint16(36816),
	3487: uint16(29327),
	3488: uint16(22155),
	3489: uint16(38119),
	3490: uint16(38377),
	3491: uint16(38320),
	3492: uint16(38328),
	3493: uint16(38706),
	3494: uint16(39121),
	3495: uint16(39241),
	3496: uint16(39274),
	3497: uint16(39363),
	3498: uint16(39464),
	3499: uint16(39694),
	3500: uint16(40282),
	3501: uint16(40347),
	3502: uint16(32415),
	3503: uint16(40696),
	3504: uint16(40739),
	3505: uint16(19620),
	3506: uint16(38215),
	3507: uint16(41619),
	3508: uint16(29090),
	3509: uint16(41727),
	3510: uint16(19857),
	3511: uint16(36882),
	3512: uint16(42443),
	3513: uint16(19868),
	3514: uint16(3228),
	3515: uint16(36798),
	3516: uint16(21953),
	3517: uint16(36794),
	3518: uint16(9392),
	3519: uint16(36793),
	3520: uint16(19091),
	3521: uint16(17673),
	3522: uint16(32383),
	3523: uint16(28502),
	3524: uint16(27313),
	3525: uint16(20202),
	3526: uint16(13540),
	3527: uint16(35628),
	3528: uint16(30877),
	3529: uint16(14138),
	3530: uint16(36480),
	3531: uint16(6133),
	3532: uint16(32804),
	3533: uint16(35692),
	3534: uint16(35737),
	3535: uint16(31294),
	3536: uint16(26287),
	3537: uint16(15851),
	3538: uint16(30293),
	3539: uint16(15543),
	3540: uint16(22069),
	3541: uint16(22870),
	3542: uint16(20122),
	3543: uint16(24193),
	3544: uint16(25176),
	3545: uint16(22207),
	3546: uint16(3693),
	3547: uint16(36366),
	3548: uint16(23405),
	3549: uint16(16008),
	3550: uint16(19614),
	3551: uint16(25566),
	3553: uint16(6134),
	3554: uint16(6267),
	3555: uint16(25904),
	3556: uint16(22061),
	3557: uint16(23626),
	3558: uint16(21530),
	3559: uint16(21265),
	3560: uint16(15814),
	3561: uint16(40344),
	3562: uint16(19581),
	3563: uint16(22050),
	3564: uint16(22046),
	3565: uint16(32585),
	3566: uint16(24280),
	3567: uint16(22901),
	3568: uint16(15680),
	3569: uint16(34672),
	3570: uint16(19996),
	3571: uint16(4074),
	3572: uint16(3401),
	3573: uint16(14010),
	3574: uint16(33047),
	3575: uint16(40286),
	3576: uint16(36120),
	3577: uint16(30267),
	3578: uint16(40005),
	3579: uint16(30286),
	3580: uint16(30649),
	3581: uint16(37701),
	3582: uint16(21554),
	3583: uint16(33096),
	3584: uint16(33527),
	3585: uint16(22053),
	3586: uint16(33074),
	3587: uint16(33816),
	3588: uint16(32957),
	3589: uint16(21994),
	3590: uint16(31074),
	3591: uint16(22083),
	3592: uint16(21526),
	3593: uint16(3741),
	3594: uint16(13774),
	3595: uint16(22021),
	3596: uint16(22001),
	3597: uint16(26353),
	3598: uint16(33506),
	3599: uint16(13869),
	3600: uint16(30004),
	3601: uint16(22000),
	3602: uint16(21946),
	3603: uint16(21655),
	3604: uint16(21874),
	3605: uint16(3137),
	3606: uint16(3222),
	3607: uint16(24272),
	3608: uint16(20808),
	3609: uint16(3702),
	3610: uint16(11362),
	3611: uint16(3746),
	3612: uint16(40619),
	3613: uint16(32090),
	3614: uint16(21982),
	3615: uint16(4213),
	3616: uint16(25245),
	3617: uint16(38765),
	3618: uint16(21652),
	3619: uint16(36045),
	3620: uint16(29174),
	3621: uint16(37238),
	3622: uint16(25596),
	3623: uint16(25529),
	3624: uint16(25598),
	3625: uint16(21865),
	3626: uint16(11075),
	3627: uint16(40050),
	3628: uint16(11955),
	3629: uint16(20890),
	3630: uint16(13535),
	3631: uint16(3495),
	3632: uint16(20903),
	3633: uint16(21581),
	3634: uint16(21790),
	3635: uint16(21779),
	3636: uint16(30310),
	3637: uint16(36397),
	3638: uint16(26762),
	3639: uint16(30129),
	3640: uint16(32950),
	3641: uint16(34820),
	3642: uint16(34694),
	3643: uint16(35015),
	3644: uint16(33206),
	3645: uint16(33820),
	3646: uint16(4289),
	3647: uint16(17644),
	3648: uint16(29444),
	3649: uint16(18182),
	3650: uint16(23440),
	3651: uint16(33547),
	3652: uint16(26771),
	3653: uint16(22139),
	3654: uint16(9972),
	3655: uint16(32047),
	3656: uint16(16803),
	3657: uint16(32115),
	3658: uint16(28368),
	3659: uint16(29366),
	3660: uint16(37232),
	3661: uint16(4569),
	3662: uint16(37384),
	3663: uint16(15612),
	3664: uint16(42665),
	3665: uint16(3756),
	3666: uint16(3833),
	3667: uint16(29286),
	3668: uint16(7330),
	3669: uint16(18254),
	3670: uint16(20418),
	3671: uint16(32761),
	3672: uint16(4075),
	3673: uint16(16634),
	3674: uint16(40029),
	3675: uint16(25887),
	3676: uint16(11680),
	3677: uint16(18675),
	3678: uint16(18400),
	3679: uint16(40316),
	3680: uint16(4076),
	3681: uint16(3594),
	3683: uint16(30115),
	3684: uint16(4077),
	3686: uint16(24648),
	3687: uint16(4487),
	3688: uint16(29091),
	3689: uint16(32398),
	3690: uint16(40272),
	3691: uint16(19994),
	3692: uint16(19972),
	3693: uint16(13687),
	3694: uint16(23309),
	3695: uint16(27826),
	3696: uint16(21351),
	3697: uint16(13996),
	3698: uint16(14812),
	3699: uint16(21373),
	3700: uint16(13989),
	3701: uint16(17944),
	3702: uint16(22682),
	3703: uint16(19310),
	3704: uint16(33325),
	3705: uint16(21579),
	3706: uint16(22442),
	3707: uint16(23189),
	3708: uint16(2425),
	3710: uint16(14930),
	3711: uint16(9317),
	3712: uint16(29556),
	3713: uint16(40620),
	3714: uint16(19721),
	3715: uint16(39917),
	3716: uint16(15614),
	3717: uint16(40752),
	3718: uint16(19547),
	3719: uint16(20393),
	3720: uint16(38302),
	3721: uint16(40926),
	3722: uint16(33884),
	3723: uint16(15798),
	3724: uint16(29362),
	3725: uint16(26547),
	3726: uint16(14112),
	3727: uint16(25390),
	3728: uint16(32037),
	3729: uint16(16119),
	3730: uint16(15916),
	3731: uint16(14890),
	3732: uint16(36872),
	3733: uint16(21196),
	3734: uint16(15988),
	3735: uint16(13946),
	3736: uint16(17897),
	3737: uint16(1166),
	3738: uint16(30272),
	3739: uint16(23280),
	3740: uint16(3766),
	3741: uint16(30842),
	3742: uint16(32558),
	3743: uint16(22695),
	3744: uint16(16575),
	3745: uint16(22140),
	3746: uint16(39819),
	3747: uint16(23924),
	3748: uint16(30292),
	3749: uint16(42036),
	3750: uint16(40581),
	3751: uint16(19681),
	3753: uint16(14331),
	3754: uint16(24857),
	3755: uint16(12506),
	3756: uint16(17394),
	3758: uint16(22109),
	3759: uint16(4777),
	3760: uint16(22439),
	3761: uint16(18787),
	3762: uint16(40454),
	3763: uint16(21044),
	3764: uint16(28846),
	3765: uint16(13741),
	3767: uint16(40316),
	3768: uint16(31830),
	3769: uint16(39737),
	3770: uint16(22494),
	3771: uint16(5996),
	3772: uint16(23635),
	3773: uint16(25811),
	3774: uint16(38096),
	3775: uint16(25397),
	3776: uint16(29028),
	3777: uint16(34477),
	3778: uint16(3368),
	3779: uint16(27938),
	3780: uint16(19170),
	3781: uint16(3441),
	3783: uint16(20990),
	3784: uint16(7951),
	3785: uint16(23950),
	3786: uint16(38659),
	3787: uint16(7633),
	3788: uint16(40577),
	3789: uint16(36940),
	3790: uint16(31519),
	3791: uint16(39682),
	3792: uint16(23761),
	3793: uint16(31651),
	3794: uint16(25192),
	3795: uint16(25397),
	3796: uint16(39679),
	3797: uint16(31695),
	3798: uint16(39722),
	3799: uint16(31870),
	3801: uint16(31810),
	3802: uint16(31878),
	3803: uint16(39957),
	3804: uint16(31740),
	3805: uint16(39689),
	3807: uint16(39963),
	3808: uint16(18750),
	3809: uint16(40794),
	3810: uint16(21875),
	3811: uint16(23491),
	3812: uint16(20477),
	3813: uint16(40600),
	3814: uint16(20466),
	3815: uint16(21088),
	3816: uint16(15878),
	3817: uint16(21201),
	3818: uint16(22375),
	3819: uint16(20566),
	3820: uint16(22967),
	3821: uint16(24082),
	3822: uint16(38856),
	3823: uint16(40363),
	3824: uint16(36700),
	3825: uint16(21609),
	3826: uint16(38836),
	3827: uint16(39232),
	3828: uint16(38842),
	3829: uint16(21292),
	3830: uint16(24880),
	3831: uint16(26924),
	3832: uint16(21466),
	3833: uint16(39946),
	3834: uint16(40194),
	3835: uint16(19515),
	3836: uint16(38465),
	3837: uint16(27008),
	3838: uint16(20646),
	3839: uint16(30022),
	3840: uint16(5997),
	3841: uint16(39386),
	3842: uint16(21107),
	3844: uint16(37209),
	3845: uint16(38529),
	3846: uint16(37212),
	3848: uint16(37201),
	3849: uint16(36503),
	3850: uint16(25471),
	3851: uint16(27939),
	3852: uint16(27338),
	3853: uint16(22033),
	3854: uint16(37262),
	3855: uint16(30074),
	3856: uint16(25221),
	3857: uint16(1020),
	3858: uint16(29519),
	3859: uint16(31856),
	3860: uint16(23585),
	3861: uint16(15613),
	3863: uint16(18713),
	3864: uint16(30422),
	3865: uint16(39837),
	3866: uint16(20010),
	3867: uint16(3284),
	3868: uint16(33726),
	3869: uint16(34882),
	3871: uint16(23626),
	3872: uint16(27072),
	3874: uint16(22394),
	3875: uint16(21023),
	3876: uint16(24053),
	3877: uint16(20174),
	3878: uint16(27697),
	3879: uint16(498),
	3880: uint16(20281),
	3881: uint16(21660),
	3882: uint16(21722),
	3883: uint16(21146),
	3884: uint16(36226),
	3885: uint16(13822),
	3887: uint16(13811),
	3889: uint16(27474),
	3890: uint16(37244),
	3891: uint16(40869),
	3892: uint16(39831),
	3893: uint16(38958),
	3894: uint16(39092),
	3895: uint16(39610),
	3896: uint16(40616),
	3897: uint16(40580),
	3898: uint16(29050),
	3899: uint16(31508),
	3901: uint16(27642),
	3902: uint16(34840),
	3903: uint16(32632),
	3905: uint16(22048),
	3906: uint16(42570),
	3907: uint16(36471),
	3908: uint16(40787),
	3910: uint16(36308),
	3911: uint16(36431),
	3912: uint16(40476),
	3913: uint16(36353),
	3914: uint16(25218),
	3915: uint16(33661),
	3916: uint16(36392),
	3917: uint16(36469),
	3918: uint16(31443),
	3919: uint16(19063),
	3920: uint16(31294),
	3921: uint16(30936),
	3922: uint16(27882),
	3923: uint16(35431),
	3924: uint16(30215),
	3925: uint16(35418),
	3926: uint16(40742),
	3927: uint16(27854),
	3928: uint16(34774),
	3929: uint16(30147),
	3930: uint16(41650),
	3931: uint16(30803),
	3932: uint16(63552),
	3933: uint16(36108),
	3934: uint16(29410),
	3935: uint16(29553),
	3936: uint16(35629),
	3937: uint16(29442),
	3938: uint16(29937),
	3939: uint16(36075),
	3940: uint16(19131),
	3941: uint16(34351),
	3942: uint16(24506),
	3943: uint16(34976),
	3944: uint16(17591),
	3946: uint16(6203),
	3947: uint16(28165),
	3949: uint16(35454),
	3950: uint16(9499),
	3952: uint16(24829),
	3953: uint16(30311),
	3954: uint16(39639),
	3955: uint16(40260),
	3956: uint16(37742),
	3957: uint16(39823),
	3958: uint16(34805),
	3961: uint16(36087),
	3962: uint16(29484),
	3963: uint16(38689),
	3964: uint16(39856),
	3965: uint16(13782),
	3966: uint16(29362),
	3967: uint16(19463),
	3968: uint16(31825),
	3969: uint16(39242),
	3970: uint16(24921),
	3971: uint16(24921),
	3972: uint16(19460),
	3973: uint16(40598),
	3974: uint16(24957),
	3976: uint16(22367),
	3977: uint16(24943),
	3978: uint16(25254),
	3979: uint16(25145),
	3981: uint16(14940),
	3982: uint16(25058),
	3983: uint16(21418),
	3984: uint16(13301),
	3985: uint16(25444),
	3986: uint16(26626),
	3987: uint16(13778),
	3988: uint16(23895),
	3989: uint16(35778),
	3990: uint16(36826),
	3991: uint16(36409),
	3993: uint16(20697),
	3994: uint16(7494),
	3995: uint16(30982),
	3996: uint16(21298),
	3997: uint16(38456),
	3998: uint16(3899),
	3999: uint16(16485),
	4001: uint16(30718),
	4003: uint16(31938),
	4004: uint16(24346),
	4005: uint16(31962),
	4006: uint16(31277),
	4007: uint16(32870),
	4008: uint16(32867),
	4009: uint16(32077),
	4010: uint16(29957),
	4011: uint16(29938),
	4012: uint16(35220),
	4013: uint16(33306),
	4014: uint16(26380),
	4015: uint16(32866),
	4016: uint16(29830),
	4017: uint16(32859),
	4018: uint16(29936),
	4019: uint16(33027),
	4020: uint16(30500),
	4021: uint16(35209),
	4022: uint16(26572),
	4023: uint16(30035),
	4024: uint16(28369),
	4025: uint16(34729),
	4026: uint16(34766),
	4027: uint16(33224),
	4028: uint16(34700),
	4029: uint16(35401),
	4030: uint16(36013),
	4031: uint16(35651),
	4032: uint16(30507),
	4033: uint16(29944),
	4034: uint16(34010),
	4035: uint16(13877),
	4036: uint16(27058),
	4037: uint16(36262),
	4039: uint16(35241),
	4041: uint16(28089),
	4042: uint16(34753),
	4043: uint16(16401),
	4044: uint16(29927),
	4045: uint16(15835),
	4046: uint16(29046),
	4047: uint16(24740),
	4048: uint16(24988),
	4049: uint16(15569),
	4051: uint16(24695),
	4053: uint16(32625),
	4054: uint16(35629),
	4056: uint16(24809),
	4057: uint16(19326),
	4058: uint16(21024),
	4059: uint16(15384),
	4060: uint16(15559),
	4061: uint16(24279),
	4062: uint16(30294),
	4063: uint16(21809),
	4064: uint16(6468),
	4065: uint16(4862),
	4066: uint16(39171),
	4067: uint16(28124),
	4068: uint16(28845),
	4069: uint16(23745),
	4070: uint16(25005),
	4071: uint16(35343),
	4072: uint16(13943),
	4073: uint16(238),
	4074: uint16(26694),
	4075: uint16(20238),
	4076: uint16(17762),
	4077: uint16(23327),
	4078: uint16(25420),
	4079: uint16(40784),
	4080: uint16(40614),
	4081: uint16(25195),
	4082: uint16(1351),
	4083: uint16(37595),
	4084: uint16(1503),
	4085: uint16(16325),
	4086: uint16(34124),
	4087: uint16(17077),
	4088: uint16(29679),
	4089: uint16(20917),
	4090: uint16(13897),
	4091: uint16(18754),
	4092: uint16(35300),
	4093: uint16(37700),
	4094: uint16(6619),
	4095: uint16(33518),
	4096: uint16(15560),
	4097: uint16(30780),
	4098: uint16(26436),
	4099: uint16(25311),
	4100: uint16(18739),
	4101: uint16(35242),
	4102: uint16(672),
	4103: uint16(27571),
	4104: uint16(4869),
	4105: uint16(20395),
	4106: uint16(9453),
	4107: uint16(20488),
	4108: uint16(27945),
	4109: uint16(31364),
	4110: uint16(13824),
	4111: uint16(19121),
	4112: uint16(9491),
	4114: uint16(894),
	4115: uint16(24484),
	4116: uint16(896),
	4117: uint16(839),
	4118: uint16(28379),
	4119: uint16(1055),
	4121: uint16(20737),
	4122: uint16(13434),
	4123: uint16(20750),
	4124: uint16(39020),
	4125: uint16(14147),
	4126: uint16(33814),
	4127: uint16(18852),
	4128: uint16(1159),
	4129: uint16(20832),
	4130: uint16(13236),
	4131: uint16(20842),
	4132: uint16(3071),
	4133: uint16(8444),
	4134: uint16(741),
	4135: uint16(9520),
	4136: uint16(1422),
	4137: uint16(12851),
	4138: uint16(6531),
	4139: uint16(23426),
	4140: uint16(34685),
	4141: uint16(1459),
	4142: uint16(15513),
	4143: uint16(20914),
	4144: uint16(20920),
	4145: uint16(40244),
	4146: uint16(20937),
	4147: uint16(20943),
	4148: uint16(20945),
	4149: uint16(15580),
	4150: uint16(20947),
	4151: uint16(19110),
	4152: uint16(20915),
	4153: uint16(20962),
	4154: uint16(21314),
	4155: uint16(20973),
	4156: uint16(33741),
	4157: uint16(26942),
	4158: uint16(14125),
	4159: uint16(24443),
	4160: uint16(21003),
	4161: uint16(21030),
	4162: uint16(21052),
	4163: uint16(21173),
	4164: uint16(21079),
	4165: uint16(21140),
	4166: uint16(21177),
	4167: uint16(21189),
	4168: uint16(31765),
	4169: uint16(34114),
	4170: uint16(21216),
	4171: uint16(34317),
	4172: uint16(27411),
	4174: uint16(35550),
	4175: uint16(21833),
	4176: uint16(28377),
	4177: uint16(16256),
	4178: uint16(2388),
	4179: uint16(16364),
	4180: uint16(21299),
	4182: uint16(3042),
	4183: uint16(27851),
	4184: uint16(5926),
	4185: uint16(26651),
	4186: uint16(29653),
	4187: uint16(24650),
	4188: uint16(16042),
	4189: uint16(14540),
	4190: uint16(5864),
	4191: uint16(29149),
	4192: uint16(17570),
	4193: uint16(21357),
	4194: uint16(21364),
	4195: uint16(34475),
	4196: uint16(21374),
	4198: uint16(5526),
	4199: uint16(5651),
	4200: uint16(30694),
	4201: uint16(21395),
	4202: uint16(35483),
	4203: uint16(21408),
	4204: uint16(21419),
	4205: uint16(21422),
	4206: uint16(29607),
	4207: uint16(22386),
	4208: uint16(16217),
	4209: uint16(29596),
	4210: uint16(21441),
	4211: uint16(21445),
	4212: uint16(27721),
	4213: uint16(20041),
	4214: uint16(22526),
	4215: uint16(21465),
	4216: uint16(15019),
	4217: uint16(2959),
	4218: uint16(21472),
	4219: uint16(16363),
	4220: uint16(11683),
	4221: uint16(21494),
	4222: uint16(3191),
	4223: uint16(21523),
	4224: uint16(28793),
	4225: uint16(21803),
	4226: uint16(26199),
	4227: uint16(27995),
	4228: uint16(21613),
	4229: uint16(27475),
	4230: uint16(3444),
	4231: uint16(21853),
	4232: uint16(21647),
	4233: uint16(21668),
	4234: uint16(18342),
	4235: uint16(5901),
	4236: uint16(3805),
	4237: uint16(15796),
	4238: uint16(3405),
	4239: uint16(35260),
	4240: uint16(9880),
	4241: uint16(21831),
	4242: uint16(19693),
	4243: uint16(21551),
	4244: uint16(29719),
	4245: uint16(21894),
	4246: uint16(21929),
	4248: uint16(6359),
	4249: uint16(16442),
	4250: uint16(17746),
	4251: uint16(17461),
	4252: uint16(26291),
	4253: uint16(4276),
	4254: uint16(22071),
	4255: uint16(26317),
	4256: uint16(12938),
	4257: uint16(26276),
	4258: uint16(26285),
	4259: uint16(22093),
	4260: uint16(22095),
	4261: uint16(30961),
	4262: uint16(22257),
	4263: uint16(38791),
	4264: uint16(21502),
	4265: uint16(22272),
	4266: uint16(22255),
	4267: uint16(22253),
	4268: uint16(35686),
	4269: uint16(13859),
	4270: uint16(4687),
	4271: uint16(22342),
	4272: uint16(16805),
	4273: uint16(27758),
	4274: uint16(28811),
	4275: uint16(22338),
	4276: uint16(14001),
	4277: uint16(27774),
	4278: uint16(22502),
	4279: uint16(5142),
	4280: uint16(22531),
	4281: uint16(5204),
	4282: uint16(17251),
	4283: uint16(22566),
	4284: uint16(19445),
	4285: uint16(22620),
	4286: uint16(22698),
	4287: uint16(13665),
	4288: uint16(22752),
	4289: uint16(22748),
	4290: uint16(4668),
	4291: uint16(22779),
	4292: uint16(23551),
	4293: uint16(22339),
	4294: uint16(41296),
	4295: uint16(17016),
	4296: uint16(37843),
	4297: uint16(13729),
	4298: uint16(22815),
	4299: uint16(26790),
	4300: uint16(14019),
	4301: uint16(28249),
	4302: uint16(5694),
	4303: uint16(23076),
	4304: uint16(21843),
	4305: uint16(5778),
	4306: uint16(34053),
	4307: uint16(22985),
	4308: uint16(3406),
	4309: uint16(27777),
	4310: uint16(27946),
	4311: uint16(6108),
	4312: uint16(23001),
	4313: uint16(6139),
	4314: uint16(6066),
	4315: uint16(28070),
	4316: uint16(28017),
	4317: uint16(6184),
	4318: uint16(5845),
	4319: uint16(23033),
	4320: uint16(28229),
	4321: uint16(23211),
	4322: uint16(23139),
	4323: uint16(14054),
	4324: uint16(18857),
	4326: uint16(14088),
	4327: uint16(23190),
	4328: uint16(29797),
	4329: uint16(23251),
	4330: uint16(28577),
	4331: uint16(9556),
	4332: uint16(15749),
	4333: uint16(6417),
	4334: uint16(14130),
	4335: uint16(5816),
	4336: uint16(24195),
	4337: uint16(21200),
	4338: uint16(23414),
	4339: uint16(25992),
	4340: uint16(23420),
	4341: uint16(31246),
	4342: uint16(16388),
	4343: uint16(18525),
	4344: uint16(516),
	4345: uint16(23509),
	4346: uint16(24928),
	4347: uint16(6708),
	4348: uint16(22988),
	4349: uint16(1445),
	4350: uint16(23539),
	4351: uint16(23453),
	4352: uint16(19728),
	4353: uint16(23557),
	4354: uint16(6980),
	4355: uint16(23571),
	4356: uint16(29646),
	4357: uint16(23572),
	4358: uint16(7333),
	4359: uint16(27432),
	4360: uint16(23625),
	4361: uint16(18653),
	4362: uint16(23685),
	4363: uint16(23785),
	4364: uint16(23791),
	4365: uint16(23947),
	4366: uint16(7673),
	4367: uint16(7735),
	4368: uint16(23824),
	4369: uint16(23832),
	4370: uint16(23878),
	4371: uint16(7844),
	4372: uint16(23738),
	4373: uint16(24023),
	4374: uint16(33532),
	4375: uint16(14381),
	4376: uint16(18689),
	4377: uint16(8265),
	4378: uint16(8563),
	4379: uint16(33415),
	4380: uint16(14390),
	4381: uint16(15298),
	4382: uint16(24110),
	4383: uint16(27274),
	4385: uint16(24186),
	4386: uint16(17596),
	4387: uint16(3283),
	4388: uint16(21414),
	4389: uint16(20151),
	4391: uint16(21416),
	4392: uint16(6001),
	4393: uint16(24073),
	4394: uint16(24308),
	4395: uint16(33922),
	4396: uint16(24313),
	4397: uint16(24315),
	4398: uint16(14496),
	4399: uint16(24316),
	4400: uint16(26686),
	4401: uint16(37915),
	4402: uint16(24333),
	4403: uint16(449),
	4404: uint16(63636),
	4405: uint16(15070),
	4406: uint16(18606),
	4407: uint16(4922),
	4408: uint16(24378),
	4409: uint16(26760),
	4410: uint16(9168),
	4412: uint16(9329),
	4413: uint16(24419),
	4414: uint16(38845),
	4415: uint16(28270),
	4416: uint16(24434),
	4417: uint16(37696),
	4418: uint16(35382),
	4419: uint16(24487),
	4420: uint16(23990),
	4421: uint16(15711),
	4422: uint16(21072),
	4423: uint16(8042),
	4424: uint16(28920),
	4425: uint16(9832),
	4426: uint16(37334),
	4427: uint16(670),
	4428: uint16(35369),
	4429: uint16(24625),
	4430: uint16(26245),
	4431: uint16(6263),
	4432: uint16(14691),
	4433: uint16(15815),
	4434: uint16(13881),
	4435: uint16(22416),
	4436: uint16(10164),
	4437: uint16(31089),
	4438: uint16(15936),
	4439: uint16(24734),
	4441: uint16(24755),
	4442: uint16(18818),
	4443: uint16(18831),
	4444: uint16(31315),
	4445: uint16(29860),
	4446: uint16(20705),
	4447: uint16(23200),
	4448: uint16(24932),
	4449: uint16(33828),
	4450: uint16(24898),
	4451: uint16(63654),
	4452: uint16(28370),
	4453: uint16(24961),
	4454: uint16(20980),
	4455: uint16(1622),
	4456: uint16(24967),
	4457: uint16(23466),
	4458: uint16(16311),
	4459: uint16(10335),
	4460: uint16(25043),
	4461: uint16(35741),
	4462: uint16(39261),
	4463: uint16(25040),
	4464: uint16(14642),
	4465: uint16(10624),
	4466: uint16(10433),
	4467: uint16(24611),
	4468: uint16(24924),
	4469: uint16(25886),
	4470: uint16(25483),
	4471: uint16(280),
	4472: uint16(25285),
	4473: uint16(6000),
	4474: uint16(25301),
	4475: uint16(11789),
	4476: uint16(25452),
	4477: uint16(18911),
	4478: uint16(14871),
	4479: uint16(25656),
	4480: uint16(25592),
	4481: uint16(5006),
	4482: uint16(6140),
	4484: uint16(28554),
	4485: uint16(11830),
	4486: uint16(38932),
	4487: uint16(16524),
	4488: uint16(22301),
	4489: uint16(25825),
	4490: uint16(25829),
	4491: uint16(38011),
	4492: uint16(14950),
	4493: uint16(25658),
	4494: uint16(14935),
	4495: uint16(25933),
	4496: uint16(28438),
	4497: uint16(18984),
	4498: uint16(18979),
	4499: uint16(25989),
	4500: uint16(25965),
	4501: uint16(25951),
	4502: uint16(12414),
	4503: uint16(26037),
	4504: uint16(18752),
	4505: uint16(19255),
	4506: uint16(26065),
	4507: uint16(16600),
	4508: uint16(6185),
	4509: uint16(26080),
	4510: uint16(26083),
	4511: uint16(24543),
	4512: uint16(13312),
	4513: uint16(26136),
	4514: uint16(12791),
	4515: uint16(12792),
	4516: uint16(26180),
	4517: uint16(12708),
	4518: uint16(12709),
	4519: uint16(26187),
	4520: uint16(3701),
	4521: uint16(26215),
	4522: uint16(20966),
	4523: uint16(26227),
	4525: uint16(7741),
	4526: uint16(12849),
	4527: uint16(34292),
	4528: uint16(12744),
	4529: uint16(21267),
	4530: uint16(30661),
	4531: uint16(10487),
	4532: uint16(39332),
	4533: uint16(26370),
	4534: uint16(17308),
	4535: uint16(18977),
	4536: uint16(15147),
	4537: uint16(27130),
	4538: uint16(14274),
	4540: uint16(26471),
	4541: uint16(26466),
	4542: uint16(16845),
	4543: uint16(37101),
	4544: uint16(26583),
	4545: uint16(17641),
	4546: uint16(26658),
	4547: uint16(28240),
	4548: uint16(37436),
	4549: uint16(26625),
	4550: uint16(13286),
	4551: uint16(28064),
	4552: uint16(26717),
	4553: uint16(13423),
	4554: uint16(27105),
	4555: uint16(27147),
	4556: uint16(35551),
	4557: uint16(26995),
	4558: uint16(26819),
	4559: uint16(13773),
	4560: uint16(26881),
	4561: uint16(26880),
	4562: uint16(15666),
	4563: uint16(14849),
	4564: uint16(13884),
	4565: uint16(15232),
	4566: uint16(26540),
	4567: uint16(26977),
	4568: uint16(35402),
	4569: uint16(17148),
	4570: uint16(26934),
	4571: uint16(27032),
	4572: uint16(15265),
	4573: uint16(969),
	4574: uint16(33635),
	4575: uint16(20624),
	4576: uint16(27129),
	4577: uint16(13913),
	4578: uint16(8490),
	4579: uint16(27205),
	4580: uint16(14083),
	4581: uint16(27293),
	4582: uint16(15347),
	4583: uint16(26545),
	4584: uint16(27336),
	4585: uint16(37276),
	4586: uint16(15373),
	4587: uint16(27421),
	4588: uint16(2339),
	4589: uint16(24798),
	4590: uint16(27445),
	4591: uint16(27508),
	4592: uint16(10189),
	4593: uint16(28341),
	4594: uint16(15067),
	4595: uint16(949),
	4596: uint16(6488),
	4597: uint16(14144),
	4598: uint16(21537),
	4599: uint16(15194),
	4600: uint16(27617),
	4601: uint16(16124),
	4602: uint16(27612),
	4603: uint16(27703),
	4604: uint16(9355),
	4605: uint16(18673),
	4606: uint16(27473),
	4607: uint16(27738),
	4608: uint16(33318),
	4609: uint16(27769),
	4610: uint16(15804),
	4611: uint16(17605),
	4612: uint16(15805),
	4613: uint16(16804),
	4614: uint16(18700),
	4615: uint16(18688),
	4616: uint16(15561),
	4617: uint16(14053),
	4618: uint16(15595),
	4619: uint16(3378),
	4620: uint16(39811),
	4621: uint16(12793),
	4622: uint16(9361),
	4623: uint16(32655),
	4624: uint16(26679),
	4625: uint16(27941),
	4626: uint16(28065),
	4627: uint16(28139),
	4628: uint16(28054),
	4629: uint16(27996),
	4630: uint16(28284),
	4631: uint16(28420),
	4632: uint16(18815),
	4633: uint16(16517),
	4634: uint16(28274),
	4635: uint16(34099),
	4636: uint16(28532),
	4637: uint16(20935),
	4640: uint16(33838),
	4641: uint16(35617),
	4643: uint16(15919),
	4644: uint16(29779),
	4645: uint16(16258),
	4646: uint16(31180),
	4647: uint16(28239),
	4648: uint16(23185),
	4649: uint16(12363),
	4650: uint16(28664),
	4651: uint16(14093),
	4652: uint16(28573),
	4653: uint16(15920),
	4654: uint16(28410),
	4655: uint16(5271),
	4656: uint16(16445),
	4657: uint16(17749),
	4658: uint16(37872),
	4659: uint16(28484),
	4660: uint16(28508),
	4661: uint16(15694),
	4662: uint16(28532),
	4663: uint16(37232),
	4664: uint16(15675),
	4665: uint16(28575),
	4666: uint16(16708),
	4667: uint16(28627),
	4668: uint16(16529),
	4669: uint16(16725),
	4670: uint16(16441),
	4671: uint16(16368),
	4672: uint16(16308),
	4673: uint16(16703),
	4674: uint16(20959),
	4675: uint16(16726),
	4676: uint16(16727),
	4677: uint16(16704),
	4678: uint16(25053),
	4679: uint16(28747),
	4680: uint16(28798),
	4681: uint16(28839),
	4682: uint16(28801),
	4683: uint16(28876),
	4684: uint16(28885),
	4685: uint16(28886),
	4686: uint16(28895),
	4687: uint16(16644),
	4688: uint16(15848),
	4689: uint16(29108),
	4690: uint16(29078),
	4691: uint16(17015),
	4692: uint16(28971),
	4693: uint16(28997),
	4694: uint16(23176),
	4695: uint16(29002),
	4697: uint16(23708),
	4698: uint16(17253),
	4699: uint16(29007),
	4700: uint16(37730),
	4701: uint16(17089),
	4702: uint16(28972),
	4703: uint16(17498),
	4704: uint16(18983),
	4705: uint16(18978),
	4706: uint16(29114),
	4707: uint16(35816),
	4708: uint16(28861),
	4709: uint16(29198),
	4710: uint16(37954),
	4711: uint16(29205),
	4712: uint16(22801),
	4713: uint16(37955),
	4714: uint16(29220),
	4715: uint16(37697),
	4716: uint16(22021),
	4717: uint16(29230),
	4718: uint16(29248),
	4719: uint16(18804),
	4720: uint16(26813),
	4721: uint16(29269),
	4722: uint16(29271),
	4723: uint16(15957),
	4724: uint16(12356),
	4725: uint16(26637),
	4726: uint16(28477),
	4727: uint16(29314),
	4729: uint16(29483),
	4730: uint16(18467),
	4731: uint16(34859),
	4732: uint16(18669),
	4733: uint16(34820),
	4734: uint16(29480),
	4735: uint16(29486),
	4736: uint16(29647),
	4737: uint16(29610),
	4738: uint16(3130),
	4739: uint16(27182),
	4740: uint16(29641),
	4741: uint16(29769),
	4742: uint16(16866),
	4743: uint16(5863),
	4744: uint16(18980),
	4745: uint16(26147),
	4746: uint16(14021),
	4747: uint16(18871),
	4748: uint16(18829),
	4749: uint16(18939),
	4750: uint16(29687),
	4751: uint16(29717),
	4752: uint16(26883),
	4753: uint16(18982),
	4754: uint16(29753),
	4755: uint16(1475),
	4756: uint16(16087),
	4758: uint16(10413),
	4759: uint16(29792),
	4760: uint16(36530),
	4761: uint16(29767),
	4762: uint16(29668),
	4763: uint16(29814),
	4764: uint16(33721),
	4765: uint16(29804),
	4766: uint16(14128),
	4767: uint16(29812),
	4768: uint16(37873),
	4769: uint16(27180),
	4770: uint16(29826),
	4771: uint16(18771),
	4772: uint16(19084),
	4773: uint16(16735),
	4774: uint16(19065),
	4775: uint16(35727),
	4776: uint16(23366),
	4777: uint16(35843),
	4778: uint16(6302),
	4779: uint16(29896),
	4780: uint16(6536),
	4781: uint16(29966),
	4783: uint16(29982),
	4784: uint16(36569),
	4785: uint16(6731),
	4786: uint16(23511),
	4787: uint16(36524),
	4788: uint16(37765),
	4789: uint16(30029),
	4790: uint16(30026),
	4791: uint16(30055),
	4792: uint16(30062),
	4793: uint16(20354),
	4794: uint16(16132),
	4795: uint16(19731),
	4796: uint16(30094),
	4797: uint16(29789),
	4798: uint16(30110),
	4799: uint16(30132),
	4800: uint16(30210),
	4801: uint16(30252),
	4802: uint16(30289),
	4803: uint16(30287),
	4804: uint16(30319),
	4805: uint16(30326),
	4806: uint16(25589),
	4807: uint16(30352),
	4808: uint16(33263),
	4809: uint16(14328),
	4810: uint16(26897),
	4811: uint16(26894),
	4812: uint16(30369),
	4813: uint16(30373),
	4814: uint16(30391),
	4815: uint16(30412),
	4816: uint16(28575),
	4817: uint16(33890),
	4818: uint16(20637),
	4819: uint16(20861),
	4820: uint16(7708),
	4821: uint16(30494),
	4822: uint16(30502),
	4823: uint16(30528),
	4824: uint16(25775),
	4825: uint16(21024),
	4826: uint16(30552),
	4827: uint16(12972),
	4828: uint16(30639),
	4829: uint16(35172),
	4830: uint16(35176),
	4831: uint16(5825),
	4832: uint16(30708),
	4834: uint16(4982),
	4835: uint16(18962),
	4836: uint16(26826),
	4837: uint16(30895),
	4838: uint16(30919),
	4839: uint16(30931),
	4840: uint16(38565),
	4841: uint16(31022),
	4842: uint16(21984),
	4843: uint16(30935),
	4844: uint16(31028),
	4845: uint16(30897),
	4846: uint16(30220),
	4847: uint16(36792),
	4848: uint16(34948),
	4849: uint16(35627),
	4850: uint16(24707),
	4851: uint16(9756),
	4852: uint16(31110),
	4853: uint16(35072),
	4854: uint16(26882),
	4855: uint16(31104),
	4856: uint16(22615),
	4857: uint16(31133),
	4858: uint16(31545),
	4859: uint16(31036),
	4860: uint16(31145),
	4861: uint16(28202),
	4862: uint16(28966),
	4863: uint16(16040),
	4864: uint16(31174),
	4865: uint16(37133),
	4866: uint16(31188),
	4867: uint16(1312),
	4868: uint16(17503),
	4869: uint16(21007),
	4870: uint16(47234),
	4871: uint16(248),
	4872: uint16(16384),
	4873: uint16(43296),
	4874: uint16(1102),
	4877: uint16(2868),
	4878: uint16(1),
	4886: uint16(3072),
	4887: uint16(64),
	4891: uint16(1024),
	4892: uint16(88),
	4893: uint16(60),
	4896: uint16(23680),
	4897: uint16(56493),
	4898: uint16(48115),
	4899: uint16(17353),
	4900: uint16(60910),
	4901: uint16(4004),
	4902: uint16(49446),
	4903: uint16(30363),
	4904: uint16(61426),
	4905: uint16(64478),
	4906: uint16(63482),
	4907: uint16(12815),
	4908: uint16(44868),
	4909: uint16(61438),
	4910: uint16(65277),
	4911: uint16(24593),
	4912: uint16(176),
	4913: uint16(8448),
	4914: uint16(33049),
	4915: uint16(4128),
	4916: uint16(43144),
	4917: uint16(8544),
	4918: uint16(9321),
	4919: uint16(17408),
	4920: uint16(50313),
	4922: uint16(16387),
	4923: uint16(53),
	4924: uint16(33859),
	4925: uint16(20785),
	4926: uint16(26771),
	4927: uint16(514),
	4933: uint16(16384),
	4934: uint16(256),
	4935: uint16(44160),
	4936: uint16(33380),
	4937: uint16(35904),
	4938: uint16(37025),
	4939: uint16(20484),
	4940: uint16(54368),
	4941: uint16(53760),
	4942: uint16(6186),
	4943: uint16(26781),
	4944: uint16(38709),
	4945: uint16(55375),
	4946: uint16(8440),
	4947: uint16(33476),
	4948: uint16(10268),
	4949: uint16(30082),
	4950: uint16(660),
	4951: uint16(16440),
	4952: uint16(41376),
	4953: uint16(4293),
	4954: uint16(19825),
	4955: uint16(3524),
	4956: uint16(47512),
	4957: uint16(23390),
	4958: uint16(17153),
	4959: uint16(39327),
	4960: uint16(30723),
	4961: uint16(57888),
	4962: uint16(2079),
	4963: uint16(393),
	4964: uint16(16585),
	4965: uint16(775),
	4966: uint16(39437),
	4967: uint16(21136),
	4968: uint16(20433),
	4969: uint16(892),
	4970: uint16(8450),
	4971: uint16(49184),
	4972: uint16(4974),
	4973: uint16(46467),
	4974: uint16(62939),
	4975: uint16(30693),
	4976: uint16(20368),
	4977: uint16(39447),
	4978: uint16(5942),
	4979: uint16(12),
	4980: uint16(47726),
	4981: uint16(12041),
	4982: uint16(21600),
	4983: uint16(7680),
	4984: uint16(26744),
	4985: uint16(28706),
	4986: uint16(40534),
	4987: uint16(62245),
	4988: uint16(46990),
	4989: uint16(2839),
	4990: uint16(59119),
	4991: uint16(6007),
	4992: uint16(7003),
	4993: uint16(4289),
	4994: uint16(36248),
	4995: uint16(6162),
	4996: uint16(53174),
	4997: uint16(12545),
	4998: uint16(6770),
	4999: uint16(11355),
	5000: uint16(49334),
	5001: uint16(57888),
	5002: uint16(23747),
	5003: uint16(7042),
	5004: uint16(56032),
	5005: uint16(34254),
	5006: uint16(16598),
	5007: uint16(21673),
	5008: uint16(53259),
	5009: uint16(18447),
	5010: uint16(16452),
	5011: uint16(2320),
	5012: uint16(16596),
	5013: uint16(15278),
	5014: uint16(7780),
	5015: uint16(11076),
	5016: uint16(2071),
	5017: uint16(33414),
	5018: uint16(6198),
	5019: uint16(35232),
	5020: uint16(40167),
	5021: uint16(2139),
	5022: uint16(900),
	5023: uint16(55810),
	5024: uint16(60560),
	5025: uint16(34779),
	5026: uint16(49029),
	5027: uint16(44450),
	5028: uint16(36509),
	5029: uint16(39069),
	5030: uint16(9504),
	5031: uint16(70),
	5032: uint16(40774),
	5033: uint16(58239),
	5034: uint16(51669),
	5035: uint16(62596),
	5036: uint16(19926),
	5037: uint16(58118),
	5038: uint16(6326),
	5039: uint16(2322),
	5041: uint16(1024),
	5043: uint16(32),
	5045: uint16(512),
	5050: uint16(8192),
	5057: uint16(8),
	5058: uint16(36352),
	5059: uint16(28280),
	5060: uint16(16223),
	5061: uint16(56702),
	5062: uint16(63293),
	5063: uint16(39932),
	5064: uint16(44796),
	5065: uint16(65490),
	5066: uint16(27535),
	5067: uint16(59377),
	5068: uint16(47807),
	5069: uint16(28334),
	5070: uint16(61207),
	5071: uint16(42972),
	5072: uint16(46654),
	5073: uint16(30645),
	5074: uint16(37577),
	5075: uint16(42455),
	5076: uint16(19126),
	5077: uint16(39790),
	5078: uint16(33209),
	5079: uint16(26445),
	5080: uint16(21758),
	5081: uint16(39921),
	5082: uint16(65122),
	5083: uint16(21103),
	5084: uint16(14039),
	5085: uint16(49150),
	5086: uint16(17705),
	5087: uint16(63873),
	5088: uint16(26045),
	5089: uint16(17062),
	5090: uint16(57),
	5091: uint16(16896),
	5092: uint16(36704),
	5093: uint16(37888),
	5094: uint16(16448),
	5095: uint16(45010),
	5096: uint16(53719),
	5097: uint16(219),
	5098: uint16(39072),
	5099: uint16(31666),
	5100: uint16(20998),
	5101: uint16(38944),
	5102: uint16(51222),
	5103: uint16(2365),
	5105: uint16(1),
	5107: uint16(2561),
	5108: uint16(2226),
	5109: uint16(128),
	5111: uint16(34820),
	5112: uint16(5152),
	5113: uint16(19472),
	5115: uint16(4),
	5116: uint16(17569),
	5117: uint16(16),
	5118: uint16(321),
	5119: uint16(2048),
	5120: uint16(61504),
	5121: uint16(20447),
	5122: uint16(22582),
	5123: uint16(62961),
	5124: uint16(32949),
	5125: uint16(26613),
	5126: uint16(16512),
	5127: uint16(20480),
	5128: uint16(16718),
	5129: uint16(33992),
	5130: uint16(23040),
	5131: uint16(55392),
	5132: uint16(11009),
	5133: uint16(20481),
	5134: uint16(5793),
	5135: uint16(16580),
	5136: uint16(28402),
	5137: uint16(44049),
	5138: uint16(14624),
	5139: uint16(49348),
	5140: uint16(1800),
	5141: uint16(2316),
	5142: uint16(38552),
	5143: uint16(39876),
	5144: uint16(7184),
	5145: uint16(27800),
	5146: uint16(10886),
	5147: uint16(422),
	5148: uint16(4422),
	5149: uint16(58733),
	5150: uint16(50379),
	5151: uint16(37568),
	5152: uint16(8464),
	5153: uint16(4630),
	5154: uint16(29341),
	5155: uint16(27124),
	5156: uint16(5902),
	5157: uint16(41514),
	5158: uint16(62593),
	5159: uint16(123),
	5160: uint16(41992),
	5161: uint16(36875),
	5162: uint16(11280),
	5163: uint16(14796),
	5164: uint16(330),
	5165: uint16(5872),
	5166: uint16(2571),
	5167: uint16(3136),
	5168: uint16(59933),
	5169: uint16(17420),
	5170: uint16(17678),
	5171: uint16(2),
}

var _ksc = [93][94]uint16{
	0: {
		0:  uint16(12288),
		1:  uint16(12289),
		2:  uint16(12290),
		3:  uint16(183),
		4:  uint16(8229),
		5:  uint16(8230),
		6:  uint16(168),
		7:  uint16(12291),
		8:  uint16(173),
		9:  uint16(8213),
		10: uint16(8741),
		11: uint16(65340),
		12: uint16(8764),
		13: uint16(8216),
		14: uint16(8217),
		15: uint16(8220),
		16: uint16(8221),
		17: uint16(12308),
		18: uint16(12309),
		19: uint16(12296),
		20: uint16(12297),
		21: uint16(12298),
		22: uint16(12299),
		23: uint16(12300),
		24: uint16(12301),
		25: uint16(12302),
		26: uint16(12303),
		27: uint16(12304),
		28: uint16(12305),
		29: uint16(177),
		30: uint16(215),
		31: uint16(247),
		32: uint16(8800),
		33: uint16(8804),
		34: uint16(8805),
		35: uint16(8734),
		36: uint16(8756),
		37: uint16(176),
		38: uint16(8242),
		39: uint16(8243),
		40: uint16(8451),
		41: uint16(8491),
		42: uint16(65504),
		43: uint16(65505),
		44: uint16(65509),
		45: uint16(9794),
		46: uint16(9792),
		47: uint16(8736),
		48: uint16(8869),
		49: uint16(8978),
		50: uint16(8706),
		51: uint16(8711),
		52: uint16(8801),
		53: uint16(8786),
		54: uint16(167),
		55: uint16(8251),
		56: uint16(9734),
		57: uint16(9733),
		58: uint16(9675),
		59: uint16(9679),
		60: uint16(9678),
		61: uint16(9671),
		62: uint16(9670),
		63: uint16(9633),
		64: uint16(9632),
		65: uint16(9651),
		66: uint16(9650),
		67: uint16(9661),
		68: uint16(9660),
		69: uint16(8594),
		70: uint16(8592),
		71: uint16(8593),
		72: uint16(8595),
		73: uint16(8596),
		74: uint16(12307),
		75: uint16(8810),
		76: uint16(8811),
		77: uint16(8730),
		78: uint16(8765),
		79: uint16(8733),
		80: uint16(8757),
		81: uint16(8747),
		82: uint16(8748),
		83: uint16(8712),
		84: uint16(8715),
		85: uint16(8838),
		86: uint16(8839),
		87: uint16(8834),
		88: uint16(8835),
		89: uint16(8746),
		90: uint16(8745),
		91: uint16(8743),
		92: uint16(8744),
		93: uint16(65506),
	},
	1: {
		0:  uint16(8658),
		1:  uint16(8660),
		2:  uint16(8704),
		3:  uint16(8707),
		4:  uint16(180),
		5:  uint16(65374),
		6:  uint16(711),
		7:  uint16(728),
		8:  uint16(733),
		9:  uint16(730),
		10: uint16(729),
		11: uint16(184),
		12: uint16(731),
		13: uint16(161),
		14: uint16(191),
		15: uint16(720),
		16: uint16(8750),
		17: uint16(8721),
		18: uint16(8719),
		19: uint16(164),
		20: uint16(8457),
		21: uint16(8240),
		22: uint16(9665),
		23: uint16(9664),
		24: uint16(9655),
		25: uint16(9654),
		26: uint16(9828),
		27: uint16(9824),
		28: uint16(9825),
		29: uint16(9829),
		30: uint16(9831),
		31: uint16(9827),
		32: uint16(8857),
		33: uint16(9672),
		34: uint16(9635),
		35: uint16(9680),
		36: uint16(9681),
		37: uint16(9618),
		38: uint16(9636),
		39: uint16(9637),
		40: uint16(9640),
		41: uint16(9639),
		42: uint16(9638),
		43: uint16(9641),
		44: uint16(9832),
		45: uint16(9743),
		46: uint16(9742),
		47: uint16(9756),
		48: uint16(9758),
		49: uint16(182),
		50: uint16(8224),
		51: uint16(8225),
		52: uint16(8597),
		53: uint16(8599),
		54: uint16(8601),
		55: uint16(8598),
		56: uint16(8600),
		57: uint16(9837),
		58: uint16(9833),
		59: uint16(9834),
		60: uint16(9836),
		61: uint16(12927),
		62: uint16(12828),
		63: uint16(8470),
		64: uint16(13255),
		65: uint16(8482),
		66: uint16(13250),
		67: uint16(13272),
		68: uint16(8481),
		69: uint16(8364),
		70: uint16(174),
	},
	2: {
		0:  uint16(65281),
		1:  uint16(65282),
		2:  uint16(65283),
		3:  uint16(65284),
		4:  uint16(65285),
		5:  uint16(65286),
		6:  uint16(65287),
		7:  uint16(65288),
		8:  uint16(65289),
		9:  uint16(65290),
		10: uint16(65291),
		11: uint16(65292),
		12: uint16(65293),
		13: uint16(65294),
		14: uint16(65295),
		15: uint16(65296),
		16: uint16(65297),
		17: uint16(65298),
		18: uint16(65299),
		19: uint16(65300),
		20: uint16(65301),
		21: uint16(65302),
		22: uint16(65303),
		23: uint16(65304),
		24: uint16(65305),
		25: uint16(65306),
		26: uint16(65307),
		27: uint16(65308),
		28: uint16(65309),
		29: uint16(65310),
		30: uint16(65311),
		31: uint16(65312),
		32: uint16(65313),
		33: uint16(65314),
		34: uint16(65315),
		35: uint16(65316),
		36: uint16(65317),
		37: uint16(65318),
		38: uint16(65319),
		39: uint16(65320),
		40: uint16(65321),
		41: uint16(65322),
		42: uint16(65323),
		43: uint16(65324),
		44: uint16(65325),
		45: uint16(65326),
		46: uint16(65327),
		47: uint16(65328),
		48: uint16(65329),
		49: uint16(65330),
		50: uint16(65331),
		51: uint16(65332),
		52: uint16(65333),
		53: uint16(65334),
		54: uint16(65335),
		55: uint16(65336),
		56: uint16(65337),
		57: uint16(65338),
		58: uint16(65339),
		59: uint16(65510),
		60: uint16(65341),
		61: uint16(65342),
		62: uint16(65343),
		63: uint16(65344),
		64: uint16(65345),
		65: uint16(65346),
		66: uint16(65347),
		67: uint16(65348),
		68: uint16(65349),
		69: uint16(65350),
		70: uint16(65351),
		71: uint16(65352),
		72: uint16(65353),
		73: uint16(65354),
		74: uint16(65355),
		75: uint16(65356),
		76: uint16(65357),
		77: uint16(65358),
		78: uint16(65359),
		79: uint16(65360),
		80: uint16(65361),
		81: uint16(65362),
		82: uint16(65363),
		83: uint16(65364),
		84: uint16(65365),
		85: uint16(65366),
		86: uint16(65367),
		87: uint16(65368),
		88: uint16(65369),
		89: uint16(65370),
		90: uint16(65371),
		91: uint16(65372),
		92: uint16(65373),
		93: uint16(65507),
	},
	3: {
		0:  uint16(12593),
		1:  uint16(12594),
		2:  uint16(12595),
		3:  uint16(12596),
		4:  uint16(12597),
		5:  uint16(12598),
		6:  uint16(12599),
		7:  uint16(12600),
		8:  uint16(12601),
		9:  uint16(12602),
		10: uint16(12603),
		11: uint16(12604),
		12: uint16(12605),
		13: uint16(12606),
		14: uint16(12607),
		15: uint16(12608),
		16: uint16(12609),
		17: uint16(12610),
		18: uint16(12611),
		19: uint16(12612),
		20: uint16(12613),
		21: uint16(12614),
		22: uint16(12615),
		23: uint16(12616),
		24: uint16(12617),
		25: uint16(12618),
		26: uint16(12619),
		27: uint16(12620),
		28: uint16(12621),
		29: uint16(12622),
		30: uint16(12623),
		31: uint16(12624),
		32: uint16(12625),
		33: uint16(12626),
		34: uint16(12627),
		35: uint16(12628),
		36: uint16(12629),
		37: uint16(12630),
		38: uint16(12631),
		39: uint16(12632),
		40: uint16(12633),
		41: uint16(12634),
		42: uint16(12635),
		43: uint16(12636),
		44: uint16(12637),
		45: uint16(12638),
		46: uint16(12639),
		47: uint16(12640),
		48: uint16(12641),
		49: uint16(12642),
		50: uint16(12643),
		51: uint16(12644),
		52: uint16(12645),
		53: uint16(12646),
		54: uint16(12647),
		55: uint16(12648),
		56: uint16(12649),
		57: uint16(12650),
		58: uint16(12651),
		59: uint16(12652),
		60: uint16(12653),
		61: uint16(12654),
		62: uint16(12655),
		63: uint16(12656),
		64: uint16(12657),
		65: uint16(12658),
		66: uint16(12659),
		67: uint16(12660),
		68: uint16(12661),
		69: uint16(12662),
		70: uint16(12663),
		71: uint16(12664),
		72: uint16(12665),
		73: uint16(12666),
		74: uint16(12667),
		75: uint16(12668),
		76: uint16(12669),
		77: uint16(12670),
		78: uint16(12671),
		79: uint16(12672),
		80: uint16(12673),
		81: uint16(12674),
		82: uint16(12675),
		83: uint16(12676),
		84: uint16(12677),
		85: uint16(12678),
		86: uint16(12679),
		87: uint16(12680),
		88: uint16(12681),
		89: uint16(12682),
		90: uint16(12683),
		91: uint16(12684),
		92: uint16(12685),
		93: uint16(12686),
	},
	4: {
		0:  uint16(8560),
		1:  uint16(8561),
		2:  uint16(8562),
		3:  uint16(8563),
		4:  uint16(8564),
		5:  uint16(8565),
		6:  uint16(8566),
		7:  uint16(8567),
		8:  uint16(8568),
		9:  uint16(8569),
		15: uint16(8544),
		16: uint16(8545),
		17: uint16(8546),
		18: uint16(8547),
		19: uint16(8548),
		20: uint16(8549),
		21: uint16(8550),
		22: uint16(8551),
		23: uint16(8552),
		24: uint16(8553),
		32: uint16(913),
		33: uint16(914),
		34: uint16(915),
		35: uint16(916),
		36: uint16(917),
		37: uint16(918),
		38: uint16(919),
		39: uint16(920),
		40: uint16(921),
		41: uint16(922),
		42: uint16(923),
		43: uint16(924),
		44: uint16(925),
		45: uint16(926),
		46: uint16(927),
		47: uint16(928),
		48: uint16(929),
		49: uint16(931),
		50: uint16(932),
		51: uint16(933),
		52: uint16(934),
		53: uint16(935),
		54: uint16(936),
		55: uint16(937),
		64: uint16(945),
		65: uint16(946),
		66: uint16(947),
		67: uint16(948),
		68: uint16(949),
		69: uint16(950),
		70: uint16(951),
		71: uint16(952),
		72: uint16(953),
		73: uint16(954),
		74: uint16(955),
		75: uint16(956),
		76: uint16(957),
		77: uint16(958),
		78: uint16(959),
		79: uint16(960),
		80: uint16(961),
		81: uint16(963),
		82: uint16(964),
		83: uint16(965),
		84: uint16(966),
		85: uint16(967),
		86: uint16(968),
		87: uint16(969),
	},
	5: {
		0:  uint16(9472),
		1:  uint16(9474),
		2:  uint16(9484),
		3:  uint16(9488),
		4:  uint16(9496),
		5:  uint16(9492),
		6:  uint16(9500),
		7:  uint16(9516),
		8:  uint16(9508),
		9:  uint16(9524),
		10: uint16(9532),
		11: uint16(9473),
		12: uint16(9475),
		13: uint16(9487),
		14: uint16(9491),
		15: uint16(9499),
		16: uint16(9495),
		17: uint16(9507),
		18: uint16(9523),
		19: uint16(9515),
		20: uint16(9531),
		21: uint16(9547),
		22: uint16(9504),
		23: uint16(9519),
		24: uint16(9512),
		25: uint16(9527),
		26: uint16(9535),
		27: uint16(9501),
		28: uint16(9520),
		29: uint16(9509),
		30: uint16(9528),
		31: uint16(9538),
		32: uint16(9490),
		33: uint16(9489),
		34: uint16(9498),
		35: uint16(9497),
		36: uint16(9494),
		37: uint16(9493),
		38: uint16(9486),
		39: uint16(9485),
		40: uint16(9502),
		41: uint16(9503),
		42: uint16(9505),
		43: uint16(9506),
		44: uint16(9510),
		45: uint16(9511),
		46: uint16(9513),
		47: uint16(9514),
		48: uint16(9517),
		49: uint16(9518),
		50: uint16(9521),
		51: uint16(9522),
		52: uint16(9525),
		53: uint16(9526),
		54: uint16(9529),
		55: uint16(9530),
		56: uint16(9533),
		57: uint16(9534),
		58: uint16(9536),
		59: uint16(9537),
		60: uint16(9539),
		61: uint16(9540),
		62: uint16(9541),
		63: uint16(9542),
		64: uint16(9543),
		65: uint16(9544),
		66: uint16(9545),
		67: uint16(9546),
	},
	6: {
		0:  uint16(13205),
		1:  uint16(13206),
		2:  uint16(13207),
		3:  uint16(8467),
		4:  uint16(13208),
		5:  uint16(13252),
		6:  uint16(13219),
		7:  uint16(13220),
		8:  uint16(13221),
		9:  uint16(13222),
		10: uint16(13209),
		11: uint16(13210),
		12: uint16(13211),
		13: uint16(13212),
		14: uint16(13213),
		15: uint16(13214),
		16: uint16(13215),
		17: uint16(13216),
		18: uint16(13217),
		19: uint16(13218),
		20: uint16(13258),
		21: uint16(13197),
		22: uint16(13198),
		23: uint16(13199),
		24: uint16(13263),
		25: uint16(13192),
		26: uint16(13193),
		27: uint16(13256),
		28: uint16(13223),
		29: uint16(13224),
		30: uint16(13232),
		31: uint16(13233),
		32: uint16(13234),
		33: uint16(13235),
		34: uint16(13236),
		35: uint16(13237),
		36: uint16(13238),
		37: uint16(13239),
		38: uint16(13240),
		39: uint16(13241),
		40: uint16(13184),
		41: uint16(13185),
		42: uint16(13186),
		43: uint16(13187),
		44: uint16(13188),
		45: uint16(13242),
		46: uint16(13243),
		47: uint16(13244),
		48: uint16(13245),
		49: uint16(13246),
		50: uint16(13247),
		51: uint16(13200),
		52: uint16(13201),
		53: uint16(13202),
		54: uint16(13203),
		55: uint16(13204),
		56: uint16(8486),
		57: uint16(13248),
		58: uint16(13249),
		59: uint16(13194),
		60: uint16(13195),
		61: uint16(13196),
		62: uint16(13270),
		63: uint16(13253),
		64: uint16(13229),
		65: uint16(13230),
		66: uint16(13231),
		67: uint16(13275),
		68: uint16(13225),
		69: uint16(13226),
		70: uint16(13227),
		71: uint16(13228),
		72: uint16(13277),
		73: uint16(13264),
		74: uint16(13267),
		75: uint16(13251),
		76: uint16(13257),
		77: uint16(13276),
		78: uint16(13254),
	},
	7: {
		0:  uint16(198),
		1:  uint16(208),
		2:  uint16(170),
		3:  uint16(294),
		5:  uint16(306),
		7:  uint16(319),
		8:  uint16(321),
		9:  uint16(216),
		10: uint16(338),
		11: uint16(186),
		12: uint16(222),
		13: uint16(358),
		14: uint16(330),
		16: uint16(12896),
		17: uint16(12897),
		18: uint16(12898),
		19: uint16(12899),
		20: uint16(12900),
		21: uint16(12901),
		22: uint16(12902),
		23: uint16(12903),
		24: uint16(12904),
		25: uint16(12905),
		26: uint16(12906),
		27: uint16(12907),
		28: uint16(12908),
		29: uint16(12909),
		30: uint16(12910),
		31: uint16(12911),
		32: uint16(12912),
		33: uint16(12913),
		34: uint16(12914),
		35: uint16(12915),
		36: uint16(12916),
		37: uint16(12917),
		38: uint16(12918),
		39: uint16(12919),
		40: uint16(12920),
		41: uint16(12921),
		42: uint16(12922),
		43: uint16(12923),
		44: uint16(9424),
		45: uint16(9425),
		46: uint16(9426),
		47: uint16(9427),
		48: uint16(9428),
		49: uint16(9429),
		50: uint16(9430),
		51: uint16(9431),
		52: uint16(9432),
		53: uint16(9433),
		54: uint16(9434),
		55: uint16(9435),
		56: uint16(9436),
		57: uint16(9437),
		58: uint16(9438),
		59: uint16(9439),
		60: uint16(9440),
		61: uint16(9441),
		62: uint16(9442),
		63: uint16(9443),
		64: uint16(9444),
		65: uint16(9445),
		66: uint16(9446),
		67: uint16(9447),
		68: uint16(9448),
		69: uint16(9449),
		70: uint16(9312),
		71: uint16(9313),
		72: uint16(9314),
		73: uint16(9315),
		74: uint16(9316),
		75: uint16(9317),
		76: uint16(9318),
		77: uint16(9319),
		78: uint16(9320),
		79: uint16(9321),
		80: uint16(9322),
		81: uint16(9323),
		82: uint16(9324),
		83: uint16(9325),
		84: uint16(9326),
		85: uint16(189),
		86: uint16(8531),
		87: uint16(8532),
		88: uint16(188),
		89: uint16(190),
		90: uint16(8539),
		91: uint16(8540),
		92: uint16(8541),
		93: uint16(8542),
	},
	8: {
		0:  uint16(230),
		1:  uint16(273),
		2:  uint16(240),
		3:  uint16(295),
		4:  uint16(305),
		5:  uint16(307),
		6:  uint16(312),
		7:  uint16(320),
		8:  uint16(322),
		9:  uint16(248),
		10: uint16(339),
		11: uint16(223),
		12: uint16(254),
		13: uint16(359),
		14: uint16(331),
		15: uint16(329),
		16: uint16(12800),
		17: uint16(12801),
		18: uint16(12802),
		19: uint16(12803),
		20: uint16(12804),
		21: uint16(12805),
		22: uint16(12806),
		23: uint16(12807),
		24: uint16(12808),
		25: uint16(12809),
		26: uint16(12810),
		27: uint16(12811),
		28: uint16(12812),
		29: uint16(12813),
		30: uint16(12814),
		31: uint16(12815),
		32: uint16(12816),
		33: uint16(12817),
		34: uint16(12818),
		35: uint16(12819),
		36: uint16(12820),
		37: uint16(12821),
		38: uint16(12822),
		39: uint16(12823),
		40: uint16(12824),
		41: uint16(12825),
		42: uint16(12826),
		43: uint16(12827),
		44: uint16(9372),
		45: uint16(9373),
		46: uint16(9374),
		47: uint16(9375),
		48: uint16(9376),
		49: uint16(9377),
		50: uint16(9378),
		51: uint16(9379),
		52: uint16(9380),
		53: uint16(9381),
		54: uint16(9382),
		55: uint16(9383),
		56: uint16(9384),
		57: uint16(9385),
		58: uint16(9386),
		59: uint16(9387),
		60: uint16(9388),
		61: uint16(9389),
		62: uint16(9390),
		63: uint16(9391),
		64: uint16(9392),
		65: uint16(9393),
		66: uint16(9394),
		67: uint16(9395),
		68: uint16(9396),
		69: uint16(9397),
		70: uint16(9332),
		71: uint16(9333),
		72: uint16(9334),
		73: uint16(9335),
		74: uint16(9336),
		75: uint16(9337),
		76: uint16(9338),
		77: uint16(9339),
		78: uint16(9340),
		79: uint16(9341),
		80: uint16(9342),
		81: uint16(9343),
		82: uint16(9344),
		83: uint16(9345),
		84: uint16(9346),
		85: uint16(185),
		86: uint16(178),
		87: uint16(179),
		88: uint16(8308),
		89: uint16(8319),
		90: uint16(8321),
		91: uint16(8322),
		92: uint16(8323),
		93: uint16(8324),
	},
	9: {
		0:  uint16(12353),
		1:  uint16(12354),
		2:  uint16(12355),
		3:  uint16(12356),
		4:  uint16(12357),
		5:  uint16(12358),
		6:  uint16(12359),
		7:  uint16(12360),
		8:  uint16(12361),
		9:  uint16(12362),
		10: uint16(12363),
		11: uint16(12364),
		12: uint16(12365),
		13: uint16(12366),
		14: uint16(12367),
		15: uint16(12368),
		16: uint16(12369),
		17: uint16(12370),
		18: uint16(12371),
		19: uint16(12372),
		20: uint16(12373),
		21: uint16(12374),
		22: uint16(12375),
		23: uint16(12376),
		24: uint16(12377),
		25: uint16(12378),
		26: uint16(12379),
		27: uint16(12380),
		28: uint16(12381),
		29: uint16(12382),
		30: uint16(12383),
		31: uint16(12384),
		32: uint16(12385),
		33: uint16(12386),
		34: uint16(12387),
		35: uint16(12388),
		36: uint16(12389),
		37: uint16(12390),
		38: uint16(12391),
		39: uint16(12392),
		40: uint16(12393),
		41: uint16(12394),
		42: uint16(12395),
		43: uint16(12396),
		44: uint16(12397),
		45: uint16(12398),
		46: uint16(12399),
		47: uint16(12400),
		48: uint16(12401),
		49: uint16(12402),
		50: uint16(12403),
		51: uint16(12404),
		52: uint16(12405),
		53: uint16(12406),
		54: uint16(12407),
		55: uint16(12408),
		56: uint16(12409),
		57: uint16(12410),
		58: uint16(12411),
		59: uint16(12412),
		60: uint16(12413),
		61: uint16(12414),
		62: uint16(12415),
		63: uint16(12416),
		64: uint16(12417),
		65: uint16(12418),
		66: uint16(12419),
		67: uint16(12420),
		68: uint16(12421),
		69: uint16(12422),
		70: uint16(12423),
		71: uint16(12424),
		72: uint16(12425),
		73: uint16(12426),
		74: uint16(12427),
		75: uint16(12428),
		76: uint16(12429),
		77: uint16(12430),
		78: uint16(12431),
		79: uint16(12432),
		80: uint16(12433),
		81: uint16(12434),
		82: uint16(12435),
	},
	10: {
		0:  uint16(12449),
		1:  uint16(12450),
		2:  uint16(12451),
		3:  uint16(12452),
		4:  uint16(12453),
		5:  uint16(12454),
		6:  uint16(12455),
		7:  uint16(12456),
		8:  uint16(12457),
		9:  uint16(12458),
		10: uint16(12459),
		11: uint16(12460),
		12: uint16(12461),
		13: uint16(12462),
		14: uint16(12463),
		15: uint16(12464),
		16: uint16(12465),
		17: uint16(12466),
		18: uint16(12467),
		19: uint16(12468),
		20: uint16(12469),
		21: uint16(12470),
		22: uint16(12471),
		23: uint16(12472),
		24: uint16(12473),
		25: uint16(12474),
		26: uint16(12475),
		27: uint16(12476),
		28: uint16(12477),
		29: uint16(12478),
		30: uint16(12479),
		31: uint16(12480),
		32: uint16(12481),
		33: uint16(12482),
		34: uint16(12483),
		35: uint16(12484),
		36: uint16(12485),
		37: uint16(12486),
		38: uint16(12487),
		39: uint16(12488),
		40: uint16(12489),
		41: uint16(12490),
		42: uint16(12491),
		43: uint16(12492),
		44: uint16(12493),
		45: uint16(12494),
		46: uint16(12495),
		47: uint16(12496),
		48: uint16(12497),
		49: uint16(12498),
		50: uint16(12499),
		51: uint16(12500),
		52: uint16(12501),
		53: uint16(12502),
		54: uint16(12503),
		55: uint16(12504),
		56: uint16(12505),
		57: uint16(12506),
		58: uint16(12507),
		59: uint16(12508),
		60: uint16(12509),
		61: uint16(12510),
		62: uint16(12511),
		63: uint16(12512),
		64: uint16(12513),
		65: uint16(12514),
		66: uint16(12515),
		67: uint16(12516),
		68: uint16(12517),
		69: uint16(12518),
		70: uint16(12519),
		71: uint16(12520),
		72: uint16(12521),
		73: uint16(12522),
		74: uint16(12523),
		75: uint16(12524),
		76: uint16(12525),
		77: uint16(12526),
		78: uint16(12527),
		79: uint16(12528),
		80: uint16(12529),
		81: uint16(12530),
		82: uint16(12531),
		83: uint16(12532),
		84: uint16(12533),
		85: uint16(12534),
	},
	11: {
		0:  uint16(1040),
		1:  uint16(1041),
		2:  uint16(1042),
		3:  uint16(1043),
		4:  uint16(1044),
		5:  uint16(1045),
		6:  uint16(1025),
		7:  uint16(1046),
		8:  uint16(1047),
		9:  uint16(1048),
		10: uint16(1049),
		11: uint16(1050),
		12: uint16(1051),
		13: uint16(1052),
		14: uint16(1053),
		15: uint16(1054),
		16: uint16(1055),
		17: uint16(1056),
		18: uint16(1057),
		19: uint16(1058),
		20: uint16(1059),
		21: uint16(1060),
		22: uint16(1061),
		23: uint16(1062),
		24: uint16(1063),
		25: uint16(1064),
		26: uint16(1065),
		27: uint16(1066),
		28: uint16(1067),
		29: uint16(1068),
		30: uint16(1069),
		31: uint16(1070),
		32: uint16(1071),
		48: uint16(1072),
		49: uint16(1073),
		50: uint16(1074),
		51: uint16(1075),
		52: uint16(1076),
		53: uint16(1077),
		54: uint16(1105),
		55: uint16(1078),
		56: uint16(1079),
		57: uint16(1080),
		58: uint16(1081),
		59: uint16(1082),
		60: uint16(1083),
		61: uint16(1084),
		62: uint16(1085),
		63: uint16(1086),
		64: uint16(1087),
		65: uint16(1088),
		66: uint16(1089),
		67: uint16(1090),
		68: uint16(1091),
		69: uint16(1092),
		70: uint16(1093),
		71: uint16(1094),
		72: uint16(1095),
		73: uint16(1096),
		74: uint16(1097),
		75: uint16(1098),
		76: uint16(1099),
		77: uint16(1100),
		78: uint16(1101),
		79: uint16(1102),
		80: uint16(1103),
	},
	12: {},
	13: {},
	14: {},
	15: {
		0:  uint16(44032),
		1:  uint16(44033),
		2:  uint16(44036),
		3:  uint16(44039),
		4:  uint16(44040),
		5:  uint16(44041),
		6:  uint16(44042),
		7:  uint16(44048),
		8:  uint16(44049),
		9:  uint16(44050),
		10: uint16(44051),
		11: uint16(44052),
		12: uint16(44053),
		13: uint16(44054),
		14: uint16(44055),
		15: uint16(44057),
		16: uint16(44058),
		17: uint16(44059),
		18: uint16(44060),
		19: uint16(44061),
		20: uint16(44064),
		21: uint16(44068),
		22: uint16(44076),
		23: uint16(44077),
		24: uint16(44079),
		25: uint16(44080),
		26: uint16(44081),
		27: uint16(44088),
		28: uint16(44089),
		29: uint16(44092),
		30: uint16(44096),
		31: uint16(44107),
		32: uint16(44109),
		33: uint16(44116),
		34: uint16(44120),
		35: uint16(44124),
		36: uint16(44144),
		37: uint16(44145),
		38: uint16(44148),
		39: uint16(44151),
		40: uint16(44152),
		41: uint16(44154),
		42: uint16(44160),
		43: uint16(44161),
		44: uint16(44163),
		45: uint16(44164),
		46: uint16(44165),
		47: uint16(44166),
		48: uint16(44169),
		49: uint16(44170),
		50: uint16(44171),
		51: uint16(44172),
		52: uint16(44176),
		53: uint16(44180),
		54: uint16(44188),
		55: uint16(44189),
		56: uint16(44191),
		57: uint16(44192),
		58: uint16(44193),
		59: uint16(44200),
		60: uint16(44201),
		61: uint16(44202),
		62: uint16(44204),
		63: uint16(44207),
		64: uint16(44208),
		65: uint16(44216),
		66: uint16(44217),
		67: uint16(44219),
		68: uint16(44220),
		69: uint16(44221),
		70: uint16(44225),
		71: uint16(44228),
		72: uint16(44232),
		73: uint16(44236),
		74: uint16(44245),
		75: uint16(44247),
		76: uint16(44256),
		77: uint16(44257),
		78: uint16(44260),
		79: uint16(44263),
		80: uint16(44264),
		81: uint16(44266),
		82: uint16(44268),
		83: uint16(44271),
		84: uint16(44272),
		85: uint16(44273),
		86: uint16(44275),
		87: uint16(44277),
		88: uint16(44278),
		89: uint16(44284),
		90: uint16(44285),
		91: uint16(44288),
		92: uint16(44292),
		93: uint16(44294),
	},
	16: {
		0:  uint16(44300),
		1:  uint16(44301),
		2:  uint16(44303),
		3:  uint16(44305),
		4:  uint16(44312),
		5:  uint16(44316),
		6:  uint16(44320),
		7:  uint16(44329),
		8:  uint16(44332),
		9:  uint16(44333),
		10: uint16(44340),
		11: uint16(44341),
		12: uint16(44344),
		13: uint16(44348),
		14: uint16(44356),
		15: uint16(44357),
		16: uint16(44359),
		17: uint16(44361),
		18: uint16(44368),
		19: uint16(44372),
		20: uint16(44376),
		21: uint16(44385),
		22: uint16(44387),
		23: uint16(44396),
		24: uint16(44397),
		25: uint16(44400),
		26: uint16(44403),
		27: uint16(44404),
		28: uint16(44405),
		29: uint16(44406),
		30: uint16(44411),
		31: uint16(44412),
		32: uint16(44413),
		33: uint16(44415),
		34: uint16(44417),
		35: uint16(44418),
		36: uint16(44424),
		37: uint16(44425),
		38: uint16(44428),
		39: uint16(44432),
		40: uint16(44444),
		41: uint16(44445),
		42: uint16(44452),
		43: uint16(44471),
		44: uint16(44480),
		45: uint16(44481),
		46: uint16(44484),
		47: uint16(44488),
		48: uint16(44496),
		49: uint16(44497),
		50: uint16(44499),
		51: uint16(44508),
		52: uint16(44512),
		53: uint16(44516),
		54: uint16(44536),
		55: uint16(44537),
		56: uint16(44540),
		57: uint16(44543),
		58: uint16(44544),
		59: uint16(44545),
		60: uint16(44552),
		61: uint16(44553),
		62: uint16(44555),
		63: uint16(44557),
		64: uint16(44564),
		65: uint16(44592),
		66: uint16(44593),
		67: uint16(44596),
		68: uint16(44599),
		69: uint16(44600),
		70: uint16(44602),
		71: uint16(44608),
		72: uint16(44609),
		73: uint16(44611),
		74: uint16(44613),
		75: uint16(44614),
		76: uint16(44618),
		77: uint16(44620),
		78: uint16(44621),
		79: uint16(44622),
		80: uint16(44624),
		81: uint16(44628),
		82: uint16(44630),
		83: uint16(44636),
		84: uint16(44637),
		85: uint16(44639),
		86: uint16(44640),
		87: uint16(44641),
		88: uint16(44645),
		89: uint16(44648),
		90: uint16(44649),
		91: uint16(44652),
		92: uint16(44656),
		93: uint16(44664),
	},
	17: {
		0:  uint16(44665),
		1:  uint16(44667),
		2:  uint16(44668),
		3:  uint16(44669),
		4:  uint16(44676),
		5:  uint16(44677),
		6:  uint16(44684),
		7:  uint16(44732),
		8:  uint16(44733),
		9:  uint16(44734),
		10: uint16(44736),
		11: uint16(44740),
		12: uint16(44748),
		13: uint16(44749),
		14: uint16(44751),
		15: uint16(44752),
		16: uint16(44753),
		17: uint16(44760),
		18: uint16(44761),
		19: uint16(44764),
		20: uint16(44776),
		21: uint16(44779),
		22: uint16(44781),
		23: uint16(44788),
		24: uint16(44792),
		25: uint16(44796),
		26: uint16(44807),
		27: uint16(44808),
		28: uint16(44813),
		29: uint16(44816),
		30: uint16(44844),
		31: uint16(44845),
		32: uint16(44848),
		33: uint16(44850),
		34: uint16(44852),
		35: uint16(44860),
		36: uint16(44861),
		37: uint16(44863),
		38: uint16(44865),
		39: uint16(44866),
		40: uint16(44867),
		41: uint16(44872),
		42: uint16(44873),
		43: uint16(44880),
		44: uint16(44892),
		45: uint16(44893),
		46: uint16(44900),
		47: uint16(44901),
		48: uint16(44921),
		49: uint16(44928),
		50: uint16(44932),
		51: uint16(44936),
		52: uint16(44944),
		53: uint16(44945),
		54: uint16(44949),
		55: uint16(44956),
		56: uint16(44984),
		57: uint16(44985),
		58: uint16(44988),
		59: uint16(44992),
		60: uint16(44999),
		61: uint16(45000),
		62: uint16(45001),
		63: uint16(45003),
		64: uint16(45005),
		65: uint16(45006),
		66: uint16(45012),
		67: uint16(45020),
		68: uint16(45032),
		69: uint16(45033),
		70: uint16(45040),
		71: uint16(45041),
		72: uint16(45044),
		73: uint16(45048),
		74: uint16(45056),
		75: uint16(45057),
		76: uint16(45060),
		77: uint16(45068),
		78: uint16(45072),
		79: uint16(45076),
		80: uint16(45084),
		81: uint16(45085),
		82: uint16(45096),
		83: uint16(45124),
		84: uint16(45125),
		85: uint16(45128),
		86: uint16(45130),
		87: uint16(45132),
		88: uint16(45134),
		89: uint16(45139),
		90: uint16(45140),
		91: uint16(45141),
		92: uint16(45143),
		93: uint16(45145),
	},
	18: {
		0:  uint16(45149),
		1:  uint16(45180),
		2:  uint16(45181),
		3:  uint16(45184),
		4:  uint16(45188),
		5:  uint16(45196),
		6:  uint16(45197),
		7:  uint16(45199),
		8:  uint16(45201),
		9:  uint16(45208),
		10: uint16(45209),
		11: uint16(45210),
		12: uint16(45212),
		13: uint16(45215),
		14: uint16(45216),
		15: uint16(45217),
		16: uint16(45218),
		17: uint16(45224),
		18: uint16(45225),
		19: uint16(45227),
		20: uint16(45228),
		21: uint16(45229),
		22: uint16(45230),
		23: uint16(45231),
		24: uint16(45233),
		25: uint16(45235),
		26: uint16(45236),
		27: uint16(45237),
		28: uint16(45240),
		29: uint16(45244),
		30: uint16(45252),
		31: uint16(45253),
		32: uint16(45255),
		33: uint16(45256),
		34: uint16(45257),
		35: uint16(45264),
		36: uint16(45265),
		37: uint16(45268),
		38: uint16(45272),
		39: uint16(45280),
		40: uint16(45285),
		41: uint16(45320),
		42: uint16(45321),
		43: uint16(45323),
		44: uint16(45324),
		45: uint16(45328),
		46: uint16(45330),
		47: uint16(45331),
		48: uint16(45336),
		49: uint16(45337),
		50: uint16(45339),
		51: uint16(45340),
		52: uint16(45341),
		53: uint16(45347),
		54: uint16(45348),
		55: uint16(45349),
		56: uint16(45352),
		57: uint16(45356),
		58: uint16(45364),
		59: uint16(45365),
		60: uint16(45367),
		61: uint16(45368),
		62: uint16(45369),
		63: uint16(45376),
		64: uint16(45377),
		65: uint16(45380),
		66: uint16(45384),
		67: uint16(45392),
		68: uint16(45393),
		69: uint16(45396),
		70: uint16(45397),
		71: uint16(45400),
		72: uint16(45404),
		73: uint16(45408),
		74: uint16(45432),
		75: uint16(45433),
		76: uint16(45436),
		77: uint16(45440),
		78: uint16(45442),
		79: uint16(45448),
		80: uint16(45449),
		81: uint16(45451),
		82: uint16(45453),
		83: uint16(45458),
		84: uint16(45459),
		85: uint16(45460),
		86: uint16(45464),
		87: uint16(45468),
		88: uint16(45480),
		89: uint16(45516),
		90: uint16(45520),
		91: uint16(45524),
		92: uint16(45532),
		93: uint16(45533),
	},
	19: {
		0:  uint16(45535),
		1:  uint16(45544),
		2:  uint16(45545),
		3:  uint16(45548),
		4:  uint16(45552),
		5:  uint16(45561),
		6:  uint16(45563),
		7:  uint16(45565),
		8:  uint16(45572),
		9:  uint16(45573),
		10: uint16(45576),
		11: uint16(45579),
		12: uint16(45580),
		13: uint16(45588),
		14: uint16(45589),
		15: uint16(45591),
		16: uint16(45593),
		17: uint16(45600),
		18: uint16(45620),
		19: uint16(45628),
		20: uint16(45656),
		21: uint16(45660),
		22: uint16(45664),
		23: uint16(45672),
		24: uint16(45673),
		25: uint16(45684),
		26: uint16(45685),
		27: uint16(45692),
		28: uint16(45700),
		29: uint16(45701),
		30: uint16(45705),
		31: uint16(45712),
		32: uint16(45713),
		33: uint16(45716),
		34: uint16(45720),
		35: uint16(45721),
		36: uint16(45722),
		37: uint16(45728),
		38: uint16(45729),
		39: uint16(45731),
		40: uint16(45733),
		41: uint16(45734),
		42: uint16(45738),
		43: uint16(45740),
		44: uint16(45744),
		45: uint16(45748),
		46: uint16(45768),
		47: uint16(45769),
		48: uint16(45772),
		49: uint16(45776),
		50: uint16(45778),
		51: uint16(45784),
		52: uint16(45785),
		53: uint16(45787),
		54: uint16(45789),
		55: uint16(45794),
		56: uint16(45796),
		57: uint16(45797),
		58: uint16(45798),
		59: uint16(45800),
		60: uint16(45803),
		61: uint16(45804),
		62: uint16(45805),
		63: uint16(45806),
		64: uint16(45807),
		65: uint16(45811),
		66: uint16(45812),
		67: uint16(45813),
		68: uint16(45815),
		69: uint16(45816),
		70: uint16(45817),
		71: uint16(45818),
		72: uint16(45819),
		73: uint16(45823),
		74: uint16(45824),
		75: uint16(45825),
		76: uint16(45828),
		77: uint16(45832),
		78: uint16(45840),
		79: uint16(45841),
		80: uint16(45843),
		81: uint16(45844),
		82: uint16(45845),
		83: uint16(45852),
		84: uint16(45908),
		85: uint16(45909),
		86: uint16(45910),
		87: uint16(45912),
		88: uint16(45915),
		89: uint16(45916),
		90: uint16(45918),
		91: uint16(45919),
		92: uint16(45924),
		93: uint16(45925),
	},
	20: {
		0:  uint16(45927),
		1:  uint16(45929),
		2:  uint16(45931),
		3:  uint16(45934),
		4:  uint16(45936),
		5:  uint16(45937),
		6:  uint16(45940),
		7:  uint16(45944),
		8:  uint16(45952),
		9:  uint16(45953),
		10: uint16(45955),
		11: uint16(45956),
		12: uint16(45957),
		13: uint16(45964),
		14: uint16(45968),
		15: uint16(45972),
		16: uint16(45984),
		17: uint16(45985),
		18: uint16(45992),
		19: uint16(45996),
		20: uint16(46020),
		21: uint16(46021),
		22: uint16(46024),
		23: uint16(46027),
		24: uint16(46028),
		25: uint16(46030),
		26: uint16(46032),
		27: uint16(46036),
		28: uint16(46037),
		29: uint16(46039),
		30: uint16(46041),
		31: uint16(46043),
		32: uint16(46045),
		33: uint16(46048),
		34: uint16(46052),
		35: uint16(46056),
		36: uint16(46076),
		37: uint16(46096),
		38: uint16(46104),
		39: uint16(46108),
		40: uint16(46112),
		41: uint16(46120),
		42: uint16(46121),
		43: uint16(46123),
		44: uint16(46132),
		45: uint16(46160),
		46: uint16(46161),
		47: uint16(46164),
		48: uint16(46168),
		49: uint16(46176),
		50: uint16(46177),
		51: uint16(46179),
		52: uint16(46181),
		53: uint16(46188),
		54: uint16(46208),
		55: uint16(46216),
		56: uint16(46237),
		57: uint16(46244),
		58: uint16(46248),
		59: uint16(46252),
		60: uint16(46261),
		61: uint16(46263),
		62: uint16(46265),
		63: uint16(46272),
		64: uint16(46276),
		65: uint16(46280),
		66: uint16(46288),
		67: uint16(46293),
		68: uint16(46300),
		69: uint16(46301),
		70: uint16(46304),
		71: uint16(46307),
		72: uint16(46308),
		73: uint16(46310),
		74: uint16(46316),
		75: uint16(46317),
		76: uint16(46319),
		77: uint16(46321),
		78: uint16(46328),
		79: uint16(46356),
		80: uint16(46357),
		81: uint16(46360),
		82: uint16(46363),
		83: uint16(46364),
		84: uint16(46372),
		85: uint16(46373),
		86: uint16(46375),
		87: uint16(46376),
		88: uint16(46377),
		89: uint16(46378),
		90: uint16(46384),
		91: uint16(46385),
		92: uint16(46388),
		93: uint16(46392),
	},
	21: {
		0:  uint16(46400),
		1:  uint16(46401),
		2:  uint16(46403),
		3:  uint16(46404),
		4:  uint16(46405),
		5:  uint16(46411),
		6:  uint16(46412),
		7:  uint16(46413),
		8:  uint16(46416),
		9:  uint16(46420),
		10: uint16(46428),
		11: uint16(46429),
		12: uint16(46431),
		13: uint16(46432),
		14: uint16(46433),
		15: uint16(46496),
		16: uint16(46497),
		17: uint16(46500),
		18: uint16(46504),
		19: uint16(46506),
		20: uint16(46507),
		21: uint16(46512),
		22: uint16(46513),
		23: uint16(46515),
		24: uint16(46516),
		25: uint16(46517),
		26: uint16(46523),
		27: uint16(46524),
		28: uint16(46525),
		29: uint16(46528),
		30: uint16(46532),
		31: uint16(46540),
		32: uint16(46541),
		33: uint16(46543),
		34: uint16(46544),
		35: uint16(46545),
		36: uint16(46552),
		37: uint16(46572),
		38: uint16(46608),
		39: uint16(46609),
		40: uint16(46612),
		41: uint16(46616),
		42: uint16(46629),
		43: uint16(46636),
		44: uint16(46644),
		45: uint16(46664),
		46: uint16(46692),
		47: uint16(46696),
		48: uint16(46748),
		49: uint16(46749),
		50: uint16(46752),
		51: uint16(46756),
		52: uint16(46763),
		53: uint16(46764),
		54: uint16(46769),
		55: uint16(46804),
		56: uint16(46832),
		57: uint16(46836),
		58: uint16(46840),
		59: uint16(46848),
		60: uint16(46849),
		61: uint16(46853),
		62: uint16(46888),
		63: uint16(46889),
		64: uint16(46892),
		65: uint16(46895),
		66: uint16(46896),
		67: uint16(46904),
		68: uint16(46905),
		69: uint16(46907),
		70: uint16(46916),
		71: uint16(46920),
		72: uint16(46924),
		73: uint16(46932),
		74: uint16(46933),
		75: uint16(46944),
		76: uint16(46948),
		77: uint16(46952),
		78: uint16(46960),
		79: uint16(46961),
		80: uint16(46963),
		81: uint16(46965),
		82: uint16(46972),
		83: uint16(46973),
		84: uint16(46976),
		85: uint16(46980),
		86: uint16(46988),
		87: uint16(46989),
		88: uint16(46991),
		89: uint16(46992),
		90: uint16(46993),
		91: uint16(46994),
		92: uint16(46998),
		93: uint16(46999),
	},
	22: {
		0:  uint16(47000),
		1:  uint16(47001),
		2:  uint16(47004),
		3:  uint16(47008),
		4:  uint16(47016),
		5:  uint16(47017),
		6:  uint16(47019),
		7:  uint16(47020),
		8:  uint16(47021),
		9:  uint16(47028),
		10: uint16(47029),
		11: uint16(47032),
		12: uint16(47047),
		13: uint16(47049),
		14: uint16(47084),
		15: uint16(47085),
		16: uint16(47088),
		17: uint16(47092),
		18: uint16(47100),
		19: uint16(47101),
		20: uint16(47103),
		21: uint16(47104),
		22: uint16(47105),
		23: uint16(47111),
		24: uint16(47112),
		25: uint16(47113),
		26: uint16(47116),
		27: uint16(47120),
		28: uint16(47128),
		29: uint16(47129),
		30: uint16(47131),
		31: uint16(47133),
		32: uint16(47140),
		33: uint16(47141),
		34: uint16(47144),
		35: uint16(47148),
		36: uint16(47156),
		37: uint16(47157),
		38: uint16(47159),
		39: uint16(47160),
		40: uint16(47161),
		41: uint16(47168),
		42: uint16(47172),
		43: uint16(47185),
		44: uint16(47187),
		45: uint16(47196),
		46: uint16(47197),
		47: uint16(47200),
		48: uint16(47204),
		49: uint16(47212),
		50: uint16(47213),
		51: uint16(47215),
		52: uint16(47217),
		53: uint16(47224),
		54: uint16(47228),
		55: uint16(47245),
		56: uint16(47272),
		57: uint16(47280),
		58: uint16(47284),
		59: uint16(47288),
		60: uint16(47296),
		61: uint16(47297),
		62: uint16(47299),
		63: uint16(47301),
		64: uint16(47308),
		65: uint16(47312),
		66: uint16(47316),
		67: uint16(47325),
		68: uint16(47327),
		69: uint16(47329),
		70: uint16(47336),
		71: uint16(47337),
		72: uint16(47340),
		73: uint16(47344),
		74: uint16(47352),
		75: uint16(47353),
		76: uint16(47355),
		77: uint16(47357),
		78: uint16(47364),
		79: uint16(47384),
		80: uint16(47392),
		81: uint16(47420),
		82: uint16(47421),
		83: uint16(47424),
		84: uint16(47428),
		85: uint16(47436),
		86: uint16(47439),
		87: uint16(47441),
		88: uint16(47448),
		89: uint16(47449),
		90: uint16(47452),
		91: uint16(47456),
		92: uint16(47464),
		93: uint16(47465),
	},
	23: {
		0:  uint16(47467),
		1:  uint16(47469),
		2:  uint16(47476),
		3:  uint16(47477),
		4:  uint16(47480),
		5:  uint16(47484),
		6:  uint16(47492),
		7:  uint16(47493),
		8:  uint16(47495),
		9:  uint16(47497),
		10: uint16(47498),
		11: uint16(47501),
		12: uint16(47502),
		13: uint16(47532),
		14: uint16(47533),
		15: uint16(47536),
		16: uint16(47540),
		17: uint16(47548),
		18: uint16(47549),
		19: uint16(47551),
		20: uint16(47553),
		21: uint16(47560),
		22: uint16(47561),
		23: uint16(47564),
		24: uint16(47566),
		25: uint16(47567),
		26: uint16(47568),
		27: uint16(47569),
		28: uint16(47570),
		29: uint16(47576),
		30: uint16(47577),
		31: uint16(47579),
		32: uint16(47581),
		33: uint16(47582),
		34: uint16(47585),
		35: uint16(47587),
		36: uint16(47588),
		37: uint16(47589),
		38: uint16(47592),
		39: uint16(47596),
		40: uint16(47604),
		41: uint16(47605),
		42: uint16(47607),
		43: uint16(47608),
		44: uint16(47609),
		45: uint16(47610),
		46: uint16(47616),
		47: uint16(47617),
		48: uint16(47624),
		49: uint16(47637),
		50: uint16(47672),
		51: uint16(47673),
		52: uint16(47676),
		53: uint16(47680),
		54: uint16(47682),
		55: uint16(47688),
		56: uint16(47689),
		57: uint16(47691),
		58: uint16(47693),
		59: uint16(47694),
		60: uint16(47699),
		61: uint16(47700),
		62: uint16(47701),
		63: uint16(47704),
		64: uint16(47708),
		65: uint16(47716),
		66: uint16(47717),
		67: uint16(47719),
		68: uint16(47720),
		69: uint16(47721),
		70: uint16(47728),
		71: uint16(47729),
		72: uint16(47732),
		73: uint16(47736),
		74: uint16(47747),
		75: uint16(47748),
		76: uint16(47749),
		77: uint16(47751),
		78: uint16(47756),
		79: uint16(47784),
		80: uint16(47785),
		81: uint16(47787),
		82: uint16(47788),
		83: uint16(47792),
		84: uint16(47794),
		85: uint16(47800),
		86: uint16(47801),
		87: uint16(47803),
		88: uint16(47805),
		89: uint16(47812),
		90: uint16(47816),
		91: uint16(47832),
		92: uint16(47833),
		93: uint16(47868),
	},
	24: {
		0:  uint16(47872),
		1:  uint16(47876),
		2:  uint16(47885),
		3:  uint16(47887),
		4:  uint16(47889),
		5:  uint16(47896),
		6:  uint16(47900),
		7:  uint16(47904),
		8:  uint16(47913),
		9:  uint16(47915),
		10: uint16(47924),
		11: uint16(47925),
		12: uint16(47926),
		13: uint16(47928),
		14: uint16(47931),
		15: uint16(47932),
		16: uint16(47933),
		17: uint16(47934),
		18: uint16(47940),
		19: uint16(47941),
		20: uint16(47943),
		21: uint16(47945),
		22: uint16(47949),
		23: uint16(47951),
		24: uint16(47952),
		25: uint16(47956),
		26: uint16(47960),
		27: uint16(47969),
		28: uint16(47971),
		29: uint16(47980),
		30: uint16(48008),
		31: uint16(48012),
		32: uint16(48016),
		33: uint16(48036),
		34: uint16(48040),
		35: uint16(48044),
		36: uint16(48052),
		37: uint16(48055),
		38: uint16(48064),
		39: uint16(48068),
		40: uint16(48072),
		41: uint16(48080),
		42: uint16(48083),
		43: uint16(48120),
		44: uint16(48121),
		45: uint16(48124),
		46: uint16(48127),
		47: uint16(48128),
		48: uint16(48130),
		49: uint16(48136),
		50: uint16(48137),
		51: uint16(48139),
		52: uint16(48140),
		53: uint16(48141),
		54: uint16(48143),
		55: uint16(48145),
		56: uint16(48148),
		57: uint16(48149),
		58: uint16(48150),
		59: uint16(48151),
		60: uint16(48152),
		61: uint16(48155),
		62: uint16(48156),
		63: uint16(48157),
		64: uint16(48158),
		65: uint16(48159),
		66: uint16(48164),
		67: uint16(48165),
		68: uint16(48167),
		69: uint16(48169),
		70: uint16(48173),
		71: uint16(48176),
		72: uint16(48177),
		73: uint16(48180),
		74: uint16(48184),
		75: uint16(48192),
		76: uint16(48193),
		77: uint16(48195),
		78: uint16(48196),
		79: uint16(48197),
		80: uint16(48201),
		81: uint16(48204),
		82: uint16(48205),
		83: uint16(48208),
		84: uint16(48221),
		85: uint16(48260),
		86: uint16(48261),
		87: uint16(48264),
		88: uint16(48267),
		89: uint16(48268),
		90: uint16(48270),
		91: uint16(48276),
		92: uint16(48277),
		93: uint16(48279),
	},
	25: {
		0:  uint16(48281),
		1:  uint16(48282),
		2:  uint16(48288),
		3:  uint16(48289),
		4:  uint16(48292),
		5:  uint16(48295),
		6:  uint16(48296),
		7:  uint16(48304),
		8:  uint16(48305),
		9:  uint16(48307),
		10: uint16(48308),
		11: uint16(48309),
		12: uint16(48316),
		13: uint16(48317),
		14: uint16(48320),
		15: uint16(48324),
		16: uint16(48333),
		17: uint16(48335),
		18: uint16(48336),
		19: uint16(48337),
		20: uint16(48341),
		21: uint16(48344),
		22: uint16(48348),
		23: uint16(48372),
		24: uint16(48373),
		25: uint16(48374),
		26: uint16(48376),
		27: uint16(48380),
		28: uint16(48388),
		29: uint16(48389),
		30: uint16(48391),
		31: uint16(48393),
		32: uint16(48400),
		33: uint16(48404),
		34: uint16(48420),
		35: uint16(48428),
		36: uint16(48448),
		37: uint16(48456),
		38: uint16(48457),
		39: uint16(48460),
		40: uint16(48464),
		41: uint16(48472),
		42: uint16(48473),
		43: uint16(48484),
		44: uint16(48488),
		45: uint16(48512),
		46: uint16(48513),
		47: uint16(48516),
		48: uint16(48519),
		49: uint16(48520),
		50: uint16(48521),
		51: uint16(48522),
		52: uint16(48528),
		53: uint16(48529),
		54: uint16(48531),
		55: uint16(48533),
		56: uint16(48537),
		57: uint16(48538),
		58: uint16(48540),
		59: uint16(48548),
		60: uint16(48560),
		61: uint16(48568),
		62: uint16(48596),
		63: uint16(48597),
		64: uint16(48600),
		65: uint16(48604),
		66: uint16(48617),
		67: uint16(48624),
		68: uint16(48628),
		69: uint16(48632),
		70: uint16(48640),
		71: uint16(48643),
		72: uint16(48645),
		73: uint16(48652),
		74: uint16(48653),
		75: uint16(48656),
		76: uint16(48660),
		77: uint16(48668),
		78: uint16(48669),
		79: uint16(48671),
		80: uint16(48708),
		81: uint16(48709),
		82: uint16(48712),
		83: uint16(48716),
		84: uint16(48718),
		85: uint16(48724),
		86: uint16(48725),
		87: uint16(48727),
		88: uint16(48729),
		89: uint16(48730),
		90: uint16(48731),
		91: uint16(48736),
		92: uint16(48737),
		93: uint16(48740),
	},
	26: {
		0:  uint16(48744),
		1:  uint16(48746),
		2:  uint16(48752),
		3:  uint16(48753),
		4:  uint16(48755),
		5:  uint16(48756),
		6:  uint16(48757),
		7:  uint16(48763),
		8:  uint16(48764),
		9:  uint16(48765),
		10: uint16(48768),
		11: uint16(48772),
		12: uint16(48780),
		13: uint16(48781),
		14: uint16(48783),
		15: uint16(48784),
		16: uint16(48785),
		17: uint16(48792),
		18: uint16(48793),
		19: uint16(48808),
		20: uint16(48848),
		21: uint16(48849),
		22: uint16(48852),
		23: uint16(48855),
		24: uint16(48856),
		25: uint16(48864),
		26: uint16(48867),
		27: uint16(48868),
		28: uint16(48869),
		29: uint16(48876),
		30: uint16(48897),
		31: uint16(48904),
		32: uint16(48905),
		33: uint16(48920),
		34: uint16(48921),
		35: uint16(48923),
		36: uint16(48924),
		37: uint16(48925),
		38: uint16(48960),
		39: uint16(48961),
		40: uint16(48964),
		41: uint16(48968),
		42: uint16(48976),
		43: uint16(48977),
		44: uint16(48981),
		45: uint16(49044),
		46: uint16(49072),
		47: uint16(49093),
		48: uint16(49100),
		49: uint16(49101),
		50: uint16(49104),
		51: uint16(49108),
		52: uint16(49116),
		53: uint16(49119),
		54: uint16(49121),
		55: uint16(49212),
		56: uint16(49233),
		57: uint16(49240),
		58: uint16(49244),
		59: uint16(49248),
		60: uint16(49256),
		61: uint16(49257),
		62: uint16(49296),
		63: uint16(49297),
		64: uint16(49300),
		65: uint16(49304),
		66: uint16(49312),
		67: uint16(49313),
		68: uint16(49315),
		69: uint16(49317),
		70: uint16(49324),
		71: uint16(49325),
		72: uint16(49327),
		73: uint16(49328),
		74: uint16(49331),
		75: uint16(49332),
		76: uint16(49333),
		77: uint16(49334),
		78: uint16(49340),
		79: uint16(49341),
		80: uint16(49343),
		81: uint16(49344),
		82: uint16(49345),
		83: uint16(49349),
		84: uint16(49352),
		85: uint16(49353),
		86: uint16(49356),
		87: uint16(49360),
		88: uint16(49368),
		89: uint16(49369),
		90: uint16(49371),
		91: uint16(49372),
		92: uint16(49373),
		93: uint16(49380),
	},
	27: {
		0:  uint16(49381),
		1:  uint16(49384),
		2:  uint16(49388),
		3:  uint16(49396),
		4:  uint16(49397),
		5:  uint16(49399),
		6:  uint16(49401),
		7:  uint16(49408),
		8:  uint16(49412),
		9:  uint16(49416),
		10: uint16(49424),
		11: uint16(49429),
		12: uint16(49436),
		13: uint16(49437),
		14: uint16(49438),
		15: uint16(49439),
		16: uint16(49440),
		17: uint16(49443),
		18: uint16(49444),
		19: uint16(49446),
		20: uint16(49447),
		21: uint16(49452),
		22: uint16(49453),
		23: uint16(49455),
		24: uint16(49456),
		25: uint16(49457),
		26: uint16(49462),
		27: uint16(49464),
		28: uint16(49465),
		29: uint16(49468),
		30: uint16(49472),
		31: uint16(49480),
		32: uint16(49481),
		33: uint16(49483),
		34: uint16(49484),
		35: uint16(49485),
		36: uint16(49492),
		37: uint16(49493),
		38: uint16(49496),
		39: uint16(49500),
		40: uint16(49508),
		41: uint16(49509),
		42: uint16(49511),
		43: uint16(49512),
		44: uint16(49513),
		45: uint16(49520),
		46: uint16(49524),
		47: uint16(49528),
		48: uint16(49541),
		49: uint16(49548),
		50: uint16(49549),
		51: uint16(49550),
		52: uint16(49552),
		53: uint16(49556),
		54: uint16(49558),
		55: uint16(49564),
		56: uint16(49565),
		57: uint16(49567),
		58: uint16(49569),
		59: uint16(49573),
		60: uint16(49576),
		61: uint16(49577),
		62: uint16(49580),
		63: uint16(49584),
		64: uint16(49597),
		65: uint16(49604),
		66: uint16(49608),
		67: uint16(49612),
		68: uint16(49620),
		69: uint16(49623),
		70: uint16(49624),
		71: uint16(49632),
		72: uint16(49636),
		73: uint16(49640),
		74: uint16(49648),
		75: uint16(49649),
		76: uint16(49651),
		77: uint16(49660),
		78: uint16(49661),
		79: uint16(49664),
		80: uint16(49668),
		81: uint16(49676),
		82: uint16(49677),
		83: uint16(49679),
		84: uint16(49681),
		85: uint16(49688),
		86: uint16(49689),
		87: uint16(49692),
		88: uint16(49695),
		89: uint16(49696),
		90: uint16(49704),
		91: uint16(49705),
		92: uint16(49707),
		93: uint16(49709),
	},
	28: {
		0:  uint16(49711),
		1:  uint16(49713),
		2:  uint16(49714),
		3:  uint16(49716),
		4:  uint16(49736),
		5:  uint16(49744),
		6:  uint16(49745),
		7:  uint16(49748),
		8:  uint16(49752),
		9:  uint16(49760),
		10: uint16(49765),
		11: uint16(49772),
		12: uint16(49773),
		13: uint16(49776),
		14: uint16(49780),
		15: uint16(49788),
		16: uint16(49789),
		17: uint16(49791),
		18: uint16(49793),
		19: uint16(49800),
		20: uint16(49801),
		21: uint16(49808),
		22: uint16(49816),
		23: uint16(49819),
		24: uint16(49821),
		25: uint16(49828),
		26: uint16(49829),
		27: uint16(49832),
		28: uint16(49836),
		29: uint16(49837),
		30: uint16(49844),
		31: uint16(49845),
		32: uint16(49847),
		33: uint16(49849),
		34: uint16(49884),
		35: uint16(49885),
		36: uint16(49888),
		37: uint16(49891),
		38: uint16(49892),
		39: uint16(49899),
		40: uint16(49900),
		41: uint16(49901),
		42: uint16(49903),
		43: uint16(49905),
		44: uint16(49910),
		45: uint16(49912),
		46: uint16(49913),
		47: uint16(49915),
		48: uint16(49916),
		49: uint16(49920),
		50: uint16(49928),
		51: uint16(49929),
		52: uint16(49932),
		53: uint16(49933),
		54: uint16(49939),
		55: uint16(49940),
		56: uint16(49941),
		57: uint16(49944),
		58: uint16(49948),
		59: uint16(49956),
		60: uint16(49957),
		61: uint16(49960),
		62: uint16(49961),
		63: uint16(49989),
		64: uint16(50024),
		65: uint16(50025),
		66: uint16(50028),
		67: uint16(50032),
		68: uint16(50034),
		69: uint16(50040),
		70: uint16(50041),
		71: uint16(50044),
		72: uint16(50045),
		73: uint16(50052),
		74: uint16(50056),
		75: uint16(50060),
		76: uint16(50112),
		77: uint16(50136),
		78: uint16(50137),
		79: uint16(50140),
		80: uint16(50143),
		81: uint16(50144),
		82: uint16(50146),
		83: uint16(50152),
		84: uint16(50153),
		85: uint16(50157),
		86: uint16(50164),
		87: uint16(50165),
		88: uint16(50168),
		89: uint16(50184),
		90: uint16(50192),
		91: uint16(50212),
		92: uint16(50220),
		93: uint16(50224),
	},
	29: {
		0:  uint16(50228),
		1:  uint16(50236),
		2:  uint16(50237),
		3:  uint16(50248),
		4:  uint16(50276),
		5:  uint16(50277),
		6:  uint16(50280),
		7:  uint16(50284),
		8:  uint16(50292),
		9:  uint16(50293),
		10: uint16(50297),
		11: uint16(50304),
		12: uint16(50324),
		13: uint16(50332),
		14: uint16(50360),
		15: uint16(50364),
		16: uint16(50409),
		17: uint16(50416),
		18: uint16(50417),
		19: uint16(50420),
		20: uint16(50424),
		21: uint16(50426),
		22: uint16(50431),
		23: uint16(50432),
		24: uint16(50433),
		25: uint16(50444),
		26: uint16(50448),
		27: uint16(50452),
		28: uint16(50460),
		29: uint16(50472),
		30: uint16(50473),
		31: uint16(50476),
		32: uint16(50480),
		33: uint16(50488),
		34: uint16(50489),
		35: uint16(50491),
		36: uint16(50493),
		37: uint16(50500),
		38: uint16(50501),
		39: uint16(50504),
		40: uint16(50505),
		41: uint16(50506),
		42: uint16(50508),
		43: uint16(50509),
		44: uint16(50510),
		45: uint16(50515),
		46: uint16(50516),
		47: uint16(50517),
		48: uint16(50519),
		49: uint16(50520),
		50: uint16(50521),
		51: uint16(50525),
		52: uint16(50526),
		53: uint16(50528),
		54: uint16(50529),
		55: uint16(50532),
		56: uint16(50536),
		57: uint16(50544),
		58: uint16(50545),
		59: uint16(50547),
		60: uint16(50548),
		61: uint16(50549),
		62: uint16(50556),
		63: uint16(50557),
		64: uint16(50560),
		65: uint16(50564),
		66: uint16(50567),
		67: uint16(50572),
		68: uint16(50573),
		69: uint16(50575),
		70: uint16(50577),
		71: uint16(50581),
		72: uint16(50583),
		73: uint16(50584),
		74: uint16(50588),
		75: uint16(50592),
		76: uint16(50601),
		77: uint16(50612),
		78: uint16(50613),
		79: uint16(50616),
		80: uint16(50617),
		81: uint16(50619),
		82: uint16(50620),
		83: uint16(50621),
		84: uint16(50622),
		85: uint16(50628),
		86: uint16(50629),
		87: uint16(50630),
		88: uint16(50631),
		89: uint16(50632),
		90: uint16(50633),
		91: uint16(50634),
		92: uint16(50636),
		93: uint16(50638),
	},
	30: {
		0:  uint16(50640),
		1:  uint16(50641),
		2:  uint16(50644),
		3:  uint16(50648),
		4:  uint16(50656),
		5:  uint16(50657),
		6:  uint16(50659),
		7:  uint16(50661),
		8:  uint16(50668),
		9:  uint16(50669),
		10: uint16(50670),
		11: uint16(50672),
		12: uint16(50676),
		13: uint16(50678),
		14: uint16(50679),
		15: uint16(50684),
		16: uint16(50685),
		17: uint16(50686),
		18: uint16(50687),
		19: uint16(50688),
		20: uint16(50689),
		21: uint16(50693),
		22: uint16(50694),
		23: uint16(50695),
		24: uint16(50696),
		25: uint16(50700),
		26: uint16(50704),
		27: uint16(50712),
		28: uint16(50713),
		29: uint16(50715),
		30: uint16(50716),
		31: uint16(50724),
		32: uint16(50725),
		33: uint16(50728),
		34: uint16(50732),
		35: uint16(50733),
		36: uint16(50734),
		37: uint16(50736),
		38: uint16(50739),
		39: uint16(50740),
		40: uint16(50741),
		41: uint16(50743),
		42: uint16(50745),
		43: uint16(50747),
		44: uint16(50752),
		45: uint16(50753),
		46: uint16(50756),
		47: uint16(50760),
		48: uint16(50768),
		49: uint16(50769),
		50: uint16(50771),
		51: uint16(50772),
		52: uint16(50773),
		53: uint16(50780),
		54: uint16(50781),
		55: uint16(50784),
		56: uint16(50796),
		57: uint16(50799),
		58: uint16(50801),
		59: uint16(50808),
		60: uint16(50809),
		61: uint16(50812),
		62: uint16(50816),
		63: uint16(50824),
		64: uint16(50825),
		65: uint16(50827),
		66: uint16(50829),
		67: uint16(50836),
		68: uint16(50837),
		69: uint16(50840),
		70: uint16(50844),
		71: uint16(50852),
		72: uint16(50853),
		73: uint16(50855),
		74: uint16(50857),
		75: uint16(50864),
		76: uint16(50865),
		77: uint16(50868),
		78: uint16(50872),
		79: uint16(50873),
		80: uint16(50874),
		81: uint16(50880),
		82: uint16(50881),
		83: uint16(50883),
		84: uint16(50885),
		85: uint16(50892),
		86: uint16(50893),
		87: uint16(50896),
		88: uint16(50900),
		89: uint16(50908),
		90: uint16(50909),
		91: uint16(50912),
		92: uint16(50913),
		93: uint16(50920),
	},
	31: {
		0:  uint16(50921),
		1:  uint16(50924),
		2:  uint16(50928),
		3:  uint16(50936),
		4:  uint16(50937),
		5:  uint16(50941),
		6:  uint16(50948),
		7:  uint16(50949),
		8:  uint16(50952),
		9:  uint16(50956),
		10: uint16(50964),
		11: uint16(50965),
		12: uint16(50967),
		13: uint16(50969),
		14: uint16(50976),
		15: uint16(50977),
		16: uint16(50980),
		17: uint16(50984),
		18: uint16(50992),
		19: uint16(50993),
		20: uint16(50995),
		21: uint16(50997),
		22: uint16(50999),
		23: uint16(51004),
		24: uint16(51005),
		25: uint16(51008),
		26: uint16(51012),
		27: uint16(51018),
		28: uint16(51020),
		29: uint16(51021),
		30: uint16(51023),
		31: uint16(51025),
		32: uint16(51026),
		33: uint16(51027),
		34: uint16(51028),
		35: uint16(51029),
		36: uint16(51030),
		37: uint16(51031),
		38: uint16(51032),
		39: uint16(51036),
		40: uint16(51040),
		41: uint16(51048),
		42: uint16(51051),
		43: uint16(51060),
		44: uint16(51061),
		45: uint16(51064),
		46: uint16(51068),
		47: uint16(51069),
		48: uint16(51070),
		49: uint16(51075),
		50: uint16(51076),
		51: uint16(51077),
		52: uint16(51079),
		53: uint16(51080),
		54: uint16(51081),
		55: uint16(51082),
		56: uint16(51086),
		57: uint16(51088),
		58: uint16(51089),
		59: uint16(51092),
		60: uint16(51094),
		61: uint16(51095),
		62: uint16(51096),
		63: uint16(51098),
		64: uint16(51104),
		65: uint16(51105),
		66: uint16(51107),
		67: uint16(51108),
		68: uint16(51109),
		69: uint16(51110),
		70: uint16(51116),
		71: uint16(51117),
		72: uint16(51120),
		73: uint16(51124),
		74: uint16(51132),
		75: uint16(51133),
		76: uint16(51135),
		77: uint16(51136),
		78: uint16(51137),
		79: uint16(51144),
		80: uint16(51145),
		81: uint16(51148),
		82: uint16(51150),
		83: uint16(51152),
		84: uint16(51160),
		85: uint16(51165),
		86: uint16(51172),
		87: uint16(51176),
		88: uint16(51180),
		89: uint16(51200),
		90: uint16(51201),
		91: uint16(51204),
		92: uint16(51208),
		93: uint16(51210),
	},
	32: {
		0:  uint16(51216),
		1:  uint16(51217),
		2:  uint16(51219),
		3:  uint16(51221),
		4:  uint16(51222),
		5:  uint16(51228),
		6:  uint16(51229),
		7:  uint16(51232),
		8:  uint16(51236),
		9:  uint16(51244),
		10: uint16(51245),
		11: uint16(51247),
		12: uint16(51249),
		13: uint16(51256),
		14: uint16(51260),
		15: uint16(51264),
		16: uint16(51272),
		17: uint16(51273),
		18: uint16(51276),
		19: uint16(51277),
		20: uint16(51284),
		21: uint16(51312),
		22: uint16(51313),
		23: uint16(51316),
		24: uint16(51320),
		25: uint16(51322),
		26: uint16(51328),
		27: uint16(51329),
		28: uint16(51331),
		29: uint16(51333),
		30: uint16(51334),
		31: uint16(51335),
		32: uint16(51339),
		33: uint16(51340),
		34: uint16(51341),
		35: uint16(51348),
		36: uint16(51357),
		37: uint16(51359),
		38: uint16(51361),
		39: uint16(51368),
		40: uint16(51388),
		41: uint16(51389),
		42: uint16(51396),
		43: uint16(51400),
		44: uint16(51404),
		45: uint16(51412),
		46: uint16(51413),
		47: uint16(51415),
		48: uint16(51417),
		49: uint16(51424),
		50: uint16(51425),
		51: uint16(51428),
		52: uint16(51445),
		53: uint16(51452),
		54: uint16(51453),
		55: uint16(51456),
		56: uint16(51460),
		57: uint16(51461),
		58: uint16(51462),
		59: uint16(51468),
		60: uint16(51469),
		61: uint16(51471),
		62: uint16(51473),
		63: uint16(51480),
		64: uint16(51500),
		65: uint16(51508),
		66: uint16(51536),
		67: uint16(51537),
		68: uint16(51540),
		69: uint16(51544),
		70: uint16(51552),
		71: uint16(51553),
		72: uint16(51555),
		73: uint16(51564),
		74: uint16(51568),
		75: uint16(51572),
		76: uint16(51580),
		77: uint16(51592),
		78: uint16(51593),
		79: uint16(51596),
		80: uint16(51600),
		81: uint16(51608),
		82: uint16(51609),
		83: uint16(51611),
		84: uint16(51613),
		85: uint16(51648),
		86: uint16(51649),
		87: uint16(51652),
		88: uint16(51655),
		89: uint16(51656),
		90: uint16(51658),
		91: uint16(51664),
		92: uint16(51665),
		93: uint16(51667),
	},
	33: {
		0:  uint16(51669),
		1:  uint16(51670),
		2:  uint16(51673),
		3:  uint16(51674),
		4:  uint16(51676),
		5:  uint16(51677),
		6:  uint16(51680),
		7:  uint16(51682),
		8:  uint16(51684),
		9:  uint16(51687),
		10: uint16(51692),
		11: uint16(51693),
		12: uint16(51695),
		13: uint16(51696),
		14: uint16(51697),
		15: uint16(51704),
		16: uint16(51705),
		17: uint16(51708),
		18: uint16(51712),
		19: uint16(51720),
		20: uint16(51721),
		21: uint16(51723),
		22: uint16(51724),
		23: uint16(51725),
		24: uint16(51732),
		25: uint16(51736),
		26: uint16(51753),
		27: uint16(51788),
		28: uint16(51789),
		29: uint16(51792),
		30: uint16(51796),
		31: uint16(51804),
		32: uint16(51805),
		33: uint16(51807),
		34: uint16(51808),
		35: uint16(51809),
		36: uint16(51816),
		37: uint16(51837),
		38: uint16(51844),
		39: uint16(51864),
		40: uint16(51900),
		41: uint16(51901),
		42: uint16(51904),
		43: uint16(51908),
		44: uint16(51916),
		45: uint16(51917),
		46: uint16(51919),
		47: uint16(51921),
		48: uint16(51923),
		49: uint16(51928),
		50: uint16(51929),
		51: uint16(51936),
		52: uint16(51948),
		53: uint16(51956),
		54: uint16(51976),
		55: uint16(51984),
		56: uint16(51988),
		57: uint16(51992),
		58: uint16(52000),
		59: uint16(52001),
		60: uint16(52033),
		61: uint16(52040),
		62: uint16(52041),
		63: uint16(52044),
		64: uint16(52048),
		65: uint16(52056),
		66: uint16(52057),
		67: uint16(52061),
		68: uint16(52068),
		69: uint16(52088),
		70: uint16(52089),
		71: uint16(52124),
		72: uint16(52152),
		73: uint16(52180),
		74: uint16(52196),
		75: uint16(52199),
		76: uint16(52201),
		77: uint16(52236),
		78: uint16(52237),
		79: uint16(52240),
		80: uint16(52244),
		81: uint16(52252),
		82: uint16(52253),
		83: uint16(52257),
		84: uint16(52258),
		85: uint16(52263),
		86: uint16(52264),
		87: uint16(52265),
		88: uint16(52268),
		89: uint16(52270),
		90: uint16(52272),
		91: uint16(52280),
		92: uint16(52281),
		93: uint16(52283),
	},
	34: {
		0:  uint16(52284),
		1:  uint16(52285),
		2:  uint16(52286),
		3:  uint16(52292),
		4:  uint16(52293),
		5:  uint16(52296),
		6:  uint16(52300),
		7:  uint16(52308),
		8:  uint16(52309),
		9:  uint16(52311),
		10: uint16(52312),
		11: uint16(52313),
		12: uint16(52320),
		13: uint16(52324),
		14: uint16(52326),
		15: uint16(52328),
		16: uint16(52336),
		17: uint16(52341),
		18: uint16(52376),
		19: uint16(52377),
		20: uint16(52380),
		21: uint16(52384),
		22: uint16(52392),
		23: uint16(52393),
		24: uint16(52395),
		25: uint16(52396),
		26: uint16(52397),
		27: uint16(52404),
		28: uint16(52405),
		29: uint16(52408),
		30: uint16(52412),
		31: uint16(52420),
		32: uint16(52421),
		33: uint16(52423),
		34: uint16(52425),
		35: uint16(52432),
		36: uint16(52436),
		37: uint16(52452),
		38: uint16(52460),
		39: uint16(52464),
		40: uint16(52481),
		41: uint16(52488),
		42: uint16(52489),
		43: uint16(52492),
		44: uint16(52496),
		45: uint16(52504),
		46: uint16(52505),
		47: uint16(52507),
		48: uint16(52509),
		49: uint16(52516),
		50: uint16(52520),
		51: uint16(52524),
		52: uint16(52537),
		53: uint16(52572),
		54: uint16(52576),
		55: uint16(52580),
		56: uint16(52588),
		57: uint16(52589),
		58: uint16(52591),
		59: uint16(52593),
		60: uint16(52600),
		61: uint16(52616),
		62: uint16(52628),
		63: uint16(52629),
		64: uint16(52632),
		65: uint16(52636),
		66: uint16(52644),
		67: uint16(52645),
		68: uint16(52647),
		69: uint16(52649),
		70: uint16(52656),
		71: uint16(52676),
		72: uint16(52684),
		73: uint16(52688),
		74: uint16(52712),
		75: uint16(52716),
		76: uint16(52720),
		77: uint16(52728),
		78: uint16(52729),
		79: uint16(52731),
		80: uint16(52733),
		81: uint16(52740),
		82: uint16(52744),
		83: uint16(52748),
		84: uint16(52756),
		85: uint16(52761),
		86: uint16(52768),
		87: uint16(52769),
		88: uint16(52772),
		89: uint16(52776),
		90: uint16(52784),
		91: uint16(52785),
		92: uint16(52787),
		93: uint16(52789),
	},
	35: {
		0:  uint16(52824),
		1:  uint16(52825),
		2:  uint16(52828),
		3:  uint16(52831),
		4:  uint16(52832),
		5:  uint16(52833),
		6:  uint16(52840),
		7:  uint16(52841),
		8:  uint16(52843),
		9:  uint16(52845),
		10: uint16(52852),
		11: uint16(52853),
		12: uint16(52856),
		13: uint16(52860),
		14: uint16(52868),
		15: uint16(52869),
		16: uint16(52871),
		17: uint16(52873),
		18: uint16(52880),
		19: uint16(52881),
		20: uint16(52884),
		21: uint16(52888),
		22: uint16(52896),
		23: uint16(52897),
		24: uint16(52899),
		25: uint16(52900),
		26: uint16(52901),
		27: uint16(52908),
		28: uint16(52909),
		29: uint16(52929),
		30: uint16(52964),
		31: uint16(52965),
		32: uint16(52968),
		33: uint16(52971),
		34: uint16(52972),
		35: uint16(52980),
		36: uint16(52981),
		37: uint16(52983),
		38: uint16(52984),
		39: uint16(52985),
		40: uint16(52992),
		41: uint16(52993),
		42: uint16(52996),
		43: uint16(53000),
		44: uint16(53008),
		45: uint16(53009),
		46: uint16(53011),
		47: uint16(53013),
		48: uint16(53020),
		49: uint16(53024),
		50: uint16(53028),
		51: uint16(53036),
		52: uint16(53037),
		53: uint16(53039),
		54: uint16(53040),
		55: uint16(53041),
		56: uint16(53048),
		57: uint16(53076),
		58: uint16(53077),
		59: uint16(53080),
		60: uint16(53084),
		61: uint16(53092),
		62: uint16(53093),
		63: uint16(53095),
		64: uint16(53097),
		65: uint16(53104),
		66: uint16(53105),
		67: uint16(53108),
		68: uint16(53112),
		69: uint16(53120),
		70: uint16(53125),
		71: uint16(53132),
		72: uint16(53153),
		73: uint16(53160),
		74: uint16(53168),
		75: uint16(53188),
		76: uint16(53216),
		77: uint16(53217),
		78: uint16(53220),
		79: uint16(53224),
		80: uint16(53232),
		81: uint16(53233),
		82: uint16(53235),
		83: uint16(53237),
		84: uint16(53244),
		85: uint16(53248),
		86: uint16(53252),
		87: uint16(53265),
		88: uint16(53272),
		89: uint16(53293),
		90: uint16(53300),
		91: uint16(53301),
		92: uint16(53304),
		93: uint16(53308),
	},
	36: {
		0:  uint16(53316),
		1:  uint16(53317),
		2:  uint16(53319),
		3:  uint16(53321),
		4:  uint16(53328),
		5:  uint16(53332),
		6:  uint16(53336),
		7:  uint16(53344),
		8:  uint16(53356),
		9:  uint16(53357),
		10: uint16(53360),
		11: uint16(53364),
		12: uint16(53372),
		13: uint16(53373),
		14: uint16(53377),
		15: uint16(53412),
		16: uint16(53413),
		17: uint16(53416),
		18: uint16(53420),
		19: uint16(53428),
		20: uint16(53429),
		21: uint16(53431),
		22: uint16(53433),
		23: uint16(53440),
		24: uint16(53441),
		25: uint16(53444),
		26: uint16(53448),
		27: uint16(53449),
		28: uint16(53456),
		29: uint16(53457),
		30: uint16(53459),
		31: uint16(53460),
		32: uint16(53461),
		33: uint16(53468),
		34: uint16(53469),
		35: uint16(53472),
		36: uint16(53476),
		37: uint16(53484),
		38: uint16(53485),
		39: uint16(53487),
		40: uint16(53488),
		41: uint16(53489),
		42: uint16(53496),
		43: uint16(53517),
		44: uint16(53552),
		45: uint16(53553),
		46: uint16(53556),
		47: uint16(53560),
		48: uint16(53562),
		49: uint16(53568),
		50: uint16(53569),
		51: uint16(53571),
		52: uint16(53572),
		53: uint16(53573),
		54: uint16(53580),
		55: uint16(53581),
		56: uint16(53584),
		57: uint16(53588),
		58: uint16(53596),
		59: uint16(53597),
		60: uint16(53599),
		61: uint16(53601),
		62: uint16(53608),
		63: uint16(53612),
		64: uint16(53628),
		65: uint16(53636),
		66: uint16(53640),
		67: uint16(53664),
		68: uint16(53665),
		69: uint16(53668),
		70: uint16(53672),
		71: uint16(53680),
		72: uint16(53681),
		73: uint16(53683),
		74: uint16(53685),
		75: uint16(53690),
		76: uint16(53692),
		77: uint16(53696),
		78: uint16(53720),
		79: uint16(53748),
		80: uint16(53752),
		81: uint16(53767),
		82: uint16(53769),
		83: uint16(53776),
		84: uint16(53804),
		85: uint16(53805),
		86: uint16(53808),
		87: uint16(53812),
		88: uint16(53820),
		89: uint16(53821),
		90: uint16(53823),
		91: uint16(53825),
		92: uint16(53832),
		93: uint16(53852),
	},
	37: {
		0:  uint16(53860),
		1:  uint16(53888),
		2:  uint16(53889),
		3:  uint16(53892),
		4:  uint16(53896),
		5:  uint16(53904),
		6:  uint16(53905),
		7:  uint16(53909),
		8:  uint16(53916),
		9:  uint16(53920),
		10: uint16(53924),
		11: uint16(53932),
		12: uint16(53937),
		13: uint16(53944),
		14: uint16(53945),
		15: uint16(53948),
		16: uint16(53951),
		17: uint16(53952),
		18: uint16(53954),
		19: uint16(53960),
		20: uint16(53961),
		21: uint16(53963),
		22: uint16(53972),
		23: uint16(53976),
		24: uint16(53980),
		25: uint16(53988),
		26: uint16(53989),
		27: uint16(54000),
		28: uint16(54001),
		29: uint16(54004),
		30: uint16(54008),
		31: uint16(54016),
		32: uint16(54017),
		33: uint16(54019),
		34: uint16(54021),
		35: uint16(54028),
		36: uint16(54029),
		37: uint16(54030),
		38: uint16(54032),
		39: uint16(54036),
		40: uint16(54038),
		41: uint16(54044),
		42: uint16(54045),
		43: uint16(54047),
		44: uint16(54048),
		45: uint16(54049),
		46: uint16(54053),
		47: uint16(54056),
		48: uint16(54057),
		49: uint16(54060),
		50: uint16(54064),
		51: uint16(54072),
		52: uint16(54073),
		53: uint16(54075),
		54: uint16(54076),
		55: uint16(54077),
		56: uint16(54084),
		57: uint16(54085),
		58: uint16(54140),
		59: uint16(54141),
		60: uint16(54144),
		61: uint16(54148),
		62: uint16(54156),
		63: uint16(54157),
		64: uint16(54159),
		65: uint16(54160),
		66: uint16(54161),
		67: uint16(54168),
		68: uint16(54169),
		69: uint16(54172),
		70: uint16(54176),
		71: uint16(54184),
		72: uint16(54185),
		73: uint16(54187),
		74: uint16(54189),
		75: uint16(54196),
		76: uint16(54200),
		77: uint16(54204),
		78: uint16(54212),
		79: uint16(54213),
		80: uint16(54216),
		81: uint16(54217),
		82: uint16(54224),
		83: uint16(54232),
		84: uint16(54241),
		85: uint16(54243),
		86: uint16(54252),
		87: uint16(54253),
		88: uint16(54256),
		89: uint16(54260),
		90: uint16(54268),
		91: uint16(54269),
		92: uint16(54271),
		93: uint16(54273),
	},
	38: {
		0:  uint16(54280),
		1:  uint16(54301),
		2:  uint16(54336),
		3:  uint16(54340),
		4:  uint16(54364),
		5:  uint16(54368),
		6:  uint16(54372),
		7:  uint16(54381),
		8:  uint16(54383),
		9:  uint16(54392),
		10: uint16(54393),
		11: uint16(54396),
		12: uint16(54399),
		13: uint16(54400),
		14: uint16(54402),
		15: uint16(54408),
		16: uint16(54409),
		17: uint16(54411),
		18: uint16(54413),
		19: uint16(54420),
		20: uint16(54441),
		21: uint16(54476),
		22: uint16(54480),
		23: uint16(54484),
		24: uint16(54492),
		25: uint16(54495),
		26: uint16(54504),
		27: uint16(54508),
		28: uint16(54512),
		29: uint16(54520),
		30: uint16(54523),
		31: uint16(54525),
		32: uint16(54532),
		33: uint16(54536),
		34: uint16(54540),
		35: uint16(54548),
		36: uint16(54549),
		37: uint16(54551),
		38: uint16(54588),
		39: uint16(54589),
		40: uint16(54592),
		41: uint16(54596),
		42: uint16(54604),
		43: uint16(54605),
		44: uint16(54607),
		45: uint16(54609),
		46: uint16(54616),
		47: uint16(54617),
		48: uint16(54620),
		49: uint16(54624),
		50: uint16(54629),
		51: uint16(54632),
		52: uint16(54633),
		53: uint16(54635),
		54: uint16(54637),
		55: uint16(54644),
		56: uint16(54645),
		57: uint16(54648),
		58: uint16(54652),
		59: uint16(54660),
		60: uint16(54661),
		61: uint16(54663),
		62: uint16(54664),
		63: uint16(54665),
		64: uint16(54672),
		65: uint16(54693),
		66: uint16(54728),
		67: uint16(54729),
		68: uint16(54732),
		69: uint16(54736),
		70: uint16(54738),
		71: uint16(54744),
		72: uint16(54745),
		73: uint16(54747),
		74: uint16(54749),
		75: uint16(54756),
		76: uint16(54757),
		77: uint16(54760),
		78: uint16(54764),
		79: uint16(54772),
		80: uint16(54773),
		81: uint16(54775),
		82: uint16(54777),
		83: uint16(54784),
		84: uint16(54785),
		85: uint16(54788),
		86: uint16(54792),
		87: uint16(54800),
		88: uint16(54801),
		89: uint16(54803),
		90: uint16(54804),
		91: uint16(54805),
		92: uint16(54812),
		93: uint16(54816),
	},
	39: {
		0:  uint16(54820),
		1:  uint16(54829),
		2:  uint16(54840),
		3:  uint16(54841),
		4:  uint16(54844),
		5:  uint16(54848),
		6:  uint16(54853),
		7:  uint16(54856),
		8:  uint16(54857),
		9:  uint16(54859),
		10: uint16(54861),
		11: uint16(54865),
		12: uint16(54868),
		13: uint16(54869),
		14: uint16(54872),
		15: uint16(54876),
		16: uint16(54887),
		17: uint16(54889),
		18: uint16(54896),
		19: uint16(54897),
		20: uint16(54900),
		21: uint16(54915),
		22: uint16(54917),
		23: uint16(54924),
		24: uint16(54925),
		25: uint16(54928),
		26: uint16(54932),
		27: uint16(54941),
		28: uint16(54943),
		29: uint16(54945),
		30: uint16(54952),
		31: uint16(54956),
		32: uint16(54960),
		33: uint16(54969),
		34: uint16(54971),
		35: uint16(54980),
		36: uint16(54981),
		37: uint16(54984),
		38: uint16(54988),
		39: uint16(54993),
		40: uint16(54996),
		41: uint16(54999),
		42: uint16(55001),
		43: uint16(55008),
		44: uint16(55012),
		45: uint16(55016),
		46: uint16(55024),
		47: uint16(55029),
		48: uint16(55036),
		49: uint16(55037),
		50: uint16(55040),
		51: uint16(55044),
		52: uint16(55057),
		53: uint16(55064),
		54: uint16(55065),
		55: uint16(55068),
		56: uint16(55072),
		57: uint16(55080),
		58: uint16(55081),
		59: uint16(55083),
		60: uint16(55085),
		61: uint16(55092),
		62: uint16(55093),
		63: uint16(55096),
		64: uint16(55100),
		65: uint16(55108),
		66: uint16(55111),
		67: uint16(55113),
		68: uint16(55120),
		69: uint16(55121),
		70: uint16(55124),
		71: uint16(55126),
		72: uint16(55127),
		73: uint16(55128),
		74: uint16(55129),
		75: uint16(55136),
		76: uint16(55137),
		77: uint16(55139),
		78: uint16(55141),
		79: uint16(55145),
		80: uint16(55148),
		81: uint16(55152),
		82: uint16(55156),
		83: uint16(55164),
		84: uint16(55165),
		85: uint16(55169),
		86: uint16(55176),
		87: uint16(55177),
		88: uint16(55180),
		89: uint16(55184),
		90: uint16(55192),
		91: uint16(55193),
		92: uint16(55195),
		93: uint16(55197),
	},
	40: {},
	41: {
		0:  uint16(20285),
		1:  uint16(20339),
		2:  uint16(20551),
		3:  uint16(20729),
		4:  uint16(21152),
		5:  uint16(21487),
		6:  uint16(21621),
		7:  uint16(21733),
		8:  uint16(22025),
		9:  uint16(23233),
		10: uint16(23478),
		11: uint16(26247),
		12: uint16(26550),
		13: uint16(26551),
		14: uint16(26607),
		15: uint16(27468),
		16: uint16(29634),
		17: uint16(30146),
		18: uint16(31292),
		19: uint16(33499),
		20: uint16(33540),
		21: uint16(34903),
		22: uint16(34952),
		23: uint16(35382),
		24: uint16(36040),
		25: uint16(36303),
		26: uint16(36603),
		27: uint16(36838),
		28: uint16(39381),
		29: uint16(21051),
		30: uint16(21364),
		31: uint16(21508),
		32: uint16(24682),
		33: uint16(24932),
		34: uint16(27580),
		35: uint16(29647),
		36: uint16(33050),
		37: uint16(35258),
		38: uint16(35282),
		39: uint16(38307),
		40: uint16(20355),
		41: uint16(21002),
		42: uint16(22718),
		43: uint16(22904),
		44: uint16(23014),
		45: uint16(24178),
		46: uint16(24185),
		47: uint16(25031),
		48: uint16(25536),
		49: uint16(26438),
		50: uint16(26604),
		51: uint16(26751),
		52: uint16(28567),
		53: uint16(30286),
		54: uint16(30475),
		55: uint16(30965),
		56: uint16(31240),
		57: uint16(31487),
		58: uint16(31777),
		59: uint16(32925),
		60: uint16(33390),
		61: uint16(33393),
		62: uint16(35563),
		63: uint16(38291),
		64: uint16(20075),
		65: uint16(21917),
		66: uint16(26359),
		67: uint16(28212),
		68: uint16(30883),
		69: uint16(31469),
		70: uint16(33883),
		71: uint16(35088),
		72: uint16(34638),
		73: uint16(38824),
		74: uint16(21208),
		75: uint16(22350),
		76: uint16(22570),
		77: uint16(23884),
		78: uint16(24863),
		79: uint16(25022),
		80: uint16(25121),
		81: uint16(25954),
		82: uint16(26577),
		83: uint16(27204),
		84: uint16(28187),
		85: uint16(29976),
		86: uint16(30131),
		87: uint16(30435),
		88: uint16(30640),
		89: uint16(32058),
		90: uint16(37039),
		91: uint16(37969),
		92: uint16(37970),
		93: uint16(40853),
	},
	42: {
		0:  uint16(21283),
		1:  uint16(23724),
		2:  uint16(30002),
		3:  uint16(32987),
		4:  uint16(37440),
		5:  uint16(38296),
		6:  uint16(21083),
		7:  uint16(22536),
		8:  uint16(23004),
		9:  uint16(23713),
		10: uint16(23831),
		11: uint16(24247),
		12: uint16(24378),
		13: uint16(24394),
		14: uint16(24951),
		15: uint16(27743),
		16: uint16(30074),
		17: uint16(30086),
		18: uint16(31968),
		19: uint16(32115),
		20: uint16(32177),
		21: uint16(32652),
		22: uint16(33108),
		23: uint16(33313),
		24: uint16(34193),
		25: uint16(35137),
		26: uint16(35611),
		27: uint16(37628),
		28: uint16(38477),
		29: uint16(40007),
		30: uint16(20171),
		31: uint16(20215),
		32: uint16(20491),
		33: uint16(20977),
		34: uint16(22607),
		35: uint16(24887),
		36: uint16(24894),
		37: uint16(24936),
		38: uint16(25913),
		39: uint16(27114),
		40: uint16(28433),
		41: uint16(30117),
		42: uint16(30342),
		43: uint16(30422),
		44: uint16(31623),
		45: uint16(33445),
		46: uint16(33995),
		47: uint16(63744),
		48: uint16(37799),
		49: uint16(38283),
		50: uint16(21888),
		51: uint16(23458),
		52: uint16(22353),
		53: uint16(63745),
		54: uint16(31923),
		55: uint16(32697),
		56: uint16(37301),
		57: uint16(20520),
		58: uint16(21435),
		59: uint16(23621),
		60: uint16(24040),
		61: uint16(25298),
		62: uint16(25454),
		63: uint16(25818),
		64: uint16(25831),
		65: uint16(28192),
		66: uint16(28844),
		67: uint16(31067),
		68: uint16(36317),
		69: uint16(36382),
		70: uint16(63746),
		71: uint16(36989),
		72: uint16(37445),
		73: uint16(37624),
		74: uint16(20094),
		75: uint16(20214),
		76: uint16(20581),
		77: uint16(24062),
		78: uint16(24314),
		79: uint16(24838),
		80: uint16(26967),
		81: uint16(33137),
		82: uint16(34388),
		83: uint16(36423),
		84: uint16(37749),
		85: uint16(39467),
		86: uint16(20062),
		87: uint16(20625),
		88: uint16(26480),
		89: uint16(26688),
		90: uint16(20745),
		91: uint16(21133),
		92: uint16(21138),
		93: uint16(27298),
	},
	43: {
		0:  uint16(30652),
		1:  uint16(37392),
		2:  uint16(40660),
		3:  uint16(21163),
		4:  uint16(24623),
		5:  uint16(36850),
		6:  uint16(20552),
		7:  uint16(25001),
		8:  uint16(25581),
		9:  uint16(25802),
		10: uint16(26684),
		11: uint16(27268),
		12: uint16(28608),
		13: uint16(33160),
		14: uint16(35233),
		15: uint16(38548),
		16: uint16(22533),
		17: uint16(29309),
		18: uint16(29356),
		19: uint16(29956),
		20: uint16(32121),
		21: uint16(32365),
		22: uint16(32937),
		23: uint16(35211),
		24: uint16(35700),
		25: uint16(36963),
		26: uint16(40273),
		27: uint16(25225),
		28: uint16(27770),
		29: uint16(28500),
		30: uint16(32080),
		31: uint16(32570),
		32: uint16(35363),
		33: uint16(20860),
		34: uint16(24906),
		35: uint16(31645),
		36: uint16(35609),
		37: uint16(37463),
		38: uint16(37772),
		39: uint16(20140),
		40: uint16(20435),
		41: uint16(20510),
		42: uint16(20670),
		43: uint16(20742),
		44: uint16(21185),
		45: uint16(21197),
		46: uint16(21375),
		47: uint16(22384),
		48: uint16(22659),
		49: uint16(24218),
		50: uint16(24465),
		51: uint16(24950),
		52: uint16(25004),
		53: uint16(25806),
		54: uint16(25964),
		55: uint16(26223),
		56: uint16(26299),
		57: uint16(26356),
		58: uint16(26775),
		59: uint16(28039),
		60: uint16(28805),
		61: uint16(28913),
		62: uint16(29855),
		63: uint16(29861),
		64: uint16(29898),
		65: uint16(30169),
		66: uint16(30828),
		67: uint16(30956),
		68: uint16(31455),
		69: uint16(31478),
		70: uint16(32069),
		71: uint16(32147),
		72: uint16(32789),
		73: uint16(32831),
		74: uint16(33051),
		75: uint16(33686),
		76: uint16(35686),
		77: uint16(36629),
		78: uint16(36885),
		79: uint16(37857),
		80: uint16(38915),
		81: uint16(38968),
		82: uint16(39514),
		83: uint16(39912),
		84: uint16(20418),
		85: uint16(21843),
		86: uint16(22586),
		87: uint16(22865),
		88: uint16(23395),
		89: uint16(23622),
		90: uint16(24760),
		91: uint16(25106),
		92: uint16(26690),
		93: uint16(26800),
	},
	44: {
		0:  uint16(26856),
		1:  uint16(28330),
		2:  uint16(30028),
		3:  uint16(30328),
		4:  uint16(30926),
		5:  uint16(31293),
		6:  uint16(31995),
		7:  uint16(32363),
		8:  uint16(32380),
		9:  uint16(35336),
		10: uint16(35489),
		11: uint16(35903),
		12: uint16(38542),
		13: uint16(40388),
		14: uint16(21476),
		15: uint16(21481),
		16: uint16(21578),
		17: uint16(21617),
		18: uint16(22266),
		19: uint16(22993),
		20: uint16(23396),
		21: uint16(23611),
		22: uint16(24235),
		23: uint16(25335),
		24: uint16(25911),
		25: uint16(25925),
		26: uint16(25970),
		27: uint16(26272),
		28: uint16(26543),
		29: uint16(27073),
		30: uint16(27837),
		31: uint16(30204),
		32: uint16(30352),
		33: uint16(30590),
		34: uint16(31295),
		35: uint16(32660),
		36: uint16(32771),
		37: uint16(32929),
		38: uint16(33167),
		39: uint16(33510),
		40: uint16(33533),
		41: uint16(33776),
		42: uint16(34241),
		43: uint16(34865),
		44: uint16(34996),
		45: uint16(35493),
		46: uint16(63747),
		47: uint16(36764),
		48: uint16(37678),
		49: uint16(38599),
		50: uint16(39015),
		51: uint16(39640),
		52: uint16(40723),
		53: uint16(21741),
		54: uint16(26011),
		55: uint16(26354),
		56: uint16(26767),
		57: uint16(31296),
		58: uint16(35895),
		59: uint16(40288),
		60: uint16(22256),
		61: uint16(22372),
		62: uint16(23825),
		63: uint16(26118),
		64: uint16(26801),
		65: uint16(26829),
		66: uint16(28414),
		67: uint16(29736),
		68: uint16(34974),
		69: uint16(39908),
		70: uint16(27752),
		71: uint16(63748),
		72: uint16(39592),
		73: uint16(20379),
		74: uint16(20844),
		75: uint16(20849),
		76: uint16(21151),
		77: uint16(23380),
		78: uint16(24037),
		79: uint16(24656),
		80: uint16(24685),
		81: uint16(25329),
		82: uint16(25511),
		83: uint16(25915),
		84: uint16(29657),
		85: uint16(31354),
		86: uint16(34467),
		87: uint16(36002),
		88: uint16(38799),
		89: uint16(20018),
		90: uint16(23521),
		91: uint16(25096),
		92: uint16(26524),
		93: uint16(29916),
	},
	45: {
		0:  uint16(31185),
		1:  uint16(33747),
		2:  uint16(35463),
		3:  uint16(35506),
		4:  uint16(36328),
		5:  uint16(36942),
		6:  uint16(37707),
		7:  uint16(38982),
		8:  uint16(24275),
		9:  uint16(27112),
		10: uint16(34303),
		11: uint16(37101),
		12: uint16(63749),
		13: uint16(20896),
		14: uint16(23448),
		15: uint16(23532),
		16: uint16(24931),
		17: uint16(26874),
		18: uint16(27454),
		19: uint16(28748),
		20: uint16(29743),
		21: uint16(29912),
		22: uint16(31649),
		23: uint16(32592),
		24: uint16(33733),
		25: uint16(35264),
		26: uint16(36011),
		27: uint16(38364),
		28: uint16(39208),
		29: uint16(21038),
		30: uint16(24669),
		31: uint16(25324),
		32: uint16(36866),
		33: uint16(20362),
		34: uint16(20809),
		35: uint16(21281),
		36: uint16(22745),
		37: uint16(24291),
		38: uint16(26336),
		39: uint16(27960),
		40: uint16(28826),
		41: uint16(29378),
		42: uint16(29654),
		43: uint16(31568),
		44: uint16(33009),
		45: uint16(37979),
		46: uint16(21350),
		47: uint16(25499),
		48: uint16(32619),
		49: uint16(20054),
		50: uint16(20608),
		51: uint16(22602),
		52: uint16(22750),
		53: uint16(24618),
		54: uint16(24871),
		55: uint16(25296),
		56: uint16(27088),
		57: uint16(39745),
		58: uint16(23439),
		59: uint16(32024),
		60: uint16(32945),
		61: uint16(36703),
		62: uint16(20132),
		63: uint16(20689),
		64: uint16(21676),
		65: uint16(21932),
		66: uint16(23308),
		67: uint16(23968),
		68: uint16(24039),
		69: uint16(25898),
		70: uint16(25934),
		71: uint16(26657),
		72: uint16(27211),
		73: uint16(29409),
		74: uint16(30350),
		75: uint16(30703),
		76: uint16(32094),
		77: uint16(32761),
		78: uint16(33184),
		79: uint16(34126),
		80: uint16(34527),
		81: uint16(36611),
		82: uint16(36686),
		83: uint16(37066),
		84: uint16(39171),
		85: uint16(39509),
		86: uint16(39851),
		87: uint16(19992),
		88: uint16(20037),
		89: uint16(20061),
		90: uint16(20167),
		91: uint16(20465),
		92: uint16(20855),
		93: uint16(21246),
	},
	46: {
		0:  uint16(21312),
		1:  uint16(21475),
		2:  uint16(21477),
		3:  uint16(21646),
		4:  uint16(22036),
		5:  uint16(22389),
		6:  uint16(22434),
		7:  uint16(23495),
		8:  uint16(23943),
		9:  uint16(24272),
		10: uint16(25084),
		11: uint16(25304),
		12: uint16(25937),
		13: uint16(26552),
		14: uint16(26601),
		15: uint16(27083),
		16: uint16(27472),
		17: uint16(27590),
		18: uint16(27628),
		19: uint16(27714),
		20: uint16(28317),
		21: uint16(28792),
		22: uint16(29399),
		23: uint16(29590),
		24: uint16(29699),
		25: uint16(30655),
		26: uint16(30697),
		27: uint16(31350),
		28: uint16(32127),
		29: uint16(32777),
		30: uint16(33276),
		31: uint16(33285),
		32: uint16(33290),
		33: uint16(33503),
		34: uint16(34914),
		35: uint16(35635),
		36: uint16(36092),
		37: uint16(36544),
		38: uint16(36881),
		39: uint16(37041),
		40: uint16(37476),
		41: uint16(37558),
		42: uint16(39378),
		43: uint16(39493),
		44: uint16(40169),
		45: uint16(40407),
		46: uint16(40860),
		47: uint16(22283),
		48: uint16(23616),
		49: uint16(33738),
		50: uint16(38816),
		51: uint16(38827),
		52: uint16(40628),
		53: uint16(21531),
		54: uint16(31384),
		55: uint16(32676),
		56: uint16(35033),
		57: uint16(36557),
		58: uint16(37089),
		59: uint16(22528),
		60: uint16(23624),
		61: uint16(25496),
		62: uint16(31391),
		63: uint16(23470),
		64: uint16(24339),
		65: uint16(31353),
		66: uint16(31406),
		67: uint16(33422),
		68: uint16(36524),
		69: uint16(20518),
		70: uint16(21048),
		71: uint16(21240),
		72: uint16(21367),
		73: uint16(22280),
		74: uint16(25331),
		75: uint16(25458),
		76: uint16(27402),
		77: uint16(28099),
		78: uint16(30519),
		79: uint16(21413),
		80: uint16(29527),
		81: uint16(34152),
		82: uint16(36470),
		83: uint16(38357),
		84: uint16(26426),
		85: uint16(27331),
		86: uint16(28528),
		87: uint16(35437),
		88: uint16(36556),
		89: uint16(39243),
		90: uint16(63750),
		91: uint16(26231),
		92: uint16(27512),
		93: uint16(36020),
	},
	47: {
		0:  uint16(39740),
		1:  uint16(63751),
		2:  uint16(21483),
		3:  uint16(22317),
		4:  uint16(22862),
		5:  uint16(25542),
		6:  uint16(27131),
		7:  uint16(29674),
		8:  uint16(30789),
		9:  uint16(31418),
		10: uint16(31429),
		11: uint16(31998),
		12: uint16(33909),
		13: uint16(35215),
		14: uint16(36211),
		15: uint16(36917),
		16: uint16(38312),
		17: uint16(21243),
		18: uint16(22343),
		19: uint16(30023),
		20: uint16(31584),
		21: uint16(33740),
		22: uint16(37406),
		23: uint16(63752),
		24: uint16(27224),
		25: uint16(20811),
		26: uint16(21067),
		27: uint16(21127),
		28: uint16(25119),
		29: uint16(26840),
		30: uint16(26997),
		31: uint16(38553),
		32: uint16(20677),
		33: uint16(21156),
		34: uint16(21220),
		35: uint16(25027),
		36: uint16(26020),
		37: uint16(26681),
		38: uint16(27135),
		39: uint16(29822),
		40: uint16(31563),
		41: uint16(33465),
		42: uint16(33771),
		43: uint16(35250),
		44: uint16(35641),
		45: uint16(36817),
		46: uint16(39241),
		47: uint16(63753),
		48: uint16(20170),
		49: uint16(22935),
		50: uint16(25810),
		51: uint16(26129),
		52: uint16(27278),
		53: uint16(29748),
		54: uint16(31105),
		55: uint16(31165),
		56: uint16(33449),
		57: uint16(34942),
		58: uint16(34943),
		59: uint16(35167),
		60: uint16(63754),
		61: uint16(37670),
		62: uint16(20235),
		63: uint16(21450),
		64: uint16(24613),
		65: uint16(25201),
		66: uint16(27762),
		67: uint16(32026),
		68: uint16(32102),
		69: uint16(20120),
		70: uint16(20834),
		71: uint16(30684),
		72: uint16(32943),
		73: uint16(20225),
		74: uint16(20238),
		75: uint16(20854),
		76: uint16(20864),
		77: uint16(21980),
		78: uint16(22120),
		79: uint16(22331),
		80: uint16(22522),
		81: uint16(22524),
		82: uint16(22804),
		83: uint16(22855),
		84: uint16(22931),
		85: uint16(23492),
		86: uint16(23696),
		87: uint16(23822),
		88: uint16(24049),
		89: uint16(24190),
		90: uint16(24524),
		91: uint16(25216),
		92: uint16(26071),
		93: uint16(26083),
	},
	48: {
		0:  uint16(26398),
		1:  uint16(26399),
		2:  uint16(26462),
		3:  uint16(26827),
		4:  uint16(26820),
		5:  uint16(27231),
		6:  uint16(27450),
		7:  uint16(27683),
		8:  uint16(27773),
		9:  uint16(27778),
		10: uint16(28103),
		11: uint16(29592),
		12: uint16(29734),
		13: uint16(29738),
		14: uint16(29826),
		15: uint16(29859),
		16: uint16(30072),
		17: uint16(30079),
		18: uint16(30849),
		19: uint16(30959),
		20: uint16(31041),
		21: uint16(31047),
		22: uint16(31048),
		23: uint16(31098),
		24: uint16(31637),
		25: uint16(32000),
		26: uint16(32186),
		27: uint16(32648),
		28: uint16(32774),
		29: uint16(32813),
		30: uint16(32908),
		31: uint16(35352),
		32: uint16(35663),
		33: uint16(35912),
		34: uint16(36215),
		35: uint16(37665),
		36: uint16(37668),
		37: uint16(39138),
		38: uint16(39249),
		39: uint16(39438),
		40: uint16(39439),
		41: uint16(39525),
		42: uint16(40594),
		43: uint16(32202),
		44: uint16(20342),
		45: uint16(21513),
		46: uint16(25326),
		47: uint16(26708),
		48: uint16(37329),
		49: uint16(21931),
		50: uint16(20794),
		51: uint16(63755),
		52: uint16(63756),
		53: uint16(23068),
		54: uint16(25062),
		55: uint16(63757),
		56: uint16(25295),
		57: uint16(25343),
		58: uint16(63758),
		59: uint16(63759),
		60: uint16(63760),
		61: uint16(63761),
		62: uint16(63762),
		63: uint16(63763),
		64: uint16(37027),
		65: uint16(63764),
		66: uint16(63765),
		67: uint16(63766),
		68: uint16(63767),
		69: uint16(63768),
		70: uint16(35582),
		71: uint16(63769),
		72: uint16(63770),
		73: uint16(63771),
		74: uint16(63772),
		75: uint16(26262),
		76: uint16(63773),
		77: uint16(29014),
		78: uint16(63774),
		79: uint16(63775),
		80: uint16(38627),
		81: uint16(63776),
		82: uint16(25423),
		83: uint16(25466),
		84: uint16(21335),
		85: uint16(63777),
		86: uint16(26511),
		87: uint16(26976),
		88: uint16(28275),
		89: uint16(63778),
		90: uint16(30007),
		91: uint16(63779),
		92: uint16(63780),
		93: uint16(63781),
	},
	49: {
		0:  uint16(32013),
		1:  uint16(63782),
		2:  uint16(63783),
		3:  uint16(34930),
		4:  uint16(22218),
		5:  uint16(23064),
		6:  uint16(63784),
		7:  uint16(63785),
		8:  uint16(63786),
		9:  uint16(63787),
		10: uint16(63788),
		11: uint16(20035),
		12: uint16(63789),
		13: uint16(20839),
		14: uint16(22856),
		15: uint16(26608),
		16: uint16(32784),
		17: uint16(63790),
		18: uint16(22899),
		19: uint16(24180),
		20: uint16(25754),
		21: uint16(31178),
		22: uint16(24565),
		23: uint16(24684),
		24: uint16(25288),
		25: uint16(25467),
		26: uint16(23527),
		27: uint16(23511),
		28: uint16(21162),
		29: uint16(63791),
		30: uint16(22900),
		31: uint16(24361),
		32: uint16(24594),
		33: uint16(63792),
		34: uint16(63793),
		35: uint16(63794),
		36: uint16(29785),
		37: uint16(63795),
		38: uint16(63796),
		39: uint16(63797),
		40: uint16(63798),
		41: uint16(63799),
		42: uint16(63800),
		43: uint16(39377),
		44: uint16(63801),
		45: uint16(63802),
		46: uint16(63803),
		47: uint16(63804),
		48: uint16(63805),
		49: uint16(63806),
		50: uint16(63807),
		51: uint16(63808),
		52: uint16(63809),
		53: uint16(63810),
		54: uint16(63811),
		55: uint16(28611),
		56: uint16(63812),
		57: uint16(63813),
		58: uint16(33215),
		59: uint16(36786),
		60: uint16(24817),
		61: uint16(63814),
		62: uint16(63815),
		63: uint16(33126),
		64: uint16(63816),
		65: uint16(63817),
		66: uint16(23615),
		67: uint16(63818),
		68: uint16(63819),
		69: uint16(63820),
		70: uint16(63821),
		71: uint16(63822),
		72: uint16(63823),
		73: uint16(63824),
		74: uint16(63825),
		75: uint16(23273),
		76: uint16(35365),
		77: uint16(26491),
		78: uint16(32016),
		79: uint16(63826),
		80: uint16(63827),
		81: uint16(63828),
		82: uint16(63829),
		83: uint16(63830),
		84: uint16(63831),
		85: uint16(33021),
		86: uint16(63832),
		87: uint16(63833),
		88: uint16(23612),
		89: uint16(27877),
		90: uint16(21311),
		91: uint16(28346),
		92: uint16(22810),
		93: uint16(33590),
	},
	50: {
		0:  uint16(20025),
		1:  uint16(20150),
		2:  uint16(20294),
		3:  uint16(21934),
		4:  uint16(22296),
		5:  uint16(22727),
		6:  uint16(24406),
		7:  uint16(26039),
		8:  uint16(26086),
		9:  uint16(27264),
		10: uint16(27573),
		11: uint16(28237),
		12: uint16(30701),
		13: uint16(31471),
		14: uint16(31774),
		15: uint16(32222),
		16: uint16(34507),
		17: uint16(34962),
		18: uint16(37170),
		19: uint16(37723),
		20: uint16(25787),
		21: uint16(28606),
		22: uint16(29562),
		23: uint16(30136),
		24: uint16(36948),
		25: uint16(21846),
		26: uint16(22349),
		27: uint16(25018),
		28: uint16(25812),
		29: uint16(26311),
		30: uint16(28129),
		31: uint16(28251),
		32: uint16(28525),
		33: uint16(28601),
		34: uint16(30192),
		35: uint16(32835),
		36: uint16(33213),
		37: uint16(34113),
		38: uint16(35203),
		39: uint16(35527),
		40: uint16(35674),
		41: uint16(37663),
		42: uint16(27795),
		43: uint16(30035),
		44: uint16(31572),
		45: uint16(36367),
		46: uint16(36957),
		47: uint16(21776),
		48: uint16(22530),
		49: uint16(22616),
		50: uint16(24162),
		51: uint16(25095),
		52: uint16(25758),
		53: uint16(26848),
		54: uint16(30070),
		55: uint16(31958),
		56: uint16(34739),
		57: uint16(40680),
		58: uint16(20195),
		59: uint16(22408),
		60: uint16(22382),
		61: uint16(22823),
		62: uint16(23565),
		63: uint16(23729),
		64: uint16(24118),
		65: uint16(24453),
		66: uint16(25140),
		67: uint16(25825),
		68: uint16(29619),
		69: uint16(33274),
		70: uint16(34955),
		71: uint16(36024),
		72: uint16(38538),
		73: uint16(40667),
		74: uint16(23429),
		75: uint16(24503),
		76: uint16(24755),
		77: uint16(20498),
		78: uint16(20992),
		79: uint16(21040),
		80: uint16(22294),
		81: uint16(22581),
		82: uint16(22615),
		83: uint16(23566),
		84: uint16(23648),
		85: uint16(23798),
		86: uint16(23947),
		87: uint16(24230),
		88: uint16(24466),
		89: uint16(24764),
		90: uint16(25361),
		91: uint16(25481),
		92: uint16(25623),
		93: uint16(26691),
	},
	51: {
		0:  uint16(26873),
		1:  uint16(27330),
		2:  uint16(28120),
		3:  uint16(28193),
		4:  uint16(28372),
		5:  uint16(28644),
		6:  uint16(29182),
		7:  uint16(30428),
		8:  uint16(30585),
		9:  uint16(31153),
		10: uint16(31291),
		11: uint16(33796),
		12: uint16(35241),
		13: uint16(36077),
		14: uint16(36339),
		15: uint16(36424),
		16: uint16(36867),
		17: uint16(36884),
		18: uint16(36947),
		19: uint16(37117),
		20: uint16(37709),
		21: uint16(38518),
		22: uint16(38876),
		23: uint16(27602),
		24: uint16(28678),
		25: uint16(29272),
		26: uint16(29346),
		27: uint16(29544),
		28: uint16(30563),
		29: uint16(31167),
		30: uint16(31716),
		31: uint16(32411),
		32: uint16(35712),
		33: uint16(22697),
		34: uint16(24775),
		35: uint16(25958),
		36: uint16(26109),
		37: uint16(26302),
		38: uint16(27788),
		39: uint16(28958),
		40: uint16(29129),
		41: uint16(35930),
		42: uint16(38931),
		43: uint16(20077),
		44: uint16(31361),
		45: uint16(20189),
		46: uint16(20908),
		47: uint16(20941),
		48: uint16(21205),
		49: uint16(21516),
		50: uint16(24999),
		51: uint16(26481),
		52: uint16(26704),
		53: uint16(26847),
		54: uint16(27934),
		55: uint16(28540),
		56: uint16(30140),
		57: uint16(30643),
		58: uint16(31461),
		59: uint16(33012),
		60: uint16(33891),
		61: uint16(37509),
		62: uint16(20828),
		63: uint16(26007),
		64: uint16(26460),
		65: uint16(26515),
		66: uint16(30168),
		67: uint16(31431),
		68: uint16(33651),
		69: uint16(63834),
		70: uint16(35910),
		71: uint16(36887),
		72: uint16(38957),
		73: uint16(23663),
		74: uint16(33216),
		75: uint16(33434),
		76: uint16(36929),
		77: uint16(36975),
		78: uint16(37389),
		79: uint16(24471),
		80: uint16(23965),
		81: uint16(27225),
		82: uint16(29128),
		83: uint16(30331),
		84: uint16(31561),
		85: uint16(34276),
		86: uint16(35588),
		87: uint16(37159),
		88: uint16(39472),
		89: uint16(21895),
		90: uint16(25078),
		91: uint16(63835),
		92: uint16(30313),
		93: uint16(32645),
	},
	52: {
		0:  uint16(34367),
		1:  uint16(34746),
		2:  uint16(35064),
		3:  uint16(37007),
		4:  uint16(63836),
		5:  uint16(27931),
		6:  uint16(28889),
		7:  uint16(29662),
		8:  uint16(32097),
		9:  uint16(33853),
		10: uint16(63837),
		11: uint16(37226),
		12: uint16(39409),
		13: uint16(63838),
		14: uint16(20098),
		15: uint16(21365),
		16: uint16(27396),
		17: uint16(27410),
		18: uint16(28734),
		19: uint16(29211),
		20: uint16(34349),
		21: uint16(40478),
		22: uint16(21068),
		23: uint16(36771),
		24: uint16(23888),
		25: uint16(25829),
		26: uint16(25900),
		27: uint16(27414),
		28: uint16(28651),
		29: uint16(31811),
		30: uint16(32412),
		31: uint16(34253),
		32: uint16(35172),
		33: uint16(35261),
		34: uint16(25289),
		35: uint16(33240),
		36: uint16(34847),
		37: uint16(24266),
		38: uint16(26391),
		39: uint16(28010),
		40: uint16(29436),
		41: uint16(29701),
		42: uint16(29807),
		43: uint16(34690),
		44: uint16(37086),
		45: uint16(20358),
		46: uint16(23821),
		47: uint16(24480),
		48: uint16(33802),
		49: uint16(20919),
		50: uint16(25504),
		51: uint16(30053),
		52: uint16(20142),
		53: uint16(20486),
		54: uint16(20841),
		55: uint16(20937),
		56: uint16(26753),
		57: uint16(27153),
		58: uint16(31918),
		59: uint16(31921),
		60: uint16(31975),
		61: uint16(33391),
		62: uint16(35538),
		63: uint16(36635),
		64: uint16(37327),
		65: uint16(20406),
		66: uint16(20791),
		67: uint16(21237),
		68: uint16(21570),
		69: uint16(24300),
		70: uint16(24942),
		71: uint16(25150),
		72: uint16(26053),
		73: uint16(27354),
		74: uint16(28670),
		75: uint16(31018),
		76: uint16(34268),
		77: uint16(34851),
		78: uint16(38317),
		79: uint16(39522),
		80: uint16(39530),
		81: uint16(40599),
		82: uint16(40654),
		83: uint16(21147),
		84: uint16(26310),
		85: uint16(27511),
		86: uint16(28701),
		87: uint16(31019),
		88: uint16(36706),
		89: uint16(38722),
		90: uint16(24976),
		91: uint16(25088),
		92: uint16(25891),
		93: uint16(28451),
	},
	53: {
		0:  uint16(29001),
		1:  uint16(29833),
		2:  uint16(32244),
		3:  uint16(32879),
		4:  uint16(34030),
		5:  uint16(36646),
		6:  uint16(36899),
		7:  uint16(37706),
		8:  uint16(20925),
		9:  uint16(21015),
		10: uint16(21155),
		11: uint16(27916),
		12: uint16(28872),
		13: uint16(35010),
		14: uint16(24265),
		15: uint16(25986),
		16: uint16(27566),
		17: uint16(28610),
		18: uint16(31806),
		19: uint16(29557),
		20: uint16(20196),
		21: uint16(20278),
		22: uint16(22265),
		23: uint16(63839),
		24: uint16(23738),
		25: uint16(23994),
		26: uint16(24604),
		27: uint16(29618),
		28: uint16(31533),
		29: uint16(32666),
		30: uint16(32718),
		31: uint16(32838),
		32: uint16(36894),
		33: uint16(37428),
		34: uint16(38646),
		35: uint16(38728),
		36: uint16(38936),
		37: uint16(40801),
		38: uint16(20363),
		39: uint16(28583),
		40: uint16(31150),
		41: uint16(37300),
		42: uint16(38583),
		43: uint16(21214),
		44: uint16(63840),
		45: uint16(25736),
		46: uint16(25796),
		47: uint16(27347),
		48: uint16(28510),
		49: uint16(28696),
		50: uint16(29200),
		51: uint16(30439),
		52: uint16(32769),
		53: uint16(34310),
		54: uint16(34396),
		55: uint16(36335),
		56: uint16(36613),
		57: uint16(38706),
		58: uint16(39791),
		59: uint16(40442),
		60: uint16(40565),
		61: uint16(30860),
		62: uint16(31103),
		63: uint16(32160),
		64: uint16(33737),
		65: uint16(37636),
		66: uint16(40575),
		67: uint16(40595),
		68: uint16(35542),
		69: uint16(22751),
		70: uint16(24324),
		71: uint16(26407),
		72: uint16(28711),
		73: uint16(29903),
		74: uint16(31840),
		75: uint16(32894),
		76: uint16(20769),
		77: uint16(28712),
		78: uint16(29282),
		79: uint16(30922),
		80: uint16(36034),
		81: uint16(36058),
		82: uint16(36084),
		83: uint16(38647),
		84: uint16(20102),
		85: uint16(20698),
		86: uint16(23534),
		87: uint16(24278),
		88: uint16(26009),
		89: uint16(29134),
		90: uint16(30274),
		91: uint16(30637),
		92: uint16(32842),
		93: uint16(34044),
	},
	54: {
		0:  uint16(36988),
		1:  uint16(39719),
		2:  uint16(40845),
		3:  uint16(22744),
		4:  uint16(23105),
		5:  uint16(23650),
		6:  uint16(27155),
		7:  uint16(28122),
		8:  uint16(28431),
		9:  uint16(30267),
		10: uint16(32047),
		11: uint16(32311),
		12: uint16(34078),
		13: uint16(35128),
		14: uint16(37860),
		15: uint16(38475),
		16: uint16(21129),
		17: uint16(26066),
		18: uint16(26611),
		19: uint16(27060),
		20: uint16(27969),
		21: uint16(28316),
		22: uint16(28687),
		23: uint16(29705),
		24: uint16(29792),
		25: uint16(30041),
		26: uint16(30244),
		27: uint16(30827),
		28: uint16(35628),
		29: uint16(39006),
		30: uint16(20845),
		31: uint16(25134),
		32: uint16(38520),
		33: uint16(20374),
		34: uint16(20523),
		35: uint16(23833),
		36: uint16(28138),
		37: uint16(32184),
		38: uint16(36650),
		39: uint16(24459),
		40: uint16(24900),
		41: uint16(26647),
		42: uint16(63841),
		43: uint16(38534),
		44: uint16(21202),
		45: uint16(32907),
		46: uint16(20956),
		47: uint16(20940),
		48: uint16(26974),
		49: uint16(31260),
		50: uint16(32190),
		51: uint16(33777),
		52: uint16(38517),
		53: uint16(20442),
		54: uint16(21033),
		55: uint16(21400),
		56: uint16(21519),
		57: uint16(21774),
		58: uint16(23653),
		59: uint16(24743),
		60: uint16(26446),
		61: uint16(26792),
		62: uint16(28012),
		63: uint16(29313),
		64: uint16(29432),
		65: uint16(29702),
		66: uint16(29827),
		67: uint16(63842),
		68: uint16(30178),
		69: uint16(31852),
		70: uint16(32633),
		71: uint16(32696),
		72: uint16(33673),
		73: uint16(35023),
		74: uint16(35041),
		75: uint16(37324),
		76: uint16(37328),
		77: uint16(38626),
		78: uint16(39881),
		79: uint16(21533),
		80: uint16(28542),
		81: uint16(29136),
		82: uint16(29848),
		83: uint16(34298),
		84: uint16(36522),
		85: uint16(38563),
		86: uint16(40023),
		87: uint16(40607),
		88: uint16(26519),
		89: uint16(28107),
		90: uint16(29747),
		91: uint16(33256),
		92: uint16(38678),
		93: uint16(30764),
	},
	55: {
		0:  uint16(31435),
		1:  uint16(31520),
		2:  uint16(31890),
		3:  uint16(25705),
		4:  uint16(29802),
		5:  uint16(30194),
		6:  uint16(30908),
		7:  uint16(30952),
		8:  uint16(39340),
		9:  uint16(39764),
		10: uint16(40635),
		11: uint16(23518),
		12: uint16(24149),
		13: uint16(28448),
		14: uint16(33180),
		15: uint16(33707),
		16: uint16(37000),
		17: uint16(19975),
		18: uint16(21325),
		19: uint16(23081),
		20: uint16(24018),
		21: uint16(24398),
		22: uint16(24930),
		23: uint16(25405),
		24: uint16(26217),
		25: uint16(26364),
		26: uint16(28415),
		27: uint16(28459),
		28: uint16(28771),
		29: uint16(30622),
		30: uint16(33836),
		31: uint16(34067),
		32: uint16(34875),
		33: uint16(36627),
		34: uint16(39237),
		35: uint16(39995),
		36: uint16(21788),
		37: uint16(25273),
		38: uint16(26411),
		39: uint16(27819),
		40: uint16(33545),
		41: uint16(35178),
		42: uint16(38778),
		43: uint16(20129),
		44: uint16(22916),
		45: uint16(24536),
		46: uint16(24537),
		47: uint16(26395),
		48: uint16(32178),
		49: uint16(32596),
		50: uint16(33426),
		51: uint16(33579),
		52: uint16(33725),
		53: uint16(36638),
		54: uint16(37017),
		55: uint16(22475),
		56: uint16(22969),
		57: uint16(23186),
		58: uint16(23504),
		59: uint16(26151),
		60: uint16(26522),
		61: uint16(26757),
		62: uint16(27599),
		63: uint16(29028),
		64: uint16(32629),
		65: uint16(36023),
		66: uint16(36067),
		67: uint16(36993),
		68: uint16(39749),
		69: uint16(33032),
		70: uint16(35978),
		71: uint16(38476),
		72: uint16(39488),
		73: uint16(40613),
		74: uint16(23391),
		75: uint16(27667),
		76: uint16(29467),
		77: uint16(30450),
		78: uint16(30431),
		79: uint16(33804),
		80: uint16(20906),
		81: uint16(35219),
		82: uint16(20813),
		83: uint16(20885),
		84: uint16(21193),
		85: uint16(26825),
		86: uint16(27796),
		87: uint16(30468),
		88: uint16(30496),
		89: uint16(32191),
		90: uint16(32236),
		91: uint16(38754),
		92: uint16(40629),
		93: uint16(28357),
	},
	56: {
		0:  uint16(34065),
		1:  uint16(20901),
		2:  uint16(21517),
		3:  uint16(21629),
		4:  uint16(26126),
		5:  uint16(26269),
		6:  uint16(26919),
		7:  uint16(28319),
		8:  uint16(30399),
		9:  uint16(30609),
		10: uint16(33559),
		11: uint16(33986),
		12: uint16(34719),
		13: uint16(37225),
		14: uint16(37528),
		15: uint16(40180),
		16: uint16(34946),
		17: uint16(20398),
		18: uint16(20882),
		19: uint16(21215),
		20: uint16(22982),
		21: uint16(24125),
		22: uint16(24917),
		23: uint16(25720),
		24: uint16(25721),
		25: uint16(26286),
		26: uint16(26576),
		27: uint16(27169),
		28: uint16(27597),
		29: uint16(27611),
		30: uint16(29279),
		31: uint16(29281),
		32: uint16(29761),
		33: uint16(30520),
		34: uint16(30683),
		35: uint16(32791),
		36: uint16(33468),
		37: uint16(33541),
		38: uint16(35584),
		39: uint16(35624),
		40: uint16(35980),
		41: uint16(26408),
		42: uint16(27792),
		43: uint16(29287),
		44: uint16(30446),
		45: uint16(30566),
		46: uint16(31302),
		47: uint16(40361),
		48: uint16(27519),
		49: uint16(27794),
		50: uint16(22818),
		51: uint16(26406),
		52: uint16(33945),
		53: uint16(21359),
		54: uint16(22675),
		55: uint16(22937),
		56: uint16(24287),
		57: uint16(25551),
		58: uint16(26164),
		59: uint16(26483),
		60: uint16(28218),
		61: uint16(29483),
		62: uint16(31447),
		63: uint16(33495),
		64: uint16(37672),
		65: uint16(21209),
		66: uint16(24043),
		67: uint16(25006),
		68: uint16(25035),
		69: uint16(25098),
		70: uint16(25287),
		71: uint16(25771),
		72: uint16(26080),
		73: uint16(26969),
		74: uint16(27494),
		75: uint16(27595),
		76: uint16(28961),
		77: uint16(29687),
		78: uint16(30045),
		79: uint16(32326),
		80: uint16(33310),
		81: uint16(33538),
		82: uint16(34154),
		83: uint16(35491),
		84: uint16(36031),
		85: uint16(38695),
		86: uint16(40289),
		87: uint16(22696),
		88: uint16(40664),
		89: uint16(20497),
		90: uint16(21006),
		91: uint16(21563),
		92: uint16(21839),
		93: uint16(25991),
	},
	57: {
		0:  uint16(27766),
		1:  uint16(32010),
		2:  uint16(32011),
		3:  uint16(32862),
		4:  uint16(34442),
		5:  uint16(38272),
		6:  uint16(38639),
		7:  uint16(21247),
		8:  uint16(27797),
		9:  uint16(29289),
		10: uint16(21619),
		11: uint16(23194),
		12: uint16(23614),
		13: uint16(23883),
		14: uint16(24396),
		15: uint16(24494),
		16: uint16(26410),
		17: uint16(26806),
		18: uint16(26979),
		19: uint16(28220),
		20: uint16(28228),
		21: uint16(30473),
		22: uint16(31859),
		23: uint16(32654),
		24: uint16(34183),
		25: uint16(35598),
		26: uint16(36855),
		27: uint16(38753),
		28: uint16(40692),
		29: uint16(23735),
		30: uint16(24758),
		31: uint16(24845),
		32: uint16(25003),
		33: uint16(25935),
		34: uint16(26107),
		35: uint16(26108),
		36: uint16(27665),
		37: uint16(27887),
		38: uint16(29599),
		39: uint16(29641),
		40: uint16(32225),
		41: uint16(38292),
		42: uint16(23494),
		43: uint16(34588),
		44: uint16(35600),
		45: uint16(21085),
		46: uint16(21338),
		47: uint16(25293),
		48: uint16(25615),
		49: uint16(25778),
		50: uint16(26420),
		51: uint16(27192),
		52: uint16(27850),
		53: uint16(29632),
		54: uint16(29854),
		55: uint16(31636),
		56: uint16(31893),
		57: uint16(32283),
		58: uint16(33162),
		59: uint16(33334),
		60: uint16(34180),
		61: uint16(36843),
		62: uint16(38649),
		63: uint16(39361),
		64: uint16(20276),
		65: uint16(21322),
		66: uint16(21453),
		67: uint16(21467),
		68: uint16(25292),
		69: uint16(25644),
		70: uint16(25856),
		71: uint16(26001),
		72: uint16(27075),
		73: uint16(27886),
		74: uint16(28504),
		75: uint16(29677),
		76: uint16(30036),
		77: uint16(30242),
		78: uint16(30436),
		79: uint16(30460),
		80: uint16(30928),
		81: uint16(30971),
		82: uint16(31020),
		83: uint16(32070),
		84: uint16(33324),
		85: uint16(34784),
		86: uint16(36820),
		87: uint16(38930),
		88: uint16(39151),
		89: uint16(21187),
		90: uint16(25300),
		91: uint16(25765),
		92: uint16(28196),
		93: uint16(28497),
	},
	58: {
		0:  uint16(30332),
		1:  uint16(36299),
		2:  uint16(37297),
		3:  uint16(37474),
		4:  uint16(39662),
		5:  uint16(39747),
		6:  uint16(20515),
		7:  uint16(20621),
		8:  uint16(22346),
		9:  uint16(22952),
		10: uint16(23592),
		11: uint16(24135),
		12: uint16(24439),
		13: uint16(25151),
		14: uint16(25918),
		15: uint16(26041),
		16: uint16(26049),
		17: uint16(26121),
		18: uint16(26507),
		19: uint16(27036),
		20: uint16(28354),
		21: uint16(30917),
		22: uint16(32033),
		23: uint16(32938),
		24: uint16(33152),
		25: uint16(33323),
		26: uint16(33459),
		27: uint16(33953),
		28: uint16(34444),
		29: uint16(35370),
		30: uint16(35607),
		31: uint16(37030),
		32: uint16(38450),
		33: uint16(40848),
		34: uint16(20493),
		35: uint16(20467),
		36: uint16(63843),
		37: uint16(22521),
		38: uint16(24472),
		39: uint16(25308),
		40: uint16(25490),
		41: uint16(26479),
		42: uint16(28227),
		43: uint16(28953),
		44: uint16(30403),
		45: uint16(32972),
		46: uint16(32986),
		47: uint16(35060),
		48: uint16(35061),
		49: uint16(35097),
		50: uint16(36064),
		51: uint16(36649),
		52: uint16(37197),
		53: uint16(38506),
		54: uint16(20271),
		55: uint16(20336),
		56: uint16(24091),
		57: uint16(26575),
		58: uint16(26658),
		59: uint16(30333),
		60: uint16(30334),
		61: uint16(39748),
		62: uint16(24161),
		63: uint16(27146),
		64: uint16(29033),
		65: uint16(29140),
		66: uint16(30058),
		67: uint16(63844),
		68: uint16(32321),
		69: uint16(34115),
		70: uint16(34281),
		71: uint16(39132),
		72: uint16(20240),
		73: uint16(31567),
		74: uint16(32624),
		75: uint16(38309),
		76: uint16(20961),
		77: uint16(24070),
		78: uint16(26805),
		79: uint16(27710),
		80: uint16(27726),
		81: uint16(27867),
		82: uint16(29359),
		83: uint16(31684),
		84: uint16(33539),
		85: uint16(27861),
		86: uint16(29754),
		87: uint16(20731),
		88: uint16(21128),
		89: uint16(22721),
		90: uint16(25816),
		91: uint16(27287),
		92: uint16(29863),
		93: uint16(30294),
	},
	59: {
		0:  uint16(30887),
		1:  uint16(34327),
		2:  uint16(38370),
		3:  uint16(38713),
		4:  uint16(63845),
		5:  uint16(21342),
		6:  uint16(24321),
		7:  uint16(35722),
		8:  uint16(36776),
		9:  uint16(36783),
		10: uint16(37002),
		11: uint16(21029),
		12: uint16(30629),
		13: uint16(40009),
		14: uint16(40712),
		15: uint16(19993),
		16: uint16(20482),
		17: uint16(20853),
		18: uint16(23643),
		19: uint16(24183),
		20: uint16(26142),
		21: uint16(26170),
		22: uint16(26564),
		23: uint16(26821),
		24: uint16(28851),
		25: uint16(29953),
		26: uint16(30149),
		27: uint16(31177),
		28: uint16(31453),
		29: uint16(36647),
		30: uint16(39200),
		31: uint16(39432),
		32: uint16(20445),
		33: uint16(22561),
		34: uint16(22577),
		35: uint16(23542),
		36: uint16(26222),
		37: uint16(27493),
		38: uint16(27921),
		39: uint16(28282),
		40: uint16(28541),
		41: uint16(29668),
		42: uint16(29995),
		43: uint16(33769),
		44: uint16(35036),
		45: uint16(35091),
		46: uint16(35676),
		47: uint16(36628),
		48: uint16(20239),
		49: uint16(20693),
		50: uint16(21264),
		51: uint16(21340),
		52: uint16(23443),
		53: uint16(24489),
		54: uint16(26381),
		55: uint16(31119),
		56: uint16(33145),
		57: uint16(33583),
		58: uint16(34068),
		59: uint16(35079),
		60: uint16(35206),
		61: uint16(36665),
		62: uint16(36667),
		63: uint16(39333),
		64: uint16(39954),
		65: uint16(26412),
		66: uint16(20086),
		67: uint16(20472),
		68: uint16(22857),
		69: uint16(23553),
		70: uint16(23791),
		71: uint16(23792),
		72: uint16(25447),
		73: uint16(26834),
		74: uint16(28925),
		75: uint16(29090),
		76: uint16(29739),
		77: uint16(32299),
		78: uint16(34028),
		79: uint16(34562),
		80: uint16(36898),
		81: uint16(37586),
		82: uint16(40179),
		83: uint16(19981),
		84: uint16(20184),
		85: uint16(20463),
		86: uint16(20613),
		87: uint16(21078),
		88: uint16(21103),
		89: uint16(21542),
		90: uint16(21648),
		91: uint16(22496),
		92: uint16(22827),
		93: uint16(23142),
	},
	60: {
		0:  uint16(23386),
		1:  uint16(23413),
		2:  uint16(23500),
		3:  uint16(24220),
		4:  uint16(63846),
		5:  uint16(25206),
		6:  uint16(25975),
		7:  uint16(26023),
		8:  uint16(28014),
		9:  uint16(28325),
		10: uint16(29238),
		11: uint16(31526),
		12: uint16(31807),
		13: uint16(32566),
		14: uint16(33104),
		15: uint16(33105),
		16: uint16(33178),
		17: uint16(33344),
		18: uint16(33433),
		19: uint16(33705),
		20: uint16(35331),
		21: uint16(36000),
		22: uint16(36070),
		23: uint16(36091),
		24: uint16(36212),
		25: uint16(36282),
		26: uint16(37096),
		27: uint16(37340),
		28: uint16(38428),
		29: uint16(38468),
		30: uint16(39385),
		31: uint16(40167),
		32: uint16(21271),
		33: uint16(20998),
		34: uint16(21545),
		35: uint16(22132),
		36: uint16(22707),
		37: uint16(22868),
		38: uint16(22894),
		39: uint16(24575),
		40: uint16(24996),
		41: uint16(25198),
		42: uint16(26128),
		43: uint16(27774),
		44: uint16(28954),
		45: uint16(30406),
		46: uint16(31881),
		47: uint16(31966),
		48: uint16(32027),
		49: uint16(33452),
		50: uint16(36033),
		51: uint16(38640),
		52: uint16(63847),
		53: uint16(20315),
		54: uint16(24343),
		55: uint16(24447),
		56: uint16(25282),
		57: uint16(23849),
		58: uint16(26379),
		59: uint16(26842),
		60: uint16(30844),
		61: uint16(32323),
		62: uint16(40300),
		63: uint16(19989),
		64: uint16(20633),
		65: uint16(21269),
		66: uint16(21290),
		67: uint16(21329),
		68: uint16(22915),
		69: uint16(23138),
		70: uint16(24199),
		71: uint16(24754),
		72: uint16(24970),
		73: uint16(25161),
		74: uint16(25209),
		75: uint16(26000),
		76: uint16(26503),
		77: uint16(27047),
		78: uint16(27604),
		79: uint16(27606),
		80: uint16(27607),
		81: uint16(27608),
		82: uint16(27832),
		83: uint16(63848),
		84: uint16(29749),
		85: uint16(30202),
		86: uint16(30738),
		87: uint16(30865),
		88: uint16(31189),
		89: uint16(31192),
		90: uint16(31875),
		91: uint16(32203),
		92: uint16(32737),
		93: uint16(32933),
	},
	61: {
		0:  uint16(33086),
		1:  uint16(33218),
		2:  uint16(33778),
		3:  uint16(34586),
		4:  uint16(35048),
		5:  uint16(35513),
		6:  uint16(35692),
		7:  uint16(36027),
		8:  uint16(37145),
		9:  uint16(38750),
		10: uint16(39131),
		11: uint16(40763),
		12: uint16(22188),
		13: uint16(23338),
		14: uint16(24428),
		15: uint16(25996),
		16: uint16(27315),
		17: uint16(27567),
		18: uint16(27996),
		19: uint16(28657),
		20: uint16(28693),
		21: uint16(29277),
		22: uint16(29613),
		23: uint16(36007),
		24: uint16(36051),
		25: uint16(38971),
		26: uint16(24977),
		27: uint16(27703),
		28: uint16(32856),
		29: uint16(39425),
		30: uint16(20045),
		31: uint16(20107),
		32: uint16(20123),
		33: uint16(20181),
		34: uint16(20282),
		35: uint16(20284),
		36: uint16(20351),
		37: uint16(20447),
		38: uint16(20735),
		39: uint16(21490),
		40: uint16(21496),
		41: uint16(21766),
		42: uint16(21987),
		43: uint16(22235),
		44: uint16(22763),
		45: uint16(22882),
		46: uint16(23057),
		47: uint16(23531),
		48: uint16(23546),
		49: uint16(23556),
		50: uint16(24051),
		51: uint16(24107),
		52: uint16(24473),
		53: uint16(24605),
		54: uint16(25448),
		55: uint16(26012),
		56: uint16(26031),
		57: uint16(26614),
		58: uint16(26619),
		59: uint16(26797),
		60: uint16(27515),
		61: uint16(27801),
		62: uint16(27863),
		63: uint16(28195),
		64: uint16(28681),
		65: uint16(29509),
		66: uint16(30722),
		67: uint16(31038),
		68: uint16(31040),
		69: uint16(31072),
		70: uint16(31169),
		71: uint16(31721),
		72: uint16(32023),
		73: uint16(32114),
		74: uint16(32902),
		75: uint16(33293),
		76: uint16(33678),
		77: uint16(34001),
		78: uint16(34503),
		79: uint16(35039),
		80: uint16(35408),
		81: uint16(35422),
		82: uint16(35613),
		83: uint16(36060),
		84: uint16(36198),
		85: uint16(36781),
		86: uint16(37034),
		87: uint16(39164),
		88: uint16(39391),
		89: uint16(40605),
		90: uint16(21066),
		91: uint16(63849),
		92: uint16(26388),
		93: uint16(63850),
	},
	62: {
		0:  uint16(20632),
		1:  uint16(21034),
		2:  uint16(23665),
		3:  uint16(25955),
		4:  uint16(27733),
		5:  uint16(29642),
		6:  uint16(29987),
		7:  uint16(30109),
		8:  uint16(31639),
		9:  uint16(33948),
		10: uint16(37240),
		11: uint16(38704),
		12: uint16(20087),
		13: uint16(25746),
		14: uint16(27578),
		15: uint16(29022),
		16: uint16(34217),
		17: uint16(19977),
		18: uint16(63851),
		19: uint16(26441),
		20: uint16(26862),
		21: uint16(28183),
		22: uint16(33439),
		23: uint16(34072),
		24: uint16(34923),
		25: uint16(25591),
		26: uint16(28545),
		27: uint16(37394),
		28: uint16(39087),
		29: uint16(19978),
		30: uint16(20663),
		31: uint16(20687),
		32: uint16(20767),
		33: uint16(21830),
		34: uint16(21930),
		35: uint16(22039),
		36: uint16(23360),
		37: uint16(23577),
		38: uint16(23776),
		39: uint16(24120),
		40: uint16(24202),
		41: uint16(24224),
		42: uint16(24258),
		43: uint16(24819),
		44: uint16(26705),
		45: uint16(27233),
		46: uint16(28248),
		47: uint16(29245),
		48: uint16(29248),
		49: uint16(29376),
		50: uint16(30456),
		51: uint16(31077),
		52: uint16(31665),
		53: uint16(32724),
		54: uint16(35059),
		55: uint16(35316),
		56: uint16(35443),
		57: uint16(35937),
		58: uint16(36062),
		59: uint16(38684),
		60: uint16(22622),
		61: uint16(29885),
		62: uint16(36093),
		63: uint16(21959),
		64: uint16(63852),
		65: uint16(31329),
		66: uint16(32034),
		67: uint16(33394),
		68: uint16(29298),
		69: uint16(29983),
		70: uint16(29989),
		71: uint16(63853),
		72: uint16(31513),
		73: uint16(22661),
		74: uint16(22779),
		75: uint16(23996),
		76: uint16(24207),
		77: uint16(24246),
		78: uint16(24464),
		79: uint16(24661),
		80: uint16(25234),
		81: uint16(25471),
		82: uint16(25933),
		83: uint16(26257),
		84: uint16(26329),
		85: uint16(26360),
		86: uint16(26646),
		87: uint16(26866),
		88: uint16(29312),
		89: uint16(29790),
		90: uint16(31598),
		91: uint16(32110),
		92: uint16(32214),
		93: uint16(32626),
	},
	63: {
		0:  uint16(32997),
		1:  uint16(33298),
		2:  uint16(34223),
		3:  uint16(35199),
		4:  uint16(35475),
		5:  uint16(36893),
		6:  uint16(37604),
		7:  uint16(40653),
		8:  uint16(40736),
		9:  uint16(22805),
		10: uint16(22893),
		11: uint16(24109),
		12: uint16(24796),
		13: uint16(26132),
		14: uint16(26227),
		15: uint16(26512),
		16: uint16(27728),
		17: uint16(28101),
		18: uint16(28511),
		19: uint16(30707),
		20: uint16(30889),
		21: uint16(33990),
		22: uint16(37323),
		23: uint16(37675),
		24: uint16(20185),
		25: uint16(20682),
		26: uint16(20808),
		27: uint16(21892),
		28: uint16(23307),
		29: uint16(23459),
		30: uint16(25159),
		31: uint16(25982),
		32: uint16(26059),
		33: uint16(28210),
		34: uint16(29053),
		35: uint16(29697),
		36: uint16(29764),
		37: uint16(29831),
		38: uint16(29887),
		39: uint16(30316),
		40: uint16(31146),
		41: uint16(32218),
		42: uint16(32341),
		43: uint16(32680),
		44: uint16(33146),
		45: uint16(33203),
		46: uint16(33337),
		47: uint16(34330),
		48: uint16(34796),
		49: uint16(35445),
		50: uint16(36323),
		51: uint16(36984),
		52: uint16(37521),
		53: uint16(37925),
		54: uint16(39245),
		55: uint16(39854),
		56: uint16(21352),
		57: uint16(23633),
		58: uint16(26964),
		59: uint16(27844),
		60: uint16(27945),
		61: uint16(28203),
		62: uint16(33292),
		63: uint16(34203),
		64: uint16(35131),
		65: uint16(35373),
		66: uint16(35498),
		67: uint16(38634),
		68: uint16(40807),
		69: uint16(21089),
		70: uint16(26297),
		71: uint16(27570),
		72: uint16(32406),
		73: uint16(34814),
		74: uint16(36109),
		75: uint16(38275),
		76: uint16(38493),
		77: uint16(25885),
		78: uint16(28041),
		79: uint16(29166),
		80: uint16(63854),
		81: uint16(22478),
		82: uint16(22995),
		83: uint16(23468),
		84: uint16(24615),
		85: uint16(24826),
		86: uint16(25104),
		87: uint16(26143),
		88: uint16(26207),
		89: uint16(29481),
		90: uint16(29689),
		91: uint16(30427),
		92: uint16(30465),
		93: uint16(31596),
	},
	64: {
		0:  uint16(32854),
		1:  uint16(32882),
		2:  uint16(33125),
		3:  uint16(35488),
		4:  uint16(37266),
		5:  uint16(19990),
		6:  uint16(21218),
		7:  uint16(27506),
		8:  uint16(27927),
		9:  uint16(31237),
		10: uint16(31545),
		11: uint16(32048),
		12: uint16(63855),
		13: uint16(36016),
		14: uint16(21484),
		15: uint16(22063),
		16: uint16(22609),
		17: uint16(23477),
		18: uint16(23567),
		19: uint16(23569),
		20: uint16(24034),
		21: uint16(25152),
		22: uint16(25475),
		23: uint16(25620),
		24: uint16(26157),
		25: uint16(26803),
		26: uint16(27836),
		27: uint16(28040),
		28: uint16(28335),
		29: uint16(28703),
		30: uint16(28836),
		31: uint16(29138),
		32: uint16(29990),
		33: uint16(30095),
		34: uint16(30094),
		35: uint16(30233),
		36: uint16(31505),
		37: uint16(31712),
		38: uint16(31787),
		39: uint16(32032),
		40: uint16(32057),
		41: uint16(34092),
		42: uint16(34157),
		43: uint16(34311),
		44: uint16(35380),
		45: uint16(36877),
		46: uint16(36961),
		47: uint16(37045),
		48: uint16(37559),
		49: uint16(38902),
		50: uint16(39479),
		51: uint16(20439),
		52: uint16(23660),
		53: uint16(26463),
		54: uint16(28049),
		55: uint16(31903),
		56: uint16(32396),
		57: uint16(35606),
		58: uint16(36118),
		59: uint16(36895),
		60: uint16(23403),
		61: uint16(24061),
		62: uint16(25613),
		63: uint16(33984),
		64: uint16(36956),
		65: uint16(39137),
		66: uint16(29575),
		67: uint16(23435),
		68: uint16(24730),
		69: uint16(26494),
		70: uint16(28126),
		71: uint16(35359),
		72: uint16(35494),
		73: uint16(36865),
		74: uint16(38924),
		75: uint16(21047),
		76: uint16(63856),
		77: uint16(28753),
		78: uint16(30862),
		79: uint16(37782),
		80: uint16(34928),
		81: uint16(37335),
		82: uint16(20462),
		83: uint16(21463),
		84: uint16(22013),
		85: uint16(22234),
		86: uint16(22402),
		87: uint16(22781),
		88: uint16(23234),
		89: uint16(23432),
		90: uint16(23723),
		91: uint16(23744),
		92: uint16(24101),
		93: uint16(24833),
	},
	65: {
		0:  uint16(25101),
		1:  uint16(25163),
		2:  uint16(25480),
		3:  uint16(25628),
		4:  uint16(25910),
		5:  uint16(25976),
		6:  uint16(27193),
		7:  uint16(27530),
		8:  uint16(27700),
		9:  uint16(27929),
		10: uint16(28465),
		11: uint16(29159),
		12: uint16(29417),
		13: uint16(29560),
		14: uint16(29703),
		15: uint16(29874),
		16: uint16(30246),
		17: uint16(30561),
		18: uint16(31168),
		19: uint16(31319),
		20: uint16(31466),
		21: uint16(31929),
		22: uint16(32143),
		23: uint16(32172),
		24: uint16(32353),
		25: uint16(32670),
		26: uint16(33065),
		27: uint16(33585),
		28: uint16(33936),
		29: uint16(34010),
		30: uint16(34282),
		31: uint16(34966),
		32: uint16(35504),
		33: uint16(35728),
		34: uint16(36664),
		35: uint16(36930),
		36: uint16(36995),
		37: uint16(37228),
		38: uint16(37526),
		39: uint16(37561),
		40: uint16(38539),
		41: uint16(38567),
		42: uint16(38568),
		43: uint16(38614),
		44: uint16(38656),
		45: uint16(38920),
		46: uint16(39318),
		47: uint16(39635),
		48: uint16(39706),
		49: uint16(21460),
		50: uint16(22654),
		51: uint16(22809),
		52: uint16(23408),
		53: uint16(23487),
		54: uint16(28113),
		55: uint16(28506),
		56: uint16(29087),
		57: uint16(29729),
		58: uint16(29881),
		59: uint16(32901),
		60: uint16(33789),
		61: uint16(24033),
		62: uint16(24455),
		63: uint16(24490),
		64: uint16(24642),
		65: uint16(26092),
		66: uint16(26642),
		67: uint16(26991),
		68: uint16(27219),
		69: uint16(27529),
		70: uint16(27957),
		71: uint16(28147),
		72: uint16(29667),
		73: uint16(30462),
		74: uint16(30636),
		75: uint16(31565),
		76: uint16(32020),
		77: uint16(33059),
		78: uint16(33308),
		79: uint16(33600),
		80: uint16(34036),
		81: uint16(34147),
		82: uint16(35426),
		83: uint16(35524),
		84: uint16(37255),
		85: uint16(37662),
		86: uint16(38918),
		87: uint16(39348),
		88: uint16(25100),
		89: uint16(34899),
		90: uint16(36848),
		91: uint16(37477),
		92: uint16(23815),
		93: uint16(23847),
	},
	66: {
		0:  uint16(23913),
		1:  uint16(29791),
		2:  uint16(33181),
		3:  uint16(34664),
		4:  uint16(28629),
		5:  uint16(25342),
		6:  uint16(32722),
		7:  uint16(35126),
		8:  uint16(35186),
		9:  uint16(19998),
		10: uint16(20056),
		11: uint16(20711),
		12: uint16(21213),
		13: uint16(21319),
		14: uint16(25215),
		15: uint16(26119),
		16: uint16(32361),
		17: uint16(34821),
		18: uint16(38494),
		19: uint16(20365),
		20: uint16(21273),
		21: uint16(22070),
		22: uint16(22987),
		23: uint16(23204),
		24: uint16(23608),
		25: uint16(23630),
		26: uint16(23629),
		27: uint16(24066),
		28: uint16(24337),
		29: uint16(24643),
		30: uint16(26045),
		31: uint16(26159),
		32: uint16(26178),
		33: uint16(26558),
		34: uint16(26612),
		35: uint16(29468),
		36: uint16(30690),
		37: uint16(31034),
		38: uint16(32709),
		39: uint16(33940),
		40: uint16(33997),
		41: uint16(35222),
		42: uint16(35430),
		43: uint16(35433),
		44: uint16(35553),
		45: uint16(35925),
		46: uint16(35962),
		47: uint16(22516),
		48: uint16(23508),
		49: uint16(24335),
		50: uint16(24687),
		51: uint16(25325),
		52: uint16(26893),
		53: uint16(27542),
		54: uint16(28252),
		55: uint16(29060),
		56: uint16(31698),
		57: uint16(34645),
		58: uint16(35672),
		59: uint16(36606),
		60: uint16(39135),
		61: uint16(39166),
		62: uint16(20280),
		63: uint16(20353),
		64: uint16(20449),
		65: uint16(21627),
		66: uint16(23072),
		67: uint16(23480),
		68: uint16(24892),
		69: uint16(26032),
		70: uint16(26216),
		71: uint16(29180),
		72: uint16(30003),
		73: uint16(31070),
		74: uint16(32051),
		75: uint16(33102),
		76: uint16(33251),
		77: uint16(33688),
		78: uint16(34218),
		79: uint16(34254),
		80: uint16(34563),
		81: uint16(35338),
		82: uint16(36523),
		83: uint16(36763),
		84: uint16(63857),
		85: uint16(36805),
		86: uint16(22833),
		87: uint16(23460),
		88: uint16(23526),
		89: uint16(24713),
		90: uint16(23529),
		91: uint16(23563),
		92: uint16(24515),
		93: uint16(27777),
	},
	67: {
		0:  uint16(63858),
		1:  uint16(28145),
		2:  uint16(28683),
		3:  uint16(29978),
		4:  uint16(33455),
		5:  uint16(35574),
		6:  uint16(20160),
		7:  uint16(21313),
		8:  uint16(63859),
		9:  uint16(38617),
		10: uint16(27663),
		11: uint16(20126),
		12: uint16(20420),
		13: uint16(20818),
		14: uint16(21854),
		15: uint16(23077),
		16: uint16(23784),
		17: uint16(25105),
		18: uint16(29273),
		19: uint16(33469),
		20: uint16(33706),
		21: uint16(34558),
		22: uint16(34905),
		23: uint16(35357),
		24: uint16(38463),
		25: uint16(38597),
		26: uint16(39187),
		27: uint16(40201),
		28: uint16(40285),
		29: uint16(22538),
		30: uint16(23731),
		31: uint16(23997),
		32: uint16(24132),
		33: uint16(24801),
		34: uint16(24853),
		35: uint16(25569),
		36: uint16(27138),
		37: uint16(28197),
		38: uint16(37122),
		39: uint16(37716),
		40: uint16(38990),
		41: uint16(39952),
		42: uint16(40823),
		43: uint16(23433),
		44: uint16(23736),
		45: uint16(25353),
		46: uint16(26191),
		47: uint16(26696),
		48: uint16(30524),
		49: uint16(38593),
		50: uint16(38797),
		51: uint16(38996),
		52: uint16(39839),
		53: uint16(26017),
		54: uint16(35585),
		55: uint16(36555),
		56: uint16(38332),
		57: uint16(21813),
		58: uint16(23721),
		59: uint16(24022),
		60: uint16(24245),
		61: uint16(26263),
		62: uint16(30284),
		63: uint16(33780),
		64: uint16(38343),
		65: uint16(22739),
		66: uint16(25276),
		67: uint16(29390),
		68: uint16(40232),
		69: uint16(20208),
		70: uint16(22830),
		71: uint16(24591),
		72: uint16(26171),
		73: uint16(27523),
		74: uint16(31207),
		75: uint16(40230),
		76: uint16(21395),
		77: uint16(21696),
		78: uint16(22467),
		79: uint16(23830),
		80: uint16(24859),
		81: uint16(26326),
		82: uint16(28079),
		83: uint16(30861),
		84: uint16(33406),
		85: uint16(38552),
		86: uint16(38724),
		87: uint16(21380),
		88: uint16(25212),
		89: uint16(25494),
		90: uint16(28082),
		91: uint16(32266),
		92: uint16(33099),
		93: uint16(38989),
	},
	68: {
		0:  uint16(27387),
		1:  uint16(32588),
		2:  uint16(40367),
		3:  uint16(40474),
		4:  uint16(20063),
		5:  uint16(20539),
		6:  uint16(20918),
		7:  uint16(22812),
		8:  uint16(24825),
		9:  uint16(25590),
		10: uint16(26928),
		11: uint16(29242),
		12: uint16(32822),
		13: uint16(63860),
		14: uint16(37326),
		15: uint16(24369),
		16: uint16(63861),
		17: uint16(63862),
		18: uint16(32004),
		19: uint16(33509),
		20: uint16(33903),
		21: uint16(33979),
		22: uint16(34277),
		23: uint16(36493),
		24: uint16(63863),
		25: uint16(20335),
		26: uint16(63864),
		27: uint16(63865),
		28: uint16(22756),
		29: uint16(23363),
		30: uint16(24665),
		31: uint16(25562),
		32: uint16(25880),
		33: uint16(25965),
		34: uint16(26264),
		35: uint16(63866),
		36: uint16(26954),
		37: uint16(27171),
		38: uint16(27915),
		39: uint16(28673),
		40: uint16(29036),
		41: uint16(30162),
		42: uint16(30221),
		43: uint16(31155),
		44: uint16(31344),
		45: uint16(63867),
		46: uint16(32650),
		47: uint16(63868),
		48: uint16(35140),
		49: uint16(63869),
		50: uint16(35731),
		51: uint16(37312),
		52: uint16(38525),
		53: uint16(63870),
		54: uint16(39178),
		55: uint16(22276),
		56: uint16(24481),
		57: uint16(26044),
		58: uint16(28417),
		59: uint16(30208),
		60: uint16(31142),
		61: uint16(35486),
		62: uint16(39341),
		63: uint16(39770),
		64: uint16(40812),
		65: uint16(20740),
		66: uint16(25014),
		67: uint16(25233),
		68: uint16(27277),
		69: uint16(33222),
		70: uint16(20547),
		71: uint16(22576),
		72: uint16(24422),
		73: uint16(28937),
		74: uint16(35328),
		75: uint16(35578),
		76: uint16(23420),
		77: uint16(34326),
		78: uint16(20474),
		79: uint16(20796),
		80: uint16(22196),
		81: uint16(22852),
		82: uint16(25513),
		83: uint16(28153),
		84: uint16(23978),
		85: uint16(26989),
		86: uint16(20870),
		87: uint16(20104),
		88: uint16(20313),
		89: uint16(63871),
		90: uint16(63872),
		91: uint16(63873),
		92: uint16(22914),
		93: uint16(63874),
	},
	69: {
		0:  uint16(63875),
		1:  uint16(27487),
		2:  uint16(27741),
		3:  uint16(63876),
		4:  uint16(29877),
		5:  uint16(30998),
		6:  uint16(63877),
		7:  uint16(33287),
		8:  uint16(33349),
		9:  uint16(33593),
		10: uint16(36671),
		11: uint16(36701),
		12: uint16(63878),
		13: uint16(39192),
		14: uint16(63879),
		15: uint16(63880),
		16: uint16(63881),
		17: uint16(20134),
		18: uint16(63882),
		19: uint16(22495),
		20: uint16(24441),
		21: uint16(26131),
		22: uint16(63883),
		23: uint16(63884),
		24: uint16(30123),
		25: uint16(32377),
		26: uint16(35695),
		27: uint16(63885),
		28: uint16(36870),
		29: uint16(39515),
		30: uint16(22181),
		31: uint16(22567),
		32: uint16(23032),
		33: uint16(23071),
		34: uint16(23476),
		35: uint16(63886),
		36: uint16(24310),
		37: uint16(63887),
		38: uint16(63888),
		39: uint16(25424),
		40: uint16(25403),
		41: uint16(63889),
		42: uint16(26941),
		43: uint16(27783),
		44: uint16(27839),
		45: uint16(28046),
		46: uint16(28051),
		47: uint16(28149),
		48: uint16(28436),
		49: uint16(63890),
		50: uint16(28895),
		51: uint16(28982),
		52: uint16(29017),
		53: uint16(63891),
		54: uint16(29123),
		55: uint16(29141),
		56: uint16(63892),
		57: uint16(30799),
		58: uint16(30831),
		59: uint16(63893),
		60: uint16(31605),
		61: uint16(32227),
		62: uint16(63894),
		63: uint16(32303),
		64: uint16(63895),
		65: uint16(34893),
		66: uint16(36575),
		67: uint16(63896),
		68: uint16(63897),
		69: uint16(63898),
		70: uint16(37467),
		71: uint16(63899),
		72: uint16(40182),
		73: uint16(63900),
		74: uint16(63901),
		75: uint16(63902),
		76: uint16(24709),
		77: uint16(28037),
		78: uint16(63903),
		79: uint16(29105),
		80: uint16(63904),
		81: uint16(63905),
		82: uint16(38321),
		83: uint16(21421),
		84: uint16(63906),
		85: uint16(63907),
		86: uint16(63908),
		87: uint16(26579),
		88: uint16(63909),
		89: uint16(28814),
		90: uint16(28976),
		91: uint16(29744),
		92: uint16(33398),
		93: uint16(33490),
	},
	70: {
		0:  uint16(63910),
		1:  uint16(38331),
		2:  uint16(39653),
		3:  uint16(40573),
		4:  uint16(26308),
		5:  uint16(63911),
		6:  uint16(29121),
		7:  uint16(33865),
		8:  uint16(63912),
		9:  uint16(63913),
		10: uint16(22603),
		11: uint16(63914),
		12: uint16(63915),
		13: uint16(23992),
		14: uint16(24433),
		15: uint16(63916),
		16: uint16(26144),
		17: uint16(26254),
		18: uint16(27001),
		19: uint16(27054),
		20: uint16(27704),
		21: uint16(27891),
		22: uint16(28214),
		23: uint16(28481),
		24: uint16(28634),
		25: uint16(28699),
		26: uint16(28719),
		27: uint16(29008),
		28: uint16(29151),
		29: uint16(29552),
		30: uint16(63917),
		31: uint16(29787),
		32: uint16(63918),
		33: uint16(29908),
		34: uint16(30408),
		35: uint16(31310),
		36: uint16(32403),
		37: uint16(63919),
		38: uint16(63920),
		39: uint16(33521),
		40: uint16(35424),
		41: uint16(36814),
		42: uint16(63921),
		43: uint16(37704),
		44: uint16(63922),
		45: uint16(38681),
		46: uint16(63923),
		47: uint16(63924),
		48: uint16(20034),
		49: uint16(20522),
		50: uint16(63925),
		51: uint16(21000),
		52: uint16(21473),
		53: uint16(26355),
		54: uint16(27757),
		55: uint16(28618),
		56: uint16(29450),
		57: uint16(30591),
		58: uint16(31330),
		59: uint16(33454),
		60: uint16(34269),
		61: uint16(34306),
		62: uint16(63926),
		63: uint16(35028),
		64: uint16(35427),
		65: uint16(35709),
		66: uint16(35947),
		67: uint16(63927),
		68: uint16(37555),
		69: uint16(63928),
		70: uint16(38675),
		71: uint16(38928),
		72: uint16(20116),
		73: uint16(20237),
		74: uint16(20425),
		75: uint16(20658),
		76: uint16(21320),
		77: uint16(21566),
		78: uint16(21555),
		79: uint16(21978),
		80: uint16(22626),
		81: uint16(22714),
		82: uint16(22887),
		83: uint16(23067),
		84: uint16(23524),
		85: uint16(24735),
		86: uint16(63929),
		87: uint16(25034),
		88: uint16(25942),
		89: uint16(26111),
		90: uint16(26212),
		91: uint16(26791),
		92: uint16(27738),
		93: uint16(28595),
	},
	71: {
		0:  uint16(28879),
		1:  uint16(29100),
		2:  uint16(29522),
		3:  uint16(31613),
		4:  uint16(34568),
		5:  uint16(35492),
		6:  uint16(39986),
		7:  uint16(40711),
		8:  uint16(23627),
		9:  uint16(27779),
		10: uint16(29508),
		11: uint16(29577),
		12: uint16(37434),
		13: uint16(28331),
		14: uint16(29797),
		15: uint16(30239),
		16: uint16(31337),
		17: uint16(32277),
		18: uint16(34314),
		19: uint16(20800),
		20: uint16(22725),
		21: uint16(25793),
		22: uint16(29934),
		23: uint16(29973),
		24: uint16(30320),
		25: uint16(32705),
		26: uint16(37013),
		27: uint16(38605),
		28: uint16(39252),
		29: uint16(28198),
		30: uint16(29926),
		31: uint16(31401),
		32: uint16(31402),
		33: uint16(33253),
		34: uint16(34521),
		35: uint16(34680),
		36: uint16(35355),
		37: uint16(23113),
		38: uint16(23436),
		39: uint16(23451),
		40: uint16(26785),
		41: uint16(26880),
		42: uint16(28003),
		43: uint16(29609),
		44: uint16(29715),
		45: uint16(29740),
		46: uint16(30871),
		47: uint16(32233),
		48: uint16(32747),
		49: uint16(33048),
		50: uint16(33109),
		51: uint16(33694),
		52: uint16(35916),
		53: uint16(38446),
		54: uint16(38929),
		55: uint16(26352),
		56: uint16(24448),
		57: uint16(26106),
		58: uint16(26505),
		59: uint16(27754),
		60: uint16(29579),
		61: uint16(20525),
		62: uint16(23043),
		63: uint16(27498),
		64: uint16(30702),
		65: uint16(22806),
		66: uint16(23916),
		67: uint16(24013),
		68: uint16(29477),
		69: uint16(30031),
		70: uint16(63930),
		71: uint16(63931),
		72: uint16(20709),
		73: uint16(20985),
		74: uint16(22575),
		75: uint16(22829),
		76: uint16(22934),
		77: uint16(23002),
		78: uint16(23525),
		79: uint16(63932),
		80: uint16(63933),
		81: uint16(23970),
		82: uint16(25303),
		83: uint16(25622),
		84: uint16(25747),
		85: uint16(25854),
		86: uint16(63934),
		87: uint16(26332),
		88: uint16(63935),
		89: uint16(27208),
		90: uint16(63936),
		91: uint16(29183),
		92: uint16(29796),
		93: uint16(63937),
	},
	72: {
		0:  uint16(31368),
		1:  uint16(31407),
		2:  uint16(32327),
		3:  uint16(32350),
		4:  uint16(32768),
		5:  uint16(33136),
		6:  uint16(63938),
		7:  uint16(34799),
		8:  uint16(35201),
		9:  uint16(35616),
		10: uint16(36953),
		11: uint16(63939),
		12: uint16(36992),
		13: uint16(39250),
		14: uint16(24958),
		15: uint16(27442),
		16: uint16(28020),
		17: uint16(32287),
		18: uint16(35109),
		19: uint16(36785),
		20: uint16(20433),
		21: uint16(20653),
		22: uint16(20887),
		23: uint16(21191),
		24: uint16(22471),
		25: uint16(22665),
		26: uint16(23481),
		27: uint16(24248),
		28: uint16(24898),
		29: uint16(27029),
		30: uint16(28044),
		31: uint16(28263),
		32: uint16(28342),
		33: uint16(29076),
		34: uint16(29794),
		35: uint16(29992),
		36: uint16(29996),
		37: uint16(32883),
		38: uint16(33592),
		39: uint16(33993),
		40: uint16(36362),
		41: uint16(37780),
		42: uint16(37854),
		43: uint16(63940),
		44: uint16(20110),
		45: uint16(20305),
		46: uint16(20598),
		47: uint16(20778),
		48: uint16(21448),
		49: uint16(21451),
		50: uint16(21491),
		51: uint16(23431),
		52: uint16(23507),
		53: uint16(23588),
		54: uint16(24858),
		55: uint16(24962),
		56: uint16(26100),
		57: uint16(29275),
		58: uint16(29591),
		59: uint16(29760),
		60: uint16(30402),
		61: uint16(31056),
		62: uint16(31121),
		63: uint16(31161),
		64: uint16(32006),
		65: uint16(32701),
		66: uint16(33419),
		67: uint16(34261),
		68: uint16(34398),
		69: uint16(36802),
		70: uint16(36935),
		71: uint16(37109),
		72: uint16(37354),
		73: uint16(38533),
		74: uint16(38632),
		75: uint16(38633),
		76: uint16(21206),
		77: uint16(24423),
		78: uint16(26093),
		79: uint16(26161),
		80: uint16(26671),
		81: uint16(29020),
		82: uint16(31286),
		83: uint16(37057),
		84: uint16(38922),
		85: uint16(20113),
		86: uint16(63941),
		87: uint16(27218),
		88: uint16(27550),
		89: uint16(28560),
		90: uint16(29065),
		91: uint16(32792),
		92: uint16(33464),
		93: uint16(34131),
	},
	73: {
		0:  uint16(36939),
		1:  uint16(38549),
		2:  uint16(38642),
		3:  uint16(38907),
		4:  uint16(34074),
		5:  uint16(39729),
		6:  uint16(20112),
		7:  uint16(29066),
		8:  uint16(38596),
		9:  uint16(20803),
		10: uint16(21407),
		11: uint16(21729),
		12: uint16(22291),
		13: uint16(22290),
		14: uint16(22435),
		15: uint16(23195),
		16: uint16(23236),
		17: uint16(23491),
		18: uint16(24616),
		19: uint16(24895),
		20: uint16(25588),
		21: uint16(27781),
		22: uint16(27961),
		23: uint16(28274),
		24: uint16(28304),
		25: uint16(29232),
		26: uint16(29503),
		27: uint16(29783),
		28: uint16(33489),
		29: uint16(34945),
		30: uint16(36677),
		31: uint16(36960),
		32: uint16(63942),
		33: uint16(38498),
		34: uint16(39000),
		35: uint16(40219),
		36: uint16(26376),
		37: uint16(36234),
		38: uint16(37470),
		39: uint16(20301),
		40: uint16(20553),
		41: uint16(20702),
		42: uint16(21361),
		43: uint16(22285),
		44: uint16(22996),
		45: uint16(23041),
		46: uint16(23561),
		47: uint16(24944),
		48: uint16(26256),
		49: uint16(28205),
		50: uint16(29234),
		51: uint16(29771),
		52: uint16(32239),
		53: uint16(32963),
		54: uint16(33806),
		55: uint16(33894),
		56: uint16(34111),
		57: uint16(34655),
		58: uint16(34907),
		59: uint16(35096),
		60: uint16(35586),
		61: uint16(36949),
		62: uint16(38859),
		63: uint16(39759),
		64: uint16(20083),
		65: uint16(20369),
		66: uint16(20754),
		67: uint16(20842),
		68: uint16(63943),
		69: uint16(21807),
		70: uint16(21929),
		71: uint16(23418),
		72: uint16(23461),
		73: uint16(24188),
		74: uint16(24189),
		75: uint16(24254),
		76: uint16(24736),
		77: uint16(24799),
		78: uint16(24840),
		79: uint16(24841),
		80: uint16(25540),
		81: uint16(25912),
		82: uint16(26377),
		83: uint16(63944),
		84: uint16(26580),
		85: uint16(26586),
		86: uint16(63945),
		87: uint16(26977),
		88: uint16(26978),
		89: uint16(27833),
		90: uint16(27943),
		91: uint16(63946),
		92: uint16(28216),
		93: uint16(63947),
	},
	74: {
		0:  uint16(28641),
		1:  uint16(29494),
		2:  uint16(29495),
		3:  uint16(63948),
		4:  uint16(29788),
		5:  uint16(30001),
		6:  uint16(63949),
		7:  uint16(30290),
		8:  uint16(63950),
		9:  uint16(63951),
		10: uint16(32173),
		11: uint16(33278),
		12: uint16(33848),
		13: uint16(35029),
		14: uint16(35480),
		15: uint16(35547),
		16: uint16(35565),
		17: uint16(36400),
		18: uint16(36418),
		19: uint16(36938),
		20: uint16(36926),
		21: uint16(36986),
		22: uint16(37193),
		23: uint16(37321),
		24: uint16(37742),
		25: uint16(63952),
		26: uint16(63953),
		27: uint16(22537),
		28: uint16(63954),
		29: uint16(27603),
		30: uint16(32905),
		31: uint16(32946),
		32: uint16(63955),
		33: uint16(63956),
		34: uint16(20801),
		35: uint16(22891),
		36: uint16(23609),
		37: uint16(63957),
		38: uint16(63958),
		39: uint16(28516),
		40: uint16(29607),
		41: uint16(32996),
		42: uint16(36103),
		43: uint16(63959),
		44: uint16(37399),
		45: uint16(38287),
		46: uint16(63960),
		47: uint16(63961),
		48: uint16(63962),
		49: uint16(63963),
		50: uint16(32895),
		51: uint16(25102),
		52: uint16(28700),
		53: uint16(32104),
		54: uint16(34701),
		55: uint16(63964),
		56: uint16(22432),
		57: uint16(24681),
		58: uint16(24903),
		59: uint16(27575),
		60: uint16(35518),
		61: uint16(37504),
		62: uint16(38577),
		63: uint16(20057),
		64: uint16(21535),
		65: uint16(28139),
		66: uint16(34093),
		67: uint16(38512),
		68: uint16(38899),
		69: uint16(39150),
		70: uint16(25558),
		71: uint16(27875),
		72: uint16(37009),
		73: uint16(20957),
		74: uint16(25033),
		75: uint16(33210),
		76: uint16(40441),
		77: uint16(20381),
		78: uint16(20506),
		79: uint16(20736),
		80: uint16(23452),
		81: uint16(24847),
		82: uint16(25087),
		83: uint16(25836),
		84: uint16(26885),
		85: uint16(27589),
		86: uint16(30097),
		87: uint16(30691),
		88: uint16(32681),
		89: uint16(33380),
		90: uint16(34191),
		91: uint16(34811),
		92: uint16(34915),
		93: uint16(35516),
	},
	75: {
		0:  uint16(35696),
		1:  uint16(37291),
		2:  uint16(20108),
		3:  uint16(20197),
		4:  uint16(20234),
		5:  uint16(63965),
		6:  uint16(63966),
		7:  uint16(22839),
		8:  uint16(23016),
		9:  uint16(63967),
		10: uint16(24050),
		11: uint16(24347),
		12: uint16(24411),
		13: uint16(24609),
		14: uint16(63968),
		15: uint16(63969),
		16: uint16(63970),
		17: uint16(63971),
		18: uint16(29246),
		19: uint16(29669),
		20: uint16(63972),
		21: uint16(30064),
		22: uint16(30157),
		23: uint16(63973),
		24: uint16(31227),
		25: uint16(63974),
		26: uint16(32780),
		27: uint16(32819),
		28: uint16(32900),
		29: uint16(33505),
		30: uint16(33617),
		31: uint16(63975),
		32: uint16(63976),
		33: uint16(36029),
		34: uint16(36019),
		35: uint16(36999),
		36: uint16(63977),
		37: uint16(63978),
		38: uint16(39156),
		39: uint16(39180),
		40: uint16(63979),
		41: uint16(63980),
		42: uint16(28727),
		43: uint16(30410),
		44: uint16(32714),
		45: uint16(32716),
		46: uint16(32764),
		47: uint16(35610),
		48: uint16(20154),
		49: uint16(20161),
		50: uint16(20995),
		51: uint16(21360),
		52: uint16(63981),
		53: uint16(21693),
		54: uint16(22240),
		55: uint16(23035),
		56: uint16(23493),
		57: uint16(24341),
		58: uint16(24525),
		59: uint16(28270),
		60: uint16(63982),
		61: uint16(63983),
		62: uint16(32106),
		63: uint16(33589),
		64: uint16(63984),
		65: uint16(34451),
		66: uint16(35469),
		67: uint16(63985),
		68: uint16(38765),
		69: uint16(38775),
		70: uint16(63986),
		71: uint16(63987),
		72: uint16(19968),
		73: uint16(20314),
		74: uint16(20350),
		75: uint16(22777),
		76: uint16(26085),
		77: uint16(28322),
		78: uint16(36920),
		79: uint16(37808),
		80: uint16(39353),
		81: uint16(20219),
		82: uint16(22764),
		83: uint16(22922),
		84: uint16(23001),
		85: uint16(24641),
		86: uint16(63988),
		87: uint16(63989),
		88: uint16(31252),
		89: uint16(63990),
		90: uint16(33615),
		91: uint16(36035),
		92: uint16(20837),
		93: uint16(21316),
	},
	76: {
		0:  uint16(63991),
		1:  uint16(63992),
		2:  uint16(63993),
		3:  uint16(20173),
		4:  uint16(21097),
		5:  uint16(23381),
		6:  uint16(33471),
		7:  uint16(20180),
		8:  uint16(21050),
		9:  uint16(21672),
		10: uint16(22985),
		11: uint16(23039),
		12: uint16(23376),
		13: uint16(23383),
		14: uint16(23388),
		15: uint16(24675),
		16: uint16(24904),
		17: uint16(28363),
		18: uint16(28825),
		19: uint16(29038),
		20: uint16(29574),
		21: uint16(29943),
		22: uint16(30133),
		23: uint16(30913),
		24: uint16(32043),
		25: uint16(32773),
		26: uint16(33258),
		27: uint16(33576),
		28: uint16(34071),
		29: uint16(34249),
		30: uint16(35566),
		31: uint16(36039),
		32: uint16(38604),
		33: uint16(20316),
		34: uint16(21242),
		35: uint16(22204),
		36: uint16(26027),
		37: uint16(26152),
		38: uint16(28796),
		39: uint16(28856),
		40: uint16(29237),
		41: uint16(32189),
		42: uint16(33421),
		43: uint16(37196),
		44: uint16(38592),
		45: uint16(40306),
		46: uint16(23409),
		47: uint16(26855),
		48: uint16(27544),
		49: uint16(28538),
		50: uint16(30430),
		51: uint16(23697),
		52: uint16(26283),
		53: uint16(28507),
		54: uint16(31668),
		55: uint16(31786),
		56: uint16(34870),
		57: uint16(38620),
		58: uint16(19976),
		59: uint16(20183),
		60: uint16(21280),
		61: uint16(22580),
		62: uint16(22715),
		63: uint16(22767),
		64: uint16(22892),
		65: uint16(23559),
		66: uint16(24115),
		67: uint16(24196),
		68: uint16(24373),
		69: uint16(25484),
		70: uint16(26290),
		71: uint16(26454),
		72: uint16(27167),
		73: uint16(27299),
		74: uint16(27404),
		75: uint16(28479),
		76: uint16(29254),
		77: uint16(63994),
		78: uint16(29520),
		79: uint16(29835),
		80: uint16(31456),
		81: uint16(31911),
		82: uint16(33144),
		83: uint16(33247),
		84: uint16(33255),
		85: uint16(33674),
		86: uint16(33900),
		87: uint16(34083),
		88: uint16(34196),
		89: uint16(34255),
		90: uint16(35037),
		91: uint16(36115),
		92: uint16(37292),
		93: uint16(38263),
	},
	77: {
		0:  uint16(38556),
		1:  uint16(20877),
		2:  uint16(21705),
		3:  uint16(22312),
		4:  uint16(23472),
		5:  uint16(25165),
		6:  uint16(26448),
		7:  uint16(26685),
		8:  uint16(26771),
		9:  uint16(28221),
		10: uint16(28371),
		11: uint16(28797),
		12: uint16(32289),
		13: uint16(35009),
		14: uint16(36001),
		15: uint16(36617),
		16: uint16(40779),
		17: uint16(40782),
		18: uint16(29229),
		19: uint16(31631),
		20: uint16(35533),
		21: uint16(37658),
		22: uint16(20295),
		23: uint16(20302),
		24: uint16(20786),
		25: uint16(21632),
		26: uint16(22992),
		27: uint16(24213),
		28: uint16(25269),
		29: uint16(26485),
		30: uint16(26990),
		31: uint16(27159),
		32: uint16(27822),
		33: uint16(28186),
		34: uint16(29401),
		35: uint16(29482),
		36: uint16(30141),
		37: uint16(31672),
		38: uint16(32053),
		39: uint16(33511),
		40: uint16(33785),
		41: uint16(33879),
		42: uint16(34295),
		43: uint16(35419),
		44: uint16(36015),
		45: uint16(36487),
		46: uint16(36889),
		47: uint16(37048),
		48: uint16(38606),
		49: uint16(40799),
		50: uint16(21219),
		51: uint16(21514),
		52: uint16(23265),
		53: uint16(23490),
		54: uint16(25688),
		55: uint16(25973),
		56: uint16(28404),
		57: uint16(29380),
		58: uint16(63995),
		59: uint16(30340),
		60: uint16(31309),
		61: uint16(31515),
		62: uint16(31821),
		63: uint16(32318),
		64: uint16(32735),
		65: uint16(33659),
		66: uint16(35627),
		67: uint16(36042),
		68: uint16(36196),
		69: uint16(36321),
		70: uint16(36447),
		71: uint16(36842),
		72: uint16(36857),
		73: uint16(36969),
		74: uint16(37841),
		75: uint16(20291),
		76: uint16(20346),
		77: uint16(20659),
		78: uint16(20840),
		79: uint16(20856),
		80: uint16(21069),
		81: uint16(21098),
		82: uint16(22625),
		83: uint16(22652),
		84: uint16(22880),
		85: uint16(23560),
		86: uint16(23637),
		87: uint16(24283),
		88: uint16(24731),
		89: uint16(25136),
		90: uint16(26643),
		91: uint16(27583),
		92: uint16(27656),
		93: uint16(28593),
	},
	78: {
		0:  uint16(29006),
		1:  uint16(29728),
		2:  uint16(30000),
		3:  uint16(30008),
		4:  uint16(30033),
		5:  uint16(30322),
		6:  uint16(31564),
		7:  uint16(31627),
		8:  uint16(31661),
		9:  uint16(31686),
		10: uint16(32399),
		11: uint16(35438),
		12: uint16(36670),
		13: uint16(36681),
		14: uint16(37439),
		15: uint16(37523),
		16: uint16(37666),
		17: uint16(37931),
		18: uint16(38651),
		19: uint16(39002),
		20: uint16(39019),
		21: uint16(39198),
		22: uint16(20999),
		23: uint16(25130),
		24: uint16(25240),
		25: uint16(27993),
		26: uint16(30308),
		27: uint16(31434),
		28: uint16(31680),
		29: uint16(32118),
		30: uint16(21344),
		31: uint16(23742),
		32: uint16(24215),
		33: uint16(28472),
		34: uint16(28857),
		35: uint16(31896),
		36: uint16(38673),
		37: uint16(39822),
		38: uint16(40670),
		39: uint16(25509),
		40: uint16(25722),
		41: uint16(34678),
		42: uint16(19969),
		43: uint16(20117),
		44: uint16(20141),
		45: uint16(20572),
		46: uint16(20597),
		47: uint16(21576),
		48: uint16(22979),
		49: uint16(23450),
		50: uint16(24128),
		51: uint16(24237),
		52: uint16(24311),
		53: uint16(24449),
		54: uint16(24773),
		55: uint16(25402),
		56: uint16(25919),
		57: uint16(25972),
		58: uint16(26060),
		59: uint16(26230),
		60: uint16(26232),
		61: uint16(26622),
		62: uint16(26984),
		63: uint16(27273),
		64: uint16(27491),
		65: uint16(27712),
		66: uint16(28096),
		67: uint16(28136),
		68: uint16(28191),
		69: uint16(28254),
		70: uint16(28702),
		71: uint16(28833),
		72: uint16(29582),
		73: uint16(29693),
		74: uint16(30010),
		75: uint16(30555),
		76: uint16(30855),
		77: uint16(31118),
		78: uint16(31243),
		79: uint16(31357),
		80: uint16(31934),
		81: uint16(32142),
		82: uint16(33351),
		83: uint16(35330),
		84: uint16(35562),
		85: uint16(35998),
		86: uint16(37165),
		87: uint16(37194),
		88: uint16(37336),
		89: uint16(37478),
		90: uint16(37580),
		91: uint16(37664),
		92: uint16(38662),
		93: uint16(38742),
	},
	79: {
		0:  uint16(38748),
		1:  uint16(38914),
		2:  uint16(40718),
		3:  uint16(21046),
		4:  uint16(21137),
		5:  uint16(21884),
		6:  uint16(22564),
		7:  uint16(24093),
		8:  uint16(24351),
		9:  uint16(24716),
		10: uint16(25552),
		11: uint16(26799),
		12: uint16(28639),
		13: uint16(31085),
		14: uint16(31532),
		15: uint16(33229),
		16: uint16(34234),
		17: uint16(35069),
		18: uint16(35576),
		19: uint16(36420),
		20: uint16(37261),
		21: uint16(38500),
		22: uint16(38555),
		23: uint16(38717),
		24: uint16(38988),
		25: uint16(40778),
		26: uint16(20430),
		27: uint16(20806),
		28: uint16(20939),
		29: uint16(21161),
		30: uint16(22066),
		31: uint16(24340),
		32: uint16(24427),
		33: uint16(25514),
		34: uint16(25805),
		35: uint16(26089),
		36: uint16(26177),
		37: uint16(26362),
		38: uint16(26361),
		39: uint16(26397),
		40: uint16(26781),
		41: uint16(26839),
		42: uint16(27133),
		43: uint16(28437),
		44: uint16(28526),
		45: uint16(29031),
		46: uint16(29157),
		47: uint16(29226),
		48: uint16(29866),
		49: uint16(30522),
		50: uint16(31062),
		51: uint16(31066),
		52: uint16(31199),
		53: uint16(31264),
		54: uint16(31381),
		55: uint16(31895),
		56: uint16(31967),
		57: uint16(32068),
		58: uint16(32368),
		59: uint16(32903),
		60: uint16(34299),
		61: uint16(34468),
		62: uint16(35412),
		63: uint16(35519),
		64: uint16(36249),
		65: uint16(36481),
		66: uint16(36896),
		67: uint16(36973),
		68: uint16(37347),
		69: uint16(38459),
		70: uint16(38613),
		71: uint16(40165),
		72: uint16(26063),
		73: uint16(31751),
		74: uint16(36275),
		75: uint16(37827),
		76: uint16(23384),
		77: uint16(23562),
		78: uint16(21330),
		79: uint16(25305),
		80: uint16(29469),
		81: uint16(20519),
		82: uint16(23447),
		83: uint16(24478),
		84: uint16(24752),
		85: uint16(24939),
		86: uint16(26837),
		87: uint16(28121),
		88: uint16(29742),
		89: uint16(31278),
		90: uint16(32066),
		91: uint16(32156),
		92: uint16(32305),
		93: uint16(33131),
	},
	80: {
		0:  uint16(36394),
		1:  uint16(36405),
		2:  uint16(37758),
		3:  uint16(37912),
		4:  uint16(20304),
		5:  uint16(22352),
		6:  uint16(24038),
		7:  uint16(24231),
		8:  uint16(25387),
		9:  uint16(32618),
		10: uint16(20027),
		11: uint16(20303),
		12: uint16(20367),
		13: uint16(20570),
		14: uint16(23005),
		15: uint16(32964),
		16: uint16(21610),
		17: uint16(21608),
		18: uint16(22014),
		19: uint16(22863),
		20: uint16(23449),
		21: uint16(24030),
		22: uint16(24282),
		23: uint16(26205),
		24: uint16(26417),
		25: uint16(26609),
		26: uint16(26666),
		27: uint16(27880),
		28: uint16(27954),
		29: uint16(28234),
		30: uint16(28557),
		31: uint16(28855),
		32: uint16(29664),
		33: uint16(30087),
		34: uint16(31820),
		35: uint16(32002),
		36: uint16(32044),
		37: uint16(32162),
		38: uint16(33311),
		39: uint16(34523),
		40: uint16(35387),
		41: uint16(35461),
		42: uint16(36208),
		43: uint16(36490),
		44: uint16(36659),
		45: uint16(36913),
		46: uint16(37198),
		47: uint16(37202),
		48: uint16(37956),
		49: uint16(39376),
		50: uint16(31481),
		51: uint16(31909),
		52: uint16(20426),
		53: uint16(20737),
		54: uint16(20934),
		55: uint16(22472),
		56: uint16(23535),
		57: uint16(23803),
		58: uint16(26201),
		59: uint16(27197),
		60: uint16(27994),
		61: uint16(28310),
		62: uint16(28652),
		63: uint16(28940),
		64: uint16(30063),
		65: uint16(31459),
		66: uint16(34850),
		67: uint16(36897),
		68: uint16(36981),
		69: uint16(38603),
		70: uint16(39423),
		71: uint16(33537),
		72: uint16(20013),
		73: uint16(20210),
		74: uint16(34886),
		75: uint16(37325),
		76: uint16(21373),
		77: uint16(27355),
		78: uint16(26987),
		79: uint16(27713),
		80: uint16(33914),
		81: uint16(22686),
		82: uint16(24974),
		83: uint16(26366),
		84: uint16(25327),
		85: uint16(28893),
		86: uint16(29969),
		87: uint16(30151),
		88: uint16(32338),
		89: uint16(33976),
		90: uint16(35657),
		91: uint16(36104),
		92: uint16(20043),
		93: uint16(21482),
	},
	81: {
		0:  uint16(21675),
		1:  uint16(22320),
		2:  uint16(22336),
		3:  uint16(24535),
		4:  uint16(25345),
		5:  uint16(25351),
		6:  uint16(25711),
		7:  uint16(25903),
		8:  uint16(26088),
		9:  uint16(26234),
		10: uint16(26525),
		11: uint16(26547),
		12: uint16(27490),
		13: uint16(27744),
		14: uint16(27802),
		15: uint16(28460),
		16: uint16(30693),
		17: uint16(30757),
		18: uint16(31049),
		19: uint16(31063),
		20: uint16(32025),
		21: uint16(32930),
		22: uint16(33026),
		23: uint16(33267),
		24: uint16(33437),
		25: uint16(33463),
		26: uint16(34584),
		27: uint16(35468),
		28: uint16(63996),
		29: uint16(36100),
		30: uint16(36286),
		31: uint16(36978),
		32: uint16(30452),
		33: uint16(31257),
		34: uint16(31287),
		35: uint16(32340),
		36: uint16(32887),
		37: uint16(21767),
		38: uint16(21972),
		39: uint16(22645),
		40: uint16(25391),
		41: uint16(25634),
		42: uint16(26185),
		43: uint16(26187),
		44: uint16(26733),
		45: uint16(27035),
		46: uint16(27524),
		47: uint16(27941),
		48: uint16(28337),
		49: uint16(29645),
		50: uint16(29800),
		51: uint16(29857),
		52: uint16(30043),
		53: uint16(30137),
		54: uint16(30433),
		55: uint16(30494),
		56: uint16(30603),
		57: uint16(31206),
		58: uint16(32265),
		59: uint16(32285),
		60: uint16(33275),
		61: uint16(34095),
		62: uint16(34967),
		63: uint16(35386),
		64: uint16(36049),
		65: uint16(36587),
		66: uint16(36784),
		67: uint16(36914),
		68: uint16(37805),
		69: uint16(38499),
		70: uint16(38515),
		71: uint16(38663),
		72: uint16(20356),
		73: uint16(21489),
		74: uint16(23018),
		75: uint16(23241),
		76: uint16(24089),
		77: uint16(26702),
		78: uint16(29894),
		79: uint16(30142),
		80: uint16(31209),
		81: uint16(31378),
		82: uint16(33187),
		83: uint16(34541),
		84: uint16(36074),
		85: uint16(36300),
		86: uint16(36845),
		87: uint16(26015),
		88: uint16(26389),
		89: uint16(63997),
		90: uint16(22519),
		91: uint16(28503),
		92: uint16(32221),
		93: uint16(36655),
	},
	82: {
		0:  uint16(37878),
		1:  uint16(38598),
		2:  uint16(24501),
		3:  uint16(25074),
		4:  uint16(28548),
		5:  uint16(19988),
		6:  uint16(20376),
		7:  uint16(20511),
		8:  uint16(21449),
		9:  uint16(21983),
		10: uint16(23919),
		11: uint16(24046),
		12: uint16(27425),
		13: uint16(27492),
		14: uint16(30923),
		15: uint16(31642),
		16: uint16(63998),
		17: uint16(36425),
		18: uint16(36554),
		19: uint16(36974),
		20: uint16(25417),
		21: uint16(25662),
		22: uint16(30528),
		23: uint16(31364),
		24: uint16(37679),
		25: uint16(38015),
		26: uint16(40810),
		27: uint16(25776),
		28: uint16(28591),
		29: uint16(29158),
		30: uint16(29864),
		31: uint16(29914),
		32: uint16(31428),
		33: uint16(31762),
		34: uint16(32386),
		35: uint16(31922),
		36: uint16(32408),
		37: uint16(35738),
		38: uint16(36106),
		39: uint16(38013),
		40: uint16(39184),
		41: uint16(39244),
		42: uint16(21049),
		43: uint16(23519),
		44: uint16(25830),
		45: uint16(26413),
		46: uint16(32046),
		47: uint16(20717),
		48: uint16(21443),
		49: uint16(22649),
		50: uint16(24920),
		51: uint16(24921),
		52: uint16(25082),
		53: uint16(26028),
		54: uint16(31449),
		55: uint16(35730),
		56: uint16(35734),
		57: uint16(20489),
		58: uint16(20513),
		59: uint16(21109),
		60: uint16(21809),
		61: uint16(23100),
		62: uint16(24288),
		63: uint16(24432),
		64: uint16(24884),
		65: uint16(25950),
		66: uint16(26124),
		67: uint16(26166),
		68: uint16(26274),
		69: uint16(27085),
		70: uint16(28356),
		71: uint16(28466),
		72: uint16(29462),
		73: uint16(30241),
		74: uint16(31379),
		75: uint16(33081),
		76: uint16(33369),
		77: uint16(33750),
		78: uint16(33980),
		79: uint16(20661),
		80: uint16(22512),
		81: uint16(23488),
		82: uint16(23528),
		83: uint16(24425),
		84: uint16(25505),
		85: uint16(30758),
		86: uint16(32181),
		87: uint16(33756),
		88: uint16(34081),
		89: uint16(37319),
		90: uint16(37365),
		91: uint16(20874),
		92: uint16(26613),
		93: uint16(31574),
	},
	83: {
		0:  uint16(36012),
		1:  uint16(20932),
		2:  uint16(22971),
		3:  uint16(24765),
		4:  uint16(34389),
		5:  uint16(20508),
		6:  uint16(63999),
		7:  uint16(21076),
		8:  uint16(23610),
		9:  uint16(24957),
		10: uint16(25114),
		11: uint16(25299),
		12: uint16(25842),
		13: uint16(26021),
		14: uint16(28364),
		15: uint16(30240),
		16: uint16(33034),
		17: uint16(36448),
		18: uint16(38495),
		19: uint16(38587),
		20: uint16(20191),
		21: uint16(21315),
		22: uint16(21912),
		23: uint16(22825),
		24: uint16(24029),
		25: uint16(25797),
		26: uint16(27849),
		27: uint16(28154),
		28: uint16(29588),
		29: uint16(31359),
		30: uint16(33307),
		31: uint16(34214),
		32: uint16(36068),
		33: uint16(36368),
		34: uint16(36983),
		35: uint16(37351),
		36: uint16(38369),
		37: uint16(38433),
		38: uint16(38854),
		39: uint16(20984),
		40: uint16(21746),
		41: uint16(21894),
		42: uint16(24505),
		43: uint16(25764),
		44: uint16(28552),
		45: uint16(32180),
		46: uint16(36639),
		47: uint16(36685),
		48: uint16(37941),
		49: uint16(20681),
		50: uint16(23574),
		51: uint16(27838),
		52: uint16(28155),
		53: uint16(29979),
		54: uint16(30651),
		55: uint16(31805),
		56: uint16(31844),
		57: uint16(35449),
		58: uint16(35522),
		59: uint16(22558),
		60: uint16(22974),
		61: uint16(24086),
		62: uint16(25463),
		63: uint16(29266),
		64: uint16(30090),
		65: uint16(30571),
		66: uint16(35548),
		67: uint16(36028),
		68: uint16(36626),
		69: uint16(24307),
		70: uint16(26228),
		71: uint16(28152),
		72: uint16(32893),
		73: uint16(33729),
		74: uint16(35531),
		75: uint16(38737),
		76: uint16(39894),
		77: uint16(64000),
		78: uint16(21059),
		79: uint16(26367),
		80: uint16(28053),
		81: uint16(28399),
		82: uint16(32224),
		83: uint16(35558),
		84: uint16(36910),
		85: uint16(36958),
		86: uint16(39636),
		87: uint16(21021),
		88: uint16(21119),
		89: uint16(21736),
		90: uint16(24980),
		91: uint16(25220),
		92: uint16(25307),
		93: uint16(26786),
	},
	84: {
		0:  uint16(26898),
		1:  uint16(26970),
		2:  uint16(27189),
		3:  uint16(28818),
		4:  uint16(28966),
		5:  uint16(30813),
		6:  uint16(30977),
		7:  uint16(30990),
		8:  uint16(31186),
		9:  uint16(31245),
		10: uint16(32918),
		11: uint16(33400),
		12: uint16(33493),
		13: uint16(33609),
		14: uint16(34121),
		15: uint16(35970),
		16: uint16(36229),
		17: uint16(37218),
		18: uint16(37259),
		19: uint16(37294),
		20: uint16(20419),
		21: uint16(22225),
		22: uint16(29165),
		23: uint16(30679),
		24: uint16(34560),
		25: uint16(35320),
		26: uint16(23544),
		27: uint16(24534),
		28: uint16(26449),
		29: uint16(37032),
		30: uint16(21474),
		31: uint16(22618),
		32: uint16(23541),
		33: uint16(24740),
		34: uint16(24961),
		35: uint16(25696),
		36: uint16(32317),
		37: uint16(32880),
		38: uint16(34085),
		39: uint16(37507),
		40: uint16(25774),
		41: uint16(20652),
		42: uint16(23828),
		43: uint16(26368),
		44: uint16(22684),
		45: uint16(25277),
		46: uint16(25512),
		47: uint16(26894),
		48: uint16(27000),
		49: uint16(27166),
		50: uint16(28267),
		51: uint16(30394),
		52: uint16(31179),
		53: uint16(33467),
		54: uint16(33833),
		55: uint16(35535),
		56: uint16(36264),
		57: uint16(36861),
		58: uint16(37138),
		59: uint16(37195),
		60: uint16(37276),
		61: uint16(37648),
		62: uint16(37656),
		63: uint16(37786),
		64: uint16(38619),
		65: uint16(39478),
		66: uint16(39949),
		67: uint16(19985),
		68: uint16(30044),
		69: uint16(31069),
		70: uint16(31482),
		71: uint16(31569),
		72: uint16(31689),
		73: uint16(32302),
		74: uint16(33988),
		75: uint16(36441),
		76: uint16(36468),
		77: uint16(36600),
		78: uint16(36880),
		79: uint16(26149),
		80: uint16(26943),
		81: uint16(29763),
		82: uint16(20986),
		83: uint16(26414),
		84: uint16(40668),
		85: uint16(20805),
		86: uint16(24544),
		87: uint16(27798),
		88: uint16(34802),
		89: uint16(34909),
		90: uint16(34935),
		91: uint16(24756),
		92: uint16(33205),
		93: uint16(33795),
	},
	85: {
		0:  uint16(36101),
		1:  uint16(21462),
		2:  uint16(21561),
		3:  uint16(22068),
		4:  uint16(23094),
		5:  uint16(23601),
		6:  uint16(28810),
		7:  uint16(32736),
		8:  uint16(32858),
		9:  uint16(33030),
		10: uint16(33261),
		11: uint16(36259),
		12: uint16(37257),
		13: uint16(39519),
		14: uint16(40434),
		15: uint16(20596),
		16: uint16(20164),
		17: uint16(21408),
		18: uint16(24827),
		19: uint16(28204),
		20: uint16(23652),
		21: uint16(20360),
		22: uint16(20516),
		23: uint16(21988),
		24: uint16(23769),
		25: uint16(24159),
		26: uint16(24677),
		27: uint16(26772),
		28: uint16(27835),
		29: uint16(28100),
		30: uint16(29118),
		31: uint16(30164),
		32: uint16(30196),
		33: uint16(30305),
		34: uint16(31258),
		35: uint16(31305),
		36: uint16(32199),
		37: uint16(32251),
		38: uint16(32622),
		39: uint16(33268),
		40: uint16(34473),
		41: uint16(36636),
		42: uint16(38601),
		43: uint16(39347),
		44: uint16(40786),
		45: uint16(21063),
		46: uint16(21189),
		47: uint16(39149),
		48: uint16(35242),
		49: uint16(19971),
		50: uint16(26578),
		51: uint16(28422),
		52: uint16(20405),
		53: uint16(23522),
		54: uint16(26517),
		55: uint16(27784),
		56: uint16(28024),
		57: uint16(29723),
		58: uint16(30759),
		59: uint16(37341),
		60: uint16(37756),
		61: uint16(34756),
		62: uint16(31204),
		63: uint16(31281),
		64: uint16(24555),
		65: uint16(20182),
		66: uint16(21668),
		67: uint16(21822),
		68: uint16(22702),
		69: uint16(22949),
		70: uint16(24816),
		71: uint16(25171),
		72: uint16(25302),
		73: uint16(26422),
		74: uint16(26965),
		75: uint16(33333),
		76: uint16(38464),
		77: uint16(39345),
		78: uint16(39389),
		79: uint16(20524),
		80: uint16(21331),
		81: uint16(21828),
		82: uint16(22396),
		83: uint16(64001),
		84: uint16(25176),
		85: uint16(64002),
		86: uint16(25826),
		87: uint16(26219),
		88: uint16(26589),
		89: uint16(28609),
		90: uint16(28655),
		91: uint16(29730),
		92: uint16(29752),
		93: uint16(35351),
	},
	86: {
		0:  uint16(37944),
		1:  uint16(21585),
		2:  uint16(22022),
		3:  uint16(22374),
		4:  uint16(24392),
		5:  uint16(24986),
		6:  uint16(27470),
		7:  uint16(28760),
		8:  uint16(28845),
		9:  uint16(32187),
		10: uint16(35477),
		11: uint16(22890),
		12: uint16(33067),
		13: uint16(25506),
		14: uint16(30472),
		15: uint16(32829),
		16: uint16(36010),
		17: uint16(22612),
		18: uint16(25645),
		19: uint16(27067),
		20: uint16(23445),
		21: uint16(24081),
		22: uint16(28271),
		23: uint16(64003),
		24: uint16(34153),
		25: uint16(20812),
		26: uint16(21488),
		27: uint16(22826),
		28: uint16(24608),
		29: uint16(24907),
		30: uint16(27526),
		31: uint16(27760),
		32: uint16(27888),
		33: uint16(31518),
		34: uint16(32974),
		35: uint16(33492),
		36: uint16(36294),
		37: uint16(37040),
		38: uint16(39089),
		39: uint16(64004),
		40: uint16(25799),
		41: uint16(28580),
		42: uint16(25745),
		43: uint16(25860),
		44: uint16(20814),
		45: uint16(21520),
		46: uint16(22303),
		47: uint16(35342),
		48: uint16(24927),
		49: uint16(26742),
		50: uint16(64005),
		51: uint16(30171),
		52: uint16(31570),
		53: uint16(32113),
		54: uint16(36890),
		55: uint16(22534),
		56: uint16(27084),
		57: uint16(33151),
		58: uint16(35114),
		59: uint16(36864),
		60: uint16(38969),
		61: uint16(20600),
		62: uint16(22871),
		63: uint16(22956),
		64: uint16(25237),
		65: uint16(36879),
		66: uint16(39722),
		67: uint16(24925),
		68: uint16(29305),
		69: uint16(38358),
		70: uint16(22369),
		71: uint16(23110),
		72: uint16(24052),
		73: uint16(25226),
		74: uint16(25773),
		75: uint16(25850),
		76: uint16(26487),
		77: uint16(27874),
		78: uint16(27966),
		79: uint16(29228),
		80: uint16(29750),
		81: uint16(30772),
		82: uint16(32631),
		83: uint16(33453),
		84: uint16(36315),
		85: uint16(38935),
		86: uint16(21028),
		87: uint16(22338),
		88: uint16(26495),
		89: uint16(29256),
		90: uint16(29923),
		91: uint16(36009),
		92: uint16(36774),
		93: uint16(37393),
	},
	87: {
		0:  uint16(38442),
		1:  uint16(20843),
		2:  uint16(21485),
		3:  uint16(25420),
		4:  uint16(20329),
		5:  uint16(21764),
		6:  uint16(24726),
		7:  uint16(25943),
		8:  uint16(27803),
		9:  uint16(28031),
		10: uint16(29260),
		11: uint16(29437),
		12: uint16(31255),
		13: uint16(35207),
		14: uint16(35997),
		15: uint16(24429),
		16: uint16(28558),
		17: uint16(28921),
		18: uint16(33192),
		19: uint16(24846),
		20: uint16(20415),
		21: uint16(20559),
		22: uint16(25153),
		23: uint16(29255),
		24: uint16(31687),
		25: uint16(32232),
		26: uint16(32745),
		27: uint16(36941),
		28: uint16(38829),
		29: uint16(39449),
		30: uint16(36022),
		31: uint16(22378),
		32: uint16(24179),
		33: uint16(26544),
		34: uint16(33805),
		35: uint16(35413),
		36: uint16(21536),
		37: uint16(23318),
		38: uint16(24163),
		39: uint16(24290),
		40: uint16(24330),
		41: uint16(25987),
		42: uint16(32954),
		43: uint16(34109),
		44: uint16(38281),
		45: uint16(38491),
		46: uint16(20296),
		47: uint16(21253),
		48: uint16(21261),
		49: uint16(21263),
		50: uint16(21638),
		51: uint16(21754),
		52: uint16(22275),
		53: uint16(24067),
		54: uint16(24598),
		55: uint16(25243),
		56: uint16(25265),
		57: uint16(25429),
		58: uint16(64006),
		59: uint16(27873),
		60: uint16(28006),
		61: uint16(30129),
		62: uint16(30770),
		63: uint16(32990),
		64: uint16(33071),
		65: uint16(33502),
		66: uint16(33889),
		67: uint16(33970),
		68: uint16(34957),
		69: uint16(35090),
		70: uint16(36875),
		71: uint16(37610),
		72: uint16(39165),
		73: uint16(39825),
		74: uint16(24133),
		75: uint16(26292),
		76: uint16(26333),
		77: uint16(28689),
		78: uint16(29190),
		79: uint16(64007),
		80: uint16(20469),
		81: uint16(21117),
		82: uint16(24426),
		83: uint16(24915),
		84: uint16(26451),
		85: uint16(27161),
		86: uint16(28418),
		87: uint16(29922),
		88: uint16(31080),
		89: uint16(34920),
		90: uint16(35961),
		91: uint16(39111),
		92: uint16(39108),
		93: uint16(39491),
	},
	88: {
		0:  uint16(21697),
		1:  uint16(31263),
		2:  uint16(26963),
		3:  uint16(35575),
		4:  uint16(35914),
		5:  uint16(39080),
		6:  uint16(39342),
		7:  uint16(24444),
		8:  uint16(25259),
		9:  uint16(30130),
		10: uint16(30382),
		11: uint16(34987),
		12: uint16(36991),
		13: uint16(38466),
		14: uint16(21305),
		15: uint16(24380),
		16: uint16(24517),
		17: uint16(27852),
		18: uint16(29644),
		19: uint16(30050),
		20: uint16(30091),
		21: uint16(31558),
		22: uint16(33534),
		23: uint16(39325),
		24: uint16(20047),
		25: uint16(36924),
		26: uint16(19979),
		27: uint16(20309),
		28: uint16(21414),
		29: uint16(22799),
		30: uint16(24264),
		31: uint16(26160),
		32: uint16(27827),
		33: uint16(29781),
		34: uint16(33655),
		35: uint16(34662),
		36: uint16(36032),
		37: uint16(36944),
		38: uint16(38686),
		39: uint16(39957),
		40: uint16(22737),
		41: uint16(23416),
		42: uint16(34384),
		43: uint16(35604),
		44: uint16(40372),
		45: uint16(23506),
		46: uint16(24680),
		47: uint16(24717),
		48: uint16(26097),
		49: uint16(27735),
		50: uint16(28450),
		51: uint16(28579),
		52: uint16(28698),
		53: uint16(32597),
		54: uint16(32752),
		55: uint16(38289),
		56: uint16(38290),
		57: uint16(38480),
		58: uint16(38867),
		59: uint16(21106),
		60: uint16(36676),
		61: uint16(20989),
		62: uint16(21547),
		63: uint16(21688),
		64: uint16(21859),
		65: uint16(21898),
		66: uint16(27323),
		67: uint16(28085),
		68: uint16(32216),
		69: uint16(33382),
		70: uint16(37532),
		71: uint16(38519),
		72: uint16(40569),
		73: uint16(21512),
		74: uint16(21704),
		75: uint16(30418),
		76: uint16(34532),
		77: uint16(38308),
		78: uint16(38356),
		79: uint16(38492),
		80: uint16(20130),
		81: uint16(20233),
		82: uint16(23022),
		83: uint16(23270),
		84: uint16(24055),
		85: uint16(24658),
		86: uint16(25239),
		87: uint16(26477),
		88: uint16(26689),
		89: uint16(27782),
		90: uint16(28207),
		91: uint16(32568),
		92: uint16(32923),
		93: uint16(33322),
	},
	89: {
		0:  uint16(64008),
		1:  uint16(64009),
		2:  uint16(38917),
		3:  uint16(20133),
		4:  uint16(20565),
		5:  uint16(21683),
		6:  uint16(22419),
		7:  uint16(22874),
		8:  uint16(23401),
		9:  uint16(23475),
		10: uint16(25032),
		11: uint16(26999),
		12: uint16(28023),
		13: uint16(28707),
		14: uint16(34809),
		15: uint16(35299),
		16: uint16(35442),
		17: uint16(35559),
		18: uint16(36994),
		19: uint16(39405),
		20: uint16(39608),
		21: uint16(21182),
		22: uint16(26680),
		23: uint16(20502),
		24: uint16(24184),
		25: uint16(26447),
		26: uint16(33607),
		27: uint16(34892),
		28: uint16(20139),
		29: uint16(21521),
		30: uint16(22190),
		31: uint16(29670),
		32: uint16(37141),
		33: uint16(38911),
		34: uint16(39177),
		35: uint16(39255),
		36: uint16(39321),
		37: uint16(22099),
		38: uint16(22687),
		39: uint16(34395),
		40: uint16(35377),
		41: uint16(25010),
		42: uint16(27382),
		43: uint16(29563),
		44: uint16(36562),
		45: uint16(27463),
		46: uint16(38570),
		47: uint16(39511),
		48: uint16(22869),
		49: uint16(29184),
		50: uint16(36203),
		51: uint16(38761),
		52: uint16(20436),
		53: uint16(23796),
		54: uint16(24358),
		55: uint16(25080),
		56: uint16(26203),
		57: uint16(27883),
		58: uint16(28843),
		59: uint16(29572),
		60: uint16(29625),
		61: uint16(29694),
		62: uint16(30505),
		63: uint16(30541),
		64: uint16(32067),
		65: uint16(32098),
		66: uint16(32291),
		67: uint16(33335),
		68: uint16(34898),
		69: uint16(64010),
		70: uint16(36066),
		71: uint16(37449),
		72: uint16(39023),
		73: uint16(23377),
		74: uint16(31348),
		75: uint16(34880),
		76: uint16(38913),
		77: uint16(23244),
		78: uint16(20448),
		79: uint16(21332),
		80: uint16(22846),
		81: uint16(23805),
		82: uint16(25406),
		83: uint16(28025),
		84: uint16(29433),
		85: uint16(33029),
		86: uint16(33031),
		87: uint16(33698),
		88: uint16(37583),
		89: uint16(38960),
		90: uint16(20136),
		91: uint16(20804),
		92: uint16(21009),
		93: uint16(22411),
	},
	90: {
		0:  uint16(24418),
		1:  uint16(27842),
		2:  uint16(28366),
		3:  uint16(28677),
		4:  uint16(28752),
		5:  uint16(28847),
		6:  uint16(29074),
		7:  uint16(29673),
		8:  uint16(29801),
		9:  uint16(33610),
		10: uint16(34722),
		11: uint16(34913),
		12: uint16(36872),
		13: uint16(37026),
		14: uint16(37795),
		15: uint16(39336),
		16: uint16(20846),
		17: uint16(24407),
		18: uint16(24800),
		19: uint16(24935),
		20: uint16(26291),
		21: uint16(34137),
		22: uint16(36426),
		23: uint16(37295),
		24: uint16(38795),
		25: uint16(20046),
		26: uint16(20114),
		27: uint16(21628),
		28: uint16(22741),
		29: uint16(22778),
		30: uint16(22909),
		31: uint16(23733),
		32: uint16(24359),
		33: uint16(25142),
		34: uint16(25160),
		35: uint16(26122),
		36: uint16(26215),
		37: uint16(27627),
		38: uint16(28009),
		39: uint16(28111),
		40: uint16(28246),
		41: uint16(28408),
		42: uint16(28564),
		43: uint16(28640),
		44: uint16(28649),
		45: uint16(28765),
		46: uint16(29392),
		47: uint16(29733),
		48: uint16(29786),
		49: uint16(29920),
		50: uint16(30355),
		51: uint16(31068),
		52: uint16(31946),
		53: uint16(32286),
		54: uint16(32993),
		55: uint16(33446),
		56: uint16(33899),
		57: uint16(33983),
		58: uint16(34382),
		59: uint16(34399),
		60: uint16(34676),
		61: uint16(35703),
		62: uint16(35946),
		63: uint16(37804),
		64: uint16(38912),
		65: uint16(39013),
		66: uint16(24785),
		67: uint16(25110),
		68: uint16(37239),
		69: uint16(23130),
		70: uint16(26127),
		71: uint16(28151),
		72: uint16(28222),
		73: uint16(29759),
		74: uint16(39746),
		75: uint16(24573),
		76: uint16(24794),
		77: uint16(31503),
		78: uint16(21700),
		79: uint16(24344),
		80: uint16(27742),
		81: uint16(27859),
		82: uint16(27946),
		83: uint16(28888),
		84: uint16(32005),
		85: uint16(34425),
		86: uint16(35340),
		87: uint16(40251),
		88: uint16(21270),
		89: uint16(21644),
		90: uint16(23301),
		91: uint16(27194),
		92: uint16(28779),
		93: uint16(30069),
	},
	91: {
		0:  uint16(31117),
		1:  uint16(31166),
		2:  uint16(33457),
		3:  uint16(33775),
		4:  uint16(35441),
		5:  uint16(35649),
		6:  uint16(36008),
		7:  uint16(38772),
		8:  uint16(64011),
		9:  uint16(25844),
		10: uint16(25899),
		11: uint16(30906),
		12: uint16(30907),
		13: uint16(31339),
		14: uint16(20024),
		15: uint16(21914),
		16: uint16(22864),
		17: uint16(23462),
		18: uint16(24187),
		19: uint16(24739),
		20: uint16(25563),
		21: uint16(27489),
		22: uint16(26213),
		23: uint16(26707),
		24: uint16(28185),
		25: uint16(29029),
		26: uint16(29872),
		27: uint16(32008),
		28: uint16(36996),
		29: uint16(39529),
		30: uint16(39973),
		31: uint16(27963),
		32: uint16(28369),
		33: uint16(29502),
		34: uint16(35905),
		35: uint16(38346),
		36: uint16(20976),
		37: uint16(24140),
		38: uint16(24488),
		39: uint16(24653),
		40: uint16(24822),
		41: uint16(24880),
		42: uint16(24908),
		43: uint16(26179),
		44: uint16(26180),
		45: uint16(27045),
		46: uint16(27841),
		47: uint16(28255),
		48: uint16(28361),
		49: uint16(28514),
		50: uint16(29004),
		51: uint16(29852),
		52: uint16(30343),
		53: uint16(31681),
		54: uint16(31783),
		55: uint16(33618),
		56: uint16(34647),
		57: uint16(36945),
		58: uint16(38541),
		59: uint16(40643),
		60: uint16(21295),
		61: uint16(22238),
		62: uint16(24315),
		63: uint16(24458),
		64: uint16(24674),
		65: uint16(24724),
		66: uint16(25079),
		67: uint16(26214),
		68: uint16(26371),
		69: uint16(27292),
		70: uint16(28142),
		71: uint16(28590),
		72: uint16(28784),
		73: uint16(29546),
		74: uint16(32362),
		75: uint16(33214),
		76: uint16(33588),
		77: uint16(34516),
		78: uint16(35496),
		79: uint16(36036),
		80: uint16(21123),
		81: uint16(29554),
		82: uint16(23446),
		83: uint16(27243),
		84: uint16(37892),
		85: uint16(21742),
		86: uint16(22150),
		87: uint16(23389),
		88: uint16(25928),
		89: uint16(25989),
		90: uint16(26313),
		91: uint16(26783),
		92: uint16(28045),
		93: uint16(28102),
	},
	92: {
		0:  uint16(29243),
		1:  uint16(32948),
		2:  uint16(37237),
		3:  uint16(39501),
		4:  uint16(20399),
		5:  uint16(20505),
		6:  uint16(21402),
		7:  uint16(21518),
		8:  uint16(21564),
		9:  uint16(21897),
		10: uint16(21957),
		11: uint16(24127),
		12: uint16(24460),
		13: uint16(26429),
		14: uint16(29030),
		15: uint16(29661),
		16: uint16(36869),
		17: uint16(21211),
		18: uint16(21235),
		19: uint16(22628),
		20: uint16(22734),
		21: uint16(28932),
		22: uint16(29071),
		23: uint16(29179),
		24: uint16(34224),
		25: uint16(35347),
		26: uint16(26248),
		27: uint16(34216),
		28: uint16(21927),
		29: uint16(26244),
		30: uint16(29002),
		31: uint16(33841),
		32: uint16(21321),
		33: uint16(21913),
		34: uint16(27585),
		35: uint16(24409),
		36: uint16(24509),
		37: uint16(25582),
		38: uint16(26249),
		39: uint16(28999),
		40: uint16(35569),
		41: uint16(36637),
		42: uint16(40638),
		43: uint16(20241),
		44: uint16(25658),
		45: uint16(28875),
		46: uint16(30054),
		47: uint16(34407),
		48: uint16(24676),
		49: uint16(35662),
		50: uint16(40440),
		51: uint16(20807),
		52: uint16(20982),
		53: uint16(21256),
		54: uint16(27958),
		55: uint16(33016),
		56: uint16(40657),
		57: uint16(26133),
		58: uint16(27427),
		59: uint16(28824),
		60: uint16(30165),
		61: uint16(21507),
		62: uint16(23673),
		63: uint16(32007),
		64: uint16(35350),
		65: uint16(27424),
		66: uint16(27453),
		67: uint16(27462),
		68: uint16(21560),
		69: uint16(24688),
		70: uint16(27965),
		71: uint16(32725),
		72: uint16(33288),
		73: uint16(20694),
		74: uint16(20958),
		75: uint16(21916),
		76: uint16(22123),
		77: uint16(22221),
		78: uint16(23020),
		79: uint16(23305),
		80: uint16(24076),
		81: uint16(24985),
		82: uint16(24984),
		83: uint16(25137),
		84: uint16(26206),
		85: uint16(26342),
		86: uint16(29081),
		87: uint16(29113),
		88: uint16(29114),
		89: uint16(29351),
		90: uint16(31143),
		91: uint16(31232),
		92: uint16(32690),
		93: uint16(35440),
	},
}

var _rev_jis = [6879]uint16{
	0:    uint16(31),
	1:    uint16(80),
	2:    uint16(81),
	3:    uint16(87),
	4:    uint16(14),
	5:    uint16(299),
	6:    uint16(74),
	7:    uint16(61),
	8:    uint16(12),
	9:    uint16(344),
	10:   uint16(62),
	11:   uint16(63),
	12:   uint16(1280),
	13:   uint16(1281),
	14:   uint16(1282),
	15:   uint16(1283),
	16:   uint16(1284),
	17:   uint16(1285),
	18:   uint16(1286),
	19:   uint16(1287),
	20:   uint16(1288),
	21:   uint16(1289),
	22:   uint16(1290),
	23:   uint16(1291),
	24:   uint16(1292),
	25:   uint16(1293),
	26:   uint16(1294),
	27:   uint16(1295),
	28:   uint16(1296),
	29:   uint16(1297),
	30:   uint16(1298),
	31:   uint16(1299),
	32:   uint16(1300),
	33:   uint16(1301),
	34:   uint16(1302),
	35:   uint16(1303),
	36:   uint16(1312),
	37:   uint16(1313),
	38:   uint16(1314),
	39:   uint16(1315),
	40:   uint16(1316),
	41:   uint16(1317),
	42:   uint16(1318),
	43:   uint16(1319),
	44:   uint16(1320),
	45:   uint16(1321),
	46:   uint16(1322),
	47:   uint16(1323),
	48:   uint16(1324),
	49:   uint16(1325),
	50:   uint16(1326),
	51:   uint16(1327),
	52:   uint16(1328),
	53:   uint16(1329),
	54:   uint16(1330),
	55:   uint16(1331),
	56:   uint16(1332),
	57:   uint16(1333),
	58:   uint16(1334),
	59:   uint16(1335),
	60:   uint16(1542),
	61:   uint16(1536),
	62:   uint16(1537),
	63:   uint16(1538),
	64:   uint16(1539),
	65:   uint16(1540),
	66:   uint16(1541),
	67:   uint16(1543),
	68:   uint16(1544),
	69:   uint16(1545),
	70:   uint16(1546),
	71:   uint16(1547),
	72:   uint16(1548),
	73:   uint16(1549),
	74:   uint16(1550),
	75:   uint16(1551),
	76:   uint16(1552),
	77:   uint16(1553),
	78:   uint16(1554),
	79:   uint16(1555),
	80:   uint16(1556),
	81:   uint16(1557),
	82:   uint16(1558),
	83:   uint16(1559),
	84:   uint16(1560),
	85:   uint16(1561),
	86:   uint16(1562),
	87:   uint16(1563),
	88:   uint16(1564),
	89:   uint16(1565),
	90:   uint16(1566),
	91:   uint16(1567),
	92:   uint16(1568),
	93:   uint16(1584),
	94:   uint16(1585),
	95:   uint16(1586),
	96:   uint16(1587),
	97:   uint16(1588),
	98:   uint16(1589),
	99:   uint16(1591),
	100:  uint16(1592),
	101:  uint16(1593),
	102:  uint16(1594),
	103:  uint16(1595),
	104:  uint16(1596),
	105:  uint16(1597),
	106:  uint16(1598),
	107:  uint16(1599),
	108:  uint16(1600),
	109:  uint16(1601),
	110:  uint16(1602),
	111:  uint16(1603),
	112:  uint16(1604),
	113:  uint16(1605),
	114:  uint16(1606),
	115:  uint16(1607),
	116:  uint16(1608),
	117:  uint16(1609),
	118:  uint16(1610),
	119:  uint16(1611),
	120:  uint16(1612),
	121:  uint16(1613),
	122:  uint16(1614),
	123:  uint16(1615),
	124:  uint16(1616),
	125:  uint16(1590),
	126:  uint16(29),
	127:  uint16(28),
	128:  uint16(33),
	129:  uint16(37),
	130:  uint16(38),
	131:  uint16(39),
	132:  uint16(40),
	133:  uint16(342),
	134:  uint16(343),
	135:  uint16(36),
	136:  uint16(35),
	137:  uint16(338),
	138:  uint16(75),
	139:  uint16(76),
	140:  uint16(263),
	141:  uint16(77),
	142:  uint16(337),
	143:  uint16(266),
	144:  uint16(267),
	145:  uint16(265),
	146:  uint16(268),
	147:  uint16(300),
	148:  uint16(301),
	149:  uint16(302),
	150:  uint16(318),
	151:  uint16(303),
	152:  uint16(319),
	153:  uint16(281),
	154:  uint16(282),
	155:  uint16(60),
	156:  uint16(324),
	157:  uint16(326),
	158:  uint16(70),
	159:  uint16(315),
	160:  uint16(297),
	161:  uint16(298),
	162:  uint16(288),
	163:  uint16(287),
	164:  uint16(328),
	165:  uint16(329),
	166:  uint16(71),
	167:  uint16(327),
	168:  uint16(325),
	169:  uint16(321),
	170:  uint16(65),
	171:  uint16(320),
	172:  uint16(68),
	173:  uint16(69),
	174:  uint16(322),
	175:  uint16(323),
	176:  uint16(285),
	177:  uint16(286),
	178:  uint16(283),
	179:  uint16(284),
	180:  uint16(316),
	181:  uint16(317),
	182:  uint16(1792),
	183:  uint16(1803),
	184:  uint16(1793),
	185:  uint16(1804),
	186:  uint16(1794),
	187:  uint16(1805),
	188:  uint16(1795),
	189:  uint16(1806),
	190:  uint16(1797),
	191:  uint16(1808),
	192:  uint16(1796),
	193:  uint16(1807),
	194:  uint16(1798),
	195:  uint16(1819),
	196:  uint16(1814),
	197:  uint16(1809),
	198:  uint16(1800),
	199:  uint16(1821),
	200:  uint16(1816),
	201:  uint16(1811),
	202:  uint16(1799),
	203:  uint16(1815),
	204:  uint16(1820),
	205:  uint16(1810),
	206:  uint16(1801),
	207:  uint16(1817),
	208:  uint16(1822),
	209:  uint16(1812),
	210:  uint16(1802),
	211:  uint16(1818),
	212:  uint16(1823),
	213:  uint16(1813),
	214:  uint16(258),
	215:  uint16(257),
	216:  uint16(260),
	217:  uint16(259),
	218:  uint16(262),
	219:  uint16(261),
	220:  uint16(256),
	221:  uint16(93),
	222:  uint16(90),
	223:  uint16(92),
	224:  uint16(91),
	225:  uint16(349),
	226:  uint16(89),
	227:  uint16(88),
	228:  uint16(73),
	229:  uint16(72),
	230:  uint16(341),
	231:  uint16(340),
	232:  uint16(339),
	234:  uint16(1),
	235:  uint16(2),
	236:  uint16(22),
	237:  uint16(24),
	238:  uint16(25),
	239:  uint16(26),
	240:  uint16(49),
	241:  uint16(50),
	242:  uint16(51),
	243:  uint16(52),
	244:  uint16(53),
	245:  uint16(54),
	246:  uint16(55),
	247:  uint16(56),
	248:  uint16(57),
	249:  uint16(58),
	250:  uint16(264),
	251:  uint16(269),
	252:  uint16(43),
	253:  uint16(44),
	254:  uint16(32),
	255:  uint16(768),
	256:  uint16(769),
	257:  uint16(770),
	258:  uint16(771),
	259:  uint16(772),
	260:  uint16(773),
	261:  uint16(774),
	262:  uint16(775),
	263:  uint16(776),
	264:  uint16(777),
	265:  uint16(778),
	266:  uint16(779),
	267:  uint16(780),
	268:  uint16(781),
	269:  uint16(782),
	270:  uint16(783),
	271:  uint16(784),
	272:  uint16(785),
	273:  uint16(786),
	274:  uint16(787),
	275:  uint16(788),
	276:  uint16(789),
	277:  uint16(790),
	278:  uint16(791),
	279:  uint16(792),
	280:  uint16(793),
	281:  uint16(794),
	282:  uint16(795),
	283:  uint16(796),
	284:  uint16(797),
	285:  uint16(798),
	286:  uint16(799),
	287:  uint16(800),
	288:  uint16(801),
	289:  uint16(802),
	290:  uint16(803),
	291:  uint16(804),
	292:  uint16(805),
	293:  uint16(806),
	294:  uint16(807),
	295:  uint16(808),
	296:  uint16(809),
	297:  uint16(810),
	298:  uint16(811),
	299:  uint16(812),
	300:  uint16(813),
	301:  uint16(814),
	302:  uint16(815),
	303:  uint16(816),
	304:  uint16(817),
	305:  uint16(818),
	306:  uint16(819),
	307:  uint16(820),
	308:  uint16(821),
	309:  uint16(822),
	310:  uint16(823),
	311:  uint16(824),
	312:  uint16(825),
	313:  uint16(826),
	314:  uint16(827),
	315:  uint16(828),
	316:  uint16(829),
	317:  uint16(830),
	318:  uint16(831),
	319:  uint16(832),
	320:  uint16(833),
	321:  uint16(834),
	322:  uint16(835),
	323:  uint16(836),
	324:  uint16(837),
	325:  uint16(838),
	326:  uint16(839),
	327:  uint16(840),
	328:  uint16(841),
	329:  uint16(842),
	330:  uint16(843),
	331:  uint16(844),
	332:  uint16(845),
	333:  uint16(846),
	334:  uint16(847),
	335:  uint16(848),
	336:  uint16(849),
	337:  uint16(850),
	338:  uint16(10),
	339:  uint16(11),
	340:  uint16(20),
	341:  uint16(21),
	342:  uint16(1024),
	343:  uint16(1025),
	344:  uint16(1026),
	345:  uint16(1027),
	346:  uint16(1028),
	347:  uint16(1029),
	348:  uint16(1030),
	349:  uint16(1031),
	350:  uint16(1032),
	351:  uint16(1033),
	352:  uint16(1034),
	353:  uint16(1035),
	354:  uint16(1036),
	355:  uint16(1037),
	356:  uint16(1038),
	357:  uint16(1039),
	358:  uint16(1040),
	359:  uint16(1041),
	360:  uint16(1042),
	361:  uint16(1043),
	362:  uint16(1044),
	363:  uint16(1045),
	364:  uint16(1046),
	365:  uint16(1047),
	366:  uint16(1048),
	367:  uint16(1049),
	368:  uint16(1050),
	369:  uint16(1051),
	370:  uint16(1052),
	371:  uint16(1053),
	372:  uint16(1054),
	373:  uint16(1055),
	374:  uint16(1056),
	375:  uint16(1057),
	376:  uint16(1058),
	377:  uint16(1059),
	378:  uint16(1060),
	379:  uint16(1061),
	380:  uint16(1062),
	381:  uint16(1063),
	382:  uint16(1064),
	383:  uint16(1065),
	384:  uint16(1066),
	385:  uint16(1067),
	386:  uint16(1068),
	387:  uint16(1069),
	388:  uint16(1070),
	389:  uint16(1071),
	390:  uint16(1072),
	391:  uint16(1073),
	392:  uint16(1074),
	393:  uint16(1075),
	394:  uint16(1076),
	395:  uint16(1077),
	396:  uint16(1078),
	397:  uint16(1079),
	398:  uint16(1080),
	399:  uint16(1081),
	400:  uint16(1082),
	401:  uint16(1083),
	402:  uint16(1084),
	403:  uint16(1085),
	404:  uint16(1086),
	405:  uint16(1087),
	406:  uint16(1088),
	407:  uint16(1089),
	408:  uint16(1090),
	409:  uint16(1091),
	410:  uint16(1092),
	411:  uint16(1093),
	412:  uint16(1094),
	413:  uint16(1095),
	414:  uint16(1096),
	415:  uint16(1097),
	416:  uint16(1098),
	417:  uint16(1099),
	418:  uint16(1100),
	419:  uint16(1101),
	420:  uint16(1102),
	421:  uint16(1103),
	422:  uint16(1104),
	423:  uint16(1105),
	424:  uint16(1106),
	425:  uint16(1107),
	426:  uint16(1108),
	427:  uint16(1109),
	428:  uint16(5),
	429:  uint16(27),
	430:  uint16(18),
	431:  uint16(19),
	432:  uint16(3915),
	433:  uint16(8793),
	434:  uint16(6934),
	435:  uint16(10843),
	436:  uint16(7493),
	437:  uint16(6671),
	438:  uint16(7492),
	439:  uint16(4379),
	440:  uint16(10291),
	441:  uint16(11294),
	442:  uint16(12033),
	443:  uint16(4110),
	444:  uint16(4685),
	445:  uint16(12034),
	446:  uint16(7939),
	447:  uint16(12577),
	448:  uint16(5173),
	449:  uint16(10521),
	450:  uint16(7494),
	451:  uint16(11549),
	452:  uint16(10529),
	453:  uint16(12035),
	454:  uint16(8773),
	455:  uint16(12036),
	456:  uint16(5465),
	457:  uint16(12037),
	458:  uint16(4924),
	459:  uint16(8719),
	460:  uint16(6982),
	461:  uint16(12038),
	462:  uint16(12039),
	463:  uint16(12040),
	464:  uint16(9748),
	465:  uint16(5174),
	466:  uint16(9750),
	467:  uint16(9538),
	468:  uint16(5922),
	469:  uint16(10770),
	470:  uint16(18472),
	471:  uint16(12041),
	472:  uint16(7495),
	473:  uint16(12042),
	474:  uint16(4372),
	475:  uint16(5444),
	476:  uint16(5967),
	477:  uint16(11080),
	478:  uint16(13573),
	479:  uint16(11343),
	480:  uint16(9564),
	481:  uint16(4868),
	482:  uint16(5140),
	483:  uint16(12043),
	484:  uint16(12044),
	485:  uint16(11546),
	486:  uint16(11292),
	487:  uint16(8263),
	488:  uint16(12046),
	489:  uint16(6741),
	490:  uint16(9554),
	491:  uint16(12049),
	492:  uint16(4125),
	493:  uint16(5950),
	494:  uint16(5949),
	495:  uint16(3909),
	496:  uint16(11818),
	497:  uint16(11817),
	498:  uint16(6418),
	499:  uint16(3840),
	500:  uint16(12050),
	501:  uint16(12051),
	502:  uint16(12052),
	503:  uint16(10771),
	504:  uint16(12053),
	505:  uint16(5969),
	506:  uint16(3910),
	507:  uint16(10833),
	508:  uint16(5211),
	509:  uint16(5212),
	510:  uint16(5213),
	511:  uint16(9025),
	512:  uint16(11547),
	513:  uint16(12054),
	514:  uint16(12055),
	515:  uint16(12056),
	516:  uint16(7724),
	517:  uint16(7193),
	518:  uint16(7725),
	519:  uint16(12061),
	520:  uint16(12059),
	521:  uint16(12060),
	522:  uint16(5175),
	523:  uint16(6402),
	524:  uint16(4431),
	525:  uint16(12058),
	526:  uint16(12057),
	527:  uint16(10504),
	528:  uint16(6693),
	529:  uint16(6692),
	530:  uint16(8477),
	531:  uint16(12062),
	532:  uint16(10292),
	533:  uint16(8006),
	534:  uint16(23),
	535:  uint16(12063),
	536:  uint16(12065),
	537:  uint16(8516),
	538:  uint16(11584),
	539:  uint16(3881),
	540:  uint16(12064),
	541:  uint16(4381),
	542:  uint16(5411),
	543:  uint16(8774),
	544:  uint16(5710),
	545:  uint16(12066),
	546:  uint16(9731),
	547:  uint16(4938),
	548:  uint16(12067),
	549:  uint16(3882),
	550:  uint16(5951),
	551:  uint16(4939),
	552:  uint16(10329),
	553:  uint16(10001),
	554:  uint16(5176),
	555:  uint16(4432),
	556:  uint16(12102),
	557:  uint16(9248),
	558:  uint16(9803),
	559:  uint16(12069),
	560:  uint16(10011),
	561:  uint16(11585),
	562:  uint16(7692),
	563:  uint16(6694),
	564:  uint16(6742),
	565:  uint16(4383),
	566:  uint16(9008),
	567:  uint16(8705),
	568:  uint16(12073),
	569:  uint16(3883),
	570:  uint16(9026),
	571:  uint16(7194),
	572:  uint16(6419),
	573:  uint16(11267),
	574:  uint16(8493),
	575:  uint16(4382),
	576:  uint16(12072),
	577:  uint16(11293),
	578:  uint16(12068),
	579:  uint16(12070),
	580:  uint16(6477),
	581:  uint16(12071),
	582:  uint16(13315),
	583:  uint16(12079),
	584:  uint16(12082),
	585:  uint16(12080),
	586:  uint16(4385),
	587:  uint16(10522),
	588:  uint16(12074),
	589:  uint16(12078),
	590:  uint16(5970),
	591:  uint16(6695),
	592:  uint16(4869),
	593:  uint16(12083),
	594:  uint16(12075),
	595:  uint16(11586),
	596:  uint16(6743),
	597:  uint16(12076),
	598:  uint16(12081),
	599:  uint16(12084),
	600:  uint16(12077),
	601:  uint16(5376),
	602:  uint16(3884),
	603:  uint16(5377),
	604:  uint16(4384),
	605:  uint16(13316),
	606:  uint16(10840),
	607:  uint16(10317),
	608:  uint16(5971),
	609:  uint16(7694),
	610:  uint16(11542),
	611:  uint16(10551),
	612:  uint16(5655),
	613:  uint16(8452),
	614:  uint16(4419),
	615:  uint16(7218),
	616:  uint16(12088),
	617:  uint16(12093),
	618:  uint16(12091),
	619:  uint16(12086),
	620:  uint16(8462),
	621:  uint16(12089),
	622:  uint16(12092),
	623:  uint16(12090),
	624:  uint16(10556),
	625:  uint16(12087),
	626:  uint16(7693),
	627:  uint16(10834),
	628:  uint16(12094),
	629:  uint16(12095),
	630:  uint16(7171),
	631:  uint16(12108),
	632:  uint16(9775),
	633:  uint16(10261),
	634:  uint16(12103),
	635:  uint16(10575),
	636:  uint16(4373),
	637:  uint16(12107),
	638:  uint16(12101),
	639:  uint16(12110),
	640:  uint16(8241),
	641:  uint16(5923),
	642:  uint16(9787),
	643:  uint16(16166),
	644:  uint16(12109),
	645:  uint16(9276),
	646:  uint16(12098),
	647:  uint16(5973),
	648:  uint16(5972),
	649:  uint16(12096),
	650:  uint16(6969),
	651:  uint16(12104),
	652:  uint16(10574),
	653:  uint16(8748),
	654:  uint16(12100),
	655:  uint16(5712),
	656:  uint16(12097),
	657:  uint16(12105),
	658:  uint16(12099),
	659:  uint16(11568),
	660:  uint16(12106),
	661:  uint16(11808),
	662:  uint16(5445),
	663:  uint16(5711),
	664:  uint16(12111),
	665:  uint16(12112),
	666:  uint16(12116),
	667:  uint16(3885),
	668:  uint16(10543),
	669:  uint16(12115),
	670:  uint16(12114),
	671:  uint16(12118),
	672:  uint16(12117),
	673:  uint16(9027),
	674:  uint16(5713),
	675:  uint16(12119),
	676:  uint16(6948),
	677:  uint16(8453),
	678:  uint16(9028),
	679:  uint16(5461),
	680:  uint16(12120),
	681:  uint16(5141),
	682:  uint16(12121),
	683:  uint16(12123),
	684:  uint16(10772),
	685:  uint16(5701),
	686:  uint16(6672),
	687:  uint16(10070),
	688:  uint16(12122),
	689:  uint16(6436),
	690:  uint16(11298),
	691:  uint16(12125),
	692:  uint16(12290),
	693:  uint16(12124),
	694:  uint16(6435),
	695:  uint16(7260),
	696:  uint16(5656),
	697:  uint16(12291),
	698:  uint16(5422),
	699:  uint16(12288),
	700:  uint16(12289),
	701:  uint16(9486),
	702:  uint16(8283),
	703:  uint16(5378),
	704:  uint16(10796),
	705:  uint16(12292),
	706:  uint16(11548),
	707:  uint16(12293),
	708:  uint16(12296),
	709:  uint16(12294),
	710:  uint16(8237),
	711:  uint16(12295),
	712:  uint16(12297),
	713:  uint16(12299),
	714:  uint16(12298),
	715:  uint16(10535),
	716:  uint16(5142),
	717:  uint16(12301),
	718:  uint16(12302),
	719:  uint16(4366),
	720:  uint16(12300),
	721:  uint16(6995),
	722:  uint16(12305),
	723:  uint16(12304),
	724:  uint16(12303),
	725:  uint16(12085),
	726:  uint16(12306),
	727:  uint16(7261),
	728:  uint16(12307),
	729:  uint16(11268),
	730:  uint16(11064),
	731:  uint16(12309),
	732:  uint16(12308),
	733:  uint16(12311),
	734:  uint16(12310),
	735:  uint16(12312),
	736:  uint16(12313),
	737:  uint16(3923),
	738:  uint16(5908),
	739:  uint16(5658),
	740:  uint16(7195),
	741:  uint16(8794),
	742:  uint16(5379),
	743:  uint16(8007),
	744:  uint16(5974),
	745:  uint16(6221),
	746:  uint16(12315),
	747:  uint16(11047),
	748:  uint16(9253),
	749:  uint16(6744),
	750:  uint16(12314),
	751:  uint16(12316),
	752:  uint16(9277),
	753:  uint16(4692),
	754:  uint16(12317),
	755:  uint16(9565),
	756:  uint16(8211),
	757:  uint16(12319),
	758:  uint16(12320),
	759:  uint16(9995),
	760:  uint16(5975),
	761:  uint16(11802),
	762:  uint16(12321),
	763:  uint16(5381),
	764:  uint16(10523),
	765:  uint16(8469),
	766:  uint16(5456),
	767:  uint16(9236),
	768:  uint16(5714),
	769:  uint16(12322),
	770:  uint16(12323),
	771:  uint16(9537),
	772:  uint16(4158),
	773:  uint16(12326),
	774:  uint16(6492),
	775:  uint16(12325),
	776:  uint16(6437),
	777:  uint16(12327),
	778:  uint16(17741),
	779:  uint16(12328),
	780:  uint16(10784),
	781:  uint16(12329),
	782:  uint16(12330),
	783:  uint16(12331),
	784:  uint16(7496),
	785:  uint16(6955),
	786:  uint16(4870),
	787:  uint16(12334),
	788:  uint16(12332),
	789:  uint16(11036),
	790:  uint16(12333),
	791:  uint16(10297),
	792:  uint16(12335),
	793:  uint16(12336),
	794:  uint16(12337),
	795:  uint16(9278),
	796:  uint16(12341),
	797:  uint16(12339),
	798:  uint16(12340),
	799:  uint16(12338),
	800:  uint16(6466),
	801:  uint16(12342),
	802:  uint16(11081),
	803:  uint16(11587),
	804:  uint16(12343),
	805:  uint16(7943),
	806:  uint16(12344),
	807:  uint16(7225),
	808:  uint16(12345),
	809:  uint16(8795),
	810:  uint16(11550),
	811:  uint16(9279),
	812:  uint16(12580),
	813:  uint16(12346),
	814:  uint16(21252),
	815:  uint16(5412),
	816:  uint16(12347),
	817:  uint16(10813),
	818:  uint16(7239),
	819:  uint16(8539),
	820:  uint16(12349),
	821:  uint16(9539),
	822:  uint16(12350),
	823:  uint16(12351),
	824:  uint16(4621),
	825:  uint16(12352),
	826:  uint16(5382),
	827:  uint16(9515),
	828:  uint16(4185),
	829:  uint16(7215),
	830:  uint16(9984),
	831:  uint16(12353),
	832:  uint16(9280),
	833:  uint16(7726),
	834:  uint16(12354),
	835:  uint16(10507),
	836:  uint16(7993),
	837:  uint16(4865),
	838:  uint16(4872),
	839:  uint16(12355),
	840:  uint16(12357),
	841:  uint16(5657),
	842:  uint16(12356),
	843:  uint16(11602),
	844:  uint16(7240),
	845:  uint16(10012),
	846:  uint16(10539),
	847:  uint16(12358),
	848:  uint16(11351),
	849:  uint16(12359),
	850:  uint16(12360),
	851:  uint16(9309),
	852:  uint16(12361),
	853:  uint16(7944),
	854:  uint16(6493),
	855:  uint16(5715),
	856:  uint16(12362),
	857:  uint16(6696),
	858:  uint16(6222),
	859:  uint16(9029),
	860:  uint16(12364),
	861:  uint16(8454),
	862:  uint16(6478),
	863:  uint16(12365),
	864:  uint16(12366),
	865:  uint16(8207),
	866:  uint16(12363),
	867:  uint16(12368),
	868:  uint16(10773),
	869:  uint16(6211),
	870:  uint16(12367),
	871:  uint16(5716),
	872:  uint16(6461),
	873:  uint16(9804),
	874:  uint16(12371),
	875:  uint16(12369),
	876:  uint16(10330),
	877:  uint16(7497),
	878:  uint16(12378),
	879:  uint16(4675),
	880:  uint16(12372),
	881:  uint16(12370),
	882:  uint16(8238),
	883:  uint16(12374),
	884:  uint16(12373),
	885:  uint16(4643),
	886:  uint16(5695),
	887:  uint16(12379),
	888:  uint16(11532),
	889:  uint16(12375),
	890:  uint16(12380),
	891:  uint16(12377),
	892:  uint16(12376),
	893:  uint16(11566),
	894:  uint16(5976),
	895:  uint16(4386),
	896:  uint16(11603),
	897:  uint16(7252),
	898:  uint16(9271),
	899:  uint16(6212),
	900:  uint16(12545),
	901:  uint16(12546),
	902:  uint16(11588),
	903:  uint16(11786),
	904:  uint16(12548),
	905:  uint16(5977),
	906:  uint16(12547),
	907:  uint16(4622),
	908:  uint16(12549),
	909:  uint16(10805),
	910:  uint16(8987),
	911:  uint16(11269),
	912:  uint16(10552),
	913:  uint16(12550),
	914:  uint16(20276),
	915:  uint16(9487),
	916:  uint16(12551),
	917:  uint16(4873),
	918:  uint16(11026),
	919:  uint16(7424),
	920:  uint16(12552),
	921:  uint16(10566),
	922:  uint16(12556),
	923:  uint16(7945),
	924:  uint16(12553),
	925:  uint16(5423),
	926:  uint16(12554),
	927:  uint16(4874),
	928:  uint16(5645),
	929:  uint16(12557),
	930:  uint16(12558),
	931:  uint16(12559),
	932:  uint16(12560),
	933:  uint16(6970),
	934:  uint16(5978),
	935:  uint16(11069),
	936:  uint16(11079),
	937:  uint16(9558),
	938:  uint16(10576),
	939:  uint16(12561),
	940:  uint16(12562),
	941:  uint16(12564),
	942:  uint16(12566),
	943:  uint16(12565),
	944:  uint16(12567),
	945:  uint16(4380),
	946:  uint16(10795),
	947:  uint16(6491),
	948:  uint16(12568),
	949:  uint16(8248),
	950:  uint16(7425),
	951:  uint16(5384),
	952:  uint16(12569),
	953:  uint16(10042),
	954:  uint16(12570),
	955:  uint16(12571),
	956:  uint16(12572),
	957:  uint16(12573),
	958:  uint16(10243),
	959:  uint16(5447),
	960:  uint16(3908),
	961:  uint16(9502),
	962:  uint16(12574),
	963:  uint16(7196),
	964:  uint16(8008),
	965:  uint16(12576),
	966:  uint16(12575),
	967:  uint16(7426),
	968:  uint16(5952),
	969:  uint16(12578),
	970:  uint16(10013),
	971:  uint16(12579),
	972:  uint16(10043),
	973:  uint16(8467),
	974:  uint16(8525),
	975:  uint16(5383),
	976:  uint16(9549),
	977:  uint16(8720),
	978:  uint16(9805),
	979:  uint16(10797),
	980:  uint16(12581),
	981:  uint16(8009),
	982:  uint16(5652),
	983:  uint16(12582),
	984:  uint16(12583),
	985:  uint16(4107),
	986:  uint16(3924),
	987:  uint16(4940),
	988:  uint16(8455),
	989:  uint16(5168),
	990:  uint16(11344),
	991:  uint16(12586),
	992:  uint16(4374),
	993:  uint16(12585),
	994:  uint16(5385),
	995:  uint16(12587),
	996:  uint16(11088),
	997:  uint16(12588),
	998:  uint16(11569),
	999:  uint16(5979),
	1000: uint16(5909),
	1001: uint16(12589),
	1002: uint16(12591),
	1003: uint16(12590),
	1004: uint16(7742),
	1005: uint16(4120),
	1006: uint16(4157),
	1007: uint16(12592),
	1008: uint16(12593),
	1009: uint16(5910),
	1010: uint16(12594),
	1011: uint16(5197),
	1012: uint16(6673),
	1013: uint16(12595),
	1014: uint16(10835),
	1015: uint16(6420),
	1016: uint16(5177),
	1017: uint16(11270),
	1018: uint16(8239),
	1019: uint16(10014),
	1020: uint16(7004),
	1021: uint16(7206),
	1022: uint16(6983),
	1023: uint16(6996),
	1024: uint16(7253),
	1025: uint16(10015),
	1026: uint16(12598),
	1027: uint16(4130),
	1028: uint16(8240),
	1029: uint16(5980),
	1030: uint16(5924),
	1031: uint16(5446),
	1032: uint16(12602),
	1033: uint16(8704),
	1034: uint16(8541),
	1035: uint16(5386),
	1036: uint16(7427),
	1037: uint16(12603),
	1038: uint16(12601),
	1039: uint16(4387),
	1040: uint16(8517),
	1041: uint16(6935),
	1042: uint16(6698),
	1043: uint16(4101),
	1044: uint16(4687),
	1045: uint16(6213),
	1046: uint16(6697),
	1047: uint16(12604),
	1048: uint16(12605),
	1049: uint16(5160),
	1050: uint16(4645),
	1051: uint16(6214),
	1052: uint16(5159),
	1053: uint16(9022),
	1054: uint16(4100),
	1055: uint16(9488),
	1056: uint16(11037),
	1057: uint16(6144),
	1058: uint16(11352),
	1059: uint16(9254),
	1060: uint16(5981),
	1061: uint16(5646),
	1062: uint16(12614),
	1063: uint16(5442),
	1064: uint16(10793),
	1065: uint16(10044),
	1066: uint16(12613),
	1067: uint16(4925),
	1068: uint16(12608),
	1069: uint16(12609),
	1070: uint16(12611),
	1071: uint16(12612),
	1072: uint16(5178),
	1073: uint16(7744),
	1074: uint16(10508),
	1075: uint16(12610),
	1076: uint16(12606),
	1077: uint16(5954),
	1078: uint16(12607),
	1079: uint16(11779),
	1080: uint16(10577),
	1081: uint16(9031),
	1082: uint16(5953),
	1083: uint16(6223),
	1084: uint16(12615),
	1085: uint16(9532),
	1086: uint16(12619),
	1087: uint16(7005),
	1088: uint16(6997),
	1089: uint16(12622),
	1090: uint16(12620),
	1091: uint16(11010),
	1092: uint16(12617),
	1093: uint16(12626),
	1094: uint16(12621),
	1095: uint16(12624),
	1096: uint16(5925),
	1097: uint16(11038),
	1098: uint16(12625),
	1099: uint16(12627),
	1100: uint16(12629),
	1101: uint16(6479),
	1102: uint16(11809),
	1103: uint16(12618),
	1104: uint16(12616),
	1105: uint16(12628),
	1106: uint16(12623),
	1107: uint16(12631),
	1108: uint16(12802),
	1109: uint16(12633),
	1110: uint16(12637),
	1111: uint16(12800),
	1112: uint16(12634),
	1113: uint16(12829),
	1114: uint16(6472),
	1115: uint16(4624),
	1116: uint16(12632),
	1117: uint16(12804),
	1118: uint16(3925),
	1119: uint16(12803),
	1120: uint16(3844),
	1121: uint16(10281),
	1122: uint16(12801),
	1123: uint16(12635),
	1124: uint16(12630),
	1125: uint16(12636),
	1126: uint16(6439),
	1127: uint16(12805),
	1128: uint16(3926),
	1129: uint16(12814),
	1130: uint16(12806),
	1131: uint16(12807),
	1132: uint16(7428),
	1133: uint16(10824),
	1134: uint16(12812),
	1135: uint16(12811),
	1136: uint16(9230),
	1137: uint16(12813),
	1138: uint16(12810),
	1139: uint16(4115),
	1140: uint16(6421),
	1141: uint16(7695),
	1142: uint16(12808),
	1143: uint16(9281),
	1144: uint16(12809),
	1145: uint16(3841),
	1146: uint16(12819),
	1147: uint16(11266),
	1148: uint16(7430),
	1149: uint16(12825),
	1150: uint16(12824),
	1151: uint16(12815),
	1152: uint16(8482),
	1153: uint16(12816),
	1154: uint16(8526),
	1155: uint16(12821),
	1156: uint16(7429),
	1157: uint16(12818),
	1158: uint16(11075),
	1159: uint16(5659),
	1160: uint16(12822),
	1161: uint16(12823),
	1162: uint16(12820),
	1163: uint16(12826),
	1164: uint16(12817),
	1165: uint16(12832),
	1166: uint16(12837),
	1167: uint16(12833),
	1168: uint16(12828),
	1169: uint16(12838),
	1170: uint16(8208),
	1171: uint16(12840),
	1172: uint16(6145),
	1173: uint16(12830),
	1174: uint16(8796),
	1175: uint16(12834),
	1176: uint16(12827),
	1177: uint16(4876),
	1178: uint16(4941),
	1179: uint16(4676),
	1180: uint16(12835),
	1181: uint16(12831),
	1182: uint16(5717),
	1183: uint16(12841),
	1184: uint16(12839),
	1185: uint16(8242),
	1186: uint16(5161),
	1187: uint16(5387),
	1188: uint16(12836),
	1189: uint16(5459),
	1190: uint16(4131),
	1191: uint16(12845),
	1192: uint16(12843),
	1193: uint16(13062),
	1194: uint16(12848),
	1195: uint16(12842),
	1196: uint16(12846),
	1197: uint16(12844),
	1198: uint16(6699),
	1199: uint16(12847),
	1200: uint16(12850),
	1201: uint16(12855),
	1202: uint16(12853),
	1203: uint16(12852),
	1204: uint16(8721),
	1205: uint16(4388),
	1206: uint16(12849),
	1207: uint16(12851),
	1208: uint16(7431),
	1209: uint16(4114),
	1210: uint16(12854),
	1211: uint16(4413),
	1212: uint16(12865),
	1213: uint16(7515),
	1214: uint16(12861),
	1215: uint16(12859),
	1216: uint16(12860),
	1217: uint16(12862),
	1218: uint16(4124),
	1219: uint16(8216),
	1220: uint16(12856),
	1221: uint16(12857),
	1222: uint16(4697),
	1223: uint16(12864),
	1224: uint16(4942),
	1225: uint16(12867),
	1226: uint16(12863),
	1227: uint16(12866),
	1228: uint16(10509),
	1229: uint16(9524),
	1230: uint16(10007),
	1231: uint16(12869),
	1232: uint16(12868),
	1233: uint16(4644),
	1234: uint16(12870),
	1235: uint16(12873),
	1236: uint16(12872),
	1237: uint16(12871),
	1238: uint16(9752),
	1239: uint16(12874),
	1240: uint16(12875),
	1241: uint16(12877),
	1242: uint16(12876),
	1243: uint16(12879),
	1244: uint16(12882),
	1245: uint16(12880),
	1246: uint16(12878),
	1247: uint16(12881),
	1248: uint16(12883),
	1249: uint16(12884),
	1250: uint16(12885),
	1251: uint16(12886),
	1252: uint16(12887),
	1253: uint16(12324),
	1254: uint16(7003),
	1255: uint16(6700),
	1256: uint16(4434),
	1257: uint16(3927),
	1258: uint16(8739),
	1259: uint16(12888),
	1260: uint16(6403),
	1261: uint16(3886),
	1262: uint16(7741),
	1263: uint16(12889),
	1264: uint16(5926),
	1265: uint16(6224),
	1266: uint16(12891),
	1267: uint16(12890),
	1268: uint16(10559),
	1269: uint16(12892),
	1270: uint16(13056),
	1271: uint16(12893),
	1272: uint16(13057),
	1273: uint16(13058),
	1274: uint16(5718),
	1275: uint16(4159),
	1276: uint16(13059),
	1277: uint16(13061),
	1278: uint16(13060),
	1279: uint16(13063),
	1280: uint16(9273),
	1281: uint16(13064),
	1282: uint16(3860),
	1283: uint16(6462),
	1284: uint16(5660),
	1285: uint16(8750),
	1286: uint16(13065),
	1287: uint16(13066),
	1288: uint16(13068),
	1289: uint16(13069),
	1290: uint16(6467),
	1291: uint16(5424),
	1292: uint16(10774),
	1293: uint16(13067),
	1294: uint16(13070),
	1295: uint16(6432),
	1296: uint16(6146),
	1297: uint16(13074),
	1298: uint16(6404),
	1299: uint16(8722),
	1300: uint16(13071),
	1301: uint16(9017),
	1302: uint16(13075),
	1303: uint16(7745),
	1304: uint16(13073),
	1305: uint16(13076),
	1306: uint16(5662),
	1307: uint16(13077),
	1308: uint16(13078),
	1309: uint16(6147),
	1310: uint16(4639),
	1311: uint16(13080),
	1312: uint16(13081),
	1313: uint16(13082),
	1314: uint16(13079),
	1315: uint16(13072),
	1316: uint16(13083),
	1317: uint16(13084),
	1318: uint16(10819),
	1319: uint16(7498),
	1320: uint16(13086),
	1321: uint16(13087),
	1322: uint16(13085),
	1323: uint16(13089),
	1324: uint16(9751),
	1325: uint16(3911),
	1326: uint16(10293),
	1327: uint16(13090),
	1328: uint16(7516),
	1329: uint16(6936),
	1330: uint16(9788),
	1331: uint16(4943),
	1332: uint16(6474),
	1333: uint16(10808),
	1334: uint16(9489),
	1335: uint16(5719),
	1336: uint16(8494),
	1337: uint16(13088),
	1338: uint16(13091),
	1339: uint16(8483),
	1340: uint16(13092),
	1341: uint16(13093),
	1342: uint16(13095),
	1343: uint16(9032),
	1344: uint16(4877),
	1345: uint16(21248),
	1346: uint16(4160),
	1347: uint16(10578),
	1348: uint16(7499),
	1349: uint16(9255),
	1350: uint16(6469),
	1351: uint16(13101),
	1352: uint16(10524),
	1353: uint16(11580),
	1354: uint16(4435),
	1355: uint16(13097),
	1356: uint16(8217),
	1357: uint16(13100),
	1358: uint16(9282),
	1359: uint16(9256),
	1360: uint16(9283),
	1361: uint16(10008),
	1362: uint16(9004),
	1363: uint16(6440),
	1364: uint16(13096),
	1365: uint16(4181),
	1366: uint16(9237),
	1367: uint16(13098),
	1368: uint16(13094),
	1369: uint16(7727),
	1370: uint16(13102),
	1371: uint16(7213),
	1372: uint16(5388),
	1373: uint16(13103),
	1374: uint16(10567),
	1375: uint16(8284),
	1376: uint16(8997),
	1377: uint16(13105),
	1378: uint16(10798),
	1379: uint16(13106),
	1380: uint16(13111),
	1381: uint16(10510),
	1382: uint16(13110),
	1383: uint16(13104),
	1384: uint16(13107),
	1385: uint16(13109),
	1386: uint16(6405),
	1387: uint16(10536),
	1388: uint16(13112),
	1389: uint16(8740),
	1390: uint16(4436),
	1391: uint16(7500),
	1392: uint16(13114),
	1393: uint16(13113),
	1394: uint16(6215),
	1395: uint16(13115),
	1396: uint16(13117),
	1397: uint16(13116),
	1398: uint16(13119),
	1399: uint16(13108),
	1400: uint16(13121),
	1401: uint16(13120),
	1402: uint16(13118),
	1403: uint16(6701),
	1404: uint16(7728),
	1405: uint16(8243),
	1406: uint16(13122),
	1407: uint16(7963),
	1408: uint16(3916),
	1409: uint16(9795),
	1410: uint16(9018),
	1411: uint16(13124),
	1412: uint16(13123),
	1413: uint16(13125),
	1414: uint16(13126),
	1415: uint16(13127),
	1416: uint16(13128),
	1417: uint16(10544),
	1418: uint16(13129),
	1419: uint16(4389),
	1420: uint16(13130),
	1421: uint16(11291),
	1422: uint16(4623),
	1423: uint16(12584),
	1424: uint16(7207),
	1425: uint16(8478),
	1426: uint16(13131),
	1427: uint16(11082),
	1428: uint16(11027),
	1429: uint16(13133),
	1430: uint16(8518),
	1431: uint16(9238),
	1432: uint16(8479),
	1433: uint16(10294),
	1434: uint16(13134),
	1435: uint16(13135),
	1436: uint16(4186),
	1437: uint16(6937),
	1438: uint16(13136),
	1439: uint16(3887),
	1440: uint16(13137),
	1441: uint16(13138),
	1442: uint16(4161),
	1443: uint16(4944),
	1444: uint16(9535),
	1445: uint16(10579),
	1446: uint16(13142),
	1447: uint16(8244),
	1448: uint16(13141),
	1449: uint16(5663),
	1450: uint16(10810),
	1451: uint16(13140),
	1452: uint16(9284),
	1453: uint16(13144),
	1454: uint16(13143),
	1455: uint16(13146),
	1456: uint16(13145),
	1457: uint16(4187),
	1458: uint16(13147),
	1459: uint16(7432),
	1460: uint16(13149),
	1461: uint16(8708),
	1462: uint16(13148),
	1463: uint16(10514),
	1464: uint16(7254),
	1465: uint16(9274),
	1466: uint16(13312),
	1467: uint16(6148),
	1468: uint16(13313),
	1469: uint16(9728),
	1470: uint16(10045),
	1471: uint16(11056),
	1472: uint16(9732),
	1473: uint16(13322),
	1474: uint16(5143),
	1475: uint16(11300),
	1476: uint16(11022),
	1477: uint16(13579),
	1478: uint16(13314),
	1479: uint16(13317),
	1480: uint16(8484),
	1481: uint16(10775),
	1482: uint16(9257),
	1483: uint16(13318),
	1484: uint16(10820),
	1485: uint16(6441),
	1486: uint16(7433),
	1487: uint16(13319),
	1488: uint16(6703),
	1489: uint16(6702),
	1490: uint16(3864),
	1491: uint16(5927),
	1492: uint16(7946),
	1493: uint16(3888),
	1494: uint16(13323),
	1495: uint16(13324),
	1496: uint16(13321),
	1497: uint16(4119),
	1498: uint16(4878),
	1499: uint16(13320),
	1500: uint16(11044),
	1501: uint16(10256),
	1502: uint16(3847),
	1503: uint16(3928),
	1504: uint16(6704),
	1505: uint16(3889),
	1506: uint16(3842),
	1507: uint16(13329),
	1508: uint16(13327),
	1509: uint16(11035),
	1510: uint16(13330),
	1511: uint16(13328),
	1512: uint16(13326),
	1513: uint16(7696),
	1514: uint16(13325),
	1515: uint16(10553),
	1516: uint16(5955),
	1517: uint16(13334),
	1518: uint16(13335),
	1519: uint16(7434),
	1520: uint16(13331),
	1521: uint16(11787),
	1522: uint16(9771),
	1523: uint16(13333),
	1524: uint16(6406),
	1525: uint16(13336),
	1526: uint16(10295),
	1527: uint16(13337),
	1528: uint16(13332),
	1529: uint16(11034),
	1530: uint16(9789),
	1531: uint16(13338),
	1532: uint16(10257),
	1533: uint16(13339),
	1534: uint16(13343),
	1535: uint16(13340),
	1536: uint16(4390),
	1537: uint16(13342),
	1538: uint16(6938),
	1539: uint16(13341),
	1540: uint16(5720),
	1541: uint16(13355),
	1542: uint16(13348),
	1543: uint16(13345),
	1544: uint16(8771),
	1545: uint16(13344),
	1546: uint16(13346),
	1547: uint16(13347),
	1548: uint16(13349),
	1549: uint16(13350),
	1550: uint16(4945),
	1551: uint16(13352),
	1552: uint16(13351),
	1553: uint16(13353),
	1554: uint16(7501),
	1555: uint16(13356),
	1556: uint16(9019),
	1557: uint16(4132),
	1558: uint16(13354),
	1559: uint16(13357),
	1560: uint16(13358),
	1561: uint16(13361),
	1562: uint16(13359),
	1563: uint16(13360),
	1564: uint16(6705),
	1565: uint16(13362),
	1566: uint16(6149),
	1567: uint16(13363),
	1568: uint16(6745),
	1569: uint16(8471),
	1570: uint16(13364),
	1571: uint16(13365),
	1572: uint16(6713),
	1573: uint16(6150),
	1574: uint16(11057),
	1575: uint16(5127),
	1576: uint16(5928),
	1577: uint16(13366),
	1578: uint16(4663),
	1579: uint16(13367),
	1580: uint16(8472),
	1581: uint16(13368),
	1582: uint16(13570),
	1583: uint16(13369),
	1584: uint16(13370),
	1585: uint16(13371),
	1586: uint16(13373),
	1587: uint16(13374),
	1588: uint16(13375),
	1589: uint16(8527),
	1590: uint16(4102),
	1591: uint16(6984),
	1592: uint16(3873),
	1593: uint16(8246),
	1594: uint16(4879),
	1595: uint16(6932),
	1596: uint16(6151),
	1597: uint16(9285),
	1598: uint16(7168),
	1599: uint16(4880),
	1600: uint16(8775),
	1601: uint16(9033),
	1602: uint16(3863),
	1603: uint16(5144),
	1604: uint16(10580),
	1605: uint16(6945),
	1606: uint16(5169),
	1607: uint16(8010),
	1608: uint16(6939),
	1609: uint16(11271),
	1610: uint16(13376),
	1611: uint16(5179),
	1612: uint16(6442),
	1613: uint16(4625),
	1614: uint16(4162),
	1615: uint16(7435),
	1616: uint16(4391),
	1617: uint16(13377),
	1618: uint16(11301),
	1619: uint16(7208),
	1620: uint16(6979),
	1621: uint16(13378),
	1622: uint16(4946),
	1623: uint16(9521),
	1624: uint16(11016),
	1625: uint16(13379),
	1626: uint16(13380),
	1627: uint16(10296),
	1628: uint16(13382),
	1629: uint16(4871),
	1630: uint16(5462),
	1631: uint16(13381),
	1632: uint16(4881),
	1633: uint16(7697),
	1634: uint16(13386),
	1635: uint16(6656),
	1636: uint16(4392),
	1637: uint16(13385),
	1638: uint16(13383),
	1639: uint16(13387),
	1640: uint16(13384),
	1641: uint16(9738),
	1642: uint16(15148),
	1643: uint16(7698),
	1644: uint16(13388),
	1645: uint16(11551),
	1646: uint16(13389),
	1647: uint16(13391),
	1648: uint16(8797),
	1649: uint16(13390),
	1650: uint16(7938),
	1651: uint16(6746),
	1652: uint16(8495),
	1653: uint16(6998),
	1654: uint16(10324),
	1655: uint16(8011),
	1656: uint16(6956),
	1657: uint16(13392),
	1658: uint16(7436),
	1659: uint16(13393),
	1660: uint16(13394),
	1661: uint16(3890),
	1662: uint16(8473),
	1663: uint16(7729),
	1664: uint16(13395),
	1665: uint16(9490),
	1666: uint16(7437),
	1667: uint16(7438),
	1668: uint16(13396),
	1669: uint16(8012),
	1670: uint16(7439),
	1671: uint16(13397),
	1672: uint16(13398),
	1673: uint16(11071),
	1674: uint16(13399),
	1675: uint16(5413),
	1676: uint16(7169),
	1677: uint16(13400),
	1678: uint16(13401),
	1679: uint16(6971),
	1680: uint16(7691),
	1681: uint16(9555),
	1682: uint16(7731),
	1683: uint16(10071),
	1684: uint16(9729),
	1685: uint16(5416),
	1686: uint16(13402),
	1687: uint16(5198),
	1688: uint16(13403),
	1689: uint16(5469),
	1690: uint16(9518),
	1691: uint16(4367),
	1692: uint16(6706),
	1693: uint16(13404),
	1694: uint16(13569),
	1695: uint16(13568),
	1696: uint16(5468),
	1697: uint16(13405),
	1698: uint16(9239),
	1699: uint16(8463),
	1700: uint16(9258),
	1701: uint16(6951),
	1702: uint16(8247),
	1703: uint16(11353),
	1704: uint16(13571),
	1705: uint16(13572),
	1706: uint16(9525),
	1707: uint16(6674),
	1708: uint16(13574),
	1709: uint16(13575),
	1710: uint16(13576),
	1711: uint16(4947),
	1712: uint16(13577),
	1713: uint16(13578),
	1714: uint16(4363),
	1715: uint16(8218),
	1716: uint16(4931),
	1717: uint16(13580),
	1718: uint16(11015),
	1719: uint16(8497),
	1720: uint16(4664),
	1721: uint16(13582),
	1722: uint16(13584),
	1723: uint16(4926),
	1724: uint16(13581),
	1725: uint16(13583),
	1726: uint16(13586),
	1727: uint16(13585),
	1728: uint16(13587),
	1729: uint16(13588),
	1730: uint16(9500),
	1731: uint16(5389),
	1732: uint16(4420),
	1733: uint16(13589),
	1734: uint16(13594),
	1735: uint16(13592),
	1736: uint16(10582),
	1737: uint16(10581),
	1738: uint16(9286),
	1739: uint16(13591),
	1740: uint16(7219),
	1741: uint16(13590),
	1742: uint16(7761),
	1743: uint16(13595),
	1744: uint16(6473),
	1745: uint16(13601),
	1746: uint16(13602),
	1747: uint16(13596),
	1748: uint16(4626),
	1749: uint16(13597),
	1750: uint16(13606),
	1751: uint16(13605),
	1752: uint16(13604),
	1753: uint16(13600),
	1754: uint16(13599),
	1755: uint16(13603),
	1756: uint16(10583),
	1757: uint16(13610),
	1758: uint16(13607),
	1759: uint16(13609),
	1760: uint16(11345),
	1761: uint16(13608),
	1762: uint16(13598),
	1763: uint16(7762),
	1764: uint16(13611),
	1765: uint16(6422),
	1766: uint16(13612),
	1767: uint16(13613),
	1768: uint16(13616),
	1769: uint16(13615),
	1770: uint16(13614),
	1771: uint16(9287),
	1772: uint16(13593),
	1773: uint16(13622),
	1774: uint16(13618),
	1775: uint16(13617),
	1776: uint16(13619),
	1777: uint16(13620),
	1778: uint16(13623),
	1779: uint16(11589),
	1780: uint16(13624),
	1781: uint16(13621),
	1782: uint16(13625),
	1783: uint16(4927),
	1784: uint16(13626),
	1785: uint16(13628),
	1786: uint16(13627),
	1787: uint16(13629),
	1788: uint16(13630),
	1789: uint16(8013),
	1790: uint16(7170),
	1791: uint16(7235),
	1792: uint16(8258),
	1793: uint16(6152),
	1794: uint16(6423),
	1795: uint16(6153),
	1796: uint16(5199),
	1797: uint16(13631),
	1798: uint16(6424),
	1799: uint16(5929),
	1800: uint16(13632),
	1801: uint16(11013),
	1802: uint16(9762),
	1803: uint16(13633),
	1804: uint16(6154),
	1805: uint16(4875),
	1806: uint16(8710),
	1807: uint16(5425),
	1808: uint16(6707),
	1809: uint16(10298),
	1810: uint16(10016),
	1811: uint16(13634),
	1812: uint16(4948),
	1813: uint16(13637),
	1814: uint16(8960),
	1815: uint16(13636),
	1816: uint16(13635),
	1817: uint16(13638),
	1818: uint16(9034),
	1819: uint16(7746),
	1820: uint16(6708),
	1821: uint16(7977),
	1822: uint16(8498),
	1823: uint16(5121),
	1824: uint16(8961),
	1825: uint16(13639),
	1826: uint16(13640),
	1827: uint16(7502),
	1828: uint16(10776),
	1829: uint16(13643),
	1830: uint16(13642),
	1831: uint16(13641),
	1832: uint16(10332),
	1833: uint16(13650),
	1834: uint16(10809),
	1835: uint16(13644),
	1836: uint16(13646),
	1837: uint16(10826),
	1838: uint16(13645),
	1839: uint16(13647),
	1840: uint16(9991),
	1841: uint16(13648),
	1842: uint16(10525),
	1843: uint16(13649),
	1844: uint16(4882),
	1845: uint16(10526),
	1846: uint16(9742),
	1847: uint16(13651),
	1848: uint16(13652),
	1849: uint16(6155),
	1850: uint16(4883),
	1851: uint16(13653),
	1852: uint16(5911),
	1853: uint16(11299),
	1854: uint16(11272),
	1855: uint16(4949),
	1856: uint16(13655),
	1857: uint16(8962),
	1858: uint16(6156),
	1859: uint16(7440),
	1860: uint16(10046),
	1861: uint16(7441),
	1862: uint16(7255),
	1863: uint16(9035),
	1864: uint16(10584),
	1865: uint16(9240),
	1866: uint16(6157),
	1867: uint16(10299),
	1868: uint16(13656),
	1869: uint16(9272),
	1870: uint16(6433),
	1871: uint16(5930),
	1872: uint16(9036),
	1873: uint16(3874),
	1874: uint16(7245),
	1875: uint16(6158),
	1876: uint16(11302),
	1877: uint16(13657),
	1878: uint16(13658),
	1879: uint16(9776),
	1880: uint16(13659),
	1881: uint16(11606),
	1882: uint16(11788),
	1883: uint16(13661),
	1884: uint16(13660),
	1885: uint16(4646),
	1886: uint16(13824),
	1887: uint16(13827),
	1888: uint16(13828),
	1889: uint16(13826),
	1890: uint16(10271),
	1891: uint16(7442),
	1892: uint16(13830),
	1893: uint16(13829),
	1894: uint16(13825),
	1895: uint16(13831),
	1896: uint16(13832),
	1897: uint16(13833),
	1898: uint16(13836),
	1899: uint16(13834),
	1900: uint16(13835),
	1901: uint16(13837),
	1902: uint16(4163),
	1903: uint16(9037),
	1904: uint16(13838),
	1905: uint16(5721),
	1906: uint16(4437),
	1907: uint16(9749),
	1908: uint16(13839),
	1909: uint16(9562),
	1910: uint16(10554),
	1911: uint16(13840),
	1912: uint16(11789),
	1913: uint16(13841),
	1914: uint16(10527),
	1915: uint16(13844),
	1916: uint16(12032),
	1917: uint16(12048),
	1918: uint16(6927),
	1919: uint16(9556),
	1920: uint16(13845),
	1921: uint16(5180),
	1922: uint16(8963),
	1923: uint16(3929),
	1924: uint16(13846),
	1925: uint16(10501),
	1926: uint16(6159),
	1927: uint16(8751),
	1928: uint16(9038),
	1929: uint16(11086),
	1930: uint16(5912),
	1931: uint16(5931),
	1932: uint16(13847),
	1933: uint16(13848),
	1934: uint16(13854),
	1935: uint16(6980),
	1936: uint16(8964),
	1937: uint16(5390),
	1938: uint16(13849),
	1939: uint16(10250),
	1940: uint16(8741),
	1941: uint16(13850),
	1942: uint16(13851),
	1943: uint16(5391),
	1944: uint16(13852),
	1945: uint16(13853),
	1946: uint16(13855),
	1947: uint16(9301),
	1948: uint16(13856),
	1949: uint16(13857),
	1950: uint16(13858),
	1951: uint16(13843),
	1952: uint16(13842),
	1953: uint16(13859),
	1954: uint16(5664),
	1955: uint16(10246),
	1956: uint16(6443),
	1957: uint16(10262),
	1958: uint16(8965),
	1959: uint16(10282),
	1960: uint16(13860),
	1961: uint16(7443),
	1962: uint16(4133),
	1963: uint16(13861),
	1964: uint16(13862),
	1965: uint16(11089),
	1966: uint16(10047),
	1967: uint16(13865),
	1968: uint16(4188),
	1969: uint16(7947),
	1970: uint16(13864),
	1971: uint16(13863),
	1972: uint16(5665),
	1973: uint16(8499),
	1974: uint16(13869),
	1975: uint16(13867),
	1976: uint16(13866),
	1977: uint16(11526),
	1978: uint16(5956),
	1979: uint16(7256),
	1980: uint16(13868),
	1981: uint16(9259),
	1982: uint16(7197),
	1983: uint16(9503),
	1984: uint16(13872),
	1985: uint16(13871),
	1986: uint16(13870),
	1987: uint16(13873),
	1988: uint16(5957),
	1989: uint16(13874),
	1990: uint16(10331),
	1991: uint16(7226),
	1992: uint16(13875),
	1993: uint16(10072),
	1994: uint16(9504),
	1995: uint16(8966),
	1996: uint16(9231),
	1997: uint16(13876),
	1998: uint16(5130),
	1999: uint16(7699),
	2000: uint16(10251),
	2001: uint16(4950),
	2002: uint16(9733),
	2003: uint16(13877),
	2004: uint16(6709),
	2005: uint16(10777),
	2006: uint16(10778),
	2007: uint16(4189),
	2008: uint16(13882),
	2009: uint16(8776),
	2010: uint16(13879),
	2011: uint16(4438),
	2012: uint16(14092),
	2013: uint16(13881),
	2014: uint16(9743),
	2015: uint16(13880),
	2016: uint16(13878),
	2017: uint16(6233),
	2018: uint16(13884),
	2019: uint16(13890),
	2020: uint16(13896),
	2021: uint16(13888),
	2022: uint16(9275),
	2023: uint16(13893),
	2024: uint16(10300),
	2025: uint16(13887),
	2026: uint16(13892),
	2027: uint16(11590),
	2028: uint16(6710),
	2029: uint16(8500),
	2030: uint16(13885),
	2031: uint16(5181),
	2032: uint16(13895),
	2033: uint16(7948),
	2034: uint16(4164),
	2035: uint16(13889),
	2036: uint16(4439),
	2037: uint16(13894),
	2038: uint16(5392),
	2039: uint16(13891),
	2040: uint16(13897),
	2041: uint16(13899),
	2042: uint16(13909),
	2043: uint16(13907),
	2044: uint16(13904),
	2045: uint16(13903),
	2046: uint16(11607),
	2047: uint16(13905),
	2048: uint16(5393),
	2049: uint16(6160),
	2050: uint16(7257),
	2051: uint16(13912),
	2052: uint16(13898),
	2053: uint16(13902),
	2054: uint16(13886),
	2055: uint16(4441),
	2056: uint16(13906),
	2057: uint16(13908),
	2058: uint16(8752),
	2059: uint16(6407),
	2060: uint16(4375),
	2061: uint16(13900),
	2062: uint16(13911),
	2063: uint16(13910),
	2064: uint16(5394),
	2065: uint16(8456),
	2066: uint16(4677),
	2067: uint16(5666),
	2068: uint16(13901),
	2069: uint16(13913),
	2070: uint16(13916),
	2071: uint16(14080),
	2072: uint16(6940),
	2073: uint16(14086),
	2074: uint16(9039),
	2075: uint16(13914),
	2076: uint16(14084),
	2077: uint16(4440),
	2078: uint16(14082),
	2079: uint16(14083),
	2080: uint16(13917),
	2081: uint16(14081),
	2082: uint16(5958),
	2083: uint16(11273),
	2084: uint16(4884),
	2085: uint16(4152),
	2086: uint16(14085),
	2087: uint16(9753),
	2088: uint16(3852),
	2089: uint16(10048),
	2090: uint16(13883),
	2091: uint16(14091),
	2092: uint16(14095),
	2093: uint16(11076),
	2094: uint16(14088),
	2095: uint16(9288),
	2096: uint16(14093),
	2097: uint16(7503),
	2098: uint16(14094),
	2099: uint16(9526),
	2100: uint16(11814),
	2101: uint16(14090),
	2102: uint16(14096),
	2103: uint16(6234),
	2104: uint16(7978),
	2105: uint16(3891),
	2106: uint16(14089),
	2107: uint16(14087),
	2108: uint16(8249),
	2109: uint16(13915),
	2110: uint16(6675),
	2111: uint16(8485),
	2112: uint16(14108),
	2113: uint16(8250),
	2114: uint16(14103),
	2115: uint16(14100),
	2116: uint16(14101),
	2117: uint16(6981),
	2118: uint16(14104),
	2119: uint16(14107),
	2120: uint16(14102),
	2121: uint16(7172),
	2122: uint16(14105),
	2123: uint16(14099),
	2124: uint16(11099),
	2125: uint16(11098),
	2126: uint16(14109),
	2127: uint16(14110),
	2128: uint16(3892),
	2129: uint16(14098),
	2130: uint16(5457),
	2131: uint16(3845),
	2132: uint16(4885),
	2133: uint16(14106),
	2134: uint16(14114),
	2135: uint16(14113),
	2136: uint16(14118),
	2137: uint16(14119),
	2138: uint16(14117),
	2139: uint16(14120),
	2140: uint16(14112),
	2141: uint16(14116),
	2142: uint16(14121),
	2143: uint16(14122),
	2144: uint16(14111),
	2145: uint16(6747),
	2146: uint16(14115),
	2147: uint16(8501),
	2148: uint16(6161),
	2149: uint16(14097),
	2150: uint16(7700),
	2151: uint16(14135),
	2152: uint16(10568),
	2153: uint16(14125),
	2154: uint16(14126),
	2155: uint16(14127),
	2156: uint16(14134),
	2157: uint16(14133),
	2158: uint16(10844),
	2159: uint16(4886),
	2160: uint16(14131),
	2161: uint16(5668),
	2162: uint16(4627),
	2163: uint16(14128),
	2164: uint16(11543),
	2165: uint16(14130),
	2166: uint16(3893),
	2167: uint16(14132),
	2168: uint16(14123),
	2169: uint16(14129),
	2170: uint16(14136),
	2171: uint16(5667),
	2172: uint16(14124),
	2173: uint16(11324),
	2174: uint16(11274),
	2175: uint16(14139),
	2176: uint16(14143),
	2177: uint16(8285),
	2178: uint16(11608),
	2179: uint16(14144),
	2180: uint16(14141),
	2181: uint16(14138),
	2182: uint16(14137),
	2183: uint16(14142),
	2184: uint16(10511),
	2185: uint16(9491),
	2186: uint16(5669),
	2187: uint16(14145),
	2188: uint16(14140),
	2189: uint16(14146),
	2190: uint16(5722),
	2191: uint16(4368),
	2192: uint16(14154),
	2193: uint16(4887),
	2194: uint16(14152),
	2195: uint16(14153),
	2196: uint16(6408),
	2197: uint16(14151),
	2198: uint16(14149),
	2199: uint16(14148),
	2200: uint16(14155),
	2201: uint16(14147),
	2202: uint16(14157),
	2203: uint16(4442),
	2204: uint16(14159),
	2205: uint16(14158),
	2206: uint16(8967),
	2207: uint16(14162),
	2208: uint16(14160),
	2209: uint16(14150),
	2210: uint16(5723),
	2211: uint16(14161),
	2212: uint16(14165),
	2213: uint16(14164),
	2214: uint16(14166),
	2215: uint16(14163),
	2216: uint16(14167),
	2217: uint16(14168),
	2218: uint16(14169),
	2219: uint16(10569),
	2220: uint16(14171),
	2221: uint16(14170),
	2222: uint16(7198),
	2223: uint16(7949),
	2224: uint16(4421),
	2225: uint16(4443),
	2226: uint16(14172),
	2227: uint16(3870),
	2228: uint16(7979),
	2229: uint16(14173),
	2230: uint16(19234),
	2231: uint16(14336),
	2232: uint16(5696),
	2233: uint16(14337),
	2234: uint16(8014),
	2235: uint16(14338),
	2236: uint16(14339),
	2237: uint16(5145),
	2238: uint16(14340),
	2239: uint16(14341),
	2240: uint16(14342),
	2241: uint16(8502),
	2242: uint16(5932),
	2243: uint16(11072),
	2244: uint16(10779),
	2245: uint16(7241),
	2246: uint16(14343),
	2247: uint16(8015),
	2248: uint16(19740),
	2249: uint16(10049),
	2250: uint16(6985),
	2251: uint16(6444),
	2252: uint16(14344),
	2253: uint16(8486),
	2254: uint16(10502),
	2255: uint16(8528),
	2256: uint16(14347),
	2257: uint16(14345),
	2258: uint16(14348),
	2259: uint16(14346),
	2260: uint16(14349),
	2261: uint16(10512),
	2262: uint16(3862),
	2263: uint16(10301),
	2264: uint16(10050),
	2265: uint16(14350),
	2266: uint16(14353),
	2267: uint16(7444),
	2268: uint16(5146),
	2269: uint16(14351),
	2270: uint16(14358),
	2271: uint16(7445),
	2272: uint16(14352),
	2273: uint16(9763),
	2274: uint16(11325),
	2275: uint16(14354),
	2276: uint16(14355),
	2277: uint16(14359),
	2278: uint16(9289),
	2279: uint16(14356),
	2280: uint16(6162),
	2281: uint16(7997),
	2282: uint16(14373),
	2283: uint16(10003),
	2284: uint16(8529),
	2285: uint16(10051),
	2286: uint16(14604),
	2287: uint16(10585),
	2288: uint16(9040),
	2289: uint16(10836),
	2290: uint16(14362),
	2291: uint16(4352),
	2292: uint16(8777),
	2293: uint16(14371),
	2294: uint16(8723),
	2295: uint16(14365),
	2296: uint16(14372),
	2297: uint16(14367),
	2298: uint16(14374),
	2299: uint16(14370),
	2300: uint16(14369),
	2301: uint16(9806),
	2302: uint16(14363),
	2303: uint16(4444),
	2304: uint16(14361),
	2305: uint16(5200),
	2306: uint16(8530),
	2307: uint16(14357),
	2308: uint16(14360),
	2309: uint16(6163),
	2310: uint16(7994),
	2311: uint16(7446),
	2312: uint16(14368),
	2313: uint16(9777),
	2314: uint16(5201),
	2315: uint16(4647),
	2316: uint16(4678),
	2317: uint16(7680),
	2318: uint16(14376),
	2319: uint16(14381),
	2320: uint16(14377),
	2321: uint16(5724),
	2322: uint16(14382),
	2323: uint16(6657),
	2324: uint16(6216),
	2325: uint16(7173),
	2326: uint16(14364),
	2327: uint16(6748),
	2328: uint16(14379),
	2329: uint16(6711),
	2330: uint16(14380),
	2331: uint16(3875),
	2332: uint16(14375),
	2333: uint16(8968),
	2334: uint16(5202),
	2335: uint16(5395),
	2336: uint16(14378),
	2337: uint16(3846),
	2338: uint16(6434),
	2339: uint16(7701),
	2340: uint16(9041),
	2341: uint16(10035),
	2342: uint16(14384),
	2343: uint16(8253),
	2344: uint16(8457),
	2345: uint16(6666),
	2346: uint16(14385),
	2347: uint16(14387),
	2348: uint16(14383),
	2349: uint16(10560),
	2350: uint16(8988),
	2351: uint16(8251),
	2352: uint16(10586),
	2353: uint16(6957),
	2354: uint16(14399),
	2355: uint16(14398),
	2356: uint16(7767),
	2357: uint16(5725),
	2358: uint16(14392),
	2359: uint16(7448),
	2360: uint16(9543),
	2361: uint16(9744),
	2362: uint16(14390),
	2363: uint16(8252),
	2364: uint16(6999),
	2365: uint16(14395),
	2366: uint16(7447),
	2367: uint16(14389),
	2368: uint16(14394),
	2369: uint16(9778),
	2370: uint16(14388),
	2371: uint16(5632),
	2372: uint16(4668),
	2373: uint16(14396),
	2374: uint16(11530),
	2375: uint16(6445),
	2376: uint16(8724),
	2377: uint16(14393),
	2378: uint16(7995),
	2379: uint16(6164),
	2380: uint16(7747),
	2381: uint16(4165),
	2382: uint16(8219),
	2383: uint16(14391),
	2384: uint16(5156),
	2385: uint16(5670),
	2386: uint16(9006),
	2387: uint16(14397),
	2388: uint16(8254),
	2389: uint16(14400),
	2390: uint16(14402),
	2391: uint16(8470),
	2392: uint16(14408),
	2393: uint16(14403),
	2394: uint16(14405),
	2395: uint16(10272),
	2396: uint16(9042),
	2397: uint16(14406),
	2398: uint16(11275),
	2399: uint16(11303),
	2400: uint16(4888),
	2401: uint16(3853),
	2402: uint16(14404),
	2403: uint16(14401),
	2404: uint16(4951),
	2405: uint16(4166),
	2406: uint16(14407),
	2407: uint16(11304),
	2408: uint16(14411),
	2409: uint16(8474),
	2410: uint16(14418),
	2411: uint16(14412),
	2412: uint16(14409),
	2413: uint16(14416),
	2414: uint16(14386),
	2415: uint16(14413),
	2416: uint16(14417),
	2417: uint16(10017),
	2418: uint16(9290),
	2419: uint16(14410),
	2420: uint16(14414),
	2421: uint16(5671),
	2422: uint16(6480),
	2423: uint16(7996),
	2424: uint16(14422),
	2425: uint16(9221),
	2426: uint16(14419),
	2427: uint16(10815),
	2428: uint16(14420),
	2429: uint16(14421),
	2430: uint16(11053),
	2431: uint16(7937),
	2432: uint16(5697),
	2433: uint16(14428),
	2434: uint16(6676),
	2435: uint16(14425),
	2436: uint16(14424),
	2437: uint16(9745),
	2438: uint16(9492),
	2439: uint16(9232),
	2440: uint16(14426),
	2441: uint16(14427),
	2442: uint16(10318),
	2443: uint16(9764),
	2444: uint16(6658),
	2445: uint16(8016),
	2446: uint16(10799),
	2447: uint16(4648),
	2448: uint16(14596),
	2449: uint16(14429),
	2450: uint16(11305),
	2451: uint16(14598),
	2452: uint16(14594),
	2453: uint16(14595),
	2454: uint16(8255),
	2455: uint16(14593),
	2456: uint16(14366),
	2457: uint16(14597),
	2458: uint16(14592),
	2459: uint16(14602),
	2460: uint16(14603),
	2461: uint16(9222),
	2462: uint16(14605),
	2463: uint16(6659),
	2464: uint16(14600),
	2465: uint16(5147),
	2466: uint16(14606),
	2467: uint16(14599),
	2468: uint16(14610),
	2469: uint16(14609),
	2470: uint16(14608),
	2471: uint16(14611),
	2472: uint16(14613),
	2473: uint16(7504),
	2474: uint16(14612),
	2475: uint16(14616),
	2476: uint16(14614),
	2477: uint16(14615),
	2478: uint16(14415),
	2479: uint16(14618),
	2480: uint16(14617),
	2481: uint16(14423),
	2482: uint16(14619),
	2483: uint16(14607),
	2484: uint16(6712),
	2485: uint16(14620),
	2486: uint16(14621),
	2487: uint16(14623),
	2488: uint16(14622),
	2489: uint16(14624),
	2490: uint16(4445),
	2491: uint16(6165),
	2492: uint16(10587),
	2493: uint16(7950),
	2494: uint16(5933),
	2495: uint16(14626),
	2496: uint16(14629),
	2497: uint16(10289),
	2498: uint16(5182),
	2499: uint16(14628),
	2500: uint16(14627),
	2501: uint16(9779),
	2502: uint16(14630),
	2503: uint16(5396),
	2504: uint16(14632),
	2505: uint16(14631),
	2506: uint16(4889),
	2507: uint16(6677),
	2508: uint16(9527),
	2509: uint16(5672),
	2510: uint16(7763),
	2511: uint16(14633),
	2512: uint16(7951),
	2513: uint16(9223),
	2514: uint16(10302),
	2515: uint16(14634),
	2516: uint16(14635),
	2517: uint16(14636),
	2518: uint16(10519),
	2519: uint16(13372),
	2520: uint16(7973),
	2521: uint16(10283),
	2522: uint16(6455),
	2523: uint16(10052),
	2524: uint16(10018),
	2525: uint16(9260),
	2526: uint16(11552),
	2527: uint16(14638),
	2528: uint16(6959),
	2529: uint16(14639),
	2530: uint16(3861),
	2531: uint16(5427),
	2532: uint16(7980),
	2533: uint16(10303),
	2534: uint16(14640),
	2535: uint16(6689),
	2536: uint16(8742),
	2537: uint16(6714),
	2538: uint16(7702),
	2539: uint16(14641),
	2540: uint16(10588),
	2541: uint16(4182),
	2542: uint16(6715),
	2543: uint16(14644),
	2544: uint16(14642),
	2545: uint16(14645),
	2546: uint16(11544),
	2547: uint16(14643),
	2548: uint16(8026),
	2549: uint16(14646),
	2550: uint16(8465),
	2551: uint16(14647),
	2552: uint16(4953),
	2553: uint16(14649),
	2554: uint16(14648),
	2555: uint16(14650),
	2556: uint16(14651),
	2557: uint16(4954),
	2558: uint16(9563),
	2559: uint16(8725),
	2560: uint16(5195),
	2561: uint16(6716),
	2562: uint16(8256),
	2563: uint16(7227),
	2564: uint16(3855),
	2565: uint16(14652),
	2566: uint16(4353),
	2567: uint16(14656),
	2568: uint16(6166),
	2569: uint16(14655),
	2570: uint16(6410),
	2571: uint16(7449),
	2572: uint16(14654),
	2573: uint16(7450),
	2574: uint16(11039),
	2575: uint16(6409),
	2576: uint16(3894),
	2577: uint16(7981),
	2578: uint16(14661),
	2579: uint16(7952),
	2580: uint16(4134),
	2581: uint16(7220),
	2582: uint16(10821),
	2583: uint16(6481),
	2584: uint16(7451),
	2585: uint16(7942),
	2586: uint16(14660),
	2587: uint16(14658),
	2588: uint16(14659),
	2589: uint16(8778),
	2590: uint16(14853),
	2591: uint16(14665),
	2592: uint16(6749),
	2593: uint16(6167),
	2594: uint16(14663),
	2595: uint16(14664),
	2596: uint16(7703),
	2597: uint16(14662),
	2598: uint16(6670),
	2599: uint16(14667),
	2600: uint16(14666),
	2601: uint16(14671),
	2602: uint16(14672),
	2603: uint16(14668),
	2604: uint16(4609),
	2605: uint16(14669),
	2606: uint16(14670),
	2607: uint16(10036),
	2608: uint16(10304),
	2609: uint16(5673),
	2610: uint16(14673),
	2611: uint16(7953),
	2612: uint16(7452),
	2613: uint16(8753),
	2614: uint16(5414),
	2615: uint16(14674),
	2616: uint16(14678),
	2617: uint16(4394),
	2618: uint16(14675),
	2619: uint16(14677),
	2620: uint16(14676),
	2621: uint16(7242),
	2622: uint16(8743),
	2623: uint16(3876),
	2624: uint16(14679),
	2625: uint16(14680),
	2626: uint16(8969),
	2627: uint16(11600),
	2628: uint16(6690),
	2629: uint16(10570),
	2630: uint16(10780),
	2631: uint16(14849),
	2632: uint16(14682),
	2633: uint16(14685),
	2634: uint16(14684),
	2635: uint16(14681),
	2636: uint16(14848),
	2637: uint16(9533),
	2638: uint16(14683),
	2639: uint16(14850),
	2640: uint16(7243),
	2641: uint16(14851),
	2642: uint16(11306),
	2643: uint16(9815),
	2644: uint16(14852),
	2645: uint16(14854),
	2646: uint16(14855),
	2647: uint16(14856),
	2648: uint16(5417),
	2649: uint16(4135),
	2650: uint16(6168),
	2651: uint16(14857),
	2652: uint16(14858),
	2653: uint16(7248),
	2654: uint16(8257),
	2655: uint16(12599),
	2656: uint16(8221),
	2657: uint16(8220),
	2658: uint16(8503),
	2659: uint16(6438),
	2660: uint16(12113),
	2661: uint16(5709),
	2662: uint16(11276),
	2663: uint16(10589),
	2664: uint16(10333),
	2665: uint16(14859),
	2666: uint16(6482),
	2667: uint16(8990),
	2668: uint16(14860),
	2669: uint16(11790),
	2670: uint16(10781),
	2671: uint16(8970),
	2672: uint16(14861),
	2673: uint16(4955),
	2674: uint16(14862),
	2675: uint16(14863),
	2676: uint16(11065),
	2677: uint16(11011),
	2678: uint16(10837),
	2679: uint16(10811),
	2680: uint16(6660),
	2681: uint16(14865),
	2682: uint16(6986),
	2683: uint16(10800),
	2684: uint16(14867),
	2685: uint16(14870),
	2686: uint16(14869),
	2687: uint16(4952),
	2688: uint16(5183),
	2689: uint16(14866),
	2690: uint16(14868),
	2691: uint16(14871),
	2692: uint16(7768),
	2693: uint16(11354),
	2694: uint16(3880),
	2695: uint16(6463),
	2696: uint16(8475),
	2697: uint16(6972),
	2698: uint16(7506),
	2699: uint16(14874),
	2700: uint16(9261),
	2701: uint16(14872),
	2702: uint16(8458),
	2703: uint16(14873),
	2704: uint16(7505),
	2705: uint16(11068),
	2706: uint16(14875),
	2707: uint16(14876),
	2708: uint16(11335),
	2709: uint16(14881),
	2710: uint16(6169),
	2711: uint16(9780),
	2712: uint16(14878),
	2713: uint16(9291),
	2714: uint16(14653),
	2715: uint16(14657),
	2716: uint16(5166),
	2717: uint16(9766),
	2718: uint16(14880),
	2719: uint16(7453),
	2720: uint16(10019),
	2721: uint16(14886),
	2722: uint16(10073),
	2723: uint16(14877),
	2724: uint16(14883),
	2725: uint16(14882),
	2726: uint16(7982),
	2727: uint16(10828),
	2728: uint16(11570),
	2729: uint16(10822),
	2730: uint16(4395),
	2731: uint16(6717),
	2732: uint16(11815),
	2733: uint16(14885),
	2734: uint16(7764),
	2735: uint16(14884),
	2736: uint16(14879),
	2737: uint16(5934),
	2738: uint16(14891),
	2739: uint16(14889),
	2740: uint16(4396),
	2741: uint16(14887),
	2742: uint16(14893),
	2743: uint16(14899),
	2744: uint16(8487),
	2745: uint16(10528),
	2746: uint16(14901),
	2747: uint16(10241),
	2748: uint16(14900),
	2749: uint16(9807),
	2750: uint16(10782),
	2751: uint16(4890),
	2752: uint16(8022),
	2753: uint16(7199),
	2754: uint16(9010),
	2755: uint16(11277),
	2756: uint16(14896),
	2757: uint16(14895),
	2758: uint16(14897),
	2759: uint16(14894),
	2760: uint16(14902),
	2761: uint16(14892),
	2762: uint16(14890),
	2763: uint16(14898),
	2764: uint16(14888),
	2765: uint16(8779),
	2766: uint16(11095),
	2767: uint16(6949),
	2768: uint16(6483),
	2769: uint16(6425),
	2770: uint16(10830),
	2771: uint16(4640),
	2772: uint16(9005),
	2773: uint16(9513),
	2774: uint16(4136),
	2775: uint16(8017),
	2776: uint16(7955),
	2777: uint16(5641),
	2778: uint16(14904),
	2779: uint16(6170),
	2780: uint16(4699),
	2781: uint16(14906),
	2782: uint16(4691),
	2783: uint16(14912),
	2784: uint16(14909),
	2785: uint16(8018),
	2786: uint16(4650),
	2787: uint16(6411),
	2788: uint16(4649),
	2789: uint16(6446),
	2790: uint16(14907),
	2791: uint16(5700),
	2792: uint16(5674),
	2793: uint16(9292),
	2794: uint16(14905),
	2795: uint16(3877),
	2796: uint16(14908),
	2797: uint16(14910),
	2798: uint16(5420),
	2799: uint16(5643),
	2800: uint16(4891),
	2801: uint16(5162),
	2802: uint16(14913),
	2803: uint16(6488),
	2804: uint16(10832),
	2805: uint16(6678),
	2806: uint16(14914),
	2807: uint16(10255),
	2808: uint16(14926),
	2809: uint16(4370),
	2810: uint16(14915),
	2811: uint16(14932),
	2812: uint16(14916),
	2813: uint16(11553),
	2814: uint16(14923),
	2815: uint16(9790),
	2816: uint16(14931),
	2817: uint16(14918),
	2818: uint16(3859),
	2819: uint16(14920),
	2820: uint16(6171),
	2821: uint16(14922),
	2822: uint16(14921),
	2823: uint16(14917),
	2824: uint16(14928),
	2825: uint16(7454),
	2826: uint16(13132),
	2827: uint16(5959),
	2828: uint16(11355),
	2829: uint16(14919),
	2830: uint16(9043),
	2831: uint16(4610),
	2832: uint16(6412),
	2833: uint16(14911),
	2834: uint16(14927),
	2835: uint16(4672),
	2836: uint16(14925),
	2837: uint16(14929),
	2838: uint16(9293),
	2839: uint16(4957),
	2840: uint16(15121),
	2841: uint16(11048),
	2842: uint16(14934),
	2843: uint16(4956),
	2844: uint16(14941),
	2845: uint16(10783),
	2846: uint16(15104),
	2847: uint16(15106),
	2848: uint16(15110),
	2849: uint16(14936),
	2850: uint16(8713),
	2851: uint16(9294),
	2852: uint16(15114),
	2853: uint16(14939),
	2854: uint16(15111),
	2855: uint16(15105),
	2856: uint16(7704),
	2857: uint16(15115),
	2858: uint16(7954),
	2859: uint16(15113),
	2860: uint16(4892),
	2861: uint16(11823),
	2862: uint16(14933),
	2863: uint16(15109),
	2864: uint16(3895),
	2865: uint16(14935),
	2866: uint16(11033),
	2867: uint16(14940),
	2868: uint16(7681),
	2869: uint16(8998),
	2870: uint16(14930),
	2871: uint16(15108),
	2872: uint16(7769),
	2873: uint16(15118),
	2874: uint16(4688),
	2875: uint16(5888),
	2876: uint16(15120),
	2877: uint16(14937),
	2878: uint16(15119),
	2879: uint16(15112),
	2880: uint16(14938),
	2881: uint16(15116),
	2882: uint16(15117),
	2883: uint16(15134),
	2884: uint16(9517),
	2885: uint16(15107),
	2886: uint16(15130),
	2887: uint16(15132),
	2888: uint16(9015),
	2889: uint16(11307),
	2890: uint16(10325),
	2891: uint16(15127),
	2892: uint16(8489),
	2893: uint16(15133),
	2894: uint16(8222),
	2895: uint16(15124),
	2896: uint16(15137),
	2897: uint16(15136),
	2898: uint16(9550),
	2899: uint16(15135),
	2900: uint16(9545),
	2901: uint16(15139),
	2902: uint16(15126),
	2903: uint16(5415),
	2904: uint16(15129),
	2905: uint16(7228),
	2906: uint16(9791),
	2907: uint16(15131),
	2908: uint16(5418),
	2909: uint16(15123),
	2910: uint16(15125),
	2911: uint16(15122),
	2912: uint16(11791),
	2913: uint16(4665),
	2914: uint16(15128),
	2915: uint16(15138),
	2916: uint16(4628),
	2917: uint16(6470),
	2918: uint16(4156),
	2919: uint16(15155),
	2920: uint16(11792),
	2921: uint16(15158),
	2922: uint16(7705),
	2923: uint16(15157),
	2924: uint16(15156),
	2925: uint16(15153),
	2926: uint16(15141),
	2927: uint16(15170),
	2928: uint16(15140),
	2929: uint16(15159),
	2930: uint16(15151),
	2931: uint16(15146),
	2932: uint16(15143),
	2933: uint16(15144),
	2934: uint16(15152),
	2935: uint16(21249),
	2936: uint16(15149),
	2937: uint16(6172),
	2938: uint16(8999),
	2939: uint16(8259),
	2940: uint16(15147),
	2941: uint16(15142),
	2942: uint16(15145),
	2943: uint16(11308),
	2944: uint16(10825),
	2945: uint16(15150),
	2946: uint16(15160),
	2947: uint16(15168),
	2948: uint16(15161),
	2949: uint16(15174),
	2950: uint16(15172),
	2951: uint16(15167),
	2952: uint16(15166),
	2953: uint16(9007),
	2954: uint16(8260),
	2955: uint16(15164),
	2956: uint16(15162),
	2957: uint16(15169),
	2958: uint16(15175),
	2959: uint16(10068),
	2960: uint16(15181),
	2961: uint16(15176),
	2962: uint16(15179),
	2963: uint16(15173),
	2964: uint16(8787),
	2965: uint16(10263),
	2966: uint16(15163),
	2967: uint16(15171),
	2968: uint16(7455),
	2969: uint16(11054),
	2970: uint16(15191),
	2971: uint16(15178),
	2972: uint16(5889),
	2973: uint16(4354),
	2974: uint16(4670),
	2975: uint16(15154),
	2976: uint16(7456),
	2977: uint16(15183),
	2978: uint16(15190),
	2979: uint16(7000),
	2980: uint16(4689),
	2981: uint16(8717),
	2982: uint16(15180),
	2983: uint16(15185),
	2984: uint16(15189),
	2985: uint16(5397),
	2986: uint16(5163),
	2987: uint16(15187),
	2988: uint16(5120),
	2989: uint16(9514),
	2990: uint16(15186),
	2991: uint16(15188),
	2992: uint16(15182),
	2993: uint16(15184),
	2994: uint16(4671),
	2995: uint16(8744),
	2996: uint16(15195),
	2997: uint16(15193),
	2998: uint16(5960),
	2999: uint16(15192),
	3000: uint16(15360),
	3001: uint16(14903),
	3002: uint16(15194),
	3003: uint16(15196),
	3004: uint16(15197),
	3005: uint16(15371),
	3006: uint16(15367),
	3007: uint16(14924),
	3008: uint16(15366),
	3009: uint16(15365),
	3010: uint16(15362),
	3011: uint16(15177),
	3012: uint16(15364),
	3013: uint16(15363),
	3014: uint16(15369),
	3015: uint16(11781),
	3016: uint16(15372),
	3017: uint16(5466),
	3018: uint16(15368),
	3019: uint16(15370),
	3020: uint16(9990),
	3021: uint16(15373),
	3022: uint16(15377),
	3023: uint16(15374),
	3024: uint16(11346),
	3025: uint16(15375),
	3026: uint16(15165),
	3027: uint16(15378),
	3028: uint16(15379),
	3029: uint16(4116),
	3030: uint16(15381),
	3031: uint16(5702),
	3032: uint16(6912),
	3033: uint16(5428),
	3034: uint16(4355),
	3035: uint16(11326),
	3036: uint16(15383),
	3037: uint16(15382),
	3038: uint16(15385),
	3039: uint16(5148),
	3040: uint16(5429),
	3041: uint16(4893),
	3042: uint16(15388),
	3043: uint16(15387),
	3044: uint16(15389),
	3045: uint16(4397),
	3046: uint16(8726),
	3047: uint16(15390),
	3048: uint16(4894),
	3049: uint16(15392),
	3050: uint16(15391),
	3051: uint16(15393),
	3052: uint16(15394),
	3053: uint16(15395),
	3054: uint16(6718),
	3055: uint16(7956),
	3056: uint16(6400),
	3057: uint16(10319),
	3058: uint16(10561),
	3059: uint16(11811),
	3060: uint16(6740),
	3061: uint16(6447),
	3062: uint16(11601),
	3063: uint16(15396),
	3064: uint16(15397),
	3065: uint16(6719),
	3066: uint16(15398),
	3067: uint16(15399),
	3068: uint16(15401),
	3069: uint16(15400),
	3070: uint16(10807),
	3071: uint16(7229),
	3072: uint16(6987),
	3073: uint16(6691),
	3074: uint16(15402),
	3075: uint16(15404),
	3076: uint16(7682),
	3077: uint16(15403),
	3078: uint16(15405),
	3079: uint16(15406),
	3080: uint16(15407),
	3081: uint16(15408),
	3082: uint16(15409),
	3083: uint16(15411),
	3084: uint16(15410),
	3085: uint16(15412),
	3086: uint16(4356),
	3087: uint16(8745),
	3088: uint16(15413),
	3089: uint16(6661),
	3090: uint16(4651),
	3091: uint16(15414),
	3092: uint16(9249),
	3093: uint16(13099),
	3094: uint16(5122),
	3095: uint16(15415),
	3096: uint16(15416),
	3097: uint16(10571),
	3098: uint16(10823),
	3099: uint16(9510),
	3100: uint16(15417),
	3101: uint16(10053),
	3102: uint16(10074),
	3103: uint16(11058),
	3104: uint16(15418),
	3105: uint16(15420),
	3106: uint16(15419),
	3107: uint16(15422),
	3108: uint16(15421),
	3109: uint16(15424),
	3110: uint16(6720),
	3111: uint16(11024),
	3112: uint16(15425),
	3113: uint16(15426),
	3114: uint16(5123),
	3115: uint16(15427),
	3116: uint16(15429),
	3117: uint16(15428),
	3118: uint16(7748),
	3119: uint16(10264),
	3120: uint16(4137),
	3121: uint16(10020),
	3122: uint16(9044),
	3123: uint16(7200),
	3124: uint16(5184),
	3125: uint16(10021),
	3126: uint16(6925),
	3127: uint16(15431),
	3128: uint16(4895),
	3129: uint16(4183),
	3130: uint16(9553),
	3131: uint16(15430),
	3132: uint16(6173),
	3133: uint16(8754),
	3134: uint16(15432),
	3135: uint16(15440),
	3136: uint16(15433),
	3137: uint16(8480),
	3138: uint16(5185),
	3139: uint16(15441),
	3140: uint16(5703),
	3141: uint16(5124),
	3142: uint16(15439),
	3143: uint16(15437),
	3144: uint16(15434),
	3145: uint16(11327),
	3146: uint16(8991),
	3147: uint16(9528),
	3148: uint16(15435),
	3149: uint16(15443),
	3150: uint16(15442),
	3151: uint16(5634),
	3152: uint16(4364),
	3153: uint16(6426),
	3154: uint16(15436),
	3155: uint16(15438),
	3156: uint16(10806),
	3157: uint16(8531),
	3158: uint16(10838),
	3159: uint16(15451),
	3160: uint16(15452),
	3161: uint16(4398),
	3162: uint16(10503),
	3163: uint16(11100),
	3164: uint16(15616),
	3165: uint16(6914),
	3166: uint16(7457),
	3167: uint16(15447),
	3168: uint16(15453),
	3169: uint16(4167),
	3170: uint16(5398),
	3171: uint16(15444),
	3172: uint16(15449),
	3173: uint16(8019),
	3174: uint16(9808),
	3175: uint16(10054),
	3176: uint16(15446),
	3177: uint16(10752),
	3178: uint16(15448),
	3179: uint16(15619),
	3180: uint16(15617),
	3181: uint16(15450),
	3182: uint16(10753),
	3183: uint16(9767),
	3184: uint16(5186),
	3185: uint16(9220),
	3186: uint16(8780),
	3187: uint16(15620),
	3188: uint16(15618),
	3189: uint16(8504),
	3190: uint16(15445),
	3191: uint16(4138),
	3192: uint16(11309),
	3193: uint16(15631),
	3194: uint16(15630),
	3195: uint16(8021),
	3196: uint16(15627),
	3197: uint16(11339),
	3198: uint16(9493),
	3199: uint16(15621),
	3200: uint16(8996),
	3201: uint16(4139),
	3202: uint16(6174),
	3203: uint16(15624),
	3204: uint16(7174),
	3205: uint16(15629),
	3206: uint16(15628),
	3207: uint16(15623),
	3208: uint16(15626),
	3209: uint16(4679),
	3210: uint16(15625),
	3211: uint16(9768),
	3212: uint16(11533),
	3213: uint16(7507),
	3214: uint16(8020),
	3215: uint16(15637),
	3216: uint16(15635),
	3217: uint16(10284),
	3218: uint16(15632),
	3219: uint16(15634),
	3220: uint16(4121),
	3221: uint16(6175),
	3222: uint16(11793),
	3223: uint16(4636),
	3224: uint16(10305),
	3225: uint16(11328),
	3226: uint16(4611),
	3227: uint16(7706),
	3228: uint16(15636),
	3229: uint16(15641),
	3230: uint16(7458),
	3231: uint16(11279),
	3232: uint16(15638),
	3233: uint16(15633),
	3234: uint16(15639),
	3235: uint16(11581),
	3236: uint16(9298),
	3237: uint16(9505),
	3238: uint16(4629),
	3239: uint16(4148),
	3240: uint16(15645),
	3241: uint16(15648),
	3242: uint16(11554),
	3243: uint16(11331),
	3244: uint16(15655),
	3245: uint16(15649),
	3246: uint16(15646),
	3247: uint16(11571),
	3248: uint16(15652),
	3249: uint16(7209),
	3250: uint16(15654),
	3251: uint16(15659),
	3252: uint16(9296),
	3253: uint16(15657),
	3254: uint16(15651),
	3255: uint16(8727),
	3256: uint16(15658),
	3257: uint16(15647),
	3258: uint16(15653),
	3259: uint16(15660),
	3260: uint16(3931),
	3261: uint16(15650),
	3262: uint16(15661),
	3263: uint16(7707),
	3264: uint16(7230),
	3265: uint16(10500),
	3266: uint16(6413),
	3267: uint16(15642),
	3268: uint16(15656),
	3269: uint16(9241),
	3270: uint16(7957),
	3271: uint16(4680),
	3272: uint16(6448),
	3273: uint16(7459),
	3274: uint16(15644),
	3275: uint16(7201),
	3276: uint16(5675),
	3277: uint16(15643),
	3278: uint16(15665),
	3279: uint16(7244),
	3280: uint16(5913),
	3281: uint16(15680),
	3282: uint16(15674),
	3283: uint16(5203),
	3284: uint16(9262),
	3285: uint16(15669),
	3286: uint16(15678),
	3287: uint16(3854),
	3288: uint16(4113),
	3289: uint16(4376),
	3290: uint16(15671),
	3291: uint16(8459),
	3292: uint16(15662),
	3293: uint16(15664),
	3294: uint16(6176),
	3295: uint16(15681),
	3296: uint16(15676),
	3297: uint16(15668),
	3298: uint16(15675),
	3299: uint16(11018),
	3300: uint16(15673),
	3301: uint16(15677),
	3302: uint16(5935),
	3303: uint16(7460),
	3304: uint16(8728),
	3305: uint16(15667),
	3306: uint16(11278),
	3307: uint16(15670),
	3308: uint16(15663),
	3309: uint16(9297),
	3310: uint16(15666),
	3311: uint16(15672),
	3312: uint16(11824),
	3313: uint16(6941),
	3314: uint16(10845),
	3315: uint16(15682),
	3316: uint16(9997),
	3317: uint16(15694),
	3318: uint16(5914),
	3319: uint16(7231),
	3320: uint16(15684),
	3321: uint16(11534),
	3322: uint16(6177),
	3323: uint16(15697),
	3324: uint16(3917),
	3325: uint16(15695),
	3326: uint16(15683),
	3327: uint16(15689),
	3328: uint16(15691),
	3329: uint16(11310),
	3330: uint16(15686),
	3331: uint16(9229),
	3332: uint16(15688),
	3333: uint16(15696),
	3334: uint16(15690),
	3335: uint16(11046),
	3336: uint16(15685),
	3337: uint16(6913),
	3338: uint16(15709),
	3339: uint16(4681),
	3340: uint16(15687),
	3341: uint16(15692),
	3342: uint16(15693),
	3343: uint16(8523),
	3344: uint16(8505),
	3345: uint16(15701),
	3346: uint16(15707),
	3347: uint16(15705),
	3348: uint16(9224),
	3349: uint16(15874),
	3350: uint16(15702),
	3351: uint16(15703),
	3352: uint16(15679),
	3353: uint16(5208),
	3354: uint16(10265),
	3355: uint16(6942),
	3356: uint16(6230),
	3357: uint16(11794),
	3358: uint16(15699),
	3359: uint16(15873),
	3360: uint16(4168),
	3361: uint16(8261),
	3362: uint16(9816),
	3363: uint16(4896),
	3364: uint16(11609),
	3365: uint16(11008),
	3366: uint16(9009),
	3367: uint16(15706),
	3368: uint16(15708),
	3369: uint16(8209),
	3370: uint16(15872),
	3371: uint16(15704),
	3372: uint16(15698),
	3373: uint16(4898),
	3374: uint16(5704),
	3375: uint16(15886),
	3376: uint16(15881),
	3377: uint16(8023),
	3378: uint16(4674),
	3379: uint16(7232),
	3380: uint16(15890),
	3381: uint16(15883),
	3382: uint16(8971),
	3383: uint16(15880),
	3384: uint16(9016),
	3385: uint16(15915),
	3386: uint16(15877),
	3387: uint16(15876),
	3388: uint16(15885),
	3389: uint16(15879),
	3390: uint16(15878),
	3391: uint16(15884),
	3392: uint16(7936),
	3393: uint16(15875),
	3394: uint16(15887),
	3395: uint16(15888),
	3396: uint16(4897),
	3397: uint16(15893),
	3398: uint16(15892),
	3399: uint16(15894),
	3400: uint16(15897),
	3401: uint16(9250),
	3402: uint16(15891),
	3403: uint16(15895),
	3404: uint16(5698),
	3405: uint16(8536),
	3406: uint16(15889),
	3407: uint16(9754),
	3408: uint16(15896),
	3409: uint16(15901),
	3410: uint16(15899),
	3411: uint16(15902),
	3412: uint16(15905),
	3413: uint16(15898),
	3414: uint16(6217),
	3415: uint16(9735),
	3416: uint16(15640),
	3417: uint16(11347),
	3418: uint16(15900),
	3419: uint16(15904),
	3420: uint16(8532),
	3421: uint16(15903),
	3422: uint16(15882),
	3423: uint16(20040),
	3424: uint16(15908),
	3425: uint16(15912),
	3426: uint16(15910),
	3427: uint16(15906),
	3428: uint16(15907),
	3429: uint16(15911),
	3430: uint16(15909),
	3431: uint16(10285),
	3432: uint16(15917),
	3433: uint16(15914),
	3434: uint16(15913),
	3435: uint16(15916),
	3436: uint16(9523),
	3437: uint16(15918),
	3438: uint16(8788),
	3439: uint16(8524),
	3440: uint16(7940),
	3441: uint16(15919),
	3442: uint16(15921),
	3443: uint16(15920),
	3444: uint16(15700),
	3445: uint16(15922),
	3446: uint16(9542),
	3447: uint16(15923),
	3448: uint16(4399),
	3449: uint16(9299),
	3450: uint16(4612),
	3451: uint16(5187),
	3452: uint16(6973),
	3453: uint16(6449),
	3454: uint16(11782),
	3455: uint16(7749),
	3456: uint16(4169),
	3457: uint16(15925),
	3458: uint16(15924),
	3459: uint16(15928),
	3460: uint16(8729),
	3461: uint16(15931),
	3462: uint16(15926),
	3463: uint16(15930),
	3464: uint16(15929),
	3465: uint16(9247),
	3466: uint16(3896),
	3467: uint16(11604),
	3468: uint16(15933),
	3469: uint16(4103),
	3470: uint16(15935),
	3471: uint16(15934),
	3472: uint16(15932),
	3473: uint16(15927),
	3474: uint16(10754),
	3475: uint16(15937),
	3476: uint16(15936),
	3477: uint16(4170),
	3478: uint16(15939),
	3479: uint16(10513),
	3480: uint16(15938),
	3481: uint16(11028),
	3482: uint16(7462),
	3483: uint16(8210),
	3484: uint16(7461),
	3485: uint16(11610),
	3486: uint16(15945),
	3487: uint16(8024),
	3488: uint16(15941),
	3489: uint16(15946),
	3490: uint16(4171),
	3491: uint16(15944),
	3492: uint16(9792),
	3493: uint16(15940),
	3494: uint16(15943),
	3495: uint16(7463),
	3496: uint16(10032),
	3497: uint16(15947),
	3498: uint16(6960),
	3499: uint16(8025),
	3500: uint16(15950),
	3501: uint16(15942),
	3502: uint16(5638),
	3503: uint16(15948),
	3504: uint16(11311),
	3505: uint16(15951),
	3506: uint16(21253),
	3507: uint16(7214),
	3508: uint16(15952),
	3509: uint16(15953),
	3510: uint16(9741),
	3511: uint16(15955),
	3512: uint16(15956),
	3513: uint16(9746),
	3514: uint16(9300),
	3515: uint16(15958),
	3516: uint16(15960),
	3517: uint16(11572),
	3518: uint16(15957),
	3519: uint16(15959),
	3520: uint16(4172),
	3521: uint16(15954),
	3522: uint16(12858),
	3523: uint16(15961),
	3524: uint16(8262),
	3525: uint16(6679),
	3526: uint16(15963),
	3527: uint16(15962),
	3528: uint16(7683),
	3529: uint16(12600),
	3530: uint16(15964),
	3531: uint16(16128),
	3532: uint16(15949),
	3533: uint16(15965),
	3534: uint16(16129),
	3535: uint16(9817),
	3536: uint16(16130),
	3537: uint16(16131),
	3538: uint16(16132),
	3539: uint16(16133),
	3540: uint16(9021),
	3541: uint16(16135),
	3542: uint16(16134),
	3543: uint16(16136),
	3544: uint16(16137),
	3545: uint16(6974),
	3546: uint16(10306),
	3547: uint16(11083),
	3548: uint16(16138),
	3549: uint16(16139),
	3550: uint16(8245),
	3551: uint16(6915),
	3552: uint16(16140),
	3553: uint16(16141),
	3554: uint16(16142),
	3555: uint16(10545),
	3556: uint16(10022),
	3557: uint16(16143),
	3558: uint16(9782),
	3559: uint16(8972),
	3560: uint16(16144),
	3561: uint16(4422),
	3562: uint16(5196),
	3563: uint16(11045),
	3564: uint16(11029),
	3565: uint16(4371),
	3566: uint16(11795),
	3567: uint16(10801),
	3568: uint16(10505),
	3569: uint16(7958),
	3570: uint16(16145),
	3571: uint16(9506),
	3572: uint16(5890),
	3573: uint16(16146),
	3574: uint16(6451),
	3575: uint16(16148),
	3576: uint16(16147),
	3577: uint16(16149),
	3578: uint16(16150),
	3579: uint16(16151),
	3580: uint16(5149),
	3581: uint16(16152),
	3582: uint16(16153),
	3583: uint16(5891),
	3584: uint16(10023),
	3585: uint16(16155),
	3586: uint16(7508),
	3587: uint16(16154),
	3588: uint16(5399),
	3589: uint16(16156),
	3590: uint16(16158),
	3591: uint16(16157),
	3592: uint16(16159),
	3593: uint16(5936),
	3594: uint16(16160),
	3595: uint16(5448),
	3596: uint16(8223),
	3597: uint16(6236),
	3598: uint16(16162),
	3599: uint16(16163),
	3600: uint16(16161),
	3601: uint16(6988),
	3602: uint16(9511),
	3603: uint16(5400),
	3604: uint16(16165),
	3605: uint16(8715),
	3606: uint16(16164),
	3607: uint16(11796),
	3608: uint16(9793),
	3609: uint16(16168),
	3610: uint16(16170),
	3611: uint16(16167),
	3612: uint16(11059),
	3613: uint16(16169),
	3614: uint16(16171),
	3615: uint16(11555),
	3616: uint16(16175),
	3617: uint16(16174),
	3618: uint16(8789),
	3619: uint16(9740),
	3620: uint16(5892),
	3621: uint16(16173),
	3622: uint16(16172),
	3623: uint16(11280),
	3624: uint16(11281),
	3625: uint16(16176),
	3626: uint16(4173),
	3627: uint16(6229),
	3628: uint16(6721),
	3629: uint16(16177),
	3630: uint16(16178),
	3631: uint16(16180),
	3632: uint16(7202),
	3633: uint16(16182),
	3634: uint16(16181),
	3635: uint16(16183),
	3636: uint16(4652),
	3637: uint16(16185),
	3638: uint16(16184),
	3639: uint16(16187),
	3640: uint16(16186),
	3641: uint16(5915),
	3642: uint16(11527),
	3643: uint16(5419),
	3644: uint16(4357),
	3645: uint16(5449),
	3646: uint16(4928),
	3647: uint16(11591),
	3648: uint16(16189),
	3649: uint16(16191),
	3650: uint16(16192),
	3651: uint16(4400),
	3652: uint16(16188),
	3653: uint16(6680),
	3654: uint16(8992),
	3655: uint16(16190),
	3656: uint16(16195),
	3657: uint16(6989),
	3658: uint16(16193),
	3659: uint16(5661),
	3660: uint16(10024),
	3661: uint16(16194),
	3662: uint16(16221),
	3663: uint16(16200),
	3664: uint16(5916),
	3665: uint16(5188),
	3666: uint16(16197),
	3667: uint16(11356),
	3668: uint16(11535),
	3669: uint16(8533),
	3670: uint16(16199),
	3671: uint16(16201),
	3672: uint16(11573),
	3673: uint16(5430),
	3674: uint16(10075),
	3675: uint16(9769),
	3676: uint16(16202),
	3677: uint16(16204),
	3678: uint16(16207),
	3679: uint16(16203),
	3680: uint16(16206),
	3681: uint16(5961),
	3682: uint16(4140),
	3683: uint16(16208),
	3684: uint16(7759),
	3685: uint16(16205),
	3686: uint16(11579),
	3687: uint16(16211),
	3688: uint16(21251),
	3689: uint16(16209),
	3690: uint16(16212),
	3691: uint16(16198),
	3692: uint16(16210),
	3693: uint16(6427),
	3694: uint16(16213),
	3695: uint16(16214),
	3696: uint16(11357),
	3697: uint16(16215),
	3698: uint16(16216),
	3699: uint16(16196),
	3700: uint16(16217),
	3701: uint16(4899),
	3702: uint16(6916),
	3703: uint16(16218),
	3704: uint16(16219),
	3705: uint16(16220),
	3706: uint16(4122),
	3707: uint16(16384),
	3708: uint16(10266),
	3709: uint16(16385),
	3710: uint16(4867),
	3711: uint16(16386),
	3712: uint16(16387),
	3713: uint16(16388),
	3714: uint16(16390),
	3715: uint16(16391),
	3716: uint16(16389),
	3717: uint16(10290),
	3718: uint16(16393),
	3719: uint16(16392),
	3720: uint16(16395),
	3721: uint16(16394),
	3722: uint16(16396),
	3723: uint16(16397),
	3724: uint16(16399),
	3725: uint16(16398),
	3726: uint16(6232),
	3727: uint16(16401),
	3728: uint16(16400),
	3729: uint16(4900),
	3730: uint16(7730),
	3731: uint16(9243),
	3732: uint16(16402),
	3733: uint16(7959),
	3734: uint16(6681),
	3735: uint16(4184),
	3736: uint16(16403),
	3737: uint16(11312),
	3738: uint16(10562),
	3739: uint16(16404),
	3740: uint16(9251),
	3741: uint16(11282),
	3742: uint16(6178),
	3743: uint16(7708),
	3744: uint16(8746),
	3745: uint16(12563),
	3746: uint16(8973),
	3747: uint16(4423),
	3748: uint16(16405),
	3749: uint16(16406),
	3750: uint16(16411),
	3751: uint16(16409),
	3752: uint16(16408),
	3753: uint16(14625),
	3754: uint16(4613),
	3755: uint16(16407),
	3756: uint16(3897),
	3757: uint16(9993),
	3758: uint16(10025),
	3759: uint16(11536),
	3760: uint16(16412),
	3761: uint16(16410),
	3762: uint16(8763),
	3763: uint16(7941),
	3764: uint16(9994),
	3765: uint16(10252),
	3766: uint16(16414),
	3767: uint16(11531),
	3768: uint16(5676),
	3769: uint16(16415),
	3770: uint16(16413),
	3771: uint16(10037),
	3772: uint16(16416),
	3773: uint16(16417),
	3774: uint16(3898),
	3775: uint16(7509),
	3776: uint16(16422),
	3777: uint16(16419),
	3778: uint16(9548),
	3779: uint16(16418),
	3780: uint16(5125),
	3781: uint16(16425),
	3782: uint16(16420),
	3783: uint16(16421),
	3784: uint16(16424),
	3785: uint16(16423),
	3786: uint16(10244),
	3787: uint16(8225),
	3788: uint16(8224),
	3789: uint16(5150),
	3790: uint16(16426),
	3791: uint16(16427),
	3792: uint16(16428),
	3793: uint16(16430),
	3794: uint16(16429),
	3795: uint16(4149),
	3796: uint16(16438),
	3797: uint16(10055),
	3798: uint16(16432),
	3799: uint16(16434),
	3800: uint16(16436),
	3801: uint16(7709),
	3802: uint16(16437),
	3803: uint16(16435),
	3804: uint16(6943),
	3805: uint16(16431),
	3806: uint16(16433),
	3807: uint16(10273),
	3808: uint16(7464),
	3809: uint16(16440),
	3810: uint16(16439),
	3811: uint16(16441),
	3812: uint16(6917),
	3813: uint16(6414),
	3814: uint16(9302),
	3815: uint16(16442),
	3816: uint16(9002),
	3817: uint16(16444),
	3818: uint16(11520),
	3819: uint16(16443),
	3820: uint16(8264),
	3821: uint16(16449),
	3822: uint16(16451),
	3823: uint16(16452),
	3824: uint16(8755),
	3825: uint16(16450),
	3826: uint16(16447),
	3827: uint16(16445),
	3828: uint16(16446),
	3829: uint16(16448),
	3830: uint16(16455),
	3831: uint16(16453),
	3832: uint16(16454),
	3833: uint16(16456),
	3834: uint16(16458),
	3835: uint16(16459),
	3836: uint16(16460),
	3837: uint16(16461),
	3838: uint16(16457),
	3839: uint16(16463),
	3840: uint16(16462),
	3841: uint16(16464),
	3842: uint16(11556),
	3843: uint16(16467),
	3844: uint16(16465),
	3845: uint16(16466),
	3846: uint16(4929),
	3847: uint16(11101),
	3848: uint16(10537),
	3849: uint16(16469),
	3850: uint16(16468),
	3851: uint16(16470),
	3852: uint16(16471),
	3853: uint16(16475),
	3854: uint16(16472),
	3855: uint16(16473),
	3856: uint16(16474),
	3857: uint16(16476),
	3858: uint16(16477),
	3859: uint16(16640),
	3860: uint16(16641),
	3861: uint16(16642),
	3862: uint16(9998),
	3863: uint16(9263),
	3864: uint16(16643),
	3865: uint16(9809),
	3866: uint16(10259),
	3867: uint16(16644),
	3868: uint16(16645),
	3869: uint16(9225),
	3870: uint16(4614),
	3871: uint16(6179),
	3872: uint16(16646),
	3873: uint16(16647),
	3874: uint16(16648),
	3875: uint16(6664),
	3876: uint16(16650),
	3877: uint16(16649),
	3878: uint16(16651),
	3879: uint16(16652),
	3880: uint16(10056),
	3881: uint16(16653),
	3882: uint16(16654),
	3883: uint16(21064),
	3884: uint16(16655),
	3885: uint16(16656),
	3886: uint16(16657),
	3887: uint16(6669),
	3888: uint16(16658),
	3889: uint16(9781),
	3890: uint16(10814),
	3891: uint16(4141),
	3892: uint16(4150),
	3893: uint16(16659),
	3894: uint16(16661),
	3895: uint16(16660),
	3896: uint16(9295),
	3897: uint16(7960),
	3898: uint16(15384),
	3899: uint16(16662),
	3900: uint16(11040),
	3901: uint16(16663),
	3902: uint16(4901),
	3903: uint16(10038),
	3904: uint16(16664),
	3905: uint16(16665),
	3906: uint16(16666),
	3907: uint16(11067),
	3908: uint16(11060),
	3909: uint16(8989),
	3910: uint16(8265),
	3911: uint16(16668),
	3912: uint16(7233),
	3913: uint16(7465),
	3914: uint16(16671),
	3915: uint16(16670),
	3916: uint16(16669),
	3917: uint16(10076),
	3918: uint16(4902),
	3919: uint16(5896),
	3920: uint16(16677),
	3921: uint16(16674),
	3922: uint16(7710),
	3923: uint16(11025),
	3924: uint16(16673),
	3925: uint16(16675),
	3926: uint16(16676),
	3927: uint16(16672),
	3928: uint16(16678),
	3929: uint16(16679),
	3930: uint16(8974),
	3931: uint16(4930),
	3932: uint16(8772),
	3933: uint16(16680),
	3934: uint16(16681),
	3935: uint16(16684),
	3936: uint16(7750),
	3937: uint16(9507),
	3938: uint16(16685),
	3939: uint16(10802),
	3940: uint16(16682),
	3941: uint16(16683),
	3942: uint16(16688),
	3943: uint16(16687),
	3944: uint16(16686),
	3945: uint16(16690),
	3946: uint16(16689),
	3947: uint16(16691),
	3948: uint16(16693),
	3949: uint16(16692),
	3950: uint16(10540),
	3951: uint16(7221),
	3952: uint16(11557),
	3953: uint16(16694),
	3954: uint16(9494),
	3955: uint16(16695),
	3956: uint16(16696),
	3957: uint16(16700),
	3958: uint16(16698),
	3959: uint16(16699),
	3960: uint16(16697),
	3961: uint16(16701),
	3962: uint16(16702),
	3963: uint16(16703),
	3964: uint16(16704),
	3965: uint16(11030),
	3966: uint16(16705),
	3967: uint16(11087),
	3968: uint16(16706),
	3969: uint16(8749),
	3970: uint16(9801),
	3971: uint16(5450),
	3972: uint16(8730),
	3973: uint16(16707),
	3974: uint16(5401),
	3975: uint16(7983),
	3976: uint16(16708),
	3977: uint16(6428),
	3978: uint16(16709),
	3979: uint16(16710),
	3980: uint16(5893),
	3981: uint16(6452),
	3982: uint16(16712),
	3983: uint16(9269),
	3984: uint16(6453),
	3985: uint16(5165),
	3986: uint16(10755),
	3987: uint16(9770),
	3988: uint16(9270),
	3989: uint16(6203),
	3990: uint16(16714),
	3991: uint16(7466),
	3992: uint16(11537),
	3993: uint16(6180),
	3994: uint16(5894),
	3995: uint16(9986),
	3996: uint16(16716),
	3997: uint16(16718),
	3998: uint16(5962),
	3999: uint16(16717),
	4000: uint16(9045),
	4001: uint16(16720),
	4002: uint16(4630),
	4003: uint16(16715),
	4004: uint16(10057),
	4005: uint16(4111),
	4006: uint16(6475),
	4007: uint16(11825),
	4008: uint16(16719),
	4009: uint16(16721),
	4010: uint16(10538),
	4011: uint16(7992),
	4012: uint16(16723),
	4013: uint16(16724),
	4014: uint16(16722),
	4015: uint16(4653),
	4016: uint16(16730),
	4017: uint16(16729),
	4018: uint16(6918),
	4019: uint16(16731),
	4020: uint16(16726),
	4021: uint16(16732),
	4022: uint16(16727),
	4023: uint16(10039),
	4024: uint16(16725),
	4025: uint16(16728),
	4026: uint16(16897),
	4027: uint16(16896),
	4028: uint16(10816),
	4029: uint16(16733),
	4030: uint16(3914),
	4031: uint16(16899),
	4032: uint16(16898),
	4033: uint16(7467),
	4034: uint16(16900),
	4035: uint16(8226),
	4036: uint16(16902),
	4037: uint16(16901),
	4038: uint16(16903),
	4039: uint16(16711),
	4040: uint16(16713),
	4041: uint16(16905),
	4042: uint16(16904),
	4043: uint16(6919),
	4044: uint16(11592),
	4045: uint16(6961),
	4046: uint16(16906),
	4047: uint16(5654),
	4048: uint16(5151),
	4049: uint16(5126),
	4050: uint16(6722),
	4051: uint16(11283),
	4052: uint16(16912),
	4053: uint16(16911),
	4054: uint16(8227),
	4055: uint16(16908),
	4056: uint16(16910),
	4057: uint16(7210),
	4058: uint16(7711),
	4059: uint16(16909),
	4060: uint16(16907),
	4061: uint16(9737),
	4062: uint16(7468),
	4063: uint16(10267),
	4064: uint16(6454),
	4065: uint16(9303),
	4066: uint16(16913),
	4067: uint16(16914),
	4068: uint16(16936),
	4069: uint16(5431),
	4070: uint16(11804),
	4071: uint16(8212),
	4072: uint16(16915),
	4073: uint16(4401),
	4074: uint16(9046),
	4075: uint16(10496),
	4076: uint16(16916),
	4077: uint16(5209),
	4078: uint16(16917),
	4079: uint16(16919),
	4080: uint16(16920),
	4081: uint16(9736),
	4082: uint16(16921),
	4083: uint16(16922),
	4084: uint16(16923),
	4085: uint16(5432),
	4086: uint16(4402),
	4087: uint16(9508),
	4088: uint16(7175),
	4089: uint16(6723),
	4090: uint16(16924),
	4091: uint16(7176),
	4092: uint16(4393),
	4093: uint16(10274),
	4094: uint16(16925),
	4095: uint16(10058),
	4096: uint16(8228),
	4097: uint16(16928),
	4098: uint16(16929),
	4099: uint16(9800),
	4100: uint16(7712),
	4101: uint16(16926),
	4102: uint16(8768),
	4103: uint16(16927),
	4104: uint16(7469),
	4105: uint16(3899),
	4106: uint16(5128),
	4107: uint16(16930),
	4108: uint16(9047),
	4109: uint16(16931),
	4110: uint16(7974),
	4111: uint16(11020),
	4112: uint16(10242),
	4113: uint16(16932),
	4114: uint16(16933),
	4115: uint16(8756),
	4116: uint16(11558),
	4117: uint16(16935),
	4118: uint16(16934),
	4119: uint16(6990),
	4120: uint16(16937),
	4121: uint16(3919),
	4122: uint16(16940),
	4123: uint16(16938),
	4124: uint16(4403),
	4125: uint16(5677),
	4126: uint16(16939),
	4127: uint16(6181),
	4128: uint16(6225),
	4129: uint16(10565),
	4130: uint16(16941),
	4131: uint16(10803),
	4132: uint16(16943),
	4133: uint16(7984),
	4134: uint16(4142),
	4135: uint16(4377),
	4136: uint16(3851),
	4137: uint16(16942),
	4138: uint16(16944),
	4139: uint16(16945),
	4140: uint16(7510),
	4141: uint16(16946),
	4142: uint16(4654),
	4143: uint16(16948),
	4144: uint16(5705),
	4145: uint16(5189),
	4146: uint16(16949),
	4147: uint16(5460),
	4148: uint16(16950),
	4149: uint16(8027),
	4150: uint16(9516),
	4151: uint16(7999),
	4152: uint16(6484),
	4153: uint16(16951),
	4154: uint16(8769),
	4155: uint16(8266),
	4156: uint16(16953),
	4157: uint16(16955),
	4158: uint16(16952),
	4159: uint16(16954),
	4160: uint16(5633),
	4161: uint16(16956),
	4162: uint16(5637),
	4163: uint16(5190),
	4164: uint16(11313),
	4165: uint16(16958),
	4166: uint16(16959),
	4167: uint16(4109),
	4168: uint16(16962),
	4169: uint16(4693),
	4170: uint16(16961),
	4171: uint16(16960),
	4172: uint16(16964),
	4173: uint16(16957),
	4174: uint16(16965),
	4175: uint16(11528),
	4176: uint16(16966),
	4177: uint16(16967),
	4178: uint16(13139),
	4179: uint16(16969),
	4180: uint16(16968),
	4181: uint16(16970),
	4182: uint16(16971),
	4183: uint16(11540),
	4184: uint16(16972),
	4185: uint16(20302),
	4186: uint16(7470),
	4187: uint16(16973),
	4188: uint16(16974),
	4189: uint16(7222),
	4190: uint16(9495),
	4191: uint16(16975),
	4192: uint16(8711),
	4193: uint16(16976),
	4194: uint16(8731),
	4195: uint16(16977),
	4196: uint16(5380),
	4197: uint16(12318),
	4198: uint16(8764),
	4199: uint16(6930),
	4200: uint16(4903),
	4201: uint16(16978),
	4202: uint16(17153),
	4203: uint16(16981),
	4204: uint16(5191),
	4205: uint16(16980),
	4206: uint16(17155),
	4207: uint16(16979),
	4208: uint16(7471),
	4209: uint16(16983),
	4210: uint16(16984),
	4211: uint16(9226),
	4212: uint16(16985),
	4213: uint16(4669),
	4214: uint16(7737),
	4215: uint16(10307),
	4216: uint16(16987),
	4217: uint16(8519),
	4218: uint16(16982),
	4219: uint16(16986),
	4220: uint16(16988),
	4221: uint16(6490),
	4222: uint16(17157),
	4223: uint16(10253),
	4224: uint16(9989),
	4225: uint16(9304),
	4226: uint16(5433),
	4227: uint16(17156),
	4228: uint16(17154),
	4229: uint16(10004),
	4230: uint16(16989),
	4231: uint16(8765),
	4232: uint16(9306),
	4233: uint16(9305),
	4234: uint16(6485),
	4235: uint16(17175),
	4236: uint16(17159),
	4237: uint16(17161),
	4238: uint16(17164),
	4239: uint16(17165),
	4240: uint16(17162),
	4241: uint16(17163),
	4242: uint16(17160),
	4243: uint16(17158),
	4244: uint16(17152),
	4245: uint16(10542),
	4246: uint16(4404),
	4247: uint16(17172),
	4248: uint16(17169),
	4249: uint16(17174),
	4250: uint16(17173),
	4251: uint16(9810),
	4252: uint16(11014),
	4253: uint16(6682),
	4254: uint16(17167),
	4255: uint16(17176),
	4256: uint16(17171),
	4257: uint16(17170),
	4258: uint16(17166),
	4259: uint16(17168),
	4260: uint16(4904),
	4261: uint16(8732),
	4262: uint16(8028),
	4263: uint16(9985),
	4264: uint16(17181),
	4265: uint16(9987),
	4266: uint16(8000),
	4267: uint16(17178),
	4268: uint16(10030),
	4269: uint16(17182),
	4270: uint16(10546),
	4271: uint16(8762),
	4272: uint16(17177),
	4273: uint16(17179),
	4274: uint16(17180),
	4275: uint16(17183),
	4276: uint16(6947),
	4277: uint16(9509),
	4278: uint16(17188),
	4279: uint16(17187),
	4280: uint16(17184),
	4281: uint16(11797),
	4282: uint16(17193),
	4283: uint16(17197),
	4284: uint16(17194),
	4285: uint16(17190),
	4286: uint16(17191),
	4287: uint16(17196),
	4288: uint16(17185),
	4289: uint16(12596),
	4290: uint16(17192),
	4291: uint16(17186),
	4292: uint16(17195),
	4293: uint16(17201),
	4294: uint16(4905),
	4295: uint16(17198),
	4296: uint16(17199),
	4297: uint16(17200),
	4298: uint16(17203),
	4299: uint16(17202),
	4300: uint16(10069),
	4301: uint16(17204),
	4302: uint16(11611),
	4303: uint16(10572),
	4304: uint16(17209),
	4305: uint16(17206),
	4306: uint16(17205),
	4307: uint16(7985),
	4308: uint16(17208),
	4309: uint16(17210),
	4310: uint16(17207),
	4311: uint16(17214),
	4312: uint16(17211),
	4313: uint16(17212),
	4314: uint16(17189),
	4315: uint16(17213),
	4316: uint16(17215),
	4317: uint16(17216),
	4318: uint16(10533),
	4319: uint16(17217),
	4320: uint16(11073),
	4321: uint16(5421),
	4322: uint16(5640),
	4323: uint16(17218),
	4324: uint16(10515),
	4325: uint16(7751),
	4326: uint16(11023),
	4327: uint16(17219),
	4328: uint16(11538),
	4329: uint16(9811),
	4330: uint16(8229),
	4331: uint16(9747),
	4332: uint16(7212),
	4333: uint16(3871),
	4334: uint16(17224),
	4335: uint16(17222),
	4336: uint16(17220),
	4337: uint16(4864),
	4338: uint16(7472),
	4339: uint16(17225),
	4340: uint16(17223),
	4341: uint16(17221),
	4342: uint16(17229),
	4343: uint16(17228),
	4344: uint16(17227),
	4345: uint16(17226),
	4346: uint16(17230),
	4347: uint16(17231),
	4348: uint16(7961),
	4349: uint16(17232),
	4350: uint16(17234),
	4351: uint16(17233),
	4352: uint16(5937),
	4353: uint16(8215),
	4354: uint16(17236),
	4355: uint16(9307),
	4356: uint16(17235),
	4357: uint16(17237),
	4358: uint16(10516),
	4359: uint16(8267),
	4360: uint16(6182),
	4361: uint16(17238),
	4362: uint16(11559),
	4363: uint16(17240),
	4364: uint16(17241),
	4365: uint16(17242),
	4366: uint16(17243),
	4367: uint16(6724),
	4368: uint16(17244),
	4369: uint16(5678),
	4370: uint16(5193),
	4371: uint16(5129),
	4372: uint16(17408),
	4373: uint16(11090),
	4374: uint16(6183),
	4375: uint16(17245),
	4376: uint16(17411),
	4377: uint16(11077),
	4378: uint16(9755),
	4379: uint16(10258),
	4380: uint16(7234),
	4381: uint16(17410),
	4382: uint16(6962),
	4383: uint16(6184),
	4384: uint16(6725),
	4385: uint16(5192),
	4386: uint16(10517),
	4387: uint16(17409),
	4388: uint16(8230),
	4389: uint16(10785),
	4390: uint16(6486),
	4391: uint16(6726),
	4392: uint16(9020),
	4393: uint16(17414),
	4394: uint16(11582),
	4395: uint16(6456),
	4396: uint16(17415),
	4397: uint16(7713),
	4398: uint16(17417),
	4399: uint16(7473),
	4400: uint16(6415),
	4401: uint16(17416),
	4402: uint16(7177),
	4403: uint16(5917),
	4404: uint16(8231),
	4405: uint16(17412),
	4406: uint16(17418),
	4407: uint16(17413),
	4408: uint16(5679),
	4409: uint16(17421),
	4410: uint16(17425),
	4411: uint16(5706),
	4412: uint16(17420),
	4413: uint16(17429),
	4414: uint16(6185),
	4415: uint16(11340),
	4416: uint16(3867),
	4417: uint16(17426),
	4418: uint16(5194),
	4419: uint16(17423),
	4420: uint16(17424),
	4421: uint16(9308),
	4422: uint16(17422),
	4423: uint16(17419),
	4424: uint16(4615),
	4425: uint16(8003),
	4426: uint16(5895),
	4427: uint16(17431),
	4428: uint16(17428),
	4429: uint16(17430),
	4430: uint16(17427),
	4431: uint16(5680),
	4432: uint16(8466),
	4433: uint16(17432),
	4434: uint16(8269),
	4435: uint16(17445),
	4436: uint16(17441),
	4437: uint16(17435),
	4438: uint16(17439),
	4439: uint16(7001),
	4440: uint16(3900),
	4441: uint16(17434),
	4442: uint16(17442),
	4443: uint16(17446),
	4444: uint16(6186),
	4445: uint16(11061),
	4446: uint16(9013),
	4447: uint16(17436),
	4448: uint16(17444),
	4449: uint16(17433),
	4450: uint16(8733),
	4451: uint16(17438),
	4452: uint16(3868),
	4453: uint16(11049),
	4454: uint16(17437),
	4455: uint16(5434),
	4456: uint16(10059),
	4457: uint16(8268),
	4458: uint16(11567),
	4459: uint16(7246),
	4460: uint16(17485),
	4461: uint16(17447),
	4462: uint16(8029),
	4463: uint16(17443),
	4464: uint16(17448),
	4465: uint16(17450),
	4466: uint16(9048),
	4467: uint16(17453),
	4468: uint16(17449),
	4469: uint16(10547),
	4470: uint16(4906),
	4471: uint16(11050),
	4472: uint16(3901),
	4473: uint16(17452),
	4474: uint16(11612),
	4475: uint16(17451),
	4476: uint16(4174),
	4477: uint16(9547),
	4478: uint16(17454),
	4479: uint16(17461),
	4480: uint16(17455),
	4481: uint16(17462),
	4482: uint16(17458),
	4483: uint16(9818),
	4484: uint16(6953),
	4485: uint16(17460),
	4486: uint16(17457),
	4487: uint16(17463),
	4488: uint16(17456),
	4489: uint16(7203),
	4490: uint16(10756),
	4491: uint16(7211),
	4492: uint16(17459),
	4493: uint16(17471),
	4494: uint16(17467),
	4495: uint16(17470),
	4496: uint16(17468),
	4497: uint16(17472),
	4498: uint16(17466),
	4499: uint16(17440),
	4500: uint16(7986),
	4501: uint16(10026),
	4502: uint16(17469),
	4503: uint16(17464),
	4504: uint16(8192),
	4505: uint16(5681),
	4506: uint16(7178),
	4507: uint16(7684),
	4508: uint16(8213),
	4509: uint16(17475),
	4510: uint16(17477),
	4511: uint16(17478),
	4512: uint16(17474),
	4513: uint16(17476),
	4514: uint16(17465),
	4515: uint16(17473),
	4516: uint16(17481),
	4517: uint16(17480),
	4518: uint16(10841),
	4519: uint16(5642),
	4520: uint16(17479),
	4521: uint16(17483),
	4522: uint16(17482),
	4523: uint16(17486),
	4524: uint16(17488),
	4525: uint16(6683),
	4526: uint16(17484),
	4527: uint16(17489),
	4528: uint16(17490),
	4529: uint16(17491),
	4530: uint16(17497),
	4531: uint16(9242),
	4532: uint16(17493),
	4533: uint16(17492),
	4534: uint16(17494),
	4535: uint16(17495),
	4536: uint16(17496),
	4537: uint16(17498),
	4538: uint16(17499),
	4539: uint16(4907),
	4540: uint16(17500),
	4541: uint16(17501),
	4542: uint16(17664),
	4543: uint16(17665),
	4544: uint16(17666),
	4545: uint16(17667),
	4546: uint16(17668),
	4547: uint16(17669),
	4548: uint16(17671),
	4549: uint16(17670),
	4550: uint16(17672),
	4551: uint16(17673),
	4552: uint16(17674),
	4553: uint16(17677),
	4554: uint16(17675),
	4555: uint16(17676),
	4556: uint16(6464),
	4557: uint16(5682),
	4558: uint16(8757),
	4559: uint16(10002),
	4560: uint16(7247),
	4561: uint16(9772),
	4562: uint16(10060),
	4563: uint16(17678),
	4564: uint16(14156),
	4565: uint16(17679),
	4566: uint16(17681),
	4567: uint16(11332),
	4568: uint16(17680),
	4569: uint16(17683),
	4570: uint16(17682),
	4571: uint16(11314),
	4572: uint16(17684),
	4573: uint16(10077),
	4574: uint16(17685),
	4575: uint16(17688),
	4576: uint16(17687),
	4577: uint16(17686),
	4578: uint16(17689),
	4579: uint16(5649),
	4580: uint16(8193),
	4581: uint16(5152),
	4582: uint16(17693),
	4583: uint16(17690),
	4584: uint16(17691),
	4585: uint16(17694),
	4586: uint16(17695),
	4587: uint16(17692),
	4588: uint16(4104),
	4589: uint16(4358),
	4590: uint16(17697),
	4591: uint16(17698),
	4592: uint16(17699),
	4593: uint16(11329),
	4594: uint16(7179),
	4595: uint16(17701),
	4596: uint16(17700),
	4597: uint16(7752),
	4598: uint16(17702),
	4599: uint16(17703),
	4600: uint16(17704),
	4601: uint16(4932),
	4602: uint16(4908),
	4603: uint16(17705),
	4604: uint16(17706),
	4605: uint16(10812),
	4606: uint16(11330),
	4607: uint16(11315),
	4608: uint16(11798),
	4609: uint16(6188),
	4610: uint16(17709),
	4611: uint16(6963),
	4612: uint16(17708),
	4613: uint16(17710),
	4614: uint16(6920),
	4615: uint16(8496),
	4616: uint16(17711),
	4617: uint16(6187),
	4618: uint16(11062),
	4619: uint16(17712),
	4620: uint16(17713),
	4621: uint16(17714),
	4622: uint16(17715),
	4623: uint16(17716),
	4624: uint16(6921),
	4625: uint16(11084),
	4626: uint16(17718),
	4627: uint16(8734),
	4628: uint16(17717),
	4629: uint16(17720),
	4630: uint16(17719),
	4631: uint16(17721),
	4632: uint16(7962),
	4633: uint16(17722),
	4634: uint16(17723),
	4635: uint16(10520),
	4636: uint16(17724),
	4637: uint16(8270),
	4638: uint16(17725),
	4639: uint16(17726),
	4640: uint16(11613),
	4641: uint16(17729),
	4642: uint16(17728),
	4643: uint16(17727),
	4644: uint16(8975),
	4645: uint16(17730),
	4646: uint16(7685),
	4647: uint16(17731),
	4648: uint16(17732),
	4649: uint16(11799),
	4650: uint16(17733),
	4651: uint16(17734),
	4652: uint16(17736),
	4653: uint16(17735),
	4654: uint16(9988),
	4655: uint16(9560),
	4656: uint16(11805),
	4657: uint16(9992),
	4658: uint16(17738),
	4659: uint16(7474),
	4660: uint16(10249),
	4661: uint16(17739),
	4662: uint16(17737),
	4663: uint16(4909),
	4664: uint16(5939),
	4665: uint16(6727),
	4666: uint16(10061),
	4667: uint16(5897),
	4668: uint16(10786),
	4669: uint16(17742),
	4670: uint16(17740),
	4671: uint16(6189),
	4672: uint16(6190),
	4673: uint16(3912),
	4674: uint16(6471),
	4675: uint16(9784),
	4676: uint16(3902),
	4677: uint16(17747),
	4678: uint16(8735),
	4679: uint16(9783),
	4680: uint16(8506),
	4681: uint16(17749),
	4682: uint16(17745),
	4683: uint16(17748),
	4684: uint16(17743),
	4685: uint16(17746),
	4686: uint16(10757),
	4687: uint16(5940),
	4688: uint16(3932),
	4689: uint16(17744),
	4690: uint16(17751),
	4691: uint16(17752),
	4692: uint16(9496),
	4693: uint16(5402),
	4694: uint16(17925),
	4695: uint16(9756),
	4696: uint16(6728),
	4697: uint16(5403),
	4698: uint16(7975),
	4699: uint16(11813),
	4700: uint16(11021),
	4701: uint16(17750),
	4702: uint16(7987),
	4703: uint16(5170),
	4704: uint16(17753),
	4705: uint16(17755),
	4706: uint16(17754),
	4707: uint16(17756),
	4708: uint16(8709),
	4709: uint16(9757),
	4710: uint16(8976),
	4711: uint16(17922),
	4712: uint16(17921),
	4713: uint16(17757),
	4714: uint16(7732),
	4715: uint16(10308),
	4716: uint16(17924),
	4717: uint16(17923),
	4718: uint16(6191),
	4719: uint16(11826),
	4720: uint16(17940),
	4721: uint16(17928),
	4722: uint16(17929),
	4723: uint16(6991),
	4724: uint16(17927),
	4725: uint16(6231),
	4726: uint16(17926),
	4727: uint16(17930),
	4728: uint16(8977),
	4729: uint16(10497),
	4730: uint16(8194),
	4731: uint16(8507),
	4732: uint16(17934),
	4733: uint16(17935),
	4734: uint16(17931),
	4735: uint16(17932),
	4736: uint16(17933),
	4737: uint16(6192),
	4738: uint16(17941),
	4739: uint16(17937),
	4740: uint16(10309),
	4741: uint16(10827),
	4742: uint16(10247),
	4743: uint16(17936),
	4744: uint16(17939),
	4745: uint16(17938),
	4746: uint16(10787),
	4747: uint16(17942),
	4748: uint16(17943),
	4749: uint16(8214),
	4750: uint16(17944),
	4751: uint16(17946),
	4752: uint16(17950),
	4753: uint16(17947),
	4754: uint16(17945),
	4755: uint16(9758),
	4756: uint16(17948),
	4757: uint16(17949),
	4758: uint16(4369),
	4759: uint16(17956),
	4760: uint16(17951),
	4761: uint16(17952),
	4762: uint16(17953),
	4763: uint16(8448),
	4764: uint16(17955),
	4765: uint16(17954),
	4766: uint16(17957),
	4767: uint16(17958),
	4768: uint16(17959),
	4769: uint16(7714),
	4770: uint16(4424),
	4771: uint16(17960),
	4772: uint16(11574),
	4773: uint16(6922),
	4774: uint16(7180),
	4775: uint16(6729),
	4776: uint16(8758),
	4777: uint16(17961),
	4778: uint16(17962),
	4779: uint16(4112),
	4780: uint16(17963),
	4781: uint16(17964),
	4782: uint16(17965),
	4783: uint16(17966),
	4784: uint16(17967),
	4785: uint16(5404),
	4786: uint16(14601),
	4787: uint16(17968),
	4788: uint16(8004),
	4789: uint16(17969),
	4790: uint16(6954),
	4791: uint16(17970),
	4792: uint16(12047),
	4793: uint16(17971),
	4794: uint16(10557),
	4795: uint16(4923),
	4796: uint16(8195),
	4797: uint16(7223),
	4798: uint16(10320),
	4799: uint16(7181),
	4800: uint16(17972),
	4801: uint16(6193),
	4802: uint16(17973),
	4803: uint16(10027),
	4804: uint16(17987),
	4805: uint16(17975),
	4806: uint16(8488),
	4807: uint16(9812),
	4808: uint16(5918),
	4809: uint16(17974),
	4810: uint16(8196),
	4811: uint16(17976),
	4812: uint16(9049),
	4813: uint16(17978),
	4814: uint16(17977),
	4815: uint16(17980),
	4816: uint16(17979),
	4817: uint16(17981),
	4818: uint16(17983),
	4819: uint16(17982),
	4820: uint16(4910),
	4821: uint16(17984),
	4822: uint16(17985),
	4823: uint16(17986),
	4824: uint16(6416),
	4825: uint16(11560),
	4826: uint16(17988),
	4827: uint16(7686),
	4828: uint16(4175),
	4829: uint16(17989),
	4830: uint16(17990),
	4831: uint16(17991),
	4832: uint16(3921),
	4833: uint16(17992),
	4834: uint16(17993),
	4835: uint16(10310),
	4836: uint16(6950),
	4837: uint16(17995),
	4838: uint16(4616),
	4839: uint16(3857),
	4840: uint16(17994),
	4841: uint16(17997),
	4842: uint16(9773),
	4843: uint16(7715),
	4844: uint16(4405),
	4845: uint16(10758),
	4846: uint16(5692),
	4847: uint16(5435),
	4848: uint16(17996),
	4849: uint16(4425),
	4850: uint16(4866),
	4851: uint16(4176),
	4852: uint16(18001),
	4853: uint16(11593),
	4854: uint16(8508),
	4855: uint16(10275),
	4856: uint16(18013),
	4857: uint16(4406),
	4858: uint16(18011),
	4859: uint16(18009),
	4860: uint16(18000),
	4861: uint16(17998),
	4862: uint16(17999),
	4863: uint16(6978),
	4864: uint16(5451),
	4865: uint16(8790),
	4866: uint16(9520),
	4867: uint16(4144),
	4868: uint16(18003),
	4869: uint16(18002),
	4870: uint16(18008),
	4871: uint16(18004),
	4872: uint16(18007),
	4873: uint16(11055),
	4874: uint16(18006),
	4875: uint16(4407),
	4876: uint16(4700),
	4877: uint16(18010),
	4878: uint16(18012),
	4879: uint16(5683),
	4880: uint16(18178),
	4881: uint16(18187),
	4882: uint16(18188),
	4883: uint16(3850),
	4884: uint16(18195),
	4885: uint16(3920),
	4886: uint16(18186),
	4887: uint16(18185),
	4888: uint16(18180),
	4889: uint16(18179),
	4890: uint16(18177),
	4891: uint16(18176),
	4892: uint16(8770),
	4893: uint16(8538),
	4894: uint16(18182),
	4895: uint16(18181),
	4896: uint16(18184),
	4897: uint16(8271),
	4898: uint16(5684),
	4899: uint16(4128),
	4900: uint16(18183),
	4901: uint16(6194),
	4902: uint16(8272),
	4903: uint16(18201),
	4904: uint16(18202),
	4905: uint16(4408),
	4906: uint16(4365),
	4907: uint16(18199),
	4908: uint16(18189),
	4909: uint16(18197),
	4910: uint16(18204),
	4911: uint16(18198),
	4912: uint16(18196),
	4913: uint16(18005),
	4914: uint16(18194),
	4915: uint16(18190),
	4916: uint16(4911),
	4917: uint16(18192),
	4918: uint16(18203),
	4919: uint16(18193),
	4920: uint16(18205),
	4921: uint16(18191),
	4922: uint16(9819),
	4923: uint16(11336),
	4924: uint16(18200),
	4925: uint16(18222),
	4926: uint16(18214),
	4927: uint16(7770),
	4928: uint16(5157),
	4929: uint16(5436),
	4930: uint16(18209),
	4931: uint16(4410),
	4932: uint16(7475),
	4933: uint16(18212),
	4934: uint16(6457),
	4935: uint16(9264),
	4936: uint16(18217),
	4937: uint16(10573),
	4938: uint16(18208),
	4939: uint16(4409),
	4940: uint16(5941),
	4941: uint16(10248),
	4942: uint16(18218),
	4943: uint16(18206),
	4944: uint16(18215),
	4945: uint16(18225),
	4946: uint16(18210),
	4947: uint16(18211),
	4948: uint16(9497),
	4949: uint16(18216),
	4950: uint16(18213),
	4951: uint16(10759),
	4952: uint16(18219),
	4953: uint16(3903),
	4954: uint16(18207),
	4955: uint16(18221),
	4956: uint16(18220),
	4957: uint16(9802),
	4958: uint16(18227),
	4959: uint16(18238),
	4960: uint16(4701),
	4961: uint16(18241),
	4962: uint16(18223),
	4963: uint16(18228),
	4964: uint16(11341),
	4965: uint16(18237),
	4966: uint16(11316),
	4967: uint16(11529),
	4968: uint16(8791),
	4969: uint16(4682),
	4970: uint16(10321),
	4971: uint16(18243),
	4972: uint16(9472),
	4973: uint16(3856),
	4974: uint16(18236),
	4975: uint16(18232),
	4976: uint16(8273),
	4977: uint16(18226),
	4978: uint16(18234),
	4979: uint16(18239),
	4980: uint16(9739),
	4981: uint16(3849),
	4982: uint16(18231),
	4983: uint16(18240),
	4984: uint16(10327),
	4985: uint16(18235),
	4986: uint16(18230),
	4987: uint16(7476),
	4988: uint16(7182),
	4989: uint16(6923),
	4990: uint16(11063),
	4991: uint16(10278),
	4992: uint16(18246),
	4993: uint16(18255),
	4994: uint16(18233),
	4995: uint16(4694),
	4996: uint16(7511),
	4997: uint16(18244),
	4998: uint16(18249),
	4999: uint16(8274),
	5000: uint16(18245),
	5001: uint16(18252),
	5002: uint16(8766),
	5003: uint16(18253),
	5004: uint16(11317),
	5005: uint16(18242),
	5006: uint16(4631),
	5007: uint16(18248),
	5008: uint16(18251),
	5009: uint16(11019),
	5010: uint16(18254),
	5011: uint16(18247),
	5012: uint16(18250),
	5013: uint16(10760),
	5014: uint16(11776),
	5015: uint16(18258),
	5016: uint16(18265),
	5017: uint16(18257),
	5018: uint16(6946),
	5019: uint16(18224),
	5020: uint16(10541),
	5021: uint16(11009),
	5022: uint16(18264),
	5023: uint16(18263),
	5024: uint16(18259),
	5025: uint16(18260),
	5026: uint16(4117),
	5027: uint16(18262),
	5028: uint16(18256),
	5029: uint16(9012),
	5030: uint16(18261),
	5031: uint16(3933),
	5032: uint16(8449),
	5033: uint16(10530),
	5034: uint16(18266),
	5035: uint16(18432),
	5036: uint16(10040),
	5037: uint16(18269),
	5038: uint16(7477),
	5039: uint16(6952),
	5040: uint16(18434),
	5041: uint16(5405),
	5042: uint16(18435),
	5043: uint16(10328),
	5044: uint16(18268),
	5045: uint16(18229),
	5046: uint16(18267),
	5047: uint16(11822),
	5048: uint16(9473),
	5049: uint16(10322),
	5050: uint16(18442),
	5051: uint16(18448),
	5052: uint16(18449),
	5053: uint16(18436),
	5054: uint16(9813),
	5055: uint16(18446),
	5056: uint16(18438),
	5057: uint16(18440),
	5058: uint16(18450),
	5059: uint16(18439),
	5060: uint16(18443),
	5061: uint16(4177),
	5062: uint16(9540),
	5063: uint16(18444),
	5064: uint16(18447),
	5065: uint16(18437),
	5066: uint16(8197),
	5067: uint16(18441),
	5068: uint16(6662),
	5069: uint16(7716),
	5070: uint16(5647),
	5071: uint16(11091),
	5072: uint16(11096),
	5073: uint16(7249),
	5074: uint16(18454),
	5075: uint16(18452),
	5076: uint16(11821),
	5077: uint16(18451),
	5078: uint16(11348),
	5079: uint16(18453),
	5080: uint16(18455),
	5081: uint16(18456),
	5082: uint16(18459),
	5083: uint16(18457),
	5084: uint16(9474),
	5085: uint16(18458),
	5086: uint16(10028),
	5087: uint16(18445),
	5088: uint16(7250),
	5089: uint16(18460),
	5090: uint16(18465),
	5091: uint16(8275),
	5092: uint16(18464),
	5093: uint16(18433),
	5094: uint16(18466),
	5095: uint16(8232),
	5096: uint16(18461),
	5097: uint16(18463),
	5098: uint16(18462),
	5099: uint16(15376),
	5100: uint16(15361),
	5101: uint16(18468),
	5102: uint16(18467),
	5103: uint16(11349),
	5104: uint16(16667),
	5105: uint16(18469),
	5106: uint16(18470),
	5107: uint16(18471),
	5108: uint16(5942),
	5109: uint16(5171),
	5110: uint16(18473),
	5111: uint16(12348),
	5112: uint16(5204),
	5113: uint16(11545),
	5114: uint16(5458),
	5115: uint16(18474),
	5116: uint16(18475),
	5117: uint16(8781),
	5118: uint16(18476),
	5119: uint16(9561),
	5120: uint16(3865),
	5121: uint16(4418),
	5122: uint16(18481),
	5123: uint16(18482),
	5124: uint16(18477),
	5125: uint16(6684),
	5126: uint16(18478),
	5127: uint16(9761),
	5128: uint16(18479),
	5129: uint16(18480),
	5130: uint16(18490),
	5131: uint16(18484),
	5132: uint16(18487),
	5133: uint16(18483),
	5134: uint16(18485),
	5135: uint16(18486),
	5136: uint16(6967),
	5137: uint16(18488),
	5138: uint16(8736),
	5139: uint16(5685),
	5140: uint16(4641),
	5141: uint16(18491),
	5142: uint16(4638),
	5143: uint16(18496),
	5144: uint16(18492),
	5145: uint16(18495),
	5146: uint16(10009),
	5147: uint16(18493),
	5148: uint16(18494),
	5149: uint16(10279),
	5150: uint16(10041),
	5151: uint16(18497),
	5152: uint16(8540),
	5153: uint16(18507),
	5154: uint16(18503),
	5155: uint16(4426),
	5156: uint16(18501),
	5157: uint16(10761),
	5158: uint16(18502),
	5159: uint16(18499),
	5160: uint16(18500),
	5161: uint16(18505),
	5162: uint16(18508),
	5163: uint16(18506),
	5164: uint16(18504),
	5165: uint16(18498),
	5166: uint16(8759),
	5167: uint16(18515),
	5168: uint16(11017),
	5169: uint16(18513),
	5170: uint16(18514),
	5171: uint16(18509),
	5172: uint16(18511),
	5173: uint16(18512),
	5174: uint16(18510),
	5175: uint16(8005),
	5176: uint16(11800),
	5177: uint16(18519),
	5178: uint16(18520),
	5179: uint16(18688),
	5180: uint16(7689),
	5181: uint16(18522),
	5182: uint16(18525),
	5183: uint16(18517),
	5184: uint16(18516),
	5185: uint16(18689),
	5186: uint16(4411),
	5187: uint16(18523),
	5188: uint16(18690),
	5189: uint16(18524),
	5190: uint16(18521),
	5191: uint16(8978),
	5192: uint16(18518),
	5193: uint16(9799),
	5194: uint16(18694),
	5195: uint16(11290),
	5196: uint16(18693),
	5197: uint16(18692),
	5198: uint16(18701),
	5199: uint16(18695),
	5200: uint16(18703),
	5201: uint16(11333),
	5202: uint16(18706),
	5203: uint16(18697),
	5204: uint16(18698),
	5205: uint16(18702),
	5206: uint16(18705),
	5207: uint16(18704),
	5208: uint16(18696),
	5209: uint16(18699),
	5210: uint16(18716),
	5211: uint16(18709),
	5212: uint16(18707),
	5213: uint16(18708),
	5214: uint16(18713),
	5215: uint16(18714),
	5216: uint16(4617),
	5217: uint16(5153),
	5218: uint16(18712),
	5219: uint16(18691),
	5220: uint16(18711),
	5221: uint16(18715),
	5222: uint16(18710),
	5223: uint16(18717),
	5224: uint16(18719),
	5225: uint16(18718),
	5226: uint16(18721),
	5227: uint16(18720),
	5228: uint16(18489),
	5229: uint16(18725),
	5230: uint16(18722),
	5231: uint16(18723),
	5232: uint16(18724),
	5233: uint16(18726),
	5234: uint16(5707),
	5235: uint16(18728),
	5236: uint16(18727),
	5237: uint16(7183),
	5238: uint16(6195),
	5239: uint16(15622),
	5240: uint16(18729),
	5241: uint16(7216),
	5242: uint16(4632),
	5243: uint16(18730),
	5244: uint16(4145),
	5245: uint16(7478),
	5246: uint16(18731),
	5247: uint16(6196),
	5248: uint16(18732),
	5249: uint16(3904),
	5250: uint16(10268),
	5251: uint16(18733),
	5252: uint16(7753),
	5253: uint16(18740),
	5254: uint16(18737),
	5255: uint16(8782),
	5256: uint16(18738),
	5257: uint16(18735),
	5258: uint16(5437),
	5259: uint16(18734),
	5260: uint16(18741),
	5261: uint16(5653),
	5262: uint16(8509),
	5263: uint16(18747),
	5264: uint16(18743),
	5265: uint16(8468),
	5266: uint16(18742),
	5267: uint16(18745),
	5268: uint16(18736),
	5269: uint16(18746),
	5270: uint16(18748),
	5271: uint16(10062),
	5272: uint16(18744),
	5273: uint16(18749),
	5274: uint16(18751),
	5275: uint16(5938),
	5276: uint16(18739),
	5277: uint16(3872),
	5278: uint16(18750),
	5279: uint16(6458),
	5280: uint16(11605),
	5281: uint16(18752),
	5282: uint16(18753),
	5283: uint16(8276),
	5284: uint16(11521),
	5285: uint16(18754),
	5286: uint16(11284),
	5287: uint16(18755),
	5288: uint16(18756),
	5289: uint16(10563),
	5290: uint16(18757),
	5291: uint16(6431),
	5292: uint16(11522),
	5293: uint16(18762),
	5294: uint16(18763),
	5295: uint16(7479),
	5296: uint16(18761),
	5297: uint16(11334),
	5298: uint16(18758),
	5299: uint16(18760),
	5300: uint16(7964),
	5301: uint16(7773),
	5302: uint16(18759),
	5303: uint16(18764),
	5304: uint16(10498),
	5305: uint16(18766),
	5306: uint16(18765),
	5307: uint16(4683),
	5308: uint16(10762),
	5309: uint16(18767),
	5310: uint16(18779),
	5311: uint16(18769),
	5312: uint16(18770),
	5313: uint16(18771),
	5314: uint16(18772),
	5315: uint16(18776),
	5316: uint16(18777),
	5317: uint16(18775),
	5318: uint16(18773),
	5319: uint16(18768),
	5320: uint16(18774),
	5321: uint16(18778),
	5322: uint16(20246),
	5323: uint16(4359),
	5324: uint16(18781),
	5325: uint16(5438),
	5326: uint16(18780),
	5327: uint16(18945),
	5328: uint16(18944),
	5329: uint16(18947),
	5330: uint16(18946),
	5331: uint16(18948),
	5332: uint16(7184),
	5333: uint16(18949),
	5334: uint16(18950),
	5335: uint16(18951),
	5336: uint16(7965),
	5337: uint16(11318),
	5338: uint16(18952),
	5339: uint16(10499),
	5340: uint16(9765),
	5341: uint16(18953),
	5342: uint16(18954),
	5343: uint16(5898),
	5344: uint16(5131),
	5345: uint16(18955),
	5346: uint16(6730),
	5347: uint16(9760),
	5348: uint16(18956),
	5349: uint16(4655),
	5350: uint16(18957),
	5351: uint16(18959),
	5352: uint16(11350),
	5353: uint16(18958),
	5354: uint16(7717),
	5355: uint16(18960),
	5356: uint16(18961),
	5357: uint16(18962),
	5358: uint16(4912),
	5359: uint16(18963),
	5360: uint16(18964),
	5361: uint16(18965),
	5362: uint16(18966),
	5363: uint16(4656),
	5364: uint16(18967),
	5365: uint16(18968),
	5366: uint16(18969),
	5367: uint16(4433),
	5368: uint16(7687),
	5369: uint16(18970),
	5370: uint16(18971),
	5371: uint16(18972),
	5372: uint16(5919),
	5373: uint16(9050),
	5374: uint16(18973),
	5375: uint16(5686),
	5376: uint16(7733),
	5377: uint16(18976),
	5378: uint16(9475),
	5379: uint16(18975),
	5380: uint16(5648),
	5381: uint16(18974),
	5382: uint16(8534),
	5383: uint16(5132),
	5384: uint16(18977),
	5385: uint16(18978),
	5386: uint16(7480),
	5387: uint16(5708),
	5388: uint16(18979),
	5389: uint16(10763),
	5390: uint16(7998),
	5391: uint16(5205),
	5392: uint16(11092),
	5393: uint16(8233),
	5394: uint16(18980),
	5395: uint16(7718),
	5396: uint16(8783),
	5397: uint16(7481),
	5398: uint16(18981),
	5399: uint16(18984),
	5400: uint16(18985),
	5401: uint16(6429),
	5402: uint16(8481),
	5403: uint16(18983),
	5404: uint16(7482),
	5405: uint16(10269),
	5406: uint16(18982),
	5407: uint16(6731),
	5408: uint16(4146),
	5409: uint16(18989),
	5410: uint16(5687),
	5411: uint16(6733),
	5412: uint16(6732),
	5413: uint16(11820),
	5414: uint16(18988),
	5415: uint16(18987),
	5416: uint16(8198),
	5417: uint16(5164),
	5418: uint16(11810),
	5419: uint16(4633),
	5420: uint16(7483),
	5421: uint16(18986),
	5422: uint16(18991),
	5423: uint16(18992),
	5424: uint16(18990),
	5425: uint16(5943),
	5426: uint16(11295),
	5427: uint16(6734),
	5428: uint16(9734),
	5429: uint16(18995),
	5430: uint16(7967),
	5431: uint16(8737),
	5432: uint16(11285),
	5433: uint16(18998),
	5434: uint16(5963),
	5435: uint16(7966),
	5436: uint16(18994),
	5437: uint16(18999),
	5438: uint16(5964),
	5439: uint16(18996),
	5440: uint16(18997),
	5441: uint16(18993),
	5442: uint16(8001),
	5443: uint16(9512),
	5444: uint16(8718),
	5445: uint16(4412),
	5446: uint16(10063),
	5447: uint16(5154),
	5448: uint16(8979),
	5449: uint16(19002),
	5450: uint16(19000),
	5451: uint16(8747),
	5452: uint16(7968),
	5453: uint16(4913),
	5454: uint16(19001),
	5455: uint16(7738),
	5456: uint16(11561),
	5457: uint16(11807),
	5458: uint16(19003),
	5459: uint16(19014),
	5460: uint16(8980),
	5461: uint16(19013),
	5462: uint16(19010),
	5463: uint16(19018),
	5464: uint16(19011),
	5465: uint16(19007),
	5466: uint16(9051),
	5467: uint16(19006),
	5468: uint16(19004),
	5469: uint16(11264),
	5470: uint16(6735),
	5471: uint16(19008),
	5472: uint16(19005),
	5473: uint16(19012),
	5474: uint16(7251),
	5475: uint16(5920),
	5476: uint16(8537),
	5477: uint16(10788),
	5478: uint16(4153),
	5479: uint16(3905),
	5480: uint16(9476),
	5481: uint16(19016),
	5482: uint16(19015),
	5483: uint16(9541),
	5484: uint16(19020),
	5485: uint16(19009),
	5486: uint16(19019),
	5487: uint16(19021),
	5488: uint16(5899),
	5489: uint16(19017),
	5490: uint16(6197),
	5491: uint16(6964),
	5492: uint16(19022),
	5493: uint16(11319),
	5494: uint16(19025),
	5495: uint16(19028),
	5496: uint16(19026),
	5497: uint16(10260),
	5498: uint16(19023),
	5499: uint16(5439),
	5500: uint16(19027),
	5501: uint16(19029),
	5502: uint16(19033),
	5503: uint16(19030),
	5504: uint16(19032),
	5505: uint16(19031),
	5506: uint16(19034),
	5507: uint16(6928),
	5508: uint16(19036),
	5509: uint16(19035),
	5510: uint16(10311),
	5511: uint16(19200),
	5512: uint16(5688),
	5513: uint16(19037),
	5514: uint16(19201),
	5515: uint16(19202),
	5516: uint16(5155),
	5517: uint16(17696),
	5518: uint16(7512),
	5519: uint16(19203),
	5520: uint16(5965),
	5521: uint16(19204),
	5522: uint16(19205),
	5523: uint16(6685),
	5524: uint16(14637),
	5525: uint16(19206),
	5526: uint16(19207),
	5527: uint16(7185),
	5528: uint16(19208),
	5529: uint16(19209),
	5530: uint16(19210),
	5531: uint16(19211),
	5532: uint16(19212),
	5533: uint16(8714),
	5534: uint16(19213),
	5535: uint16(19215),
	5536: uint16(19214),
	5537: uint16(9477),
	5538: uint16(19216),
	5539: uint16(10764),
	5540: uint16(19217),
	5541: uint16(19218),
	5542: uint16(19219),
	5543: uint16(19220),
	5544: uint16(9529),
	5545: uint16(7484),
	5546: uint16(19221),
	5547: uint16(6218),
	5548: uint16(12045),
	5549: uint16(19222),
	5550: uint16(19223),
	5551: uint16(10270),
	5552: uint16(19224),
	5553: uint16(19232),
	5554: uint16(19225),
	5555: uint16(19227),
	5556: uint16(19226),
	5557: uint16(19228),
	5558: uint16(10789),
	5559: uint16(19229),
	5560: uint16(19230),
	5561: uint16(19231),
	5562: uint16(19233),
	5563: uint16(4620),
	5564: uint16(9030),
	5565: uint16(10312),
	5566: uint16(6465),
	5567: uint16(6198),
	5568: uint16(10286),
	5569: uint16(4414),
	5570: uint16(10029),
	5571: uint16(19236),
	5572: uint16(4914),
	5573: uint16(7988),
	5574: uint16(19235),
	5575: uint16(19240),
	5576: uint16(8792),
	5577: uint16(11074),
	5578: uint16(19238),
	5579: uint16(19239),
	5580: uint16(5133),
	5581: uint16(19241),
	5582: uint16(9794),
	5583: uint16(8510),
	5584: uint16(10064),
	5585: uint16(9244),
	5586: uint16(19237),
	5587: uint16(10790),
	5588: uint16(4427),
	5589: uint16(19243),
	5590: uint16(11783),
	5591: uint16(8993),
	5592: uint16(11812),
	5593: uint16(6736),
	5594: uint16(19242),
	5595: uint16(8464),
	5596: uint16(19259),
	5597: uint16(8199),
	5598: uint16(9559),
	5599: uint16(10287),
	5600: uint16(19246),
	5601: uint16(6686),
	5602: uint16(6737),
	5603: uint16(7485),
	5604: uint16(9796),
	5605: uint16(5900),
	5606: uint16(19245),
	5607: uint16(19244),
	5608: uint16(10313),
	5609: uint16(6944),
	5610: uint16(9265),
	5611: uint16(19248),
	5612: uint16(19249),
	5613: uint16(6199),
	5614: uint16(19247),
	5615: uint16(19250),
	5616: uint16(19251),
	5617: uint16(19253),
	5618: uint16(8450),
	5619: uint16(19252),
	5620: uint16(4933),
	5621: uint16(19255),
	5622: uint16(19254),
	5623: uint16(19256),
	5624: uint16(19258),
	5625: uint16(19260),
	5626: uint16(19261),
	5627: uint16(7989),
	5628: uint16(6958),
	5629: uint16(19262),
	5630: uint16(4657),
	5631: uint16(19263),
	5632: uint16(8277),
	5633: uint16(19264),
	5634: uint16(19265),
	5635: uint16(10314),
	5636: uint16(5134),
	5637: uint16(19266),
	5638: uint16(8981),
	5639: uint16(4154),
	5640: uint16(19267),
	5641: uint16(6992),
	5642: uint16(7765),
	5643: uint16(8460),
	5644: uint16(19270),
	5645: uint16(19269),
	5646: uint16(19268),
	5647: uint16(19276),
	5648: uint16(19274),
	5649: uint16(19271),
	5650: uint16(19273),
	5651: uint16(19272),
	5652: uint16(19275),
	5653: uint16(5206),
	5654: uint16(19279),
	5655: uint16(7990),
	5656: uint16(19280),
	5657: uint16(5944),
	5658: uint16(19277),
	5659: uint16(19278),
	5660: uint16(11784),
	5661: uint16(8982),
	5662: uint16(8200),
	5663: uint16(19281),
	5664: uint16(19284),
	5665: uint16(19282),
	5666: uint16(19283),
	5667: uint16(11320),
	5668: uint16(9478),
	5669: uint16(19287),
	5670: uint16(19285),
	5671: uint16(19286),
	5672: uint16(19288),
	5673: uint16(19464),
	5674: uint16(19291),
	5675: uint16(19292),
	5676: uint16(19290),
	5677: uint16(19289),
	5678: uint16(9052),
	5679: uint16(19456),
	5680: uint16(19460),
	5681: uint16(19457),
	5682: uint16(19293),
	5683: uint16(19458),
	5684: uint16(19459),
	5685: uint16(19466),
	5686: uint16(19461),
	5687: uint16(7991),
	5688: uint16(19463),
	5689: uint16(19465),
	5690: uint16(19462),
	5691: uint16(19468),
	5692: uint16(7186),
	5693: uint16(19467),
	5694: uint16(19469),
	5695: uint16(19470),
	5696: uint16(19473),
	5697: uint16(19472),
	5698: uint16(19471),
	5699: uint16(19475),
	5700: uint16(19474),
	5701: uint16(11093),
	5702: uint16(19477),
	5703: uint16(19476),
	5704: uint16(19478),
	5705: uint16(19479),
	5706: uint16(19481),
	5707: uint16(19480),
	5708: uint16(7719),
	5709: uint16(19482),
	5710: uint16(5452),
	5711: uint16(19483),
	5712: uint16(19485),
	5713: uint16(19486),
	5714: uint16(19487),
	5715: uint16(19484),
	5716: uint16(19488),
	5717: uint16(6965),
	5718: uint16(19489),
	5719: uint16(5135),
	5720: uint16(5650),
	5721: uint16(5901),
	5722: uint16(19490),
	5723: uint16(9551),
	5724: uint16(9245),
	5725: uint16(19491),
	5726: uint16(19494),
	5727: uint16(6931),
	5728: uint16(19493),
	5729: uint16(19492),
	5730: uint16(5689),
	5731: uint16(19495),
	5732: uint16(4658),
	5733: uint16(19497),
	5734: uint16(6459),
	5735: uint16(19496),
	5736: uint16(19505),
	5737: uint16(19499),
	5738: uint16(19501),
	5739: uint16(10564),
	5740: uint16(19498),
	5741: uint16(19500),
	5742: uint16(19504),
	5743: uint16(19502),
	5744: uint16(5136),
	5745: uint16(19503),
	5746: uint16(19506),
	5747: uint16(9785),
	5748: uint16(11575),
	5749: uint16(7187),
	5750: uint16(19507),
	5751: uint16(11265),
	5752: uint16(19509),
	5753: uint16(19508),
	5754: uint16(19512),
	5755: uint16(11296),
	5756: uint16(19511),
	5757: uint16(4684),
	5758: uint16(19510),
	5759: uint16(19515),
	5760: uint16(19514),
	5761: uint16(19513),
	5762: uint16(9233),
	5763: uint16(19516),
	5764: uint16(19517),
	5765: uint16(19518),
	5766: uint16(6219),
	5767: uint16(5636),
	5768: uint16(19519),
	5769: uint16(19520),
	5770: uint16(19521),
	5771: uint16(7720),
	5772: uint16(19522),
	5773: uint16(6924),
	5774: uint16(19523),
	5775: uint16(19524),
	5776: uint16(12544),
	5777: uint16(12381),
	5778: uint16(19525),
	5779: uint16(17487),
	5780: uint16(19526),
	5781: uint16(8707),
	5782: uint16(7690),
	5783: uint16(9759),
	5784: uint16(19527),
	5785: uint16(10548),
	5786: uint16(9011),
	5787: uint16(6237),
	5788: uint16(8712),
	5789: uint16(4105),
	5790: uint16(10839),
	5791: uint16(7734),
	5792: uint16(5693),
	5793: uint16(5440),
	5794: uint16(10549),
	5795: uint16(19528),
	5796: uint16(19530),
	5797: uint16(19529),
	5798: uint16(4415),
	5799: uint16(9557),
	5800: uint16(19531),
	5801: uint16(9814),
	5802: uint16(9234),
	5803: uint16(19532),
	5804: uint16(7217),
	5805: uint16(19534),
	5806: uint16(11041),
	5807: uint16(19549),
	5808: uint16(19536),
	5809: uint16(19537),
	5810: uint16(9000),
	5811: uint16(8511),
	5812: uint16(8278),
	5813: uint16(9479),
	5814: uint16(19535),
	5815: uint16(5172),
	5816: uint16(19544),
	5817: uint16(19541),
	5818: uint16(19716),
	5819: uint16(9480),
	5820: uint16(8767),
	5821: uint16(19538),
	5822: uint16(9053),
	5823: uint16(9266),
	5824: uint16(19539),
	5825: uint16(19543),
	5826: uint16(7743),
	5827: uint16(9798),
	5828: uint16(9003),
	5829: uint16(7969),
	5830: uint16(19542),
	5831: uint16(8461),
	5832: uint16(8451),
	5833: uint16(19540),
	5834: uint16(3848),
	5835: uint16(11777),
	5836: uint16(19545),
	5837: uint16(8512),
	5838: uint16(7188),
	5839: uint16(7721),
	5840: uint16(19547),
	5841: uint16(19546),
	5842: uint16(3918),
	5843: uint16(19548),
	5844: uint16(10254),
	5845: uint16(19718),
	5846: uint16(9530),
	5847: uint16(7754),
	5848: uint16(8760),
	5849: uint16(5463),
	5850: uint16(19717),
	5851: uint16(11286),
	5852: uint16(4126),
	5853: uint16(10550),
	5854: uint16(4416),
	5855: uint16(19712),
	5856: uint16(19713),
	5857: uint16(19714),
	5858: uint16(19715),
	5859: uint16(9498),
	5860: uint16(8706),
	5861: uint16(3906),
	5862: uint16(19719),
	5863: uint16(19720),
	5864: uint16(21250),
	5865: uint16(8476),
	5866: uint16(19721),
	5867: uint16(4178),
	5868: uint16(8235),
	5869: uint16(5902),
	5870: uint16(11321),
	5871: uint16(19722),
	5872: uint16(9227),
	5873: uint16(8279),
	5874: uint16(6966),
	5875: uint16(19723),
	5876: uint16(19726),
	5877: uint16(7236),
	5878: uint16(19724),
	5879: uint16(8202),
	5880: uint16(8201),
	5881: uint16(3907),
	5882: uint16(11562),
	5883: uint16(19728),
	5884: uint16(10065),
	5885: uint16(19730),
	5886: uint16(19729),
	5887: uint16(19727),
	5888: uint16(16963),
	5889: uint16(4915),
	5890: uint16(19533),
	5891: uint16(19732),
	5892: uint16(19731),
	5893: uint16(19733),
	5894: uint16(11287),
	5895: uint16(9536),
	5896: uint16(10765),
	5897: uint16(19734),
	5898: uint16(6968),
	5899: uint16(19735),
	5900: uint16(19736),
	5901: uint16(19737),
	5902: uint16(9216),
	5903: uint16(3913),
	5904: uint16(6200),
	5905: uint16(11801),
	5906: uint16(19741),
	5907: uint16(5651),
	5908: uint16(19738),
	5909: uint16(19739),
	5910: uint16(10323),
	5911: uint16(4659),
	5912: uint16(11288),
	5913: uint16(5406),
	5914: uint16(9267),
	5915: uint16(19742),
	5916: uint16(19743),
	5917: uint16(19744),
	5918: uint16(9217),
	5919: uint16(19746),
	5920: uint16(19745),
	5921: uint16(9522),
	5922: uint16(19747),
	5923: uint16(7189),
	5924: uint16(6975),
	5925: uint16(9786),
	5926: uint16(8784),
	5927: uint16(6993),
	5928: uint16(7755),
	5929: uint16(19748),
	5930: uint16(19749),
	5931: uint16(7740),
	5932: uint16(19750),
	5933: uint16(19751),
	5934: uint16(19752),
	5935: uint16(11342),
	5936: uint16(7190),
	5937: uint16(19754),
	5938: uint16(19753),
	5939: uint16(6201),
	5940: uint16(6226),
	5941: uint16(6687),
	5942: uint16(19757),
	5943: uint16(7237),
	5944: uint16(19756),
	5945: uint16(19755),
	5946: uint16(8520),
	5947: uint16(5966),
	5948: uint16(7970),
	5949: uint16(9999),
	5950: uint16(7192),
	5951: uint16(19758),
	5952: uint16(7486),
	5953: uint16(19761),
	5954: uint16(19759),
	5955: uint16(19760),
	5956: uint16(19763),
	5957: uint16(19762),
	5958: uint16(7513),
	5959: uint16(19764),
	5960: uint16(19765),
	5961: uint16(19766),
	5962: uint16(10031),
	5963: uint16(6450),
	5964: uint16(6976),
	5965: uint16(19767),
	5966: uint16(19768),
	5967: uint16(11523),
	5968: uint16(7204),
	5969: uint16(11085),
	5970: uint16(11563),
	5971: uint16(19769),
	5972: uint16(5441),
	5973: uint16(19770),
	5974: uint16(9218),
	5975: uint16(19773),
	5976: uint16(4695),
	5977: uint16(7722),
	5978: uint16(19771),
	5979: uint16(19772),
	5980: uint16(9023),
	5981: uint16(10804),
	5982: uint16(5467),
	5983: uint16(19775),
	5984: uint16(19776),
	5985: uint16(19774),
	5986: uint16(19778),
	5987: uint16(9534),
	5988: uint16(4642),
	5989: uint16(19782),
	5990: uint16(19779),
	5991: uint16(19781),
	5992: uint16(19777),
	5993: uint16(20014),
	5994: uint16(19780),
	5995: uint16(11594),
	5996: uint16(5945),
	5997: uint16(19790),
	5998: uint16(9235),
	5999: uint16(19785),
	6000: uint16(19788),
	6001: uint16(19786),
	6002: uint16(19791),
	6003: uint16(19792),
	6004: uint16(19784),
	6005: uint16(19797),
	6006: uint16(4179),
	6007: uint16(19783),
	6008: uint16(9996),
	6009: uint16(19787),
	6010: uint16(7487),
	6011: uint16(6202),
	6012: uint16(10791),
	6013: uint16(5443),
	6014: uint16(7205),
	6015: uint16(9499),
	6016: uint16(8204),
	6017: uint16(19795),
	6018: uint16(19789),
	6019: uint16(19794),
	6020: uint16(11042),
	6021: uint16(8983),
	6022: uint16(19796),
	6023: uint16(19793),
	6024: uint16(8203),
	6025: uint16(19800),
	6026: uint16(19799),
	6027: uint16(19798),
	6028: uint16(10766),
	6029: uint16(7258),
	6030: uint16(19801),
	6031: uint16(10558),
	6032: uint16(4147),
	6033: uint16(10277),
	6034: uint16(8785),
	6035: uint16(5207),
	6036: uint16(19803),
	6037: uint16(6204),
	6038: uint16(6667),
	6039: uint16(19802),
	6040: uint16(7756),
	6041: uint16(7757),
	6042: uint16(19968),
	6043: uint16(19970),
	6044: uint16(7514),
	6045: uint16(19969),
	6046: uint16(19971),
	6047: uint16(5426),
	6048: uint16(10276),
	6049: uint16(6977),
	6050: uint16(11778),
	6051: uint16(19805),
	6052: uint16(6487),
	6053: uint16(11806),
	6054: uint16(19973),
	6055: uint16(19972),
	6056: uint16(19974),
	6057: uint16(19804),
	6058: uint16(9544),
	6059: uint16(9268),
	6060: uint16(9014),
	6061: uint16(19979),
	6062: uint16(8738),
	6063: uint16(19975),
	6064: uint16(19976),
	6065: uint16(5644),
	6066: uint16(19978),
	6067: uint16(5903),
	6068: uint16(19977),
	6069: uint16(7488),
	6070: uint16(4696),
	6071: uint16(19983),
	6072: uint16(6430),
	6073: uint16(8280),
	6074: uint16(9001),
	6075: uint16(4634),
	6076: uint16(19981),
	6077: uint16(19982),
	6078: uint16(8994),
	6079: uint16(19980),
	6080: uint16(19984),
	6081: uint16(19990),
	6082: uint16(19993),
	6083: uint16(19992),
	6084: uint16(9228),
	6085: uint16(19985),
	6086: uint16(19986),
	6087: uint16(19989),
	6088: uint16(19991),
	6089: uint16(5407),
	6090: uint16(19994),
	6091: uint16(19988),
	6092: uint16(19987),
	6093: uint16(19998),
	6094: uint16(19999),
	6095: uint16(20000),
	6096: uint16(19997),
	6097: uint16(19996),
	6098: uint16(7489),
	6099: uint16(9481),
	6100: uint16(19995),
	6101: uint16(20004),
	6102: uint16(20002),
	6103: uint16(20003),
	6104: uint16(20001),
	6105: uint16(8535),
	6106: uint16(20005),
	6107: uint16(20006),
	6108: uint16(20008),
	6109: uint16(4916),
	6110: uint16(20007),
	6111: uint16(11097),
	6112: uint16(20019),
	6113: uint16(20009),
	6114: uint16(20012),
	6115: uint16(20010),
	6116: uint16(20011),
	6117: uint16(20013),
	6118: uint16(20015),
	6119: uint16(20016),
	6120: uint16(20017),
	6121: uint16(20020),
	6122: uint16(20018),
	6123: uint16(20021),
	6124: uint16(20023),
	6125: uint16(20022),
	6126: uint16(8984),
	6127: uint16(11078),
	6128: uint16(20024),
	6129: uint16(8205),
	6130: uint16(20025),
	6131: uint16(10531),
	6132: uint16(20026),
	6133: uint16(4618),
	6134: uint16(4123),
	6135: uint16(4918),
	6136: uint16(4917),
	6137: uint16(20027),
	6138: uint16(20028),
	6139: uint16(20029),
	6140: uint16(20030),
	6141: uint16(20031),
	6142: uint16(4919),
	6143: uint16(4660),
	6144: uint16(6205),
	6145: uint16(10005),
	6146: uint16(20033),
	6147: uint16(20032),
	6148: uint16(20034),
	6149: uint16(4155),
	6150: uint16(20037),
	6151: uint16(20036),
	6152: uint16(20035),
	6153: uint16(20038),
	6154: uint16(20041),
	6155: uint16(3878),
	6156: uint16(20039),
	6157: uint16(20043),
	6158: uint16(20042),
	6159: uint16(20045),
	6160: uint16(20044),
	6161: uint16(20046),
	6162: uint16(9485),
	6163: uint16(20047),
	6164: uint16(20048),
	6165: uint16(20050),
	6166: uint16(20049),
	6167: uint16(10315),
	6168: uint16(20051),
	6169: uint16(20052),
	6170: uint16(6468),
	6171: uint16(20053),
	6172: uint16(20054),
	6173: uint16(10792),
	6174: uint16(8234),
	6175: uint16(3843),
	6176: uint16(8490),
	6177: uint16(20055),
	6178: uint16(10316),
	6179: uint16(20058),
	6180: uint16(20056),
	6181: uint16(6206),
	6182: uint16(20057),
	6183: uint16(5921),
	6184: uint16(10532),
	6185: uint16(20060),
	6186: uint16(20224),
	6187: uint16(20061),
	6188: uint16(20225),
	6189: uint16(4096),
	6190: uint16(7735),
	6191: uint16(7259),
	6192: uint16(4920),
	6193: uint16(20226),
	6194: uint16(9797),
	6195: uint16(20228),
	6196: uint16(4097),
	6197: uint16(20227),
	6198: uint16(8995),
	6199: uint16(11564),
	6200: uint16(9482),
	6201: uint16(20059),
	6202: uint16(11525),
	6203: uint16(5904),
	6204: uint16(11322),
	6205: uint16(5464),
	6206: uint16(11539),
	6207: uint16(5639),
	6208: uint16(8513),
	6209: uint16(17920),
	6210: uint16(20229),
	6211: uint16(4619),
	6212: uint16(7758),
	6213: uint16(4661),
	6214: uint16(20231),
	6215: uint16(20232),
	6216: uint16(20230),
	6217: uint16(5699),
	6218: uint16(6460),
	6219: uint16(7490),
	6220: uint16(4098),
	6221: uint16(11576),
	6222: uint16(20234),
	6223: uint16(19725),
	6224: uint16(20233),
	6225: uint16(20237),
	6226: uint16(20235),
	6227: uint16(20236),
	6228: uint16(20238),
	6229: uint16(20239),
	6230: uint16(11595),
	6231: uint16(20240),
	6232: uint16(20241),
	6233: uint16(7976),
	6234: uint16(10010),
	6235: uint16(7772),
	6236: uint16(4934),
	6237: uint16(11289),
	6238: uint16(4428),
	6239: uint16(7191),
	6240: uint16(5946),
	6241: uint16(20244),
	6242: uint16(20243),
	6243: uint16(6738),
	6244: uint16(20245),
	6245: uint16(20242),
	6246: uint16(6663),
	6247: uint16(20249),
	6248: uint16(18700),
	6249: uint16(12597),
	6250: uint16(7766),
	6251: uint16(20247),
	6252: uint16(11524),
	6253: uint16(9552),
	6254: uint16(4106),
	6255: uint16(8002),
	6256: uint16(6933),
	6257: uint16(10518),
	6258: uint16(4127),
	6259: uint16(11596),
	6260: uint16(11338),
	6261: uint16(20250),
	6262: uint16(9252),
	6263: uint16(7002),
	6264: uint16(20251),
	6265: uint16(20252),
	6266: uint16(7723),
	6267: uint16(20253),
	6268: uint16(11597),
	6269: uint16(20248),
	6270: uint16(20255),
	6271: uint16(20257),
	6272: uint16(20256),
	6273: uint16(20254),
	6274: uint16(20258),
	6275: uint16(20259),
	6276: uint16(8281),
	6277: uint16(4417),
	6278: uint16(20260),
	6279: uint16(11031),
	6280: uint16(20261),
	6281: uint16(20262),
	6282: uint16(11785),
	6283: uint16(14864),
	6284: uint16(20263),
	6285: uint16(20264),
	6286: uint16(20265),
	6287: uint16(20269),
	6288: uint16(20266),
	6289: uint16(20267),
	6290: uint16(20268),
	6291: uint16(20270),
	6292: uint16(7971),
	6293: uint16(11094),
	6294: uint16(7972),
	6295: uint16(20271),
	6296: uint16(10066),
	6297: uint16(20272),
	6298: uint16(21042),
	6299: uint16(11051),
	6300: uint16(20273),
	6301: uint16(20274),
	6302: uint16(20275),
	6303: uint16(4662),
	6304: uint16(20277),
	6305: uint16(7736),
	6306: uint16(20278),
	6307: uint16(5635),
	6308: uint16(20279),
	6309: uint16(20283),
	6310: uint16(20281),
	6311: uint16(20282),
	6312: uint16(4690),
	6313: uint16(20280),
	6314: uint16(20284),
	6315: uint16(20285),
	6316: uint16(3879),
	6317: uint16(20286),
	6318: uint16(20287),
	6319: uint16(7491),
	6320: uint16(20288),
	6321: uint16(5158),
	6322: uint16(20291),
	6323: uint16(20290),
	6324: uint16(20289),
	6325: uint16(19024),
	6326: uint16(10555),
	6327: uint16(20292),
	6328: uint16(20293),
	6329: uint16(20294),
	6330: uint16(20295),
	6331: uint16(20296),
	6332: uint16(20297),
	6333: uint16(4921),
	6334: uint16(20298),
	6335: uint16(20299),
	6336: uint16(9730),
	6337: uint16(20301),
	6338: uint16(4378),
	6339: uint16(20304),
	6340: uint16(20303),
	6341: uint16(4099),
	6342: uint16(5408),
	6343: uint16(10534),
	6344: uint16(8985),
	6345: uint16(6401),
	6346: uint16(6207),
	6347: uint16(7238),
	6348: uint16(7739),
	6349: uint16(20306),
	6350: uint16(20305),
	6351: uint16(11297),
	6352: uint16(4935),
	6353: uint16(10033),
	6354: uint16(9531),
	6355: uint16(7771),
	6356: uint16(11565),
	6357: uint16(5690),
	6358: uint16(20309),
	6359: uint16(20308),
	6360: uint16(10794),
	6361: uint16(9483),
	6362: uint16(4143),
	6363: uint16(20310),
	6364: uint16(20307),
	6365: uint16(10288),
	6366: uint16(11337),
	6367: uint16(20311),
	6368: uint16(20312),
	6369: uint16(20314),
	6370: uint16(8521),
	6371: uint16(4666),
	6372: uint16(4667),
	6373: uint16(20313),
	6374: uint16(4936),
	6375: uint16(5905),
	6376: uint16(4937),
	6377: uint16(9246),
	6378: uint16(11583),
	6379: uint16(5947),
	6380: uint16(20315),
	6381: uint16(20316),
	6382: uint16(20317),
	6383: uint16(20480),
	6384: uint16(20482),
	6385: uint16(20481),
	6386: uint16(10326),
	6387: uint16(20483),
	6388: uint16(20484),
	6389: uint16(20485),
	6390: uint16(20486),
	6391: uint16(20488),
	6392: uint16(20487),
	6393: uint16(20489),
	6394: uint16(10067),
	6395: uint16(17707),
	6396: uint16(7688),
	6397: uint16(5137),
	6398: uint16(20490),
	6399: uint16(20491),
	6400: uint16(12555),
	6401: uint16(15386),
	6402: uint16(10034),
	6403: uint16(3930),
	6404: uint16(3866),
	6405: uint16(6739),
	6406: uint16(10767),
	6407: uint16(7517),
	6408: uint16(20492),
	6409: uint16(11070),
	6410: uint16(20493),
	6411: uint16(11323),
	6412: uint16(4129),
	6413: uint16(6688),
	6414: uint16(20494),
	6415: uint16(4429),
	6416: uint16(20495),
	6417: uint16(20496),
	6418: uint16(20498),
	6419: uint16(20499),
	6420: uint16(20501),
	6421: uint16(20497),
	6422: uint16(20500),
	6423: uint16(4922),
	6424: uint16(20502),
	6425: uint16(20503),
	6426: uint16(20504),
	6427: uint16(20505),
	6428: uint16(20506),
	6429: uint16(20508),
	6430: uint16(20507),
	6431: uint16(20510),
	6432: uint16(20513),
	6433: uint16(20509),
	6434: uint16(20511),
	6435: uint16(20512),
	6436: uint16(20514),
	6437: uint16(5409),
	6438: uint16(6994),
	6439: uint16(20515),
	6440: uint16(20516),
	6441: uint16(6208),
	6442: uint16(20517),
	6443: uint16(4637),
	6444: uint16(9774),
	6445: uint16(20518),
	6446: uint16(20519),
	6447: uint16(8761),
	6448: uint16(9546),
	6449: uint16(20520),
	6450: uint16(9820),
	6451: uint16(8491),
	6452: uint16(4151),
	6453: uint16(5453),
	6454: uint16(5454),
	6455: uint16(8786),
	6456: uint16(20525),
	6457: uint16(5455),
	6458: uint16(4430),
	6459: uint16(20524),
	6460: uint16(20522),
	6461: uint16(20523),
	6462: uint16(20521),
	6463: uint16(20535),
	6464: uint16(20526),
	6465: uint16(20527),
	6466: uint16(20528),
	6467: uint16(20529),
	6468: uint16(20531),
	6469: uint16(20530),
	6470: uint16(7224),
	6471: uint16(20532),
	6472: uint16(20534),
	6473: uint16(5138),
	6474: uint16(20533),
	6475: uint16(8282),
	6476: uint16(5906),
	6477: uint16(20536),
	6478: uint16(8492),
	6479: uint16(20537),
	6480: uint16(9484),
	6481: uint16(20538),
	6482: uint16(20543),
	6483: uint16(20541),
	6484: uint16(20540),
	6485: uint16(20542),
	6486: uint16(20539),
	6487: uint16(20545),
	6488: uint16(20544),
	6489: uint16(20547),
	6490: uint16(5410),
	6491: uint16(20546),
	6492: uint16(20548),
	6493: uint16(20549),
	6494: uint16(20551),
	6495: uint16(20550),
	6496: uint16(20552),
	6497: uint16(20554),
	6498: uint16(20553),
	6499: uint16(6235),
	6500: uint16(20555),
	6501: uint16(20556),
	6502: uint16(4635),
	6503: uint16(20557),
	6504: uint16(20558),
	6505: uint16(7760),
	6506: uint16(20559),
	6507: uint16(20560),
	6508: uint16(20561),
	6509: uint16(20562),
	6510: uint16(6209),
	6511: uint16(20563),
	6512: uint16(20564),
	6513: uint16(20565),
	6514: uint16(20566),
	6515: uint16(20567),
	6516: uint16(10000),
	6517: uint16(20569),
	6518: uint16(10245),
	6519: uint16(20570),
	6520: uint16(20568),
	6521: uint16(20572),
	6522: uint16(20571),
	6523: uint16(20573),
	6524: uint16(20736),
	6525: uint16(20737),
	6526: uint16(20738),
	6527: uint16(20739),
	6528: uint16(20740),
	6529: uint16(20741),
	6530: uint16(20742),
	6531: uint16(20743),
	6532: uint16(20744),
	6533: uint16(20745),
	6534: uint16(20746),
	6535: uint16(20747),
	6536: uint16(20748),
	6537: uint16(20749),
	6538: uint16(15380),
	6539: uint16(20750),
	6540: uint16(17239),
	6541: uint16(5139),
	6542: uint16(4608),
	6543: uint16(6417),
	6544: uint16(20752),
	6545: uint16(20751),
	6546: uint16(11012),
	6547: uint16(20754),
	6548: uint16(20755),
	6549: uint16(20753),
	6550: uint16(20756),
	6551: uint16(10817),
	6552: uint16(20757),
	6553: uint16(5210),
	6554: uint16(11780),
	6555: uint16(20758),
	6556: uint16(20760),
	6557: uint16(3869),
	6558: uint16(20761),
	6559: uint16(10506),
	6560: uint16(20759),
	6561: uint16(20762),
	6562: uint16(20763),
	6563: uint16(20764),
	6564: uint16(20765),
	6565: uint16(20766),
	6566: uint16(10829),
	6567: uint16(6668),
	6568: uint16(6489),
	6569: uint16(8206),
	6570: uint16(20767),
	6571: uint16(20770),
	6572: uint16(20768),
	6573: uint16(20771),
	6574: uint16(5968),
	6575: uint16(20769),
	6576: uint16(20772),
	6577: uint16(20773),
	6578: uint16(20774),
	6579: uint16(20778),
	6580: uint16(6665),
	6581: uint16(8515),
	6582: uint16(20779),
	6583: uint16(20776),
	6584: uint16(20775),
	6585: uint16(20777),
	6586: uint16(5694),
	6587: uint16(20783),
	6588: uint16(20782),
	6589: uint16(20781),
	6590: uint16(3858),
	6591: uint16(20793),
	6592: uint16(20789),
	6593: uint16(20790),
	6594: uint16(20786),
	6595: uint16(20792),
	6596: uint16(20788),
	6597: uint16(4673),
	6598: uint16(11819),
	6599: uint16(20791),
	6600: uint16(20787),
	6601: uint16(20785),
	6602: uint16(20784),
	6603: uint16(20795),
	6604: uint16(20798),
	6605: uint16(20797),
	6606: uint16(20796),
	6607: uint16(10280),
	6608: uint16(20794),
	6609: uint16(3922),
	6610: uint16(20799),
	6611: uint16(20801),
	6612: uint16(4686),
	6613: uint16(20780),
	6614: uint16(4118),
	6615: uint16(20803),
	6616: uint16(20802),
	6617: uint16(20800),
	6618: uint16(8716),
	6619: uint16(10831),
	6620: uint16(11577),
	6621: uint16(20804),
	6622: uint16(20805),
	6623: uint16(20806),
	6624: uint16(20807),
	6625: uint16(20808),
	6626: uint16(8986),
	6627: uint16(20809),
	6628: uint16(10006),
	6629: uint16(20814),
	6630: uint16(20810),
	6631: uint16(20811),
	6632: uint16(10768),
	6633: uint16(11043),
	6634: uint16(9519),
	6635: uint16(20815),
	6636: uint16(20816),
	6637: uint16(9501),
	6638: uint16(20813),
	6639: uint16(20812),
	6640: uint16(4361),
	6641: uint16(20824),
	6642: uint16(20823),
	6643: uint16(4180),
	6644: uint16(20821),
	6645: uint16(20820),
	6646: uint16(20818),
	6647: uint16(4698),
	6648: uint16(20817),
	6649: uint16(6929),
	6650: uint16(4360),
	6651: uint16(6210),
	6652: uint16(20827),
	6653: uint16(20826),
	6654: uint16(20825),
	6655: uint16(20822),
	6656: uint16(20828),
	6657: uint16(20829),
	6658: uint16(20996),
	6659: uint16(20995),
	6660: uint16(20997),
	6661: uint16(4108),
	6662: uint16(20992),
	6663: uint16(20993),
	6664: uint16(6227),
	6665: uint16(11032),
	6666: uint16(20994),
	6667: uint16(10769),
	6668: uint16(21002),
	6669: uint16(20998),
	6670: uint16(21003),
	6671: uint16(21000),
	6672: uint16(20999),
	6673: uint16(5691),
	6674: uint16(21004),
	6675: uint16(21005),
	6676: uint16(21006),
	6677: uint16(21001),
	6678: uint16(20819),
	6679: uint16(21007),
	6680: uint16(9024),
	6681: uint16(21011),
	6682: uint16(21012),
	6683: uint16(21010),
	6684: uint16(21009),
	6685: uint16(21015),
	6686: uint16(21008),
	6687: uint16(21013),
	6688: uint16(21014),
	6689: uint16(21017),
	6690: uint16(21016),
	6691: uint16(21019),
	6692: uint16(21020),
	6693: uint16(21021),
	6694: uint16(11816),
	6695: uint16(21018),
	6696: uint16(8522),
	6697: uint16(6476),
	6698: uint16(21022),
	6699: uint16(21023),
	6700: uint16(21024),
	6701: uint16(21025),
	6702: uint16(21026),
	6703: uint16(5907),
	6704: uint16(21027),
	6705: uint16(21028),
	6706: uint16(6926),
	6707: uint16(21029),
	6708: uint16(21030),
	6709: uint16(21031),
	6710: uint16(21032),
	6711: uint16(21035),
	6712: uint16(21033),
	6713: uint16(11803),
	6714: uint16(21034),
	6715: uint16(11598),
	6716: uint16(21036),
	6717: uint16(11578),
	6718: uint16(21037),
	6719: uint16(9821),
	6720: uint16(21038),
	6721: uint16(21040),
	6722: uint16(21041),
	6723: uint16(21039),
	6724: uint16(6220),
	6725: uint16(11052),
	6726: uint16(10818),
	6727: uint16(13654),
	6728: uint16(15423),
	6729: uint16(10842),
	6730: uint16(4362),
	6731: uint16(21043),
	6732: uint16(5167),
	6733: uint16(21044),
	6734: uint16(21045),
	6735: uint16(21046),
	6736: uint16(6228),
	6737: uint16(21047),
	6738: uint16(16179),
	6739: uint16(11066),
	6740: uint16(8514),
	6741: uint16(21048),
	6742: uint16(21050),
	6743: uint16(21049),
	6744: uint16(21051),
	6745: uint16(21052),
	6746: uint16(21053),
	6747: uint16(21054),
	6748: uint16(21055),
	6749: uint16(21056),
	6750: uint16(21057),
	6751: uint16(21058),
	6752: uint16(21059),
	6753: uint16(21060),
	6754: uint16(21061),
	6755: uint16(21062),
	6756: uint16(21063),
	6757: uint16(9219),
	6758: uint16(5948),
	6759: uint16(21065),
	6760: uint16(8236),
	6761: uint16(21066),
	6762: uint16(21067),
	6763: uint16(10240),
	6764: uint16(21068),
	6765: uint16(21069),
	6766: uint16(16918),
	6767: uint16(19257),
	6768: uint16(20300),
	6769: uint16(21070),
	6770: uint16(21071),
	6771: uint16(21073),
	6772: uint16(21074),
	6773: uint16(21075),
	6774: uint16(11599),
	6775: uint16(21072),
	6776: uint16(21076),
	6777: uint16(21077),
	6778: uint16(21079),
	6779: uint16(21078),
	6780: uint16(21081),
	6781: uint16(21082),
	6782: uint16(21080),
	6783: uint16(11541),
	6784: uint16(21083),
	6785: uint16(21084),
	6786: uint16(16947),
	6787: uint16(21085),
	6788: uint16(9),
	6789: uint16(83),
	6790: uint16(79),
	6791: uint16(82),
	6792: uint16(84),
	6793: uint16(41),
	6794: uint16(42),
	6795: uint16(85),
	6796: uint16(59),
	6797: uint16(3),
	6798: uint16(4),
	6799: uint16(30),
	6800: uint16(527),
	6801: uint16(528),
	6802: uint16(529),
	6803: uint16(530),
	6804: uint16(531),
	6805: uint16(532),
	6806: uint16(533),
	6807: uint16(534),
	6808: uint16(535),
	6809: uint16(536),
	6810: uint16(6),
	6811: uint16(7),
	6812: uint16(66),
	6813: uint16(64),
	6814: uint16(67),
	6815: uint16(8),
	6816: uint16(86),
	6817: uint16(544),
	6818: uint16(545),
	6819: uint16(546),
	6820: uint16(547),
	6821: uint16(548),
	6822: uint16(549),
	6823: uint16(550),
	6824: uint16(551),
	6825: uint16(552),
	6826: uint16(553),
	6827: uint16(554),
	6828: uint16(555),
	6829: uint16(556),
	6830: uint16(557),
	6831: uint16(558),
	6832: uint16(559),
	6833: uint16(560),
	6834: uint16(561),
	6835: uint16(562),
	6836: uint16(563),
	6837: uint16(564),
	6838: uint16(565),
	6839: uint16(566),
	6840: uint16(567),
	6841: uint16(568),
	6842: uint16(569),
	6843: uint16(45),
	6844: uint16(46),
	6845: uint16(15),
	6846: uint16(17),
	6847: uint16(13),
	6848: uint16(576),
	6849: uint16(577),
	6850: uint16(578),
	6851: uint16(579),
	6852: uint16(580),
	6853: uint16(581),
	6854: uint16(582),
	6855: uint16(583),
	6856: uint16(584),
	6857: uint16(585),
	6858: uint16(586),
	6859: uint16(587),
	6860: uint16(588),
	6861: uint16(589),
	6862: uint16(590),
	6863: uint16(591),
	6864: uint16(592),
	6865: uint16(593),
	6866: uint16(594),
	6867: uint16(595),
	6868: uint16(596),
	6869: uint16(597),
	6870: uint16(598),
	6871: uint16(599),
	6872: uint16(600),
	6873: uint16(601),
	6874: uint16(47),
	6875: uint16(34),
	6876: uint16(48),
	6877: uint16(16),
	6878: uint16(78),
}

func _fuzzycmp(tls *TLS, a uintptr, b uintptr) (r int32) {
	for {
		if !(*(*uint8)(unsafe.Pointer(a)) != 0 && *(*uint8)(unsafe.Pointer(b)) != 0) {
			break
		}
		for *(*uint8)(unsafe.Pointer(a)) != 0 && uint32(*(*uint8)(unsafe.Pointer(a)))|uint32(32)-uint32('a') > uint32(26) && uint32(int32(*(*uint8)(unsafe.Pointer(a)))-int32('0')) > uint32(10) {
			a++
		}
		if uint32(*(*uint8)(unsafe.Pointer(a)))|uint32(32) != uint32(*(*uint8)(unsafe.Pointer(b))) {
			return int32(1)
		}
		goto _1
	_1:
		;
		a++
		b++
	}
	return BoolInt32(int32(*(*uint8)(unsafe.Pointer(a))) != int32(*(*uint8)(unsafe.Pointer(b))))
}

func _find_charmap(tls *TLS, name uintptr) (r Tsize_t) {
	var s uintptr
	_ = s
	if !(*(*uint8)(unsafe.Pointer(name)) != 0) {
		name = uintptr(unsafe.Pointer(&_charmaps))
	} /* "utf8" */
	s = uintptr(unsafe.Pointer(&_charmaps))
	for {
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			break
		}
		if !(_fuzzycmp(tls, name, s) != 0) {
			for {
				if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
					break
				}
				goto _2
			_2:
				;
				s += uintptr(Xstrlen(tls, s) + uint64(1))
			}
			return uint64(int64(s+uintptr(1)) - t__predefined_ptrdiff_t(uintptr(unsafe.Pointer(&_charmaps))))
		}
		s += uintptr(Xstrlen(tls, s) + uint64(1))
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			if int32(*(*uint8)(unsafe.Pointer(s + 1))) > int32(0200) {
				s += uintptr(2)
			} else {
				s += uintptr(uint32(2) + (uint32(64)-uint32(*(*uint8)(unsafe.Pointer(s + 1))))*uint32(5))
			}
		}
		goto _1
	_1:
	}
	return uint64(-Int32FromInt32(1))
}

type Tstateful_cd = struct {
	Fbase_cd Ticonv_t
	Fstate   uint32
}

func _combine_to_from(tls *TLS, t Tsize_t, f Tsize_t) (r Ticonv_t) {
	return uintptr(f<<Int32FromInt32(16) | t<<Int32FromInt32(1) | Uint64FromInt32(1))
}

func _extract_from(tls *TLS, cd Ticonv_t) (r Tsize_t) {
	return uint64(cd) >> int32(16)
}

func _extract_to(tls *TLS, cd Ticonv_t) (r Tsize_t) {
	return uint64(cd) >> int32(1) & uint64(0x7fff)
}

func Xiconv_open(tls *TLS, to uintptr, from uintptr) (r Ticonv_t) {
	if __ccgo_strace {
		trc("tls=%v to=%v from=%v, (%v:)", tls, to, from, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var cd Ticonv_t
	var f, t, v1, v2 Tsize_t
	var scd uintptr
	var v3 bool
	_, _, _, _, _, _, _ = cd, f, scd, t, v1, v2, v3
	v1 = _find_charmap(tls, to)
	t = v1
	if v3 = v1 == uint64(-Int32FromInt32(1)); !v3 {
		v2 = _find_charmap(tls, from)
		f = v2
	}
	if v3 || v2 == uint64(-Int32FromInt32(1)) || int32(_charmaps[t]) >= int32(0330) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(-Int32FromInt32(1))
	}
	cd = _combine_to_from(tls, t, f)
	switch int32(_charmaps[f]) {
	case int32(UTF_16):
		fallthrough
	case int32(UTF_32):
		fallthrough
	case int32(UCS2):
		fallthrough
	case int32(ISO2022_JP):
		scd = Xmalloc(tls, uint64(16))
		if !(scd != 0) {
			return uintptr(-Int32FromInt32(1))
		}
		(*Tstateful_cd)(unsafe.Pointer(scd)).Fbase_cd = cd
		(*Tstateful_cd)(unsafe.Pointer(scd)).Fstate = uint32(0)
		cd = scd
	}
	return cd
}

func _get_16(tls *TLS, s uintptr, e int32) (r uint32) {
	e &= int32(1)
	return uint32(int32(*(*uint8)(unsafe.Pointer(s + uintptr(e))))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(s + uintptr(int32(1)-e)))))
}

func _put_16(tls *TLS, s uintptr, c uint32, e int32) {
	e &= int32(1)
	*(*uint8)(unsafe.Pointer(s + uintptr(e))) = uint8(c >> int32(8))
	*(*uint8)(unsafe.Pointer(s + uintptr(int32(1)-e))) = uint8(c)
}

func _get_32(tls *TLS, s uintptr, e int32) (r uint32) {
	e &= int32(3)
	return (uint32(*(*uint8)(unsafe.Pointer(s + uintptr(e))))+0)<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(1)))))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(2)))))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(3)))))
}

func _put_32(tls *TLS, s uintptr, c uint32, e int32) {
	e &= int32(3)
	*(*uint8)(unsafe.Pointer(s + uintptr(e^0))) = uint8(c >> int32(24))
	*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(1)))) = uint8(c >> int32(16))
	*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(2)))) = uint8(c >> int32(8))
	*(*uint8)(unsafe.Pointer(s + uintptr(e^int32(3)))) = uint8(c)
}

/* Adapt as needed */

func _legacy_map(tls *TLS, map1 uintptr, c uint32) (r uint32) {
	var x, v1 uint32
	_, _ = x, v1
	if c < uint32(int32(4)*int32(*(*uint8)(unsafe.Pointer(map1 + uintptr(-Int32FromInt32(1)))))) {
		return c
	}
	x = c - uint32(int32(4)*int32(*(*uint8)(unsafe.Pointer(map1 + uintptr(-Int32FromInt32(1))))))
	x = uint32(int32(*(*uint8)(unsafe.Pointer(map1 + uintptr(x*uint32(5)/uint32(4)))))>>(uint32(2)*x%uint32(8)) | int32(*(*uint8)(unsafe.Pointer(map1 + uintptr(x*uint32(5)/uint32(4)+uint32(1)))))<<(uint32(8)-uint32(2)*x%uint32(8))&int32(1023))
	if x < uint32(256) {
		v1 = x
	} else {
		v1 = uint32(_legacy_chars[x-uint32(256)])
	}
	return v1
}

func _uni_to_jis(tls *TLS, c uint32) (r uint32) {
	var b, d, i, j, nel uint32
	_, _, _, _, _ = b, d, i, j, nel
	nel = uint32(Uint64FromInt64(13758) / Uint64FromInt64(2))
	b = uint32(0)
	for {
		i = nel / uint32(2)
		j = uint32(_rev_jis[b+i])
		d = uint32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_jis0208)) + uintptr(j/uint32(256))*188 + uintptr(j%uint32(256))*2)))
		if d == c {
			return j + uint32(0x2121)
		} else {
			if nel == uint32(1) {
				return uint32(0)
			} else {
				if c < d {
					nel /= uint32(2)
				} else {
					b += i
					nel -= nel / uint32(2)
				}
			}
		}
		goto _1
	_1:
	}
	return r
}

func Xiconv(tls *TLS, cd Ticonv_t, in uintptr, inb uintptr, out uintptr, outb uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v cd=%v in=%v inb=%v out=%v outb=%v, (%v:)", tls, cd, in, inb, out, outb, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var c, d, from, to, v62 uint32
	var err, i, i1, j, j1, v25, v26, v27, v28, v59 int32
	var k, l, tmplen, tmpx, x Tsize_t
	var loc Tlocale_t
	var map1, ploc, scd, tomap, v100, v101, v102, v103, v104, v54, v55, v57, v58, v60, v61, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99 uintptr
	var totype, type1 uint8
	var _ /* ptmp at bp+48 */ uintptr
	var _ /* st at bp+24 */ Tmbstate_t
	var _ /* tmp at bp+40 */ struct {
		Fwc [0][2]Twchar_t
		Fc  [8]uint8
	}
	var _ /* tmp at bp+56 */ [4]uint8
	var _ /* wc at bp+32 */ Twchar_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, d, err, from, i, i1, j, j1, k, l, loc, map1, ploc, scd, tmplen, tmpx, to, tomap, totype, type1, x, v100, v101, v102, v103, v104, v25, v26, v27, v28, v54, v55, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98, v99
	x = uint64(0)
	scd = uintptr(0)
	if !(uint64(cd)&Uint64FromInt32(1) != 0) {
		scd = cd
		cd = (*Tstateful_cd)(unsafe.Pointer(scd)).Fbase_cd
	}
	to = uint32(_extract_to(tls, cd))
	from = uint32(_extract_from(tls, cd))
	map1 = uintptr(unsafe.Pointer(&_charmaps)) + uintptr(from) + uintptr(1)
	tomap = uintptr(unsafe.Pointer(&_charmaps)) + uintptr(to) + uintptr(1)
	*(*Tmbstate_t)(unsafe.Pointer(bp + 24)) = Tmbstate_t{}
	type1 = *(*uint8)(unsafe.Pointer(map1 + uintptr(-Int32FromInt32(1))))
	totype = *(*uint8)(unsafe.Pointer(tomap + uintptr(-Int32FromInt32(1))))
	ploc = ___get_tp(tls) + 152
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if !(in != 0) || !(*(*uintptr)(unsafe.Pointer(in)) != 0) || !(*(*Tsize_t)(unsafe.Pointer(inb)) != 0) {
		return uint64(0)
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = uintptr(unsafe.Pointer(&X__c_dot_utf8_locale))
	for {
		if !(*(*Tsize_t)(unsafe.Pointer(inb)) != 0) {
			break
		}
		c = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)))))
		l = uint64(1)
		switch int32(type1) {
		case int32(UTF_8):
			goto _2
		case int32(US_ASCII):
			goto _3
		case int32(WCHAR_T):
			goto _4
		case int32(UTF_32LE):
			goto _5
		case int32(UTF_32BE):
			goto _6
		case int32(UTF_16LE):
			goto _7
		case int32(UTF_16BE):
			goto _8
		case int32(UCS2LE):
			goto _9
		case int32(UCS2BE):
			goto _10
		case int32(UTF_16):
			goto _11
		case int32(UCS2):
			goto _12
		case int32(UTF_32):
			goto _13
		case int32(SHIFT_JIS):
			goto _14
		case int32(EUC_JP):
			goto _15
		case int32(ISO2022_JP):
			goto _16
		case int32(GB2312):
			goto _17
		case int32(GBK):
			goto _18
		case int32(GB18030):
			goto _19
		case int32(BIG5):
			goto _20
		case int32(EUC_KR):
			goto _21
		default:
			goto _22
		}
		goto _23
	_2:
		;
		if c < uint32(128) {
			goto _23
		}
		l = Xmbrtowc(tls, bp+32, *(*uintptr)(unsafe.Pointer(in)), *(*Tsize_t)(unsafe.Pointer(inb)), bp+24)
		if l == uint64(-Int32FromInt32(1)) {
			goto ilseq
		}
		if l == uint64(-Int32FromInt32(2)) {
			goto starved
		}
		c = *(*Twchar_t)(unsafe.Pointer(bp + 32))
		goto _23
	_3:
		;
		if c >= uint32(128) {
			goto ilseq
		}
		goto _23
	_4:
		;
		l = uint64(4)
		if *(*Tsize_t)(unsafe.Pointer(inb)) < l {
			goto starved
		}
		c = *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in))))
		if !(0 != 0) {
			goto _24
		}
	_6:
		;
	_5:
		;
		l = uint64(4)
		if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(4) {
			goto starved
		}
		c = _get_32(tls, *(*uintptr)(unsafe.Pointer(in)), int32(type1))
	_24:
		;
		if c-uint32(0xd800) < uint32(0x800) || c >= uint32(0x110000) {
			goto ilseq
		}
		goto _23
	_10:
		;
	_9:
		;
	_8:
		;
	_7:
		;
		l = uint64(2)
		if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(2) {
			goto starved
		}
		c = _get_16(tls, *(*uintptr)(unsafe.Pointer(in)), int32(type1))
		if c-Uint32FromInt32(0xdc00) < uint32(0x400) {
			goto ilseq
		}
		if c-Uint32FromInt32(0xd800) < uint32(0x400) {
			if uint32(int32(type1)-int32(UCS2BE)) < uint32(2) {
				goto ilseq
			}
			l = uint64(4)
			if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(4) {
				goto starved
			}
			d = _get_16(tls, *(*uintptr)(unsafe.Pointer(in))+UintptrFromInt32(2), int32(type1))
			if d-Uint32FromInt32(0xdc00) >= uint32(0x400) {
				goto ilseq
			}
			c = (c-uint32(0xd7c0))<<int32(10) + (d - uint32(0xdc00))
		}
		goto _23
	_12:
		;
	_11:
		;
		l = uint64(0)
		if !((*Tstateful_cd)(unsafe.Pointer(scd)).Fstate != 0) {
			if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(2) {
				goto starved
			}
			c = _get_16(tls, *(*uintptr)(unsafe.Pointer(in)), 0)
			if int32(type1) == int32(UCS2) {
				if c == uint32(0xfffe) {
					v26 = int32(UCS2LE)
				} else {
					v26 = int32(UCS2BE)
				}
				v25 = v26
			} else {
				if c == uint32(0xfffe) {
					v27 = int32(UTF_16LE)
				} else {
					v27 = int32(UTF_16BE)
				}
				v25 = v27
			}
			(*Tstateful_cd)(unsafe.Pointer(scd)).Fstate = uint32(v25)
			if c == uint32(0xfffe) || c == uint32(0xfeff) {
				l = uint64(2)
			}
		}
		type1 = uint8((*Tstateful_cd)(unsafe.Pointer(scd)).Fstate)
		goto _1
	_13:
		;
		l = uint64(0)
		if !((*Tstateful_cd)(unsafe.Pointer(scd)).Fstate != 0) {
			if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(4) {
				goto starved
			}
			c = _get_32(tls, *(*uintptr)(unsafe.Pointer(in)), 0)
			if c == uint32(0xfffe0000) {
				v28 = int32(UTF_32LE)
			} else {
				v28 = int32(UTF_32BE)
			}
			(*Tstateful_cd)(unsafe.Pointer(scd)).Fstate = uint32(v28)
			if c == uint32(0xfffe0000) || c == uint32(0xfeff) {
				l = uint64(4)
			}
		}
		type1 = uint8((*Tstateful_cd)(unsafe.Pointer(scd)).Fstate)
		goto _1
	_14:
		;
		if c < uint32(128) {
			goto _23
		}
		if c-uint32(0xa1) <= uint32(Int32FromInt32(0xdf)-Int32FromInt32(0xa1)) {
			c += uint32(Int32FromInt32(0xff61) - Int32FromInt32(0xa1))
			goto _23
		}
		l = uint64(2)
		if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(2) {
			goto starved
		}
		d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(1))))
		if c-uint32(129) <= uint32(Int32FromInt32(159)-Int32FromInt32(129)) {
			c -= uint32(129)
		} else {
			if c-uint32(224) <= uint32(Int32FromInt32(239)-Int32FromInt32(224)) {
				c -= uint32(193)
			} else {
				goto ilseq
			}
		}
		c *= uint32(2)
		if d-uint32(64) <= uint32(Int32FromInt32(158)-Int32FromInt32(64)) {
			if d == uint32(127) {
				goto ilseq
			}
			if d > uint32(127) {
				d--
			}
			d -= uint32(64)
		} else {
			if d-uint32(159) <= uint32(Int32FromInt32(252)-Int32FromInt32(159)) {
				c++
				d -= uint32(159)
			}
		}
		if c >= uint32(84) {
			goto ilseq
		}
		c = uint32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_jis0208)) + uintptr(c)*188 + uintptr(d)*2)))
		if !(c != 0) {
			goto ilseq
		}
		goto _23
	_15:
		;
		if c < uint32(128) {
			goto _23
		}
		l = uint64(2)
		if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(2) {
			goto starved
		}
		d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(1))))
		if c == uint32(0x8e) {
			c = d
			if c-uint32(0xa1) > uint32(Int32FromInt32(0xdf)-Int32FromInt32(0xa1)) {
				goto ilseq
			}
			c += uint32(Int32FromInt32(0xff61) - Int32FromInt32(0xa1))
			goto _23
		}
		c -= uint32(0xa1)
		d -= uint32(0xa1)
		if c >= uint32(84) || d >= uint32(94) {
			goto ilseq
		}
		c = uint32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_jis0208)) + uintptr(c)*188 + uintptr(d)*2)))
		if !(c != 0) {
			goto ilseq
		}
		goto _23
	_16:
		;
		if c >= uint32(128) {
			goto ilseq
		}
		if c == uint32('\033') {
			l = uint64(3)
			if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(3) {
				goto starved
			}
			c = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(1))))
			d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(2))))
			if c != uint32('(') && c != uint32('$') {
				goto ilseq
			}
			switch uint32(Int32FromInt32(128)*BoolInt32(c == Uint32FromUint8('$'))) + d {
			case uint32('B'):
				(*Tstateful_cd)(unsafe.Pointer(scd)).Fstate = uint32(0)
				goto _1
			case uint32('J'):
				(*Tstateful_cd)(unsafe.Pointer(scd)).Fstate = uint32(1)
				goto _1
			case uint32('I'):
				(*Tstateful_cd)(unsafe.Pointer(scd)).Fstate = uint32(4)
				goto _1
			case uint32(Int32FromInt32(128) + Int32FromUint8('@')):
				(*Tstateful_cd)(unsafe.Pointer(scd)).Fstate = uint32(2)
				goto _1
			case uint32(Int32FromInt32(128) + Int32FromUint8('B')):
				(*Tstateful_cd)(unsafe.Pointer(scd)).Fstate = uint32(3)
				goto _1
			}
			goto ilseq
		}
		switch (*Tstateful_cd)(unsafe.Pointer(scd)).Fstate {
		case uint32(1):
			if c == uint32('\\') {
				c = uint32(0xa5)
			}
			if c == uint32('~') {
				c = uint32(0x203e)
			}
		case uint32(2):
			fallthrough
		case uint32(3):
			l = uint64(2)
			if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(2) {
				goto starved
			}
			d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(1))))
			c -= uint32(0x21)
			d -= uint32(0x21)
			if c >= uint32(84) || d >= uint32(94) {
				goto ilseq
			}
			c = uint32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_jis0208)) + uintptr(c)*188 + uintptr(d)*2)))
			if !(c != 0) {
				goto ilseq
			}
		case uint32(4):
			if c-uint32(0x60) < uint32(0x1f) {
				goto ilseq
			}
			if c-uint32(0x21) < uint32(0x5e) {
				c += uint32(Int32FromInt32(0xff61) - Int32FromInt32(0x21))
			}
			break
		}
		goto _23
	_17:
		;
		if c < uint32(128) {
			goto _23
		}
		if c < uint32(0xa1) {
			goto ilseq
		}
	_18:
		;
		if c == uint32(128) {
			c = uint32(0x20ac)
			goto _23
		}
	_19:
		;
		if c < uint32(128) {
			goto _23
		}
		c -= uint32(0x81)
		if c >= uint32(126) {
			goto ilseq
		}
		l = uint64(2)
		if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(2) {
			goto starved
		}
		d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(1))))
		if d < uint32(0xa1) && int32(type1) == int32(GB2312) {
			goto ilseq
		}
		if d-uint32(0x40) >= uint32(191) || d == uint32(127) {
			if d-uint32('0') > uint32(9) || int32(type1) != int32(GB18030) {
				goto ilseq
			}
			l = uint64(4)
			if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(4) {
				goto starved
			}
			c = (uint32(10)*c + d - uint32('0')) * uint32(1260)
			d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(2))))
			if d-uint32(0x81) > uint32(126) {
				goto ilseq
			}
			c += uint32(10) * (d - uint32(0x81))
			d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(3))))
			if d-uint32('0') > uint32(9) {
				goto ilseq
			}
			c += d - uint32('0')
			c += uint32(128)
			d = uint32(0)
			for {
				if !(d <= c) {
					break
				}
				k = uint64(0)
				i = 0
				for {
					if !(i < int32(126)) {
						break
					}
					j = 0
					for {
						if !(j < int32(190)) {
							break
						}
						if uint32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_gb18030)) + uintptr(i)*380 + uintptr(j)*2)))-d <= c-d {
							k++
						}
						goto _31
					_31:
						;
						j++
					}
					goto _30
				_30:
					;
					i++
				}
				d = c + uint32(1)
				c = uint32(uint64(c) + k)
				goto _29
			_29:
			}
			goto _23
		}
		d -= uint32(0x40)
		if d > uint32(63) {
			d--
		}
		c = uint32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_gb18030)) + uintptr(c)*380 + uintptr(d)*2)))
		goto _23
	_20:
		;
		if c < uint32(128) {
			goto _23
		}
		l = uint64(2)
		if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(2) {
			goto starved
		}
		d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(1))))
		if d-uint32(0x40) >= uint32(Int32FromInt32(0xff)-Int32FromInt32(0x40)) || d-uint32(0x7f) < uint32(Int32FromInt32(0xa1)-Int32FromInt32(0x7f)) {
			goto ilseq
		}
		d -= uint32(0x40)
		if d > uint32(0x3e) {
			d -= uint32(0x22)
		}
		if c-uint32(0xa1) >= uint32(Int32FromInt32(0xfa)-Int32FromInt32(0xa1)) {
			if c-uint32(0x87) >= uint32(Int32FromInt32(0xff)-Int32FromInt32(0x87)) {
				goto ilseq
			}
			if c < uint32(0xa1) {
				c -= uint32(0x87)
			} else {
				c -= uint32(Int32FromInt32(0x87) + (Int32FromInt32(0xfa) - Int32FromInt32(0xa1)))
			}
			c = uint32(int32(_hkscs[uint32(4867)+(c*uint32(157)+d)/uint32(16)])>>((c*uint32(157)+d)%uint32(16))%int32(2)<<int32(17) | int32(_hkscs[c*uint32(157)+d]))
			/* A few HKSCS characters map to pairs of UCS
			 * characters. These are mapped to surrogate
			 * range in the hkscs table then hard-coded
			 * here. Ugly, yes. */
			if c/uint32(256) == uint32(0xdc) {
				*(*uintptr)(unsafe.Pointer(bp + 48)) = bp + 40
				*(*uintptr)(unsafe.Pointer(bp)) = __ccgo_ts + 494 + uintptr(c%uint32(256))
				*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(4)
				*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(8)
				tmpx = Xiconv(tls, _combine_to_from(tls, uint64(to), _find_charmap(tls, __ccgo_ts+511)), bp, bp+8, bp+48, bp+16)
				tmplen = uint64(int64(*(*uintptr)(unsafe.Pointer(bp + 48))) - t__predefined_ptrdiff_t(bp+40))
				if tmplen > *(*Tsize_t)(unsafe.Pointer(outb)) {
					goto toobig
				}
				if tmpx != 0 {
					x++
				}
				Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(out)), bp+40, tmplen)
				*(*uintptr)(unsafe.Pointer(out)) += uintptr(tmplen)
				*(*Tsize_t)(unsafe.Pointer(outb)) -= tmplen
				goto _1
			}
			if !(c != 0) {
				goto ilseq
			}
			goto _23
		}
		c -= uint32(0xa1)
		c = uint32(int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_big5)) + uintptr(c)*314 + uintptr(d)*2))) | BoolInt32(c == uint32(0x27) && (d == uint32(0x3a) || d == uint32(0x3c) || d == uint32(0x42)))<<int32(17))
		if !(c != 0) {
			goto ilseq
		}
		goto _23
	_21:
		;
		if c < uint32(128) {
			goto _23
		}
		l = uint64(2)
		if *(*Tsize_t)(unsafe.Pointer(inb)) < uint64(2) {
			goto starved
		}
		d = uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(in)) + UintptrFromInt32(1))))
		c -= uint32(0xa1)
		d -= uint32(0xa1)
		if c >= uint32(93) || d >= uint32(94) {
			c += uint32(Int32FromInt32(0xa1) - Int32FromInt32(0x81))
			d += uint32(0xa1)
			if c >= uint32(93) || c >= uint32(Int32FromInt32(0xc6)-Int32FromInt32(0x81)) && d > uint32(0x52) {
				goto ilseq
			}
			if d-uint32('A') < uint32(26) {
				d = d - uint32('A')
			} else {
				if d-uint32('a') < uint32(26) {
					d = d - uint32('a') + uint32(26)
				} else {
					if d-uint32(0x81) < uint32(Int32FromInt32(0xff)-Int32FromInt32(0x81)) {
						d = d - uint32(0x81) + uint32(52)
					} else {
						goto ilseq
					}
				}
			}
			if c < uint32(0x20) {
				c = uint32(178)*c + d
			} else {
				c = uint32(Int32FromInt32(178)*Int32FromInt32(0x20)) + uint32(84)*(c-uint32(0x20)) + d
			}
			c += uint32(0xac00)
			d = uint32(0xac00)
			for {
				if !(d <= c) {
					break
				}
				k = uint64(0)
				i1 = 0
				for {
					if !(i1 < int32(93)) {
						break
					}
					j1 = 0
					for {
						if !(j1 < int32(94)) {
							break
						}
						if uint32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ksc)) + uintptr(i1)*188 + uintptr(j1)*2)))-d <= c-d {
							k++
						}
						goto _34
					_34:
						;
						j1++
					}
					goto _33
				_33:
					;
					i1++
				}
				d = c + uint32(1)
				c = uint32(uint64(c) + k)
				goto _32
			_32:
			}
			goto _23
		}
		c = uint32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(&_ksc)) + uintptr(c)*188 + uintptr(d)*2)))
		if !(c != 0) {
			goto ilseq
		}
		goto _23
	_22:
		;
		if !(c != 0) {
			goto _23
		}
		c = _legacy_map(tls, map1, c)
		if !(c != 0) {
			goto ilseq
		}
	_23:
		;
		switch int32(totype) {
		case int32(WCHAR_T):
			goto _35
		case int32(UTF_8):
			goto _36
		case int32(US_ASCII):
			goto _37
		default:
			goto _38
		case int32(SHIFT_JIS):
			goto _39
		case int32(EUC_JP):
			goto _40
		case int32(ISO2022_JP):
			goto _41
		case int32(UCS2):
			goto _42
		case int32(UTF_16LE):
			goto _43
		case int32(UTF_16BE):
			goto _44
		case int32(UTF_16):
			goto _45
		case int32(UCS2LE):
			goto _46
		case int32(UCS2BE):
			goto _47
		case int32(UTF_32):
			goto _48
		case int32(UTF_32LE):
			goto _49
		case int32(UTF_32BE):
			goto _50
		}
		goto _51
	_35:
		;
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(4) {
			goto toobig
		}
		*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(out)))) = c
		*(*uintptr)(unsafe.Pointer(out)) += uintptr(4)
		*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(4)
		goto _51
	_36:
		;
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(4) {
			k = uint64(Xwctomb(tls, bp+56, c))
			if *(*Tsize_t)(unsafe.Pointer(outb)) < k {
				goto toobig
			}
			Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(out)), bp+56, k)
		} else {
			k = uint64(Xwctomb(tls, *(*uintptr)(unsafe.Pointer(out)), c))
		}
		*(*uintptr)(unsafe.Pointer(out)) += uintptr(k)
		*(*Tsize_t)(unsafe.Pointer(outb)) -= k
		goto _51
	_37:
		;
		if !(c > uint32(0x7f)) {
			goto _52
		}
		goto subst
	subst:
		;
		x++
		c = Uint32FromUint8('*')
	_52:
		;
	_38:
		;
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(1) {
			goto toobig
		}
		if !(c < uint32(256) && c == _legacy_map(tls, tomap, c)) {
			goto _53
		}
		goto revout
	revout:
		;
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(1) {
			goto toobig
		}
		v55 = out
		v54 = *(*uintptr)(unsafe.Pointer(v55))
		*(*uintptr)(unsafe.Pointer(v55))++
		*(*uint8)(unsafe.Pointer(v54)) = uint8(c)
		*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(1)
		goto _51
	_53:
		;
		d = c
		c = uint32(int32(4) * int32(totype))
		for {
			if !(c < uint32(256)) {
				break
			}
			if d == _legacy_map(tls, tomap, c) {
				goto revout
			}
			goto _56
		_56:
			;
			c++
		}
		goto subst
	_39:
		;
		if c < uint32(128) {
			goto revout
		}
		if c == uint32(0xa5) {
			x++
			c = uint32('\\')
			goto revout
		}
		if c == uint32(0x203e) {
			x++
			c = uint32('~')
			goto revout
		}
		if c-uint32(0xff61) <= uint32(Int32FromInt32(0xdf)-Int32FromInt32(0xa1)) {
			c += uint32(Int32FromInt32(0xa1) - Int32FromInt32(0xff61))
			goto revout
		}
		c = _uni_to_jis(tls, c)
		if !(c != 0) {
			goto subst
		}
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(2) {
			goto toobig
		}
		d = c % uint32(256)
		c = c / uint32(256)
		v58 = out
		v57 = *(*uintptr)(unsafe.Pointer(v58))
		*(*uintptr)(unsafe.Pointer(v58))++
		if c < uint32(95) {
			v59 = int32(112)
		} else {
			v59 = int32(176)
		}
		*(*uint8)(unsafe.Pointer(v57)) = uint8((c+uint32(1))/uint32(2) + uint32(v59))
		v61 = out
		v60 = *(*uintptr)(unsafe.Pointer(v61))
		*(*uintptr)(unsafe.Pointer(v61))++
		if c%uint32(2) != 0 {
			v62 = d + uint32(31) + d/uint32(96)
		} else {
			v62 = d + uint32(126)
		}
		*(*uint8)(unsafe.Pointer(v60)) = uint8(v62)
		*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(2)
		goto _51
	_40:
		;
		if c < uint32(128) {
			goto revout
		}
		if c-uint32(0xff61) <= uint32(Int32FromInt32(0xdf)-Int32FromInt32(0xa1)) {
			c += uint32(Int32FromInt32(0x0e00) + Int32FromInt32(0x21) - Int32FromInt32(0xff61))
		} else {
			c = _uni_to_jis(tls, c)
		}
		if !(c != 0) {
			goto subst
		}
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(2) {
			goto toobig
		}
		v64 = out
		v63 = *(*uintptr)(unsafe.Pointer(v64))
		*(*uintptr)(unsafe.Pointer(v64))++
		*(*uint8)(unsafe.Pointer(v63)) = uint8(c/uint32(256) + uint32(0x80))
		v66 = out
		v65 = *(*uintptr)(unsafe.Pointer(v66))
		*(*uintptr)(unsafe.Pointer(v66))++
		*(*uint8)(unsafe.Pointer(v65)) = uint8(c%uint32(256) + uint32(0x80))
		*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(2)
		goto _51
	_41:
		;
		if c < uint32(128) {
			goto revout
		}
		if c-uint32(0xff61) <= uint32(Int32FromInt32(0xdf)-Int32FromInt32(0xa1)) || c == uint32(0xa5) || c == uint32(0x203e) {
			if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(7) {
				goto toobig
			}
			v68 = out
			v67 = *(*uintptr)(unsafe.Pointer(v68))
			*(*uintptr)(unsafe.Pointer(v68))++
			*(*uint8)(unsafe.Pointer(v67)) = uint8('\033')
			v70 = out
			v69 = *(*uintptr)(unsafe.Pointer(v70))
			*(*uintptr)(unsafe.Pointer(v70))++
			*(*uint8)(unsafe.Pointer(v69)) = uint8('(')
			if c == uint32(0xa5) {
				v72 = out
				v71 = *(*uintptr)(unsafe.Pointer(v72))
				*(*uintptr)(unsafe.Pointer(v72))++
				*(*uint8)(unsafe.Pointer(v71)) = uint8('J')
				v74 = out
				v73 = *(*uintptr)(unsafe.Pointer(v74))
				*(*uintptr)(unsafe.Pointer(v74))++
				*(*uint8)(unsafe.Pointer(v73)) = uint8('\\')
			} else {
				if c == uint32(0x203e) {
					v76 = out
					v75 = *(*uintptr)(unsafe.Pointer(v76))
					*(*uintptr)(unsafe.Pointer(v76))++
					*(*uint8)(unsafe.Pointer(v75)) = uint8('J')
					v78 = out
					v77 = *(*uintptr)(unsafe.Pointer(v78))
					*(*uintptr)(unsafe.Pointer(v78))++
					*(*uint8)(unsafe.Pointer(v77)) = uint8('~')
				} else {
					v80 = out
					v79 = *(*uintptr)(unsafe.Pointer(v80))
					*(*uintptr)(unsafe.Pointer(v80))++
					*(*uint8)(unsafe.Pointer(v79)) = uint8('I')
					v82 = out
					v81 = *(*uintptr)(unsafe.Pointer(v82))
					*(*uintptr)(unsafe.Pointer(v82))++
					*(*uint8)(unsafe.Pointer(v81)) = uint8(c - uint32(0xff61) + uint32(0x21))
				}
			}
			v84 = out
			v83 = *(*uintptr)(unsafe.Pointer(v84))
			*(*uintptr)(unsafe.Pointer(v84))++
			*(*uint8)(unsafe.Pointer(v83)) = uint8('\033')
			v86 = out
			v85 = *(*uintptr)(unsafe.Pointer(v86))
			*(*uintptr)(unsafe.Pointer(v86))++
			*(*uint8)(unsafe.Pointer(v85)) = uint8('(')
			v88 = out
			v87 = *(*uintptr)(unsafe.Pointer(v88))
			*(*uintptr)(unsafe.Pointer(v88))++
			*(*uint8)(unsafe.Pointer(v87)) = uint8('B')
			*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(7)
			goto _51
		}
		c = _uni_to_jis(tls, c)
		if !(c != 0) {
			goto subst
		}
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(8) {
			goto toobig
		}
		v90 = out
		v89 = *(*uintptr)(unsafe.Pointer(v90))
		*(*uintptr)(unsafe.Pointer(v90))++
		*(*uint8)(unsafe.Pointer(v89)) = uint8('\033')
		v92 = out
		v91 = *(*uintptr)(unsafe.Pointer(v92))
		*(*uintptr)(unsafe.Pointer(v92))++
		*(*uint8)(unsafe.Pointer(v91)) = uint8('$')
		v94 = out
		v93 = *(*uintptr)(unsafe.Pointer(v94))
		*(*uintptr)(unsafe.Pointer(v94))++
		*(*uint8)(unsafe.Pointer(v93)) = uint8('B')
		v96 = out
		v95 = *(*uintptr)(unsafe.Pointer(v96))
		*(*uintptr)(unsafe.Pointer(v96))++
		*(*uint8)(unsafe.Pointer(v95)) = uint8(c / uint32(256))
		v98 = out
		v97 = *(*uintptr)(unsafe.Pointer(v98))
		*(*uintptr)(unsafe.Pointer(v98))++
		*(*uint8)(unsafe.Pointer(v97)) = uint8(c % uint32(256))
		v100 = out
		v99 = *(*uintptr)(unsafe.Pointer(v100))
		*(*uintptr)(unsafe.Pointer(v100))++
		*(*uint8)(unsafe.Pointer(v99)) = uint8('\033')
		v102 = out
		v101 = *(*uintptr)(unsafe.Pointer(v102))
		*(*uintptr)(unsafe.Pointer(v102))++
		*(*uint8)(unsafe.Pointer(v101)) = uint8('(')
		v104 = out
		v103 = *(*uintptr)(unsafe.Pointer(v104))
		*(*uintptr)(unsafe.Pointer(v104))++
		*(*uint8)(unsafe.Pointer(v103)) = uint8('B')
		*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(8)
		goto _51
	_42:
		;
		totype = uint8(UCS2BE)
	_47:
		;
	_46:
		;
	_45:
		;
	_44:
		;
	_43:
		;
		if c < uint32(0x10000) || uint32(int32(totype)-int32(UCS2BE)) < uint32(2) {
			if c >= uint32(0x10000) {
				c = uint32(0xFFFD)
			}
			if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(2) {
				goto toobig
			}
			_put_16(tls, *(*uintptr)(unsafe.Pointer(out)), c, int32(totype))
			*(*uintptr)(unsafe.Pointer(out)) += uintptr(2)
			*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(2)
			goto _51
		}
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(4) {
			goto toobig
		}
		c -= uint32(0x10000)
		_put_16(tls, *(*uintptr)(unsafe.Pointer(out)), c>>int32(10)|uint32(0xd800), int32(totype))
		_put_16(tls, *(*uintptr)(unsafe.Pointer(out))+UintptrFromInt32(2), c&uint32(0x3ff)|uint32(0xdc00), int32(totype))
		*(*uintptr)(unsafe.Pointer(out)) += uintptr(4)
		*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(4)
		goto _51
	_48:
		;
		totype = uint8(UTF_32BE)
	_50:
		;
	_49:
		;
		if *(*Tsize_t)(unsafe.Pointer(outb)) < uint64(4) {
			goto toobig
		}
		_put_32(tls, *(*uintptr)(unsafe.Pointer(out)), c, int32(totype))
		*(*uintptr)(unsafe.Pointer(out)) += uintptr(4)
		*(*Tsize_t)(unsafe.Pointer(outb)) -= uint64(4)
		goto _51
	_51:
		;
		goto _1
	_1:
		;
		*(*uintptr)(unsafe.Pointer(in)) += uintptr(l)
		*(*Tsize_t)(unsafe.Pointer(inb)) -= l
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return x
	goto ilseq
ilseq:
	;
	err = int32(EILSEQ)
	x = uint64(-Int32FromInt32(1))
	goto end
	goto toobig
toobig:
	;
	err = int32(E2BIG)
	x = uint64(-Int32FromInt32(1))
	goto end
	goto starved
starved:
	;
	err = int32(EINVAL)
	x = uint64(-Int32FromInt32(1))
	goto end
end:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = err
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return x
}

func Xiconv_close(tls *TLS, cd Ticonv_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v cd=%v, (%v:)", tls, cd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if !(uint64(cd)&Uint64FromInt32(1) != 0) {
		Xfree(tls, cd)
	}
	return 0
}

var _c_time = [316]uint8{'S', 'u', 'n', 0, 'M', 'o', 'n', 0, 'T', 'u', 'e', 0, 'W', 'e', 'd', 0, 'T', 'h', 'u', 0, 'F', 'r', 'i', 0, 'S', 'a', 't', 0, 'S', 'u', 'n', 'd', 'a', 'y', 0, 'M', 'o', 'n', 'd', 'a', 'y', 0, 'T', 'u', 'e', 's', 'd', 'a', 'y', 0, 'W', 'e', 'd', 'n', 'e', 's', 'd', 'a', 'y', 0, 'T', 'h', 'u', 'r', 's', 'd', 'a', 'y', 0, 'F', 'r', 'i', 'd', 'a', 'y', 0, 'S', 'a', 't', 'u', 'r', 'd', 'a', 'y', 0, 'J', 'a', 'n', 0, 'F', 'e', 'b', 0, 'M', 'a', 'r', 0, 'A', 'p', 'r', 0, 'M', 'a', 'y', 0, 'J', 'u', 'n', 0, 'J', 'u', 'l', 0, 'A', 'u', 'g', 0, 'S', 'e', 'p', 0, 'O', 'c', 't', 0, 'N', 'o', 'v', 0, 'D', 'e', 'c', 0, 'J', 'a', 'n', 'u', 'a', 'r', 'y', 0, 'F', 'e', 'b', 'r', 'u', 'a', 'r', 'y', 0, 'M', 'a', 'r', 'c', 'h', 0, 'A', 'p', 'r', 'i', 'l', 0, 'M', 'a', 'y', 0, 'J', 'u', 'n', 'e', 0, 'J', 'u', 'l', 'y', 0, 'A', 'u', 'g', 'u', 's', 't', 0, 'S', 'e', 'p', 't', 'e', 'm', 'b', 'e', 'r', 0, 'O', 'c', 't', 'o', 'b', 'e', 'r', 0, 'N', 'o', 'v', 'e', 'm', 'b', 'e', 'r', 0, 'D', 'e', 'c', 'e', 'm', 'b', 'e', 'r', 0, 'A', 'M', 0, 'P', 'M', 0, '%', 'a', ' ', '%', 'b', ' ', '%', 'e', ' ', '%', 'T', ' ', '%', 'Y', 0, '%', 'm', '/', '%', 'd', '/', '%', 'y', 0, '%', 'H', ':', '%', 'M', ':', '%', 'S', 0, '%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p', 0, 0, 0, '%', 'm', '/', '%', 'd', '/', '%', 'y', 0, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, '%', 'a', ' ', '%', 'b', ' ', '%', 'e', ' ', '%', 'T', ' ', '%', 'Y', 0, '%', 'H', ':', '%', 'M', ':', '%', 'S'}

var _c_messages = [19]uint8{'^', '[', 'y', 'Y', ']', 0, '^', '[', 'n', 'N', ']', 0, 'y', 'e', 's', 0, 'n', 'o'}
var _c_numeric = [3]uint8{'.'}

func X__nl_langinfo_l(tls *TLS, item Tnl_item, loc Tlocale_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v item=%v loc=%v, (%v:)", tls, item, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var cat, idx int32
	var str, v1, v2 uintptr
	_, _, _, _, _ = cat, idx, str, v1, v2
	cat = item >> int32(16)
	idx = item & int32(65535)
	if item == int32(CODESET) {
		if *(*uintptr)(unsafe.Pointer(loc)) != 0 {
			v1 = __ccgo_ts + 322
		} else {
			v1 = __ccgo_ts + 516
		}
		return v1
	}
	/* _NL_LOCALE_NAME extension */
	if idx == int32(65535) && cat < int32(LC_ALL) {
		if *(*uintptr)(unsafe.Pointer(loc + uintptr(cat)*8)) != 0 {
			v2 = *(*uintptr)(unsafe.Pointer(loc + uintptr(cat)*8)) + 16
		} else {
			v2 = __ccgo_ts + 522
		}
		return v2
	}
	switch cat {
	case int32(LC_NUMERIC):
		if idx > int32(1) {
			return __ccgo_ts
		}
		str = uintptr(unsafe.Pointer(&_c_numeric))
	case int32(LC_TIME):
		if idx > int32(0x31) {
			return __ccgo_ts
		}
		str = uintptr(unsafe.Pointer(&_c_time))
	case int32(LC_MONETARY):
		if idx > 0 {
			return __ccgo_ts
		}
		str = __ccgo_ts
	case int32(LC_MESSAGES):
		if idx > int32(3) {
			return __ccgo_ts
		}
		str = uintptr(unsafe.Pointer(&_c_messages))
	default:
		return __ccgo_ts
	}
	for {
		if !(idx != 0) {
			break
		}
		for {
			if !(*(*uint8)(unsafe.Pointer(str)) != 0) {
				break
			}
			goto _4
		_4:
			;
			str++
		}
		goto _3
	_3:
		;
		idx--
		str++
	}
	if cat != int32(LC_NUMERIC) && *(*uint8)(unsafe.Pointer(str)) != 0 {
		str = X__lctrans(tls, str, *(*uintptr)(unsafe.Pointer(loc + uintptr(cat)*8)))
	}
	return str
}

func X__nl_langinfo(tls *TLS, item Tnl_item) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v item=%v, (%v:)", tls, item, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__nl_langinfo_l(tls, item, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func Xnl_langinfo(tls *TLS, item Tnl_item) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v item=%v, (%v:)", tls, item, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__nl_langinfo(tls, item)
}

func Xnl_langinfo_l(tls *TLS, item Tnl_item, loc Tlocale_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v item=%v loc=%v, (%v:)", tls, item, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__nl_langinfo_l(tls, item, loc)
}

func X__lctrans_impl(tls *TLS, msg uintptr, lm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v msg=%v lm=%v, (%v:)", tls, msg, lm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var trans, v1 uintptr
	_, _ = trans, v1
	trans = uintptr(0)
	if lm != 0 {
		trans = X__mo_lookup(tls, (*t__locale_map)(unsafe.Pointer(lm)).Fmap1, (*t__locale_map)(unsafe.Pointer(lm)).Fmap_size, msg)
	}
	if trans != 0 {
		v1 = trans
	} else {
		v1 = msg
	}
	return v1
}

var _envvars = [6][12]uint8{
	0: {'L', 'C', '_', 'C', 'T', 'Y', 'P', 'E'},
	1: {'L', 'C', '_', 'N', 'U', 'M', 'E', 'R', 'I', 'C'},
	2: {'L', 'C', '_', 'T', 'I', 'M', 'E'},
	3: {'L', 'C', '_', 'C', 'O', 'L', 'L', 'A', 'T', 'E'},
	4: {'L', 'C', '_', 'M', 'O', 'N', 'E', 'T', 'A', 'R', 'Y'},
	5: {'L', 'C', '_', 'M', 'E', 'S', 'S', 'A', 'G', 'E', 'S'},
}

func X__get_locale(tls *TLS, cat int32, val uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v cat=%v val=%v, (%v:)", tls, cat, val, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(272)
	defer tls.Free(272)
	var builtin int32
	var l, n Tsize_t
	var map1, new1, p, path, z, v1, v11, v2, v4, v6 uintptr
	var v12, v3, v5, v7 bool
	var _ /* buf at bp+0 */ [256]uint8
	var _ /* map_size at bp+256 */ Tsize_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = builtin, l, map1, n, new1, p, path, z, v1, v11, v12, v2, v3, v4, v5, v6, v7
	new1 = uintptr(0)
	path = uintptr(0)
	if !(*(*uint8)(unsafe.Pointer(val)) != 0) {
		v1 = Xgetenv(tls, __ccgo_ts+524)
		val = v1
		if v3 = v1 != 0 && *(*uint8)(unsafe.Pointer(val)) != 0; !v3 {
			v2 = Xgetenv(tls, uintptr(unsafe.Pointer(&_envvars))+uintptr(cat)*12)
			val = v2
		}
		if v5 = v3 || v2 != 0 && *(*uint8)(unsafe.Pointer(val)) != 0; !v5 {
			v4 = Xgetenv(tls, __ccgo_ts+336)
			val = v4
		}
		if v7 = v5 || v4 != 0 && *(*uint8)(unsafe.Pointer(val)) != 0; !v7 {
			v6 = __ccgo_ts + 531
			val = v6
		}
		_ = v7 || v6 != 0
	}
	/* Limit name length and forbid leading dot or any slashes. */
	n = uint64(0)
	for {
		if !(n < uint64(LOCALE_NAME_MAX) && *(*uint8)(unsafe.Pointer(val + uintptr(n))) != 0 && int32(*(*uint8)(unsafe.Pointer(val + uintptr(n)))) != int32('/')) {
			break
		}
		goto _8
	_8:
		;
		n++
	}
	if int32(*(*uint8)(unsafe.Pointer(val))) == int32('.') || *(*uint8)(unsafe.Pointer(val + uintptr(n))) != 0 {
		val = __ccgo_ts + 531
	}
	builtin = BoolInt32(int32(*(*uint8)(unsafe.Pointer(val))) == int32('C') && !(*(*uint8)(unsafe.Pointer(val + 1)) != 0) || !(Xstrcmp(tls, val, __ccgo_ts+531) != 0) || !(Xstrcmp(tls, val, __ccgo_ts+539) != 0))
	if builtin != 0 {
		if cat == LC_CTYPE && int32(*(*uint8)(unsafe.Pointer(val + 1))) == int32('.') {
			return uintptr(unsafe.Pointer(&X__c_dot_utf8))
		}
		return uintptr(0)
	}
	p = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_loc_head)))
	for {
		if !(p != 0) {
			break
		}
		if !(Xstrcmp(tls, val, p+16) != 0) {
			return p
		}
		goto _9
	_9:
		;
		p = (*t__locale_map)(unsafe.Pointer(p)).Fnext
	}
	if !(X__libc.Fsecure != 0) {
		path = Xgetenv(tls, __ccgo_ts+545)
	}
	/* FIXME: add a default path? */
	if path != 0 {
		for {
			if !(*(*uint8)(unsafe.Pointer(path)) != 0) {
				break
			}
			z = X__strchrnul(tls, path, int32(':'))
			l = uint64(int64(z) - int64(path))
			if l >= uint64(256)-n-uint64(2) {
				goto _10
			}
			Xmemcpy(tls, bp, path, l)
			(*(*[256]uint8)(unsafe.Pointer(bp)))[l] = uint8('/')
			Xmemcpy(tls, bp+uintptr(l)+uintptr(1), val, n)
			(*(*[256]uint8)(unsafe.Pointer(bp)))[l+uint64(1)+n] = uint8(0)
			map1 = X__map_file(tls, bp, bp+256)
			if map1 != 0 {
				new1 = Xmalloc(tls, uint64(48))
				if !(new1 != 0) {
					X__munmap(tls, map1, *(*Tsize_t)(unsafe.Pointer(bp + 256)))
					break
				}
				(*t__locale_map)(unsafe.Pointer(new1)).Fmap1 = map1
				(*t__locale_map)(unsafe.Pointer(new1)).Fmap_size = *(*Tsize_t)(unsafe.Pointer(bp + 256))
				Xmemcpy(tls, new1+16, val, n)
				*(*uint8)(unsafe.Pointer(new1 + 16 + uintptr(n))) = uint8(0)
				(*t__locale_map)(unsafe.Pointer(new1)).Fnext = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_loc_head)))
				AtomicStorePUintptr(uintptr(unsafe.Pointer(&_loc_head)), new1)
				break
			}
			goto _10
		_10:
			;
			path = z + BoolUintptr(!!(*(*uint8)(unsafe.Pointer(z)) != 0))
		}
	}
	/* If no locale definition was found, make a locale map
	 * object anyway to store the name, which is kept for the
	 * sake of being able to do message translations at the
	 * application level. */
	if v12 = !(new1 != 0); v12 {
		v11 = Xmalloc(tls, uint64(48))
		new1 = v11
	}
	if v12 && v11 != 0 {
		(*t__locale_map)(unsafe.Pointer(new1)).Fmap1 = X__c_dot_utf8.Fmap1
		(*t__locale_map)(unsafe.Pointer(new1)).Fmap_size = X__c_dot_utf8.Fmap_size
		Xmemcpy(tls, new1+16, val, n)
		*(*uint8)(unsafe.Pointer(new1 + 16 + uintptr(n))) = uint8(0)
		(*t__locale_map)(unsafe.Pointer(new1)).Fnext = AtomicLoadPUintptr(uintptr(unsafe.Pointer(&_loc_head)))
		AtomicStorePUintptr(uintptr(unsafe.Pointer(&_loc_head)), new1)
	}
	/* For LC_CTYPE, never return a null pointer unless the
	 * requested name was "C" or "POSIX". */
	if !(new1 != 0) && cat == LC_CTYPE {
		new1 = uintptr(unsafe.Pointer(&X__c_dot_utf8))
	}
	return new1
}

var _loc_head uintptr

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

var _posix_lconv = Tlconv{
	Fdecimal_point:      __ccgo_ts + 558,
	Fthousands_sep:      __ccgo_ts,
	Fgrouping:           __ccgo_ts,
	Fint_curr_symbol:    __ccgo_ts,
	Fcurrency_symbol:    __ccgo_ts,
	Fmon_decimal_point:  __ccgo_ts,
	Fmon_thousands_sep:  __ccgo_ts,
	Fmon_grouping:       __ccgo_ts,
	Fpositive_sign:      __ccgo_ts,
	Fnegative_sign:      __ccgo_ts,
	Fint_frac_digits:    uint8(CHAR_MAX),
	Ffrac_digits:        uint8(CHAR_MAX),
	Fp_cs_precedes:      uint8(CHAR_MAX),
	Fp_sep_by_space:     uint8(CHAR_MAX),
	Fn_cs_precedes:      uint8(CHAR_MAX),
	Fn_sep_by_space:     uint8(CHAR_MAX),
	Fp_sign_posn:        uint8(CHAR_MAX),
	Fn_sign_posn:        uint8(CHAR_MAX),
	Fint_p_cs_precedes:  uint8(CHAR_MAX),
	Fint_p_sep_by_space: uint8(CHAR_MAX),
	Fint_n_cs_precedes:  uint8(CHAR_MAX),
	Fint_n_sep_by_space: uint8(CHAR_MAX),
	Fint_p_sign_posn:    uint8(CHAR_MAX),
	Fint_n_sign_posn:    uint8(CHAR_MAX),
}

func Xlocaleconv(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(unsafe.Pointer(&_posix_lconv))
}

var _default_locale_init_done int32
var _default_locale t__locale_struct
var _default_ctype_locale t__locale_struct

func X__loc_is_allocated(tls *TLS, loc Tlocale_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v loc=%v, (%v:)", tls, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(loc != 0 && loc != uintptr(unsafe.Pointer(&X__c_locale)) && loc != uintptr(unsafe.Pointer(&X__c_dot_utf8_locale)) && loc != uintptr(unsafe.Pointer(&_default_locale)) && loc != uintptr(unsafe.Pointer(&_default_ctype_locale)))
}

func _do_newlocale(tls *TLS, mask int32, name uintptr, loc Tlocale_t) (r Tlocale_t) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var i, i1 int32
	var v2, v3 uintptr
	var v5 Tlocale_t
	var _ /* tmp at bp+0 */ t__locale_struct
	_, _, _, _, _ = i, i1, v2, v3, v5
	i = 0
	for {
		if !(i < int32(LC_ALL)) {
			break
		}
		if !(mask&(Int32FromInt32(1)<<i) != 0) && loc != 0 {
			v2 = *(*uintptr)(unsafe.Pointer(loc + uintptr(i)*8))
		} else {
			if mask&(int32(1)<<i) != 0 {
				v3 = name
			} else {
				v3 = __ccgo_ts
			}
			v2 = X__get_locale(tls, i, v3)
		}
		*(*uintptr)(unsafe.Pointer(bp + uintptr(i)*8)) = v2
		if *(*uintptr)(unsafe.Pointer(bp + uintptr(i)*8)) == uintptr(-Int32FromInt32(1)) {
			return uintptr(0)
		}
		goto _1
	_1:
		;
		i++
	}
	/* For locales with allocated storage, modify in-place. */
	if X__loc_is_allocated(tls, loc) != 0 {
		*(*t__locale_struct)(unsafe.Pointer(loc)) = *(*t__locale_struct)(unsafe.Pointer(bp))
		return loc
	}
	/* Otherwise, first see if we can use one of the builtin locales.
	 * This makes the common usage case for newlocale, getting a C locale
	 * with predictable behavior, very fast, and more importantly, fail-safe. */
	if !(Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&X__c_locale)), uint64(48)) != 0) {
		return uintptr(unsafe.Pointer(&X__c_locale))
	}
	if !(Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&X__c_dot_utf8_locale)), uint64(48)) != 0) {
		return uintptr(unsafe.Pointer(&X__c_dot_utf8_locale))
	}
	/* And provide builtins for the initial default locale, and a
	 * variant of the C locale honoring the default locale's encoding. */
	if !(_default_locale_init_done != 0) {
		i1 = 0
		for {
			if !(i1 < int32(LC_ALL)) {
				break
			}
			*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_locale)) + uintptr(i1)*8)) = X__get_locale(tls, i1, __ccgo_ts)
			goto _4
		_4:
			;
			i1++
		}
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_ctype_locale)))) = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&_default_locale))))
		_default_locale_init_done = int32(1)
	}
	if !(Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&_default_locale)), uint64(48)) != 0) {
		return uintptr(unsafe.Pointer(&_default_locale))
	}
	if !(Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&_default_ctype_locale)), uint64(48)) != 0) {
		return uintptr(unsafe.Pointer(&_default_ctype_locale))
	}
	/* If no builtin locale matched, attempt to allocate and copy. */
	v5 = Xmalloc(tls, uint64(48))
	loc = v5
	if v5 != 0 {
		*(*t__locale_struct)(unsafe.Pointer(loc)) = *(*t__locale_struct)(unsafe.Pointer(bp))
	}
	return loc
}

func X__newlocale(tls *TLS, mask int32, name uintptr, loc Tlocale_t) (r Tlocale_t) {
	if __ccgo_strace {
		trc("tls=%v mask=%v name=%v loc=%v, (%v:)", tls, mask, name, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	___lock(tls, uintptr(unsafe.Pointer(&X__locale_lock)))
	loc = _do_newlocale(tls, mask, name, loc)
	___unlock(tls, uintptr(unsafe.Pointer(&X__locale_lock)))
	return loc
}

func Xnewlocale(tls *TLS, mask int32, name uintptr, loc Tlocale_t) (r Tlocale_t) {
	if __ccgo_strace {
		trc("tls=%v mask=%v name=%v loc=%v, (%v:)", tls, mask, name, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__newlocale(tls, mask, name, loc)
}

/*
grammar:

Start = Expr ';'
Expr  = Or | Or '?' Expr ':' Expr
Or    = And | Or '||' And
And   = Eq | And '&&' Eq
Eq    = Rel | Eq '==' Rel | Eq '!=' Rel
Rel   = Add | Rel '<=' Add | Rel '>=' Add | Rel '<' Add | Rel '>' Add
Add   = Mul | Add '+' Mul | Add '-' Mul
Mul   = Prim | Mul '*' Prim | Mul '/' Prim | Mul '%' Prim
Prim  = '(' Expr ')' | '!' Prim | decimal | 'n'

internals:

recursive descent expression evaluator with stack depth limit.
for binary operators an operator-precedence parser is used.
eval* functions store the result of the parsed subexpression
and return a pointer to the next non-space character.
*/

type Tst = struct {
	Fr  uint64
	Fn  uint64
	Fop int32
}

func _skipspace(tls *TLS, s uintptr) (r uintptr) {
	var v1, v2 int32
	_, _ = v1, v2
	for {
		v1 = int32(*(*uint8)(unsafe.Pointer(s)))
		v2 = BoolInt32(v1 == int32(' ') || uint32(v1)-uint32('\t') < uint32(5))
		goto _3
	_3:
		if !(v2 != 0) {
			break
		}
		s++
	}
	return s
}

func _evalprim(tls *TLS, st uintptr, s uintptr, d int32) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 int32
	var _ /* e at bp+0 */ uintptr
	_ = v1
	d--
	v1 = d
	if v1 < 0 {
		return __ccgo_ts
	}
	s = _skipspace(tls, s)
	if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0 {
		(*Tst)(unsafe.Pointer(st)).Fr = Xstrtoul(tls, s, bp, int32(10))
		if *(*uintptr)(unsafe.Pointer(bp)) == s || (*Tst)(unsafe.Pointer(st)).Fr == uint64(-Int32FromInt32(1)) {
			return __ccgo_ts
		}
		return _skipspace(tls, *(*uintptr)(unsafe.Pointer(bp)))
	}
	if int32(*(*uint8)(unsafe.Pointer(s))) == int32('n') {
		(*Tst)(unsafe.Pointer(st)).Fr = (*Tst)(unsafe.Pointer(st)).Fn
		return _skipspace(tls, s+uintptr(1))
	}
	if int32(*(*uint8)(unsafe.Pointer(s))) == int32('(') {
		s = _evalexpr(tls, st, s+uintptr(1), d)
		if int32(*(*uint8)(unsafe.Pointer(s))) != int32(')') {
			return __ccgo_ts
		}
		return _skipspace(tls, s+uintptr(1))
	}
	if int32(*(*uint8)(unsafe.Pointer(s))) == int32('!') {
		s = _evalprim(tls, st, s+uintptr(1), d)
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(!((*Tst)(unsafe.Pointer(st)).Fr != 0))
		return s
	}
	return __ccgo_ts
}

func _binop(tls *TLS, st uintptr, op int32, left uint64) (r int32) {
	var a, b uint64
	_, _ = a, b
	a = left
	b = (*Tst)(unsafe.Pointer(st)).Fr
	switch op {
	case 0:
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a != 0 || b != 0)
		return 0
	case int32(1):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a != 0 && b != 0)
		return 0
	case int32(2):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a == b)
		return 0
	case int32(3):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a != b)
		return 0
	case int32(4):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a >= b)
		return 0
	case int32(5):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a <= b)
		return 0
	case int32(6):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a > b)
		return 0
	case int32(7):
		(*Tst)(unsafe.Pointer(st)).Fr = BoolUint64(a < b)
		return 0
	case int32(8):
		(*Tst)(unsafe.Pointer(st)).Fr = a + b
		return 0
	case int32(9):
		(*Tst)(unsafe.Pointer(st)).Fr = a - b
		return 0
	case int32(10):
		(*Tst)(unsafe.Pointer(st)).Fr = a * b
		return 0
	case int32(11):
		if b != 0 {
			(*Tst)(unsafe.Pointer(st)).Fr = a % b
			return 0
		}
		return int32(1)
	case int32(12):
		if b != 0 {
			(*Tst)(unsafe.Pointer(st)).Fr = a / b
			return 0
		}
		return int32(1)
	}
	return int32(1)
}

func _parseop(tls *TLS, st uintptr, s uintptr) (r uintptr) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < int32(11)) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32(_opch[i]) {
			/* note: >,< are accepted with or without = */
			if i < int32(6) && int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32(_opch2[i]) {
				(*Tst)(unsafe.Pointer(st)).Fop = i
				return s + uintptr(2)
			}
			if i >= int32(4) {
				(*Tst)(unsafe.Pointer(st)).Fop = i + int32(2)
				return s + uintptr(1)
			}
			break
		}
		goto _1
	_1:
		;
		i++
	}
	(*Tst)(unsafe.Pointer(st)).Fop = int32(13)
	return s
}

var _opch = [11]uint8{'|', '&', '=', '!', '>', '<', '+', '-', '*', '%', '/'}

var _opch2 = [6]uint8{'|', '&', '=', '=', '=', '='}

func _evalbinop(tls *TLS, st uintptr, s uintptr, minprec int32, d int32) (r uintptr) {
	var left uint64
	var op int32
	_, _ = left, op
	d--
	s = _evalprim(tls, st, s, d)
	s = _parseop(tls, st, s)
	for {
		/*
			st->r (left hand side value) and st->op are now set,
			get the right hand side or back out if op has low prec,
			if op was missing then prec[op]==0
		*/
		op = (*Tst)(unsafe.Pointer(st)).Fop
		if int32(_prec[op]) <= minprec {
			return s
		}
		left = (*Tst)(unsafe.Pointer(st)).Fr
		s = _evalbinop(tls, st, s, int32(_prec[op]), d)
		if _binop(tls, st, op, left) != 0 {
			return __ccgo_ts
		}
		goto _1
	_1:
	}
	return r
}

var _prec = [14]uint8{
	0:  uint8(1),
	1:  uint8(2),
	2:  uint8(3),
	3:  uint8(3),
	4:  uint8(4),
	5:  uint8(4),
	6:  uint8(4),
	7:  uint8(4),
	8:  uint8(5),
	9:  uint8(5),
	10: uint8(6),
	11: uint8(6),
	12: uint8(6),
}

func _evalexpr(tls *TLS, st uintptr, s uintptr, d int32) (r uintptr) {
	var a, b, v2 uint64
	var v1 int32
	_, _, _, _ = a, b, v1, v2
	d--
	v1 = d
	if v1 < 0 {
		return __ccgo_ts
	}
	s = _evalbinop(tls, st, s, 0, d)
	if int32(*(*uint8)(unsafe.Pointer(s))) != int32('?') {
		return s
	}
	a = (*Tst)(unsafe.Pointer(st)).Fr
	s = _evalexpr(tls, st, s+uintptr(1), d)
	if int32(*(*uint8)(unsafe.Pointer(s))) != int32(':') {
		return __ccgo_ts
	}
	b = (*Tst)(unsafe.Pointer(st)).Fr
	s = _evalexpr(tls, st, s+uintptr(1), d)
	if a != 0 {
		v2 = b
	} else {
		v2 = (*Tst)(unsafe.Pointer(st)).Fr
	}
	(*Tst)(unsafe.Pointer(st)).Fr = v2
	return s
}

func X__pleval(tls *TLS, s uintptr, n uint64) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v, (%v:)", tls, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var v1 uint64
	var _ /* st at bp+0 */ Tst
	_ = v1
	(*(*Tst)(unsafe.Pointer(bp))).Fn = n
	s = _evalexpr(tls, bp, s, int32(100))
	if int32(*(*uint8)(unsafe.Pointer(s))) == int32(';') {
		v1 = (*(*Tst)(unsafe.Pointer(bp))).Fr
	} else {
		v1 = uint64(-Int32FromInt32(1))
	}
	return v1
}

var _buf1 [144]uint8

func Xsetlocale(tls *TLS, cat int32, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v cat=%v name=%v, (%v:)", tls, cat, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var i, same int32
	var l Tsize_t
	var lm, lm1, p, part1, ret, s, z, v3, v4, v5, v6 uintptr
	var _ /* part at bp+48 */ [24]uint8
	var _ /* tmp_locale at bp+0 */ t__locale_struct
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, l, lm, lm1, p, part1, ret, s, same, z, v3, v4, v5, v6
	if uint32(cat) > uint32(LC_ALL) {
		return uintptr(0)
	}
	___lock(tls, uintptr(unsafe.Pointer(&X__locale_lock)))
	/* For LC_ALL, setlocale is required to return a string which
	 * encodes the current setting for all categories. The format of
	 * this string is unspecified, and only the following code, which
	 * performs both the serialization and deserialization, depends
	 * on the format, so it can easily be changed if needed. */
	if cat == int32(LC_ALL) {
		if name != 0 {
			*(*[24]uint8)(unsafe.Pointer(bp + 48)) = [24]uint8{'C', '.', 'U', 'T', 'F', '-', '8'}
			p = name
			i = 0
			for {
				if !(i < int32(LC_ALL)) {
					break
				}
				z = X__strchrnul(tls, p, int32(';'))
				if int64(z)-int64(p) <= int64(LOCALE_NAME_MAX) {
					Xmemcpy(tls, bp+48, p, uint64(int64(z)-int64(p)))
					(*(*[24]uint8)(unsafe.Pointer(bp + 48)))[int64(z)-int64(p)] = uint8(0)
					if *(*uint8)(unsafe.Pointer(z)) != 0 {
						p = z + uintptr(1)
					}
				}
				lm = X__get_locale(tls, i, bp+48)
				if lm == uintptr(-Int32FromInt32(1)) {
					___unlock(tls, uintptr(unsafe.Pointer(&X__locale_lock)))
					return uintptr(0)
				}
				*(*uintptr)(unsafe.Pointer(bp + uintptr(i)*8)) = lm
				goto _1
			_1:
				;
				i++
			}
			X__libc.Fglobal_locale = *(*t__locale_struct)(unsafe.Pointer(bp))
		}
		s = uintptr(unsafe.Pointer(&_buf1))
		same = 0
		i = 0
		for {
			if !(i < int32(LC_ALL)) {
				break
			}
			lm1 = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__libc)) + 56 + uintptr(i)*8))
			if lm1 == *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__libc)) + 56)) {
				same++
			}
			if lm1 != 0 {
				v3 = lm1 + 16
			} else {
				v3 = __ccgo_ts + 522
			}
			part1 = v3
			l = Xstrlen(tls, part1)
			Xmemcpy(tls, s, part1, l)
			*(*uint8)(unsafe.Pointer(s + uintptr(l))) = uint8(';')
			s += uintptr(l + uint64(1))
			goto _2
		_2:
			;
			i++
		}
		s--
		v4 = s
		*(*uint8)(unsafe.Pointer(v4)) = uint8(0)
		___unlock(tls, uintptr(unsafe.Pointer(&X__locale_lock)))
		if same == int32(LC_ALL) {
			v5 = part1
		} else {
			v5 = uintptr(unsafe.Pointer(&_buf1))
		}
		return v5
	}
	if name != 0 {
		lm = X__get_locale(tls, cat, name)
		if lm == uintptr(-Int32FromInt32(1)) {
			___unlock(tls, uintptr(unsafe.Pointer(&X__locale_lock)))
			return uintptr(0)
		}
		*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__libc)) + 56 + uintptr(cat)*8)) = lm
	} else {
		lm = *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__libc)) + 56 + uintptr(cat)*8))
	}
	if lm != 0 {
		v6 = lm + 16
	} else {
		v6 = __ccgo_ts + 522
	}
	ret = v6
	___unlock(tls, uintptr(unsafe.Pointer(&X__locale_lock)))
	return ret
}

func X__strcoll_l(tls *TLS, l uintptr, r uintptr, loc Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v loc=%v, (%v:)", tls, l, r, loc, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return Xstrcmp(tls, l, r)
}

func Xstrcoll(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v, (%v:)", tls, l, r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return X__strcoll_l(tls, l, r, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func Xstrcoll_l(tls *TLS, l uintptr, r uintptr, loc Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v loc=%v, (%v:)", tls, l, r, loc, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return X__strcoll_l(tls, l, r, loc)
}

func _vstrfmon_l(tls *TLS, s uintptr, n Tsize_t, loc Tlocale_t, fmt uintptr, ap Tva_list) (r Tssize_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var fill, fw, intl, left, lp, negpar, nogrp, nosym, rp, w int32
	var l Tsize_t
	var s0, v12, v5, v6, v8 uintptr
	var x float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = fill, fw, intl, l, left, lp, negpar, nogrp, nosym, rp, s0, w, x, v12, v5, v6, v8
	s0 = s
_3:
	;
	if !(n != 0 && *(*uint8)(unsafe.Pointer(fmt)) != 0) {
		goto _1
	}
	if !(int32(*(*uint8)(unsafe.Pointer(fmt))) != int32('%')) {
		goto _4
	}
	goto literal
literal:
	;
	v5 = s
	s++
	v6 = fmt
	fmt++
	*(*uint8)(unsafe.Pointer(v5)) = *(*uint8)(unsafe.Pointer(v6))
	n--
	goto _2
_4:
	;
	fmt++
	if int32(*(*uint8)(unsafe.Pointer(fmt))) == int32('%') {
		goto literal
	}
	fill = int32(' ')
	nogrp = 0
	negpar = 0
	nosym = 0
	left = 0
	for {
		switch int32(*(*uint8)(unsafe.Pointer(fmt))) {
		case int32('='):
			fmt++
			v8 = fmt
			fill = int32(*(*uint8)(unsafe.Pointer(v8)))
			goto _7
		case int32('^'):
			nogrp = int32(1)
			goto _7
		case int32('('):
			negpar = int32(1)
			fallthrough
		case int32('+'):
			goto _7
		case int32('!'):
			nosym = int32(1)
			goto _7
		case int32('-'):
			left = int32(1)
			goto _7
		}
		break
		goto _7
	_7:
		;
		fmt++
	}
	fw = 0
	for {
		if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(fmt)))-uint32('0') < uint32(10)) != 0) {
			break
		}
		fw = int32(10)*fw + (int32(*(*uint8)(unsafe.Pointer(fmt))) - int32('0'))
		goto _9
	_9:
		;
		fmt++
	}
	lp = 0
	rp = int32(2)
	if int32(*(*uint8)(unsafe.Pointer(fmt))) == int32('#') {
		lp = 0
		fmt++
		for {
			if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(fmt)))-uint32('0') < uint32(10)) != 0) {
				break
			}
			lp = int32(10)*lp + (int32(*(*uint8)(unsafe.Pointer(fmt))) - int32('0'))
			goto _10
		_10:
			;
			fmt++
		}
	}
	if int32(*(*uint8)(unsafe.Pointer(fmt))) == int32('.') {
		rp = 0
		fmt++
		for {
			if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(fmt)))-uint32('0') < uint32(10)) != 0) {
				break
			}
			rp = int32(10)*rp + (int32(*(*uint8)(unsafe.Pointer(fmt))) - int32('0'))
			goto _11
		_11:
			;
			fmt++
		}
	}
	v12 = fmt
	fmt++
	intl = BoolInt32(int32(*(*uint8)(unsafe.Pointer(v12))) == int32('i'))
	w = lp + int32(1) + rp
	if !(left != 0) && fw > w {
		w = fw
	}
	x = VaFloat64(&ap)
	l = uint64(Xsnprintf(tls, s, n, __ccgo_ts+560, VaList(bp+8, w, rp, x)))
	if l >= n {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(E2BIG)
		return int64(-int32(1))
	}
	s += uintptr(l)
	n -= l
	goto _2
_2:
	;
	goto _3
	goto _1
_1:
	;
	return int64(s) - int64(s0)
}

func Xstrfmon_l(tls *TLS, s uintptr, n Tsize_t, loc Tlocale_t, fmt uintptr, va uintptr) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v loc=%v fmt=%v va=%v, (%v:)", tls, s, n, loc, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret Tssize_t
	_, _ = ap, ret
	ap = va
	ret = _vstrfmon_l(tls, s, n, loc, fmt, ap)
	_ = ap
	return ret
}

func Xstrfmon(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, va uintptr) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v fmt=%v va=%v, (%v:)", tls, s, n, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret Tssize_t
	_, _ = ap, ret
	ap = va
	ret = _vstrfmon_l(tls, s, n, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale, fmt, ap)
	_ = ap
	return ret
}

func Xstrtof_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float32) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v l=%v, (%v:)", tls, s, p, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtof(tls, s, p)
}

func Xstrtod_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v l=%v, (%v:)", tls, s, p, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtod(tls, s, p)
}

func Xstrtold_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v l=%v, (%v:)", tls, s, p, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtold(tls, s, p)
}

func X__strtod_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v l=%v, (%v:)", tls, s, p, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtod_l(tls, s, p, l)
}

func X__strtof_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float32) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v l=%v, (%v:)", tls, s, p, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtof_l(tls, s, p, l)
}

func X__strtold_l(tls *TLS, s uintptr, p uintptr, l Tlocale_t) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v l=%v, (%v:)", tls, s, p, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtold_l(tls, s, p, l)
}

// C documentation
//
//	/* collate only by code points */
func X__strxfrm_l(tls *TLS, dest uintptr, src uintptr, n Tsize_t, loc Tlocale_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v loc=%v, (%v:)", tls, dest, src, n, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tsize_t
	_ = l
	l = Xstrlen(tls, src)
	if n > l {
		Xstrcpy(tls, dest, src)
	}
	return l
}

func Xstrxfrm(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v, (%v:)", tls, dest, src, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__strxfrm_l(tls, dest, src, n, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

// C documentation
//
//	/* collate only by code points */
func Xstrxfrm_l(tls *TLS, dest uintptr, src uintptr, n Tsize_t, loc Tlocale_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v loc=%v, (%v:)", tls, dest, src, n, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__strxfrm_l(tls, dest, src, n, loc)
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

var _current_domain uintptr

func X__gettextdomain(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 uintptr
	_ = v1
	if _current_domain != 0 {
		v1 = _current_domain
	} else {
		v1 = __ccgo_ts + 414
	}
	return v1
}

func Xtextdomain(tls *TLS, domainname uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v domainname=%v, (%v:)", tls, domainname, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var domlen Tsize_t
	_ = domlen
	if !(domainname != 0) {
		return X__gettextdomain(tls)
	}
	domlen = Xstrlen(tls, domainname)
	if domlen > uint64(NAME_MAX) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	if !(_current_domain != 0) {
		_current_domain = Xmalloc(tls, uint64(Int32FromInt32(NAME_MAX)+Int32FromInt32(1)))
		if !(_current_domain != 0) {
			return uintptr(0)
		}
	}
	Xmemcpy(tls, _current_domain, domainname, domlen+uint64(1))
	return _current_domain
}

func Xgettext(tls *TLS, msgid uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v msgid=%v, (%v:)", tls, msgid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xdgettext(tls, uintptr(0), msgid)
}

func Xngettext(tls *TLS, msgid1 uintptr, msgid2 uintptr, n uint64) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v msgid1=%v msgid2=%v n=%v, (%v:)", tls, msgid1, msgid2, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xdngettext(tls, uintptr(0), msgid1, msgid2, n)
}

func X__uselocale(tls *TLS, new1 Tlocale_t) (r Tlocale_t) {
	if __ccgo_strace {
		trc("tls=%v new1=%v, (%v:)", tls, new1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var global, old, v1, v2 Tlocale_t
	var self Tpthread_t
	_, _, _, _, _ = global, old, self, v1, v2
	self = ___get_tp(tls)
	old = (*t__pthread)(unsafe.Pointer(self)).Flocale
	global = uintptr(unsafe.Pointer(&X__libc)) + 56
	if new1 != 0 {
		if new1 == uintptr(-Int32FromInt32(1)) {
			v1 = global
		} else {
			v1 = new1
		}
		(*t__pthread)(unsafe.Pointer(self)).Flocale = v1
	}
	if old == global {
		v2 = uintptr(-Int32FromInt32(1))
	} else {
		v2 = old
	}
	return v2
}

func Xuselocale(tls *TLS, new1 Tlocale_t) (r Tlocale_t) {
	if __ccgo_strace {
		trc("tls=%v new1=%v, (%v:)", tls, new1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__uselocale(tls, new1)
}

// C documentation
//
//	/* FIXME: stub */
func X__wcscoll_l(tls *TLS, l uintptr, r uintptr, locale Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v locale=%v, (%v:)", tls, l, r, locale, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return Xwcscmp(tls, l, r)
}

func Xwcscoll(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v, (%v:)", tls, l, r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return X__wcscoll_l(tls, l, r, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

// C documentation
//
//	/* FIXME: stub */
func Xwcscoll_l(tls *TLS, l uintptr, r uintptr, locale Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v locale=%v, (%v:)", tls, l, r, locale, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return X__wcscoll_l(tls, l, r, locale)
}

// C documentation
//
//	/* collate only by code points */
func X__wcsxfrm_l(tls *TLS, dest uintptr, src uintptr, n Tsize_t, loc Tlocale_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v loc=%v, (%v:)", tls, dest, src, n, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tsize_t
	_ = l
	l = Xwcslen(tls, src)
	if l < n {
		Xwmemcpy(tls, dest, src, l+uint64(1))
	} else {
		if n != 0 {
			Xwmemcpy(tls, dest, src, n-uint64(1))
			*(*Twchar_t)(unsafe.Pointer(dest + uintptr(n-uint64(1))*4)) = uint32(0)
		}
	}
	return l
}

func Xwcsxfrm(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v, (%v:)", tls, dest, src, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__wcsxfrm_l(tls, dest, src, n, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

// C documentation
//
//	/* collate only by code points */
func Xwcsxfrm_l(tls *TLS, dest uintptr, src uintptr, n Tsize_t, loc Tlocale_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v loc=%v, (%v:)", tls, dest, src, n, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__wcsxfrm_l(tls, dest, src, n, loc)
}

func Xreallocarray(tls *TLS, ptr uintptr, m Tsize_t, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ptr=%v m=%v n=%v, (%v:)", tls, ptr, m, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if n != 0 && m > uint64(-Int32FromInt32(1))/n {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMEM)
		return uintptr(0)
	}
	return Xrealloc(tls, ptr, m*n)
}

const LDBL_EPSILON2 = 0
const LDBL_MAX2 = 0
const LDBL_MIN2 = 0

var _C1 = float64(0.0416666666666666)                 /* 0x3FA55555, 0x5555554C */
var _C2 = -Float64FromFloat64(0.001388888888887411)   /* 0xBF56C16C, 0x16C15177 */
var _C3 = float64(2.480158728947673e-05)              /* 0x3EFA01A0, 0x19CB1590 */
var _C4 = -Float64FromFloat64(2.7557314351390663e-07) /* 0xBE927E4F, 0x809C52AD */
var _C5 = float64(2.087572321298175e-09)              /* 0x3E21EE9E, 0xBDB4B1C4 */
var _C6 = -Float64FromFloat64(1.1359647557788195e-11) /* 0xBDA8FAE9, 0xBE8838D4 */

func X__cos(tls *TLS, x float64, y float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var hz, r, w, z Tdouble_t
	_, _, _, _ = hz, r, w, z
	z = x * x
	w = z * z
	r = z*(_C1+z*(_C2+z*_C3)) + w*w*(_C4+z*(_C5+z*_C6))
	hz = float64(0.5) * z
	w = float64(1) - hz
	return w + (Float64FromFloat64(1) - w - hz + (z*r - x*y))
}

// C documentation
//
//	/* |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]). */

var _C0 = -Float64FromFloat64(0.499999997251031)     /* -0.499999997251031003120 */
var _C11 = float64(0.04166662332373906)              /*  0.0416666233237390631894 */
var _C21 = -Float64FromFloat64(0.001388676377460993) /* -0.00138867637746099294692 */
var _C31 = float64(2.439044879627741e-05)            /*  0.0000243904487962774090654 */

func X__cosdf(tls *TLS, x float64) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, w, z Tdouble_t
	_, _, _ = r, w, z
	/* Try to optimize for parallel evaluation as in __tandf.c. */
	z = x * x
	w = z * z
	r = _C21 + z*_C31
	return float32(float64(1) + z*_C0 + w*_C11 + w*z*r)
}

// C documentation
//
//	/* k is such that k*ln2 has minimal relative error and x - kln2 > log(DBL_MIN) */
var _k2 = int32(2043)
var _kln22 = float64(1416.0996898839683)

// C documentation
//
//	/* exp(x)/2 for x >= log(DBL_MAX), slightly better than 0.5*exp(x/2)*exp(x/2) */
func X__expo2(tls *TLS, x float64, sign float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v sign=%v, (%v:)", tls, x, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var scale float64
	var v1 Tuint64_t
	_, _ = scale, v1
	/* note that k is odd and scale*scale overflows */
	v1 = uint64(uint32(Int32FromInt32(0x3ff)+_k2/Int32FromInt32(2))<<Int32FromInt32(20))<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))
	scale = *(*float64)(unsafe.Pointer(&v1))
	/* exp(x - k ln2) * 2**(k-1) */
	/* in directed rounding correct sign before rounding or overflow is important */
	return Xexp(tls, x-_kln22) * (sign * scale) * scale
}

// C documentation
//
//	/* k is such that k*ln2 has minimal relative error and x - kln2 > log(FLT_MIN) */
var _k3 = int32(235)
var _kln23 = Float32FromFloat32(162.88958740234375)

// C documentation
//
//	/* expf(x)/2 for x >= log(FLT_MAX), slightly better than 0.5f*expf(x/2)*expf(x/2) */
func X__expo2f(tls *TLS, x float32, sign float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v sign=%v, (%v:)", tls, x, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var scale float32
	var v1 Tuint32_t
	_, _ = scale, v1
	/* note that k is odd and scale*scale overflows */
	v1 = uint32(Int32FromInt32(0x7f)+_k3/Int32FromInt32(2)) << int32(23)
	scale = *(*float32)(unsafe.Pointer(&v1))
	/* exp(x - k ln2) * 2**(k-1) */
	/* in directed rounding correct sign before rounding or overflow is important */
	return Xexpf(tls, x-_kln23) * (sign * scale) * scale
}

func X__fpclassify(tls *TLS, x float64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, v1, v2 int32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _ = e, v1, v2
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if !(e != 0) {
		if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(1) != 0 {
			v1 = int32(FP_SUBNORMAL)
		} else {
			v1 = int32(FP_ZERO)
		}
		return v1
	}
	if e == int32(0x7ff) {
		if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(12) != 0 {
			v2 = FP_NAN
		} else {
			v2 = int32(FP_INFINITE)
		}
		return v2
	}
	return int32(FP_NORMAL)
}

func X__fpclassifyf(tls *TLS, x float32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, v1, v2 int32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _ = e, v1, v2
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	if !(e != 0) {
		if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(1) != 0 {
			v1 = int32(FP_SUBNORMAL)
		} else {
			v1 = int32(FP_ZERO)
		}
		return v1
	}
	if e == int32(0xff) {
		if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(9) != 0 {
			v2 = FP_NAN
		} else {
			v2 = int32(FP_INFINITE)
		}
		return v2
	}
	return int32(FP_NORMAL)
}

func X__fpclassifyl(tls *TLS, x float64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fpclassify(tls, x)
}

const pio2_hi = 0
const pio2_lo = 0

func X__math_divzero(tls *TLS, sign Tuint32_t) (r float64) {
	if __ccgo_strace {
		trc("tls=%v sign=%v, (%v:)", tls, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var y, v1, v2 float64
	_, _, _ = y, v1, v2
	if sign != 0 {
		v1 = -Float64FromFloat64(1)
	} else {
		v1 = float64(1)
	}
	y = v1
	v2 = y
	goto _3
_3:
	return v2 / float64(0)
}

func X__math_divzerof(tls *TLS, sign Tuint32_t) (r float32) {
	if __ccgo_strace {
		trc("tls=%v sign=%v, (%v:)", tls, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var y, v1, v2 float32
	_, _, _ = y, v1, v2
	if sign != 0 {
		v1 = -Float32FromFloat32(1)
	} else {
		v1 = Float32FromFloat32(1)
	}
	y = v1
	v2 = y
	goto _3
_3:
	return v2 / Float32FromFloat32(0)
}

func X__math_invalid(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return (x - x) / (x - x)
}

func X__math_invalidf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return (x - x) / (x - x)
}

func X__math_oflow(tls *TLS, sign Tuint32_t) (r float64) {
	if __ccgo_strace {
		trc("tls=%v sign=%v, (%v:)", tls, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__math_xflow(tls, sign, float64(3.105036184601418e+231))
}

func X__math_oflowf(tls *TLS, sign Tuint32_t) (r float32) {
	if __ccgo_strace {
		trc("tls=%v sign=%v, (%v:)", tls, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__math_xflowf(tls, sign, Float32FromFloat32(1.5845632502852868e+29))
}

func X__math_uflow(tls *TLS, sign Tuint32_t) (r float64) {
	if __ccgo_strace {
		trc("tls=%v sign=%v, (%v:)", tls, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__math_xflow(tls, sign, float64(1.2882297539194267e-231))
}

func X__math_uflowf(tls *TLS, sign Tuint32_t) (r float32) {
	if __ccgo_strace {
		trc("tls=%v sign=%v, (%v:)", tls, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__math_xflowf(tls, sign, Float32FromFloat32(2.524354896707238e-29))
}

func X__math_xflow(tls *TLS, sign Tuint32_t, y2 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v sign=%v y2=%v, (%v:)", tls, sign, y2, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var y, y1, v1, v2, v4 float64
	_, _, _, _, _ = y, y1, v1, v2, v4
	if sign != 0 {
		v1 = -y2
	} else {
		v1 = y2
	}
	y1 = v1
	v2 = y1
	goto _3
_3:
	y = v2 * y2
	v4 = y
	goto _5
_5:
	return v4
}

func X__math_xflowf(tls *TLS, sign Tuint32_t, y2 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v sign=%v y2=%v, (%v:)", tls, sign, y2, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var y, y1, v1, v2, v4 float32
	_, _, _, _, _ = y, y1, v1, v2, v4
	if sign != 0 {
		v1 = -y2
	} else {
		v1 = y2
	}
	y1 = v1
	v2 = y1
	goto _3
_3:
	y = v2 * y2
	v4 = y
	goto _5
_5:
	return v4
}

const DBL_EPSILON1 = 2.220446049250313e-16
const EPS = 0

// C documentation
//
//	/*
//	 * invpio2:  53 bits of 2/pi
//	 * pio2_1:   first  33 bit of pi/2
//	 * pio2_1t:  pi/2 - pio2_1
//	 * pio2_2:   second 33 bit of pi/2
//	 * pio2_2t:  pi/2 - (pio2_1+pio2_2)
//	 * pio2_3:   third  33 bit of pi/2
//	 * pio2_3t:  pi/2 - (pio2_1+pio2_2+pio2_3)
//	 */

var _toint = Float64FromFloat64(1.5) / Float64FromFloat64(2.220446049250313e-16)
var _pio4 = float64(0.7853981633974483)
var _invpio2 = float64(0.6366197723675814)     /* 0x3FE45F30, 0x6DC9C883 */
var _pio2_1 = float64(1.5707963267341256)      /* 0x3FF921FB, 0x54400000 */
var _pio2_1t = float64(6.077100506506192e-11)  /* 0x3DD0B461, 0x1A626331 */
var _pio2_2 = float64(6.077100506303966e-11)   /* 0x3DD0B461, 0x1A600000 */
var _pio2_2t = float64(2.0222662487959506e-21) /* 0x3BA3198A, 0x2E037073 */
var _pio2_3 = float64(2.0222662487111665e-21)  /* 0x3BA3198A, 0x2E000000 */
var _pio2_3t = float64(8.4784276603689e-32)    /* 0x397B839A, 0x252049C1 */

// C documentation
//
//	/* caller must handle the case when reduction is not needed: |x| ~<= pi/4 */
func X__rem_pio2(tls *TLS, x float64, y uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var ex, ey, i, n, sign int32
	var fn, r, t, w, z Tdouble_t
	var ix Tuint32_t
	var v2 float64
	var _ /* tx at bp+8 */ [3]float64
	var _ /* ty at bp+32 */ [2]float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _ = ex, ey, fn, i, ix, n, r, sign, t, w, z, v2
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	if ix <= uint32(0x400f6a7a) { /* |x| ~<= 5pi/4 */
		if ix&uint32(0xfffff) == uint32(0x921fb) { /* |x| ~= pi/2 or 2pi/2 */
			goto medium
		} /* cancellation -- use medium case */
		if ix <= uint32(0x4002d97c) { /* |x| ~<= 3pi/4 */
			if !(sign != 0) {
				z = x - _pio2_1 /* one round good to 85 bits */
				*(*float64)(unsafe.Pointer(y)) = z - _pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) - _pio2_1t
				return int32(1)
			} else {
				z = x + _pio2_1
				*(*float64)(unsafe.Pointer(y)) = z + _pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) + _pio2_1t
				return -int32(1)
			}
		} else {
			if !(sign != 0) {
				z = x - Float64FromInt32(2)*_pio2_1
				*(*float64)(unsafe.Pointer(y)) = z - Float64FromInt32(2)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) - Float64FromInt32(2)*_pio2_1t
				return int32(2)
			} else {
				z = x + Float64FromInt32(2)*_pio2_1
				*(*float64)(unsafe.Pointer(y)) = z + Float64FromInt32(2)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) + Float64FromInt32(2)*_pio2_1t
				return -int32(2)
			}
		}
	}
	if ix <= uint32(0x401c463b) { /* |x| ~<= 9pi/4 */
		if ix <= uint32(0x4015fdbc) { /* |x| ~<= 7pi/4 */
			if ix == uint32(0x4012d97c) { /* |x| ~= 3pi/2 */
				goto medium
			}
			if !(sign != 0) {
				z = x - Float64FromInt32(3)*_pio2_1
				*(*float64)(unsafe.Pointer(y)) = z - Float64FromInt32(3)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) - Float64FromInt32(3)*_pio2_1t
				return int32(3)
			} else {
				z = x + Float64FromInt32(3)*_pio2_1
				*(*float64)(unsafe.Pointer(y)) = z + Float64FromInt32(3)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) + Float64FromInt32(3)*_pio2_1t
				return -int32(3)
			}
		} else {
			if ix == uint32(0x401921fb) { /* |x| ~= 4pi/2 */
				goto medium
			}
			if !(sign != 0) {
				z = x - Float64FromInt32(4)*_pio2_1
				*(*float64)(unsafe.Pointer(y)) = z - Float64FromInt32(4)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) - Float64FromInt32(4)*_pio2_1t
				return int32(4)
			} else {
				z = x + Float64FromInt32(4)*_pio2_1
				*(*float64)(unsafe.Pointer(y)) = z + Float64FromInt32(4)*_pio2_1t
				*(*float64)(unsafe.Pointer(y + 1*8)) = z - *(*float64)(unsafe.Pointer(y)) + Float64FromInt32(4)*_pio2_1t
				return -int32(4)
			}
		}
	}
	if !(ix < uint32(0x413921fb)) {
		goto _1
	} /* |x| ~< 2^20*(pi/2), medium size */
	goto medium
medium:
	;
	/* rint(x/(pi/2)) */
	fn = x*_invpio2 + _toint - _toint
	n = int32(fn)
	r = x - fn*_pio2_1
	w = fn * _pio2_1t /* 1st round, good to 85 bits */
	/* Matters with directed rounding. */
	if r-w < -_pio4 {
		n--
		fn--
		r = x - fn*_pio2_1
		w = fn * _pio2_1t
	} else {
		if r-w > _pio4 {
			n++
			fn++
			r = x - fn*_pio2_1
			w = fn * _pio2_1t
		}
	}
	*(*float64)(unsafe.Pointer(y)) = r - w
	*(*float64)(unsafe.Pointer(bp)) = *(*float64)(unsafe.Pointer(y))
	ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	ex = int32(ix >> int32(20))
	if ex-ey > int32(16) { /* 2nd round, good to 118 bits */
		t = r
		w = fn * _pio2_2
		r = t - w
		w = fn*_pio2_2t - (t - r - w)
		*(*float64)(unsafe.Pointer(y)) = r - w
		*(*float64)(unsafe.Pointer(bp)) = *(*float64)(unsafe.Pointer(y))
		ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
		if ex-ey > int32(49) { /* 3rd round, good to 151 bits, covers all cases */
			t = r
			w = fn * _pio2_3
			r = t - w
			w = fn*_pio2_3t - (t - r - w)
			*(*float64)(unsafe.Pointer(y)) = r - w
		}
	}
	*(*float64)(unsafe.Pointer(y + 1*8)) = r - *(*float64)(unsafe.Pointer(y)) - w
	return n
_1:
	;
	/*
	 * all other (large) arguments
	 */
	if ix >= uint32(0x7ff00000) { /* x is inf or NaN */
		v2 = x - x
		*(*float64)(unsafe.Pointer(y + 1*8)) = v2
		*(*float64)(unsafe.Pointer(y)) = v2
		return 0
	}
	/* set z = scalbn(|x|,-ilogb(x)+23) */
	*(*float64)(unsafe.Pointer(bp)) = x
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= uint64(-Int32FromInt32(1)) >> Int32FromInt32(12)
	*(*Tuint64_t)(unsafe.Pointer(bp)) |= uint64(Int32FromInt32(0x3ff)+Int32FromInt32(23)) << Int32FromInt32(52)
	z = *(*float64)(unsafe.Pointer(bp))
	i = 0
	for {
		if !(i < int32(2)) {
			break
		}
		(*(*[3]float64)(unsafe.Pointer(bp + 8)))[i] = float64(int32(z))
		z = (z - (*(*[3]float64)(unsafe.Pointer(bp + 8)))[i]) * float64(1.6777216e+07)
		goto _3
	_3:
		;
		i++
	}
	(*(*[3]float64)(unsafe.Pointer(bp + 8)))[i] = z
	/* skip zero terms, first term is non-zero */
	for (*(*[3]float64)(unsafe.Pointer(bp + 8)))[i] == float64(0) {
		i--
	}
	n = X__rem_pio2_large(tls, bp+8, bp+32, int32(ix>>Int32FromInt32(20))-(Int32FromInt32(0x3ff)+Int32FromInt32(23)), i+int32(1), int32(1))
	if sign != 0 {
		*(*float64)(unsafe.Pointer(y)) = -(*(*[2]float64)(unsafe.Pointer(bp + 32)))[0]
		*(*float64)(unsafe.Pointer(y + 1*8)) = -(*(*[2]float64)(unsafe.Pointer(bp + 32)))[int32(1)]
		return -n
	}
	*(*float64)(unsafe.Pointer(y)) = (*(*[2]float64)(unsafe.Pointer(bp + 32)))[0]
	*(*float64)(unsafe.Pointer(y + 1*8)) = (*(*[2]float64)(unsafe.Pointer(bp + 32)))[int32(1)]
	return n
}

const DBL_EPSILON2 = 0

var _init_jk = [4]int32{
	0: int32(3),
	1: int32(4),
	2: int32(4),
	3: int32(6),
} /* initial value for jk */

// C documentation
//
//	/*
//	 * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi
//	 *
//	 *              integer array, contains the (24*i)-th to (24*i+23)-th
//	 *              bit of 2/pi after binary point. The corresponding
//	 *              floating value is
//	 *
//	 *                      ipio2[i] * 2^(-24(i+1)).
//	 *
//	 * NB: This table must have at least (e0-3)/24 + jk terms.
//	 *     For quad precision (e0 <= 16360, jk = 6), this is 686.
//	 */
var _ipio2 = [66]Tint32_t{
	0:  int32(0xA2F983),
	1:  int32(0x6E4E44),
	2:  int32(0x1529FC),
	3:  int32(0x2757D1),
	4:  int32(0xF534DD),
	5:  int32(0xC0DB62),
	6:  int32(0x95993C),
	7:  int32(0x439041),
	8:  int32(0xFE5163),
	9:  int32(0xABDEBB),
	10: int32(0xC561B7),
	11: int32(0x246E3A),
	12: int32(0x424DD2),
	13: int32(0xE00649),
	14: int32(0x2EEA09),
	15: int32(0xD1921C),
	16: int32(0xFE1DEB),
	17: int32(0x1CB129),
	18: int32(0xA73EE8),
	19: int32(0x8235F5),
	20: int32(0x2EBB44),
	21: int32(0x84E99C),
	22: int32(0x7026B4),
	23: int32(0x5F7E41),
	24: int32(0x3991D6),
	25: int32(0x398353),
	26: int32(0x39F49C),
	27: int32(0x845F8B),
	28: int32(0xBDF928),
	29: int32(0x3B1FF8),
	30: int32(0x97FFDE),
	31: int32(0x05980F),
	32: int32(0xEF2F11),
	33: int32(0x8B5A0A),
	34: int32(0x6D1F6D),
	35: int32(0x367ECF),
	36: int32(0x27CB09),
	37: int32(0xB74F46),
	38: int32(0x3F669E),
	39: int32(0x5FEA2D),
	40: int32(0x7527BA),
	41: int32(0xC7EBE5),
	42: int32(0xF17B3D),
	43: int32(0x0739F7),
	44: int32(0x8A5292),
	45: int32(0xEA6BFB),
	46: int32(0x5FB11F),
	47: int32(0x8D5D08),
	48: int32(0x560330),
	49: int32(0x46FC7B),
	50: int32(0x6BABF0),
	51: int32(0xCFBC20),
	52: int32(0x9AF436),
	53: int32(0x1DA9E3),
	54: int32(0x91615E),
	55: int32(0xE61B08),
	56: int32(0x659985),
	57: int32(0x5F14A0),
	58: int32(0x68408D),
	59: int32(0xFFD880),
	60: int32(0x4D7327),
	61: int32(0x310606),
	62: int32(0x1556CA),
	63: int32(0x73A8C9),
	64: int32(0x60E27B),
	65: int32(0xC08C6B),
}

var _PIo2 = [8]float64{
	0: float64(1.570796251296997),
	1: float64(7.549789415861596e-08),
	2: float64(5.390302529957765e-15),
	3: float64(3.282003415807913e-22),
	4: float64(1.270655753080676e-29),
	5: float64(1.2293330898111133e-36),
	6: float64(2.7337005381646456e-44),
	7: float64(2.1674168387780482e-51),
}

func X__rem_pio2_large(tls *TLS, x uintptr, y uintptr, e0 int32, nx int32, prec int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v e0=%v nx=%v prec=%v, (%v:)", tls, x, y, e0, nx, prec, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(240)
	defer tls.Free(240)
	var carry, i, ih, j, jk, jp, jv, jx, jz, k, m, n, q0 Tint32_t
	var f, q [20]float64
	var fw, z, v2, v20, v22, v24 float64
	var _ /* fq at bp+80 */ [20]float64
	var _ /* iq at bp+0 */ [20]Tint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = carry, f, fw, i, ih, j, jk, jp, jv, jx, jz, k, m, n, q, q0, z, v2, v20, v22, v24
	/* initialize jk*/
	jk = _init_jk[prec]
	jp = jk
	/* determine jx,jv,q0, note that 3>q0 */
	jx = nx - int32(1)
	jv = (e0 - int32(3)) / int32(24)
	if jv < 0 {
		jv = 0
	}
	q0 = e0 - int32(24)*(jv+int32(1))
	/* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv - jx
	m = jx + jk
	i = 0
	for {
		if !(i <= m) {
			break
		}
		if j < 0 {
			v2 = float64(0)
		} else {
			v2 = float64(_ipio2[j])
		}
		f[i] = v2
		goto _1
	_1:
		;
		i++
		j++
	}
	/* compute q[0],q[1],...q[jk] */
	i = 0
	for {
		if !(i <= jk) {
			break
		}
		j = 0
		fw = Float64FromFloat64(0)
		for {
			if !(j <= jx) {
				break
			}
			fw += *(*float64)(unsafe.Pointer(x + uintptr(j)*8)) * f[jx+i-j]
			goto _4
		_4:
			;
			j++
		}
		q[i] = fw
		goto _3
	_3:
		;
		i++
	}
	jz = jk
	goto recompute
recompute:
	;
	/* distill q[] into iq[] reversingly */
	i = 0
	j = jz
	z = q[jz]
	for {
		if !(j > 0) {
			break
		}
		fw = float64(int32(Float64FromFloat64(5.960464477539063e-08) * z))
		(*(*[20]Tint32_t)(unsafe.Pointer(bp)))[i] = int32(z - Float64FromFloat64(1.6777216e+07)*fw)
		z = q[j-int32(1)] + fw
		goto _5
	_5:
		;
		i++
		j--
	}
	/* compute n */
	z = Xscalbn(tls, z, q0)                         /* actual value of z */
	z -= float64(8) * Xfloor(tls, z*float64(0.125)) /* trim off integer >= 8 */
	n = int32(z)
	z -= float64(n)
	ih = 0
	if q0 > 0 { /* need iq[jz-1] to determine n */
		i = (*(*[20]Tint32_t)(unsafe.Pointer(bp)))[jz-int32(1)] >> (int32(24) - q0)
		n += i
		*(*Tint32_t)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) -= i << (int32(24) - q0)
		ih = (*(*[20]Tint32_t)(unsafe.Pointer(bp)))[jz-int32(1)] >> (int32(23) - q0)
	} else {
		if q0 == 0 {
			ih = (*(*[20]Tint32_t)(unsafe.Pointer(bp)))[jz-int32(1)] >> int32(23)
		} else {
			if z >= float64(0.5) {
				ih = int32(2)
			}
		}
	}
	if ih > 0 { /* q > 0.5 */
		n += int32(1)
		carry = 0
		i = 0
		for {
			if !(i < jz) {
				break
			} /* compute 1-q */
			j = (*(*[20]Tint32_t)(unsafe.Pointer(bp)))[i]
			if carry == 0 {
				if j != 0 {
					carry = int32(1)
					(*(*[20]Tint32_t)(unsafe.Pointer(bp)))[i] = int32(0x1000000) - j
				}
			} else {
				(*(*[20]Tint32_t)(unsafe.Pointer(bp)))[i] = int32(0xffffff) - j
			}
			goto _6
		_6:
			;
			i++
		}
		if q0 > 0 { /* rare case: chance is 1 in 12 */
			switch q0 {
			case int32(1):
				*(*Tint32_t)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) &= int32(0x7fffff)
			case int32(2):
				*(*Tint32_t)(unsafe.Pointer(bp + uintptr(jz-int32(1))*4)) &= int32(0x3fffff)
				break
			}
		}
		if ih == int32(2) {
			z = float64(1) - z
			if carry != 0 {
				z -= Xscalbn(tls, float64(1), q0)
			}
		}
	}
	/* check if recomputation is needed */
	if z == float64(0) {
		j = 0
		i = jz - int32(1)
		for {
			if !(i >= jk) {
				break
			}
			j |= (*(*[20]Tint32_t)(unsafe.Pointer(bp)))[i]
			goto _7
		_7:
			;
			i--
		}
		if j == 0 { /* need recomputation */
			k = int32(1)
			for {
				if !((*(*[20]Tint32_t)(unsafe.Pointer(bp)))[jk-k] == 0) {
					break
				}
				goto _8
			_8:
				;
				k++
			} /* k = no. of terms needed */
			i = jz + int32(1)
			for {
				if !(i <= jz+k) {
					break
				} /* add q[jz+1] to q[jz+k] */
				f[jx+i] = float64(_ipio2[jv+i])
				j = 0
				fw = Float64FromFloat64(0)
				for {
					if !(j <= jx) {
						break
					}
					fw += *(*float64)(unsafe.Pointer(x + uintptr(j)*8)) * f[jx+i-j]
					goto _10
				_10:
					;
					j++
				}
				q[i] = fw
				goto _9
			_9:
				;
				i++
			}
			jz += k
			goto recompute
		}
	}
	/* chop off zero terms */
	if z == float64(0) {
		jz -= int32(1)
		q0 -= int32(24)
		for (*(*[20]Tint32_t)(unsafe.Pointer(bp)))[jz] == 0 {
			jz--
			q0 -= int32(24)
		}
	} else { /* break z into 24-bit if necessary */
		z = Xscalbn(tls, z, -q0)
		if z >= float64(1.6777216e+07) {
			fw = float64(int32(Float64FromFloat64(5.960464477539063e-08) * z))
			(*(*[20]Tint32_t)(unsafe.Pointer(bp)))[jz] = int32(z - Float64FromFloat64(1.6777216e+07)*fw)
			jz += int32(1)
			q0 += int32(24)
			(*(*[20]Tint32_t)(unsafe.Pointer(bp)))[jz] = int32(fw)
		} else {
			(*(*[20]Tint32_t)(unsafe.Pointer(bp)))[jz] = int32(z)
		}
	}
	/* convert integer "bit" chunk to floating-point value */
	fw = Xscalbn(tls, float64(1), q0)
	i = jz
	for {
		if !(i >= 0) {
			break
		}
		q[i] = fw * float64((*(*[20]Tint32_t)(unsafe.Pointer(bp)))[i])
		fw *= float64(5.960464477539063e-08)
		goto _11
	_11:
		;
		i--
	}
	/* compute PIo2[0,...,jp]*q[jz,...,0] */
	i = jz
	for {
		if !(i >= 0) {
			break
		}
		fw = float64(0)
		k = Int32FromInt32(0)
		for {
			if !(k <= jp && k <= jz-i) {
				break
			}
			fw += _PIo2[k] * q[i+k]
			goto _13
		_13:
			;
			k++
		}
		(*(*[20]float64)(unsafe.Pointer(bp + 80)))[jz-i] = fw
		goto _12
	_12:
		;
		i--
	}
	/* compress fq[] into y[] */
	switch prec {
	case 0:
		goto _14
	case int32(2):
		goto _15
	case int32(1):
		goto _16
	case int32(3):
		goto _17
	}
	goto _18
_14:
	;
	fw = float64(0)
	i = jz
	for {
		if !(i >= 0) {
			break
		}
		fw += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
		goto _19
	_19:
		;
		i--
	}
	if ih == 0 {
		v20 = fw
	} else {
		v20 = -fw
	}
	*(*float64)(unsafe.Pointer(y)) = v20
	goto _18
_16:
	;
_15:
	;
	fw = float64(0)
	i = jz
	for {
		if !(i >= 0) {
			break
		}
		fw += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
		goto _21
	_21:
		;
		i--
	}
	// TODO: drop excess precision here once double_t is used
	fw = fw
	if ih == 0 {
		v22 = fw
	} else {
		v22 = -fw
	}
	*(*float64)(unsafe.Pointer(y)) = v22
	fw = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[0] - fw
	i = int32(1)
	for {
		if !(i <= jz) {
			break
		}
		fw += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
		goto _23
	_23:
		;
		i++
	}
	if ih == 0 {
		v24 = fw
	} else {
		v24 = -fw
	}
	*(*float64)(unsafe.Pointer(y + 1*8)) = v24
	goto _18
_17:
	; /* painful */
	i = jz
_27:
	;
	if !(i > 0) {
		goto _25
	}
	fw = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] + (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
	*(*float64)(unsafe.Pointer(bp + 80 + uintptr(i)*8)) += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] - fw
	(*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] = fw
	goto _26
_26:
	;
	i--
	goto _27
	goto _25
_25:
	;
	i = jz
	for {
		if !(i > int32(1)) {
			break
		}
		fw = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] + (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
		*(*float64)(unsafe.Pointer(bp + 80 + uintptr(i)*8)) += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] - fw
		(*(*[20]float64)(unsafe.Pointer(bp + 80)))[i-int32(1)] = fw
		goto _28
	_28:
		;
		i--
	}
	fw = float64(0)
	i = jz
	for {
		if !(i >= int32(2)) {
			break
		}
		fw += (*(*[20]float64)(unsafe.Pointer(bp + 80)))[i]
		goto _29
	_29:
		;
		i--
	}
	if ih == 0 {
		*(*float64)(unsafe.Pointer(y)) = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[0]
		*(*float64)(unsafe.Pointer(y + 1*8)) = (*(*[20]float64)(unsafe.Pointer(bp + 80)))[int32(1)]
		*(*float64)(unsafe.Pointer(y + 2*8)) = fw
	} else {
		*(*float64)(unsafe.Pointer(y)) = -(*(*[20]float64)(unsafe.Pointer(bp + 80)))[0]
		*(*float64)(unsafe.Pointer(y + 1*8)) = -(*(*[20]float64)(unsafe.Pointer(bp + 80)))[int32(1)]
		*(*float64)(unsafe.Pointer(y + 2*8)) = -fw
	}
_18:
	;
	return n & int32(7)
}

const DBL_EPSILON3 = 2.220446049250313e-16

// C documentation
//
//	/*
//	 * invpio2:  53 bits of 2/pi
//	 * pio2_1:   first 25 bits of pi/2
//	 * pio2_1t:  pi/2 - pio2_1
//	 */

var _toint1 = Float64FromFloat64(1.5) / Float64FromFloat64(2.220446049250313e-16)
var _pio41 = float64(0.7853981852531433)
var _invpio21 = float64(0.6366197723675814)     /* 0x3FE45F30, 0x6DC9C883 */
var _pio2_11 = float64(1.5707963109016418)      /* 0x3FF921FB, 0x50000000 */
var _pio2_1t1 = float64(1.5893254773528196e-08) /* 0x3E5110b4, 0x611A6263 */

func X__rem_pio2f(tls *TLS, x float32, y uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var e0, n, sign int32
	var fn Tdouble_t
	var ix Tuint32_t
	var _ /* tx at bp+8 */ [1]float64
	var _ /* ty at bp+16 */ [1]float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _ = e0, fn, ix, n, sign
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	/* 25+53 bit pi is good enough for medium size */
	if ix < uint32(0x4dc90fdb) { /* |x| ~< 2^28*(pi/2), medium size */
		/* Use a specialized rint() to get fn. */
		fn = float64(x)*_invpio21 + _toint1 - _toint1
		n = int32(fn)
		*(*float64)(unsafe.Pointer(y)) = float64(x) - fn*_pio2_11 - fn*_pio2_1t1
		/* Matters with directed rounding. */
		if *(*float64)(unsafe.Pointer(y)) < -_pio41 {
			n--
			fn--
			*(*float64)(unsafe.Pointer(y)) = float64(x) - fn*_pio2_11 - fn*_pio2_1t1
		} else {
			if *(*float64)(unsafe.Pointer(y)) > _pio41 {
				n++
				fn++
				*(*float64)(unsafe.Pointer(y)) = float64(x) - fn*_pio2_11 - fn*_pio2_1t1
			}
		}
		return n
	}
	if ix >= uint32(0x7f800000) { /* x is inf or NaN */
		*(*float64)(unsafe.Pointer(y)) = float64(x - x)
		return 0
	}
	/* scale x into [2^23, 2^24-1] */
	sign = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	e0 = int32(ix>>Int32FromInt32(23) - uint32(Int32FromInt32(0x7f)+Int32FromInt32(23))) /* e0 = ilogb(|x|)-23, positive */
	*(*Tuint32_t)(unsafe.Pointer(bp)) = ix - uint32(e0<<Int32FromInt32(23))
	(*(*[1]float64)(unsafe.Pointer(bp + 8)))[0] = float64(*(*float32)(unsafe.Pointer(bp)))
	n = X__rem_pio2_large(tls, bp+8, bp+16, e0, int32(1), 0)
	if sign != 0 {
		*(*float64)(unsafe.Pointer(y)) = -(*(*[1]float64)(unsafe.Pointer(bp + 16)))[0]
		return -n
	}
	*(*float64)(unsafe.Pointer(y)) = (*(*[1]float64)(unsafe.Pointer(bp + 16)))[0]
	return n
}

const DBL_EPSILON4 = 0

// C documentation
//
//	// FIXME: macro in math.h
func X__signbit(tls *TLS, x float64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* y at bp+0 */ struct {
		Fi [0]Tuint64_t
		Fd float64
	}
	*(*struct {
		Fi [0]Tuint64_t
		Fd float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Fd float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	return int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
}

// C documentation
//
//	// FIXME: macro in math.h
func X__signbitf(tls *TLS, x float32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* y at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	return int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
}

func X__signbitl(tls *TLS, x float64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__signbit(tls, x)
}

var _S1 = -Float64FromFloat64(0.16666666666666632)    /* 0xBFC55555, 0x55555549 */
var _S2 = float64(0.00833333333332249)                /* 0x3F811111, 0x1110F8A6 */
var _S3 = -Float64FromFloat64(0.0001984126982985795)  /* 0xBF2A01A0, 0x19C161D5 */
var _S4 = float64(2.7557313707070068e-06)             /* 0x3EC71DE3, 0x57B1FE7D */
var _S5 = -Float64FromFloat64(2.5050760253406863e-08) /* 0xBE5AE5E6, 0x8A2B9CEB */
var _S6 = float64(1.58969099521155e-10)               /* 0x3DE5D93A, 0x5ACFD57C */

func X__sin(tls *TLS, x float64, y float64, iy int32) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v iy=%v, (%v:)", tls, x, y, iy, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v, w, z Tdouble_t
	_, _, _, _ = r, v, w, z
	z = x * x
	w = z * z
	r = _S2 + z*(_S3+z*_S4) + z*w*(_S5+z*_S6)
	v = z * x
	if iy == 0 {
		return x + v*(_S1+z*r)
	} else {
		return x - (z*(Float64FromFloat64(0.5)*y-v*r) - y - v*_S1)
	}
	return r1
}

// C documentation
//
//	/* |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]). */

var _S11 = -Float64FromFloat64(0.16666666641626524)    /* -0.166666666416265235595 */
var _S21 = float64(0.008333329385889463)               /*  0.0083333293858894631756 */
var _S31 = -Float64FromFloat64(0.00019839334836096632) /* -0.000198393348360966317347 */
var _S41 = float64(2.718311493989822e-06)              /*  0.0000027183114939898219064 */

func X__sindf(tls *TLS, x float64) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, s, w, z Tdouble_t
	_, _, _, _ = r, s, w, z
	/* Try to optimize for parallel evaluation as in __tandf.c. */
	z = x * x
	w = z * z
	r = _S31 + z*_S41
	s = z * x
	return float32(x + s*(_S11+z*_S21) + s*w*r)
}

var _T = [13]float64{
	0:  float64(0.3333333333333341),
	1:  float64(0.13333333333320124),
	2:  float64(0.05396825397622605),
	3:  float64(0.021869488294859542),
	4:  float64(0.0088632398235993),
	5:  float64(0.0035920791075913124),
	6:  float64(0.0014562094543252903),
	7:  float64(0.0005880412408202641),
	8:  float64(0.0002464631348184699),
	9:  float64(7.817944429395571e-05),
	10: float64(7.140724913826082e-05),
	11: -Float64FromFloat64(1.8558637485527546e-05),
	12: float64(2.590730518636337e-05),
}
var _pio42 = float64(0.7853981633974483)     /* 3FE921FB, 54442D18 */
var _pio4lo = float64(3.061616997868383e-17) /* 3C81A626, 33145C07 */

func X__tan(tls *TLS, x float64, y float64, odd int32) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v odd=%v, (%v:)", tls, x, y, odd, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var a, r, s, v, w, z, v1, v3 Tdouble_t
	var a0, w0 float64
	var big, sign int32
	var hx Tuint32_t
	var v2, v4 Tuint64_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, a0, big, hx, r, s, sign, v, w, w0, z, v1, v2, v3, v4
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	big = BoolInt32(hx&uint32(0x7fffffff) >= uint32(0x3FE59428)) /* |x| >= 0.6744 */
	if big != 0 {
		sign = int32(hx >> int32(31))
		if sign != 0 {
			x = -x
			y = -y
		}
		x = _pio42 - x + (_pio4lo - y)
		y = float64(0)
	}
	z = x * x
	w = z * z
	/*
	 * Break x^5*(T[1]+x^2*T[2]+...) into
	 * x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
	 * x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
	 */
	r = _T[int32(1)] + w*(_T[int32(3)]+w*(_T[int32(5)]+w*(_T[int32(7)]+w*(_T[int32(9)]+w*_T[int32(11)]))))
	v = z * (_T[int32(2)] + w*(_T[int32(4)]+w*(_T[int32(6)]+w*(_T[int32(8)]+w*(_T[int32(10)]+w*_T[int32(12)])))))
	s = z * x
	r = y + z*(s*(r+v)+y) + s*_T[0]
	w = x + r
	if big != 0 {
		s = float64(int32(1) - int32(2)*odd)
		v = s - float64(2)*(x+(r-w*w/(w+s)))
		if sign != 0 {
			v1 = -v
		} else {
			v1 = v
		}
		return v1
	}
	if !(odd != 0) {
		return w
	}
	/* -1.0/(x+r) has up to 2ulp error, so compute it accurately */
	w0 = w
	v2 = *(*Tuint64_t)(unsafe.Pointer(&w0))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))
	w0 = *(*float64)(unsafe.Pointer(&v2))
	v = r - (w0 - x) /* w0+v = r+x */
	v3 = -Float64FromFloat64(1) / w
	a = v3
	a0 = v3
	v4 = *(*Tuint64_t)(unsafe.Pointer(&a0))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))
	a0 = *(*float64)(unsafe.Pointer(&v4))
	return a0 + a*(Float64FromFloat64(1)+a0*w0+a0*v)
}

// C documentation
//
//	/* |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]). */
var _T1 = [6]float64{
	0: float64(0.3333313950307914),
	1: float64(0.13339200271297674),
	2: float64(0.05338123784456704),
	3: float64(0.024528318116654728),
	4: float64(0.002974357433599673),
	5: float64(0.009465647849436732),
}

func X__tandf(tls *TLS, x float64, odd int32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v odd=%v, (%v:)", tls, x, odd, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, s, t, u, w, z Tdouble_t
	var v1 float64
	_, _, _, _, _, _, _ = r, s, t, u, w, z, v1
	z = x * x
	/*
	 * Split up the polynomial into small independent terms to give
	 * opportunities for parallel evaluation.  The chosen splitting is
	 * micro-optimized for Athlons (XP, X64).  It costs 2 multiplications
	 * relative to Horner's method on sequential machines.
	 *
	 * We add the small terms from lowest degree up for efficiency on
	 * non-sequential machines (the lowest degree terms tend to be ready
	 * earlier).  Apart from this, we don't care about order of
	 * operations, and don't need to to care since we have precision to
	 * spare.  However, the chosen splitting is good for accuracy too,
	 * and would give results as accurate as Horner's method if the
	 * small terms were added from highest degree down.
	 */
	r = _T1[int32(4)] + z*_T1[int32(5)]
	t = _T1[int32(2)] + z*_T1[int32(3)]
	w = z * z
	s = z * x
	u = _T1[0] + z*_T1[int32(1)]
	r = x + s*u + s*w*(t+w*r)
	if odd != 0 {
		v1 = -Float64FromFloat64(1) / r
	} else {
		v1 = r
	}
	return float32(v1)
}

var _pio2_hi = float64(1.5707963267948966)          /* 0x3FF921FB, 0x54442D18 */
var _pio2_lo = float64(6.123233995736766e-17)       /* 0x3C91A626, 0x33145C07 */
var _pS0 = float64(0.16666666666666666)             /* 0x3FC55555, 0x55555555 */
var _pS1 = -Float64FromFloat64(0.3255658186224009)  /* 0xBFD4D612, 0x03EB6F7D */
var _pS2 = float64(0.20121253213486293)             /* 0x3FC9C155, 0x0E884455 */
var _pS3 = -Float64FromFloat64(0.04005553450067941) /* 0xBFA48228, 0xB5688F3B */
var _pS4 = float64(0.0007915349942898145)           /* 0x3F49EFE0, 0x7501B288 */
var _pS5 = float64(3.479331075960212e-05)           /* 0x3F023DE1, 0x0DFDF709 */
var _qS1 = -Float64FromFloat64(2.403394911734414)   /* 0xC0033A27, 0x1C8A2D4B */
var _qS2 = float64(2.0209457602335057)              /* 0x40002AE5, 0x9C598AC8 */
var _qS3 = -Float64FromFloat64(0.6882839716054533)  /* 0xBFE6066C, 0x1B8D0159 */
var _qS4 = float64(0.07703815055590194)             /* 0x3FB3B8C5, 0xB12E9282 */

func _R(tls *TLS, z float64) (r float64) {
	var p, q Tdouble_t
	_, _ = p, q
	p = z * (_pS0 + z*(_pS1+z*(_pS2+z*(_pS3+z*(_pS4+z*_pS5)))))
	q = float64(1) + z*(_qS1+z*(_qS2+z*(_qS3+z*_qS4)))
	return p / q
}

func Xacos(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var c, df, s, w, z float64
	var hx, ix, lx Tuint32_t
	var v1 Tuint64_t
	_, _, _, _, _, _, _, _, _ = c, df, hx, ix, lx, s, w, z, v1
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	ix = hx & uint32(0x7fffffff)
	/* |x| >= 1 or nan */
	if ix >= uint32(0x3ff00000) {
		lx = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)))
		if ix-uint32(0x3ff00000)|lx == uint32(0) {
			/* acos(1)=0, acos(-1)=pi */
			if hx>>int32(31) != 0 {
				return Float64FromInt32(2)*_pio2_hi + Float64FromFloat32(7.52316384526264e-37)
			}
			return Float64FromInt32(0)
		}
		return Float64FromInt32(0) / (x - x)
	}
	/* |x| < 0.5 */
	if ix < uint32(0x3fe00000) {
		if ix <= uint32(0x3c600000) { /* |x| < 2**-57 */
			return _pio2_hi + Float64FromFloat32(7.52316384526264e-37)
		}
		return _pio2_hi - (x - (_pio2_lo - x*_R(tls, x*x)))
	}
	/* x < -0.5 */
	if hx>>int32(31) != 0 {
		z = (float64(1) + x) * float64(0.5)
		s = Xsqrt(tls, z)
		w = _R(tls, z)*s - _pio2_lo
		return Float64FromInt32(2) * (_pio2_hi - (s + w))
	}
	/* x > 0.5 */
	z = (float64(1) - x) * float64(0.5)
	s = Xsqrt(tls, z)
	df = s
	v1 = *(*Tuint64_t)(unsafe.Pointer(&df))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))
	df = *(*float64)(unsafe.Pointer(&v1))
	c = (z - df*df) / (s + df)
	w = _R(tls, z)*s + c
	return Float64FromInt32(2) * (df + w)
}

var _pio2_hi1 = float32(1.5707962513)     /* 0x3fc90fda */
var _pio2_lo1 = float32(7.5497894159e-08) /* 0x33a22168 */
var _pS01 = float32(0.16666586697)
var _pS11 = float32(-Float64FromFloat64(0.042743422091))
var _pS21 = float32(-Float64FromFloat64(0.008656363003))
var _qS11 = float32(-Float64FromFloat64(0.7066296339))

func _R1(tls *TLS, z float32) (r float32) {
	var p, q Tfloat_t
	_, _ = p, q
	p = z * (_pS01 + z*(_pS11+z*_pS21))
	q = Float32FromFloat32(1) + z*_qS11
	return p / q
}

func Xacosf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var c, df, s, w, z float32
	var hx, ix, v1 Tuint32_t
	_, _, _, _, _, _, _, _ = c, df, hx, ix, s, w, z, v1
	hx = *(*Tuint32_t)(unsafe.Pointer(&x))
	ix = hx & uint32(0x7fffffff)
	/* |x| >= 1 or nan */
	if ix >= uint32(0x3f800000) {
		if ix == uint32(0x3f800000) {
			if hx>>int32(31) != 0 {
				return Float32FromInt32(2)*_pio2_hi1 + Float32FromFloat32(7.52316384526264e-37)
			}
			return Float32FromInt32(0)
		}
		return Float32FromInt32(0) / (x - x)
	}
	/* |x| < 0.5 */
	if ix < uint32(0x3f000000) {
		if ix <= uint32(0x32800000) { /* |x| < 2**-26 */
			return _pio2_hi1 + Float32FromFloat32(7.52316384526264e-37)
		}
		return _pio2_hi1 - (x - (_pio2_lo1 - x*_R1(tls, x*x)))
	}
	/* x < -0.5 */
	if hx>>int32(31) != 0 {
		z = (Float32FromInt32(1) + x) * Float32FromFloat32(0.5)
		s = Xsqrtf(tls, z)
		w = _R1(tls, z)*s - _pio2_lo1
		return Float32FromInt32(2) * (_pio2_hi1 - (s + w))
	}
	/* x > 0.5 */
	z = (Float32FromInt32(1) - x) * Float32FromFloat32(0.5)
	s = Xsqrtf(tls, z)
	hx = *(*Tuint32_t)(unsafe.Pointer(&s))
	v1 = hx & uint32(0xfffff000)
	df = *(*float32)(unsafe.Pointer(&v1))
	c = (z - df*df) / (s + df)
	w = _R1(tls, z)*s + c
	return Float32FromInt32(2) * (df + w)
}

// C documentation
//
//	/* acosh(x) = log(x + sqrt(x*x-1)) */
func Xacosh(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e uint32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_ = e
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	e = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	/* x < 1 domain error is handled in the called functions */
	if e < uint32(Int32FromInt32(0x3ff)+Int32FromInt32(1)) {
		/* |x| < 2, up to 2ulp error in [1,1.125] */
		return Xlog1p(tls, x-Float64FromInt32(1)+Xsqrt(tls, (x-Float64FromInt32(1))*(x-Float64FromInt32(1))+Float64FromInt32(2)*(x-Float64FromInt32(1))))
	}
	if e < uint32(Int32FromInt32(0x3ff)+Int32FromInt32(26)) {
		/* |x| < 0x1p26 */
		return Xlog(tls, Float64FromInt32(2)*x-Float64FromInt32(1)/(x+Xsqrt(tls, x*x-Float64FromInt32(1))))
	}
	/* |x| >= 0x1p26 or nan */
	return Xlog(tls, x) + float64(0.6931471805599453)
}

// C documentation
//
//	/* acosh(x) = log(x + sqrt(x*x-1)) */
func Xacoshf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var a Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_ = a
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	a = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	if a < uint32(Int32FromInt32(0x3f800000)+Int32FromInt32(1)<<Int32FromInt32(23)) {
		/* |x| < 2, invalid if x < 1 */
		/* up to 2ulp error in [1,1.125] */
		return Xlog1pf(tls, x-Float32FromInt32(1)+Xsqrtf(tls, (x-Float32FromInt32(1))*(x-Float32FromInt32(1))+Float32FromInt32(2)*(x-Float32FromInt32(1))))
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp)) < uint32(Int32FromInt32(0x3f800000)+Int32FromInt32(12)<<Int32FromInt32(23)) {
		/* 2 <= x < 0x1p12 */
		return Xlogf(tls, Float32FromInt32(2)*x-Float32FromInt32(1)/(x+Xsqrtf(tls, x*x-Float32FromInt32(1))))
	}
	/* x >= 0x1p12 or x <= -2 or nan */
	return Xlogf(tls, x) + Float32FromFloat32(0.6931471805599453)
}

func Xacoshl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xacosh(tls, x)
}

func Xacosl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xacos(tls, x)
}

var _pio2_hi2 = float64(1.5707963267948966)    /* 0x3FF921FB, 0x54442D18 */
var _pio2_lo2 = float64(6.123233995736766e-17) /* 0x3C91A626, 0x33145C07 */
/* coefficients for R(x^2) */
var _pS02 = float64(0.16666666666666666)             /* 0x3FC55555, 0x55555555 */
var _pS12 = -Float64FromFloat64(0.3255658186224009)  /* 0xBFD4D612, 0x03EB6F7D */
var _pS22 = float64(0.20121253213486293)             /* 0x3FC9C155, 0x0E884455 */
var _pS31 = -Float64FromFloat64(0.04005553450067941) /* 0xBFA48228, 0xB5688F3B */
var _pS41 = float64(0.0007915349942898145)           /* 0x3F49EFE0, 0x7501B288 */
var _pS51 = float64(3.479331075960212e-05)           /* 0x3F023DE1, 0x0DFDF709 */
var _qS12 = -Float64FromFloat64(2.403394911734414)   /* 0xC0033A27, 0x1C8A2D4B */
var _qS21 = float64(2.0209457602335057)              /* 0x40002AE5, 0x9C598AC8 */
var _qS31 = -Float64FromFloat64(0.6882839716054533)  /* 0xBFE6066C, 0x1B8D0159 */
var _qS41 = float64(0.07703815055590194)             /* 0x3FB3B8C5, 0xB12E9282 */

func _R2(tls *TLS, z float64) (r float64) {
	var p, q Tdouble_t
	_, _ = p, q
	p = z * (_pS02 + z*(_pS12+z*(_pS22+z*(_pS31+z*(_pS41+z*_pS51)))))
	q = float64(1) + z*(_qS12+z*(_qS21+z*(_qS31+z*_qS41)))
	return p / q
}

func Xasin(tls *TLS, x float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var c, f, r, s, z float64
	var hx, ix, lx Tuint32_t
	var v1 Tuint64_t
	_, _, _, _, _, _, _, _, _ = c, f, hx, ix, lx, r, s, z, v1
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	ix = hx & uint32(0x7fffffff)
	/* |x| >= 1 or nan */
	if ix >= uint32(0x3ff00000) {
		lx = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)))
		if ix-uint32(0x3ff00000)|lx == uint32(0) {
			/* asin(1) = +-pi/2 with inexact */
			return x*_pio2_hi2 + Float64FromFloat32(7.52316384526264e-37)
		}
		return Float64FromInt32(0) / (x - x)
	}
	/* |x| < 0.5 */
	if ix < uint32(0x3fe00000) {
		/* if 0x1p-1022 <= |x| < 0x1p-26, avoid raising underflow */
		if ix < uint32(0x3e500000) && ix >= uint32(0x00100000) {
			return x
		}
		return x + x*_R2(tls, x*x)
	}
	/* 1 > |x| >= 0.5 */
	z = (Float64FromInt32(1) - Xfabs(tls, x)) * float64(0.5)
	s = Xsqrt(tls, z)
	r = _R2(tls, z)
	if ix >= uint32(0x3fef3333) { /* if |x| > 0.975 */
		x = _pio2_hi2 - (Float64FromInt32(2)*(s+s*r) - _pio2_lo2)
	} else {
		/* f+c = sqrt(z) */
		f = s
		v1 = *(*Tuint64_t)(unsafe.Pointer(&f))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))
		f = *(*float64)(unsafe.Pointer(&v1))
		c = (z - f*f) / (s + f)
		x = float64(0.5)*_pio2_hi2 - (Float64FromInt32(2)*s*r - (_pio2_lo2 - Float64FromInt32(2)*c) - (float64(0.5)*_pio2_hi2 - Float64FromInt32(2)*f))
	}
	if hx>>int32(31) != 0 {
		return -x
	}
	return x
}

var _pio2 = float64(1.5707963267948966)

/* coefficients for R(x^2) */
var _pS03 = float32(0.16666586697)
var _pS13 = float32(-Float64FromFloat64(0.042743422091))
var _pS23 = float32(-Float64FromFloat64(0.008656363003))
var _qS13 = float32(-Float64FromFloat64(0.7066296339))

func _R3(tls *TLS, z float32) (r float32) {
	var p, q Tfloat_t
	_, _ = p, q
	p = z * (_pS03 + z*(_pS13+z*_pS23))
	q = Float32FromFloat32(1) + z*_qS13
	return p / q
}

func Xasinf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var hx, ix Tuint32_t
	var s float64
	var z float32
	_, _, _, _ = hx, ix, s, z
	hx = *(*Tuint32_t)(unsafe.Pointer(&x))
	ix = hx & uint32(0x7fffffff)
	if ix >= uint32(0x3f800000) { /* |x| >= 1 */
		if ix == uint32(0x3f800000) { /* |x| == 1 */
			return float32(float64(x)*_pio2 + Float64FromFloat32(7.52316384526264e-37))
		} /* asin(+-1) = +-pi/2 with inexact */
		return Float32FromInt32(0) / (x - x) /* asin(|x|>1) is NaN */
	}
	if ix < uint32(0x3f000000) { /* |x| < 0.5 */
		/* if 0x1p-126 <= |x| < 0x1p-12, avoid raising underflow */
		if ix < uint32(0x39800000) && ix >= uint32(0x00800000) {
			return x
		}
		return x + x*_R3(tls, x*x)
	}
	/* 1 > |x| >= 0.5 */
	z = (Float32FromInt32(1) - Xfabsf(tls, x)) * Float32FromFloat32(0.5)
	s = Xsqrt(tls, float64(z))
	x = float32(_pio2 - Float64FromInt32(2)*(s+s*float64(_R3(tls, z))))
	if hx>>int32(31) != 0 {
		return -x
	}
	return x
}

// C documentation
//
//	/* asinh(x) = sign(x)*log(|x|+sqrt(x*x+1)) ~= x - x^3/6 + o(x^5) */
func Xasinh(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, s uint32
	var y float32
	var y1, y2, v1 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _ = e, s, y, y1, y2, v1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	e = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	s = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	/* |x| */
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= uint64(-Int32FromInt32(1)) / Uint64FromInt32(2)
	x3 = *(*float64)(unsafe.Pointer(bp))
	if e >= uint32(Int32FromInt32(0x3ff)+Int32FromInt32(26)) {
		/* |x| >= 0x1p26 or inf or nan */
		x3 = Xlog(tls, x3) + float64(0.6931471805599453)
	} else {
		if e >= uint32(Int32FromInt32(0x3ff)+Int32FromInt32(1)) {
			/* |x| >= 2 */
			x3 = Xlog(tls, Float64FromInt32(2)*x3+Float64FromInt32(1)/(Xsqrt(tls, x3*x3+Float64FromInt32(1))+x3))
		} else {
			if e >= uint32(Int32FromInt32(0x3ff)-Int32FromInt32(26)) {
				/* |x| >= 0x1p-26, up to 1.6ulp error in [0.125,0.5] */
				x3 = Xlog1p(tls, x3+x3*x3/(Xsqrt(tls, x3*x3+Float64FromInt32(1))+Float64FromInt32(1)))
			} else {
				/* |x| < 0x1p-26, raise inexact if x != 0 */
				if uint64(8) == uint64(4) {
					y = float32(x3 + Float64FromFloat32(1.329227995784916e+36))
				} else {
					if uint64(8) == uint64(8) {
						y1 = x3 + Float64FromFloat32(1.329227995784916e+36)
					} else {
						y2 = x3 + Float64FromFloat32(1.329227995784916e+36)
					}
				}
			}
		}
	}
	if s != 0 {
		v1 = -x3
	} else {
		v1 = x3
	}
	return v1
}

// C documentation
//
//	/* asinh(x) = sign(x)*log(|x|+sqrt(x*x+1)) ~= x - x^3/6 + o(x^5) */
func Xasinhf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i Tuint32_t
	var s uint32
	var y, v1 float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _ = i, s, y, y1, y2, v1
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	i = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	s = *(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31)
	/* |x| */
	*(*Tuint32_t)(unsafe.Pointer(bp)) = i
	x3 = *(*float32)(unsafe.Pointer(bp))
	if i >= uint32(Int32FromInt32(0x3f800000)+Int32FromInt32(12)<<Int32FromInt32(23)) {
		/* |x| >= 0x1p12 or inf or nan */
		x3 = Xlogf(tls, x3) + Float32FromFloat32(0.6931471805599453)
	} else {
		if i >= uint32(Int32FromInt32(0x3f800000)+Int32FromInt32(1)<<Int32FromInt32(23)) {
			/* |x| >= 2 */
			x3 = Xlogf(tls, Float32FromInt32(2)*x3+Float32FromInt32(1)/(Xsqrtf(tls, x3*x3+Float32FromInt32(1))+x3))
		} else {
			if i >= uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(12)<<Int32FromInt32(23)) {
				/* |x| >= 0x1p-12, up to 1.6ulp error in [0.125,0.5] */
				x3 = Xlog1pf(tls, x3+x3*x3/(Xsqrtf(tls, x3*x3+Float32FromInt32(1))+Float32FromInt32(1)))
			} else {
				/* |x| < 0x1p-12, raise inexact if x!=0 */
				if uint64(4) == uint64(4) {
					y = x3 + Float32FromFloat32(1.329227995784916e+36)
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
					} else {
						y2 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
					}
				}
			}
		}
	}
	if s != 0 {
		v1 = -x3
	} else {
		v1 = x3
	}
	return v1
}

func Xasinhl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xasinh(tls, x)
}

func Xasinl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xasin(tls, x)
}

var _atanhi = [4]float64{
	0: float64(0.4636476090008061),
	1: float64(0.7853981633974483),
	2: float64(0.982793723247329),
	3: float64(1.5707963267948966),
}

var _atanlo = [4]float64{
	0: float64(2.2698777452961687e-17),
	1: float64(3.061616997868383e-17),
	2: float64(1.3903311031230998e-17),
	3: float64(6.123233995736766e-17),
}

var _aT = [11]float64{
	0:  float64(0.3333333333333293),
	1:  -Float64FromFloat64(0.19999999999876483),
	2:  float64(0.14285714272503466),
	3:  -Float64FromFloat64(0.11111110405462356),
	4:  float64(0.09090887133436507),
	5:  -Float64FromFloat64(0.0769187620504483),
	6:  float64(0.06661073137387531),
	7:  -Float64FromFloat64(0.058335701337905735),
	8:  float64(0.049768779946159324),
	9:  -Float64FromFloat64(0.036531572744216916),
	10: float64(0.016285820115365782),
}

func Xatan(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var id int32
	var ix, sign Tuint32_t
	var s1, s2, w, z, v3, v4 Tdouble_t
	var y float32
	var y1, y2 float64
	var v1 uint64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _ = id, ix, s1, s2, sign, w, y, y1, y2, z, v1, v3, v4
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x3)) >> int32(32))
	sign = ix >> int32(31)
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x44100000) { /* if |x| >= 2^66 */
		*(*float64)(unsafe.Pointer(bp)) = x3
		v1 = *(*uint64)(unsafe.Pointer(bp))
		goto _2
	_2:
		if BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
			return x3
		}
		z = _atanhi[int32(3)] + Float64FromFloat32(7.52316384526264e-37)
		if sign != 0 {
			v3 = -z
		} else {
			v3 = z
		}
		return v3
	}
	if ix < uint32(0x3fdc0000) { /* |x| < 0.4375 */
		if ix < uint32(0x3e400000) { /* |x| < 2^-27 */
			if ix < uint32(0x00100000) {
				/* raise underflow for subnormal x */
				if uint64(4) == uint64(4) {
					y = float32(x3)
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(float32(x3))
					} else {
						y2 = float64(float32(x3))
					}
				}
			}
			return x3
		}
		id = -int32(1)
	} else {
		x3 = Xfabs(tls, x3)
		if ix < uint32(0x3ff30000) { /* |x| < 1.1875 */
			if ix < uint32(0x3fe60000) { /*  7/16 <= |x| < 11/16 */
				id = 0
				x3 = (float64(2)*x3 - float64(1)) / (float64(2) + x3)
			} else { /* 11/16 <= |x| < 19/16 */
				id = int32(1)
				x3 = (x3 - float64(1)) / (x3 + float64(1))
			}
		} else {
			if ix < uint32(0x40038000) { /* |x| < 2.4375 */
				id = int32(2)
				x3 = (x3 - float64(1.5)) / (float64(1) + float64(1.5)*x3)
			} else { /* 2.4375 <= |x| < 2^66 */
				id = int32(3)
				x3 = -Float64FromFloat64(1) / x3
			}
		}
	}
	/* end of argument reduction */
	z = x3 * x3
	w = z * z
	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z * (_aT[0] + w*(_aT[int32(2)]+w*(_aT[int32(4)]+w*(_aT[int32(6)]+w*(_aT[int32(8)]+w*_aT[int32(10)])))))
	s2 = w * (_aT[int32(1)] + w*(_aT[int32(3)]+w*(_aT[int32(5)]+w*(_aT[int32(7)]+w*_aT[int32(9)]))))
	if id < 0 {
		return x3 - x3*(s1+s2)
	}
	z = _atanhi[id] - (x3*(s1+s2) - _atanlo[id] - x3)
	if sign != 0 {
		v4 = -z
	} else {
		v4 = z
	}
	return v4
}

var _pi = float64(3.141592653589793)         /* 0x400921FB, 0x54442D18 */
var _pi_lo = float64(1.2246467991473532e-16) /* 0x3CA1A626, 0x33145C07 */

func Xatan2(tls *TLS, y float64, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v y=%v x=%v, (%v:)", tls, y, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var __u1, __u2 Tuint64_t
	var ix, iy, lx, ly, m Tuint32_t
	var z, v6, v7 float64
	var v1, v3 uint64
	var v5 bool
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _ = __u1, __u2, ix, iy, lx, ly, m, z, v1, v3, v5, v6, v7
	*(*float64)(unsafe.Pointer(bp)) = x
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0; !v5 {
		*(*float64)(unsafe.Pointer(bp)) = y
		v3 = *(*uint64)(unsafe.Pointer(bp))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x + y
	}
	__u1 = *(*Tuint64_t)(unsafe.Pointer(&x))
	ix = uint32(__u1 >> int32(32))
	lx = uint32(__u1)
	__u2 = *(*Tuint64_t)(unsafe.Pointer(&y))
	iy = uint32(__u2 >> int32(32))
	ly = uint32(__u2)
	if ix-uint32(0x3ff00000)|lx == uint32(0) { /* x = 1.0 */
		return Xatan(tls, y)
	}
	m = iy>>Int32FromInt32(31)&uint32(1) | ix>>Int32FromInt32(30)&uint32(2) /* 2*sign(x)+sign(y) */
	ix = ix & uint32(0x7fffffff)
	iy = iy & uint32(0x7fffffff)
	/* when y = 0 */
	if iy|ly == uint32(0) {
		switch m {
		case uint32(0):
			fallthrough
		case uint32(1):
			return y /* atan(+-0,+anything)=+-0 */
		case uint32(2):
			return _pi /* atan(+0,-anything) = pi */
		case uint32(3):
			return -_pi /* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if ix|lx == uint32(0) {
		if m&uint32(1) != 0 {
			v6 = -_pi / Float64FromInt32(2)
		} else {
			v6 = _pi / Float64FromInt32(2)
		}
		return v6
	}
	/* when x is INF */
	if ix == uint32(0x7ff00000) {
		if iy == uint32(0x7ff00000) {
			switch m {
			case uint32(0):
				return _pi / Float64FromInt32(4) /* atan(+INF,+INF) */
			case uint32(1):
				return -_pi / Float64FromInt32(4) /* atan(-INF,+INF) */
			case uint32(2):
				return Float64FromInt32(3) * _pi / Float64FromInt32(4) /* atan(+INF,-INF) */
			case uint32(3):
				return float64(-Int32FromInt32(3)) * _pi / Float64FromInt32(4) /* atan(-INF,-INF) */
			}
		} else {
			switch m {
			case uint32(0):
				return float64(0) /* atan(+...,+INF) */
			case uint32(1):
				return -Float64FromFloat64(0) /* atan(-...,+INF) */
			case uint32(2):
				return _pi /* atan(+...,-INF) */
			case uint32(3):
				return -_pi /* atan(-...,-INF) */
			}
		}
	}
	/* |y/x| > 0x1p64 */
	if ix+uint32(Int32FromInt32(64)<<Int32FromInt32(20)) < iy || iy == uint32(0x7ff00000) {
		if m&uint32(1) != 0 {
			v7 = -_pi / Float64FromInt32(2)
		} else {
			v7 = _pi / Float64FromInt32(2)
		}
		return v7
	}
	/* z = atan(|y/x|) without spurious underflow */
	if m&uint32(2) != 0 && iy+uint32(Int32FromInt32(64)<<Int32FromInt32(20)) < ix { /* |y/x| < 0x1p-64, x<0 */
		z = Float64FromInt32(0)
	} else {
		z = Xatan(tls, Xfabs(tls, y/x))
	}
	switch m {
	case uint32(0):
		return z /* atan(+,+) */
	case uint32(1):
		return -z /* atan(-,+) */
	case uint32(2):
		return _pi - (z - _pi_lo) /* atan(+,-) */
	default: /* case 3 */
		return z - _pi_lo - _pi /* atan(-,-) */
	}
	return r
}

var _pi1 = float32(3.141592741)                              /* 0x40490fdb */
var _pi_lo1 = float32(-Float64FromFloat64(8.7422776573e-08)) /* 0xb3bbbd2e */

func Xatan2f(tls *TLS, y float32, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v y=%v x=%v, (%v:)", tls, y, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ix, iy, m Tuint32_t
	var z, v6, v7 float32
	var v1, v3 uint32
	var v5 bool
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _, _, _, _, _, _ = ix, iy, m, z, v1, v3, v5, v6, v7
	*(*float32)(unsafe.Pointer(bp)) = x
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0; !v5 {
		*(*float32)(unsafe.Pointer(bp)) = y
		v3 = *(*uint32)(unsafe.Pointer(bp))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x + y
	}
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	iy = *(*Tuint32_t)(unsafe.Pointer(&y))
	if ix == uint32(0x3f800000) { /* x=1.0 */
		return Xatanf(tls, y)
	}
	m = iy>>Int32FromInt32(31)&uint32(1) | ix>>Int32FromInt32(30)&uint32(2) /* 2*sign(x)+sign(y) */
	ix &= uint32(0x7fffffff)
	iy &= uint32(0x7fffffff)
	/* when y = 0 */
	if iy == uint32(0) {
		switch m {
		case uint32(0):
			fallthrough
		case uint32(1):
			return y /* atan(+-0,+anything)=+-0 */
		case uint32(2):
			return _pi1 /* atan(+0,-anything) = pi */
		case uint32(3):
			return -_pi1 /* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if ix == uint32(0) {
		if m&uint32(1) != 0 {
			v6 = -_pi1 / Float32FromInt32(2)
		} else {
			v6 = _pi1 / Float32FromInt32(2)
		}
		return v6
	}
	/* when x is INF */
	if ix == uint32(0x7f800000) {
		if iy == uint32(0x7f800000) {
			switch m {
			case uint32(0):
				return _pi1 / Float32FromInt32(4) /* atan(+INF,+INF) */
			case uint32(1):
				return -_pi1 / Float32FromInt32(4) /* atan(-INF,+INF) */
			case uint32(2):
				return Float32FromInt32(3) * _pi1 / Float32FromInt32(4) /*atan(+INF,-INF)*/
			case uint32(3):
				return float32(-Int32FromInt32(3)) * _pi1 / Float32FromInt32(4) /*atan(-INF,-INF)*/
			}
		} else {
			switch m {
			case uint32(0):
				return Float32FromFloat32(0) /* atan(+...,+INF) */
			case uint32(1):
				return -Float32FromFloat32(0) /* atan(-...,+INF) */
			case uint32(2):
				return _pi1 /* atan(+...,-INF) */
			case uint32(3):
				return -_pi1 /* atan(-...,-INF) */
			}
		}
	}
	/* |y/x| > 0x1p26 */
	if ix+uint32(Int32FromInt32(26)<<Int32FromInt32(23)) < iy || iy == uint32(0x7f800000) {
		if m&uint32(1) != 0 {
			v7 = -_pi1 / Float32FromInt32(2)
		} else {
			v7 = _pi1 / Float32FromInt32(2)
		}
		return v7
	}
	/* z = atan(|y/x|) with correct underflow */
	if m&uint32(2) != 0 && iy+uint32(Int32FromInt32(26)<<Int32FromInt32(23)) < ix { /*|y/x| < 0x1p-26, x < 0 */
		z = float32(0)
	} else {
		z = Xatanf(tls, Xfabsf(tls, y/x))
	}
	switch m {
	case uint32(0):
		return z /* atan(+,+) */
	case uint32(1):
		return -z /* atan(-,+) */
	case uint32(2):
		return _pi1 - (z - _pi_lo1) /* atan(+,-) */
	default: /* case 3 */
		return z - _pi_lo1 - _pi1 /* atan(-,-) */
	}
	return r
}

func Xatan2l(tls *TLS, y float64, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v y=%v x=%v, (%v:)", tls, y, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xatan2(tls, y, x)
}

var _atanhi1 = [4]float32{
	0: float32(0.46364760399),
	1: float32(0.78539812565),
	2: float32(0.98279368877),
	3: float32(1.5707962513),
}

var _atanlo1 = [4]float32{
	0: float32(5.012158244e-09),
	1: float32(3.7748947079e-08),
	2: float32(3.447321717e-08),
	3: float32(7.5497894159e-08),
}

var _aT1 = [5]float32{
	0: float32(0.33333328366),
	1: float32(-Float64FromFloat64(0.19999158382)),
	2: float32(0.14253635705),
	3: float32(-Float64FromFloat64(0.10648017377)),
	4: float32(0.061687607318),
}

func Xatanf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var id int32
	var ix, sign Tuint32_t
	var s1, s2, w, z, v3, v4 Tfloat_t
	var y float32
	var y1, y2 float64
	var v1 uint32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _ = id, ix, s1, s2, sign, w, y, y1, y2, z, v1, v3, v4
	ix = *(*Tuint32_t)(unsafe.Pointer(&x3))
	sign = ix >> int32(31)
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x4c800000) { /* if |x| >= 2**26 */
		*(*float32)(unsafe.Pointer(bp)) = x3
		v1 = *(*uint32)(unsafe.Pointer(bp))
		goto _2
	_2:
		if BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
			return x3
		}
		z = _atanhi1[int32(3)] + Float32FromFloat32(7.52316384526264e-37)
		if sign != 0 {
			v3 = -z
		} else {
			v3 = z
		}
		return v3
	}
	if ix < uint32(0x3ee00000) { /* |x| < 0.4375 */
		if ix < uint32(0x39800000) { /* |x| < 2**-12 */
			if ix < uint32(0x00800000) {
				/* raise underflow for subnormal x */
				if uint64(4) == uint64(4) {
					y = x3 * x3
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(x3 * x3)
					} else {
						y2 = float64(x3 * x3)
					}
				}
			}
			return x3
		}
		id = -int32(1)
	} else {
		x3 = Xfabsf(tls, x3)
		if ix < uint32(0x3f980000) { /* |x| < 1.1875 */
			if ix < uint32(0x3f300000) { /*  7/16 <= |x| < 11/16 */
				id = 0
				x3 = (Float32FromFloat32(2)*x3 - Float32FromFloat32(1)) / (Float32FromFloat32(2) + x3)
			} else { /* 11/16 <= |x| < 19/16 */
				id = int32(1)
				x3 = (x3 - Float32FromFloat32(1)) / (x3 + Float32FromFloat32(1))
			}
		} else {
			if ix < uint32(0x401c0000) { /* |x| < 2.4375 */
				id = int32(2)
				x3 = (x3 - Float32FromFloat32(1.5)) / (Float32FromFloat32(1) + Float32FromFloat32(1.5)*x3)
			} else { /* 2.4375 <= |x| < 2**26 */
				id = int32(3)
				x3 = -Float32FromFloat32(1) / x3
			}
		}
	}
	/* end of argument reduction */
	z = x3 * x3
	w = z * z
	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z * (_aT1[0] + w*(_aT1[int32(2)]+w*_aT1[int32(4)]))
	s2 = w * (_aT1[int32(1)] + w*_aT1[int32(3)])
	if id < 0 {
		return x3 - x3*(s1+s2)
	}
	z = _atanhi1[id] - (x3*(s1+s2) - _atanlo1[id] - x3)
	if sign != 0 {
		v4 = -z
	} else {
		v4 = z
	}
	return v4
}

// C documentation
//
//	/* atanh(x) = log((1+x)/(1-x))/2 = log1p(2x/(1-x))/2 ~= x + x^3/3 + o(x^5) */
func Xatanh(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, s uint32
	var y float32
	var y1, y2 float64
	var y3, v1 Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _ = e, s, y, y1, y2, y3, v1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	e = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	s = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	/* |x| */
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= uint64(-Int32FromInt32(1)) / Uint64FromInt32(2)
	y3 = *(*float64)(unsafe.Pointer(bp))
	if e < uint32(Int32FromInt32(0x3ff)-Int32FromInt32(1)) {
		if e < uint32(Int32FromInt32(0x3ff)-Int32FromInt32(32)) {
			/* handle underflow */
			if e == uint32(0) {
				if uint64(4) == uint64(4) {
					y = float32(y3)
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(float32(y3))
					} else {
						y2 = float64(float32(y3))
					}
				}
			}
		} else {
			/* |x| < 0.5, up to 1.7ulp error */
			y3 = float64(0.5) * Xlog1p(tls, Float64FromInt32(2)*y3+Float64FromInt32(2)*y3*y3/(Float64FromInt32(1)-y3))
		}
	} else {
		/* avoid overflow */
		y3 = float64(0.5) * Xlog1p(tls, Float64FromInt32(2)*(y3/(Float64FromInt32(1)-y3)))
	}
	if s != 0 {
		v1 = -y3
	} else {
		v1 = y3
	}
	return v1
}

// C documentation
//
//	/* atanh(x) = log((1+x)/(1-x))/2 = log1p(2x/(1-x))/2 ~= x + x^3/3 + o(x^5) */
func Xatanhf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var s uint32
	var y float32
	var y1, y2 float64
	var y3, v1 Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _ = s, y, y1, y2, y3, v1
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	s = *(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31)
	/* |x| */
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x7fffffff)
	y3 = *(*float32)(unsafe.Pointer(bp))
	if *(*Tuint32_t)(unsafe.Pointer(bp)) < uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(1)<<Int32FromInt32(23)) {
		if *(*Tuint32_t)(unsafe.Pointer(bp)) < uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(32)<<Int32FromInt32(23)) {
			/* handle underflow */
			if *(*Tuint32_t)(unsafe.Pointer(bp)) < uint32(Int32FromInt32(1)<<Int32FromInt32(23)) {
				if uint64(4) == uint64(4) {
					y = y3 * y3
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(y3 * y3)
					} else {
						y2 = float64(y3 * y3)
					}
				}
			}
		} else {
			/* |x| < 0.5, up to 1.7ulp error */
			y3 = Float32FromFloat32(0.5) * Xlog1pf(tls, Float32FromInt32(2)*y3+Float32FromInt32(2)*y3*y3/(Float32FromInt32(1)-y3))
		}
	} else {
		/* avoid overflow */
		y3 = Float32FromFloat32(0.5) * Xlog1pf(tls, Float32FromInt32(2)*(y3/(Float32FromInt32(1)-y3)))
	}
	if s != 0 {
		v1 = -y3
	} else {
		v1 = y3
	}
	return v1
}

func Xatanhl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xatanh(tls, x)
}

func Xatanl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xatan(tls, x)
}

var _B1 = uint32(715094163) /* B1 = (1023-1023/3-0.03306235651)*2**20 */
var _B2 = uint32(696219795) /* B2 = (1023-1023/3-54/3-0.03306235651)*2**20 */

// C documentation
//
//	/* |1/cbrt(x) - p(x)| < 2**-23.5 (~[-7.93e-8, 7.929e-8]). */

var _P0 = float64(1.87595182427177)               /* 0x3ffe03e6, 0x0f61e692 */
var _P1 = -Float64FromFloat64(1.8849797954337717) /* 0xbffe28e0, 0x92f02420 */
var _P2 = float64(1.6214297201053545)             /* 0x3ff9f160, 0x4a49d6c2 */
var _P3 = -Float64FromFloat64(0.758397934778766)  /* 0xbfe844cb, 0xbee751d9 */
var _P4 = float64(0.14599619288661245)            /* 0x3fc2b000, 0xd4e4edd7 */

func Xcbrt(tls *TLS, x float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var hx Tuint32_t
	var r, s, t, w Tdouble_t
	var p1 uintptr
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _ = hx, r, s, t, w, p1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	if hx >= uint32(0x7ff00000) { /* cbrt(NaN,INF) is itself */
		return x + x
	}
	/*
	 * Rough cbrt to 5 bits:
	 *    cbrt(2**e*(1+m) ~= 2**(e/3)*(1+(e%3+m)/3)
	 * where e is integral and >= 0, m is real and in [0, 1), and "/" and
	 * "%" are integer division and modulus with rounding towards minus
	 * infinity.  The RHS is always >= the LHS and has a maximum relative
	 * error of about 1 in 16.  Adding a bias of -0.03306235651 to the
	 * (e%3+m)/3 term reduces the error to about 1 in 32. With the IEEE
	 * floating point representation, for finite positive normal values,
	 * ordinary integer divison of the value in bits magically gives
	 * almost exactly the RHS of the above provided we first subtract the
	 * exponent bias (1023 for doubles) and later add it back.  We do the
	 * subtraction virtually to keep e >= 0 so that ordinary integer
	 * division rounds towards minus infinity; this is also efficient.
	 */
	if hx < uint32(0x00100000) { /* zero or subnormal? */
		*(*float64)(unsafe.Pointer(bp)) = x * float64(1.8014398509481984e+16)
		hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
		if hx == uint32(0) {
			return x
		} /* cbrt(0) is itself */
		hx = hx/uint32(3) + _B2
	} else {
		hx = hx/uint32(3) + _B1
	}
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (Uint64FromUint64(1) << Int32FromInt32(63))
	*(*Tuint64_t)(unsafe.Pointer(bp)) |= uint64(hx) << int32(32)
	t = *(*float64)(unsafe.Pointer(bp))
	/*
	 * New cbrt to 23 bits:
	 *    cbrt(x) = t*cbrt(x/t**3) ~= t*P(t**3/x)
	 * where P(r) is a polynomial of degree 4 that approximates 1/cbrt(r)
	 * to within 2**-23.5 when |r - 1| < 1/10.  The rough approximation
	 * has produced t such than |t/cbrt(x) - 1| ~< 1/32, and cubing this
	 * gives us bounds for r = t**3/x.
	 *
	 * Try to optimize for parallel evaluation as in __tanf.c.
	 */
	r = t * t * (t / x)
	t = t * (_P0 + r*(_P1+r*_P2) + r*r*r*(_P3+r*_P4))
	/*
	 * Round t away from zero to 23 bits (sloppily except for ensuring that
	 * the result is larger in magnitude than cbrt(x) but not much more than
	 * 2 23-bit ulps larger).  With rounding towards zero, the error bound
	 * would be ~5/6 instead of ~4/6.  With a maximum error of 2 23-bit ulps
	 * in the rounded t, the infinite-precision error in the Newton
	 * approximation barely affects third digit in the final error
	 * 0.667; the error in the rounded t can be up to about 3 23-bit ulps
	 * before the final error is larger than 0.667 ulps.
	 */
	*(*float64)(unsafe.Pointer(bp)) = t
	*(*Tuint64_t)(unsafe.Pointer(bp)) = (*(*Tuint64_t)(unsafe.Pointer(bp)) + Uint64FromUint32(0x80000000)) & uint64(0xffffffffc0000000)
	t = *(*float64)(unsafe.Pointer(bp))
	/* one step Newton iteration to 53 bits with error < 0.667 ulps */
	s = t * t             /* t*t is exact */
	r = x / s             /* error <= 0.5 ulps; |r| < |t| */
	w = t + t             /* t+t is exact */
	r = (r - t) / (w + r) /* r-t is exact; w+r ~= 3*t */
	t = t + t*r           /* error <= 0.5 + 0.5/3 + epsilon */
	return t
}

var _B11 = uint32(709958130) /* B1 = (127-127.0/3-0.03306235651)*2**23 */
var _B21 = uint32(642849266) /* B2 = (127-127.0/3-24/3-0.03306235651)*2**23 */

func Xcbrtf(tls *TLS, x float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var T, r Tdouble_t
	var hx Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _ = T, hx, r
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	hx = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	if hx >= uint32(0x7f800000) { /* cbrt(NaN,INF) is itself */
		return x + x
	}
	/* rough cbrt to 5 bits */
	if hx < uint32(0x00800000) { /* zero or subnormal? */
		if hx == uint32(0) {
			return x
		} /* cbrt(+-0) is itself */
		*(*float32)(unsafe.Pointer(bp)) = x * Float32FromFloat32(1.6777216e+07)
		hx = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
		hx = hx/uint32(3) + _B21
	} else {
		hx = hx/uint32(3) + _B11
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x80000000)
	*(*Tuint32_t)(unsafe.Pointer(bp)) |= hx
	/*
	 * First step Newton iteration (solving t*t-x/t == 0) to 16 bits.  In
	 * double precision so that its terms can be arranged for efficiency
	 * without causing overflow or underflow.
	 */
	T = float64(*(*float32)(unsafe.Pointer(bp)))
	r = T * T * T
	T = T * (float64(x) + float64(x) + r) / (float64(x) + r + r)
	/*
	 * Second step Newton iteration to 47 bits.  In double precision for
	 * efficiency and accuracy.
	 */
	r = T * T * T
	T = T * (float64(x) + float64(x) + r) / (float64(x) + r + r)
	/* rounding to 24 bits is perfect in round-to-nearest mode */
	return float32(T)
}

func Xcbrtl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcbrt(tls, x)
}

const DBL_EPSILON5 = 2.220446049250313e-16

var _toint2 = Float64FromInt32(1) / Float64FromFloat64(2.220446049250313e-16)

func Xceil(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var y float32
	var y1, y2, v1 float64
	var y3 Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _ = e, y, y1, y2, y3, v1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if e >= Int32FromInt32(0x3ff)+Int32FromInt32(52) || x3 == Float64FromInt32(0) {
		return x3
	}
	/* y = int(x) - x, where int(x) is an integer neighbor of x */
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		y3 = x3 - _toint2 + _toint2 - x3
	} else {
		y3 = x3 + _toint2 - _toint2 - x3
	}
	/* special case because of non-nearest rounding modes */
	if e <= Int32FromInt32(0x3ff)-Int32FromInt32(1) {
		if uint64(8) == uint64(4) {
			y = float32(y3)
		} else {
			if uint64(8) == uint64(8) {
				y1 = y3
			} else {
				y2 = y3
			}
		}
		if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
			v1 = -Float64FromFloat64(0)
		} else {
			v1 = Float64FromInt32(1)
		}
		return v1
	}
	if y3 < Float64FromInt32(0) {
		return x3 + y3 + Float64FromInt32(1)
	}
	return x3 + y3
}

const DBL_EPSILON6 = 0

func Xceilf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var m Tuint32_t
	var y float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _ = e, m, y, y1, y2
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp))>>Int32FromInt32(23)&Uint32FromInt32(0xff)) - int32(0x7f)
	if e >= int32(23) {
		return x3
	}
	if e >= 0 {
		m = uint32(int32(0x007fffff) >> e)
		if *(*Tuint32_t)(unsafe.Pointer(bp))&m == uint32(0) {
			return x3
		}
		if uint64(4) == uint64(4) {
			y = x3 + Float32FromFloat32(1.329227995784916e+36)
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
			} else {
				y2 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
			}
		}
		if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) == uint32(0) {
			*(*Tuint32_t)(unsafe.Pointer(bp)) += m
		}
		*(*Tuint32_t)(unsafe.Pointer(bp)) &= ^m
	} else {
		if uint64(4) == uint64(4) {
			y = x3 + Float32FromFloat32(1.329227995784916e+36)
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
			} else {
				y2 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
			}
		}
		if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
			*(*float32)(unsafe.Pointer(bp)) = float32(-Float64FromFloat64(0))
		} else {
			if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(1) != 0 {
				*(*float32)(unsafe.Pointer(bp)) = float32(1)
			}
		}
	}
	return *(*float32)(unsafe.Pointer(bp))
}

func Xceill(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xceil(tls, x)
}

func Xcopysign(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var p1, p2 uintptr
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _ = p1, p2
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (-Uint64FromUint64(1) / Uint64FromInt32(2))
	p2 = bp
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) | *(*Tuint64_t)(unsafe.Pointer(bp + 8))&(Uint64FromUint64(1)<<Int32FromInt32(63))
	return *(*float64)(unsafe.Pointer(bp))
}

func Xcopysignf(tls *TLS, x float32, y float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 4)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x7fffffff)
	*(*Tuint32_t)(unsafe.Pointer(bp)) |= *(*Tuint32_t)(unsafe.Pointer(bp + 4)) & uint32(0x80000000)
	return *(*float32)(unsafe.Pointer(bp))
}

func Xcopysignl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcopysign(tls, x, y)
}

func Xcos(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ix Tuint32_t
	var n uint32
	var y float32
	var y1, y2 float64
	var _ /* y at bp+0 */ [2]float64
	_, _, _, _, _ = ix, n, y, y1, y2
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x3)) >> int32(32))
	ix &= uint32(0x7fffffff)
	/* |x| ~< pi/4 */
	if ix <= uint32(0x3fe921fb) {
		if ix < uint32(0x3e46a09e) { /* |x| < 2**-27 * sqrt(2) */
			/* raise inexact if x!=0 */
			if uint64(8) == uint64(4) {
				y = float32(x3 + Float64FromFloat32(1.329227995784916e+36))
			} else {
				if uint64(8) == uint64(8) {
					y1 = x3 + Float64FromFloat32(1.329227995784916e+36)
				} else {
					y2 = x3 + Float64FromFloat32(1.329227995784916e+36)
				}
			}
			return float64(1)
		}
		return X__cos(tls, x3, Float64FromInt32(0))
	}
	/* cos(Inf or NaN) is NaN */
	if ix >= uint32(0x7ff00000) {
		return x3 - x3
	}
	/* argument reduction */
	n = uint32(X__rem_pio2(tls, x3, bp))
	switch n & Uint32FromInt32(3) {
	case uint32(0):
		return X__cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	case uint32(1):
		return -X__sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	case uint32(2):
		return -X__cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	default:
		return X__sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	}
	return r
}

const M_PI_23 = 1.5707963267948966

// C documentation
//
//	/* Small multiples of pi/2 rounded to double precision. */

var _c1pio2 = Float64FromInt32(1) * Float64FromFloat64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _c2pio2 = Float64FromInt32(2) * Float64FromFloat64(1.5707963267948966) /* 0x400921FB, 0x54442D18 */
var _c3pio2 = Float64FromInt32(3) * Float64FromFloat64(1.5707963267948966) /* 0x4012D97C, 0x7F3321D2 */
var _c4pio2 = Float64FromInt32(4) * Float64FromFloat64(1.5707963267948966) /* 0x401921FB, 0x54442D18 */

func Xcosf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ix Tuint32_t
	var n, sign uint32
	var y float32
	var y1, y2, v1, v2 float64
	var _ /* y at bp+0 */ float64
	_, _, _, _, _, _, _, _ = ix, n, sign, y, y1, y2, v1, v2
	ix = *(*Tuint32_t)(unsafe.Pointer(&x3))
	sign = ix >> int32(31)
	ix &= uint32(0x7fffffff)
	if ix <= uint32(0x3f490fda) { /* |x| ~<= pi/4 */
		if ix < uint32(0x39800000) { /* |x| < 2**-12 */
			/* raise inexact if x != 0 */
			if uint64(4) == uint64(4) {
				y = x3 + Float32FromFloat32(1.329227995784916e+36)
			} else {
				if uint64(4) == uint64(8) {
					y1 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
				} else {
					y2 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
				}
			}
			return Float32FromFloat32(1)
		}
		return X__cosdf(tls, float64(x3))
	}
	if ix <= uint32(0x407b53d1) { /* |x| ~<= 5*pi/4 */
		if ix > uint32(0x4016cbe3) { /* |x|  ~> 3*pi/4 */
			if sign != 0 {
				v1 = float64(x3) + _c2pio2
			} else {
				v1 = float64(x3) - _c2pio2
			}
			return -X__cosdf(tls, v1)
		} else {
			if sign != 0 {
				return X__sindf(tls, float64(x3)+_c1pio2)
			} else {
				return X__sindf(tls, _c1pio2-float64(x3))
			}
		}
	}
	if ix <= uint32(0x40e231d5) { /* |x| ~<= 9*pi/4 */
		if ix > uint32(0x40afeddf) { /* |x| ~> 7*pi/4 */
			if sign != 0 {
				v2 = float64(x3) + _c4pio2
			} else {
				v2 = float64(x3) - _c4pio2
			}
			return X__cosdf(tls, v2)
		} else {
			if sign != 0 {
				return X__sindf(tls, float64(-x3)-_c3pio2)
			} else {
				return X__sindf(tls, float64(x3)-_c3pio2)
			}
		}
	}
	/* cos(Inf or NaN) is NaN */
	if ix >= uint32(0x7f800000) {
		return x3 - x3
	}
	/* general argument reduction needed */
	n = uint32(X__rem_pio2f(tls, x3, bp))
	switch n & Uint32FromInt32(3) {
	case uint32(0):
		return X__cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	case uint32(1):
		return X__sindf(tls, -*(*float64)(unsafe.Pointer(bp)))
	case uint32(2):
		return -X__cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	default:
		return X__sindf(tls, *(*float64)(unsafe.Pointer(bp)))
	}
	return r
}

const M_PI_24 = 0

// C documentation
//
//	/* cosh(x) = (exp(x) + 1/exp(x))/2
//	 *         = 1 + 0.5*(exp(x)-1)*(exp(x)-1)/exp(x)
//	 *         = 1 + x*x/2 + o(x^4)
//	 */
func Xcosh(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var t, y1, y2 float64
	var w Tuint32_t
	var y float32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _ = t, w, y, y1, y2
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	/* |x| */
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= uint64(-Int32FromInt32(1)) / Uint64FromInt32(2)
	x3 = *(*float64)(unsafe.Pointer(bp))
	w = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	/* |x| < log(2) */
	if w < uint32(0x3fe62e42) {
		if w < uint32(Int32FromInt32(0x3ff00000)-Int32FromInt32(26)<<Int32FromInt32(20)) {
			/* raise inexact if x!=0 */
			if uint64(8) == uint64(4) {
				y = float32(x3 + Float64FromFloat32(1.329227995784916e+36))
			} else {
				if uint64(8) == uint64(8) {
					y1 = x3 + Float64FromFloat32(1.329227995784916e+36)
				} else {
					y2 = x3 + Float64FromFloat32(1.329227995784916e+36)
				}
			}
			return Float64FromInt32(1)
		}
		t = Xexpm1(tls, x3)
		return Float64FromInt32(1) + t*t/(Float64FromInt32(2)*(Float64FromInt32(1)+t))
	}
	/* |x| < log(DBL_MAX) */
	if w < uint32(0x40862e42) {
		t = Xexp(tls, x3)
		/* note: if x>log(0x1p26) then the 1/t is not needed */
		return float64(0.5) * (t + Float64FromInt32(1)/t)
	}
	/* |x| > log(DBL_MAX) or nan */
	/* note: the result is stored to handle overflow */
	t = X__expo2(tls, x3, float64(1))
	return t
}

func Xcoshf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var t, y float32
	var w Tuint32_t
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _ = t, w, y, y1, y2
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	/* |x| */
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x7fffffff)
	x3 = *(*float32)(unsafe.Pointer(bp))
	w = *(*Tuint32_t)(unsafe.Pointer(bp))
	/* |x| < log(2) */
	if w < uint32(0x3f317217) {
		if w < uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(12)<<Int32FromInt32(23)) {
			if uint64(4) == uint64(4) {
				y = x3 + Float32FromFloat32(1.329227995784916e+36)
			} else {
				if uint64(4) == uint64(8) {
					y1 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
				} else {
					y2 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
				}
			}
			return Float32FromInt32(1)
		}
		t = Xexpm1f(tls, x3)
		return Float32FromInt32(1) + t*t/(Float32FromInt32(2)*(Float32FromInt32(1)+t))
	}
	/* |x| < log(FLT_MAX) */
	if w < uint32(0x42b17217) {
		t = Xexpf(tls, x3)
		return Float32FromFloat32(0.5) * (t + Float32FromInt32(1)/t)
	}
	/* |x| > log(FLT_MAX) or nan */
	t = X__expo2f(tls, x3, Float32FromFloat32(1))
	return t
}

func Xcoshl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcosh(tls, x)
}

func Xcosl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcos(tls, x)
}

var _erx = float64(0.8450629115104675) /* 0x3FEB0AC1, 0x60000000 */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
var _efx8 = float64(1.0270333367641007)                /* 0x3FF06EBA, 0x8214DB69 */
var _pp0 = float64(0.12837916709551256)                /* 0x3FC06EBA, 0x8214DB68 */
var _pp1 = -Float64FromFloat64(0.3250421072470015)     /* 0xBFD4CD7D, 0x691CB913 */
var _pp2 = -Float64FromFloat64(0.02848174957559851)    /* 0xBF9D2A51, 0xDBD7194F */
var _pp3 = -Float64FromFloat64(0.005770270296489442)   /* 0xBF77A291, 0x236668E4 */
var _pp4 = -Float64FromFloat64(2.3763016656650163e-05) /* 0xBEF8EAD6, 0x120016AC */
var _qq1 = float64(0.39791722395915535)                /* 0x3FD97779, 0xCDDADC09 */
var _qq2 = float64(0.0650222499887673)                 /* 0x3FB0A54C, 0x5536CEBA */
var _qq3 = float64(0.005081306281875766)               /* 0x3F74D022, 0xC4D36B0F */
var _qq4 = float64(0.00013249473800432164)             /* 0x3F215DC9, 0x221C1A10 */
var _qq5 = -Float64FromFloat64(3.960228278775368e-06)  /* 0xBED09C43, 0x42A26120 */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
var _pa0 = -Float64FromFloat64(0.0023621185607526594) /* 0xBF6359B8, 0xBEF77538 */
var _pa1 = float64(0.41485611868374833)               /* 0x3FDA8D00, 0xAD92B34D */
var _pa2 = -Float64FromFloat64(0.3722078760357013)    /* 0xBFD7D240, 0xFBB8C3F1 */
var _pa3 = float64(0.31834661990116175)               /* 0x3FD45FCA, 0x805120E4 */
var _pa4 = -Float64FromFloat64(0.11089469428239668)   /* 0xBFBC6398, 0x3D3E28EC */
var _pa5 = float64(0.035478304325618236)              /* 0x3FA22A36, 0x599795EB */
var _pa6 = -Float64FromFloat64(0.002166375594868791)  /* 0xBF61BF38, 0x0A96073F */
var _qa1 = float64(0.10642088040084423)               /* 0x3FBB3E66, 0x18EEE323 */
var _qa2 = float64(0.540397917702171)                 /* 0x3FE14AF0, 0x92EB6F33 */
var _qa3 = float64(0.07182865441419627)               /* 0x3FB2635C, 0xD99FE9A7 */
var _qa4 = float64(0.12617121980876164)               /* 0x3FC02660, 0xE763351F */
var _qa5 = float64(0.01363708391202905)               /* 0x3F8BEDC2, 0x6B51DD1C */
var _qa6 = float64(0.011984499846799107)              /* 0x3F888B54, 0x5735151D */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
var _ra0 = -Float64FromFloat64(0.009864944034847148) /* 0xBF843412, 0x600D6435 */
var _ra1 = -Float64FromFloat64(0.6938585727071818)   /* 0xBFE63416, 0xE4BA7360 */
var _ra2 = -Float64FromFloat64(10.558626225323291)   /* 0xC0251E04, 0x41B0E726 */
var _ra3 = -Float64FromFloat64(62.375332450326006)   /* 0xC04F300A, 0xE4CBA38D */
var _ra4 = -Float64FromFloat64(162.39666946257347)   /* 0xC0644CB1, 0x84282266 */
var _ra5 = -Float64FromFloat64(184.60509290671104)   /* 0xC067135C, 0xEBCCABB2 */
var _ra6 = -Float64FromFloat64(81.2874355063066)     /* 0xC0545265, 0x57E4D2F2 */
var _ra7 = -Float64FromFloat64(9.814329344169145)    /* 0xC023A0EF, 0xC69AC25C */
var _sa1 = float64(19.651271667439257)               /* 0x4033A6B9, 0xBD707687 */
var _sa2 = float64(137.65775414351904)               /* 0x4061350C, 0x526AE721 */
var _sa3 = float64(434.56587747522923)               /* 0x407B290D, 0xD58A1A71 */
var _sa4 = float64(645.3872717332679)                /* 0x40842B19, 0x21EC2868 */
var _sa5 = float64(429.00814002756783)               /* 0x407AD021, 0x57700314 */
var _sa6 = float64(108.63500554177944)               /* 0x405B28A3, 0xEE48AE2C */
var _sa7 = float64(6.570249770319282)                /* 0x401A47EF, 0x8E484A93 */
var _sa8 = -Float64FromFloat64(0.0604244152148581)   /* 0xBFAEEFF2, 0xEE749A62 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
var _rb0 = -Float64FromFloat64(0.0098649429247001) /* 0xBF843412, 0x39E86F4A */
var _rb1 = -Float64FromFloat64(0.799283237680523)  /* 0xBFE993BA, 0x70C285DE */
var _rb2 = -Float64FromFloat64(17.757954917754752) /* 0xC031C209, 0x555F995A */
var _rb3 = -Float64FromFloat64(160.63638485582192) /* 0xC064145D, 0x43C5ED98 */
var _rb4 = -Float64FromFloat64(637.5664433683896)  /* 0xC083EC88, 0x1375F228 */
var _rb5 = -Float64FromFloat64(1025.0951316110772) /* 0xC0900461, 0x6A2E5992 */
var _rb6 = -Float64FromFloat64(483.5191916086514)  /* 0xC07E384E, 0x9BDC383F */
var _sb1 = float64(30.33806074348246)              /* 0x403E568B, 0x261D5190 */
var _sb2 = float64(325.7925129965739)              /* 0x40745CAE, 0x221B9F0A */
var _sb3 = float64(1536.729586084437)              /* 0x409802EB, 0x189D5118 */
var _sb4 = float64(3199.8582195085955)             /* 0x40A8FFB7, 0x688C246A */
var _sb5 = float64(2553.0504064331644)             /* 0x40A3F219, 0xCEDF3BE6 */
var _sb6 = float64(474.52854120695537)             /* 0x407DA874, 0xE79FE763 */
var _sb7 = -Float64FromFloat64(22.44095244658582)  /* 0xC03670E2, 0x42712D62 */

func _erfc1(tls *TLS, x float64) (r float64) {
	var P, Q, s Tdouble_t
	_, _, _ = P, Q, s
	s = Xfabs(tls, x) - Float64FromInt32(1)
	P = _pa0 + s*(_pa1+s*(_pa2+s*(_pa3+s*(_pa4+s*(_pa5+s*_pa6)))))
	Q = Float64FromInt32(1) + s*(_qa1+s*(_qa2+s*(_qa3+s*(_qa4+s*(_qa5+s*_qa6)))))
	return Float64FromInt32(1) - _erx - P/Q
}

func _erfc2(tls *TLS, ix Tuint32_t, x float64) (r float64) {
	var R, S, s Tdouble_t
	var z float64
	var v1 Tuint64_t
	_, _, _, _, _ = R, S, s, z, v1
	if ix < uint32(0x3ff40000) { /* |x| < 1.25 */
		return _erfc1(tls, x)
	}
	x = Xfabs(tls, x)
	s = Float64FromInt32(1) / (x * x)
	if ix < uint32(0x4006db6d) { /* |x| < 1/.35 ~ 2.85714 */
		R = _ra0 + s*(_ra1+s*(_ra2+s*(_ra3+s*(_ra4+s*(_ra5+s*(_ra6+s*_ra7))))))
		S = float64(1) + s*(_sa1+s*(_sa2+s*(_sa3+s*(_sa4+s*(_sa5+s*(_sa6+s*(_sa7+s*_sa8)))))))
	} else { /* |x| > 1/.35 */
		R = _rb0 + s*(_rb1+s*(_rb2+s*(_rb3+s*(_rb4+s*(_rb5+s*_rb6)))))
		S = float64(1) + s*(_sb1+s*(_sb2+s*(_sb3+s*(_sb4+s*(_sb5+s*(_sb6+s*_sb7))))))
	}
	z = x
	v1 = *(*Tuint64_t)(unsafe.Pointer(&z))>>Int32FromInt32(32)<<Int32FromInt32(32) | uint64(uint32(Int32FromInt32(0)))
	z = *(*float64)(unsafe.Pointer(&v1))
	return Xexp(tls, -z*z-float64(0.5625)) * Xexp(tls, (z-x)*(z+x)+R/S) / x
}

func Xerf(tls *TLS, x float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ix Tuint32_t
	var r, s, y, z, v1 float64
	var sign int32
	_, _, _, _, _, _, _ = ix, r, s, sign, y, z, v1
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x7ff00000) {
		/* erf(nan)=nan, erf(+-inf)=+-1 */
		return float64(int32(1)-int32(2)*sign) + Float64FromInt32(1)/x
	}
	if ix < uint32(0x3feb0000) { /* |x| < 0.84375 */
		if ix < uint32(0x3e300000) { /* |x| < 2**-28 */
			/* avoid underflow */
			return float64(0.125) * (Float64FromInt32(8)*x + _efx8*x)
		}
		z = x * x
		r = _pp0 + z*(_pp1+z*(_pp2+z*(_pp3+z*_pp4)))
		s = float64(1) + z*(_qq1+z*(_qq2+z*(_qq3+z*(_qq4+z*_qq5))))
		y = r / s
		return x + x*y
	}
	if ix < uint32(0x40180000) { /* 0.84375 <= |x| < 6 */
		y = Float64FromInt32(1) - _erfc2(tls, ix, x)
	} else {
		y = Float64FromInt32(1) - Float64FromFloat64(2.2250738585072014e-308)
	}
	if sign != 0 {
		v1 = -y
	} else {
		v1 = y
	}
	return v1
}

func Xerfc(tls *TLS, x float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ix Tuint32_t
	var r, s, y, z, v1, v2 float64
	var sign int32
	_, _, _, _, _, _, _, _ = ix, r, s, sign, y, z, v1, v2
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x7ff00000) {
		/* erfc(nan)=nan, erfc(+-inf)=0,2 */
		return float64(int32(2)*sign) + Float64FromInt32(1)/x
	}
	if ix < uint32(0x3feb0000) { /* |x| < 0.84375 */
		if ix < uint32(0x3c700000) { /* |x| < 2**-56 */
			return float64(1) - x
		}
		z = x * x
		r = _pp0 + z*(_pp1+z*(_pp2+z*(_pp3+z*_pp4)))
		s = float64(1) + z*(_qq1+z*(_qq2+z*(_qq3+z*(_qq4+z*_qq5))))
		y = r / s
		if sign != 0 || ix < uint32(0x3fd00000) { /* x < 1/4 */
			return float64(1) - (x + x*y)
		}
		return float64(0.5) - (x - float64(0.5) + x*y)
	}
	if ix < uint32(0x403c0000) { /* 0.84375 <= |x| < 28 */
		if sign != 0 {
			v1 = Float64FromInt32(2) - _erfc2(tls, ix, x)
		} else {
			v1 = _erfc2(tls, ix, x)
		}
		return v1
	}
	if sign != 0 {
		v2 = Float64FromInt32(2) - Float64FromFloat64(2.2250738585072014e-308)
	} else {
		v2 = Float64FromFloat64(2.2250738585072014e-308) * Float64FromFloat64(2.2250738585072014e-308)
	}
	return v2
}

var _erx1 = float32(0.84506291151) /* 0x3f58560b */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
var _efx81 = float32(1.027033329)                          /* 0x3f8375d4 */
var _pp01 = float32(0.12837916613)                         /* 0x3e0375d4 */
var _pp11 = float32(-Float64FromFloat64(0.32504209876))    /* 0xbea66beb */
var _pp21 = float32(-Float64FromFloat64(0.028481749818))   /* 0xbce9528f */
var _pp31 = float32(-Float64FromFloat64(0.005770270247))   /* 0xbbbd1489 */
var _pp41 = float32(-Float64FromFloat64(2.3763017452e-05)) /* 0xb7c756b1 */
var _qq11 = float32(0.39791721106)                         /* 0x3ecbbbce */
var _qq21 = float32(0.0650222525)                          /* 0x3d852a63 */
var _qq31 = float32(0.0050813062117)                       /* 0x3ba68116 */
var _qq41 = float32(0.00013249473704)                      /* 0x390aee49 */
var _qq51 = float32(-Float64FromFloat64(3.9602282413e-06)) /* 0xb684e21a */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
var _pa01 = float32(-Float64FromFloat64(0.0023621185683)) /* 0xbb1acdc6 */
var _pa11 = float32(0.41485610604)                        /* 0x3ed46805 */
var _pa21 = float32(-Float64FromFloat64(0.37220788002))   /* 0xbebe9208 */
var _pa31 = float32(0.31834661961)                        /* 0x3ea2fe54 */
var _pa41 = float32(-Float64FromFloat64(0.11089469492))   /* 0xbde31cc2 */
var _pa51 = float32(0.035478305072)                       /* 0x3d1151b3 */
var _pa61 = float32(-Float64FromFloat64(0.0021663755178)) /* 0xbb0df9c0 */
var _qa11 = float32(0.10642088205)                        /* 0x3dd9f331 */
var _qa21 = float32(0.54039794207)                        /* 0x3f0a5785 */
var _qa31 = float32(0.071828655899)                       /* 0x3d931ae7 */
var _qa41 = float32(0.12617121637)                        /* 0x3e013307 */
var _qa51 = float32(0.013637083583)                       /* 0x3c5f6e13 */
var _qa61 = float32(0.011984500103)                       /* 0x3c445aa3 */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
var _ra01 = float32(-Float64FromFloat64(0.0098649440333)) /* 0xbc21a093 */
var _ra11 = float32(-Float64FromFloat64(0.6938585639))    /* 0xbf31a0b7 */
var _ra21 = float32(-Float64FromFloat64(10.558626175))    /* 0xc128f022 */
var _ra31 = float32(-Float64FromFloat64(62.375331879))    /* 0xc2798057 */
var _ra41 = float32(-Float64FromFloat64(162.39666748))    /* 0xc322658c */
var _ra51 = float32(-Float64FromFloat64(184.60508728))    /* 0xc3389ae7 */
var _ra61 = float32(-Float64FromFloat64(81.287437439))    /* 0xc2a2932b */
var _ra71 = float32(-Float64FromFloat64(9.8143291473))    /* 0xc11d077e */
var _sa11 = float32(19.65127182)                          /* 0x419d35ce */
var _sa21 = float32(137.65776062)                         /* 0x4309a863 */
var _sa31 = float32(434.56588745)                         /* 0x43d9486f */
var _sa41 = float32(645.38726807)                         /* 0x442158c9 */
var _sa51 = float32(429.00814819)                         /* 0x43d6810b */
var _sa61 = float32(108.63500214)                         /* 0x42d9451f */
var _sa71 = float32(6.5702495575)                         /* 0x40d23f7c */
var _sa81 = float32(-Float64FromFloat64(0.060424413532))  /* 0xbd777f97 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
var _rb01 = float32(-Float64FromFloat64(0.009864943102)) /* 0xbc21a092 */
var _rb11 = float32(-Float64FromFloat64(0.79928326607))  /* 0xbf4c9dd4 */
var _rb21 = float32(-Float64FromFloat64(17.757955551))   /* 0xc18e104b */
var _rb31 = float32(-Float64FromFloat64(160.63638306))   /* 0xc320a2ea */
var _rb41 = float32(-Float64FromFloat64(637.56646729))   /* 0xc41f6441 */
var _rb51 = float32(-Float64FromFloat64(1025.0950928))   /* 0xc480230b */
var _rb61 = float32(-Float64FromFloat64(483.51919556))   /* 0xc3f1c275 */
var _sb11 = float32(30.338060379)                        /* 0x41f2b459 */
var _sb21 = float32(325.79251099)                        /* 0x43a2e571 */
var _sb31 = float32(1536.7296143)                        /* 0x44c01759 */
var _sb41 = float32(3199.8581543)                        /* 0x4547fdbb */
var _sb51 = float32(2553.050293)                         /* 0x451f90ce */
var _sb61 = float32(474.52853394)                        /* 0x43ed43a7 */
var _sb71 = float32(-Float64FromFloat64(22.440952301))   /* 0xc1b38712 */

func _erfc11(tls *TLS, x float32) (r float32) {
	var P, Q, s Tfloat_t
	_, _, _ = P, Q, s
	s = Xfabsf(tls, x) - Float32FromInt32(1)
	P = _pa01 + s*(_pa11+s*(_pa21+s*(_pa31+s*(_pa41+s*(_pa51+s*_pa61)))))
	Q = Float32FromInt32(1) + s*(_qa11+s*(_qa21+s*(_qa31+s*(_qa41+s*(_qa51+s*_qa61)))))
	return Float32FromInt32(1) - _erx1 - P/Q
}

func _erfc21(tls *TLS, ix Tuint32_t, x float32) (r float32) {
	var R, S, s Tfloat_t
	var z float32
	var v1 Tuint32_t
	_, _, _, _, _ = R, S, s, z, v1
	if ix < uint32(0x3fa00000) { /* |x| < 1.25 */
		return _erfc11(tls, x)
	}
	x = Xfabsf(tls, x)
	s = Float32FromInt32(1) / (x * x)
	if ix < uint32(0x4036db6d) { /* |x| < 1/0.35 */
		R = _ra01 + s*(_ra11+s*(_ra21+s*(_ra31+s*(_ra41+s*(_ra51+s*(_ra61+s*_ra71))))))
		S = Float32FromFloat32(1) + s*(_sa11+s*(_sa21+s*(_sa31+s*(_sa41+s*(_sa51+s*(_sa61+s*(_sa71+s*_sa81)))))))
	} else { /* |x| >= 1/0.35 */
		R = _rb01 + s*(_rb11+s*(_rb21+s*(_rb31+s*(_rb41+s*(_rb51+s*_rb61)))))
		S = Float32FromFloat32(1) + s*(_sb11+s*(_sb21+s*(_sb31+s*(_sb41+s*(_sb51+s*(_sb61+s*_sb71))))))
	}
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	v1 = ix & uint32(0xffffe000)
	z = *(*float32)(unsafe.Pointer(&v1))
	return Xexpf(tls, -z*z-Float32FromFloat32(0.5625)) * Xexpf(tls, (z-x)*(z+x)+R/S) / x
}

func Xerff(tls *TLS, x float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ix Tuint32_t
	var r, s, y, z, v1 float32
	var sign int32
	_, _, _, _, _, _, _ = ix, r, s, sign, y, z, v1
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		/* erf(nan)=nan, erf(+-inf)=+-1 */
		return float32(int32(1)-int32(2)*sign) + Float32FromInt32(1)/x
	}
	if ix < uint32(0x3f580000) { /* |x| < 0.84375 */
		if ix < uint32(0x31800000) { /* |x| < 2**-28 */
			/*avoid underflow */
			return Float32FromFloat32(0.125) * (Float32FromInt32(8)*x + _efx81*x)
		}
		z = x * x
		r = _pp01 + z*(_pp11+z*(_pp21+z*(_pp31+z*_pp41)))
		s = Float32FromInt32(1) + z*(_qq11+z*(_qq21+z*(_qq31+z*(_qq41+z*_qq51))))
		y = r / s
		return x + x*y
	}
	if ix < uint32(0x40c00000) { /* |x| < 6 */
		y = Float32FromInt32(1) - _erfc21(tls, ix, x)
	} else {
		y = Float32FromInt32(1) - Float32FromFloat32(7.52316384526264e-37)
	}
	if sign != 0 {
		v1 = -y
	} else {
		v1 = y
	}
	return v1
}

func Xerfcf(tls *TLS, x float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ix Tuint32_t
	var r, s, y, z, v1, v2 float32
	var sign int32
	_, _, _, _, _, _, _, _ = ix, r, s, sign, y, z, v1, v2
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		/* erfc(nan)=nan, erfc(+-inf)=0,2 */
		return float32(int32(2)*sign) + Float32FromInt32(1)/x
	}
	if ix < uint32(0x3f580000) { /* |x| < 0.84375 */
		if ix < uint32(0x23800000) { /* |x| < 2**-56 */
			return Float32FromFloat32(1) - x
		}
		z = x * x
		r = _pp01 + z*(_pp11+z*(_pp21+z*(_pp31+z*_pp41)))
		s = Float32FromFloat32(1) + z*(_qq11+z*(_qq21+z*(_qq31+z*(_qq41+z*_qq51))))
		y = r / s
		if sign != 0 || ix < uint32(0x3e800000) { /* x < 1/4 */
			return Float32FromFloat32(1) - (x + x*y)
		}
		return Float32FromFloat32(0.5) - (x - Float32FromFloat32(0.5) + x*y)
	}
	if ix < uint32(0x41e00000) { /* |x| < 28 */
		if sign != 0 {
			v1 = Float32FromInt32(2) - _erfc21(tls, ix, x)
		} else {
			v1 = _erfc21(tls, ix, x)
		}
		return v1
	}
	if sign != 0 {
		v2 = Float32FromInt32(2) - Float32FromFloat32(7.52316384526264e-37)
	} else {
		v2 = Float32FromFloat32(7.52316384526264e-37) * Float32FromFloat32(7.52316384526264e-37)
	}
	return v2
}

func Xerfl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xerf(tls, x)
}

func Xerfcl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xerfc(tls, x)
}

const EXP2_POLY_ORDER = 5
const EXP_POLY_ORDER = 5
const EXP_TABLE_BITS = 7
const EXP_USE_TOINT_NARROW = 0
const N = 128

// C documentation
//
//	/* Handle cases that may overflow or underflow when computing the result that
//	   is scale*(1+TMP) without intermediate rounding.  The bit representation of
//	   scale is in SBITS, however it has a computed exponent that may have
//	   overflown into the sign bit so that needs to be adjusted before using it as
//	   a double.  (int32_t)KI is the k used in the argument reduction and exponent
//	   adjustment of scale, positive k here means the result may overflow and
//	   negative k means the result may underflow.  */
func _specialcase(tls *TLS, tmp Tdouble_t, sbits Tuint64_t, ki Tuint64_t) (r float64) {
	var hi, lo, scale, y3 Tdouble_t
	var y, y1, y2, v1, v3, v5, v7 float64
	_, _, _, _, _, _, _, _, _, _, _ = hi, lo, scale, y, y1, y2, y3, v1, v3, v5, v7
	if ki&uint64(0x80000000) == uint64(0) {
		/* k > 0, the exponent of scale might have overflowed by <= 460.  */
		sbits = sbits - Uint64FromUint64(1009)<<Int32FromInt32(52)
		scale = *(*float64)(unsafe.Pointer(&sbits))
		y3 = float64(5.486124068793689e+303) * (scale + scale*tmp)
		y = y3
		v1 = y
		goto _2
	_2:
		return v1
	}
	/* k < 0, need special care in the subnormal range.  */
	sbits = sbits + Uint64FromUint64(1022)<<Int32FromInt32(52)
	scale = *(*float64)(unsafe.Pointer(&sbits))
	y3 = scale + scale*tmp
	if y3 < float64(1) {
		lo = scale - y3 + scale*tmp
		hi = float64(1) + y3
		lo = float64(1) - hi + y3 + lo
		y = hi + lo
		v3 = y
		goto _4
	_4:
		y3 = v3 - float64(1)
		/* Avoid -0.0 with downward rounding.  */
		if Bool(int32(WANT_ROUNDING) != 0) && y3 == float64(0) {
			y3 = float64(0)
		}
		/* The underflow exception needs to be signaled explicitly.  */
		y1 = float64(2.2250738585072014e-308)
		v5 = y1
		goto _6
	_6:
		y2 = v5 * float64(2.2250738585072014e-308)
	}
	y3 = float64(2.2250738585072014e-308) * y3
	y = y3
	v7 = y
	goto _8
_8:
	return v7
}

// C documentation
//
//	/* Top 12 bits of a double (sign and exponent bits).  */
func _top12(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(52))
}

func Xexp(tls *TLS, x1 float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x1=%v, (%v:)", tls, x1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var abstop Tuint32_t
	var idx, ki, sbits, top, v5 Tuint64_t
	var kd, r, r2, scale, tail, tmp, z Tdouble_t
	var y, v1, v2, v4, v6 float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = abstop, idx, kd, ki, r, r2, sbits, scale, tail, tmp, top, y, z, v1, v2, v4, v5, v6
	abstop = _top12(tls, x1) & uint32(0x7ff)
	if abstop-_top12(tls, float64(5.551115123125783e-17)) >= _top12(tls, float64(512))-_top12(tls, float64(5.551115123125783e-17)) {
		if abstop-_top12(tls, float64(5.551115123125783e-17)) >= uint32(0x80000000) {
			/* Avoid spurious underflow for tiny x.  */
			/* Note: 0 is common input.  */
			return float64(1) + x1
		}
		if abstop >= _top12(tls, float64(1024)) {
			v1 = float64(-X__builtin_inff(tls))
			if *(*Tuint64_t)(unsafe.Pointer(&x1)) == *(*Tuint64_t)(unsafe.Pointer(&v1)) {
				return float64(0)
			}
			if abstop >= _top12(tls, float64(X__builtin_inff(tls))) {
				return float64(1) + x1
			}
			if *(*Tuint64_t)(unsafe.Pointer(&x1))>>int32(63) != 0 {
				return X__math_uflow(tls, uint32(0))
			} else {
				return X__math_oflow(tls, uint32(0))
			}
		}
		/* Large x is special cased below.  */
		abstop = uint32(0)
	}
	/* exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].  */
	/* x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].  */
	z = X__exp_data.Finvln2N * x1
	/* z - kd is in [-1, 1] in non-nearest rounding modes.  */
	y = z + X__exp_data.Fshift
	v2 = y
	goto _3
_3:
	kd = v2
	v4 = kd
	ki = *(*Tuint64_t)(unsafe.Pointer(&v4))
	kd -= X__exp_data.Fshift
	r = x1 + kd*X__exp_data.Fnegln2hiN + kd*X__exp_data.Fnegln2loN
	/* 2^(k/N) ~= scale * (1 + tail).  */
	idx = uint64(2) * (ki % uint64(Int32FromInt32(1)<<Int32FromInt32(EXP_TABLE_BITS)))
	top = ki << (Int32FromInt32(52) - Int32FromInt32(EXP_TABLE_BITS))
	v5 = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 112 + uintptr(idx)*8))
	tail = *(*float64)(unsafe.Pointer(&v5))
	/* This is only a valid scale when -1023*N < k < 1024*N.  */
	sbits = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 112 + uintptr(idx+uint64(1))*8)) + top
	/* exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).  */
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	r2 = r * r
	/* Without fma the worst case error is 0.25/N ulp larger.  */
	/* Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.  */
	tmp = tail + r + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 32 + uintptr(Int32FromInt32(5)-Int32FromInt32(EXP_POLY_ORDER))*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 32 + uintptr(Int32FromInt32(6)-Int32FromInt32(EXP_POLY_ORDER))*8))) + r2*r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 32 + uintptr(Int32FromInt32(7)-Int32FromInt32(EXP_POLY_ORDER))*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 32 + uintptr(Int32FromInt32(8)-Int32FromInt32(EXP_POLY_ORDER))*8)))
	if abstop == uint32(0) {
		return _specialcase(tls, tmp, sbits, ki)
	}
	scale = *(*float64)(unsafe.Pointer(&sbits))
	/* Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
	   is no spurious underflow here even without fma.  */
	y = scale + scale*tmp
	v6 = y
	goto _7
_7:
	return v6
}

const HUGE = 0

func Xexp10(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var y float64
	var _ /* n at bp+0 */ float64
	var _ /* u at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_ = y
	y = Xmodf(tls, x, bp)
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 8)) = *(*float64)(unsafe.Pointer(bp))
	/* fabs(n) < 16 without raising invalid on nan */
	if *(*Tuint64_t)(unsafe.Pointer(bp + 8))>>int32(52)&uint64(0x7ff) < uint64(Int32FromInt32(0x3ff)+Int32FromInt32(4)) {
		if !(y != 0) {
			return _p10[int32(*(*float64)(unsafe.Pointer(bp)))+int32(15)]
		}
		y = Xexp2(tls, float64(3.321928094887362)*y)
		return y * _p10[int32(*(*float64)(unsafe.Pointer(bp)))+int32(15)]
	}
	return Xpow(tls, float64(10), x)
}

var _p10 = [31]float64{
	0:  float64(1e-15),
	1:  float64(1e-14),
	2:  float64(1e-13),
	3:  float64(1e-12),
	4:  float64(1e-11),
	5:  float64(1e-10),
	6:  float64(1e-09),
	7:  float64(1e-08),
	8:  float64(1e-07),
	9:  float64(1e-06),
	10: float64(1e-05),
	11: float64(0.0001),
	12: float64(0.001),
	13: float64(0.01),
	14: float64(0.1),
	15: Float64FromInt32(1),
	16: float64(10),
	17: float64(100),
	18: float64(1000),
	19: float64(10000),
	20: float64(100000),
	21: float64(1e+06),
	22: float64(1e+07),
	23: float64(1e+08),
	24: float64(1e+09),
	25: float64(1e+10),
	26: float64(1e+11),
	27: float64(1e+12),
	28: float64(1e+13),
	29: float64(1e+14),
	30: float64(1e+15),
}

func Xpow10(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xexp10(tls, x)
}

func Xexp10f(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var y float32
	var _ /* n at bp+0 */ float32
	var _ /* u at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_ = y
	y = Xmodff(tls, x, bp)
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 4)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 4)) = *(*float32)(unsafe.Pointer(bp))
	/* fabsf(n) < 8 without raising invalid on nan */
	if *(*Tuint32_t)(unsafe.Pointer(bp + 4))>>int32(23)&uint32(0xff) < uint32(Int32FromInt32(0x7f)+Int32FromInt32(3)) {
		if !(y != 0) {
			return _p101[int32(*(*float32)(unsafe.Pointer(bp)))+int32(7)]
		}
		y = Xexp2f(tls, Float32FromFloat32(3.321928094887362)*y)
		return y * _p101[int32(*(*float32)(unsafe.Pointer(bp)))+int32(7)]
	}
	return float32(Xexp2(tls, float64(3.321928094887362)*float64(x)))
}

var _p101 = [15]float32{
	0:  Float32FromFloat32(1e-07),
	1:  Float32FromFloat32(1e-06),
	2:  Float32FromFloat32(1e-05),
	3:  Float32FromFloat32(0.0001),
	4:  Float32FromFloat32(0.001),
	5:  Float32FromFloat32(0.01),
	6:  Float32FromFloat32(0.1),
	7:  Float32FromInt32(1),
	8:  float32(10),
	9:  float32(100),
	10: float32(1000),
	11: float32(10000),
	12: float32(100000),
	13: float32(1e+06),
	14: float32(1e+07),
}

func Xpow10f(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xexp10f(tls, x)
}

func Xexp10l(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xexp10(tls, x)
}

func Xpow10l(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xexp10l(tls, x)
}

// C documentation
//
//	/* Handle cases that may overflow or underflow when computing the result that
//	   is scale*(1+TMP) without intermediate rounding.  The bit representation of
//	   scale is in SBITS, however it has a computed exponent that may have
//	   overflown into the sign bit so that needs to be adjusted before using it as
//	   a double.  (int32_t)KI is the k used in the argument reduction and exponent
//	   adjustment of scale, positive k here means the result may overflow and
//	   negative k means the result may underflow.  */
func _specialcase1(tls *TLS, tmp Tdouble_t, sbits Tuint64_t, ki Tuint64_t) (r float64) {
	var hi, lo, scale, y3 Tdouble_t
	var y, y1, y2, v1, v3, v5, v7 float64
	_, _, _, _, _, _, _, _, _, _, _ = hi, lo, scale, y, y1, y2, y3, v1, v3, v5, v7
	if ki&uint64(0x80000000) == uint64(0) {
		/* k > 0, the exponent of scale might have overflowed by 1.  */
		sbits = sbits - Uint64FromUint64(1)<<Int32FromInt32(52)
		scale = *(*float64)(unsafe.Pointer(&sbits))
		y3 = Float64FromInt32(2) * (scale + scale*tmp)
		y = y3
		v1 = y
		goto _2
	_2:
		return v1
	}
	/* k < 0, need special care in the subnormal range.  */
	sbits = sbits + Uint64FromUint64(1022)<<Int32FromInt32(52)
	scale = *(*float64)(unsafe.Pointer(&sbits))
	y3 = scale + scale*tmp
	if y3 < float64(1) {
		lo = scale - y3 + scale*tmp
		hi = float64(1) + y3
		lo = float64(1) - hi + y3 + lo
		y = hi + lo
		v3 = y
		goto _4
	_4:
		y3 = v3 - float64(1)
		/* Avoid -0.0 with downward rounding.  */
		if Bool(int32(WANT_ROUNDING) != 0) && y3 == float64(0) {
			y3 = float64(0)
		}
		/* The underflow exception needs to be signaled explicitly.  */
		y1 = float64(2.2250738585072014e-308)
		v5 = y1
		goto _6
	_6:
		y2 = v5 * float64(2.2250738585072014e-308)
	}
	y3 = float64(2.2250738585072014e-308) * y3
	y = y3
	v7 = y
	goto _8
_8:
	return v7
}

// C documentation
//
//	/* Top 12 bits of a double (sign and exponent bits).  */
func _top121(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(52))
}

func Xexp2(tls *TLS, x1 float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x1=%v, (%v:)", tls, x1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var abstop Tuint32_t
	var idx, ki, sbits, top, v7 Tuint64_t
	var kd, r, r2, scale, tail, tmp Tdouble_t
	var y, v1, v2, v3, v4, v6, v8 float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = abstop, idx, kd, ki, r, r2, sbits, scale, tail, tmp, top, y, v1, v2, v3, v4, v6, v7, v8
	abstop = _top121(tls, x1) & uint32(0x7ff)
	if abstop-_top121(tls, float64(5.551115123125783e-17)) >= _top121(tls, float64(512))-_top121(tls, float64(5.551115123125783e-17)) {
		if abstop-_top121(tls, float64(5.551115123125783e-17)) >= uint32(0x80000000) {
			/* Avoid spurious underflow for tiny x.  */
			/* Note: 0 is common input.  */
			return float64(1) + x1
		}
		if abstop >= _top121(tls, float64(1024)) {
			v1 = float64(-X__builtin_inff(tls))
			if *(*Tuint64_t)(unsafe.Pointer(&x1)) == *(*Tuint64_t)(unsafe.Pointer(&v1)) {
				return float64(0)
			}
			if abstop >= _top121(tls, float64(X__builtin_inff(tls))) {
				return float64(1) + x1
			}
			if !(*(*Tuint64_t)(unsafe.Pointer(&x1))>>Int32FromInt32(63) != 0) {
				return X__math_oflow(tls, uint32(0))
			} else {
				v2 = -Float64FromFloat64(1075)
				if *(*Tuint64_t)(unsafe.Pointer(&x1)) >= *(*Tuint64_t)(unsafe.Pointer(&v2)) {
					return X__math_uflow(tls, uint32(0))
				}
			}
		}
		v3 = float64(928)
		if uint64(2)**(*Tuint64_t)(unsafe.Pointer(&x1)) > uint64(2)**(*Tuint64_t)(unsafe.Pointer(&v3)) {
			/* Large x is special cased below.  */
			abstop = uint32(0)
		}
	}
	/* exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].  */
	/* x = k/N + r, with int k and r in [-1/2N, 1/2N].  */
	y = x1 + X__exp_data.Fexp2_shift
	v4 = y
	goto _5
_5:
	kd = v4
	v6 = kd
	ki = *(*Tuint64_t)(unsafe.Pointer(&v6)) /* k.  */
	kd -= X__exp_data.Fexp2_shift           /* k/N for int k.  */
	r = x1 - kd
	/* 2^(k/N) ~= scale * (1 + tail).  */
	idx = uint64(2) * (ki % uint64(Int32FromInt32(1)<<Int32FromInt32(EXP_TABLE_BITS)))
	top = ki << (Int32FromInt32(52) - Int32FromInt32(EXP_TABLE_BITS))
	v7 = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 112 + uintptr(idx)*8))
	tail = *(*float64)(unsafe.Pointer(&v7))
	/* This is only a valid scale when -1023*N < k < 1024*N.  */
	sbits = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 112 + uintptr(idx+uint64(1))*8)) + top
	/* exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).  */
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	r2 = r * r
	/* Without fma the worst case error is 0.5/N ulp larger.  */
	/* Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.  */
	tmp = tail + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 72)) + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 72 + 1*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 72 + 2*8))) + r2*r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 72 + 3*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 72 + 4*8)))
	if abstop == uint32(0) {
		return _specialcase1(tls, tmp, sbits, ki)
	}
	scale = *(*float64)(unsafe.Pointer(&sbits))
	/* Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there
	   is no spurious underflow here even without fma.  */
	y = scale + scale*tmp
	v8 = y
	goto _9
_9:
	return v8
}

const EXP2F_POLY_ORDER = 3
const EXP2F_TABLE_BITS = 5
const N1 = 32

/*
EXP2F_TABLE_BITS = 5
EXP2F_POLY_ORDER = 3

ULP error: 0.502 (nearest rounding.)
Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)
Wrong count: 168353 (all nearest rounding wrong results with fma.)
Non-nearest ULP error: 1 (rounded ULP error)
*/

func _top122(tls *TLS, x float32) (r Tuint32_t) {
	return *(*Tuint32_t)(unsafe.Pointer(&x)) >> int32(20)
}

func Xexp2f(tls *TLS, x2 float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x2=%v, (%v:)", tls, x2, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var abstop Tuint32_t
	var kd, r, r2, s, xd, y2, z Tdouble_t
	var ki, t Tuint64_t
	var y, v1, v5 float32
	var y1, v2, v4 float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = abstop, kd, ki, r, r2, s, t, xd, y, y1, y2, z, v1, v2, v4, v5
	xd = float64(x2)
	abstop = _top122(tls, x2) & uint32(0x7ff)
	if abstop >= _top122(tls, Float32FromFloat32(128)) {
		/* |x| >= 128 or x is nan.  */
		v1 = -X__builtin_inff(tls)
		if *(*Tuint32_t)(unsafe.Pointer(&x2)) == *(*Tuint32_t)(unsafe.Pointer(&v1)) {
			return Float32FromFloat32(0)
		}
		if abstop >= _top122(tls, X__builtin_inff(tls)) {
			return x2 + x2
		}
		if x2 > Float32FromFloat32(0) {
			return X__math_oflowf(tls, uint32(0))
		}
		if x2 <= -Float32FromFloat32(150) {
			return X__math_uflowf(tls, uint32(0))
		}
	}
	/* x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.  */
	y1 = xd + X__exp2f_data.Fshift_scaled
	v2 = y1
	goto _3
_3:
	kd = v2
	v4 = kd
	ki = *(*Tuint64_t)(unsafe.Pointer(&v4))
	kd -= X__exp2f_data.Fshift_scaled /* k/N for int k.  */
	r = xd - kd
	/* exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1) */
	t = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + uintptr(ki%uint64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)))*8))
	t += ki << (Int32FromInt32(52) - Int32FromInt32(EXP2F_TABLE_BITS))
	s = *(*float64)(unsafe.Pointer(&t))
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 264))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 264 + 1*8))
	r2 = r * r
	y2 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 264 + 2*8))*r + Float64FromInt32(1)
	y2 = z*r2 + y2
	y2 = y2 * s
	y = float32(y2)
	v5 = y
	goto _6
_6:
	return v5
}

type Texp2f_data = struct {
	Ftab           [32]Tuint64_t
	Fshift_scaled  float64
	Fpoly          [3]float64
	Fshift         float64
	Finvln2_scaled float64
	Fpoly_scaled   [3]float64
}

func Xexp2l(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xexp2(tls, x)
}

const N2 = 128

type Texp_data = struct {
	Finvln2N    float64
	Fshift      float64
	Fnegln2hiN  float64
	Fnegln2loN  float64
	Fpoly       [4]float64
	Fexp2_shift float64
	Fexp2_poly  [5]float64
	Ftab        [256]Tuint64_t
}

const N3 = 32

/*
EXP2F_TABLE_BITS = 5
EXP2F_POLY_ORDER = 3

ULP error: 0.502 (nearest rounding.)
Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)
Wrong count: 170635 (all nearest rounding wrong results with fma.)
Non-nearest ULP error: 1 (rounded ULP error)
*/

func _top123(tls *TLS, x float32) (r Tuint32_t) {
	return *(*Tuint32_t)(unsafe.Pointer(&x)) >> int32(20)
}

func Xexpf(tls *TLS, x2 float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x2=%v, (%v:)", tls, x2, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var abstop Tuint32_t
	var kd, r, r2, s, xd, y2, z Tdouble_t
	var ki, t Tuint64_t
	var y, v1, v5 float32
	var y1, v2, v4 float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = abstop, kd, ki, r, r2, s, t, xd, y, y1, y2, z, v1, v2, v4, v5
	xd = float64(x2)
	abstop = _top123(tls, x2) & uint32(0x7ff)
	if abstop >= _top123(tls, Float32FromFloat32(88)) {
		/* |x| >= 88 or x is nan.  */
		v1 = -X__builtin_inff(tls)
		if *(*Tuint32_t)(unsafe.Pointer(&x2)) == *(*Tuint32_t)(unsafe.Pointer(&v1)) {
			return Float32FromFloat32(0)
		}
		if abstop >= _top123(tls, X__builtin_inff(tls)) {
			return x2 + x2
		}
		if x2 > Float32FromFloat32(88.72283172607422) { /* x > log(0x1p128) ~= 88.72 */
			return X__math_oflowf(tls, uint32(0))
		}
		if x2 < -Float32FromFloat32(103.97207641601562) { /* x < log(0x1p-150) ~= -103.97 */
			return X__math_uflowf(tls, uint32(0))
		}
	}
	/* x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.  */
	z = X__exp2f_data.Finvln2_scaled * xd
	/* Round and convert z to int, the result is in [-150*N, 128*N] and
	   ideally ties-to-even rule is used, otherwise the magnitude of r
	   can be bigger which gives larger approximation error.  */
	y1 = z + X__exp2f_data.Fshift
	v2 = y1
	goto _3
_3:
	kd = v2
	v4 = kd
	ki = *(*Tuint64_t)(unsafe.Pointer(&v4))
	kd -= X__exp2f_data.Fshift
	r = z - kd
	/* exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1) */
	t = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + uintptr(ki%uint64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)))*8))
	t += ki << (Int32FromInt32(52) - Int32FromInt32(EXP2F_TABLE_BITS))
	s = *(*float64)(unsafe.Pointer(&t))
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 304))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 304 + 1*8))
	r2 = r * r
	y2 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 304 + 2*8))*r + Float64FromInt32(1)
	y2 = z*r2 + y2
	y2 = y2 * s
	y = float32(y2)
	v5 = y
	goto _6
_6:
	return v5
}

func Xexpl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xexp(tls, x)
}

var _o_threshold = float64(709.782712893384)  /* 0x40862E42, 0xFEFA39EF */
var _ln2_hi = float64(0.6931471803691238)     /* 0x3fe62e42, 0xfee00000 */
var _ln2_lo = float64(1.9082149292705877e-10) /* 0x3dea39ef, 0x35793c76 */
var _invln2 = float64(1.4426950408889634)     /* 0x3ff71547, 0x652b82fe */
/* Scaled Q's: Qn_here = 2**n * Qn_above, for R(2*z) where z = hxs = x*x/2: */
var _Q1 = -Float64FromFloat64(0.03333333333333313)    /* BFA11111 111110F4 */
var _Q2 = float64(0.0015873015872548146)              /* 3F5A01A0 19FE5585 */
var _Q3 = -Float64FromFloat64(7.93650757867488e-05)   /* BF14CE19 9EAADBB7 */
var _Q4 = float64(4.008217827329362e-06)              /* 3ED0CFCA 86E65239 */
var _Q5 = -Float64FromFloat64(2.0109921818362437e-07) /* BE8AFDB7 6E09C32D */

func Xexpm1(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, e, hfx, hi, hxs, lo, r1, t, twopk, y3 Tdouble_t
	var hx Tuint32_t
	var k, sign int32
	var y float32
	var y1, y2, v3 float64
	var v1 uint64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	var _ /* u at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, e, hfx, hi, hx, hxs, k, lo, r1, sign, t, twopk, y, y1, y2, y3, v1, v3
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 8)) = x3
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(32) & uint64(0x7fffffff))
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(63))
	/* filter out huge and non-finite argument */
	if hx >= uint32(0x4043687A) { /* if |x|>=56*ln2 */
		*(*float64)(unsafe.Pointer(bp)) = x3
		v1 = *(*uint64)(unsafe.Pointer(bp))
		goto _2
	_2:
		if BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
			return x3
		}
		if sign != 0 {
			return float64(-Int32FromInt32(1))
		}
		if x3 > _o_threshold {
			x3 *= float64(8.98846567431158e+307)
			return x3
		}
	}
	/* argument reduction */
	if hx > uint32(0x3fd62e42) { /* if  |x| > 0.5 ln2 */
		if hx < uint32(0x3FF0A2B2) { /* and |x| < 1.5 ln2 */
			if !(sign != 0) {
				hi = x3 - _ln2_hi
				lo = _ln2_lo
				k = int32(1)
			} else {
				hi = x3 + _ln2_hi
				lo = -_ln2_lo
				k = -int32(1)
			}
		} else {
			if sign != 0 {
				v3 = -Float64FromFloat64(0.5)
			} else {
				v3 = float64(0.5)
			}
			k = int32(_invln2*x3 + v3)
			t = float64(k)
			hi = x3 - t*_ln2_hi /* t*ln2_hi is exact here */
			lo = t * _ln2_lo
		}
		x3 = hi - lo
		c = hi - x3 - lo
	} else {
		if hx < uint32(0x3c900000) { /* |x| < 2**-54, return x */
			if hx < uint32(0x00100000) {
				if uint64(4) == uint64(4) {
					y = float32(x3)
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(float32(x3))
					} else {
						y2 = float64(float32(x3))
					}
				}
			}
			return x3
		} else {
			k = 0
		}
	}
	/* x is now in primary range */
	hfx = float64(0.5) * x3
	hxs = x3 * hfx
	r1 = float64(1) + hxs*(_Q1+hxs*(_Q2+hxs*(_Q3+hxs*(_Q4+hxs*_Q5))))
	t = float64(3) - r1*hfx
	e = hxs * ((r1 - t) / (Float64FromFloat64(6) - x3*t))
	if k == 0 { /* c is 0 */
		return x3 - (x3*e - hxs)
	}
	e = x3*(e-c) - c
	e -= hxs
	/* exp(x) ~ 2^k (Xreduced - e + 1) */
	if k == -int32(1) {
		return float64(0.5)*(x3-e) - float64(0.5)
	}
	if k == int32(1) {
		if x3 < -Float64FromFloat64(0.25) {
			return -Float64FromFloat64(2) * (e - (x3 + Float64FromFloat64(0.5)))
		}
		return float64(1) + float64(2)*(x3-e)
	}
	*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = uint64(Int32FromInt32(0x3ff)+k) << int32(52) /* 2^k */
	twopk = *(*float64)(unsafe.Pointer(bp + 8))
	if k < 0 || k > int32(56) { /* suffice to return exp(x)-1 */
		y3 = x3 - e + float64(1)
		if k == int32(1024) {
			y3 = y3 * float64(2) * float64(8.98846567431158e+307)
		} else {
			y3 = y3 * twopk
		}
		return y3 - float64(1)
	}
	*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = uint64(Int32FromInt32(0x3ff)-k) << int32(52) /* 2^-k */
	if k < int32(20) {
		y3 = (x3 - e + (Float64FromInt32(1) - *(*float64)(unsafe.Pointer(bp + 8)))) * twopk
	} else {
		y3 = (x3 - (e + *(*float64)(unsafe.Pointer(bp + 8))) + Float64FromInt32(1)) * twopk
	}
	return y3
}

var _ln2_hi1 = float32(0.69313812256)    /* 0x3f317180 */
var _ln2_lo1 = float32(9.0580006145e-06) /* 0x3717f7d1 */
var _invln21 = float32(1.4426950216)     /* 0x3fb8aa3b */
/*
 * Domain [-0.34568, 0.34568], range ~[-6.694e-10, 6.696e-10]:
 * |6 / x * (1 + 2 * (1 / (exp(x) - 1) - 1 / x)) - q(x)| < 2**-30.04
 * Scaled coefficients: Qn_here = 2**n * Qn_for_q (see s_expm1.c):
 */
var _Q11 = float32(-Float64FromFloat64(0.033333212137)) /* -0x888868.0p-28 */
var _Q21 = float32(0.0015807170421)                     /*  0xcf3010.0p-33 */

func Xexpm1f(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, e, hfx, hi, hxs, lo, r1, t, twopk, y3 Tfloat_t
	var hx Tuint32_t
	var k, sign int32
	var y, v1 float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, e, hfx, hi, hx, hxs, k, lo, r1, sign, t, twopk, y, y1, y2, y3, v1
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	hx = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	sign = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	/* filter out huge and non-finite argument */
	if hx >= uint32(0x4195b844) { /* if |x|>=27*ln2 */
		if hx > uint32(0x7f800000) { /* NaN */
			return x3
		}
		if sign != 0 {
			return float32(-Int32FromInt32(1))
		}
		if hx > uint32(0x42b17217) { /* x > log(FLT_MAX) */
			x3 *= Float32FromFloat32(1.7014118346046923e+38)
			return x3
		}
	}
	/* argument reduction */
	if hx > uint32(0x3eb17218) { /* if  |x| > 0.5 ln2 */
		if hx < uint32(0x3F851592) { /* and |x| < 1.5 ln2 */
			if !(sign != 0) {
				hi = x3 - _ln2_hi1
				lo = _ln2_lo1
				k = int32(1)
			} else {
				hi = x3 + _ln2_hi1
				lo = -_ln2_lo1
				k = -int32(1)
			}
		} else {
			if sign != 0 {
				v1 = -Float32FromFloat32(0.5)
			} else {
				v1 = Float32FromFloat32(0.5)
			}
			k = int32(_invln21*x3 + v1)
			t = float32(k)
			hi = x3 - t*_ln2_hi1 /* t*ln2_hi is exact here */
			lo = t * _ln2_lo1
		}
		x3 = hi - lo
		c = hi - x3 - lo
	} else {
		if hx < uint32(0x33000000) { /* when |x|<2**-25, return x */
			if hx < uint32(0x00800000) {
				if uint64(4) == uint64(4) {
					y = x3 * x3
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(x3 * x3)
					} else {
						y2 = float64(x3 * x3)
					}
				}
			}
			return x3
		} else {
			k = 0
		}
	}
	/* x is now in primary range */
	hfx = Float32FromFloat32(0.5) * x3
	hxs = x3 * hfx
	r1 = Float32FromFloat32(1) + hxs*(_Q11+hxs*_Q21)
	t = Float32FromFloat32(3) - r1*hfx
	e = hxs * ((r1 - t) / (Float32FromFloat32(6) - x3*t))
	if k == 0 { /* c is 0 */
		return x3 - (x3*e - hxs)
	}
	e = x3*(e-c) - c
	e -= hxs
	/* exp(x) ~ 2^k (Xreduced - e + 1) */
	if k == -int32(1) {
		return Float32FromFloat32(0.5)*(x3-e) - Float32FromFloat32(0.5)
	}
	if k == int32(1) {
		if x3 < -Float32FromFloat32(0.25) {
			return -Float32FromFloat32(2) * (e - (x3 + Float32FromFloat32(0.5)))
		}
		return Float32FromFloat32(1) + Float32FromFloat32(2)*(x3-e)
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32((int32(0x7f) + k) << int32(23)) /* 2^k */
	twopk = *(*float32)(unsafe.Pointer(bp))
	if k < 0 || k > int32(56) { /* suffice to return exp(x)-1 */
		y3 = x3 - e + Float32FromFloat32(1)
		if k == int32(128) {
			y3 = y3 * Float32FromFloat32(2) * Float32FromFloat32(1.7014118346046923e+38)
		} else {
			y3 = y3 * twopk
		}
		return y3 - Float32FromFloat32(1)
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32((int32(0x7f) - k) << int32(23)) /* 2^-k */
	if k < int32(23) {
		y3 = (x3 - e + (Float32FromInt32(1) - *(*float32)(unsafe.Pointer(bp)))) * twopk
	} else {
		y3 = (x3 - (e + *(*float32)(unsafe.Pointer(bp))) + Float32FromInt32(1)) * twopk
	}
	return y3
}

func Xexpm1l(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xexpm1(tls, x)
}

func Xfabs(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var p1 uintptr
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_ = p1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (-Uint64FromUint64(1) / Uint64FromInt32(2))
	return *(*float64)(unsafe.Pointer(bp))
}

func Xfabsf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x7fffffff)
	return *(*float32)(unsafe.Pointer(bp))
}

func Xfabsl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfabs(tls, x)
}

func Xfdim(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v3 uint64
	var v5 float64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _ = v1, v3, v5
	*(*float64)(unsafe.Pointer(bp)) = x
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	if BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x
	}
	*(*float64)(unsafe.Pointer(bp)) = y
	v3 = *(*uint64)(unsafe.Pointer(bp))
	goto _4
_4:
	if BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return y
	}
	if x > y {
		v5 = x - y
	} else {
		v5 = Float64FromInt32(0)
	}
	return v5
}

func Xfdimf(tls *TLS, x float32, y float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v3 uint32
	var v5 float32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _ = v1, v3, v5
	*(*float32)(unsafe.Pointer(bp)) = x
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	if BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x
	}
	*(*float32)(unsafe.Pointer(bp)) = y
	v3 = *(*uint32)(unsafe.Pointer(bp))
	goto _4
_4:
	if BoolInt32(v3&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return y
	}
	if x > y {
		v5 = x - y
	} else {
		v5 = Float32FromInt32(0)
	}
	return v5
}

func Xfdiml(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfdim(tls, x, y)
}

func Xfinite(tls *TLS, x float64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 uint64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_ = v1
	*(*float64)(unsafe.Pointer(bp)) = x
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	return BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52))
}

func Xfinitef(tls *TLS, x float32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 uint32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_ = v1
	*(*float32)(unsafe.Pointer(bp)) = x
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	return BoolInt32(v1&uint32(0x7fffffff) < uint32(0x7f800000))
}

const DBL_EPSILON7 = 2.220446049250313e-16

var _toint3 = Float64FromInt32(1) / Float64FromFloat64(2.220446049250313e-16)

func Xfloor(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, v1 int32
	var y float32
	var y1, y2 float64
	var y3 Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _ = e, y, y1, y2, y3, v1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if e >= Int32FromInt32(0x3ff)+Int32FromInt32(52) || x3 == Float64FromInt32(0) {
		return x3
	}
	/* y = int(x) - x, where int(x) is an integer neighbor of x */
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		y3 = x3 - _toint3 + _toint3 - x3
	} else {
		y3 = x3 + _toint3 - _toint3 - x3
	}
	/* special case because of non-nearest rounding modes */
	if e <= Int32FromInt32(0x3ff)-Int32FromInt32(1) {
		if uint64(8) == uint64(4) {
			y = float32(y3)
		} else {
			if uint64(8) == uint64(8) {
				y1 = y3
			} else {
				y2 = y3
			}
		}
		if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
			v1 = -int32(1)
		} else {
			v1 = 0
		}
		return float64(v1)
	}
	if y3 > Float64FromInt32(0) {
		return x3 + y3 - Float64FromInt32(1)
	}
	return x3 + y3
}

const DBL_EPSILON8 = 0

func Xfloorf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var m Tuint32_t
	var y float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _ = e, m, y, y1, y2
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp))>>Int32FromInt32(23)&Uint32FromInt32(0xff)) - int32(0x7f)
	if e >= int32(23) {
		return x3
	}
	if e >= 0 {
		m = uint32(int32(0x007fffff) >> e)
		if *(*Tuint32_t)(unsafe.Pointer(bp))&m == uint32(0) {
			return x3
		}
		if uint64(4) == uint64(4) {
			y = x3 + Float32FromFloat32(1.329227995784916e+36)
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
			} else {
				y2 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
			}
		}
		if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
			*(*Tuint32_t)(unsafe.Pointer(bp)) += m
		}
		*(*Tuint32_t)(unsafe.Pointer(bp)) &= ^m
	} else {
		if uint64(4) == uint64(4) {
			y = x3 + Float32FromFloat32(1.329227995784916e+36)
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
			} else {
				y2 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
			}
		}
		if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) == uint32(0) {
			*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32(0)
		} else {
			if *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(1) != 0 {
				*(*float32)(unsafe.Pointer(bp)) = float32(-Float64FromFloat64(1))
			}
		}
	}
	return *(*float32)(unsafe.Pointer(bp))
}

func Xfloorl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfloor(tls, x)
}

const DBL_MIN1 = 2.2250738585072014e-308
const FLT_MIN1 = 1.1754943508222875e-38
const ZEROINFNAN = 971

type Tnum = struct {
	Fm    Tuint64_t
	Fe    int32
	Fsign int32
}

func _normalize(tls *TLS, x float64) (r Tnum) {
	var e, sign, v2 int32
	var ix Tuint64_t
	var v1 float64
	_, _, _, _, _ = e, ix, sign, v1, v2
	ix = *(*Tuint64_t)(unsafe.Pointer(&x))
	e = int32(ix >> int32(52))
	sign = e & int32(0x800)
	e &= int32(0x7ff)
	if !(e != 0) {
		v1 = x * float64(9.223372036854776e+18)
		ix = *(*Tuint64_t)(unsafe.Pointer(&v1))
		e = int32(ix >> int32(52) & uint64(0x7ff))
		if e != 0 {
			v2 = e - int32(63)
		} else {
			v2 = int32(0x800)
		}
		e = v2
	}
	ix = ix & (Uint64FromUint64(1)<<Int32FromInt32(52) - Uint64FromInt32(1))
	ix = ix | Uint64FromUint64(1)<<Int32FromInt32(52)
	ix <<= uint64(1)
	e -= Int32FromInt32(0x3ff) + Int32FromInt32(52) + Int32FromInt32(1)
	return Tnum{
		Fm:    ix,
		Fe:    e,
		Fsign: sign,
	}
}

func _mul(tls *TLS, hi uintptr, lo uintptr, x Tuint64_t, y Tuint64_t) {
	var t1, t2, t3, xhi, xlo, yhi, ylo Tuint64_t
	_, _, _, _, _, _, _ = t1, t2, t3, xhi, xlo, yhi, ylo
	xlo = uint64(uint32(x))
	xhi = x >> int32(32)
	ylo = uint64(uint32(y))
	yhi = y >> int32(32)
	t1 = xlo * ylo
	t2 = xlo*yhi + xhi*ylo
	t3 = xhi * yhi
	*(*Tuint64_t)(unsafe.Pointer(lo)) = t1 + t2<<Int32FromInt32(32)
	*(*Tuint64_t)(unsafe.Pointer(hi)) = t3 + t2>>Int32FromInt32(32) + BoolUint64(t1 > *(*Tuint64_t)(unsafe.Pointer(lo)))
}

func Xfma(tls *TLS, x1 float64, y float64, z float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x1=%v y=%v z=%v, (%v:)", tls, x1, y, z, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, r float64
	var d, e, nonzero, samesign, sign, v2, v5 int32
	var fltmin float32
	var i Tint64_t
	var nx, ny, nz Tnum
	var t, zhi, zlo, v1, v4 Tuint64_t
	var tiny Tdouble_t
	var _ /* rhi at bp+0 */ Tuint64_t
	var _ /* rlo at bp+8 */ Tuint64_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, d, e, fltmin, i, nonzero, nx, ny, nz, r, samesign, sign, t, tiny, zhi, zlo, v1, v2, v4, v5
	nx = _normalize(tls, x1)
	ny = _normalize(tls, y)
	nz = _normalize(tls, z)
	if nx.Fe >= Int32FromInt32(0x7ff)-Int32FromInt32(0x3ff)-Int32FromInt32(52)-Int32FromInt32(1) || ny.Fe >= Int32FromInt32(0x7ff)-Int32FromInt32(0x3ff)-Int32FromInt32(52)-Int32FromInt32(1) {
		return x1*y + z
	}
	if nz.Fe >= Int32FromInt32(0x7ff)-Int32FromInt32(0x3ff)-Int32FromInt32(52)-Int32FromInt32(1) {
		if nz.Fe > Int32FromInt32(0x7ff)-Int32FromInt32(0x3ff)-Int32FromInt32(52)-Int32FromInt32(1) { /* z==0 */
			return x1*y + z
		}
		return z
	}
	_mul(tls, bp, bp+8, nx.Fm, ny.Fm)
	/* either top 20 or 21 bits of rhi and last 2 bits of rlo are 0 */
	/* align exponents */
	e = nx.Fe + ny.Fe
	d = nz.Fe - e
	/* shift bits z<<=kz, r>>=kr, so kz+kr == d, set e = e+kr (== ez-kz) */
	if d > 0 {
		if d < int32(64) {
			zlo = nz.Fm << d
			zhi = nz.Fm >> (int32(64) - d)
		} else {
			zlo = uint64(0)
			zhi = nz.Fm
			e = nz.Fe - int32(64)
			d -= int32(64)
			if d == 0 {
			} else {
				if d < int32(64) {
					*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = *(*Tuint64_t)(unsafe.Pointer(bp))<<(int32(64)-d) | *(*Tuint64_t)(unsafe.Pointer(bp + 8))>>d | BoolUint64(!!(*(*Tuint64_t)(unsafe.Pointer(bp + 8))<<(Int32FromInt32(64)-d) != 0))
					*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp)) >> d
				} else {
					*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = uint64(1)
					*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(0)
				}
			}
		}
	} else {
		zhi = uint64(0)
		d = -d
		if d == 0 {
			zlo = nz.Fm
		} else {
			if d < int32(64) {
				zlo = nz.Fm>>d | BoolUint64(!!(nz.Fm<<(Int32FromInt32(64)-d) != 0))
			} else {
				zlo = uint64(1)
			}
		}
	}
	/* add */
	sign = nx.Fsign ^ ny.Fsign
	samesign = BoolInt32(!(sign^nz.Fsign != 0))
	nonzero = int32(1)
	if samesign != 0 {
		/* r += z */
		*(*Tuint64_t)(unsafe.Pointer(bp + 8)) += zlo
		*(*Tuint64_t)(unsafe.Pointer(bp)) += zhi + BoolUint64(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) < zlo)
	} else {
		/* r -= z */
		t = *(*Tuint64_t)(unsafe.Pointer(bp + 8))
		*(*Tuint64_t)(unsafe.Pointer(bp + 8)) -= zlo
		*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp)) - zhi - BoolUint64(t < *(*Tuint64_t)(unsafe.Pointer(bp + 8)))
		if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
			*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = -*(*Tuint64_t)(unsafe.Pointer(bp + 8))
			*(*Tuint64_t)(unsafe.Pointer(bp)) = -*(*Tuint64_t)(unsafe.Pointer(bp)) - BoolUint64(!!(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) != 0))
			sign = BoolInt32(!(sign != 0))
		}
		nonzero = BoolInt32(!!(*(*Tuint64_t)(unsafe.Pointer(bp)) != 0))
	}
	/* set rhi to top 63bit of the result (last bit is sticky) */
	if nonzero != 0 {
		e += int32(64)
		v1 = *(*Tuint64_t)(unsafe.Pointer(bp))
		// __asm__("clz %0, %1" : "=r"(x) : "r"(x));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 80, __ccgo_ts+566)
		v2 = int32(v1)
		goto _3
	_3:
		d = v2 - int32(1)
		/* note: d > 0 */
		*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp))<<d | *(*Tuint64_t)(unsafe.Pointer(bp + 8))>>(int32(64)-d) | BoolUint64(!!(*(*Tuint64_t)(unsafe.Pointer(bp + 8))<<d != 0))
	} else {
		if *(*Tuint64_t)(unsafe.Pointer(bp + 8)) != 0 {
			v4 = *(*Tuint64_t)(unsafe.Pointer(bp + 8))
			// __asm__("clz %0, %1" : "=r"(x) : "r"(x));
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 80, __ccgo_ts+566)
			v5 = int32(v4)
			goto _6
		_6:
			d = v5 - int32(1)
			if d < 0 {
				*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp + 8))>>int32(1) | *(*Tuint64_t)(unsafe.Pointer(bp + 8))&uint64(1)
			} else {
				*(*Tuint64_t)(unsafe.Pointer(bp)) = *(*Tuint64_t)(unsafe.Pointer(bp + 8)) << d
			}
		} else {
			/* exact +-0 */
			return x1*y + z
		}
	}
	e -= d
	/* convert to double */
	i = int64(*(*Tuint64_t)(unsafe.Pointer(bp))) /* i is in [1<<62,(1<<63)-1] */
	if sign != 0 {
		i = -i
	}
	r = float64(i) /* |r| is in [0x1p62,0x1p63] */
	if e < -Int32FromInt32(1022)-Int32FromInt32(62) {
		/* result is subnormal before rounding */
		if e == -Int32FromInt32(1022)-Int32FromInt32(63) {
			c = float64(9.223372036854776e+18)
			if sign != 0 {
				c = -c
			}
			if r == c {
				/* min normal after rounding, underflow depends
				   on arch behaviour which can be imitated by
				   a double to float conversion */
				fltmin = float32(Float64FromFloat64(1.0842021401737618e-19) * Float64FromFloat32(1.1754943508222875e-38) * r)
				return Float64FromFloat64(2.2250738585072014e-308) / Float64FromFloat32(1.1754943508222875e-38) * float64(fltmin)
			}
			/* one bit is lost when scaled, add another top bit to
			   only round once at conversion if it is inexact */
			if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(53) != 0 {
				i = int64(*(*Tuint64_t)(unsafe.Pointer(bp))>>int32(1) | *(*Tuint64_t)(unsafe.Pointer(bp))&uint64(1) | Uint64FromUint64(1)<<Int32FromInt32(62))
				if sign != 0 {
					i = -i
				}
				r = float64(i)
				r = Float64FromInt32(2)*r - c /* remove top bit */
				/* raise underflow portably, such that it
				   cannot be optimized away */
				tiny = Float64FromFloat64(2.2250738585072014e-308) / Float64FromFloat32(1.1754943508222875e-38) * r
				r += tiny * tiny * (r - r)
			}
		} else {
			/* only round once when scaled */
			d = int32(10)
			i = int64((*(*Tuint64_t)(unsafe.Pointer(bp))>>d | BoolUint64(!!(*(*Tuint64_t)(unsafe.Pointer(bp))<<(Int32FromInt32(64)-d) != 0))) << d)
			if sign != 0 {
				i = -i
			}
			r = float64(i)
		}
	}
	return Xscalbn(tls, r, e)
}

const DBL_MIN2 = 0
const FLT_MIN2 = 0

func Xfmal(tls *TLS, x float64, y float64, z float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v z=%v, (%v:)", tls, x, y, z, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfma(tls, x, y, z)
}

func Xfmax(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v10, v3, v5, v7 uint64
	var v12, v9 float64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _, _, _, _ = v1, v10, v12, v3, v5, v7, v9
	*(*float64)(unsafe.Pointer(bp)) = x
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	if BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return y
	}
	*(*float64)(unsafe.Pointer(bp)) = y
	v3 = *(*uint64)(unsafe.Pointer(bp))
	goto _4
_4:
	if BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x
	}
	/* handle signed zeros, see C99 Annex F.9.9.2 */
	*(*float64)(unsafe.Pointer(bp)) = x
	v5 = *(*uint64)(unsafe.Pointer(bp))
	goto _6
_6:
	*(*float64)(unsafe.Pointer(bp)) = y
	v7 = *(*uint64)(unsafe.Pointer(bp))
	goto _8
_8:
	if int32(v5>>Int32FromInt32(63)) != int32(v7>>Int32FromInt32(63)) {
		*(*float64)(unsafe.Pointer(bp)) = x
		v10 = *(*uint64)(unsafe.Pointer(bp))
		goto _11
	_11:
		if int32(v10>>Int32FromInt32(63)) != 0 {
			v9 = y
		} else {
			v9 = x
		}
		return v9
	}
	if x < y {
		v12 = y
	} else {
		v12 = x
	}
	return v12
}

func Xfmaxf(tls *TLS, x float32, y float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v10, v3, v5, v7 uint32
	var v12, v9 float32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _, _, _, _ = v1, v10, v12, v3, v5, v7, v9
	*(*float32)(unsafe.Pointer(bp)) = x
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	if BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return y
	}
	*(*float32)(unsafe.Pointer(bp)) = y
	v3 = *(*uint32)(unsafe.Pointer(bp))
	goto _4
_4:
	if BoolInt32(v3&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x
	}
	/* handle signed zeroes, see C99 Annex F.9.9.2 */
	*(*float32)(unsafe.Pointer(bp)) = x
	v5 = *(*uint32)(unsafe.Pointer(bp))
	goto _6
_6:
	*(*float32)(unsafe.Pointer(bp)) = y
	v7 = *(*uint32)(unsafe.Pointer(bp))
	goto _8
_8:
	if int32(v5>>Int32FromInt32(31)) != int32(v7>>Int32FromInt32(31)) {
		*(*float32)(unsafe.Pointer(bp)) = x
		v10 = *(*uint32)(unsafe.Pointer(bp))
		goto _11
	_11:
		if int32(v10>>Int32FromInt32(31)) != 0 {
			v9 = y
		} else {
			v9 = x
		}
		return v9
	}
	if x < y {
		v12 = y
	} else {
		v12 = x
	}
	return v12
}

func Xfmaxl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfmax(tls, x, y)
}

func Xfmin(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v10, v3, v5, v7 uint64
	var v12, v9 float64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _, _, _, _ = v1, v10, v12, v3, v5, v7, v9
	*(*float64)(unsafe.Pointer(bp)) = x
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	if BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return y
	}
	*(*float64)(unsafe.Pointer(bp)) = y
	v3 = *(*uint64)(unsafe.Pointer(bp))
	goto _4
_4:
	if BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x
	}
	/* handle signed zeros, see C99 Annex F.9.9.2 */
	*(*float64)(unsafe.Pointer(bp)) = x
	v5 = *(*uint64)(unsafe.Pointer(bp))
	goto _6
_6:
	*(*float64)(unsafe.Pointer(bp)) = y
	v7 = *(*uint64)(unsafe.Pointer(bp))
	goto _8
_8:
	if int32(v5>>Int32FromInt32(63)) != int32(v7>>Int32FromInt32(63)) {
		*(*float64)(unsafe.Pointer(bp)) = x
		v10 = *(*uint64)(unsafe.Pointer(bp))
		goto _11
	_11:
		if int32(v10>>Int32FromInt32(63)) != 0 {
			v9 = x
		} else {
			v9 = y
		}
		return v9
	}
	if x < y {
		v12 = x
	} else {
		v12 = y
	}
	return v12
}

func Xfminf(tls *TLS, x float32, y float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v10, v3, v5, v7 uint32
	var v12, v9 float32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _, _, _, _ = v1, v10, v12, v3, v5, v7, v9
	*(*float32)(unsafe.Pointer(bp)) = x
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	if BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return y
	}
	*(*float32)(unsafe.Pointer(bp)) = y
	v3 = *(*uint32)(unsafe.Pointer(bp))
	goto _4
_4:
	if BoolInt32(v3&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x
	}
	/* handle signed zeros, see C99 Annex F.9.9.2 */
	*(*float32)(unsafe.Pointer(bp)) = x
	v5 = *(*uint32)(unsafe.Pointer(bp))
	goto _6
_6:
	*(*float32)(unsafe.Pointer(bp)) = y
	v7 = *(*uint32)(unsafe.Pointer(bp))
	goto _8
_8:
	if int32(v5>>Int32FromInt32(31)) != int32(v7>>Int32FromInt32(31)) {
		*(*float32)(unsafe.Pointer(bp)) = x
		v10 = *(*uint32)(unsafe.Pointer(bp))
		goto _11
	_11:
		if int32(v10>>Int32FromInt32(31)) != 0 {
			v9 = x
		} else {
			v9 = y
		}
		return v9
	}
	if x < y {
		v12 = x
	} else {
		v12 = y
	}
	return v12
}

func Xfminl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfmin(tls, x, y)
}

func Xfmod(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ex, ey, sx int32
	var i, uxi Tuint64_t
	var v1 uint64
	var v3 bool
	var p6, p7 uintptr
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	var _ /* ux at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+16 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _ = ex, ey, i, sx, uxi, v1, v3, p6, p7
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 8)) = x
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 16)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 16)) = y
	ex = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(52) & uint64(0x7ff))
	ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 16)) >> int32(52) & uint64(0x7ff))
	sx = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(63))
	/* in the followings uxi should be ux.i, but then gcc wrongly adds */
	/* float load/store to inner loops ruining performance and code size */
	uxi = *(*Tuint64_t)(unsafe.Pointer(bp + 8))
	if v3 = *(*Tuint64_t)(unsafe.Pointer(bp + 16))<<int32(1) == uint64(0); !v3 {
		*(*float64)(unsafe.Pointer(bp)) = y
		v1 = *(*uint64)(unsafe.Pointer(bp))
		goto _2
	_2:
	}
	if v3 || BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 || ex == int32(0x7ff) {
		return x * y / (x * y)
	}
	if uxi<<int32(1) <= *(*Tuint64_t)(unsafe.Pointer(bp + 16))<<int32(1) {
		if uxi<<int32(1) == *(*Tuint64_t)(unsafe.Pointer(bp + 16))<<int32(1) {
			return Float64FromInt32(0) * x
		}
		return x
	}
	/* normalize x and y */
	if !(ex != 0) {
		i = uxi << int32(12)
		for {
			if !(i>>int32(63) == uint64(0)) {
				break
			}
			goto _4
		_4:
			;
			ex--
			i <<= uint64(1)
		}
		uxi <<= uint64(-ex + int32(1))
	} else {
		uxi = uxi & (-Uint64FromUint64(1) >> Int32FromInt32(12))
		uxi = uxi | Uint64FromUint64(1)<<Int32FromInt32(52)
	}
	if !(ey != 0) {
		i = *(*Tuint64_t)(unsafe.Pointer(bp + 16)) << int32(12)
		for {
			if !(i>>int32(63) == uint64(0)) {
				break
			}
			goto _5
		_5:
			;
			ey--
			i <<= uint64(1)
		}
		*(*Tuint64_t)(unsafe.Pointer(bp + 16)) <<= uint64(-ey + int32(1))
	} else {
		p6 = bp + 16
		*(*Tuint64_t)(unsafe.Pointer(p6)) = *(*Tuint64_t)(unsafe.Pointer(p6)) & (-Uint64FromUint64(1) >> Int32FromInt32(12))
		p7 = bp + 16
		*(*Tuint64_t)(unsafe.Pointer(p7)) = *(*Tuint64_t)(unsafe.Pointer(p7)) | Uint64FromUint64(1)<<Int32FromInt32(52)
	}
	/* x mod y */
	for {
		if !(ex > ey) {
			break
		}
		i = uxi - *(*Tuint64_t)(unsafe.Pointer(bp + 16))
		if i>>int32(63) == uint64(0) {
			if i == uint64(0) {
				return Float64FromInt32(0) * x
			}
			uxi = i
		}
		uxi <<= uint64(1)
		goto _8
	_8:
		;
		ex--
	}
	i = uxi - *(*Tuint64_t)(unsafe.Pointer(bp + 16))
	if i>>int32(63) == uint64(0) {
		if i == uint64(0) {
			return Float64FromInt32(0) * x
		}
		uxi = i
	}
	for {
		if !(uxi>>int32(52) == uint64(0)) {
			break
		}
		goto _9
	_9:
		;
		uxi <<= uint64(1)
		ex--
	}
	/* scale result */
	if ex > 0 {
		uxi = uxi - Uint64FromUint64(1)<<Int32FromInt32(52)
		uxi |= uint64(ex) << int32(52)
	} else {
		uxi >>= uint64(-ex + int32(1))
	}
	uxi |= uint64(sx) << int32(63)
	*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = uxi
	return *(*float64)(unsafe.Pointer(bp + 8))
}

func Xfmodf(tls *TLS, x float32, y float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ex, ey int32
	var i, sx, uxi Tuint32_t
	var v1 uint32
	var v3 bool
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	var _ /* ux at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _ = ex, ey, i, sx, uxi, v1, v3
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 4)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 4)) = x
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 8)) = y
	ex = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(23) & uint32(0xff))
	ey = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 8)) >> int32(23) & uint32(0xff))
	sx = *(*Tuint32_t)(unsafe.Pointer(bp + 4)) & uint32(0x80000000)
	uxi = *(*Tuint32_t)(unsafe.Pointer(bp + 4))
	if v3 = *(*Tuint32_t)(unsafe.Pointer(bp + 8))<<int32(1) == uint32(0); !v3 {
		*(*float32)(unsafe.Pointer(bp)) = y
		v1 = *(*uint32)(unsafe.Pointer(bp))
		goto _2
	_2:
	}
	if v3 || BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 || ex == int32(0xff) {
		return x * y / (x * y)
	}
	if uxi<<int32(1) <= *(*Tuint32_t)(unsafe.Pointer(bp + 8))<<int32(1) {
		if uxi<<int32(1) == *(*Tuint32_t)(unsafe.Pointer(bp + 8))<<int32(1) {
			return Float32FromInt32(0) * x
		}
		return x
	}
	/* normalize x and y */
	if !(ex != 0) {
		i = uxi << int32(9)
		for {
			if !(i>>int32(31) == uint32(0)) {
				break
			}
			goto _4
		_4:
			;
			ex--
			i <<= uint32(1)
		}
		uxi <<= uint32(-ex + int32(1))
	} else {
		uxi &= -Uint32FromUint32(1) >> Int32FromInt32(9)
		uxi |= Uint32FromUint32(1) << Int32FromInt32(23)
	}
	if !(ey != 0) {
		i = *(*Tuint32_t)(unsafe.Pointer(bp + 8)) << int32(9)
		for {
			if !(i>>int32(31) == uint32(0)) {
				break
			}
			goto _5
		_5:
			;
			ey--
			i <<= uint32(1)
		}
		*(*Tuint32_t)(unsafe.Pointer(bp + 8)) <<= uint32(-ey + int32(1))
	} else {
		*(*Tuint32_t)(unsafe.Pointer(bp + 8)) &= -Uint32FromUint32(1) >> Int32FromInt32(9)
		*(*Tuint32_t)(unsafe.Pointer(bp + 8)) |= Uint32FromUint32(1) << Int32FromInt32(23)
	}
	/* x mod y */
	for {
		if !(ex > ey) {
			break
		}
		i = uxi - *(*Tuint32_t)(unsafe.Pointer(bp + 8))
		if i>>int32(31) == uint32(0) {
			if i == uint32(0) {
				return Float32FromInt32(0) * x
			}
			uxi = i
		}
		uxi <<= uint32(1)
		goto _6
	_6:
		;
		ex--
	}
	i = uxi - *(*Tuint32_t)(unsafe.Pointer(bp + 8))
	if i>>int32(31) == uint32(0) {
		if i == uint32(0) {
			return Float32FromInt32(0) * x
		}
		uxi = i
	}
	for {
		if !(uxi>>int32(23) == uint32(0)) {
			break
		}
		goto _7
	_7:
		;
		uxi <<= uint32(1)
		ex--
	}
	/* scale result up */
	if ex > 0 {
		uxi -= Uint32FromUint32(1) << Int32FromInt32(23)
		uxi |= uint32(ex) << int32(23)
	} else {
		uxi >>= uint32(-ex + int32(1))
	}
	uxi |= sx
	*(*Tuint32_t)(unsafe.Pointer(bp + 4)) = uxi
	return *(*float32)(unsafe.Pointer(bp + 4))
}

func Xfmodl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfmod(tls, x, y)
}

func Xfrexp(tls *TLS, x float64, e uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v e=%v, (%v:)", tls, x, e, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ee int32
	var p1, p2 uintptr
	var _ /* y at bp+0 */ struct {
		Fi [0]Tuint64_t
		Fd float64
	}
	_, _, _ = ee, p1, p2
	*(*struct {
		Fi [0]Tuint64_t
		Fd float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Fd float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	ee = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if !(ee != 0) {
		if x != 0 {
			x = Xfrexp(tls, x*float64(1.8446744073709552e+19), e)
			*(*int32)(unsafe.Pointer(e)) -= int32(64)
		} else {
			*(*int32)(unsafe.Pointer(e)) = 0
		}
		return x
	} else {
		if ee == int32(0x7ff) {
			return x
		}
	}
	*(*int32)(unsafe.Pointer(e)) = ee - int32(0x3fe)
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & Uint64FromUint64(0x800fffffffffffff)
	p2 = bp
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) | Uint64FromUint64(0x3fe0000000000000)
	return *(*float64)(unsafe.Pointer(bp))
}

func Xfrexpf(tls *TLS, x float32, e uintptr) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v e=%v, (%v:)", tls, x, e, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ee int32
	var p1, p2 uintptr
	var _ /* y at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _ = ee, p1, p2
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	ee = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	if !(ee != 0) {
		if x != 0 {
			x = Xfrexpf(tls, float32(float64(x)*float64(1.8446744073709552e+19)), e)
			*(*int32)(unsafe.Pointer(e)) -= int32(64)
		} else {
			*(*int32)(unsafe.Pointer(e)) = 0
		}
		return x
	} else {
		if ee == int32(0xff) {
			return x
		}
	}
	*(*int32)(unsafe.Pointer(e)) = ee - int32(0x7e)
	p1 = bp
	*(*Tuint32_t)(unsafe.Pointer(p1)) = Tuint32_t(uint64(*(*Tuint32_t)(unsafe.Pointer(p1))) & Uint64FromUint64(0x807fffff))
	p2 = bp
	*(*Tuint32_t)(unsafe.Pointer(p2)) = Tuint32_t(uint64(*(*Tuint32_t)(unsafe.Pointer(p2))) | Uint64FromUint64(0x3f000000))
	return *(*float32)(unsafe.Pointer(bp))
}

func Xfrexpl(tls *TLS, x float64, e uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v e=%v, (%v:)", tls, x, e, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfrexp(tls, x, e)
}

const SPLIT = 1

func _sq(tls *TLS, hi uintptr, lo uintptr, x float64) {
	var xc, xh, xl Tdouble_t
	_, _, _ = xc, xh, xl
	xc = x * (Float64FromFloat64(1.34217728e+08) + Float64FromInt32(1))
	xh = x - xc + xc
	xl = x - xh
	*(*Tdouble_t)(unsafe.Pointer(hi)) = x * x
	*(*Tdouble_t)(unsafe.Pointer(lo)) = xh*xh - *(*Tdouble_t)(unsafe.Pointer(hi)) + Float64FromInt32(2)*xh*xl + xl*xl
}

func Xhypot(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var ex, ey int32
	var ut struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var z Tdouble_t
	var p1, p2 uintptr
	var _ /* hx at bp+16 */ Tdouble_t
	var _ /* hy at bp+32 */ Tdouble_t
	var _ /* lx at bp+24 */ Tdouble_t
	var _ /* ly at bp+40 */ Tdouble_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _ = ex, ey, ut, z, p1, p2
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 8)) = y
	/* arrange |x| >= |y| */
	p1 = bp
	*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (-Uint64FromUint64(1) >> Int32FromInt32(1))
	p2 = bp + 8
	*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) & (-Uint64FromUint64(1) >> Int32FromInt32(1))
	if *(*Tuint64_t)(unsafe.Pointer(bp)) < *(*Tuint64_t)(unsafe.Pointer(bp + 8)) {
		ut = *(*struct {
			Fi [0]Tuint64_t
			Ff float64
		})(unsafe.Pointer(bp))
		*(*struct {
			Fi [0]Tuint64_t
			Ff float64
		})(unsafe.Pointer(bp)) = *(*struct {
			Fi [0]Tuint64_t
			Ff float64
		})(unsafe.Pointer(bp + 8))
		*(*struct {
			Fi [0]Tuint64_t
			Ff float64
		})(unsafe.Pointer(bp + 8)) = ut
	}
	/* special cases */
	ex = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52))
	ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(52))
	x = *(*float64)(unsafe.Pointer(bp))
	y = *(*float64)(unsafe.Pointer(bp + 8))
	/* note: hypot(inf,nan) == inf */
	if ey == int32(0x7ff) {
		return y
	}
	if ex == int32(0x7ff) || *(*Tuint64_t)(unsafe.Pointer(bp + 8)) == uint64(0) {
		return x
	}
	/* note: hypot(x,y) ~= x + y*y/x/2 with inexact for small y/x */
	/* 64 difference is enough for ld80 double_t */
	if ex-ey > int32(64) {
		return x + y
	}
	/* precise sqrt argument in nearest rounding mode without overflow */
	/* xh*xh must not overflow and xl*xl must not underflow in sq */
	z = Float64FromInt32(1)
	if ex > Int32FromInt32(0x3ff)+Int32FromInt32(510) {
		z = float64(5.260135901548374e+210)
		x *= float64(1.90109156629516e-211)
		y *= float64(1.90109156629516e-211)
	} else {
		if ey < Int32FromInt32(0x3ff)-Int32FromInt32(450) {
			z = float64(1.90109156629516e-211)
			x *= float64(5.260135901548374e+210)
			y *= float64(5.260135901548374e+210)
		}
	}
	_sq(tls, bp+16, bp+24, x)
	_sq(tls, bp+32, bp+40, y)
	return z * Xsqrt(tls, *(*Tdouble_t)(unsafe.Pointer(bp + 40))+*(*Tdouble_t)(unsafe.Pointer(bp + 24))+*(*Tdouble_t)(unsafe.Pointer(bp + 32))+*(*Tdouble_t)(unsafe.Pointer(bp + 16)))
}

func Xhypotf(tls *TLS, x float32, y float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ut struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var z Tfloat_t
	var _ /* ux at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _ = ut, z
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 4)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 4)) = y
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= -Uint32FromUint32(1) >> Int32FromInt32(1)
	*(*Tuint32_t)(unsafe.Pointer(bp + 4)) &= -Uint32FromUint32(1) >> Int32FromInt32(1)
	if *(*Tuint32_t)(unsafe.Pointer(bp)) < *(*Tuint32_t)(unsafe.Pointer(bp + 4)) {
		ut = *(*struct {
			Fi [0]Tuint32_t
			Ff float32
		})(unsafe.Pointer(bp))
		*(*struct {
			Fi [0]Tuint32_t
			Ff float32
		})(unsafe.Pointer(bp)) = *(*struct {
			Fi [0]Tuint32_t
			Ff float32
		})(unsafe.Pointer(bp + 4))
		*(*struct {
			Fi [0]Tuint32_t
			Ff float32
		})(unsafe.Pointer(bp + 4)) = ut
	}
	x = *(*float32)(unsafe.Pointer(bp))
	y = *(*float32)(unsafe.Pointer(bp + 4))
	if *(*Tuint32_t)(unsafe.Pointer(bp + 4)) == uint32(Int32FromInt32(0xff)<<Int32FromInt32(23)) {
		return y
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp)) >= uint32(Int32FromInt32(0xff)<<Int32FromInt32(23)) || *(*Tuint32_t)(unsafe.Pointer(bp + 4)) == uint32(0) || *(*Tuint32_t)(unsafe.Pointer(bp))-*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >= uint32(Int32FromInt32(25)<<Int32FromInt32(23)) {
		return x + y
	}
	z = Float32FromInt32(1)
	if *(*Tuint32_t)(unsafe.Pointer(bp)) >= uint32((Int32FromInt32(0x7f)+Int32FromInt32(60))<<Int32FromInt32(23)) {
		z = Float32FromFloat32(1.2379400392853803e+27)
		x *= Float32FromFloat32(8.077935669463161e-28)
		y *= Float32FromFloat32(8.077935669463161e-28)
	} else {
		if *(*Tuint32_t)(unsafe.Pointer(bp + 4)) < uint32((Int32FromInt32(0x7f)-Int32FromInt32(60))<<Int32FromInt32(23)) {
			z = Float32FromFloat32(8.077935669463161e-28)
			x *= Float32FromFloat32(1.2379400392853803e+27)
			y *= Float32FromFloat32(1.2379400392853803e+27)
		}
	}
	return z * Xsqrtf(tls, float32(float64(x)*float64(x)+float64(y)*float64(y)))
}

func Xhypotl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xhypot(tls, x, y)
}

func Xilogb(tls *TLS, x3 float64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, v2 int32
	var i Tuint64_t
	var y float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _ = e, i, y, y1, y2, v2
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	i = *(*Tuint64_t)(unsafe.Pointer(bp))
	e = int32(i >> int32(52) & uint64(0x7ff))
	if !(e != 0) {
		i <<= uint64(12)
		if i == uint64(0) {
			if uint64(4) == uint64(4) {
				y = Float32FromInt32(0) / Float32FromFloat32(0)
			} else {
				if uint64(4) == uint64(8) {
					y1 = float64(Float32FromInt32(0) / Float32FromFloat32(0))
				} else {
					y2 = float64(Float32FromInt32(0) / Float32FromFloat32(0))
				}
			}
			return -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
		}
		/* subnormal x */
		e = -int32(0x3ff)
		for {
			if !(i>>int32(63) == uint64(0)) {
				break
			}
			goto _1
		_1:
			;
			e--
			i <<= uint64(1)
		}
		return e
	}
	if e == int32(0x7ff) {
		if uint64(4) == uint64(4) {
			y = Float32FromInt32(0) / Float32FromFloat32(0)
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(Float32FromInt32(0) / Float32FromFloat32(0))
			} else {
				y2 = float64(Float32FromInt32(0) / Float32FromFloat32(0))
			}
		}
		if i<<int32(12) != 0 {
			v2 = -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
		} else {
			v2 = int32(INT_MAX)
		}
		return v2
	}
	return e - int32(0x3ff)
}

func Xilogbf(tls *TLS, x3 float32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, v2 int32
	var i Tuint32_t
	var y float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _ = e, i, y, y1, y2, v2
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	i = *(*Tuint32_t)(unsafe.Pointer(bp))
	e = int32(i >> int32(23) & uint32(0xff))
	if !(e != 0) {
		i <<= uint32(9)
		if i == uint32(0) {
			if uint64(4) == uint64(4) {
				y = Float32FromInt32(0) / Float32FromFloat32(0)
			} else {
				if uint64(4) == uint64(8) {
					y1 = float64(Float32FromInt32(0) / Float32FromFloat32(0))
				} else {
					y2 = float64(Float32FromInt32(0) / Float32FromFloat32(0))
				}
			}
			return -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
		}
		/* subnormal x */
		e = -int32(0x7f)
		for {
			if !(i>>int32(31) == uint32(0)) {
				break
			}
			goto _1
		_1:
			;
			e--
			i <<= uint32(1)
		}
		return e
	}
	if e == int32(0xff) {
		if uint64(4) == uint64(4) {
			y = Float32FromInt32(0) / Float32FromFloat32(0)
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(Float32FromInt32(0) / Float32FromFloat32(0))
			} else {
				y2 = float64(Float32FromInt32(0) / Float32FromFloat32(0))
			}
		}
		if i<<int32(9) != 0 {
			v2 = -Int32FromInt32(1) - Int32FromInt32(0x7fffffff)
		} else {
			v2 = int32(INT_MAX)
		}
		return v2
	}
	return e - int32(0x7f)
}

func Xilogbl(tls *TLS, x float64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xilogb(tls, x)
}

var _invsqrtpi = float64(0.5641895835477563) /* 0x3FE20DD7, 0x50429B6D */
var _tpi = float64(0.6366197723675814)       /* 0x3FE45F30, 0x6DC9C883 */

// C documentation
//
//	/* common method when |x|>=2 */
func _common(tls *TLS, ix Tuint32_t, x float64, y0 int32) (r float64) {
	var c, cc, s, ss, z float64
	_, _, _, _, _ = c, cc, s, ss, z
	/*
	 * j0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x-pi/4)-q0(x)*sin(x-pi/4))
	 * y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x-pi/4)+q0(x)*cos(x-pi/4))
	 *
	 * sin(x-pi/4) = (sin(x) - cos(x))/sqrt(2)
	 * cos(x-pi/4) = (sin(x) + cos(x))/sqrt(2)
	 * sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
	 */
	s = Xsin(tls, x)
	c = Xcos(tls, x)
	if y0 != 0 {
		c = -c
	}
	cc = s + c
	/* avoid overflow in 2*x, big ulp error when x>=0x1p1023 */
	if ix < uint32(0x7fe00000) {
		ss = s - c
		z = -Xcos(tls, Float64FromInt32(2)*x)
		if s*c < Float64FromInt32(0) {
			cc = z / ss
		} else {
			ss = z / cc
		}
		if ix < uint32(0x48000000) {
			if y0 != 0 {
				ss = -ss
			}
			cc = _pzero(tls, x)*cc - _qzero(tls, x)*ss
		}
	}
	return _invsqrtpi * cc / Xsqrt(tls, x)
}

// C documentation
//
//	/* R0/S0 on [0, 2.00] */

var _R02 = float64(0.015624999999999995)               /* 0x3F8FFFFF, 0xFFFFFFFD */
var _R03 = -Float64FromFloat64(0.00018997929423885472) /* 0xBF28E6A5, 0xB61AC6E9 */
var _R04 = float64(1.8295404953270067e-06)             /* 0x3EBEB1D1, 0x0C503919 */
var _R05 = -Float64FromFloat64(4.618326885321032e-09)  /* 0xBE33D5E7, 0x73D63FCE */
var _S01 = float64(0.015619102946489001)               /* 0x3F8FFCE8, 0x82C8C2A4 */
var _S02 = float64(0.00011692678466333745)             /* 0x3F1EA6D2, 0xDD57DBF4 */
var _S03 = float64(5.135465502073181e-07)              /* 0x3EA13B54, 0xCE84D5A9 */
var _S04 = float64(1.1661400333379e-09)                /* 0x3E1408BC, 0xF4745D8F */

func Xj0(tls *TLS, x float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ix Tuint32_t
	var r, s, z float64
	_, _, _, _ = ix, r, s, z
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	ix &= uint32(0x7fffffff)
	/* j0(+-inf)=0, j0(nan)=nan */
	if ix >= uint32(0x7ff00000) {
		return Float64FromInt32(1) / (x * x)
	}
	x = Xfabs(tls, x)
	if ix >= uint32(0x40000000) { /* |x| >= 2 */
		/* large ulp error near zeros: 2.4, 5.52, 8.6537,.. */
		return _common(tls, ix, x, 0)
	}
	/* 1 - x*x/4 + x*x*R(x^2)/S(x^2) */
	if ix >= uint32(0x3f200000) { /* |x| >= 2**-13 */
		/* up to 4ulp error close to 2 */
		z = x * x
		r = z * (_R02 + z*(_R03+z*(_R04+z*_R05)))
		s = Float64FromInt32(1) + z*(_S01+z*(_S02+z*(_S03+z*_S04)))
		return (Float64FromInt32(1)+x/Float64FromInt32(2))*(Float64FromInt32(1)-x/Float64FromInt32(2)) + z*(r/s)
	}
	/* 1 - x*x/4 */
	/* prevent underflow */
	/* inexact should be raised when x!=0, this is not done correctly */
	if ix >= uint32(0x38000000) { /* |x| >= 2**-127 */
		x = float64(0.25) * x * x
	}
	return Float64FromInt32(1) - x
}

var _u00 = -Float64FromFloat64(0.07380429510868723)    /* 0xBFB2E4D6, 0x99CBD01F */
var _u01 = float64(0.17666645250918112)                /* 0x3FC69D01, 0x9DE9E3FC */
var _u02 = -Float64FromFloat64(0.01381856719455969)    /* 0xBF8C4CE8, 0xB16CFA97 */
var _u03 = float64(0.00034745343209368365)             /* 0x3F36C54D, 0x20B29B6B */
var _u04 = -Float64FromFloat64(3.8140705372436416e-06) /* 0xBECFFEA7, 0x73D25CAD */
var _u05 = float64(1.9559013703502292e-08)             /* 0x3E550057, 0x3B4EABD4 */
var _u06 = -Float64FromFloat64(3.982051941321034e-11)  /* 0xBDC5E43D, 0x693FB3C8 */
var _v01 = float64(0.01273048348341237)                /* 0x3F8A1270, 0x91C9C71A */
var _v02 = float64(7.600686273503533e-05)              /* 0x3F13ECBB, 0xF578C6C1 */
var _v03 = float64(2.591508518404578e-07)              /* 0x3E91642D, 0x7FF202FD */
var _v04 = float64(4.4111031133267547e-10)             /* 0x3DFE5018, 0x3BD6D9EF */

func Xy0(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __u Tuint64_t
	var ix, lx Tuint32_t
	var u, v, z float64
	_, _, _, _, _, _ = __u, ix, lx, u, v, z
	__u = *(*Tuint64_t)(unsafe.Pointer(&x))
	ix = uint32(__u >> int32(32))
	lx = uint32(__u)
	/* y0(nan)=nan, y0(<0)=nan, y0(0)=-inf, y0(inf)=0 */
	if ix<<int32(1)|lx == uint32(0) {
		return float64(-Int32FromInt32(1)) / Float64FromFloat64(0)
	}
	if ix>>int32(31) != 0 {
		return Float64FromInt32(0) / Float64FromFloat64(0)
	}
	if ix >= uint32(0x7ff00000) {
		return Float64FromInt32(1) / x
	}
	if ix >= uint32(0x40000000) { /* x >= 2 */
		/* large ulp errors near zeros: 3.958, 7.086,.. */
		return _common(tls, ix, x, int32(1))
	}
	/* U(x^2)/V(x^2) + (2/pi)*j0(x)*log(x) */
	if ix >= uint32(0x3e400000) { /* x >= 2**-27 */
		/* large ulp error near the first zero, x ~= 0.89 */
		z = x * x
		u = _u00 + z*(_u01+z*(_u02+z*(_u03+z*(_u04+z*(_u05+z*_u06)))))
		v = float64(1) + z*(_v01+z*(_v02+z*(_v03+z*_v04)))
		return u/v + _tpi*(Xj0(tls, x)*Xlog(tls, x))
	}
	return _u00 + _tpi*Xlog(tls, x)
}

// C documentation
//
//	/* The asymptotic expansions of pzero is
//	 *      1 - 9/128 s^2 + 11025/98304 s^4 - ...,  where s = 1/x.
//	 * For x >= 2, We approximate pzero by
//	 *      pzero(x) = 1 + (R/S)
//	 * where  R = pR0 + pR1*s^2 + pR2*s^4 + ... + pR5*s^10
//	 *        S = 1 + pS0*s^2 + ... + pS4*s^10
//	 * and
//	 *      | pzero(x)-1-R/S | <= 2  ** ( -60.26)
//	 */
var _pR8 = [6]float64{
	1: -Float64FromFloat64(0.07031249999999004),
	2: -Float64FromFloat64(8.081670412753498),
	3: -Float64FromFloat64(257.06310567970485),
	4: -Float64FromFloat64(2485.216410094288),
	5: -Float64FromFloat64(5253.043804907295),
}
var _pS8 = [5]float64{
	0: float64(116.53436461966818),
	1: float64(3833.7447536412183),
	2: float64(40597.857264847255),
	3: float64(116752.97256437592),
	4: float64(47627.728414673096),
}

var _pR5 = [6]float64{
	0: -Float64FromFloat64(1.141254646918945e-11),
	1: -Float64FromFloat64(0.07031249408735993),
	2: -Float64FromFloat64(4.159610644705878),
	3: -Float64FromFloat64(67.67476522651673),
	4: -Float64FromFloat64(331.23129964917297),
	5: -Float64FromFloat64(346.4333883656049),
}
var _pS52 = [5]float64{
	0: float64(60.753938269230034),
	1: float64(1051.2523059570458),
	2: float64(5978.970943338558),
	3: float64(9625.445143577745),
	4: float64(2406.058159229391),
}

var _pR3 = [6]float64{
	0: -Float64FromFloat64(2.547046017719519e-09),
	1: -Float64FromFloat64(0.07031196163814817),
	2: -Float64FromFloat64(2.409032215495296),
	3: -Float64FromFloat64(21.96597747348831),
	4: -Float64FromFloat64(58.07917047017376),
	5: -Float64FromFloat64(31.44794705948885),
}
var _pS32 = [5]float64{
	0: float64(35.85603380552097),
	1: float64(361.51398305030386),
	2: float64(1193.6078379211153),
	3: float64(1127.9967985690741),
	4: float64(173.58093081333575),
}

var _pR2 = [6]float64{
	0: -Float64FromFloat64(8.875343330325264e-08),
	1: -Float64FromFloat64(0.07030309954836247),
	2: -Float64FromFloat64(1.4507384678095299),
	3: -Float64FromFloat64(7.635696138235278),
	4: -Float64FromFloat64(11.193166886035675),
	5: -Float64FromFloat64(3.2336457935133534),
}
var _pS24 = [5]float64{
	0: float64(22.22029975320888),
	1: float64(136.2067942182152),
	2: float64(270.4702786580835),
	3: float64(153.87539420832033),
	4: float64(14.65761769482562),
}

func _pzero(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var p, q uintptr
	var r, s, z Tdouble_t
	_, _, _, _, _, _ = ix, p, q, r, s, z
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x40200000) {
		p = uintptr(unsafe.Pointer(&_pR8))
		q = uintptr(unsafe.Pointer(&_pS8))
	} else {
		if ix >= uint32(0x40122E8B) {
			p = uintptr(unsafe.Pointer(&_pR5))
			q = uintptr(unsafe.Pointer(&_pS52))
		} else {
			if ix >= uint32(0x4006DB6D) {
				p = uintptr(unsafe.Pointer(&_pR3))
				q = uintptr(unsafe.Pointer(&_pS32))
			} else { /*ix >= 0x40000000*/
				p = uintptr(unsafe.Pointer(&_pR2))
				q = uintptr(unsafe.Pointer(&_pS24))
			}
		}
	}
	z = float64(1) / (x * x)
	r = *(*float64)(unsafe.Pointer(p)) + z*(*(*float64)(unsafe.Pointer(p + 1*8))+z*(*(*float64)(unsafe.Pointer(p + 2*8))+z*(*(*float64)(unsafe.Pointer(p + 3*8))+z*(*(*float64)(unsafe.Pointer(p + 4*8))+z**(*float64)(unsafe.Pointer(p + 5*8))))))
	s = float64(1) + z*(*(*float64)(unsafe.Pointer(q))+z*(*(*float64)(unsafe.Pointer(q + 1*8))+z*(*(*float64)(unsafe.Pointer(q + 2*8))+z*(*(*float64)(unsafe.Pointer(q + 3*8))+z**(*float64)(unsafe.Pointer(q + 4*8))))))
	return float64(1) + r/s
}

// C documentation
//
//	/* For x >= 8, the asymptotic expansions of qzero is
//	 *      -1/8 s + 75/1024 s^3 - ..., where s = 1/x.
//	 * We approximate pzero by
//	 *      qzero(x) = s*(-1.25 + (R/S))
//	 * where  R = qR0 + qR1*s^2 + qR2*s^4 + ... + qR5*s^10
//	 *        S = 1 + qS0*s^2 + ... + qS5*s^12
//	 * and
//	 *      | qzero(x)/s +1.25-R/S | <= 2  ** ( -61.22)
//	 */
var _qR8 = [6]float64{
	1: float64(0.0732421874999935),
	2: float64(11.76820646822527),
	3: float64(557.6733802564019),
	4: float64(8859.197207564686),
	5: float64(37014.62677768878),
}
var _qS8 = [6]float64{
	0: float64(163.77602689568982),
	1: float64(8098.344946564498),
	2: float64(142538.29141912048),
	3: float64(803309.2571195144),
	4: float64(840501.5798190605),
	5: -Float64FromFloat64(343899.2935378666),
}

var _qR5 = [6]float64{
	0: float64(1.8408596359451553e-11),
	1: float64(0.07324217666126848),
	2: float64(5.8356350896205695),
	3: float64(135.11157728644983),
	4: float64(1027.243765961641),
	5: float64(1989.9778586460538),
}
var _qS5 = [6]float64{
	0: float64(82.77661022365378),
	1: float64(2077.81416421393),
	2: float64(18847.28877857181),
	3: float64(56751.11228949473),
	4: float64(35976.75384251145),
	5: -Float64FromFloat64(5354.342756019448),
}

var _qR3 = [6]float64{
	0: float64(4.377410140897386e-09),
	1: float64(0.07324111800429114),
	2: float64(3.344231375161707),
	3: float64(42.621844074541265),
	4: float64(170.8080913405656),
	5: float64(166.73394869665117),
}
var _qS32 = [6]float64{
	0: float64(48.75887297245872),
	1: float64(709.689221056606),
	2: float64(3704.1482262011136),
	3: float64(6460.425167525689),
	4: float64(2516.3336892036896),
	5: -Float64FromFloat64(149.2474518361564),
}

var _qR2 = [6]float64{
	0: float64(1.5044444488698327e-07),
	1: float64(0.07322342659630793),
	2: float64(1.99819174093816),
	3: float64(14.495602934788574),
	4: float64(31.666231750478154),
	5: float64(16.252707571092927),
}
var _qS22 = [6]float64{
	0: float64(30.36558483552192),
	1: float64(269.34811860804984),
	2: float64(844.7837575953201),
	3: float64(882.9358451124886),
	4: float64(212.66638851179883),
	5: -Float64FromFloat64(5.3109549388266695),
}

func _qzero(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var p, q uintptr
	var r, s, z Tdouble_t
	_, _, _, _, _, _ = ix, p, q, r, s, z
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x40200000) {
		p = uintptr(unsafe.Pointer(&_qR8))
		q = uintptr(unsafe.Pointer(&_qS8))
	} else {
		if ix >= uint32(0x40122E8B) {
			p = uintptr(unsafe.Pointer(&_qR5))
			q = uintptr(unsafe.Pointer(&_qS5))
		} else {
			if ix >= uint32(0x4006DB6D) {
				p = uintptr(unsafe.Pointer(&_qR3))
				q = uintptr(unsafe.Pointer(&_qS32))
			} else { /*ix >= 0x40000000*/
				p = uintptr(unsafe.Pointer(&_qR2))
				q = uintptr(unsafe.Pointer(&_qS22))
			}
		}
	}
	z = float64(1) / (x * x)
	r = *(*float64)(unsafe.Pointer(p)) + z*(*(*float64)(unsafe.Pointer(p + 1*8))+z*(*(*float64)(unsafe.Pointer(p + 2*8))+z*(*(*float64)(unsafe.Pointer(p + 3*8))+z*(*(*float64)(unsafe.Pointer(p + 4*8))+z**(*float64)(unsafe.Pointer(p + 5*8))))))
	s = float64(1) + z*(*(*float64)(unsafe.Pointer(q))+z*(*(*float64)(unsafe.Pointer(q + 1*8))+z*(*(*float64)(unsafe.Pointer(q + 2*8))+z*(*(*float64)(unsafe.Pointer(q + 3*8))+z*(*(*float64)(unsafe.Pointer(q + 4*8))+z**(*float64)(unsafe.Pointer(q + 5*8)))))))
	return (-Float64FromFloat64(0.125) + r/s) / x
}

var _invsqrtpi1 = float32(0.56418961287) /* 0x3f106ebb */
var _tpi1 = float32(0.63661974669)       /* 0x3f22f983 */

func _common1(tls *TLS, ix Tuint32_t, x float32, y0 int32) (r float32) {
	var c, cc, s, ss, z float32
	_, _, _, _, _ = c, cc, s, ss, z
	/*
	 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
	 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
	 */
	s = Xsinf(tls, x)
	c = Xcosf(tls, x)
	if y0 != 0 {
		c = -c
	}
	cc = s + c
	if ix < uint32(0x7f000000) {
		ss = s - c
		z = -Xcosf(tls, Float32FromInt32(2)*x)
		if s*c < Float32FromInt32(0) {
			cc = z / ss
		} else {
			ss = z / cc
		}
		if ix < uint32(0x58800000) {
			if y0 != 0 {
				ss = -ss
			}
			cc = _pzerof(tls, x)*cc - _qzerof(tls, x)*ss
		}
	}
	return _invsqrtpi1 * cc / Xsqrtf(tls, x)
}

// C documentation
//
//	/* R0/S0 on [0, 2.00] */

var _R021 = float32(0.015625)                              /* 0x3c800000 */
var _R031 = float32(-Float64FromFloat64(0.00018997929874)) /* 0xb947352e */
var _R041 = float32(1.8295404516e-06)                      /* 0x35f58e88 */
var _R051 = float32(-Float64FromFloat64(4.6183270541e-09)) /* 0xb19eaf3c */
var _S011 = float32(0.015619102865)                        /* 0x3c7fe744 */
var _S021 = float32(0.00011692678527)                      /* 0x38f53697 */
var _S031 = float32(5.1354652442e-07)                      /* 0x3509daa6 */
var _S041 = float32(1.1661400734e-09)                      /* 0x30a045e8 */

func Xj0f(tls *TLS, x float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ix Tuint32_t
	var r, s, z float32
	_, _, _, _ = ix, r, s, z
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		return Float32FromInt32(1) / (x * x)
	}
	x = Xfabsf(tls, x)
	if ix >= uint32(0x40000000) { /* |x| >= 2 */
		/* large ulp error near zeros */
		return _common1(tls, ix, x, 0)
	}
	if ix >= uint32(0x3a000000) { /* |x| >= 2**-11 */
		/* up to 4ulp error near 2 */
		z = x * x
		r = z * (_R021 + z*(_R031+z*(_R041+z*_R051)))
		s = Float32FromInt32(1) + z*(_S011+z*(_S021+z*(_S031+z*_S041)))
		return (Float32FromInt32(1)+x/Float32FromInt32(2))*(Float32FromInt32(1)-x/Float32FromInt32(2)) + z*(r/s)
	}
	if ix >= uint32(0x21800000) { /* |x| >= 2**-60 */
		x = Float32FromFloat32(0.25) * x * x
	}
	return Float32FromInt32(1) - x
}

var _u001 = float32(-Float64FromFloat64(0.073804296553))   /* 0xbd9726b5 */
var _u011 = float32(0.17666645348)                         /* 0x3e34e80d */
var _u021 = float32(-Float64FromFloat64(0.013818567619))   /* 0xbc626746 */
var _u031 = float32(0.00034745343146)                      /* 0x39b62a69 */
var _u041 = float32(-Float64FromFloat64(3.8140706238e-06)) /* 0xb67ff53c */
var _u051 = float32(1.9559013964e-08)                      /* 0x32a802ba */
var _u061 = float32(-Float64FromFloat64(3.982051841e-11))  /* 0xae2f21eb */
var _v011 = float32(0.012730483897)                        /* 0x3c509385 */
var _v021 = float32(7.6006865129e-05)                      /* 0x389f65e0 */
var _v031 = float32(2.5915085189e-07)                      /* 0x348b216c */
var _v041 = float32(4.4111031494e-10)                      /* 0x2ff280c2 */

func Xy0f(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ix Tuint32_t
	var u, v, z float32
	_, _, _, _ = ix, u, v, z
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	if ix&uint32(0x7fffffff) == uint32(0) {
		return float32(-Int32FromInt32(1)) / Float32FromFloat32(0)
	}
	if ix>>int32(31) != 0 {
		return Float32FromInt32(0) / Float32FromFloat32(0)
	}
	if ix >= uint32(0x7f800000) {
		return Float32FromInt32(1) / x
	}
	if ix >= uint32(0x40000000) { /* |x| >= 2.0 */
		/* large ulp error near zeros */
		return _common1(tls, ix, x, int32(1))
	}
	if ix >= uint32(0x39000000) { /* x >= 2**-13 */
		/* large ulp error at x ~= 0.89 */
		z = x * x
		u = _u001 + z*(_u011+z*(_u021+z*(_u031+z*(_u041+z*(_u051+z*_u061)))))
		v = Float32FromInt32(1) + z*(_v011+z*(_v021+z*(_v031+z*_v041)))
		return u/v + _tpi1*(Xj0f(tls, x)*Xlogf(tls, x))
	}
	return _u001 + _tpi1*Xlogf(tls, x)
}

// C documentation
//
//	/* The asymptotic expansions of pzero is
//	 *      1 - 9/128 s^2 + 11025/98304 s^4 - ...,  where s = 1/x.
//	 * For x >= 2, We approximate pzero by
//	 *      pzero(x) = 1 + (R/S)
//	 * where  R = pR0 + pR1*s^2 + pR2*s^4 + ... + pR5*s^10
//	 *        S = 1 + pS0*s^2 + ... + pS4*s^10
//	 * and
//	 *      | pzero(x)-1-R/S | <= 2  ** ( -60.26)
//	 */
var _pR81 = [6]float32{
	1: float32(-Float64FromFloat64(0.0703125)),
	2: float32(-Float64FromFloat64(8.0816707611)),
	3: float32(-Float64FromFloat64(257.06311035)),
	4: float32(-Float64FromFloat64(2485.2163086)),
	5: float32(-Float64FromFloat64(5253.0439453)),
}
var _pS81 = [5]float32{
	0: float32(116.53436279),
	1: float32(3833.744873),
	2: float32(40597.855469),
	3: float32(116752.96875),
	4: float32(47627.726562),
}
var _pR51 = [6]float32{
	0: float32(-Float64FromFloat64(1.1412546255e-11)),
	1: float32(-Float64FromFloat64(0.070312492549)),
	2: float32(-Float64FromFloat64(4.1596107483)),
	3: float32(-Float64FromFloat64(67.674766541)),
	4: float32(-Float64FromFloat64(331.23129272)),
	5: float32(-Float64FromFloat64(346.43338013)),
}
var _pS53 = [5]float32{
	0: float32(60.753936768),
	1: float32(1051.2523193),
	2: float32(5978.9707031),
	3: float32(9625.4453125),
	4: float32(2406.0581055),
}

var _pR31 = [6]float32{
	0: float32(-Float64FromFloat64(2.5470459075e-09)),
	1: float32(-Float64FromFloat64(0.070311963558)),
	2: float32(-Float64FromFloat64(2.4090321064)),
	3: float32(-Float64FromFloat64(21.965976715)),
	4: float32(-Float64FromFloat64(58.079170227)),
	5: float32(-Float64FromFloat64(31.447946548)),
}
var _pS33 = [5]float32{
	0: float32(35.856033325),
	1: float32(361.51397705),
	2: float32(1193.6077881),
	3: float32(1127.9968262),
	4: float32(173.58093262),
}

var _pR21 = [6]float32{
	0: float32(-Float64FromFloat64(8.8753431271e-08)),
	1: float32(-Float64FromFloat64(0.070303097367)),
	2: float32(-Float64FromFloat64(1.45073843)),
	3: float32(-Float64FromFloat64(7.6356959343)),
	4: float32(-Float64FromFloat64(11.193166733)),
	5: float32(-Float64FromFloat64(3.2336456776)),
}
var _pS25 = [5]float32{
	0: float32(22.220300674),
	1: float32(136.20678711),
	2: float32(270.47027588),
	3: float32(153.87539673),
	4: float32(14.657617569),
}

func _pzerof(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var p, q uintptr
	var r, s, z Tfloat_t
	_, _, _, _, _, _ = ix, p, q, r, s, z
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x41000000) {
		p = uintptr(unsafe.Pointer(&_pR81))
		q = uintptr(unsafe.Pointer(&_pS81))
	} else {
		if ix >= uint32(0x409173eb) {
			p = uintptr(unsafe.Pointer(&_pR51))
			q = uintptr(unsafe.Pointer(&_pS53))
		} else {
			if ix >= uint32(0x4036d917) {
				p = uintptr(unsafe.Pointer(&_pR31))
				q = uintptr(unsafe.Pointer(&_pS33))
			} else { /*ix >= 0x40000000*/
				p = uintptr(unsafe.Pointer(&_pR21))
				q = uintptr(unsafe.Pointer(&_pS25))
			}
		}
	}
	z = Float32FromFloat32(1) / (x * x)
	r = *(*float32)(unsafe.Pointer(p)) + z*(*(*float32)(unsafe.Pointer(p + 1*4))+z*(*(*float32)(unsafe.Pointer(p + 2*4))+z*(*(*float32)(unsafe.Pointer(p + 3*4))+z*(*(*float32)(unsafe.Pointer(p + 4*4))+z**(*float32)(unsafe.Pointer(p + 5*4))))))
	s = Float32FromFloat32(1) + z*(*(*float32)(unsafe.Pointer(q))+z*(*(*float32)(unsafe.Pointer(q + 1*4))+z*(*(*float32)(unsafe.Pointer(q + 2*4))+z*(*(*float32)(unsafe.Pointer(q + 3*4))+z**(*float32)(unsafe.Pointer(q + 4*4))))))
	return Float32FromFloat32(1) + r/s
}

// C documentation
//
//	/* For x >= 8, the asymptotic expansions of qzero is
//	 *      -1/8 s + 75/1024 s^3 - ..., where s = 1/x.
//	 * We approximate pzero by
//	 *      qzero(x) = s*(-1.25 + (R/S))
//	 * where  R = qR0 + qR1*s^2 + qR2*s^4 + ... + qR5*s^10
//	 *        S = 1 + qS0*s^2 + ... + qS5*s^12
//	 * and
//	 *      | qzero(x)/s +1.25-R/S | <= 2  ** ( -61.22)
//	 */
var _qR81 = [6]float32{
	1: float32(0.0732421875),
	2: float32(11.768206596),
	3: float32(557.67340088),
	4: float32(8859.1972656),
	5: float32(37014.625),
}
var _qS81 = [6]float32{
	0: float32(163.77603149),
	1: float32(8098.3447266),
	2: float32(142538.29688),
	3: float32(803309.25),
	4: float32(840501.5625),
	5: float32(-Float64FromFloat64(343899.28125)),
}

var _qR51 = [6]float32{
	0: float32(1.8408595828e-11),
	1: float32(0.073242180049),
	2: float32(5.8356351852),
	3: float32(135.11157227),
	4: float32(1027.2437744),
	5: float32(1989.9779053),
}
var _qS51 = [6]float32{
	0: float32(82.776611328),
	1: float32(2077.814209),
	2: float32(18847.289062),
	3: float32(56751.113281),
	4: float32(35976.753906),
	5: float32(-Float64FromFloat64(5354.3427734)),
}

var _qR31 = [6]float32{
	0: float32(4.37740999e-09),
	1: float32(0.073241114616),
	2: float32(3.3442313671),
	3: float32(42.621845245),
	4: float32(170.80809021),
	5: float32(166.73394775),
}
var _qS33 = [6]float32{
	0: float32(48.758872986),
	1: float32(709.68920898),
	2: float32(3704.1481934),
	3: float32(6460.425293),
	4: float32(2516.3337402),
	5: float32(-Float64FromFloat64(149.24745178)),
}

var _qR21 = [6]float32{
	0: float32(1.5044444979e-07),
	1: float32(0.073223426938),
	2: float32(1.9981917143),
	3: float32(14.495602608),
	4: float32(31.666231155),
	5: float32(16.252708435),
}
var _qS23 = [6]float32{
	0: float32(30.365585327),
	1: float32(269.34811401),
	2: float32(844.78375244),
	3: float32(882.93585205),
	4: float32(212.66638184),
	5: float32(-Float64FromFloat64(5.3109550476)),
}

func _qzerof(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var p, q uintptr
	var r, s, z Tfloat_t
	_, _, _, _, _, _ = ix, p, q, r, s, z
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x41000000) {
		p = uintptr(unsafe.Pointer(&_qR81))
		q = uintptr(unsafe.Pointer(&_qS81))
	} else {
		if ix >= uint32(0x409173eb) {
			p = uintptr(unsafe.Pointer(&_qR51))
			q = uintptr(unsafe.Pointer(&_qS51))
		} else {
			if ix >= uint32(0x4036d917) {
				p = uintptr(unsafe.Pointer(&_qR31))
				q = uintptr(unsafe.Pointer(&_qS33))
			} else { /*ix >= 0x40000000*/
				p = uintptr(unsafe.Pointer(&_qR21))
				q = uintptr(unsafe.Pointer(&_qS23))
			}
		}
	}
	z = Float32FromFloat32(1) / (x * x)
	r = *(*float32)(unsafe.Pointer(p)) + z*(*(*float32)(unsafe.Pointer(p + 1*4))+z*(*(*float32)(unsafe.Pointer(p + 2*4))+z*(*(*float32)(unsafe.Pointer(p + 3*4))+z*(*(*float32)(unsafe.Pointer(p + 4*4))+z**(*float32)(unsafe.Pointer(p + 5*4))))))
	s = Float32FromFloat32(1) + z*(*(*float32)(unsafe.Pointer(q))+z*(*(*float32)(unsafe.Pointer(q + 1*4))+z*(*(*float32)(unsafe.Pointer(q + 2*4))+z*(*(*float32)(unsafe.Pointer(q + 3*4))+z*(*(*float32)(unsafe.Pointer(q + 4*4))+z**(*float32)(unsafe.Pointer(q + 5*4)))))))
	return (-Float32FromFloat32(0.125) + r/s) / x
}

var _invsqrtpi2 = float64(0.5641895835477563) /* 0x3FE20DD7, 0x50429B6D */
var _tpi2 = float64(0.6366197723675814)       /* 0x3FE45F30, 0x6DC9C883 */

func _common2(tls *TLS, ix Tuint32_t, x float64, y1 int32, sign int32) (r float64) {
	var c, cc, s, ss, z float64
	_, _, _, _, _ = c, cc, s, ss, z
	/*
	 * j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x-3pi/4)-q1(x)*sin(x-3pi/4))
	 * y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x-3pi/4)+q1(x)*cos(x-3pi/4))
	 *
	 * sin(x-3pi/4) = -(sin(x) + cos(x))/sqrt(2)
	 * cos(x-3pi/4) = (sin(x) - cos(x))/sqrt(2)
	 * sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
	 */
	s = Xsin(tls, x)
	if y1 != 0 {
		s = -s
	}
	c = Xcos(tls, x)
	cc = s - c
	if ix < uint32(0x7fe00000) {
		/* avoid overflow in 2*x */
		ss = -s - c
		z = Xcos(tls, Float64FromInt32(2)*x)
		if s*c > Float64FromInt32(0) {
			cc = z / ss
		} else {
			ss = z / cc
		}
		if ix < uint32(0x48000000) {
			if y1 != 0 {
				ss = -ss
			}
			cc = _pone(tls, x)*cc - _qone(tls, x)*ss
		}
	}
	if sign != 0 {
		cc = -cc
	}
	return _invsqrtpi2 * cc / Xsqrt(tls, x)
}

// C documentation
//
//	/* R0/S0 on [0,2] */

var _r00 = -Float64FromFloat64(0.0625)                /* 0xBFB00000, 0x00000000 */
var _r01 = float64(0.001407056669551897)              /* 0x3F570D9F, 0x98472C61 */
var _r02 = -Float64FromFloat64(1.599556310840356e-05) /* 0xBEF0C5C6, 0xBA169668 */
var _r03 = float64(4.9672799960958445e-08)            /* 0x3E6AAAFA, 0x46CA0BD9 */
var _s01 = float64(0.019153759953836346)              /* 0x3F939D0B, 0x12637E53 */
var _s02 = float64(0.00018594678558863092)            /* 0x3F285F56, 0xB9CDF664 */
var _s03 = float64(1.1771846404262368e-06)            /* 0x3EB3BFF8, 0x333F8498 */
var _s04 = float64(5.0463625707621704e-09)            /* 0x3E35AC88, 0xC97DFF2C */
var _s05 = float64(1.2354227442613791e-11)            /* 0x3DAB2ACF, 0xCFB97ED8 */

func Xj1(tls *TLS, x float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ix Tuint32_t
	var r, s, z float64
	var sign int32
	_, _, _, _, _ = ix, r, s, sign, z
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x7ff00000) {
		return Float64FromInt32(1) / (x * x)
	}
	if ix >= uint32(0x40000000) { /* |x| >= 2 */
		return _common2(tls, ix, Xfabs(tls, x), 0, sign)
	}
	if ix >= uint32(0x38000000) { /* |x| >= 2**-127 */
		z = x * x
		r = z * (_r00 + z*(_r01+z*(_r02+z*_r03)))
		s = Float64FromInt32(1) + z*(_s01+z*(_s02+z*(_s03+z*(_s04+z*_s05))))
		z = r / s
	} else {
		/* avoid underflow, raise inexact if x!=0 */
		z = x
	}
	return (float64(0.5) + z) * x
}

var _U0 = [5]float64{
	0: -Float64FromFloat64(0.19605709064623894),
	1: float64(0.05044387166398113),
	2: -Float64FromFloat64(0.0019125689587576355),
	3: float64(2.352526005616105e-05),
	4: -Float64FromFloat64(9.190991580398789e-08),
}
var _V0 = [5]float64{
	0: float64(0.01991673182366499),
	1: float64(0.00020255258102513517),
	2: float64(1.3560880109751623e-06),
	3: float64(6.227414523646215e-09),
	4: float64(1.6655924620799208e-11),
}

func Xy1(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __u Tuint64_t
	var ix, lx Tuint32_t
	var u, v, z float64
	_, _, _, _, _, _ = __u, ix, lx, u, v, z
	__u = *(*Tuint64_t)(unsafe.Pointer(&x))
	ix = uint32(__u >> int32(32))
	lx = uint32(__u)
	/* y1(nan)=nan, y1(<0)=nan, y1(0)=-inf, y1(inf)=0 */
	if ix<<int32(1)|lx == uint32(0) {
		return float64(-Int32FromInt32(1)) / Float64FromFloat64(0)
	}
	if ix>>int32(31) != 0 {
		return Float64FromInt32(0) / Float64FromFloat64(0)
	}
	if ix >= uint32(0x7ff00000) {
		return Float64FromInt32(1) / x
	}
	if ix >= uint32(0x40000000) { /* x >= 2 */
		return _common2(tls, ix, x, int32(1), 0)
	}
	if ix < uint32(0x3c900000) { /* x < 2**-54 */
		return -_tpi2 / x
	}
	z = x * x
	u = _U0[0] + z*(_U0[int32(1)]+z*(_U0[int32(2)]+z*(_U0[int32(3)]+z*_U0[int32(4)])))
	v = Float64FromInt32(1) + z*(_V0[0]+z*(_V0[int32(1)]+z*(_V0[int32(2)]+z*(_V0[int32(3)]+z*_V0[int32(4)]))))
	return x*(u/v) + _tpi2*(Xj1(tls, x)*Xlog(tls, x)-Float64FromInt32(1)/x)
}

/* For x >= 8, the asymptotic expansions of pone is
 *      1 + 15/128 s^2 - 4725/2^15 s^4 - ...,   where s = 1/x.
 * We approximate pone by
 *      pone(x) = 1 + (R/S)
 * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10
 *        S = 1 + ps0*s^2 + ... + ps4*s^10
 * and
 *      | pone(x)-1-R/S | <= 2  ** ( -60.06)
 */

var _pr8 = [6]float64{
	1: float64(0.11718749999998865),
	2: float64(13.239480659307358),
	3: float64(412.05185430737856),
	4: float64(3874.7453891396053),
	5: float64(7914.479540318917),
}
var _ps8 = [5]float64{
	0: float64(114.20737037567841),
	1: float64(3650.9308342085346),
	2: float64(36956.206026903346),
	3: float64(97602.79359349508),
	4: float64(30804.27206278888),
}

var _pr5 = [6]float64{
	0: float64(1.3199051955624352e-11),
	1: float64(0.1171874931906141),
	2: float64(6.802751278684329),
	3: float64(108.30818299018911),
	4: float64(517.6361395331998),
	5: float64(528.7152013633375),
}
var _ps5 = [5]float64{
	0: float64(59.28059872211313),
	1: float64(991.4014187336144),
	2: float64(5353.26695291488),
	3: float64(7844.690317495512),
	4: float64(1504.0468881036106),
}

var _pr3 = [6]float64{
	0: float64(3.025039161373736e-09),
	1: float64(0.11718686556725359),
	2: float64(3.9329775003331564),
	3: float64(35.11940355916369),
	4: float64(91.05501107507813),
	5: float64(48.55906851973649),
}
var _ps3 = [5]float64{
	0: float64(34.79130950012515),
	1: float64(336.76245874782575),
	2: float64(1046.8713997577513),
	3: float64(890.8113463982564),
	4: float64(103.78793243963928),
}

var _pr2 = [6]float64{
	0: float64(1.0771083010687374e-07),
	1: float64(0.11717621946268335),
	2: float64(2.368514966676088),
	3: float64(12.242610914826123),
	4: float64(17.693971127168773),
	5: float64(5.073523125888185),
}
var _ps2 = [5]float64{
	0: float64(21.43648593638214),
	1: float64(125.29022716840275),
	2: float64(232.2764690571628),
	3: float64(117.6793732871471),
	4: float64(8.364638933716183),
}

func _pone(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var p, q uintptr
	var r, s, z Tdouble_t
	_, _, _, _, _, _ = ix, p, q, r, s, z
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x40200000) {
		p = uintptr(unsafe.Pointer(&_pr8))
		q = uintptr(unsafe.Pointer(&_ps8))
	} else {
		if ix >= uint32(0x40122E8B) {
			p = uintptr(unsafe.Pointer(&_pr5))
			q = uintptr(unsafe.Pointer(&_ps5))
		} else {
			if ix >= uint32(0x4006DB6D) {
				p = uintptr(unsafe.Pointer(&_pr3))
				q = uintptr(unsafe.Pointer(&_ps3))
			} else { /*ix >= 0x40000000*/
				p = uintptr(unsafe.Pointer(&_pr2))
				q = uintptr(unsafe.Pointer(&_ps2))
			}
		}
	}
	z = float64(1) / (x * x)
	r = *(*float64)(unsafe.Pointer(p)) + z*(*(*float64)(unsafe.Pointer(p + 1*8))+z*(*(*float64)(unsafe.Pointer(p + 2*8))+z*(*(*float64)(unsafe.Pointer(p + 3*8))+z*(*(*float64)(unsafe.Pointer(p + 4*8))+z**(*float64)(unsafe.Pointer(p + 5*8))))))
	s = float64(1) + z*(*(*float64)(unsafe.Pointer(q))+z*(*(*float64)(unsafe.Pointer(q + 1*8))+z*(*(*float64)(unsafe.Pointer(q + 2*8))+z*(*(*float64)(unsafe.Pointer(q + 3*8))+z**(*float64)(unsafe.Pointer(q + 4*8))))))
	return float64(1) + r/s
}

/* For x >= 8, the asymptotic expansions of qone is
 *      3/8 s - 105/1024 s^3 - ..., where s = 1/x.
 * We approximate pone by
 *      qone(x) = s*(0.375 + (R/S))
 * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10
 *        S = 1 + qs1*s^2 + ... + qs6*s^12
 * and
 *      | qone(x)/s -0.375-R/S | <= 2  ** ( -61.13)
 */

var _qr8 = [6]float64{
	1: -Float64FromFloat64(0.10253906249999271),
	2: -Float64FromFloat64(16.271753454459),
	3: -Float64FromFloat64(759.6017225139501),
	4: -Float64FromFloat64(11849.806670242959),
	5: -Float64FromFloat64(48438.512428575035),
}
var _qs8 = [6]float64{
	0: float64(161.3953697007229),
	1: float64(7825.385999233485),
	2: float64(133875.33628724958),
	3: float64(719657.7236832409),
	4: float64(666601.2326177764),
	5: -Float64FromFloat64(294490.26430383464),
}

var _qr5 = [6]float64{
	0: -Float64FromFloat64(2.089799311417641e-11),
	1: -Float64FromFloat64(0.10253905024137543),
	2: -Float64FromFloat64(8.05644828123936),
	3: -Float64FromFloat64(183.66960747488838),
	4: -Float64FromFloat64(1373.1937606550816),
	5: -Float64FromFloat64(2612.4444045321566),
}
var _qs5 = [6]float64{
	0: float64(81.27655013843358),
	1: float64(1991.7987346048596),
	2: float64(17468.48519249089),
	3: float64(49851.42709103523),
	4: float64(27948.075163891812),
	5: -Float64FromFloat64(4719.183547951285),
}

var _qr3 = [6]float64{
	0: -Float64FromFloat64(5.078312264617666e-09),
	1: -Float64FromFloat64(0.10253782982083709),
	2: -Float64FromFloat64(4.610115811394734),
	3: -Float64FromFloat64(57.847221656278364),
	4: -Float64FromFloat64(228.2445407376317),
	5: -Float64FromFloat64(219.21012847890933),
}
var _qs3 = [6]float64{
	0: float64(47.66515503237295),
	1: float64(673.8651126766997),
	2: float64(3380.1528667952634),
	3: float64(5547.729097207228),
	4: float64(1903.119193388108),
	5: -Float64FromFloat64(135.20119144430734),
}

var _qr2 = [6]float64{
	0: -Float64FromFloat64(1.7838172751095887e-07),
	1: -Float64FromFloat64(0.10251704260798555),
	2: -Float64FromFloat64(2.7522056827818746),
	3: -Float64FromFloat64(19.663616264370372),
	4: -Float64FromFloat64(42.32531333728305),
	5: -Float64FromFloat64(21.371921170370406),
}
var _qs2 = [6]float64{
	0: float64(29.533362906052385),
	1: float64(252.98154998219053),
	2: float64(757.5028348686454),
	3: float64(739.3932053204672),
	4: float64(155.94900333666612),
	5: -Float64FromFloat64(4.959498988226282),
}

func _qone(tls *TLS, x float64) (r1 float64) {
	var ix Tuint32_t
	var p, q uintptr
	var r, s, z Tdouble_t
	_, _, _, _, _, _ = ix, p, q, r, s, z
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(32))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x40200000) {
		p = uintptr(unsafe.Pointer(&_qr8))
		q = uintptr(unsafe.Pointer(&_qs8))
	} else {
		if ix >= uint32(0x40122E8B) {
			p = uintptr(unsafe.Pointer(&_qr5))
			q = uintptr(unsafe.Pointer(&_qs5))
		} else {
			if ix >= uint32(0x4006DB6D) {
				p = uintptr(unsafe.Pointer(&_qr3))
				q = uintptr(unsafe.Pointer(&_qs3))
			} else { /*ix >= 0x40000000*/
				p = uintptr(unsafe.Pointer(&_qr2))
				q = uintptr(unsafe.Pointer(&_qs2))
			}
		}
	}
	z = float64(1) / (x * x)
	r = *(*float64)(unsafe.Pointer(p)) + z*(*(*float64)(unsafe.Pointer(p + 1*8))+z*(*(*float64)(unsafe.Pointer(p + 2*8))+z*(*(*float64)(unsafe.Pointer(p + 3*8))+z*(*(*float64)(unsafe.Pointer(p + 4*8))+z**(*float64)(unsafe.Pointer(p + 5*8))))))
	s = float64(1) + z*(*(*float64)(unsafe.Pointer(q))+z*(*(*float64)(unsafe.Pointer(q + 1*8))+z*(*(*float64)(unsafe.Pointer(q + 2*8))+z*(*(*float64)(unsafe.Pointer(q + 3*8))+z*(*(*float64)(unsafe.Pointer(q + 4*8))+z**(*float64)(unsafe.Pointer(q + 5*8)))))))
	return (float64(0.375) + r/s) / x
}

var _invsqrtpi3 = float32(0.56418961287) /* 0x3f106ebb */
var _tpi3 = float32(0.63661974669)       /* 0x3f22f983 */

func _common3(tls *TLS, ix Tuint32_t, x float32, y1 int32, sign int32) (r float32) {
	var c, cc, s, ss, z float64
	_, _, _, _, _ = c, cc, s, ss, z
	s = float64(Xsinf(tls, x))
	if y1 != 0 {
		s = -s
	}
	c = float64(Xcosf(tls, x))
	cc = s - c
	if ix < uint32(0x7f000000) {
		ss = -s - c
		z = float64(Xcosf(tls, Float32FromInt32(2)*x))
		if s*c > Float64FromInt32(0) {
			cc = z / ss
		} else {
			ss = z / cc
		}
		if ix < uint32(0x58800000) {
			if y1 != 0 {
				ss = -ss
			}
			cc = float64(_ponef(tls, x))*cc - float64(_qonef(tls, x))*ss
		}
	}
	if sign != 0 {
		cc = -cc
	}
	return float32(float64(_invsqrtpi3) * cc / float64(Xsqrtf(tls, x)))
}

// C documentation
//
//	/* R0/S0 on [0,2] */

var _r001 = float32(-Float64FromFloat64(0.0625))           /* 0xbd800000 */
var _r011 = float32(0.0014070566976)                       /* 0x3ab86cfd */
var _r021 = float32(-Float64FromFloat64(1.5995563444e-05)) /* 0xb7862e36 */
var _r031 = float32(4.9672799207e-08)                      /* 0x335557d2 */
var _s011 = float32(0.019153760746)                        /* 0x3c9ce859 */
var _s021 = float32(0.00018594678841)                      /* 0x3942fab6 */
var _s031 = float32(1.1771846857e-06)                      /* 0x359dffc2 */
var _s041 = float32(5.046362439e-09)                       /* 0x31ad6446 */
var _s051 = float32(1.2354227016e-11)                      /* 0x2d59567e */

func Xj1f(tls *TLS, x float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ix Tuint32_t
	var r, s, z float32
	var sign int32
	_, _, _, _, _ = ix, r, s, sign, z
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		return Float32FromInt32(1) / (x * x)
	}
	if ix >= uint32(0x40000000) { /* |x| >= 2 */
		return _common3(tls, ix, Xfabsf(tls, x), 0, sign)
	}
	if ix >= uint32(0x39000000) { /* |x| >= 2**-13 */
		z = x * x
		r = z * (_r001 + z*(_r011+z*(_r021+z*_r031)))
		s = Float32FromInt32(1) + z*(_s011+z*(_s021+z*(_s031+z*(_s041+z*_s051))))
		z = Float32FromFloat32(0.5) + r/s
	} else {
		z = Float32FromFloat32(0.5)
	}
	return z * x
}

var _U01 = [5]float32{
	0: float32(-Float64FromFloat64(0.19605709612)),
	1: float32(0.050443872809),
	2: float32(-Float64FromFloat64(0.0019125689287)),
	3: float32(2.3525259166e-05),
	4: float32(-Float64FromFloat64(9.1909917899e-08)),
}
var _V01 = [5]float32{
	0: float32(0.019916731864),
	1: float32(0.0002025525755),
	2: float32(1.3560879779e-06),
	3: float32(6.227414584e-09),
	4: float32(1.6655924903e-11),
}

func Xy1f(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ix Tuint32_t
	var u, v, z float32
	_, _, _, _ = ix, u, v, z
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	if ix&uint32(0x7fffffff) == uint32(0) {
		return float32(-Int32FromInt32(1)) / Float32FromFloat32(0)
	}
	if ix>>int32(31) != 0 {
		return Float32FromInt32(0) / Float32FromFloat32(0)
	}
	if ix >= uint32(0x7f800000) {
		return Float32FromInt32(1) / x
	}
	if ix >= uint32(0x40000000) { /* |x| >= 2.0 */
		return _common3(tls, ix, x, int32(1), 0)
	}
	if ix < uint32(0x33000000) { /* x < 2**-25 */
		return -_tpi3 / x
	}
	z = x * x
	u = _U01[0] + z*(_U01[int32(1)]+z*(_U01[int32(2)]+z*(_U01[int32(3)]+z*_U01[int32(4)])))
	v = Float32FromFloat32(1) + z*(_V01[0]+z*(_V01[int32(1)]+z*(_V01[int32(2)]+z*(_V01[int32(3)]+z*_V01[int32(4)]))))
	return x*(u/v) + _tpi3*(Xj1f(tls, x)*Xlogf(tls, x)-Float32FromFloat32(1)/x)
}

/* For x >= 8, the asymptotic expansions of pone is
 *      1 + 15/128 s^2 - 4725/2^15 s^4 - ...,   where s = 1/x.
 * We approximate pone by
 *      pone(x) = 1 + (R/S)
 * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10
 *        S = 1 + ps0*s^2 + ... + ps4*s^10
 * and
 *      | pone(x)-1-R/S | <= 2  ** ( -60.06)
 */

var _pr81 = [6]float32{
	1: float32(0.1171875),
	2: float32(13.239480972),
	3: float32(412.05184937),
	4: float32(3874.7453613),
	5: float32(7914.4794922),
}
var _ps81 = [5]float32{
	0: float32(114.20736694),
	1: float32(3650.9309082),
	2: float32(36956.207031),
	3: float32(97602.796875),
	4: float32(30804.271484),
}

var _pr51 = [6]float32{
	0: float32(1.3199052094e-11),
	1: float32(0.11718749255),
	2: float32(6.8027510643),
	3: float32(108.30818176),
	4: float32(517.63616943),
	5: float32(528.71520996),
}
var _ps51 = [5]float32{
	0: float32(59.280597687),
	1: float32(991.40142822),
	2: float32(5353.2670898),
	3: float32(7844.6904297),
	4: float32(1504.046875),
}

var _pr31 = [6]float32{
	0: float32(3.0250391081e-09),
	1: float32(0.1171868667),
	2: float32(3.932977438),
	3: float32(35.119403839),
	4: float32(91.055007935),
	5: float32(48.559066772),
}
var _ps31 = [5]float32{
	0: float32(34.791309357),
	1: float32(336.76245117),
	2: float32(1046.87146),
	3: float32(890.81134033),
	4: float32(103.78793335),
}

var _pr21 = [6]float32{
	0: float32(1.0771083225e-07),
	1: float32(0.11717621982),
	2: float32(2.3685150146),
	3: float32(12.242610931),
	4: float32(17.693971634),
	5: float32(5.0735230446),
}
var _ps21 = [5]float32{
	0: float32(21.436485291),
	1: float32(125.2902298),
	2: float32(232.276474),
	3: float32(117.67937469),
	4: float32(8.3646392822),
}

func _ponef(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var p, q uintptr
	var r, s, z Tfloat_t
	_, _, _, _, _, _ = ix, p, q, r, s, z
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x41000000) {
		p = uintptr(unsafe.Pointer(&_pr81))
		q = uintptr(unsafe.Pointer(&_ps81))
	} else {
		if ix >= uint32(0x409173eb) {
			p = uintptr(unsafe.Pointer(&_pr51))
			q = uintptr(unsafe.Pointer(&_ps51))
		} else {
			if ix >= uint32(0x4036d917) {
				p = uintptr(unsafe.Pointer(&_pr31))
				q = uintptr(unsafe.Pointer(&_ps31))
			} else { /*ix >= 0x40000000*/
				p = uintptr(unsafe.Pointer(&_pr21))
				q = uintptr(unsafe.Pointer(&_ps21))
			}
		}
	}
	z = Float32FromFloat32(1) / (x * x)
	r = *(*float32)(unsafe.Pointer(p)) + z*(*(*float32)(unsafe.Pointer(p + 1*4))+z*(*(*float32)(unsafe.Pointer(p + 2*4))+z*(*(*float32)(unsafe.Pointer(p + 3*4))+z*(*(*float32)(unsafe.Pointer(p + 4*4))+z**(*float32)(unsafe.Pointer(p + 5*4))))))
	s = Float32FromFloat32(1) + z*(*(*float32)(unsafe.Pointer(q))+z*(*(*float32)(unsafe.Pointer(q + 1*4))+z*(*(*float32)(unsafe.Pointer(q + 2*4))+z*(*(*float32)(unsafe.Pointer(q + 3*4))+z**(*float32)(unsafe.Pointer(q + 4*4))))))
	return Float32FromFloat32(1) + r/s
}

/* For x >= 8, the asymptotic expansions of qone is
 *      3/8 s - 105/1024 s^3 - ..., where s = 1/x.
 * We approximate pone by
 *      qone(x) = s*(0.375 + (R/S))
 * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10
 *        S = 1 + qs1*s^2 + ... + qs6*s^12
 * and
 *      | qone(x)/s -0.375-R/S | <= 2  ** ( -61.13)
 */

var _qr81 = [6]float32{
	1: float32(-Float64FromFloat64(0.1025390625)),
	2: float32(-Float64FromFloat64(16.271753311)),
	3: float32(-Float64FromFloat64(759.60174561)),
	4: float32(-Float64FromFloat64(11849.806641)),
	5: float32(-Float64FromFloat64(48438.511719)),
}
var _qs81 = [6]float32{
	0: float32(161.39537048),
	1: float32(7825.3862305),
	2: float32(133875.34375),
	3: float32(719657.75),
	4: float32(666601.25),
	5: float32(-Float64FromFloat64(294490.25)),
}

var _qr51 = [6]float32{
	0: float32(-Float64FromFloat64(2.0897993405e-11)),
	1: float32(-Float64FromFloat64(0.1025390476)),
	2: float32(-Float64FromFloat64(8.0564479828)),
	3: float32(-Float64FromFloat64(183.66960144)),
	4: float32(-Float64FromFloat64(1373.1937256)),
	5: float32(-Float64FromFloat64(2612.4443359)),
}
var _qs51 = [6]float32{
	0: float32(81.276550293),
	1: float32(1991.7987061),
	2: float32(17468.484375),
	3: float32(49851.425781),
	4: float32(27948.074219),
	5: float32(-Float64FromFloat64(4719.1835938)),
}

var _qr31 = [6]float32{
	0: float32(-Float64FromFloat64(5.0783124372e-09)),
	1: float32(-Float64FromFloat64(0.10253783315)),
	2: float32(-Float64FromFloat64(4.6101160049)),
	3: float32(-Float64FromFloat64(57.847221375)),
	4: float32(-Float64FromFloat64(228.24453735)),
	5: float32(-Float64FromFloat64(219.21012878)),
}
var _qs31 = [6]float32{
	0: float32(47.665153503),
	1: float32(673.8651123),
	2: float32(3380.152832),
	3: float32(5547.7290039),
	4: float32(1903.1191406),
	5: float32(-Float64FromFloat64(135.20118713)),
}

var _qr21 = [6]float32{
	0: float32(-Float64FromFloat64(1.7838172539e-07)),
	1: float32(-Float64FromFloat64(0.10251704603)),
	2: float32(-Float64FromFloat64(2.7522056103)),
	3: float32(-Float64FromFloat64(19.66361618)),
	4: float32(-Float64FromFloat64(42.325313568)),
	5: float32(-Float64FromFloat64(21.371921539)),
}
var _qs21 = [6]float32{
	0: float32(29.533363342),
	1: float32(252.98155212),
	2: float32(757.50280762),
	3: float32(739.39318848),
	4: float32(155.94900513),
	5: float32(-Float64FromFloat64(4.9594988823)),
}

func _qonef(tls *TLS, x float32) (r1 float32) {
	var ix Tuint32_t
	var p, q uintptr
	var r, s, z Tfloat_t
	_, _, _, _, _, _ = ix, p, q, r, s, z
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	ix &= uint32(0x7fffffff)
	if ix >= uint32(0x41000000) {
		p = uintptr(unsafe.Pointer(&_qr81))
		q = uintptr(unsafe.Pointer(&_qs81))
	} else {
		if ix >= uint32(0x409173eb) {
			p = uintptr(unsafe.Pointer(&_qr51))
			q = uintptr(unsafe.Pointer(&_qs51))
		} else {
			if ix >= uint32(0x4036d917) {
				p = uintptr(unsafe.Pointer(&_qr31))
				q = uintptr(unsafe.Pointer(&_qs31))
			} else { /*ix >= 0x40000000*/
				p = uintptr(unsafe.Pointer(&_qr21))
				q = uintptr(unsafe.Pointer(&_qs21))
			}
		}
	}
	z = Float32FromFloat32(1) / (x * x)
	r = *(*float32)(unsafe.Pointer(p)) + z*(*(*float32)(unsafe.Pointer(p + 1*4))+z*(*(*float32)(unsafe.Pointer(p + 2*4))+z*(*(*float32)(unsafe.Pointer(p + 3*4))+z*(*(*float32)(unsafe.Pointer(p + 4*4))+z**(*float32)(unsafe.Pointer(p + 5*4))))))
	s = Float32FromFloat32(1) + z*(*(*float32)(unsafe.Pointer(q))+z*(*(*float32)(unsafe.Pointer(q + 1*4))+z*(*(*float32)(unsafe.Pointer(q + 2*4))+z*(*(*float32)(unsafe.Pointer(q + 3*4))+z*(*(*float32)(unsafe.Pointer(q + 4*4))+z**(*float32)(unsafe.Pointer(q + 5*4)))))))
	return (Float32FromFloat32(0.375) + r/s) / x
}

var _invsqrtpi4 = float64(0.5641895835477563) /* 0x3FE20DD7, 0x50429B6D */

func Xjn(tls *TLS, n int32, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v n=%v x=%v, (%v:)", tls, n, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __u Tuint64_t
	var a, b, h, nf, q0, q1, t, temp, tmp, w, z, v6 float64
	var i, k, nm1, sign int32
	var ix, lx Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __u, a, b, h, i, ix, k, lx, nf, nm1, q0, q1, sign, t, temp, tmp, w, z, v6
	__u = *(*Tuint64_t)(unsafe.Pointer(&x))
	ix = uint32(__u >> int32(32))
	lx = uint32(__u)
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix|(lx|-lx)>>int32(31) > uint32(0x7ff00000) { /* nan */
		return x
	}
	/* J(-n,x) = (-1)^n * J(n, x), J(n, -x) = (-1)^n * J(n, x)
	 * Thus, J(-n,x) = J(n,-x)
	 */
	/* nm1 = |n|-1 is used instead of |n| to handle n==INT_MIN */
	if n == 0 {
		return Xj0(tls, x)
	}
	if n < 0 {
		nm1 = -(n + int32(1))
		x = -x
		sign ^= int32(1)
	} else {
		nm1 = n - int32(1)
	}
	if nm1 == 0 {
		return Xj1(tls, x)
	}
	sign &= n /* even n: 0, odd n: signbit(x) */
	x = Xfabs(tls, x)
	if ix|lx == uint32(0) || ix == uint32(0x7ff00000) { /* if x is 0 or inf */
		b = float64(0)
	} else {
		if float64(nm1) < x {
			/* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
			if ix >= uint32(0x52d00000) { /* x > 2**302 */
				/* (x >> n**2)
				 *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
				 *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
				 *      Let s=sin(x), c=cos(x),
				 *          xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
				 *
				 *             n    sin(xn)*sqt2    cos(xn)*sqt2
				 *          ----------------------------------
				 *             0     s-c             c+s
				 *             1    -s-c            -c+s
				 *             2    -s+c            -c-s
				 *             3     s+c             c-s
				 */
				switch nm1 & Int32FromInt32(3) {
				case 0:
					temp = -Xcos(tls, x) + Xsin(tls, x)
				case int32(1):
					temp = -Xcos(tls, x) - Xsin(tls, x)
				case int32(2):
					temp = Xcos(tls, x) - Xsin(tls, x)
				default:
					fallthrough
				case int32(3):
					temp = Xcos(tls, x) + Xsin(tls, x)
					break
				}
				b = _invsqrtpi4 * temp / Xsqrt(tls, x)
			} else {
				a = Xj0(tls, x)
				b = Xj1(tls, x)
				i = 0
				for {
					if !(i < nm1) {
						break
					}
					i++
					temp = b
					b = b*(float64(2)*float64(i)/x) - a /* avoid underflow */
					a = temp
					goto _1
				_1:
				}
			}
		} else {
			if ix < uint32(0x3e100000) { /* x < 2**-29 */
				/* x is tiny, return the first Taylor expansion of J(n,x)
				 * J(n,x) = 1/n!*(x/2)^n  - ...
				 */
				if nm1 > int32(32) { /* underflow */
					b = float64(0)
				} else {
					temp = x * float64(0.5)
					b = temp
					a = float64(1)
					i = int32(2)
					for {
						if !(i <= nm1+int32(1)) {
							break
						}
						a *= float64(i) /* a = n! */
						b *= temp       /* b = (x/2)^n */
						goto _2
					_2:
						;
						i++
					}
					b = b / a
				}
			} else {
				nf = float64(nm1) + float64(1)
				w = Float64FromInt32(2) * nf / x
				h = Float64FromInt32(2) / x
				z = w + h
				q0 = w
				q1 = w*z - float64(1)
				k = int32(1)
				for q1 < float64(1e+09) {
					k += int32(1)
					z += h
					tmp = z*q1 - q0
					q0 = q1
					q1 = tmp
				}
				t = float64(0)
				i = k
				for {
					if !(i >= 0) {
						break
					}
					t = Float64FromInt32(1) / (Float64FromInt32(2)*(float64(i)+nf)/x - t)
					goto _3
				_3:
					;
					i--
				}
				a = t
				b = float64(1)
				/*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
				 *  Hence, if n*(log(2n/x)) > ...
				 *  single 8.8722839355e+01
				 *  double 7.09782712893383973096e+02
				 *  long double 1.1356523406294143949491931077970765006170e+04
				 *  then recurrent value may overflow and the result is
				 *  likely underflow to zero
				 */
				tmp = nf * Xlog(tls, Xfabs(tls, w))
				if tmp < float64(709.782712893384) {
					i = nm1
					for {
						if !(i > 0) {
							break
						}
						temp = b
						b = b*(float64(2)*float64(i))/x - a
						a = temp
						goto _4
					_4:
						;
						i--
					}
				} else {
					i = nm1
					for {
						if !(i > 0) {
							break
						}
						temp = b
						b = b*(float64(2)*float64(i))/x - a
						a = temp
						/* scale b to avoid spurious overflow */
						if b > float64(3.273390607896142e+150) {
							a /= b
							t /= b
							b = float64(1)
						}
						goto _5
					_5:
						;
						i--
					}
				}
				z = Xj0(tls, x)
				w = Xj1(tls, x)
				if Xfabs(tls, z) >= Xfabs(tls, w) {
					b = t * z / b
				} else {
					b = t * w / a
				}
			}
		}
	}
	if sign != 0 {
		v6 = -b
	} else {
		v6 = b
	}
	return v6
}

func Xyn(tls *TLS, n int32, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v n=%v x=%v, (%v:)", tls, n, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __u Tuint64_t
	var a, b, temp, v1, v3 float64
	var i, nm1, sign int32
	var ib, ix, lx Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _ = __u, a, b, i, ib, ix, lx, nm1, sign, temp, v1, v3
	__u = *(*Tuint64_t)(unsafe.Pointer(&x))
	ix = uint32(__u >> int32(32))
	lx = uint32(__u)
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix|(lx|-lx)>>int32(31) > uint32(0x7ff00000) { /* nan */
		return x
	}
	if sign != 0 && ix|lx != uint32(0) { /* x < 0 */
		return Float64FromInt32(0) / Float64FromFloat64(0)
	}
	if ix == uint32(0x7ff00000) {
		return float64(0)
	}
	if n == 0 {
		return Xy0(tls, x)
	}
	if n < 0 {
		nm1 = -(n + int32(1))
		sign = n & int32(1)
	} else {
		nm1 = n - int32(1)
		sign = 0
	}
	if nm1 == 0 {
		if sign != 0 {
			v1 = -Xy1(tls, x)
		} else {
			v1 = Xy1(tls, x)
		}
		return v1
	}
	if ix >= uint32(0x52d00000) { /* x > 2**302 */
		/* (x >> n**2)
		 *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
		 *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
		 *      Let s=sin(x), c=cos(x),
		 *          xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
		 *
		 *             n    sin(xn)*sqt2    cos(xn)*sqt2
		 *          ----------------------------------
		 *             0     s-c             c+s
		 *             1    -s-c            -c+s
		 *             2    -s+c            -c-s
		 *             3     s+c             c-s
		 */
		switch nm1 & Int32FromInt32(3) {
		case 0:
			temp = -Xsin(tls, x) - Xcos(tls, x)
		case int32(1):
			temp = -Xsin(tls, x) + Xcos(tls, x)
		case int32(2):
			temp = Xsin(tls, x) + Xcos(tls, x)
		default:
			fallthrough
		case int32(3):
			temp = Xsin(tls, x) - Xcos(tls, x)
			break
		}
		b = _invsqrtpi4 * temp / Xsqrt(tls, x)
	} else {
		a = Xy0(tls, x)
		b = Xy1(tls, x)
		/* quit if b is -inf */
		ib = uint32(*(*Tuint64_t)(unsafe.Pointer(&b)) >> int32(32))
		i = 0
		for {
			if !(i < nm1 && ib != uint32(0xfff00000)) {
				break
			}
			i++
			temp = b
			b = float64(2)*float64(i)/x*b - a
			ib = uint32(*(*Tuint64_t)(unsafe.Pointer(&b)) >> int32(32))
			a = temp
			goto _2
		_2:
		}
	}
	if sign != 0 {
		v3 = -b
	} else {
		v3 = b
	}
	return v3
}

func Xjnf(tls *TLS, n int32, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v n=%v x=%v, (%v:)", tls, n, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, b, h, nf, q0, q1, t, temp, tmp, w, z, v6 float32
	var i, k, nm1, sign int32
	var ix Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, b, h, i, ix, k, nf, nm1, q0, q1, sign, t, temp, tmp, w, z, v6
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix > uint32(0x7f800000) { /* nan */
		return x
	}
	/* J(-n,x) = J(n,-x), use |n|-1 to avoid overflow in -n */
	if n == 0 {
		return Xj0f(tls, x)
	}
	if n < 0 {
		nm1 = -(n + int32(1))
		x = -x
		sign ^= int32(1)
	} else {
		nm1 = n - int32(1)
	}
	if nm1 == 0 {
		return Xj1f(tls, x)
	}
	sign &= n /* even n: 0, odd n: signbit(x) */
	x = Xfabsf(tls, x)
	if ix == uint32(0) || ix == uint32(0x7f800000) { /* if x is 0 or inf */
		b = Float32FromFloat32(0)
	} else {
		if float32(nm1) < x {
			/* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
			a = Xj0f(tls, x)
			b = Xj1f(tls, x)
			i = 0
			for {
				if !(i < nm1) {
					break
				}
				i++
				temp = b
				b = b*(Float32FromFloat32(2)*float32(i)/x) - a
				a = temp
				goto _1
			_1:
			}
		} else {
			if ix < uint32(0x35800000) { /* x < 2**-20 */
				/* x is tiny, return the first Taylor expansion of J(n,x)
				 * J(n,x) = 1/n!*(x/2)^n  - ...
				 */
				if nm1 > int32(8) { /* underflow */
					nm1 = int32(8)
				}
				temp = Float32FromFloat32(0.5) * x
				b = temp
				a = Float32FromFloat32(1)
				i = int32(2)
				for {
					if !(i <= nm1+int32(1)) {
						break
					}
					a *= float32(i) /* a = n! */
					b *= temp       /* b = (x/2)^n */
					goto _2
				_2:
					;
					i++
				}
				b = b / a
			} else {
				nf = float32(nm1) + Float32FromFloat32(1)
				w = Float32FromInt32(2) * nf / x
				h = Float32FromInt32(2) / x
				z = w + h
				q0 = w
				q1 = w*z - Float32FromFloat32(1)
				k = int32(1)
				for q1 < Float32FromFloat32(10000) {
					k += int32(1)
					z += h
					tmp = z*q1 - q0
					q0 = q1
					q1 = tmp
				}
				t = Float32FromFloat32(0)
				i = k
				for {
					if !(i >= 0) {
						break
					}
					t = Float32FromFloat32(1) / (Float32FromInt32(2)*(float32(i)+nf)/x - t)
					goto _3
				_3:
					;
					i--
				}
				a = t
				b = Float32FromFloat32(1)
				/*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
				 *  Hence, if n*(log(2n/x)) > ...
				 *  single 8.8722839355e+01
				 *  double 7.09782712893383973096e+02
				 *  long double 1.1356523406294143949491931077970765006170e+04
				 *  then recurrent value may overflow and the result is
				 *  likely underflow to zero
				 */
				tmp = nf * Xlogf(tls, Xfabsf(tls, w))
				if tmp < Float32FromFloat32(88.721679688) {
					i = nm1
					for {
						if !(i > 0) {
							break
						}
						temp = b
						b = Float32FromFloat32(2)*float32(i)*b/x - a
						a = temp
						goto _4
					_4:
						;
						i--
					}
				} else {
					i = nm1
					for {
						if !(i > 0) {
							break
						}
						temp = b
						b = Float32FromFloat32(2)*float32(i)*b/x - a
						a = temp
						/* scale b to avoid spurious overflow */
						if b > Float32FromFloat32(1.152921504606847e+18) {
							a /= b
							t /= b
							b = Float32FromFloat32(1)
						}
						goto _5
					_5:
						;
						i--
					}
				}
				z = Xj0f(tls, x)
				w = Xj1f(tls, x)
				if Xfabsf(tls, z) >= Xfabsf(tls, w) {
					b = t * z / b
				} else {
					b = t * w / a
				}
			}
		}
	}
	if sign != 0 {
		v6 = -b
	} else {
		v6 = b
	}
	return v6
}

func Xynf(tls *TLS, n int32, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v n=%v x=%v, (%v:)", tls, n, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, b, temp, v1, v3 float32
	var i, nm1, sign int32
	var ib, ix Tuint32_t
	_, _, _, _, _, _, _, _, _, _ = a, b, i, ib, ix, nm1, sign, temp, v1, v3
	ix = *(*Tuint32_t)(unsafe.Pointer(&x))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix > uint32(0x7f800000) { /* nan */
		return x
	}
	if sign != 0 && ix != uint32(0) { /* x < 0 */
		return Float32FromInt32(0) / Float32FromFloat32(0)
	}
	if ix == uint32(0x7f800000) {
		return Float32FromFloat32(0)
	}
	if n == 0 {
		return Xy0f(tls, x)
	}
	if n < 0 {
		nm1 = -(n + int32(1))
		sign = n & int32(1)
	} else {
		nm1 = n - int32(1)
		sign = 0
	}
	if nm1 == 0 {
		if sign != 0 {
			v1 = -Xy1f(tls, x)
		} else {
			v1 = Xy1f(tls, x)
		}
		return v1
	}
	a = Xy0f(tls, x)
	b = Xy1f(tls, x)
	/* quit if b is -inf */
	ib = *(*Tuint32_t)(unsafe.Pointer(&b))
	i = 0
	for {
		if !(i < nm1 && ib != uint32(0xff800000)) {
			break
		}
		i++
		temp = b
		b = Float32FromFloat32(2)*float32(i)/x*b - a
		ib = *(*Tuint32_t)(unsafe.Pointer(&b))
		a = temp
		goto _2
	_2:
	}
	if sign != 0 {
		v3 = -b
	} else {
		v3 = b
	}
	return v3
}

func Xldexp(tls *TLS, x float64, n int32) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xscalbn(tls, x, n)
}

func Xldexpf(tls *TLS, x float32, n int32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xscalbnf(tls, x, n)
}

func Xldexpl(tls *TLS, x float64, n int32) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xscalbnl(tls, x, n)
}

func Xlgamma(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lgamma_r(tls, x, uintptr(unsafe.Pointer(&Xsigngam)))
}

var _pi2 = float64(3.141592653589793)              /* 0x400921FB, 0x54442D18 */
var _a0 = float64(0.07721566490153287)             /* 0x3FB3C467, 0xE37DB0C8 */
var _a1 = float64(0.3224670334241136)              /* 0x3FD4A34C, 0xC4A60FAD */
var _a2 = float64(0.06735230105312927)             /* 0x3FB13E00, 0x1A5562A7 */
var _a3 = float64(0.020580808432516733)            /* 0x3F951322, 0xAC92547B */
var _a4 = float64(0.007385550860814029)            /* 0x3F7E404F, 0xB68FEFE8 */
var _a5 = float64(0.0028905138367341563)           /* 0x3F67ADD8, 0xCCB7926B */
var _a6 = float64(0.0011927076318336207)           /* 0x3F538A94, 0x116F3F5D */
var _a7 = float64(0.0005100697921535113)           /* 0x3F40B6C6, 0x89B99C00 */
var _a8 = float64(0.00022086279071390839)          /* 0x3F2CF2EC, 0xED10E54D */
var _a9 = float64(0.00010801156724758394)          /* 0x3F1C5088, 0x987DFB07 */
var _a10 = float64(2.5214456545125733e-05)         /* 0x3EFA7074, 0x428CFA52 */
var _a11 = float64(4.4864094961891516e-05)         /* 0x3F07858E, 0x90A45837 */
var _tc = float64(1.4616321449683622)              /* 0x3FF762D8, 0x6356BE3F */
var _tf = -Float64FromFloat64(0.12148629053584961) /* 0xBFBF19B9, 0xBCC38A42 */
/* tt = -(tail of tf) */
var _tt = -Float64FromFloat64(3.638676997039505e-18)   /* 0xBC50C7CA, 0xA48A971F */
var _t0 = float64(0.48383612272381005)                 /* 0x3FDEF72B, 0xC8EE38A2 */
var _t1 = -Float64FromFloat64(0.1475877229945939)      /* 0xBFC2E427, 0x8DC6C509 */
var _t2 = float64(0.06462494023913339)                 /* 0x3FB08B42, 0x94D5419B */
var _t3 = -Float64FromFloat64(0.032788541075985965)    /* 0xBFA0C9A8, 0xDF35B713 */
var _t4 = float64(0.01797067508118204)                 /* 0x3F9266E7, 0x970AF9EC */
var _t5 = -Float64FromFloat64(0.010314224129834144)    /* 0xBF851F9F, 0xBA91EC6A */
var _t6 = float64(0.006100538702462913)                /* 0x3F78FCE0, 0xE370E344 */
var _t7 = -Float64FromFloat64(0.0036845201678113826)   /* 0xBF6E2EFF, 0xB3E914D7 */
var _t8 = float64(0.0022596478090061247)               /* 0x3F6282D3, 0x2E15C915 */
var _t9 = -Float64FromFloat64(0.0014034646998923284)   /* 0xBF56FE8E, 0xBF2D1AF1 */
var _t10 = float64(0.000881081882437654)               /* 0x3F4CDF0C, 0xEF61A8E9 */
var _t11 = -Float64FromFloat64(0.0005385953053567405)  /* 0xBF41A610, 0x9C73E0EC */
var _t12 = float64(0.00031563207090362595)             /* 0x3F34AF6D, 0x6C0EBBF7 */
var _t13 = -Float64FromFloat64(0.00031275416837512086) /* 0xBF347F24, 0xECC38C38 */
var _t14 = float64(0.0003355291926355191)              /* 0x3F35FD3E, 0xE8C2D3F4 */
var _u0 = -Float64FromFloat64(0.07721566490153287)     /* 0xBFB3C467, 0xE37DB0C8 */
var _u1 = float64(0.6328270640250934)                  /* 0x3FE4401E, 0x8B005DFF */
var _u2 = float64(1.4549225013723477)                  /* 0x3FF7475C, 0xD119BD6F */
var _u3 = float64(0.9777175279633727)                  /* 0x3FEF4976, 0x44EA8450 */
var _u4 = float64(0.22896372806469245)                 /* 0x3FCD4EAE, 0xF6010924 */
var _u5 = float64(0.013381091853678766)                /* 0x3F8B678B, 0xBF2BAB09 */
var _v1 = float64(2.4559779371304113)                  /* 0x4003A5D7, 0xC2BD619C */
var _v2 = float64(2.128489763798934)                   /* 0x40010725, 0xA42B18F5 */
var _v3 = float64(0.7692851504566728)                  /* 0x3FE89DFB, 0xE45050AF */
var _v4 = float64(0.10422264559336913)                 /* 0x3FBAAE55, 0xD6537C88 */
var _v5 = float64(0.003217092422824239)                /* 0x3F6A5ABB, 0x57D0CF61 */
var _s0 = -Float64FromFloat64(0.07721566490153287)     /* 0xBFB3C467, 0xE37DB0C8 */
var _s1 = float64(0.21498241596060885)                 /* 0x3FCB848B, 0x36E20878 */
var _s2 = float64(0.325778796408931)                   /* 0x3FD4D98F, 0x4F139F59 */
var _s3 = float64(0.14635047265246445)                 /* 0x3FC2BB9C, 0xBEE5F2F7 */
var _s4 = float64(0.02664227030336386)                 /* 0x3F9B481C, 0x7E939961 */
var _s5 = float64(0.0018402845140733772)               /* 0x3F5E26B6, 0x7368F239 */
var _s6 = float64(3.194753265841009e-05)               /* 0x3F00BFEC, 0xDD17E945 */
var _r1 = float64(1.3920053346762105)                  /* 0x3FF645A7, 0x62C4AB74 */
var _r2 = float64(0.7219355475671381)                  /* 0x3FE71A18, 0x93D3DCDC */
var _r3 = float64(0.17193386563280308)                 /* 0x3FC601ED, 0xCCFBDF27 */
var _r4 = float64(0.01864591917156529)                 /* 0x3F9317EA, 0x742ED475 */
var _r5 = float64(0.0007779424963818936)               /* 0x3F497DDA, 0xCA41A95B */
var _r6 = float64(7.326684307446256e-06)               /* 0x3EDEBAF7, 0xA5B38140 */
var _w0 = float64(0.4189385332046727)                  /* 0x3FDACFE3, 0x90C97D69 */
var _w1 = float64(0.08333333333333297)                 /* 0x3FB55555, 0x5555553B */
var _w2 = -Float64FromFloat64(0.0027777777772877554)   /* 0xBF66C16C, 0x16B02E5C */
var _w3 = float64(0.0007936505586430196)               /* 0x3F4A019F, 0x98CF38B6 */
var _w4 = -Float64FromFloat64(0.00059518755745034)     /* 0xBF4380CB, 0x8C0FE741 */
var _w5 = float64(0.0008363399189962821)               /* 0x3F4B67BA, 0x4CDAD5D1 */
var _w6 = -Float64FromFloat64(0.0016309293409657527)   /* 0xBF5AB89D, 0x0B9E43E4 */

// C documentation
//
//	/* sin(pi*x) assuming x > 2^-100, if sin(pi*x)==0 the sign is arbitrary */
func _sin_pi(tls *TLS, x float64) (r float64) {
	var n int32
	_ = n
	/* spurious inexact if odd int */
	x = float64(2) * (x*float64(0.5) - Xfloor(tls, x*float64(0.5))) /* x mod 2.0 */
	n = int32(x * Float64FromFloat64(4))
	n = (n + int32(1)) / int32(2)
	x -= float64(float32(n) * Float32FromFloat32(0.5))
	x *= _pi2
	switch n {
	default: /* case 4: */
		fallthrough
	case 0:
		return X__sin(tls, x, float64(0), 0)
	case int32(1):
		return X__cos(tls, x, float64(0))
	case int32(2):
		return X__sin(tls, -x, float64(0), 0)
	case int32(3):
		return -X__cos(tls, x, float64(0))
	}
	return r
}

func X__lgamma_r(tls *TLS, x float64, signgamp uintptr) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v signgamp=%v, (%v:)", tls, x, signgamp, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, sign int32
	var ix Tuint32_t
	var nadj, p, p1, p2, p3, q, r, t, w, y, z Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, ix, nadj, p, p1, p2, p3, q, r, sign, t, w, y, z
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	/* purge off +-inf, NaN, +-0, tiny and negative arguments */
	*(*int32)(unsafe.Pointer(signgamp)) = int32(1)
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	if ix >= uint32(0x7ff00000) {
		return x * x
	}
	if ix < uint32((Int32FromInt32(0x3ff)-Int32FromInt32(70))<<Int32FromInt32(20)) { /* |x|<2**-70, return -log(|x|) */
		if sign != 0 {
			x = -x
			*(*int32)(unsafe.Pointer(signgamp)) = -int32(1)
		}
		return -Xlog(tls, x)
	}
	if sign != 0 {
		x = -x
		t = _sin_pi(tls, x)
		if t == float64(0) { /* -integer */
			return float64(1) / (x - x)
		}
		if t > float64(0) {
			*(*int32)(unsafe.Pointer(signgamp)) = -int32(1)
		} else {
			t = -t
		}
		nadj = Xlog(tls, _pi2/(t*x))
	}
	/* purge off 1 and 2 */
	if (ix == uint32(0x3ff00000) || ix == uint32(0x40000000)) && uint32(*(*Tuint64_t)(unsafe.Pointer(bp))) == uint32(0) {
		r = Float64FromInt32(0)
	} else {
		if ix < uint32(0x40000000) {
			if ix <= uint32(0x3feccccc) { /* lgamma(x) = lgamma(x+1)-log(x) */
				r = -Xlog(tls, x)
				if ix >= uint32(0x3FE76944) {
					y = float64(1) - x
					i = 0
				} else {
					if ix >= uint32(0x3FCDA661) {
						y = x - (_tc - Float64FromFloat64(1))
						i = int32(1)
					} else {
						y = x
						i = int32(2)
					}
				}
			} else {
				r = float64(0)
				if ix >= uint32(0x3FFBB4C3) { /* [1.7316,2] */
					y = float64(2) - x
					i = 0
				} else {
					if ix >= uint32(0x3FF3B4C4) { /* [1.23,1.73] */
						y = x - _tc
						i = int32(1)
					} else {
						y = x - float64(1)
						i = int32(2)
					}
				}
			}
			switch i {
			case 0:
				z = y * y
				p1 = _a0 + z*(_a2+z*(_a4+z*(_a6+z*(_a8+z*_a10))))
				p2 = z * (_a1 + z*(_a3+z*(_a5+z*(_a7+z*(_a9+z*_a11)))))
				p = y*p1 + p2
				r += p - float64(0.5)*y
			case int32(1):
				z = y * y
				w = z * y
				p1 = _t0 + w*(_t3+w*(_t6+w*(_t9+w*_t12))) /* parallel comp */
				p2 = _t1 + w*(_t4+w*(_t7+w*(_t10+w*_t13)))
				p3 = _t2 + w*(_t5+w*(_t8+w*(_t11+w*_t14)))
				p = z*p1 - (_tt - w*(p2+y*p3))
				r += _tf + p
			case int32(2):
				p1 = y * (_u0 + y*(_u1+y*(_u2+y*(_u3+y*(_u4+y*_u5)))))
				p2 = float64(1) + y*(_v1+y*(_v2+y*(_v3+y*(_v4+y*_v5))))
				r += -Float64FromFloat64(0.5)*y + p1/p2
			}
		} else {
			if ix < uint32(0x40200000) { /* x < 8.0 */
				i = int32(x)
				y = x - float64(i)
				p = y * (_s0 + y*(_s1+y*(_s2+y*(_s3+y*(_s4+y*(_s5+y*_s6))))))
				q = float64(1) + y*(_r1+y*(_r2+y*(_r3+y*(_r4+y*(_r5+y*_r6)))))
				r = float64(0.5)*y + p/q
				z = float64(1) /* lgamma(1+s) = log(s) + lgamma(s) */
				switch i {
				case int32(7):
					z *= y + float64(6) /* FALLTHRU */
					fallthrough
				case int32(6):
					z *= y + float64(5) /* FALLTHRU */
					fallthrough
				case int32(5):
					z *= y + float64(4) /* FALLTHRU */
					fallthrough
				case int32(4):
					z *= y + float64(3) /* FALLTHRU */
					fallthrough
				case int32(3):
					z *= y + float64(2) /* FALLTHRU */
					r += Xlog(tls, z)
					break
				}
			} else {
				if ix < uint32(0x43900000) { /* 8.0 <= x < 2**58 */
					t = Xlog(tls, x)
					z = float64(1) / x
					y = z * z
					w = _w0 + z*(_w1+y*(_w2+y*(_w3+y*(_w4+y*(_w5+y*_w6)))))
					r = (x-float64(0.5))*(t-Float64FromFloat64(1)) + w
				} else { /* 2**58 <= x <= inf */
					r = x * (Xlog(tls, x) - float64(1))
				}
			}
		}
	}
	if sign != 0 {
		r = nadj - r
	}
	return r
}

func Xlgamma_r(tls *TLS, x float64, signgamp uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v signgamp=%v, (%v:)", tls, x, signgamp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lgamma_r(tls, x, signgamp)
}

func Xlgammaf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lgammaf_r(tls, x, uintptr(unsafe.Pointer(&Xsigngam)))
}

var _pi3 = float32(3.141592741)                        /* 0x40490fdb */
var _a01 = float32(0.077215664089)                     /* 0x3d9e233f */
var _a12 = float32(0.32246702909)                      /* 0x3ea51a66 */
var _a21 = float32(0.067352302372)                     /* 0x3d89f001 */
var _a31 = float32(0.020580807701)                     /* 0x3ca89915 */
var _a41 = float32(0.0073855509982)                    /* 0x3bf2027e */
var _a51 = float32(0.0028905137442)                    /* 0x3b3d6ec6 */
var _a61 = float32(0.0011927076848)                    /* 0x3a9c54a1 */
var _a71 = float32(0.00051006977446)                   /* 0x3a05b634 */
var _a81 = float32(0.00022086278477)                   /* 0x39679767 */
var _a91 = float32(0.00010801156895)                   /* 0x38e28445 */
var _a101 = float32(2.52144564e-05)                    /* 0x37d383a2 */
var _a111 = float32(4.4864096708e-05)                  /* 0x383c2c75 */
var _tc1 = float32(1.4616321325)                       /* 0x3fbb16c3 */
var _tf1 = float32(-Float64FromFloat64(0.12148628384)) /* 0xbdf8cdcd */
/* tt = -(tail of tf) */
var _tt1 = float32(6.6971006518e-09)                       /* 0x31e61c52 */
var _t01 = float32(0.48383611441)                          /* 0x3ef7b95e */
var _t15 = float32(-Float64FromFloat64(0.14758771658))     /* 0xbe17213c */
var _t21 = float32(0.064624942839)                         /* 0x3d845a15 */
var _t31 = float32(-Float64FromFloat64(0.032788541168))    /* 0xbd064d47 */
var _t41 = float32(0.017970675603)                         /* 0x3c93373d */
var _t51 = float32(-Float64FromFloat64(0.010314224288))    /* 0xbc28fcfe */
var _t61 = float32(0.0061005386524)                        /* 0x3bc7e707 */
var _t71 = float32(-Float64FromFloat64(0.0036845202558))   /* 0xbb7177fe */
var _t81 = float32(0.0022596477065)                        /* 0x3b141699 */
var _t91 = float32(-Float64FromFloat64(0.0014034647029))   /* 0xbab7f476 */
var _t101 = float32(0.00088108185446)                      /* 0x3a66f867 */
var _t111 = float32(-Float64FromFloat64(0.00053859531181)) /* 0xba0d3085 */
var _t121 = float32(0.00031563205994)                      /* 0x39a57b6b */
var _t131 = float32(-Float64FromFloat64(0.00031275415677)) /* 0xb9a3f927 */
var _t141 = float32(0.00033552918467)                      /* 0x39afe9f7 */
var _u07 = float32(-Float64FromFloat64(0.077215664089))    /* 0xbd9e233f */
var _u11 = float32(0.63282704353)                          /* 0x3f2200f4 */
var _u21 = float32(1.4549225569)                           /* 0x3fba3ae7 */
var _u31 = float32(0.97771751881)                          /* 0x3f7a4bb2 */
var _u41 = float32(0.22896373272)                          /* 0x3e6a7578 */
var _u51 = float32(0.013381091878)                         /* 0x3c5b3c5e */
var _v11 = float32(2.4559779167)                           /* 0x401d2ebe */
var _v21 = float32(2.1284897327)                           /* 0x4008392d */
var _v31 = float32(0.76928514242)                          /* 0x3f44efdf */
var _v41 = float32(0.10422264785)                          /* 0x3dd572af */
var _v51 = float32(0.0032170924824)                        /* 0x3b52d5db */
var _s06 = float32(-Float64FromFloat64(0.077215664089))    /* 0xbd9e233f */
var _s11 = float32(0.21498242021)                          /* 0x3e5c245a */
var _s21 = float32(0.32577878237)                          /* 0x3ea6cc7a */
var _s31 = float32(0.14635047317)                          /* 0x3e15dce6 */
var _s41 = float32(0.026642270386)                         /* 0x3cda40e4 */
var _s51 = float32(0.0018402845599)                        /* 0x3af135b4 */
var _s61 = float32(3.1947532989e-05)                       /* 0x3805ff67 */
var _r11 = float32(1.3920053244)                           /* 0x3fb22d3b */
var _r21 = float32(0.72193557024)                          /* 0x3f38d0c5 */
var _r31 = float32(0.17193385959)                          /* 0x3e300f6e */
var _r41 = float32(0.018645919859)                         /* 0x3c98bf54 */
var _r51 = float32(0.00077794247773)                       /* 0x3a4beed6 */
var _r61 = float32(7.3266842264e-06)                       /* 0x36f5d7bd */
var _w01 = float32(0.41893854737)                          /* 0x3ed67f1d */
var _w11 = float32(0.083333335817)                         /* 0x3daaaaab */
var _w21 = float32(-Float64FromFloat64(0.002777777845))    /* 0xbb360b61 */
var _w31 = float32(0.00079365057172)                       /* 0x3a500cfd */
var _w41 = float32(-Float64FromFloat64(0.00059518753551))  /* 0xba1c065c */
var _w51 = float32(0.00083633989561)                       /* 0x3a5b3dd2 */
var _w61 = float32(-Float64FromFloat64(0.0016309292987))   /* 0xbad5c4e8 */

// C documentation
//
//	/* sin(pi*x) assuming x > 2^-100, if sin(pi*x)==0 the sign is arbitrary */
func _sin_pi1(tls *TLS, x float32) (r float32) {
	var n int32
	var y Tdouble_t
	_, _ = n, y
	/* spurious inexact if odd int */
	x = Float32FromInt32(2) * (x*Float32FromFloat32(0.5) - Xfloorf(tls, x*Float32FromFloat32(0.5))) /* x mod 2.0 */
	n = int32(x * Float32FromInt32(4))
	n = (n + int32(1)) / int32(2)
	y = float64(x - float32(n)*Float32FromFloat32(0.5))
	y *= float64(3.141592653589793)
	switch n {
	default: /* case 4: */
		fallthrough
	case 0:
		return X__sindf(tls, y)
	case int32(1):
		return X__cosdf(tls, y)
	case int32(2):
		return X__sindf(tls, -y)
	case int32(3):
		return -X__cosdf(tls, y)
	}
	return r
}

func X__lgammaf_r(tls *TLS, x float32, signgamp uintptr) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v signgamp=%v, (%v:)", tls, x, signgamp, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, sign int32
	var ix Tuint32_t
	var nadj, p, p1, p2, p3, q, r, t, w, y, z float32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, ix, nadj, p, p1, p2, p3, q, r, sign, t, w, y, z
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	/* purge off +-inf, NaN, +-0, tiny and negative arguments */
	*(*int32)(unsafe.Pointer(signgamp)) = int32(1)
	sign = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	ix = *(*Tuint32_t)(unsafe.Pointer(bp)) & uint32(0x7fffffff)
	if ix >= uint32(0x7f800000) {
		return x * x
	}
	if ix < uint32(0x35000000) { /* |x| < 2**-21, return -log(|x|) */
		if sign != 0 {
			*(*int32)(unsafe.Pointer(signgamp)) = -int32(1)
			x = -x
		}
		return -Xlogf(tls, x)
	}
	if sign != 0 {
		x = -x
		t = _sin_pi1(tls, x)
		if t == Float32FromFloat32(0) { /* -integer */
			return Float32FromFloat32(1) / (x - x)
		}
		if t > Float32FromFloat32(0) {
			*(*int32)(unsafe.Pointer(signgamp)) = -int32(1)
		} else {
			t = -t
		}
		nadj = Xlogf(tls, _pi3/(t*x))
	}
	/* purge off 1 and 2 */
	if ix == uint32(0x3f800000) || ix == uint32(0x40000000) {
		r = Float32FromInt32(0)
	} else {
		if ix < uint32(0x40000000) {
			if ix <= uint32(0x3f666666) { /* lgamma(x) = lgamma(x+1)-log(x) */
				r = -Xlogf(tls, x)
				if ix >= uint32(0x3f3b4a20) {
					y = Float32FromFloat32(1) - x
					i = 0
				} else {
					if ix >= uint32(0x3e6d3308) {
						y = x - (_tc1 - Float32FromFloat32(1))
						i = int32(1)
					} else {
						y = x
						i = int32(2)
					}
				}
			} else {
				r = Float32FromFloat32(0)
				if ix >= uint32(0x3fdda618) { /* [1.7316,2] */
					y = Float32FromFloat32(2) - x
					i = 0
				} else {
					if ix >= uint32(0x3F9da620) { /* [1.23,1.73] */
						y = x - _tc1
						i = int32(1)
					} else {
						y = x - Float32FromFloat32(1)
						i = int32(2)
					}
				}
			}
			switch i {
			case 0:
				z = y * y
				p1 = _a01 + z*(_a21+z*(_a41+z*(_a61+z*(_a81+z*_a101))))
				p2 = z * (_a12 + z*(_a31+z*(_a51+z*(_a71+z*(_a91+z*_a111)))))
				p = y*p1 + p2
				r += p - Float32FromFloat32(0.5)*y
			case int32(1):
				z = y * y
				w = z * y
				p1 = _t01 + w*(_t31+w*(_t61+w*(_t91+w*_t121))) /* parallel comp */
				p2 = _t15 + w*(_t41+w*(_t71+w*(_t101+w*_t131)))
				p3 = _t21 + w*(_t51+w*(_t81+w*(_t111+w*_t141)))
				p = z*p1 - (_tt1 - w*(p2+y*p3))
				r += _tf1 + p
			case int32(2):
				p1 = y * (_u07 + y*(_u11+y*(_u21+y*(_u31+y*(_u41+y*_u51)))))
				p2 = Float32FromFloat32(1) + y*(_v11+y*(_v21+y*(_v31+y*(_v41+y*_v51))))
				r += -Float32FromFloat32(0.5)*y + p1/p2
			}
		} else {
			if ix < uint32(0x41000000) { /* x < 8.0 */
				i = int32(x)
				y = x - float32(i)
				p = y * (_s06 + y*(_s11+y*(_s21+y*(_s31+y*(_s41+y*(_s51+y*_s61))))))
				q = Float32FromFloat32(1) + y*(_r11+y*(_r21+y*(_r31+y*(_r41+y*(_r51+y*_r61)))))
				r = Float32FromFloat32(0.5)*y + p/q
				z = Float32FromFloat32(1) /* lgamma(1+s) = log(s) + lgamma(s) */
				switch i {
				case int32(7):
					z *= y + Float32FromFloat32(6) /* FALLTHRU */
					fallthrough
				case int32(6):
					z *= y + Float32FromFloat32(5) /* FALLTHRU */
					fallthrough
				case int32(5):
					z *= y + Float32FromFloat32(4) /* FALLTHRU */
					fallthrough
				case int32(4):
					z *= y + Float32FromFloat32(3) /* FALLTHRU */
					fallthrough
				case int32(3):
					z *= y + Float32FromFloat32(2) /* FALLTHRU */
					r += Xlogf(tls, z)
					break
				}
			} else {
				if ix < uint32(0x5c800000) { /* 8.0 <= x < 2**58 */
					t = Xlogf(tls, x)
					z = Float32FromFloat32(1) / x
					y = z * z
					w = _w01 + z*(_w11+y*(_w21+y*(_w31+y*(_w41+y*(_w51+y*_w61)))))
					r = (x-Float32FromFloat32(0.5))*(t-Float32FromFloat32(1)) + w
				} else { /* 2**58 <= x <= inf */
					r = x * (Xlogf(tls, x) - Float32FromFloat32(1))
				}
			}
		}
	}
	if sign != 0 {
		r = nadj - r
	}
	return r
}

func Xlgammaf_r(tls *TLS, x float32, signgamp uintptr) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v signgamp=%v, (%v:)", tls, x, signgamp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lgammaf_r(tls, x, signgamp)
}

func X__lgammal_r(tls *TLS, x float64, sg uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v sg=%v, (%v:)", tls, x, sg, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lgamma_r(tls, x, sg)
}

func Xlgammal(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lgammal_r(tls, x, uintptr(unsafe.Pointer(&Xsigngam)))
}

func Xlgammal_r(tls *TLS, x float64, sg uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v sg=%v, (%v:)", tls, x, sg, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lgammal_r(tls, x, sg)
}

/* uses LLONG_MAX > 2^53, see comments in lrint.c */

func Xllrint(tls *TLS, x float64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xrint(tls, x))
}

/* uses LLONG_MAX > 2^24, see comments in lrint.c */

func Xllrintf(tls *TLS, x float32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xrintf(tls, x))
}

func Xllrintl(tls *TLS, x float64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xllrint(tls, x)
}

func Xllround(tls *TLS, x float64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xround(tls, x))
}

func Xllroundf(tls *TLS, x float32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xroundf(tls, x))
}

func Xllroundl(tls *TLS, x float64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xroundl(tls, x))
}

const LOG_POLY1_ORDER = 12
const LOG_POLY_ORDER = 6
const LOG_TABLE_BITS = 7
const N4 = 128
const OFF = 4604367669032910848

// C documentation
//
//	/* Top 16 bits of a double.  */
func _top16(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(48))
}

func Xlog(tls *TLS, x1 float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x1=%v, (%v:)", tls, x1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var hi, invc, kd, lo, logc, r, r2, r3, rhi, rlo, w, y1, z Tdouble_t
	var i, k int32
	var ix, iz, tmp Tuint64_t
	var top Tuint32_t
	var y, v1, v10, v2, v3, v4, v6, v8, v9 float64
	var v5 bool
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = hi, i, invc, ix, iz, k, kd, lo, logc, r, r2, r3, rhi, rlo, tmp, top, w, y, y1, z, v1, v10, v2, v3, v4, v5, v6, v8, v9
	ix = *(*Tuint64_t)(unsafe.Pointer(&x1))
	top = _top16(tls, x1)
	v1 = Float64FromFloat64(1) - Float64FromFloat64(0.0625)
	v2 = Float64FromFloat64(1) + Float64FromFloat64(0.064697265625)
	v3 = Float64FromFloat64(1) - Float64FromFloat64(0.0625)
	if ix-*(*Tuint64_t)(unsafe.Pointer(&v1)) < *(*Tuint64_t)(unsafe.Pointer(&v2))-*(*Tuint64_t)(unsafe.Pointer(&v3)) {
		/* Handle close to 1.0 inputs separately.  */
		/* Fix sign of zero with downward rounding when x==1.  */
		if v5 = Bool(int32(WANT_ROUNDING) != 0); v5 {
			v4 = float64(1)
		}
		if v5 && ix == *(*Tuint64_t)(unsafe.Pointer(&v4)) {
			return Float64FromInt32(0)
		}
		r = x1 - float64(1)
		r2 = r * r
		r3 = r * r2
		y1 = r3 * (*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 1*8)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 2*8)) + r2**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 3*8)) + r3*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 4*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 5*8))+r2**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 6*8))+r3*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 7*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 8*8))+r2**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 9*8))+r3**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56 + 10*8)))))
		/* Worst-case error is around 0.507 ULP.  */
		w = r * float64(1.34217728e+08)
		rhi = r + w - w
		rlo = r - rhi
		w = rhi * rhi * *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56)) /* B[0] == -0.5.  */
		hi = r + w
		lo = r - hi + w
		lo += *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 56)) * rlo * (rhi + r)
		y1 += lo
		y1 += hi
		y = y1
		v6 = y
		goto _7
	_7:
		return v6
	}
	if top-uint32(0x0010) >= uint32(Int32FromInt32(0x7ff0)-Int32FromInt32(0x0010)) {
		/* x < 0x1p-1022 or inf or nan.  */
		if ix*uint64(2) == uint64(0) {
			return X__math_divzero(tls, uint32(1))
		}
		v8 = float64(X__builtin_inff(tls))
		if ix == *(*Tuint64_t)(unsafe.Pointer(&v8)) { /* log(inf) == inf.  */
			return x1
		}
		if top&uint32(0x8000) != 0 || top&uint32(0x7ff0) == uint32(0x7ff0) {
			return X__math_invalid(tls, x1)
		}
		/* x is subnormal, normalize it.  */
		v9 = x1 * float64(4.503599627370496e+15)
		ix = *(*Tuint64_t)(unsafe.Pointer(&v9))
		ix = ix - Uint64FromUint64(52)<<Int32FromInt32(52)
	}
	/* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint64(OFF)
	i = int32(tmp >> (Int32FromInt32(52) - Int32FromInt32(LOG_TABLE_BITS)) % uint64(Int32FromInt32(1)<<Int32FromInt32(LOG_TABLE_BITS)))
	k = int32(int64(tmp) >> int32(52)) /* arithmetic shift */
	iz = ix - tmp&(Uint64FromUint64(0xfff)<<Int32FromInt32(52))
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 144 + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 144 + uintptr(i)*16))).Flogc
	z = *(*float64)(unsafe.Pointer(&iz))
	/* log(x) = log1p(z/c-1) + log(c) + k*Ln2.  */
	/* r ~= z/c - 1, |r| < 1/(2*N).  */
	/* rounding error: 0x1p-55/N.  */
	r = X__builtin_fma(tls, z, invc, -Float64FromFloat64(1))
	kd = float64(k)
	/* hi + lo = r + log(c) + k*Ln2.  */
	w = kd*X__log_data.Fln2hi + logc
	hi = w + r
	lo = w - hi + r + kd*X__log_data.Fln2lo
	/* log(x) = lo + (log1p(r) - r) + hi.  */
	r2 = r * r /* rounding error: 0x1p-54/N^2.  */
	/* Worst case error if |y| > 0x1p-5:
	   0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)
	   Worst case error if |y| > 0x1p-4:
	   0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).  */
	y1 = lo + r2**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 16)) + r*r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 16 + 1*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 16 + 2*8))+r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 16 + 3*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log_data)) + 16 + 4*8)))) + hi
	y = y1
	v10 = y
	goto _11
_11:
	return v10
}

var _ivln10hi = float64(0.4342944818781689)     /* 0x3fdbcb7b, 0x15200000 */
var _ivln10lo = float64(2.5082946711645275e-11) /* 0x3dbb9438, 0xca9aadd5 */
var _log10_2hi = float64(0.30102999566361177)   /* 0x3FD34413, 0x509F6000 */
var _log10_2lo = float64(3.694239077158931e-13) /* 0x3D59FEF3, 0x11F12B36 */
var _Lg1 = float64(0.6666666666666735)          /* 3FE55555 55555593 */
var _Lg2 = float64(0.3999999999940942)          /* 3FD99999 9997FA04 */
var _Lg3 = float64(0.2857142874366239)          /* 3FD24924 94229359 */
var _Lg4 = float64(0.22222198432149784)         /* 3FCC71C5 1D8E78AF */
var _Lg5 = float64(0.1818357216161805)          /* 3FC74664 96CB03DE */
var _Lg6 = float64(0.15313837699209373)         /* 3FC39A09 D078C69F */
var _Lg7 = float64(0.14798198605116586)         /* 3FC2F112 DF3E5244 */

func Xlog10(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var R, dk, f, hfsq, hi, lo, s, t1, t2, val_hi, val_lo, w, y, z Tdouble_t
	var hx Tuint32_t
	var k int32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = R, dk, f, hfsq, hi, hx, k, lo, s, t1, t2, val_hi, val_lo, w, y, z
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	k = 0
	if hx < uint32(0x00100000) || hx>>int32(31) != 0 {
		if *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(1) == uint64(0) {
			return float64(-Int32FromInt32(1)) / (x * x)
		} /* log(+-0)=-inf */
		if hx>>int32(31) != 0 {
			return (x - x) / float64(0)
		} /* log(-#) = NaN */
		/* subnormal number, scale x up */
		k -= int32(54)
		x *= float64(1.8014398509481984e+16)
		*(*float64)(unsafe.Pointer(bp)) = x
		hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	} else {
		if hx >= uint32(0x7ff00000) {
			return x
		} else {
			if hx == uint32(0x3ff00000) && *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(32) == uint64(0) {
				return Float64FromInt32(0)
			}
		}
	}
	/* reduce x into [sqrt(2)/2, sqrt(2)] */
	hx += uint32(Int32FromInt32(0x3ff00000) - Int32FromInt32(0x3fe6a09e))
	k += int32(hx>>Int32FromInt32(20)) - int32(0x3ff)
	hx = hx&uint32(0x000fffff) + uint32(0x3fe6a09e)
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(hx)<<int32(32) | *(*Tuint64_t)(unsafe.Pointer(bp))&uint64(0xffffffff)
	x = *(*float64)(unsafe.Pointer(bp))
	f = x - float64(1)
	hfsq = float64(0.5) * f * f
	s = f / (Float64FromFloat64(2) + f)
	z = s * s
	w = z * z
	t1 = w * (_Lg2 + w*(_Lg4+w*_Lg6))
	t2 = z * (_Lg1 + w*(_Lg3+w*(_Lg5+w*_Lg7)))
	R = t2 + t1
	/* See log2.c for details. */
	/* hi+lo = f - hfsq + s*(hfsq+R) ~ log(1+f) */
	hi = f - hfsq
	*(*float64)(unsafe.Pointer(bp)) = hi
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= uint64(-Int32FromInt32(1)) << Int32FromInt32(32)
	hi = *(*float64)(unsafe.Pointer(bp))
	lo = f - hi - hfsq + s*(hfsq+R)
	/* val_hi+val_lo ~ log10(1+f) + k*log10(2) */
	val_hi = hi * _ivln10hi
	dk = float64(k)
	y = dk * _log10_2hi
	val_lo = dk*_log10_2lo + (lo+hi)*_ivln10lo + lo*_ivln10hi
	/*
	 * Extra precision in for adding y is not strictly needed
	 * since there is no very large cancellation near x = sqrt(2) or
	 * x = 1/sqrt(2), but we do it anyway since it costs little on CPUs
	 * with some parallelism and it reduces the error for many args.
	 */
	w = y + val_hi
	val_lo += y - w + val_hi
	val_hi = w
	return val_lo + val_hi
}

var _ivln10hi1 = float32(0.43432617188)                         /* 0x3ede6000 */
var _ivln10lo1 = float32(-Float64FromFloat64(3.1689971365e-05)) /* 0xb804ead9 */
var _log10_2hi1 = float32(0.30102920532)                        /* 0x3e9a2080 */
var _log10_2lo1 = float32(7.9034151668e-07)                     /* 0x355427db */
/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
var _Lg11 = float32(0.6666666269302368)  /* 0.66666662693 */
var _Lg21 = float32(0.40000972151756287) /* 0.40000972152 */
var _Lg31 = float32(0.2849878668785095)  /* 0.28498786688 */
var _Lg41 = float32(0.24279078841209412) /* 0.24279078841 */

func Xlog10f(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var R, dk, f, hfsq, hi, lo, s, t1, t2, w, z Tfloat_t
	var ix Tuint32_t
	var k int32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _ = R, dk, f, hfsq, hi, ix, k, lo, s, t1, t2, w, z
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	ix = *(*Tuint32_t)(unsafe.Pointer(bp))
	k = 0
	if ix < uint32(0x00800000) || ix>>int32(31) != 0 { /* x < 2**-126  */
		if ix<<int32(1) == uint32(0) {
			return float32(-Int32FromInt32(1)) / (x * x)
		} /* log(+-0)=-inf */
		if ix>>int32(31) != 0 {
			return (x - x) / Float32FromFloat32(0)
		} /* log(-#) = NaN */
		/* subnormal number, scale up x */
		k -= int32(25)
		x *= Float32FromFloat32(3.3554432e+07)
		*(*float32)(unsafe.Pointer(bp)) = x
		ix = *(*Tuint32_t)(unsafe.Pointer(bp))
	} else {
		if ix >= uint32(0x7f800000) {
			return x
		} else {
			if ix == uint32(0x3f800000) {
				return Float32FromInt32(0)
			}
		}
	}
	/* reduce x into [sqrt(2)/2, sqrt(2)] */
	ix += uint32(Int32FromInt32(0x3f800000) - Int32FromInt32(0x3f3504f3))
	k += int32(ix>>Int32FromInt32(23)) - int32(0x7f)
	ix = ix&uint32(0x007fffff) + uint32(0x3f3504f3)
	*(*Tuint32_t)(unsafe.Pointer(bp)) = ix
	x = *(*float32)(unsafe.Pointer(bp))
	f = x - Float32FromFloat32(1)
	s = f / (Float32FromFloat32(2) + f)
	z = s * s
	w = z * z
	t1 = w * (_Lg21 + w*_Lg41)
	t2 = z * (_Lg11 + w*_Lg31)
	R = t2 + t1
	hfsq = Float32FromFloat32(0.5) * f * f
	hi = f - hfsq
	*(*float32)(unsafe.Pointer(bp)) = hi
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0xfffff000)
	hi = *(*float32)(unsafe.Pointer(bp))
	lo = f - hi - hfsq + s*(hfsq+R)
	dk = float32(k)
	return dk*_log10_2lo1 + (lo+hi)*_ivln10lo1 + lo*_ivln10hi1 + hi*_ivln10hi1 + dk*_log10_2hi1
}

func Xlog10l(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xlog10(tls, x)
}

var _ln2_hi2 = float64(0.6931471803691238)     /* 3fe62e42 fee00000 */
var _ln2_lo2 = float64(1.9082149292705877e-10) /* 3dea39ef 35793c76 */
var _Lg12 = float64(0.6666666666666735)        /* 3FE55555 55555593 */
var _Lg22 = float64(0.3999999999940942)        /* 3FD99999 9997FA04 */
var _Lg32 = float64(0.2857142874366239)        /* 3FD24924 94229359 */
var _Lg42 = float64(0.22222198432149784)       /* 3FCC71C5 1D8E78AF */
var _Lg51 = float64(0.1818357216161805)        /* 3FC74664 96CB03DE */
var _Lg61 = float64(0.15313837699209373)       /* 3FC39A09 D078C69F */
var _Lg71 = float64(0.14798198605116586)       /* 3FC2F112 DF3E5244 */

func Xlog1p(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var R, c, dk, f, hfsq, s, t1, t2, w, z Tdouble_t
	var hu, hx Tuint32_t
	var k int32
	var y float32
	var y1, y2, v1 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = R, c, dk, f, hfsq, hu, hx, k, s, t1, t2, w, y, y1, y2, z, v1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	hx = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	k = int32(1)
	if hx < uint32(0x3fda827a) || hx>>int32(31) != 0 { /* 1+x < sqrt(2)+ */
		if hx >= uint32(0xbff00000) { /* x <= -1.0 */
			if x3 == float64(-Int32FromInt32(1)) {
				return x3 / float64(0)
			} /* log1p(-1) = -inf */
			return (x3 - x3) / float64(0) /* log1p(x<-1) = NaN */
		}
		if hx<<int32(1) < uint32(Int32FromInt32(0x3ca00000)<<Int32FromInt32(1)) { /* |x| < 2**-53 */
			/* underflow if subnormal */
			if hx&uint32(0x7ff00000) == uint32(0) {
				if uint64(4) == uint64(4) {
					y = float32(x3)
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(float32(x3))
					} else {
						y2 = float64(float32(x3))
					}
				}
			}
			return x3
		}
		if hx <= uint32(0xbfd2bec4) { /* sqrt(2)/2- <= 1+x < sqrt(2)+ */
			k = 0
			c = Float64FromInt32(0)
			f = x3
		}
	} else {
		if hx >= uint32(0x7ff00000) {
			return x3
		}
	}
	if k != 0 {
		*(*float64)(unsafe.Pointer(bp)) = Float64FromInt32(1) + x3
		hu = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
		hu += uint32(Int32FromInt32(0x3ff00000) - Int32FromInt32(0x3fe6a09e))
		k = int32(hu>>Int32FromInt32(20)) - int32(0x3ff)
		/* correction term ~ log(1+x)-log(u), avoid underflow in c/u */
		if k < int32(54) {
			if k >= int32(2) {
				v1 = Float64FromInt32(1) - (*(*float64)(unsafe.Pointer(bp)) - x3)
			} else {
				v1 = x3 - (*(*float64)(unsafe.Pointer(bp)) - Float64FromInt32(1))
			}
			c = v1
			c /= *(*float64)(unsafe.Pointer(bp))
		} else {
			c = Float64FromInt32(0)
		}
		/* reduce u into [sqrt(2)/2, sqrt(2)] */
		hu = hu&uint32(0x000fffff) + uint32(0x3fe6a09e)
		*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(hu)<<int32(32) | *(*Tuint64_t)(unsafe.Pointer(bp))&uint64(0xffffffff)
		f = *(*float64)(unsafe.Pointer(bp)) - Float64FromInt32(1)
	}
	hfsq = float64(0.5) * f * f
	s = f / (Float64FromFloat64(2) + f)
	z = s * s
	w = z * z
	t1 = w * (_Lg22 + w*(_Lg42+w*_Lg61))
	t2 = z * (_Lg12 + w*(_Lg32+w*(_Lg51+w*_Lg71)))
	R = t2 + t1
	dk = float64(k)
	return s*(hfsq+R) + (dk*_ln2_lo2 + c) - hfsq + f + dk*_ln2_hi2
}

var _ln2_hi3 = float32(0.69313812256)    /* 0x3f317180 */
var _ln2_lo3 = float32(9.0580006145e-06) /* 0x3717f7d1 */
/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
var _Lg13 = float32(0.6666666269302368)  /* 0.66666662693 */
var _Lg23 = float32(0.40000972151756287) /* 0.40000972152 */
var _Lg33 = float32(0.2849878668785095)  /* 0.28498786688 */
var _Lg43 = float32(0.24279078841209412) /* 0.24279078841 */

func Xlog1pf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var R, c, dk, f, hfsq, s, t1, t2, w, z Tfloat_t
	var iu, ix Tuint32_t
	var k int32
	var y, v1 float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = R, c, dk, f, hfsq, iu, ix, k, s, t1, t2, w, y, y1, y2, z, v1
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	ix = *(*Tuint32_t)(unsafe.Pointer(bp))
	k = int32(1)
	if ix < uint32(0x3ed413d0) || ix>>int32(31) != 0 { /* 1+x < sqrt(2)+  */
		if ix >= uint32(0xbf800000) { /* x <= -1.0 */
			if x3 == float32(-Int32FromInt32(1)) {
				return x3 / Float32FromFloat32(0)
			} /* log1p(-1)=+inf */
			return (x3 - x3) / Float32FromFloat32(0) /* log1p(x<-1)=NaN */
		}
		if ix<<int32(1) < uint32(Int32FromInt32(0x33800000)<<Int32FromInt32(1)) { /* |x| < 2**-24 */
			/* underflow if subnormal */
			if ix&uint32(0x7f800000) == uint32(0) {
				if uint64(4) == uint64(4) {
					y = x3 * x3
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(x3 * x3)
					} else {
						y2 = float64(x3 * x3)
					}
				}
			}
			return x3
		}
		if ix <= uint32(0xbe95f619) { /* sqrt(2)/2- <= 1+x < sqrt(2)+ */
			k = 0
			c = Float32FromInt32(0)
			f = x3
		}
	} else {
		if ix >= uint32(0x7f800000) {
			return x3
		}
	}
	if k != 0 {
		*(*float32)(unsafe.Pointer(bp)) = Float32FromInt32(1) + x3
		iu = *(*Tuint32_t)(unsafe.Pointer(bp))
		iu += uint32(Int32FromInt32(0x3f800000) - Int32FromInt32(0x3f3504f3))
		k = int32(iu>>Int32FromInt32(23)) - int32(0x7f)
		/* correction term ~ log(1+x)-log(u), avoid underflow in c/u */
		if k < int32(25) {
			if k >= int32(2) {
				v1 = Float32FromInt32(1) - (*(*float32)(unsafe.Pointer(bp)) - x3)
			} else {
				v1 = x3 - (*(*float32)(unsafe.Pointer(bp)) - Float32FromInt32(1))
			}
			c = v1
			c /= *(*float32)(unsafe.Pointer(bp))
		} else {
			c = Float32FromInt32(0)
		}
		/* reduce u into [sqrt(2)/2, sqrt(2)] */
		iu = iu&uint32(0x007fffff) + uint32(0x3f3504f3)
		*(*Tuint32_t)(unsafe.Pointer(bp)) = iu
		f = *(*float32)(unsafe.Pointer(bp)) - Float32FromInt32(1)
	}
	s = f / (Float32FromFloat32(2) + f)
	z = s * s
	w = z * z
	t1 = w * (_Lg23 + w*_Lg43)
	t2 = z * (_Lg13 + w*_Lg33)
	R = t2 + t1
	hfsq = Float32FromFloat32(0.5) * f * f
	dk = float32(k)
	return s*(hfsq+R) + (dk*_ln2_lo3 + c) - hfsq + f + dk*_ln2_hi3
}

func Xlog1pl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xlog1p(tls, x)
}

const LOG2_POLY1_ORDER = 11
const LOG2_POLY_ORDER = 7
const LOG2_TABLE_BITS = 6
const N5 = 64

// C documentation
//
//	/* Top 16 bits of a double.  */
func _top161(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(48))
}

func Xlog2(tls *TLS, x1 float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x1=%v, (%v:)", tls, x1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var hi, invc, kd, lo, logc, p, r, r2, r4, t1, t2, t3, y1, z Tdouble_t
	var i, k int32
	var ix, iz, tmp Tuint64_t
	var top Tuint32_t
	var y, v1, v10, v2, v3, v4, v6, v8, v9 float64
	var v5 bool
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = hi, i, invc, ix, iz, k, kd, lo, logc, p, r, r2, r4, t1, t2, t3, tmp, top, y, y1, z, v1, v10, v2, v3, v4, v5, v6, v8, v9
	ix = *(*Tuint64_t)(unsafe.Pointer(&x1))
	top = _top161(tls, x1)
	v1 = Float64FromFloat64(1) - Float64FromFloat64(0.04239702224731445)
	v2 = Float64FromFloat64(1) + Float64FromFloat64(0.044274330139160156)
	v3 = Float64FromFloat64(1) - Float64FromFloat64(0.04239702224731445)
	if ix-*(*Tuint64_t)(unsafe.Pointer(&v1)) < *(*Tuint64_t)(unsafe.Pointer(&v2))-*(*Tuint64_t)(unsafe.Pointer(&v3)) {
		/* Handle close to 1.0 inputs separately.  */
		/* Fix sign of zero with downward rounding when x==1.  */
		if v5 = Bool(int32(WANT_ROUNDING) != 0); v5 {
			v4 = float64(1)
		}
		if v5 && ix == *(*Tuint64_t)(unsafe.Pointer(&v4)) {
			return Float64FromInt32(0)
		}
		r = x1 - float64(1)
		hi = r * X__log2_data.Finvln2hi
		lo = r*X__log2_data.Finvln2lo + X__builtin_fma(tls, r, X__log2_data.Finvln2hi, -hi)
		r2 = r * r /* rounding error: 0x1p-62.  */
		r4 = r2 * r2
		/* Worst-case error is less than 0.54 ULP (0.55 ULP without fma).  */
		p = r2 * (*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 1*8)))
		y1 = hi + p
		lo += hi - y1 + p
		lo += r4 * (*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 2*8)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 3*8)) + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 4*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 5*8))) + r4*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 6*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 7*8))+r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 8*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 64 + 9*8)))))
		y1 += lo
		y = y1
		v6 = y
		goto _7
	_7:
		return v6
	}
	if top-uint32(0x0010) >= uint32(Int32FromInt32(0x7ff0)-Int32FromInt32(0x0010)) {
		/* x < 0x1p-1022 or inf or nan.  */
		if ix*uint64(2) == uint64(0) {
			return X__math_divzero(tls, uint32(1))
		}
		v8 = float64(X__builtin_inff(tls))
		if ix == *(*Tuint64_t)(unsafe.Pointer(&v8)) { /* log(inf) == inf.  */
			return x1
		}
		if top&uint32(0x8000) != 0 || top&uint32(0x7ff0) == uint32(0x7ff0) {
			return X__math_invalid(tls, x1)
		}
		/* x is subnormal, normalize it.  */
		v9 = x1 * float64(4.503599627370496e+15)
		ix = *(*Tuint64_t)(unsafe.Pointer(&v9))
		ix = ix - Uint64FromUint64(52)<<Int32FromInt32(52)
	}
	/* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint64(OFF)
	i = int32(tmp >> (Int32FromInt32(52) - Int32FromInt32(LOG2_TABLE_BITS)) % uint64(Int32FromInt32(1)<<Int32FromInt32(LOG2_TABLE_BITS)))
	k = int32(int64(tmp) >> int32(52)) /* arithmetic shift */
	iz = ix - tmp&(Uint64FromUint64(0xfff)<<Int32FromInt32(52))
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 144 + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 144 + uintptr(i)*16))).Flogc
	z = *(*float64)(unsafe.Pointer(&iz))
	kd = float64(k)
	/* log2(x) = log2(z/c) + log2(c) + k.  */
	/* r ~= z/c - 1, |r| < 1/(2*N).  */
	/* rounding error: 0x1p-55/N.  */
	r = X__builtin_fma(tls, z, invc, -Float64FromFloat64(1))
	t1 = r * X__log2_data.Finvln2hi
	t2 = r*X__log2_data.Finvln2lo + X__builtin_fma(tls, r, X__log2_data.Finvln2hi, -t1)
	/* hi + lo = r/ln2 + log2(c) + k.  */
	t3 = kd + logc
	hi = t3 + t1
	lo = t3 - hi + t1 + t2
	/* log2(r+1) = r/ln2 + r^2*poly(r).  */
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	r2 = r * r /* rounding error: 0x1p-54/N^2.  */
	r4 = r2 * r2
	/* Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).
	   ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).  */
	p = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 16)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 16 + 1*8)) + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 16 + 2*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 16 + 3*8))) + r4*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 16 + 4*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2_data)) + 16 + 5*8)))
	y1 = lo + r2*p + hi
	y = y1
	v10 = y
	goto _11
_11:
	return v10
}

type Tlog2_data = struct {
	Finvln2hi float64
	Finvln2lo float64
	Fpoly     [6]float64
	Fpoly1    [10]float64
	Ftab      [64]struct {
		Finvc float64
		Flogc float64
	}
}

const LOG2F_POLY_ORDER = 4
const LOG2F_TABLE_BITS = 4
const N6 = 16
const OFF1 = 1060306944

/*
LOG2F_TABLE_BITS = 4
LOG2F_POLY_ORDER = 4

ULP error: 0.752 (nearest rounding.)
Relative error: 1.9 * 2^-26 (before rounding.)
*/

func Xlog2f(tls *TLS, x1 float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x1=%v, (%v:)", tls, x1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var i, k int32
	var invc, logc, p, r, r2, y0, y1, z Tdouble_t
	var ix, iz, tmp, top Tuint32_t
	var y, v1, v2 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, invc, ix, iz, k, logc, p, r, r2, tmp, top, y, y0, y1, z, v1, v2
	ix = *(*Tuint32_t)(unsafe.Pointer(&x1))
	/* Fix sign of zero with downward rounding when x==1.  */
	if Bool(int32(WANT_ROUNDING) != 0) && ix == uint32(0x3f800000) {
		return Float32FromInt32(0)
	}
	if ix-uint32(0x00800000) >= uint32(Int32FromInt32(0x7f800000)-Int32FromInt32(0x00800000)) {
		/* x < 0x1p-126 or inf or nan.  */
		if ix*uint32(2) == uint32(0) {
			return X__math_divzerof(tls, uint32(1))
		}
		if ix == uint32(0x7f800000) { /* log2(inf) == inf.  */
			return x1
		}
		if ix&uint32(0x80000000) != 0 || ix*uint32(2) >= uint32(0xff000000) {
			return X__math_invalidf(tls, x1)
		}
		/* x is subnormal, normalize it.  */
		v1 = x1 * Float32FromFloat32(8.388608e+06)
		ix = *(*Tuint32_t)(unsafe.Pointer(&v1))
		ix -= uint32(Int32FromInt32(23) << Int32FromInt32(23))
	}
	/* x = 2^k z; where z is in range [OFF,2*OFF] and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint32(OFF1)
	i = int32(tmp >> (Int32FromInt32(23) - Int32FromInt32(LOG2F_TABLE_BITS)) % uint32(Int32FromInt32(1)<<Int32FromInt32(LOG2F_TABLE_BITS)))
	top = tmp & uint32(0xff800000)
	iz = ix - top
	k = int32(tmp) >> int32(23) /* arithmetic shift */
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2f_data)) + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2f_data)) + uintptr(i)*16))).Flogc
	z = float64(*(*float32)(unsafe.Pointer(&iz)))
	/* log2(x) = log1p(z/c-1)/ln2 + log2(c) + k */
	r = z*invc - Float64FromInt32(1)
	y0 = logc + float64(k)
	/* Pipelined polynomial evaluation to approximate log1p(r)/ln2.  */
	r2 = r * r
	y1 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2f_data)) + 256 + 1*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2f_data)) + 256 + 2*8))
	y1 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2f_data)) + 256))*r2 + y1
	p = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__log2f_data)) + 256 + 3*8))*r + y0
	y1 = y1*r2 + p
	y = float32(y1)
	v2 = y
	goto _3
_3:
	return v2
}

type Tlog2f_data = struct {
	Ftab [16]struct {
		Finvc float64
		Flogc float64
	}
	Fpoly [4]float64
}

func Xlog2l(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xlog2(tls, x)
}

const N7 = 128

type Tlog_data = struct {
	Fln2hi float64
	Fln2lo float64
	Fpoly  [5]float64
	Fpoly1 [11]float64
	Ftab   [128]struct {
		Finvc float64
		Flogc float64
	}
}

/*
special cases:
	logb(+-0) = -inf, and raise divbyzero
	logb(+-inf) = +inf
	logb(nan) = nan
*/

func Xlogb(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 uint64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_ = v1
	*(*float64)(unsafe.Pointer(bp)) = x
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	if !(BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		return x * x
	}
	if x == Float64FromInt32(0) {
		return float64(-Int32FromInt32(1)) / (x * x)
	}
	return float64(Xilogb(tls, x))
}

func Xlogbf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 uint32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_ = v1
	*(*float32)(unsafe.Pointer(bp)) = x
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	if !(BoolInt32(v1&Uint32FromInt32(0x7fffffff) < Uint32FromInt32(0x7f800000)) != 0) {
		return x * x
	}
	if x == Float32FromInt32(0) {
		return float32(-Int32FromInt32(1)) / (x * x)
	}
	return float32(Xilogbf(tls, x))
}

func Xlogbl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 uint64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_ = v1
	*(*float64)(unsafe.Pointer(bp)) = x
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	if !(BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		return x * x
	}
	if x == Float64FromInt32(0) {
		return float64(-Int32FromInt32(1)) / (x * x)
	}
	return float64(Xilogbl(tls, x))
}

const LOGF_POLY_ORDER = 4
const LOGF_TABLE_BITS = 4
const N8 = 16

/*
LOGF_TABLE_BITS = 4
LOGF_POLY_ORDER = 4

ULP error: 0.818 (nearest rounding.)
Relative error: 1.957 * 2^-26 (before rounding.)
*/

func Xlogf(tls *TLS, x1 float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x1=%v, (%v:)", tls, x1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var i, k int32
	var invc, logc, r, r2, y0, y1, z Tdouble_t
	var ix, iz, tmp Tuint32_t
	var y, v1, v2 float32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, invc, ix, iz, k, logc, r, r2, tmp, y, y0, y1, z, v1, v2
	ix = *(*Tuint32_t)(unsafe.Pointer(&x1))
	/* Fix sign of zero with downward rounding when x==1.  */
	if Bool(int32(WANT_ROUNDING) != 0) && ix == uint32(0x3f800000) {
		return Float32FromInt32(0)
	}
	if ix-uint32(0x00800000) >= uint32(Int32FromInt32(0x7f800000)-Int32FromInt32(0x00800000)) {
		/* x < 0x1p-126 or inf or nan.  */
		if ix*uint32(2) == uint32(0) {
			return X__math_divzerof(tls, uint32(1))
		}
		if ix == uint32(0x7f800000) { /* log(inf) == inf.  */
			return x1
		}
		if ix&uint32(0x80000000) != 0 || ix*uint32(2) >= uint32(0xff000000) {
			return X__math_invalidf(tls, x1)
		}
		/* x is subnormal, normalize it.  */
		v1 = x1 * Float32FromFloat32(8.388608e+06)
		ix = *(*Tuint32_t)(unsafe.Pointer(&v1))
		ix -= uint32(Int32FromInt32(23) << Int32FromInt32(23))
	}
	/* x = 2^k z; where z is in range [OFF,2*OFF] and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint32(OFF1)
	i = int32(tmp >> (Int32FromInt32(23) - Int32FromInt32(LOGF_TABLE_BITS)) % uint32(Int32FromInt32(1)<<Int32FromInt32(LOGF_TABLE_BITS)))
	k = int32(tmp) >> int32(23) /* arithmetic shift */
	iz = ix - tmp&uint32(0xff800000)
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__logf_data)) + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__logf_data)) + uintptr(i)*16))).Flogc
	z = float64(*(*float32)(unsafe.Pointer(&iz)))
	/* log(x) = log1p(z/c-1) + log(c) + k*Ln2 */
	r = z*invc - Float64FromInt32(1)
	y0 = logc + float64(k)*X__logf_data.Fln2
	/* Pipelined polynomial evaluation to approximate log1p(r).  */
	r2 = r * r
	y1 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__logf_data)) + 264 + 1*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__logf_data)) + 264 + 2*8))
	y1 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__logf_data)) + 264))*r2 + y1
	y1 = y1*r2 + (y0 + r)
	y = float32(y1)
	v2 = y
	goto _3
_3:
	return v2
}

type Tlogf_data = struct {
	Ftab [16]struct {
		Finvc float64
		Flogc float64
	}
	Fln2  float64
	Fpoly [3]float64
}

func Xlogl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xlog(tls, x)
}

/*
If the result cannot be represented (overflow, nan), then
lrint raises the invalid exception.

Otherwise if the input was not an integer then the inexact
exception is raised.

C99 is a bit vague about whether inexact exception is
allowed to be raised when invalid is raised.
(F.9 explicitly allows spurious inexact exceptions, F.9.6.5
does not make it clear if that rule applies to lrint, but
IEEE 754r 7.8 seems to forbid spurious inexact exception in
the ineger conversion functions)

So we try to make sure that no spurious inexact exception is
raised in case of an overflow.

If the bit size of long > precision of double, then there
cannot be inexact rounding in case the result overflows,
otherwise LONG_MAX and LONG_MIN can be represented exactly
as a double.
*/

func Xlrint(tls *TLS, x float64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xrint(tls, x))
}

/* uses LONG_MAX > 2^24, see comments in lrint.c */

func Xlrintf(tls *TLS, x float32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xrintf(tls, x))
}

func Xlrintl(tls *TLS, x float64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xlrint(tls, x)
}

func Xlround(tls *TLS, x float64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xround(tls, x))
}

func Xlroundf(tls *TLS, x float32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xroundf(tls, x))
}

func Xlroundl(tls *TLS, x float64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(Xroundl(tls, x))
}

func Xmodf(tls *TLS, x float64, iptr uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v iptr=%v, (%v:)", tls, x, iptr, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var mask Tuint64_t
	var p1, p2, p3 uintptr
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _ = e, mask, p1, p2, p3
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp))>>Int32FromInt32(52)&Uint64FromInt32(0x7ff)) - int32(0x3ff)
	/* no fractional part */
	if e >= int32(52) {
		*(*float64)(unsafe.Pointer(iptr)) = x
		if e == int32(0x400) && *(*Tuint64_t)(unsafe.Pointer(bp))<<int32(12) != uint64(0) { /* nan */
			return x
		}
		p1 = bp
		*(*Tuint64_t)(unsafe.Pointer(p1)) = *(*Tuint64_t)(unsafe.Pointer(p1)) & (Uint64FromUint64(1) << Int32FromInt32(63))
		return *(*float64)(unsafe.Pointer(bp))
	}
	/* no integral part*/
	if e < 0 {
		p2 = bp
		*(*Tuint64_t)(unsafe.Pointer(p2)) = *(*Tuint64_t)(unsafe.Pointer(p2)) & (Uint64FromUint64(1) << Int32FromInt32(63))
		*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp))
		return x
	}
	mask = -Uint64FromUint64(1) >> Int32FromInt32(12) >> e
	if *(*Tuint64_t)(unsafe.Pointer(bp))&mask == uint64(0) {
		*(*float64)(unsafe.Pointer(iptr)) = x
		p3 = bp
		*(*Tuint64_t)(unsafe.Pointer(p3)) = *(*Tuint64_t)(unsafe.Pointer(p3)) & (Uint64FromUint64(1) << Int32FromInt32(63))
		return *(*float64)(unsafe.Pointer(bp))
	}
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= ^mask
	*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp))
	return x - *(*float64)(unsafe.Pointer(bp))
}

func Xmodff(tls *TLS, x float32, iptr uintptr) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v iptr=%v, (%v:)", tls, x, iptr, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var mask Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _ = e, mask
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp))>>Int32FromInt32(23)&Uint32FromInt32(0xff)) - int32(0x7f)
	/* no fractional part */
	if e >= int32(23) {
		*(*float32)(unsafe.Pointer(iptr)) = x
		if e == int32(0x80) && *(*Tuint32_t)(unsafe.Pointer(bp))<<int32(9) != uint32(0) { /* nan */
			return x
		}
		*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x80000000)
		return *(*float32)(unsafe.Pointer(bp))
	}
	/* no integral part */
	if e < 0 {
		*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x80000000)
		*(*float32)(unsafe.Pointer(iptr)) = *(*float32)(unsafe.Pointer(bp))
		return x
	}
	mask = uint32(int32(0x007fffff) >> e)
	if *(*Tuint32_t)(unsafe.Pointer(bp))&mask == uint32(0) {
		*(*float32)(unsafe.Pointer(iptr)) = x
		*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x80000000)
		return *(*float32)(unsafe.Pointer(bp))
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= ^mask
	*(*float32)(unsafe.Pointer(iptr)) = *(*float32)(unsafe.Pointer(bp))
	return x - *(*float32)(unsafe.Pointer(bp))
}

func Xmodfl(tls *TLS, x float64, iptr uintptr) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v iptr=%v, (%v:)", tls, x, iptr, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r float64
	var _ /* d at bp+0 */ float64
	_ = r
	r = Xmodf(tls, x, bp)
	*(*float64)(unsafe.Pointer(iptr)) = *(*float64)(unsafe.Pointer(bp))
	return r
}

func Xnan(tls *TLS, s uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return float64(X__builtin_nanf(tls, __ccgo_ts))
}

func Xnanf(tls *TLS, s uintptr) (r float32) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__builtin_nanf(tls, __ccgo_ts)
}

func Xnanl(tls *TLS, s uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return float64(X__builtin_nanf(tls, __ccgo_ts))
}

func Xnextafter(tls *TLS, x3 float64, y3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v y3=%v, (%v:)", tls, x3, y3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ax, ay Tuint64_t
	var e int32
	var y float32
	var y1, y2 float64
	var v1, v3 uint64
	var v5 bool
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	var _ /* ux at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+16 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _ = ax, ay, e, y, y1, y2, v1, v3, v5
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 8)) = x3
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 16)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 16)) = y3
	*(*float64)(unsafe.Pointer(bp)) = x3
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0; !v5 {
		*(*float64)(unsafe.Pointer(bp)) = y3
		v3 = *(*uint64)(unsafe.Pointer(bp))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x3 + y3
	}
	if *(*Tuint64_t)(unsafe.Pointer(bp + 8)) == *(*Tuint64_t)(unsafe.Pointer(bp + 16)) {
		return y3
	}
	ax = *(*Tuint64_t)(unsafe.Pointer(bp + 8)) & (-Uint64FromUint64(1) / Uint64FromInt32(2))
	ay = *(*Tuint64_t)(unsafe.Pointer(bp + 16)) & (-Uint64FromUint64(1) / Uint64FromInt32(2))
	if ax == uint64(0) {
		if ay == uint64(0) {
			return y3
		}
		*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = *(*Tuint64_t)(unsafe.Pointer(bp + 16))&(Uint64FromUint64(1)<<Int32FromInt32(63)) | uint64(1)
	} else {
		if ax > ay || (*(*Tuint64_t)(unsafe.Pointer(bp + 8))^*(*Tuint64_t)(unsafe.Pointer(bp + 16)))&(Uint64FromUint64(1)<<Int32FromInt32(63)) != 0 {
			*(*Tuint64_t)(unsafe.Pointer(bp + 8))--
		} else {
			*(*Tuint64_t)(unsafe.Pointer(bp + 8))++
		}
	}
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(52) & uint64(0x7ff))
	/* raise overflow if ux.f is infinite and x is finite */
	if e == int32(0x7ff) {
		if uint64(8) == uint64(4) {
			y = float32(x3 + x3)
		} else {
			if uint64(8) == uint64(8) {
				y1 = x3 + x3
			} else {
				y2 = x3 + x3
			}
		}
	}
	/* raise underflow if ux.f is subnormal or zero */
	if e == 0 {
		if uint64(8) == uint64(4) {
			y = float32(x3*x3 + *(*float64)(unsafe.Pointer(bp + 8))**(*float64)(unsafe.Pointer(bp + 8)))
		} else {
			if uint64(8) == uint64(8) {
				y1 = x3*x3 + *(*float64)(unsafe.Pointer(bp + 8))**(*float64)(unsafe.Pointer(bp + 8))
			} else {
				y2 = x3*x3 + *(*float64)(unsafe.Pointer(bp + 8))**(*float64)(unsafe.Pointer(bp + 8))
			}
		}
	}
	return *(*float64)(unsafe.Pointer(bp + 8))
}

func Xnextafterf(tls *TLS, x3 float32, y3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v y3=%v, (%v:)", tls, x3, y3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ax, ay, e Tuint32_t
	var y float32
	var y1, y2 float64
	var v1, v3 uint32
	var v5 bool
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	var _ /* ux at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _, _, _ = ax, ay, e, y, y1, y2, v1, v3, v5
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 4)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 4)) = x3
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 8)) = y3
	*(*float32)(unsafe.Pointer(bp)) = x3
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0; !v5 {
		*(*float32)(unsafe.Pointer(bp)) = y3
		v3 = *(*uint32)(unsafe.Pointer(bp))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x3 + y3
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp + 4)) == *(*Tuint32_t)(unsafe.Pointer(bp + 8)) {
		return y3
	}
	ax = *(*Tuint32_t)(unsafe.Pointer(bp + 4)) & uint32(0x7fffffff)
	ay = *(*Tuint32_t)(unsafe.Pointer(bp + 8)) & uint32(0x7fffffff)
	if ax == uint32(0) {
		if ay == uint32(0) {
			return y3
		}
		*(*Tuint32_t)(unsafe.Pointer(bp + 4)) = *(*Tuint32_t)(unsafe.Pointer(bp + 8))&uint32(0x80000000) | uint32(1)
	} else {
		if ax > ay || (*(*Tuint32_t)(unsafe.Pointer(bp + 4))^*(*Tuint32_t)(unsafe.Pointer(bp + 8)))&uint32(0x80000000) != 0 {
			*(*Tuint32_t)(unsafe.Pointer(bp + 4))--
		} else {
			*(*Tuint32_t)(unsafe.Pointer(bp + 4))++
		}
	}
	e = *(*Tuint32_t)(unsafe.Pointer(bp + 4)) & uint32(0x7f800000)
	/* raise overflow if ux.f is infinite and x is finite */
	if e == uint32(0x7f800000) {
		if uint64(4) == uint64(4) {
			y = x3 + x3
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3 + x3)
			} else {
				y2 = float64(x3 + x3)
			}
		}
	}
	/* raise underflow if ux.f is subnormal or zero */
	if e == uint32(0) {
		if uint64(4) == uint64(4) {
			y = x3*x3 + *(*float32)(unsafe.Pointer(bp + 4))**(*float32)(unsafe.Pointer(bp + 4))
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3*x3 + *(*float32)(unsafe.Pointer(bp + 4))**(*float32)(unsafe.Pointer(bp + 4)))
			} else {
				y2 = float64(x3*x3 + *(*float32)(unsafe.Pointer(bp + 4))**(*float32)(unsafe.Pointer(bp + 4)))
			}
		}
	}
	return *(*float32)(unsafe.Pointer(bp + 4))
}

func Xnextafterl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xnextafter(tls, x, y)
}

func Xnexttoward(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xnextafter(tls, x, y)
}

func Xnexttowardf(tls *TLS, x3 float32, y3 float64) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v y3=%v, (%v:)", tls, x3, y3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var e Tuint32_t
	var y float32
	var y1, y2 float64
	var v1, v10, v8 uint32
	var v3, v6 uint64
	var v5 bool
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	var _ /* __u at bp+8 */ struct {
		F__i [0]uint64
		F__f float64
	}
	var _ /* ux at bp+16 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _ = e, y, y1, y2, v1, v10, v3, v5, v6, v8
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 16)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 16)) = x3
	*(*float32)(unsafe.Pointer(bp)) = x3
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0; !v5 {
		*(*float64)(unsafe.Pointer(bp + 8)) = y3
		v3 = *(*uint64)(unsafe.Pointer(bp + 8))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return float32(float64(x3) + y3)
	}
	if float64(x3) == y3 {
		return float32(y3)
	}
	if x3 == Float32FromInt32(0) {
		*(*Tuint32_t)(unsafe.Pointer(bp + 16)) = uint32(1)
		*(*float64)(unsafe.Pointer(bp + 8)) = y3
		v6 = *(*uint64)(unsafe.Pointer(bp + 8))
		goto _7
	_7:
		if int32(v6>>Int32FromInt32(63)) != 0 {
			*(*Tuint32_t)(unsafe.Pointer(bp + 16)) |= uint32(0x80000000)
		}
	} else {
		if float64(x3) < y3 {
			*(*float32)(unsafe.Pointer(bp)) = x3
			v8 = *(*uint32)(unsafe.Pointer(bp))
			goto _9
		_9:
			if int32(v8>>Int32FromInt32(31)) != 0 {
				*(*Tuint32_t)(unsafe.Pointer(bp + 16))--
			} else {
				*(*Tuint32_t)(unsafe.Pointer(bp + 16))++
			}
		} else {
			*(*float32)(unsafe.Pointer(bp)) = x3
			v10 = *(*uint32)(unsafe.Pointer(bp))
			goto _11
		_11:
			if int32(v10>>Int32FromInt32(31)) != 0 {
				*(*Tuint32_t)(unsafe.Pointer(bp + 16))++
			} else {
				*(*Tuint32_t)(unsafe.Pointer(bp + 16))--
			}
		}
	}
	e = *(*Tuint32_t)(unsafe.Pointer(bp + 16)) & uint32(0x7f800000)
	/* raise overflow if ux.f is infinite and x is finite */
	if e == uint32(0x7f800000) {
		if uint64(4) == uint64(4) {
			y = x3 + x3
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3 + x3)
			} else {
				y2 = float64(x3 + x3)
			}
		}
	}
	/* raise underflow if ux.f is subnormal or zero */
	if e == uint32(0) {
		if uint64(4) == uint64(4) {
			y = x3*x3 + *(*float32)(unsafe.Pointer(bp + 16))**(*float32)(unsafe.Pointer(bp + 16))
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3*x3 + *(*float32)(unsafe.Pointer(bp + 16))**(*float32)(unsafe.Pointer(bp + 16)))
			} else {
				y2 = float64(x3*x3 + *(*float32)(unsafe.Pointer(bp + 16))**(*float32)(unsafe.Pointer(bp + 16)))
			}
		}
	}
	return *(*float32)(unsafe.Pointer(bp + 16))
}

func Xnexttowardl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xnextafterl(tls, x, y)
}

const OFF2 = 4604531861337669632
const POW_LOG_POLY_ORDER = 8
const POW_LOG_TABLE_BITS = 7
const SIGN_BIAS = 262144

/*
Worst-case error: 0.54 ULP (~= ulperr_exp + 1024*Ln2*relerr_log*2^53)
relerr_log: 1.3 * 2^-68 (Relative error of log, 1.5 * 2^-68 without fma)
ulperr_exp: 0.509 ULP (ULP error of exp, 0.511 ULP without fma)
*/

// C documentation
//
//	/* Top 12 bits of a double (sign and exponent bits).  */
func _top124(tls *TLS, x float64) (r Tuint32_t) {
	return uint32(*(*Tuint64_t)(unsafe.Pointer(&x)) >> int32(52))
}

// C documentation
//
//	/* Compute y+TAIL = log(x) where the rounded result is y and TAIL has about
//	   additional 15 bits precision.  IX is the bit representation of x, but
//	   normalized in the subnormal range using the sign bit for the exponent.  */
func _log_inline(tls *TLS, ix Tuint64_t, tail uintptr) (r1 Tdouble_t) {
	var ar, ar2, ar3, hi, invc, kd, lo, lo1, lo2, lo3, lo4, logc, logctail, p, r, t1, t2, y, z Tdouble_t
	var i, k int32
	var iz, tmp Tuint64_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ar, ar2, ar3, hi, i, invc, iz, k, kd, lo, lo1, lo2, lo3, lo4, logc, logctail, p, r, t1, t2, tmp, y, z
	/* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint64(OFF2)
	i = int32(tmp >> (Int32FromInt32(52) - Int32FromInt32(POW_LOG_TABLE_BITS)) % uint64(Int32FromInt32(1)<<Int32FromInt32(POW_LOG_TABLE_BITS)))
	k = int32(int64(tmp) >> int32(52)) /* arithmetic shift */
	iz = ix - tmp&(Uint64FromUint64(0xfff)<<Int32FromInt32(52))
	z = *(*float64)(unsafe.Pointer(&iz))
	kd = float64(k)
	/* log(x) = k*Ln2 + log(c) + log1p(z/c-1).  */
	invc = (*(*struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 72 + uintptr(i)*32))).Finvc
	logc = (*(*struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 72 + uintptr(i)*32))).Flogc
	logctail = (*(*struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 72 + uintptr(i)*32))).Flogctail
	/* Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and
	   |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.  */
	r = X__builtin_fma(tls, z, invc, -Float64FromFloat64(1))
	/* k*Ln2 + log(c) + r.  */
	t1 = kd*X__pow_log_data.Fln2hi + logc
	t2 = t1 + r
	lo1 = kd*X__pow_log_data.Fln2lo + logctail
	lo2 = t1 - t2 + r
	ar = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 16)) * r /* A[0] = -0.5.  */
	ar2 = r * ar
	ar3 = r * ar2
	/* k*Ln2 + log(c) + r + A[0]*r*r.  */
	hi = t2 + ar2
	lo3 = X__builtin_fma(tls, ar, r, -ar2)
	lo4 = t2 - hi + ar2
	/* p = log1p(r) - r - A[0]*r*r.  */
	p = ar3 * (*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 16 + 1*8)) + r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 16 + 2*8)) + ar2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 16 + 3*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 16 + 4*8))+ar2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 16 + 5*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__pow_log_data)) + 16 + 6*8)))))
	lo = lo1 + lo2 + lo3 + lo4 + p
	y = hi + lo
	*(*Tdouble_t)(unsafe.Pointer(tail)) = hi - y + lo
	return y
}

// C documentation
//
//	/* Handle cases that may overflow or underflow when computing the result that
//	   is scale*(1+TMP) without intermediate rounding.  The bit representation of
//	   scale is in SBITS, however it has a computed exponent that may have
//	   overflown into the sign bit so that needs to be adjusted before using it as
//	   a double.  (int32_t)KI is the k used in the argument reduction and exponent
//	   adjustment of scale, positive k here means the result may overflow and
//	   negative k means the result may underflow.  */
func _specialcase2(tls *TLS, tmp Tdouble_t, sbits Tuint64_t, ki Tuint64_t) (r float64) {
	var hi, lo, one, scale, y3 Tdouble_t
	var y, y1, y2, v1, v3, v6, v8 float64
	var v5 Tuint64_t
	_, _, _, _, _, _, _, _, _, _, _, _, _ = hi, lo, one, scale, y, y1, y2, y3, v1, v3, v5, v6, v8
	if ki&uint64(0x80000000) == uint64(0) {
		/* k > 0, the exponent of scale might have overflowed by <= 460.  */
		sbits = sbits - Uint64FromUint64(1009)<<Int32FromInt32(52)
		scale = *(*float64)(unsafe.Pointer(&sbits))
		y3 = float64(5.486124068793689e+303) * (scale + scale*tmp)
		y = y3
		v1 = y
		goto _2
	_2:
		return v1
	}
	/* k < 0, need special care in the subnormal range.  */
	sbits = sbits + Uint64FromUint64(1022)<<Int32FromInt32(52)
	/* Note: sbits is signed scale.  */
	scale = *(*float64)(unsafe.Pointer(&sbits))
	y3 = scale + scale*tmp
	if Xfabs(tls, y3) < float64(1) {
		one = float64(1)
		if y3 < float64(0) {
			one = -Float64FromFloat64(1)
		}
		lo = scale - y3 + scale*tmp
		hi = one + y3
		lo = one - hi + y3 + lo
		y = hi + lo
		v3 = y
		goto _4
	_4:
		y3 = v3 - one
		/* Fix the sign of 0.  */
		if y3 == float64(0) {
			v5 = sbits & uint64(0x8000000000000000)
			y3 = *(*float64)(unsafe.Pointer(&v5))
		}
		/* The underflow exception needs to be signaled explicitly.  */
		y1 = float64(2.2250738585072014e-308)
		v6 = y1
		goto _7
	_7:
		y2 = v6 * float64(2.2250738585072014e-308)
	}
	y3 = float64(2.2250738585072014e-308) * y3
	y = y3
	v8 = y
	goto _9
_9:
	return v8
}

// C documentation
//
//	/* Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.
//	   The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.  */
func _exp_inline(tls *TLS, x1 Tdouble_t, xtail Tdouble_t, sign_bias Tuint32_t) (r1 float64) {
	var abstop Tuint32_t
	var idx, ki, sbits, top, v6 Tuint64_t
	var kd, one, r, r2, scale, tail, tmp, z, v1 Tdouble_t
	var y, v2, v3, v5, v7 float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = abstop, idx, kd, ki, one, r, r2, sbits, scale, tail, tmp, top, y, z, v1, v2, v3, v5, v6, v7
	abstop = _top124(tls, x1) & uint32(0x7ff)
	if abstop-_top124(tls, float64(5.551115123125783e-17)) >= _top124(tls, float64(512))-_top124(tls, float64(5.551115123125783e-17)) {
		if abstop-_top124(tls, float64(5.551115123125783e-17)) >= uint32(0x80000000) {
			/* Avoid spurious underflow for tiny x.  */
			/* Note: 0 is common input.  */
			one = float64(1) + x1
			if sign_bias != 0 {
				v1 = -one
			} else {
				v1 = one
			}
			return v1
		}
		if abstop >= _top124(tls, float64(1024)) {
			/* Note: inf and nan are already handled.  */
			v2 = x1
			if *(*Tuint64_t)(unsafe.Pointer(&v2))>>int32(63) != 0 {
				return X__math_uflow(tls, sign_bias)
			} else {
				return X__math_oflow(tls, sign_bias)
			}
		}
		/* Large x is special cased below.  */
		abstop = uint32(0)
	}
	/* exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].  */
	/* x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].  */
	z = X__exp_data.Finvln2N * x1
	/* z - kd is in [-1, 1] in non-nearest rounding modes.  */
	y = z + X__exp_data.Fshift
	v3 = y
	goto _4
_4:
	kd = v3
	v5 = kd
	ki = *(*Tuint64_t)(unsafe.Pointer(&v5))
	kd -= X__exp_data.Fshift
	r = x1 + kd*X__exp_data.Fnegln2hiN + kd*X__exp_data.Fnegln2loN
	/* The code assumes 2^-200 < |xtail| < 2^-8/N.  */
	r += xtail
	/* 2^(k/N) ~= scale * (1 + tail).  */
	idx = uint64(2) * (ki % uint64(Int32FromInt32(1)<<Int32FromInt32(EXP_TABLE_BITS)))
	top = (ki + uint64(sign_bias)) << (Int32FromInt32(52) - Int32FromInt32(EXP_TABLE_BITS))
	v6 = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 112 + uintptr(idx)*8))
	tail = *(*float64)(unsafe.Pointer(&v6))
	/* This is only a valid scale when -1023*N < k < 1024*N.  */
	sbits = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 112 + uintptr(idx+uint64(1))*8)) + top
	/* exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).  */
	/* Evaluation is optimized assuming superscalar pipelined execution.  */
	r2 = r * r
	/* Without fma the worst case error is 0.25/N ulp larger.  */
	/* Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.  */
	tmp = tail + r + r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 32 + uintptr(Int32FromInt32(5)-Int32FromInt32(EXP_POLY_ORDER))*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 32 + uintptr(Int32FromInt32(6)-Int32FromInt32(EXP_POLY_ORDER))*8))) + r2*r2*(*(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 32 + uintptr(Int32FromInt32(7)-Int32FromInt32(EXP_POLY_ORDER))*8))+r**(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp_data)) + 32 + uintptr(Int32FromInt32(8)-Int32FromInt32(EXP_POLY_ORDER))*8)))
	if abstop == uint32(0) {
		return _specialcase2(tls, tmp, sbits, ki)
	}
	scale = *(*float64)(unsafe.Pointer(&sbits))
	/* Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
	   is no spurious underflow here even without fma.  */
	y = scale + scale*tmp
	v7 = y
	goto _8
_8:
	return v7
}

// C documentation
//
//	/* Returns 0 if not int, 1 if odd int, 2 if even int.  The argument is
//	   the bit representation of a non-zero finite floating-point value.  */
func _checkint(tls *TLS, iy Tuint64_t) (r int32) {
	var e int32
	_ = e
	e = int32(iy >> int32(52) & uint64(0x7ff))
	if e < int32(0x3ff) {
		return 0
	}
	if e > Int32FromInt32(0x3ff)+Int32FromInt32(52) {
		return int32(2)
	}
	if iy&(uint64(1)<<(Int32FromInt32(0x3ff)+Int32FromInt32(52)-e)-uint64(1)) != 0 {
		return 0
	}
	if iy&(uint64(1)<<(Int32FromInt32(0x3ff)+Int32FromInt32(52)-e)) != 0 {
		return int32(1)
	}
	return int32(2)
}

// C documentation
//
//	/* Returns 1 if input is the bit representation of 0, infinity or nan.  */
func _zeroinfnan(tls *TLS, i Tuint64_t) (r int32) {
	var v1 float64
	_ = v1
	v1 = float64(X__builtin_inff(tls))
	return BoolInt32(uint64(2)*i-uint64(1) >= uint64(2)**(*Tuint64_t)(unsafe.Pointer(&v1))-uint64(1))
}

func Xpow(tls *TLS, x1 float64, y1 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x1=%v y1=%v, (%v:)", tls, x1, y1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ehi, elo, hi, x2 Tdouble_t
	var ix, iy Tuint64_t
	var sign_bias, topx, topy Tuint32_t
	var y, v1, v10, v11, v12, v13, v14, v15, v2, v3, v5, v6, v7, v8 float64
	var yint int32
	var v4 bool
	var _ /* lo at bp+0 */ Tdouble_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = ehi, elo, hi, ix, iy, sign_bias, topx, topy, x2, y, yint, v1, v10, v11, v12, v13, v14, v15, v2, v3, v4, v5, v6, v7, v8
	sign_bias = uint32(0)
	ix = *(*Tuint64_t)(unsafe.Pointer(&x1))
	iy = *(*Tuint64_t)(unsafe.Pointer(&y1))
	topx = _top124(tls, x1)
	topy = _top124(tls, y1)
	if topx-uint32(0x001) >= uint32(Int32FromInt32(0x7ff)-Int32FromInt32(0x001)) || topy&uint32(0x7ff)-uint32(0x3be) >= uint32(Int32FromInt32(0x43e)-Int32FromInt32(0x3be)) {
		/* Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0
		   and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.  */
		/* Special cases: (x < 0x1p-126 or inf or nan) or
		   (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).  */
		if _zeroinfnan(tls, iy) != 0 {
			if uint64(2)*iy == uint64(0) {
				return float64(1)
			}
			v1 = float64(1)
			if ix == *(*Tuint64_t)(unsafe.Pointer(&v1)) {
				return float64(1)
			}
			v2 = float64(X__builtin_inff(tls))
			if v4 = uint64(2)*ix > uint64(2)**(*Tuint64_t)(unsafe.Pointer(&v2)); !v4 {
				v3 = float64(X__builtin_inff(tls))
			}
			if v4 || uint64(2)*iy > uint64(2)**(*Tuint64_t)(unsafe.Pointer(&v3)) {
				return x1 + y1
			}
			v5 = float64(1)
			if uint64(2)*ix == uint64(2)**(*Tuint64_t)(unsafe.Pointer(&v5)) {
				return float64(1)
			}
			v6 = float64(1)
			if BoolInt32(uint64(2)*ix < uint64(2)**(*Tuint64_t)(unsafe.Pointer(&v6))) == BoolInt32(!(iy>>Int32FromInt32(63) != 0)) {
				return float64(0)
			} /* |x|<1 && y==inf or |x|>1 && y==-inf.  */
			return y1 * y1
		}
		if _zeroinfnan(tls, ix) != 0 {
			x2 = x1 * x1
			if ix>>int32(63) != 0 && _checkint(tls, iy) == int32(1) {
				x2 = -x2
			}
			/* Without the barrier some versions of clang hoist the 1/x2 and
			   thus division by zero exception can be signaled spuriously.  */
			if iy>>int32(63) != 0 {
				y = Float64FromInt32(1) / x2
				v8 = y
				goto _9
			_9:
				v7 = v8
			} else {
				v7 = x2
			}
			return v7
		}
		/* Here x and y are non-zero finite.  */
		if ix>>int32(63) != 0 {
			/* Finite x < 0.  */
			yint = _checkint(tls, iy)
			if yint == 0 {
				return X__math_invalid(tls, x1)
			}
			if yint == int32(1) {
				sign_bias = uint32(Int32FromInt32(0x800) << Int32FromInt32(EXP_TABLE_BITS))
			}
			ix &= uint64(0x7fffffffffffffff)
			topx &= uint32(0x7ff)
		}
		if topy&uint32(0x7ff)-uint32(0x3be) >= uint32(Int32FromInt32(0x43e)-Int32FromInt32(0x3be)) {
			/* Note: sign_bias == 0 here because y is not odd.  */
			v10 = float64(1)
			if ix == *(*Tuint64_t)(unsafe.Pointer(&v10)) {
				return float64(1)
			}
			if topy&uint32(0x7ff) < uint32(0x3be) {
				/* |y| < 2^-65, x^y ~= 1 + y*log(x).  */
				if int32(WANT_ROUNDING) != 0 {
					v12 = float64(1)
					if ix > *(*Tuint64_t)(unsafe.Pointer(&v12)) {
						v11 = float64(1) + y1
					} else {
						v11 = float64(1) - y1
					}
					return v11
				} else {
					return float64(1)
				}
			}
			v14 = float64(1)
			if BoolInt32(ix > *(*Tuint64_t)(unsafe.Pointer(&v14))) == BoolInt32(topy < uint32(0x800)) {
				v13 = X__math_oflow(tls, uint32(0))
			} else {
				v13 = X__math_uflow(tls, uint32(0))
			}
			return v13
		}
		if topx == uint32(0) {
			/* Normalize subnormal x so exponent becomes negative.  */
			v15 = x1 * float64(4.503599627370496e+15)
			ix = *(*Tuint64_t)(unsafe.Pointer(&v15))
			ix &= uint64(0x7fffffffffffffff)
			ix = ix - Uint64FromUint64(52)<<Int32FromInt32(52)
		}
	}
	hi = _log_inline(tls, ix, bp)
	ehi = y1 * hi
	elo = y1**(*Tdouble_t)(unsafe.Pointer(bp)) + X__builtin_fma(tls, y1, hi, -ehi)
	return _exp_inline(tls, ehi, elo, sign_bias)
}

const N9 = 128

type Tpow_log_data = struct {
	Fln2hi float64
	Fln2lo float64
	Fpoly  [7]float64
	Ftab   [128]struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	}
}

const OFF3 = 1060306944
const POWF_LOG2_POLY_ORDER = 5
const POWF_LOG2_TABLE_BITS = 4
const POWF_SCALE_BITS = 0
const SIGN_BIAS1 = 65536

/*
POWF_LOG2_POLY_ORDER = 5
EXP2F_TABLE_BITS = 5

ULP error: 0.82 (~ 0.5 + relerr*2^24)
relerr: 1.27 * 2^-26 (Relative error ~= 128*Ln2*relerr_log2 + relerr_exp2)
relerr_log2: 1.83 * 2^-33 (Relative error of logx.)
relerr_exp2: 1.69 * 2^-34 (Relative error of exp2(ylogx).)
*/

// C documentation
//
//	/* Subnormal input is normalized so ix has negative biased exponent.
//	   Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.  */
func _log2_inline(tls *TLS, ix Tuint32_t) (r1 Tdouble_t) {
	var i, k int32
	var invc, logc, p, q, r, r2, r4, y, y0, z Tdouble_t
	var iz, tmp, top Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, invc, iz, k, logc, p, q, r, r2, r4, tmp, top, y, y0, z
	/* x = 2^k z; where z is in range [OFF,2*OFF] and exact.
	   The range is split into N subintervals.
	   The ith subinterval contains z and c is near its center.  */
	tmp = ix - uint32(OFF3)
	i = int32(tmp >> (Int32FromInt32(23) - Int32FromInt32(POWF_LOG2_TABLE_BITS)) % uint32(Int32FromInt32(1)<<Int32FromInt32(POWF_LOG2_TABLE_BITS)))
	top = tmp & uint32(0xff800000)
	iz = ix - top
	k = int32(top) >> (Int32FromInt32(23) - Int32FromInt32(POWF_SCALE_BITS)) /* arithmetic shift */
	invc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__powf_log2_data)) + uintptr(i)*16))).Finvc
	logc = (*(*struct {
		Finvc float64
		Flogc float64
	})(unsafe.Pointer(uintptr(unsafe.Pointer(&X__powf_log2_data)) + uintptr(i)*16))).Flogc
	z = float64(*(*float32)(unsafe.Pointer(&iz)))
	/* log2(x) = log1p(z/c-1)/ln2 + log2(c) + k */
	r = z*invc - Float64FromInt32(1)
	y0 = logc + float64(k)
	/* Pipelined polynomial evaluation to approximate log1p(r)/ln2.  */
	r2 = r * r
	y = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__powf_log2_data)) + 256))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__powf_log2_data)) + 256 + 1*8))
	p = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__powf_log2_data)) + 256 + 2*8))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__powf_log2_data)) + 256 + 3*8))
	r4 = r2 * r2
	q = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__powf_log2_data)) + 256 + 4*8))*r + y0
	q = p*r2 + q
	y = y*r4 + q
	return y
}

// C documentation
//
//	/* The output of log2 and thus the input of exp2 is either scaled by N
//	   (in case of fast toint intrinsics) or not.  The unscaled xd must be
//	   in [-1021,1023], sign_bias sets the sign of the result.  */
func _exp2_inline(tls *TLS, xd Tdouble_t, sign_bias Tuint32_t) (r1 float32) {
	var kd, r, r2, s, y2, z Tdouble_t
	var ki, ski, t Tuint64_t
	var y, v4 float32
	var y1, v1, v3 float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = kd, ki, r, r2, s, ski, t, y, y1, y2, z, v1, v3, v4
	/* x = k/N + r with r in [-1/(2N), 1/(2N)] */
	y1 = xd + X__exp2f_data.Fshift_scaled
	v1 = y1
	goto _2
_2:
	kd = v1
	v3 = kd
	ki = *(*Tuint64_t)(unsafe.Pointer(&v3))
	kd -= X__exp2f_data.Fshift_scaled /* k/N */
	r = xd - kd
	/* exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1) */
	t = *(*Tuint64_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + uintptr(ki%uint64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)))*8))
	ski = ki + uint64(sign_bias)
	t += ski << (Int32FromInt32(52) - Int32FromInt32(EXP2F_TABLE_BITS))
	s = *(*float64)(unsafe.Pointer(&t))
	z = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 264))*r + *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 264 + 1*8))
	r2 = r * r
	y2 = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__exp2f_data)) + 264 + 2*8))*r + Float64FromInt32(1)
	y2 = z*r2 + y2
	y2 = y2 * s
	y = float32(y2)
	v4 = y
	goto _5
_5:
	return v4
}

// C documentation
//
//	/* Returns 0 if not int, 1 if odd int, 2 if even int.  The argument is
//	   the bit representation of a non-zero finite floating-point value.  */
func _checkint1(tls *TLS, iy Tuint32_t) (r int32) {
	var e int32
	_ = e
	e = int32(iy >> int32(23) & uint32(0xff))
	if e < int32(0x7f) {
		return 0
	}
	if e > Int32FromInt32(0x7f)+Int32FromInt32(23) {
		return int32(2)
	}
	if iy&uint32(Int32FromInt32(1)<<(Int32FromInt32(0x7f)+Int32FromInt32(23)-e)-Int32FromInt32(1)) != 0 {
		return 0
	}
	if iy&uint32(Int32FromInt32(1)<<(Int32FromInt32(0x7f)+Int32FromInt32(23)-e)) != 0 {
		return int32(1)
	}
	return int32(2)
}

func _zeroinfnan1(tls *TLS, ix Tuint32_t) (r int32) {
	return BoolInt32(uint32(2)*ix-uint32(1) >= Uint32FromUint32(2)*Uint32FromInt32(0x7f800000)-Uint32FromInt32(1))
}

func Xpowf(tls *TLS, x1 float32, y1 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x1=%v y1=%v, (%v:)", tls, x1, y1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ix, iy, sign_bias Tuint32_t
	var logx, ylogx Tdouble_t
	var x2 Tfloat_t
	var y, v1, v2, v4 float32
	var yint int32
	var v5, v6 float64
	_, _, _, _, _, _, _, _, _, _, _, _, _ = ix, iy, logx, sign_bias, x2, y, yint, ylogx, v1, v2, v4, v5, v6
	sign_bias = uint32(0)
	ix = *(*Tuint32_t)(unsafe.Pointer(&x1))
	iy = *(*Tuint32_t)(unsafe.Pointer(&y1))
	if ix-uint32(0x00800000) >= uint32(Int32FromInt32(0x7f800000)-Int32FromInt32(0x00800000)) || _zeroinfnan1(tls, iy) != 0 {
		/* Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).  */
		if _zeroinfnan1(tls, iy) != 0 {
			if uint32(2)*iy == uint32(0) {
				return Float32FromFloat32(1)
			}
			if ix == uint32(0x3f800000) {
				return Float32FromFloat32(1)
			}
			if uint32(2)*ix > Uint32FromUint32(2)*Uint32FromInt32(0x7f800000) || uint32(2)*iy > Uint32FromUint32(2)*Uint32FromInt32(0x7f800000) {
				return x1 + y1
			}
			if uint32(2)*ix == uint32(Int32FromInt32(2)*Int32FromInt32(0x3f800000)) {
				return Float32FromFloat32(1)
			}
			if BoolInt32(uint32(2)*ix < uint32(Int32FromInt32(2)*Int32FromInt32(0x3f800000))) == BoolInt32(!(iy&Uint32FromUint32(0x80000000) != 0)) {
				return Float32FromFloat32(0)
			} /* |x|<1 && y==inf or |x|>1 && y==-inf.  */
			return y1 * y1
		}
		if _zeroinfnan1(tls, ix) != 0 {
			x2 = x1 * x1
			if ix&uint32(0x80000000) != 0 && _checkint1(tls, iy) == int32(1) {
				x2 = -x2
			}
			/* Without the barrier some versions of clang hoist the 1/x2 and
			   thus division by zero exception can be signaled spuriously.  */
			if iy&uint32(0x80000000) != 0 {
				y = Float32FromInt32(1) / x2
				v2 = y
				goto _3
			_3:
				v1 = v2
			} else {
				v1 = x2
			}
			return v1
		}
		/* x and y are non-zero finite.  */
		if ix&uint32(0x80000000) != 0 {
			/* Finite x < 0.  */
			yint = _checkint1(tls, iy)
			if yint == 0 {
				return X__math_invalidf(tls, x1)
			}
			if yint == int32(1) {
				sign_bias = uint32(Int32FromInt32(1) << (Int32FromInt32(EXP2F_TABLE_BITS) + Int32FromInt32(11)))
			}
			ix &= uint32(0x7fffffff)
		}
		if ix < uint32(0x00800000) {
			/* Normalize subnormal x so exponent becomes negative.  */
			v4 = x1 * Float32FromFloat32(8.388608e+06)
			ix = *(*Tuint32_t)(unsafe.Pointer(&v4))
			ix &= uint32(0x7fffffff)
			ix -= uint32(Int32FromInt32(23) << Int32FromInt32(23))
		}
	}
	logx = _log2_inline(tls, ix)
	ylogx = float64(y1) * logx /* cannot overflow, y is single prec.  */
	v5 = ylogx
	v6 = float64(126) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS))
	if *(*Tuint64_t)(unsafe.Pointer(&v5))>>int32(47)&uint64(0xffff) >= *(*Tuint64_t)(unsafe.Pointer(&v6))>>int32(47) {
		/* |y*log(x)| >= 126.  */
		if ylogx > float64(127.99999995700433)*float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)) {
			return X__math_oflowf(tls, sign_bias)
		}
		if ylogx <= -Float64FromFloat64(150)*float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)) {
			return X__math_uflowf(tls, sign_bias)
		}
	}
	return _exp2_inline(tls, ylogx, sign_bias)
}

type Tpowf_log2_data = struct {
	Ftab [16]struct {
		Finvc float64
		Flogc float64
	}
	Fpoly [5]float64
}

func Xpowl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xpow(tls, x, y)
}

func Xremainder(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* q at bp+0 */ int32
	return Xremquo(tls, x, y, bp)
}

func Xdrem(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xremainder(tls, x, y)
}

func Xremainderf(tls *TLS, x float32, y float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* q at bp+0 */ int32
	return Xremquof(tls, x, y, bp)
}

func Xdremf(tls *TLS, x float32, y float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xremainderf(tls, x, y)
}

func Xremainderl(tls *TLS, x float64, y float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v, (%v:)", tls, x, y, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xremainder(tls, x, y)
}

func Xremquo(tls *TLS, x float64, y float64, quo uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v quo=%v, (%v:)", tls, x, y, quo, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ex, ey, sx, sy, v10 int32
	var i, uxi Tuint64_t
	var q Tuint32_t
	var v1 uint64
	var v11 float64
	var v3 bool
	var p6, p7 uintptr
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	var _ /* ux at bp+8 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	var _ /* uy at bp+16 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _ = ex, ey, i, q, sx, sy, uxi, v1, v10, v11, v3, p6, p7
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 8)) = x
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp + 16)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp + 16)) = y
	ex = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(52) & uint64(0x7ff))
	ey = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 16)) >> int32(52) & uint64(0x7ff))
	sx = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 8)) >> int32(63))
	sy = int32(*(*Tuint64_t)(unsafe.Pointer(bp + 16)) >> int32(63))
	uxi = *(*Tuint64_t)(unsafe.Pointer(bp + 8))
	*(*int32)(unsafe.Pointer(quo)) = 0
	if v3 = *(*Tuint64_t)(unsafe.Pointer(bp + 16))<<int32(1) == uint64(0); !v3 {
		*(*float64)(unsafe.Pointer(bp)) = y
		v1 = *(*uint64)(unsafe.Pointer(bp))
		goto _2
	_2:
	}
	if v3 || BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 || ex == int32(0x7ff) {
		return x * y / (x * y)
	}
	if *(*Tuint64_t)(unsafe.Pointer(bp + 8))<<int32(1) == uint64(0) {
		return x
	}
	/* normalize x and y */
	if !(ex != 0) {
		i = uxi << int32(12)
		for {
			if !(i>>int32(63) == uint64(0)) {
				break
			}
			goto _4
		_4:
			;
			ex--
			i <<= uint64(1)
		}
		uxi <<= uint64(-ex + int32(1))
	} else {
		uxi = uxi & (-Uint64FromUint64(1) >> Int32FromInt32(12))
		uxi = uxi | Uint64FromUint64(1)<<Int32FromInt32(52)
	}
	if !(ey != 0) {
		i = *(*Tuint64_t)(unsafe.Pointer(bp + 16)) << int32(12)
		for {
			if !(i>>int32(63) == uint64(0)) {
				break
			}
			goto _5
		_5:
			;
			ey--
			i <<= uint64(1)
		}
		*(*Tuint64_t)(unsafe.Pointer(bp + 16)) <<= uint64(-ey + int32(1))
	} else {
		p6 = bp + 16
		*(*Tuint64_t)(unsafe.Pointer(p6)) = *(*Tuint64_t)(unsafe.Pointer(p6)) & (-Uint64FromUint64(1) >> Int32FromInt32(12))
		p7 = bp + 16
		*(*Tuint64_t)(unsafe.Pointer(p7)) = *(*Tuint64_t)(unsafe.Pointer(p7)) | Uint64FromUint64(1)<<Int32FromInt32(52)
	}
	q = uint32(0)
	if ex < ey {
		if ex+int32(1) == ey {
			goto end
		}
		return x
	}
	/* x mod y */
	for {
		if !(ex > ey) {
			break
		}
		i = uxi - *(*Tuint64_t)(unsafe.Pointer(bp + 16))
		if i>>int32(63) == uint64(0) {
			uxi = i
			q++
		}
		uxi <<= uint64(1)
		q <<= uint32(1)
		goto _8
	_8:
		;
		ex--
	}
	i = uxi - *(*Tuint64_t)(unsafe.Pointer(bp + 16))
	if i>>int32(63) == uint64(0) {
		uxi = i
		q++
	}
	if uxi == uint64(0) {
		ex = -int32(60)
	} else {
		for {
			if !(uxi>>int32(52) == uint64(0)) {
				break
			}
			goto _9
		_9:
			;
			uxi <<= uint64(1)
			ex--
		}
	}
	goto end
end:
	;
	/* scale result and decide between |x| and |x|-|y| */
	if ex > 0 {
		uxi = uxi - Uint64FromUint64(1)<<Int32FromInt32(52)
		uxi |= uint64(ex) << int32(52)
	} else {
		uxi >>= uint64(-ex + int32(1))
	}
	*(*Tuint64_t)(unsafe.Pointer(bp + 8)) = uxi
	x = *(*float64)(unsafe.Pointer(bp + 8))
	if sy != 0 {
		y = -y
	}
	if ex == ey || ex+int32(1) == ey && (Float64FromInt32(2)*x > y || Float64FromInt32(2)*x == y && q%uint32(2) != 0) {
		x -= y
		q++
	}
	q &= uint32(0x7fffffff)
	if sx^sy != 0 {
		v10 = -int32(q)
	} else {
		v10 = int32(q)
	}
	*(*int32)(unsafe.Pointer(quo)) = v10
	if sx != 0 {
		v11 = -x
	} else {
		v11 = x
	}
	return v11
}

func Xremquof(tls *TLS, x float32, y float32, quo uintptr) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v quo=%v, (%v:)", tls, x, y, quo, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ex, ey, sx, sy, v8 int32
	var i, q, uxi Tuint32_t
	var v1 uint32
	var v3 bool
	var v9 float32
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	var _ /* ux at bp+4 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	var _ /* uy at bp+8 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _, _, _, _, _ = ex, ey, i, q, sx, sy, uxi, v1, v3, v8, v9
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 4)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 4)) = x
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp + 8)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp + 8)) = y
	ex = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(23) & uint32(0xff))
	ey = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 8)) >> int32(23) & uint32(0xff))
	sx = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 4)) >> int32(31))
	sy = int32(*(*Tuint32_t)(unsafe.Pointer(bp + 8)) >> int32(31))
	uxi = *(*Tuint32_t)(unsafe.Pointer(bp + 4))
	*(*int32)(unsafe.Pointer(quo)) = 0
	if v3 = *(*Tuint32_t)(unsafe.Pointer(bp + 8))<<int32(1) == uint32(0); !v3 {
		*(*float32)(unsafe.Pointer(bp)) = y
		v1 = *(*uint32)(unsafe.Pointer(bp))
		goto _2
	_2:
	}
	if v3 || BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 || ex == int32(0xff) {
		return x * y / (x * y)
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp + 4))<<int32(1) == uint32(0) {
		return x
	}
	/* normalize x and y */
	if !(ex != 0) {
		i = uxi << int32(9)
		for {
			if !(i>>int32(31) == uint32(0)) {
				break
			}
			goto _4
		_4:
			;
			ex--
			i <<= uint32(1)
		}
		uxi <<= uint32(-ex + int32(1))
	} else {
		uxi &= -Uint32FromUint32(1) >> Int32FromInt32(9)
		uxi |= Uint32FromUint32(1) << Int32FromInt32(23)
	}
	if !(ey != 0) {
		i = *(*Tuint32_t)(unsafe.Pointer(bp + 8)) << int32(9)
		for {
			if !(i>>int32(31) == uint32(0)) {
				break
			}
			goto _5
		_5:
			;
			ey--
			i <<= uint32(1)
		}
		*(*Tuint32_t)(unsafe.Pointer(bp + 8)) <<= uint32(-ey + int32(1))
	} else {
		*(*Tuint32_t)(unsafe.Pointer(bp + 8)) &= -Uint32FromUint32(1) >> Int32FromInt32(9)
		*(*Tuint32_t)(unsafe.Pointer(bp + 8)) |= Uint32FromUint32(1) << Int32FromInt32(23)
	}
	q = uint32(0)
	if ex < ey {
		if ex+int32(1) == ey {
			goto end
		}
		return x
	}
	/* x mod y */
	for {
		if !(ex > ey) {
			break
		}
		i = uxi - *(*Tuint32_t)(unsafe.Pointer(bp + 8))
		if i>>int32(31) == uint32(0) {
			uxi = i
			q++
		}
		uxi <<= uint32(1)
		q <<= uint32(1)
		goto _6
	_6:
		;
		ex--
	}
	i = uxi - *(*Tuint32_t)(unsafe.Pointer(bp + 8))
	if i>>int32(31) == uint32(0) {
		uxi = i
		q++
	}
	if uxi == uint32(0) {
		ex = -int32(30)
	} else {
		for {
			if !(uxi>>int32(23) == uint32(0)) {
				break
			}
			goto _7
		_7:
			;
			uxi <<= uint32(1)
			ex--
		}
	}
	goto end
end:
	;
	/* scale result and decide between |x| and |x|-|y| */
	if ex > 0 {
		uxi -= Uint32FromUint32(1) << Int32FromInt32(23)
		uxi |= uint32(ex) << int32(23)
	} else {
		uxi >>= uint32(-ex + int32(1))
	}
	*(*Tuint32_t)(unsafe.Pointer(bp + 4)) = uxi
	x = *(*float32)(unsafe.Pointer(bp + 4))
	if sy != 0 {
		y = -y
	}
	if ex == ey || ex+int32(1) == ey && (Float32FromInt32(2)*x > y || Float32FromInt32(2)*x == y && q%uint32(2) != 0) {
		x -= y
		q++
	}
	q &= uint32(0x7fffffff)
	if sx^sy != 0 {
		v8 = -int32(q)
	} else {
		v8 = int32(q)
	}
	*(*int32)(unsafe.Pointer(quo)) = v8
	if sx != 0 {
		v9 = -x
	} else {
		v9 = x
	}
	return v9
}

func Xremquol(tls *TLS, x float64, y float64, quo uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v y=%v quo=%v, (%v:)", tls, x, y, quo, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xremquo(tls, x, y, quo)
}

const DBL_EPSILON9 = 2.220446049250313e-16

var _toint4 = Float64FromInt32(1) / Float64FromFloat64(2.220446049250313e-16)

func Xrint(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, s int32
	var y Tdouble_t
	var v1 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _ = e, s, y, v1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	s = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	if e >= Int32FromInt32(0x3ff)+Int32FromInt32(52) {
		return x
	}
	if s != 0 {
		y = x - _toint4 + _toint4
	} else {
		y = x + _toint4 - _toint4
	}
	if y == Float64FromInt32(0) {
		if s != 0 {
			v1 = -Float64FromFloat64(0)
		} else {
			v1 = Float64FromInt32(0)
		}
		return v1
	}
	return y
}

const DBL_EPSILON10 = 0
const FLT_EPSILON1 = 1.1920928955078125e-07

var _toint5 = Float32FromInt32(1) / Float32FromFloat32(1.1920928955078125e-07)

func Xrintf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e, s int32
	var y Tfloat_t
	var v1 float32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _ = e, s, y, v1
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	s = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	if e >= Int32FromInt32(0x7f)+Int32FromInt32(23) {
		return x
	}
	if s != 0 {
		y = x - _toint5 + _toint5
	} else {
		y = x + _toint5 - _toint5
	}
	if y == Float32FromInt32(0) {
		if s != 0 {
			v1 = -Float32FromFloat32(0)
		} else {
			v1 = Float32FromFloat32(0)
		}
		return v1
	}
	return y
}

const FLT_EPSILON2 = 0

func Xrintl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xrint(tls, x)
}

const DBL_EPSILON11 = 2.220446049250313e-16

var _toint6 = Float64FromInt32(1) / Float64FromFloat64(2.220446049250313e-16)

func Xround(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var y float32
	var y1, y2 float64
	var y3 Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _ = e, y, y1, y2, y3
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(52) & uint64(0x7ff))
	if e >= Int32FromInt32(0x3ff)+Int32FromInt32(52) {
		return x3
	}
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		x3 = -x3
	}
	if e < Int32FromInt32(0x3ff)-Int32FromInt32(1) {
		/* raise inexact if x!=0 */
		if uint64(8) == uint64(4) {
			y = float32(x3 + _toint6)
		} else {
			if uint64(8) == uint64(8) {
				y1 = x3 + _toint6
			} else {
				y2 = x3 + _toint6
			}
		}
		return Float64FromInt32(0) * *(*float64)(unsafe.Pointer(bp))
	}
	y3 = x3 + _toint6 - _toint6 - x3
	if y3 > float64(0.5) {
		y3 = y3 + x3 - Float64FromInt32(1)
	} else {
		if y3 <= -Float64FromFloat64(0.5) {
			y3 = y3 + x3 + Float64FromInt32(1)
		} else {
			y3 = y3 + x3
		}
	}
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		y3 = -y3
	}
	return y3
}

const DBL_EPSILON12 = 0
const FLT_EPSILON3 = 1.1920928955078125e-07

var _toint7 = Float32FromInt32(1) / Float32FromFloat32(1.1920928955078125e-07)

func Xroundf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var y float32
	var y1, y2 float64
	var y3 Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _ = e, y, y1, y2, y3
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(23) & uint32(0xff))
	if e >= Int32FromInt32(0x7f)+Int32FromInt32(23) {
		return x3
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
		x3 = -x3
	}
	if e < Int32FromInt32(0x7f)-Int32FromInt32(1) {
		if uint64(4) == uint64(4) {
			y = x3 + _toint7
		} else {
			if uint64(4) == uint64(8) {
				y1 = float64(x3 + _toint7)
			} else {
				y2 = float64(x3 + _toint7)
			}
		}
		return Float32FromInt32(0) * *(*float32)(unsafe.Pointer(bp))
	}
	y3 = x3 + _toint7 - _toint7 - x3
	if y3 > Float32FromFloat32(0.5) {
		y3 = y3 + x3 - Float32FromInt32(1)
	} else {
		if y3 <= -Float32FromFloat32(0.5) {
			y3 = y3 + x3 + Float32FromInt32(1)
		} else {
			y3 = y3 + x3
		}
	}
	if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
		y3 = -y3
	}
	return y3
}

const FLT_EPSILON4 = 0

func Xroundl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xround(tls, x)
}

func Xscalb(tls *TLS, x float64, fn float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v fn=%v, (%v:)", tls, x, fn, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v3, v6 uint64
	var v5 bool
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	_, _, _, _ = v1, v3, v5, v6
	*(*float64)(unsafe.Pointer(bp)) = x
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0; !v5 {
		*(*float64)(unsafe.Pointer(bp)) = fn
		v3 = *(*uint64)(unsafe.Pointer(bp))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) > Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0 {
		return x * fn
	}
	*(*float64)(unsafe.Pointer(bp)) = fn
	v6 = *(*uint64)(unsafe.Pointer(bp))
	goto _7
_7:
	if !(BoolInt32(v6&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		if fn > float64(0) {
			return x * fn
		} else {
			return x / -fn
		}
	}
	if Xrint(tls, fn) != fn {
		return (fn - fn) / (fn - fn)
	}
	if fn > float64(65000) {
		return Xscalbn(tls, x, int32(65000))
	}
	if -fn > float64(65000) {
		return Xscalbn(tls, x, -int32(65000))
	}
	return Xscalbn(tls, x, int32(fn))
}

func Xscalbf(tls *TLS, x float32, fn float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v fn=%v, (%v:)", tls, x, fn, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v3, v6 uint32
	var v5 bool
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint32
		F__f float32
	}
	_, _, _, _ = v1, v3, v5, v6
	*(*float32)(unsafe.Pointer(bp)) = x
	v1 = *(*uint32)(unsafe.Pointer(bp))
	goto _2
_2:
	;
	if v5 = BoolInt32(v1&uint32(0x7fffffff) > uint32(0x7f800000)) != 0; !v5 {
		*(*float32)(unsafe.Pointer(bp)) = fn
		v3 = *(*uint32)(unsafe.Pointer(bp))
		goto _4
	_4:
	}
	if v5 || BoolInt32(v3&uint32(0x7fffffff) > uint32(0x7f800000)) != 0 {
		return x * fn
	}
	*(*float32)(unsafe.Pointer(bp)) = fn
	v6 = *(*uint32)(unsafe.Pointer(bp))
	goto _7
_7:
	if !(BoolInt32(v6&Uint32FromInt32(0x7fffffff) < Uint32FromInt32(0x7f800000)) != 0) {
		if fn > Float32FromFloat32(0) {
			return x * fn
		} else {
			return x / -fn
		}
	}
	if Xrintf(tls, fn) != fn {
		return (fn - fn) / (fn - fn)
	}
	if fn > Float32FromFloat32(65000) {
		return Xscalbnf(tls, x, int32(65000))
	}
	if -fn > Float32FromFloat32(65000) {
		return Xscalbnf(tls, x, -int32(65000))
	}
	return Xscalbnf(tls, x, int32(fn))
}

func Xscalbln(tls *TLS, x float64, n int64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if n > int64(INT_MAX) {
		n = int64(INT_MAX)
	} else {
		if n < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)) {
			n = int64(-Int32FromInt32(1) - Int32FromInt32(0x7fffffff))
		}
	}
	return Xscalbn(tls, x, int32(n))
}

func Xscalblnf(tls *TLS, x float32, n int64) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if n > int64(INT_MAX) {
		n = int64(INT_MAX)
	} else {
		if n < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)) {
			n = int64(-Int32FromInt32(1) - Int32FromInt32(0x7fffffff))
		}
	}
	return Xscalbnf(tls, x, int32(n))
}

func Xscalblnl(tls *TLS, x float64, n int64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xscalbln(tls, x, n)
}

func Xscalbn(tls *TLS, x float64, n int32) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var y Tdouble_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_ = y
	y = x
	if n > int32(1023) {
		y *= float64(8.98846567431158e+307)
		n -= int32(1023)
		if n > int32(1023) {
			y *= float64(8.98846567431158e+307)
			n -= int32(1023)
			if n > int32(1023) {
				n = int32(1023)
			}
		}
	} else {
		if n < -int32(1022) {
			/* make sure final n < -53 to avoid double
			   rounding in the subnormal range */
			y *= Float64FromFloat64(2.2250738585072014e-308) * Float64FromFloat64(9.007199254740992e+15)
			n += Int32FromInt32(1022) - Int32FromInt32(53)
			if n < -int32(1022) {
				y *= Float64FromFloat64(2.2250738585072014e-308) * Float64FromFloat64(9.007199254740992e+15)
				n += Int32FromInt32(1022) - Int32FromInt32(53)
				if n < -int32(1022) {
					n = -int32(1022)
				}
			}
		}
	}
	*(*Tuint64_t)(unsafe.Pointer(bp)) = uint64(Int32FromInt32(0x3ff)+n) << int32(52)
	x = y * *(*float64)(unsafe.Pointer(bp))
	return x
}

func Xscalbnf(tls *TLS, x float32, n int32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var y Tfloat_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_ = y
	y = x
	if n > int32(127) {
		y *= Float32FromFloat32(1.7014118346046923e+38)
		n -= int32(127)
		if n > int32(127) {
			y *= Float32FromFloat32(1.7014118346046923e+38)
			n -= int32(127)
			if n > int32(127) {
				n = int32(127)
			}
		}
	} else {
		if n < -int32(126) {
			y *= Float32FromFloat32(1.1754943508222875e-38) * Float32FromFloat32(1.6777216e+07)
			n += Int32FromInt32(126) - Int32FromInt32(24)
			if n < -int32(126) {
				y *= Float32FromFloat32(1.1754943508222875e-38) * Float32FromFloat32(1.6777216e+07)
				n += Int32FromInt32(126) - Int32FromInt32(24)
				if n < -int32(126) {
					n = -int32(126)
				}
			}
		}
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) = uint32(Int32FromInt32(0x7f)+n) << int32(23)
	x = y * *(*float32)(unsafe.Pointer(bp))
	return x
}

func Xscalbnl(tls *TLS, x float64, n int32) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v, (%v:)", tls, x, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xscalbn(tls, x, n)
}

func Xsignificand(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xscalbn(tls, x, -Xilogb(tls, x))
}

func Xsignificandf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xscalbnf(tls, x, -Xilogbf(tls, x))
}

func Xsin(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ix Tuint32_t
	var n uint32
	var y float32
	var y1, y2, v1, v2, v3 float64
	var _ /* y at bp+0 */ [2]float64
	_, _, _, _, _, _, _, _ = ix, n, y, y1, y2, v1, v2, v3
	/* High word of x. */
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x3)) >> int32(32))
	ix &= uint32(0x7fffffff)
	/* |x| ~< pi/4 */
	if ix <= uint32(0x3fe921fb) {
		if ix < uint32(0x3e500000) { /* |x| < 2**-26 */
			/* raise inexact if x != 0 and underflow if subnormal*/
			if uint64(8) == uint64(4) {
				if ix < uint32(0x00100000) {
					v1 = x3 / Float64FromFloat32(1.329227995784916e+36)
				} else {
					v1 = x3 + Float64FromFloat32(1.329227995784916e+36)
				}
				y = float32(v1)
			} else {
				if uint64(8) == uint64(8) {
					if ix < uint32(0x00100000) {
						v2 = x3 / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v2 = x3 + Float64FromFloat32(1.329227995784916e+36)
					}
					y1 = v2
				} else {
					if ix < uint32(0x00100000) {
						v3 = x3 / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v3 = x3 + Float64FromFloat32(1.329227995784916e+36)
					}
					y2 = v3
				}
			}
			return x3
		}
		return X__sin(tls, x3, float64(0), 0)
	}
	/* sin(Inf or NaN) is NaN */
	if ix >= uint32(0x7ff00000) {
		return x3 - x3
	}
	/* argument reduction needed */
	n = uint32(X__rem_pio2(tls, x3, bp))
	switch n & Uint32FromInt32(3) {
	case uint32(0):
		return X__sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	case uint32(1):
		return X__cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	case uint32(2):
		return -X__sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	default:
		return -X__cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	}
	return r
}

func Xsincos(tls *TLS, x3 float64, sin uintptr, cos uintptr) {
	if __ccgo_strace {
		trc("tls=%v x3=%v sin=%v cos=%v, (%v:)", tls, x3, sin, cos, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, s, y1, y2, v1, v2, v3, v4 float64
	var ix Tuint32_t
	var n uint32
	var y float32
	var _ /* y at bp+0 */ [2]float64
	_, _, _, _, _, _, _, _, _, _, _ = c, ix, n, s, y, y1, y2, v1, v2, v3, v4
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x3)) >> int32(32))
	ix &= uint32(0x7fffffff)
	/* |x| ~< pi/4 */
	if ix <= uint32(0x3fe921fb) {
		/* if |x| < 2**-27 * sqrt(2) */
		if ix < uint32(0x3e46a09e) {
			/* raise inexact if x!=0 and underflow if subnormal */
			if uint64(8) == uint64(4) {
				if ix < uint32(0x00100000) {
					v1 = x3 / Float64FromFloat32(1.329227995784916e+36)
				} else {
					v1 = x3 + Float64FromFloat32(1.329227995784916e+36)
				}
				y = float32(v1)
			} else {
				if uint64(8) == uint64(8) {
					if ix < uint32(0x00100000) {
						v2 = x3 / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v2 = x3 + Float64FromFloat32(1.329227995784916e+36)
					}
					y1 = v2
				} else {
					if ix < uint32(0x00100000) {
						v3 = x3 / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v3 = x3 + Float64FromFloat32(1.329227995784916e+36)
					}
					y2 = v3
				}
			}
			*(*float64)(unsafe.Pointer(sin)) = x3
			*(*float64)(unsafe.Pointer(cos)) = float64(1)
			return
		}
		*(*float64)(unsafe.Pointer(sin)) = X__sin(tls, x3, float64(0), 0)
		*(*float64)(unsafe.Pointer(cos)) = X__cos(tls, x3, float64(0))
		return
	}
	/* sincos(Inf or NaN) is NaN */
	if ix >= uint32(0x7ff00000) {
		v4 = x3 - x3
		*(*float64)(unsafe.Pointer(cos)) = v4
		*(*float64)(unsafe.Pointer(sin)) = v4
		return
	}
	/* argument reduction needed */
	n = uint32(X__rem_pio2(tls, x3, bp))
	s = X__sin(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(1))
	c = X__cos(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)])
	switch n & Uint32FromInt32(3) {
	case uint32(0):
		*(*float64)(unsafe.Pointer(sin)) = s
		*(*float64)(unsafe.Pointer(cos)) = c
	case uint32(1):
		*(*float64)(unsafe.Pointer(sin)) = c
		*(*float64)(unsafe.Pointer(cos)) = -s
	case uint32(2):
		*(*float64)(unsafe.Pointer(sin)) = -s
		*(*float64)(unsafe.Pointer(cos)) = -c
	case uint32(3):
		fallthrough
	default:
		*(*float64)(unsafe.Pointer(sin)) = -c
		*(*float64)(unsafe.Pointer(cos)) = s
		break
	}
}

const M_PI_25 = 1.5707963267948966

// C documentation
//
//	/* Small multiples of pi/2 rounded to double precision. */

var _s1pio2 = Float64FromInt32(1) * Float64FromFloat64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _s2pio2 = Float64FromInt32(2) * Float64FromFloat64(1.5707963267948966) /* 0x400921FB, 0x54442D18 */
var _s3pio2 = Float64FromInt32(3) * Float64FromFloat64(1.5707963267948966) /* 0x4012D97C, 0x7F3321D2 */
var _s4pio2 = Float64FromInt32(4) * Float64FromFloat64(1.5707963267948966) /* 0x401921FB, 0x54442D18 */

func Xsincosf(tls *TLS, x3 float32, sin uintptr, cos uintptr) {
	if __ccgo_strace {
		trc("tls=%v x3=%v sin=%v cos=%v, (%v:)", tls, x3, sin, cos, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, s Tfloat_t
	var ix Tuint32_t
	var n, sign uint32
	var y, v1, v2, v3, v8 float32
	var y1, y2, v4, v5, v6, v7 float64
	var _ /* y at bp+0 */ float64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, ix, n, s, sign, y, y1, y2, v1, v2, v3, v4, v5, v6, v7, v8
	ix = *(*Tuint32_t)(unsafe.Pointer(&x3))
	sign = ix >> int32(31)
	ix &= uint32(0x7fffffff)
	/* |x| ~<= pi/4 */
	if ix <= uint32(0x3f490fda) {
		/* |x| < 2**-12 */
		if ix < uint32(0x39800000) {
			/* raise inexact if x!=0 and underflow if subnormal */
			if uint64(4) == uint64(4) {
				if ix < uint32(0x00100000) {
					v1 = x3 / Float32FromFloat32(1.329227995784916e+36)
				} else {
					v1 = x3 + Float32FromFloat32(1.329227995784916e+36)
				}
				y = v1
			} else {
				if uint64(4) == uint64(8) {
					if ix < uint32(0x00100000) {
						v2 = x3 / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v2 = x3 + Float32FromFloat32(1.329227995784916e+36)
					}
					y1 = float64(v2)
				} else {
					if ix < uint32(0x00100000) {
						v3 = x3 / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v3 = x3 + Float32FromFloat32(1.329227995784916e+36)
					}
					y2 = float64(v3)
				}
			}
			*(*float32)(unsafe.Pointer(sin)) = x3
			*(*float32)(unsafe.Pointer(cos)) = Float32FromFloat32(1)
			return
		}
		*(*float32)(unsafe.Pointer(sin)) = X__sindf(tls, float64(x3))
		*(*float32)(unsafe.Pointer(cos)) = X__cosdf(tls, float64(x3))
		return
	}
	/* |x| ~<= 5*pi/4 */
	if ix <= uint32(0x407b53d1) {
		if ix <= uint32(0x4016cbe3) { /* |x| ~<= 3pi/4 */
			if sign != 0 {
				*(*float32)(unsafe.Pointer(sin)) = -X__cosdf(tls, float64(x3)+_s1pio2)
				*(*float32)(unsafe.Pointer(cos)) = X__sindf(tls, float64(x3)+_s1pio2)
			} else {
				*(*float32)(unsafe.Pointer(sin)) = X__cosdf(tls, _s1pio2-float64(x3))
				*(*float32)(unsafe.Pointer(cos)) = X__sindf(tls, _s1pio2-float64(x3))
			}
			return
		}
		/* -sin(x+c) is not correct if x+c could be 0: -0 vs +0 */
		if sign != 0 {
			v4 = float64(x3) + _s2pio2
		} else {
			v4 = float64(x3) - _s2pio2
		}
		*(*float32)(unsafe.Pointer(sin)) = -X__sindf(tls, v4)
		if sign != 0 {
			v5 = float64(x3) + _s2pio2
		} else {
			v5 = float64(x3) - _s2pio2
		}
		*(*float32)(unsafe.Pointer(cos)) = -X__cosdf(tls, v5)
		return
	}
	/* |x| ~<= 9*pi/4 */
	if ix <= uint32(0x40e231d5) {
		if ix <= uint32(0x40afeddf) { /* |x| ~<= 7*pi/4 */
			if sign != 0 {
				*(*float32)(unsafe.Pointer(sin)) = X__cosdf(tls, float64(x3)+_s3pio2)
				*(*float32)(unsafe.Pointer(cos)) = -X__sindf(tls, float64(x3)+_s3pio2)
			} else {
				*(*float32)(unsafe.Pointer(sin)) = -X__cosdf(tls, float64(x3)-_s3pio2)
				*(*float32)(unsafe.Pointer(cos)) = X__sindf(tls, float64(x3)-_s3pio2)
			}
			return
		}
		if sign != 0 {
			v6 = float64(x3) + _s4pio2
		} else {
			v6 = float64(x3) - _s4pio2
		}
		*(*float32)(unsafe.Pointer(sin)) = X__sindf(tls, v6)
		if sign != 0 {
			v7 = float64(x3) + _s4pio2
		} else {
			v7 = float64(x3) - _s4pio2
		}
		*(*float32)(unsafe.Pointer(cos)) = X__cosdf(tls, v7)
		return
	}
	/* sin(Inf or NaN) is NaN */
	if ix >= uint32(0x7f800000) {
		v8 = x3 - x3
		*(*float32)(unsafe.Pointer(cos)) = v8
		*(*float32)(unsafe.Pointer(sin)) = v8
		return
	}
	/* general argument reduction needed */
	n = uint32(X__rem_pio2f(tls, x3, bp))
	s = X__sindf(tls, *(*float64)(unsafe.Pointer(bp)))
	c = X__cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	switch n & Uint32FromInt32(3) {
	case uint32(0):
		*(*float32)(unsafe.Pointer(sin)) = s
		*(*float32)(unsafe.Pointer(cos)) = c
	case uint32(1):
		*(*float32)(unsafe.Pointer(sin)) = c
		*(*float32)(unsafe.Pointer(cos)) = -s
	case uint32(2):
		*(*float32)(unsafe.Pointer(sin)) = -s
		*(*float32)(unsafe.Pointer(cos)) = -c
	case uint32(3):
		fallthrough
	default:
		*(*float32)(unsafe.Pointer(sin)) = -c
		*(*float32)(unsafe.Pointer(cos)) = s
		break
	}
}

const M_PI_26 = 0

func Xsincosl(tls *TLS, x float64, sin uintptr, cos uintptr) {
	if __ccgo_strace {
		trc("tls=%v x=%v sin=%v cos=%v, (%v:)", tls, x, sin, cos, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* cosd at bp+8 */ float64
	var _ /* sind at bp+0 */ float64
	Xsincos(tls, x, bp, bp+8)
	*(*float64)(unsafe.Pointer(sin)) = *(*float64)(unsafe.Pointer(bp))
	*(*float64)(unsafe.Pointer(cos)) = *(*float64)(unsafe.Pointer(bp + 8))
}

const M_PI_27 = 1.5707963267948966

// C documentation
//
//	/* Small multiples of pi/2 rounded to double precision. */

var _s1pio21 = Float64FromInt32(1) * Float64FromFloat64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _s2pio21 = Float64FromInt32(2) * Float64FromFloat64(1.5707963267948966) /* 0x400921FB, 0x54442D18 */
var _s3pio21 = Float64FromInt32(3) * Float64FromFloat64(1.5707963267948966) /* 0x4012D97C, 0x7F3321D2 */
var _s4pio21 = Float64FromInt32(4) * Float64FromFloat64(1.5707963267948966) /* 0x401921FB, 0x54442D18 */

func Xsinf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ix Tuint32_t
	var n, sign int32
	var y, v1, v2, v3 float32
	var y1, y2, v4, v5 float64
	var _ /* y at bp+0 */ float64
	_, _, _, _, _, _, _, _, _, _, _ = ix, n, sign, y, y1, y2, v1, v2, v3, v4, v5
	ix = *(*Tuint32_t)(unsafe.Pointer(&x3))
	sign = int32(ix >> int32(31))
	ix &= uint32(0x7fffffff)
	if ix <= uint32(0x3f490fda) { /* |x| ~<= pi/4 */
		if ix < uint32(0x39800000) { /* |x| < 2**-12 */
			/* raise inexact if x!=0 and underflow if subnormal */
			if uint64(4) == uint64(4) {
				if ix < uint32(0x00800000) {
					v1 = x3 / Float32FromFloat32(1.329227995784916e+36)
				} else {
					v1 = x3 + Float32FromFloat32(1.329227995784916e+36)
				}
				y = v1
			} else {
				if uint64(4) == uint64(8) {
					if ix < uint32(0x00800000) {
						v2 = x3 / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v2 = x3 + Float32FromFloat32(1.329227995784916e+36)
					}
					y1 = float64(v2)
				} else {
					if ix < uint32(0x00800000) {
						v3 = x3 / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v3 = x3 + Float32FromFloat32(1.329227995784916e+36)
					}
					y2 = float64(v3)
				}
			}
			return x3
		}
		return X__sindf(tls, float64(x3))
	}
	if ix <= uint32(0x407b53d1) { /* |x| ~<= 5*pi/4 */
		if ix <= uint32(0x4016cbe3) { /* |x| ~<= 3pi/4 */
			if sign != 0 {
				return -X__cosdf(tls, float64(x3)+_s1pio21)
			} else {
				return X__cosdf(tls, float64(x3)-_s1pio21)
			}
		}
		if sign != 0 {
			v4 = -(float64(x3) + _s2pio21)
		} else {
			v4 = -(float64(x3) - _s2pio21)
		}
		return X__sindf(tls, v4)
	}
	if ix <= uint32(0x40e231d5) { /* |x| ~<= 9*pi/4 */
		if ix <= uint32(0x40afeddf) { /* |x| ~<= 7*pi/4 */
			if sign != 0 {
				return X__cosdf(tls, float64(x3)+_s3pio21)
			} else {
				return -X__cosdf(tls, float64(x3)-_s3pio21)
			}
		}
		if sign != 0 {
			v5 = float64(x3) + _s4pio21
		} else {
			v5 = float64(x3) - _s4pio21
		}
		return X__sindf(tls, v5)
	}
	/* sin(Inf or NaN) is NaN */
	if ix >= uint32(0x7f800000) {
		return x3 - x3
	}
	/* general argument reduction needed */
	n = X__rem_pio2f(tls, x3, bp)
	switch n & Int32FromInt32(3) {
	case 0:
		return X__sindf(tls, *(*float64)(unsafe.Pointer(bp)))
	case int32(1):
		return X__cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	case int32(2):
		return X__sindf(tls, -*(*float64)(unsafe.Pointer(bp)))
	default:
		return -X__cosdf(tls, *(*float64)(unsafe.Pointer(bp)))
	}
	return r
}

const M_PI_28 = 0

// C documentation
//
//	/* sinh(x) = (exp(x) - 1/exp(x))/2
//	 *         = (exp(x)-1 + (exp(x)-1)/exp(x))/2
//	 *         = x + x^3/6 + o(x^5)
//	 */
func Xsinh(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var absx, h, t float64
	var w Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _ = absx, h, t, w
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x
	h = float64(0.5)
	if *(*Tuint64_t)(unsafe.Pointer(bp))>>int32(63) != 0 {
		h = -h
	}
	/* |x| */
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= uint64(-Int32FromInt32(1)) / Uint64FromInt32(2)
	absx = *(*float64)(unsafe.Pointer(bp))
	w = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	/* |x| < log(DBL_MAX) */
	if w < uint32(0x40862e42) {
		t = Xexpm1(tls, absx)
		if w < uint32(0x3ff00000) {
			if w < uint32(Int32FromInt32(0x3ff00000)-Int32FromInt32(26)<<Int32FromInt32(20)) {
				/* note: inexact and underflow are raised by expm1 */
				/* note: this branch avoids spurious underflow */
				return x
			}
			return h * (Float64FromInt32(2)*t - t*t/(t+Float64FromInt32(1)))
		}
		/* note: |x|>log(0x1p26)+eps could be just h*exp(x) */
		return h * (t + t/(t+Float64FromInt32(1)))
	}
	/* |x| > log(DBL_MAX) or nan */
	/* note: the result is stored to handle overflow */
	t = X__expo2(tls, absx, Float64FromInt32(2)*h)
	return t
}

func Xsinhf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var absx, h, t float32
	var w Tuint32_t
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _ = absx, h, t, w
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x
	h = float32(0.5)
	if *(*Tuint32_t)(unsafe.Pointer(bp))>>int32(31) != 0 {
		h = -h
	}
	/* |x| */
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x7fffffff)
	absx = *(*float32)(unsafe.Pointer(bp))
	w = *(*Tuint32_t)(unsafe.Pointer(bp))
	/* |x| < log(FLT_MAX) */
	if w < uint32(0x42b17217) {
		t = Xexpm1f(tls, absx)
		if w < uint32(0x3f800000) {
			if w < uint32(Int32FromInt32(0x3f800000)-Int32FromInt32(12)<<Int32FromInt32(23)) {
				return x
			}
			return h * (Float32FromInt32(2)*t - t*t/(t+Float32FromInt32(1)))
		}
		return h * (t + t/(t+Float32FromInt32(1)))
	}
	/* |x| > logf(FLT_MAX) or nan */
	t = X__expo2f(tls, absx, Float32FromInt32(2)*h)
	return t
}

func Xsinhl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsinh(tls, x)
}

func Xsinl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsin(tls, x)
}

const FENV_SUPPORT = 1

// C documentation
//
//	/* returns a*b*2^-32 - e, with error 0 <= e < 1.  */
func _mul32(tls *TLS, a Tuint32_t, b Tuint32_t) (r Tuint32_t) {
	return uint32(uint64(a) * uint64(b) >> int32(32))
}

// C documentation
//
//	/* returns a*b*2^-64 - e, with error 0 <= e < 3.  */
func _mul64(tls *TLS, a Tuint64_t, b Tuint64_t) (r Tuint64_t) {
	var ahi, alo, bhi, blo Tuint64_t
	_, _, _, _ = ahi, alo, bhi, blo
	ahi = a >> int32(32)
	alo = a & uint64(0xffffffff)
	bhi = b >> int32(32)
	blo = b & uint64(0xffffffff)
	return ahi*bhi + ahi*blo>>int32(32) + alo*bhi>>int32(32)
}

func Xsqrt(tls *TLS, x1 float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x1=%v, (%v:)", tls, x1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var d, d0, d1, d2, i, ix, m, r, s, tiny, top, u Tuint64_t
	var even int32
	var t, y, y1, v1, v3 float64
	var v2 int64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = d, d0, d1, d2, even, i, ix, m, r, s, t, tiny, top, u, y, y1, v1, v2, v3
	/* special case handling.  */
	ix = *(*Tuint64_t)(unsafe.Pointer(&x1))
	top = ix >> int32(52)
	if top-uint64(0x001) >= uint64(Int32FromInt32(0x7ff)-Int32FromInt32(0x001)) {
		/* x < 0x1p-1022 or inf or nan.  */
		if ix*uint64(2) == uint64(0) {
			return x1
		}
		if ix == uint64(0x7ff0000000000000) {
			return x1
		}
		if ix > uint64(0x7ff0000000000000) {
			return X__math_invalid(tls, x1)
		}
		/* x is subnormal, normalize it.  */
		v1 = x1 * float64(4.503599627370496e+15)
		ix = *(*Tuint64_t)(unsafe.Pointer(&v1))
		top = ix >> int32(52)
		top -= uint64(52)
	}
	/* argument reduction:
	   x = 4^e m; with integer e, and m in [1, 4)
	   m: fixed point representation [2.62]
	   2^e is the exponent part of the result.  */
	even = int32(top & uint64(1))
	m = ix<<Int32FromInt32(11) | uint64(0x8000000000000000)
	if even != 0 {
		m >>= uint64(1)
	}
	top = (top + uint64(0x3ff)) >> int32(1)
	i = ix >> Int32FromInt32(46) % uint64(128)
	r = uint64(uint32(X__rsqrt_tab[i]) << int32(16))
	/* |r sqrt(m) - 1| < 0x1.fdp-9 */
	s = uint64(_mul32(tls, uint32(m>>int32(32)), uint32(r)))
	/* |s/sqrt(m) - 1| < 0x1.fdp-9 */
	d = uint64(_mul32(tls, uint32(s), uint32(r)))
	u = _three - d
	r = uint64(_mul32(tls, uint32(r), uint32(u)) << int32(1))
	/* |r sqrt(m) - 1| < 0x1.7bp-16 */
	s = uint64(_mul32(tls, uint32(s), uint32(u)) << int32(1))
	/* |s/sqrt(m) - 1| < 0x1.7bp-16 */
	d = uint64(_mul32(tls, uint32(s), uint32(r)))
	u = _three - d
	r = uint64(_mul32(tls, uint32(r), uint32(u)) << int32(1))
	/* |r sqrt(m) - 1| < 0x1.3704p-29 (measured worst-case) */
	r = r << int32(32)
	s = _mul64(tls, m, r)
	d = _mul64(tls, s, r)
	u = _three<<Int32FromInt32(32) - d
	s = _mul64(tls, s, u) /* repr: 3.61 */
	/* -0x1p-57 < s - sqrt(m) < 0x1.8001p-61 */
	s = (s - uint64(2)) >> int32(9)
	d0 = m<<Int32FromInt32(42) - s*s
	d1 = s - d0
	d2 = d1 + s + uint64(1)
	s += d1 >> int32(63)
	s &= uint64(0x000fffffffffffff)
	s |= top << int32(52)
	y1 = *(*float64)(unsafe.Pointer(&s))
	if int32(FENV_SUPPORT) != 0 {
		if d2 == uint64(0) {
			v2 = 0
		} else {
			v2 = int64(0x0010000000000000)
		}
		/* handle rounding modes and inexact exception:
		   only (s+1)^2 == 2^42 m case is exact otherwise
		   add a tiny value to cause the fenv effects.  */
		tiny = uint64(v2)
		tiny |= (d1 ^ d2) & uint64(0x8000000000000000)
		t = *(*float64)(unsafe.Pointer(&tiny))
		y = y1 + t
		v3 = y
		goto _4
	_4:
		y1 = v3
	}
	return y1
}

/* approximate r ~ 1/sqrt(m) and s ~ sqrt(m) when m in [1,4)

   initial estimate:
   7bit table lookup (1bit exponent and 6bit significand).

   iterative approximation:
   using 2 goldschmidt iterations with 32bit int arithmetics
   and a final iteration with 64bit int arithmetics.

   details:

   the relative error (e = r0 sqrt(m)-1) of a linear estimate
   (r0 = a m + b) is |e| < 0.085955 ~ 0x1.6p-4 at best,
   a table lookup is faster and needs one less iteration
   6 bit lookup table (128b) gives |e| < 0x1.f9p-8
   7 bit lookup table (256b) gives |e| < 0x1.fdp-9
   for single and double prec 6bit is enough but for quad
   prec 7bit is needed (or modified iterations). to avoid
   one more iteration >=13bit table would be needed (16k).

   a newton-raphson iteration for r is
     w = r*r
     u = 3 - m*w
     r = r*u/2
   can use a goldschmidt iteration for s at the end or
     s = m*r

   first goldschmidt iteration is
     s = m*r
     u = 3 - s*r
     r = r*u/2
     s = s*u/2
   next goldschmidt iteration is
     u = 3 - s*r
     r = r*u/2
     s = s*u/2
   and at the end r is not computed only s.

   they use the same amount of operations and converge at the
   same quadratic rate, i.e. if
     r1 sqrt(m) - 1 = e, then
     r2 sqrt(m) - 1 = -3/2 e^2 - 1/2 e^3
   the advantage of goldschmidt is that the mul for s and r
   are independent (computed in parallel), however it is not
   "self synchronizing": it only uses the input m in the
   first iteration so rounding errors accumulate. at the end
   or when switching to larger precision arithmetics rounding
   errors dominate so the first iteration should be used.

   the fixed point representations are
     m: 2.30 r: 0.32, s: 2.30, d: 2.30, u: 2.30, three: 2.30
   and after switching to 64 bit
     m: 2.62 r: 0.64, s: 2.62, d: 2.62, u: 2.62, three: 2.62  */

var _three = uint64(0xc0000000)

func _mul321(tls *TLS, a Tuint32_t, b Tuint32_t) (r Tuint32_t) {
	return uint32(uint64(a) * uint64(b) >> int32(32))
}

/* see sqrt.c for more detailed comments.  */

func Xsqrtf(tls *TLS, x1 float32) (r1 float32) {
	if __ccgo_strace {
		trc("tls=%v x1=%v, (%v:)", tls, x1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var d, d0, d1, d2, even, ey, i, ix, m, m0, m1, r, s, tiny, u Tuint32_t
	var t, y, y1, v1, v4 float32
	var v2 uint32
	var v3 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = d, d0, d1, d2, even, ey, i, ix, m, m0, m1, r, s, t, tiny, u, y, y1, v1, v2, v3, v4
	ix = *(*Tuint32_t)(unsafe.Pointer(&x1))
	if ix-uint32(0x00800000) >= uint32(Int32FromInt32(0x7f800000)-Int32FromInt32(0x00800000)) {
		/* x < 0x1p-126 or inf or nan.  */
		if ix*uint32(2) == uint32(0) {
			return x1
		}
		if ix == uint32(0x7f800000) {
			return x1
		}
		if ix > uint32(0x7f800000) {
			return X__math_invalidf(tls, x1)
		}
		/* x is subnormal, normalize it.  */
		v1 = x1 * Float32FromFloat32(8.388608e+06)
		ix = *(*Tuint32_t)(unsafe.Pointer(&v1))
		ix -= uint32(Int32FromInt32(23) << Int32FromInt32(23))
	}
	/* x = 4^e m; with int e and m in [1, 4).  */
	even = ix & uint32(0x00800000)
	m1 = ix<<Int32FromInt32(8) | uint32(0x80000000)
	m0 = ix << Int32FromInt32(7) & uint32(0x7fffffff)
	if even != 0 {
		v2 = m0
	} else {
		v2 = m1
	}
	m = v2
	/* 2^e is the exponent part of the return value.  */
	ey = ix >> int32(1)
	ey += uint32(Int32FromInt32(0x3f800000) >> Int32FromInt32(1))
	ey &= uint32(0x7f800000)
	i = ix >> Int32FromInt32(17) % uint32(128)
	r = uint32(X__rsqrt_tab[i]) << int32(16)
	/* |r*sqrt(m) - 1| < 0x1p-8 */
	s = _mul321(tls, m, r)
	/* |s/sqrt(m) - 1| < 0x1p-8 */
	d = _mul321(tls, s, r)
	u = _three1 - d
	r = _mul321(tls, r, u) << int32(1)
	/* |r*sqrt(m) - 1| < 0x1.7bp-16 */
	s = _mul321(tls, s, u) << int32(1)
	/* |s/sqrt(m) - 1| < 0x1.7bp-16 */
	d = _mul321(tls, s, r)
	u = _three1 - d
	s = _mul321(tls, s, u)
	/* -0x1.03p-28 < s/sqrt(m) - 1 < 0x1.fp-31 */
	s = (s - uint32(1)) >> int32(6)
	d0 = m<<Int32FromInt32(16) - s*s
	d1 = s - d0
	d2 = d1 + s + uint32(1)
	s += d1 >> int32(31)
	s &= uint32(0x007fffff)
	s |= ey
	y1 = *(*float32)(unsafe.Pointer(&s))
	if int32(FENV_SUPPORT) != 0 {
		if d2 == uint32(0) {
			v3 = 0
		} else {
			v3 = int32(0x01000000)
		}
		/* handle rounding and inexact exception. */
		tiny = uint32(v3)
		tiny |= (d1 ^ d2) & uint32(0x80000000)
		t = *(*float32)(unsafe.Pointer(&tiny))
		y = y1 + t
		v4 = y
		goto _5
	_5:
		y1 = v4
	}
	return y1
}

/* compute r ~ 1/sqrt(m), s ~ sqrt(m) with 2 goldschmidt iterations.  */
var _three1 = uint32(0xc0000000)

func Xsqrtl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsqrt(tls, x)
}

func Xtan(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ix Tuint32_t
	var n uint32
	var y float32
	var y1, y2, v1, v2, v3 float64
	var _ /* y at bp+0 */ [2]float64
	_, _, _, _, _, _, _, _ = ix, n, y, y1, y2, v1, v2, v3
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(&x3)) >> int32(32))
	ix &= uint32(0x7fffffff)
	/* |x| ~< pi/4 */
	if ix <= uint32(0x3fe921fb) {
		if ix < uint32(0x3e400000) { /* |x| < 2**-27 */
			/* raise inexact if x!=0 and underflow if subnormal */
			if uint64(8) == uint64(4) {
				if ix < uint32(0x00100000) {
					v1 = x3 / Float64FromFloat32(1.329227995784916e+36)
				} else {
					v1 = x3 + Float64FromFloat32(1.329227995784916e+36)
				}
				y = float32(v1)
			} else {
				if uint64(8) == uint64(8) {
					if ix < uint32(0x00100000) {
						v2 = x3 / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v2 = x3 + Float64FromFloat32(1.329227995784916e+36)
					}
					y1 = v2
				} else {
					if ix < uint32(0x00100000) {
						v3 = x3 / Float64FromFloat32(1.329227995784916e+36)
					} else {
						v3 = x3 + Float64FromFloat32(1.329227995784916e+36)
					}
					y2 = v3
				}
			}
			return x3
		}
		return X__tan(tls, x3, float64(0), 0)
	}
	/* tan(Inf or NaN) is NaN */
	if ix >= uint32(0x7ff00000) {
		return x3 - x3
	}
	/* argument reduction */
	n = uint32(X__rem_pio2(tls, x3, bp))
	return X__tan(tls, (*(*[2]float64)(unsafe.Pointer(bp)))[0], (*(*[2]float64)(unsafe.Pointer(bp)))[int32(1)], int32(n&uint32(1)))
}

const M_PI_29 = 1.5707963267948966

// C documentation
//
//	/* Small multiples of pi/2 rounded to double precision. */

var _t1pio2 = Float64FromInt32(1) * Float64FromFloat64(1.5707963267948966) /* 0x3FF921FB, 0x54442D18 */
var _t2pio2 = Float64FromInt32(2) * Float64FromFloat64(1.5707963267948966) /* 0x400921FB, 0x54442D18 */
var _t3pio2 = Float64FromInt32(3) * Float64FromFloat64(1.5707963267948966) /* 0x4012D97C, 0x7F3321D2 */
var _t4pio2 = Float64FromInt32(4) * Float64FromFloat64(1.5707963267948966) /* 0x401921FB, 0x54442D18 */

func Xtanf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ix Tuint32_t
	var n, sign uint32
	var y, v1, v2, v3 float32
	var y1, y2, v4, v5, v6, v7 float64
	var _ /* y at bp+0 */ float64
	_, _, _, _, _, _, _, _, _, _, _, _, _ = ix, n, sign, y, y1, y2, v1, v2, v3, v4, v5, v6, v7
	ix = *(*Tuint32_t)(unsafe.Pointer(&x3))
	sign = ix >> int32(31)
	ix &= uint32(0x7fffffff)
	if ix <= uint32(0x3f490fda) { /* |x| ~<= pi/4 */
		if ix < uint32(0x39800000) { /* |x| < 2**-12 */
			/* raise inexact if x!=0 and underflow if subnormal */
			if uint64(4) == uint64(4) {
				if ix < uint32(0x00800000) {
					v1 = x3 / Float32FromFloat32(1.329227995784916e+36)
				} else {
					v1 = x3 + Float32FromFloat32(1.329227995784916e+36)
				}
				y = v1
			} else {
				if uint64(4) == uint64(8) {
					if ix < uint32(0x00800000) {
						v2 = x3 / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v2 = x3 + Float32FromFloat32(1.329227995784916e+36)
					}
					y1 = float64(v2)
				} else {
					if ix < uint32(0x00800000) {
						v3 = x3 / Float32FromFloat32(1.329227995784916e+36)
					} else {
						v3 = x3 + Float32FromFloat32(1.329227995784916e+36)
					}
					y2 = float64(v3)
				}
			}
			return x3
		}
		return X__tandf(tls, float64(x3), 0)
	}
	if ix <= uint32(0x407b53d1) { /* |x| ~<= 5*pi/4 */
		if ix <= uint32(0x4016cbe3) { /* |x| ~<= 3pi/4 */
			if sign != 0 {
				v4 = float64(x3) + _t1pio2
			} else {
				v4 = float64(x3) - _t1pio2
			}
			return X__tandf(tls, v4, int32(1))
		} else {
			if sign != 0 {
				v5 = float64(x3) + _t2pio2
			} else {
				v5 = float64(x3) - _t2pio2
			}
			return X__tandf(tls, v5, 0)
		}
	}
	if ix <= uint32(0x40e231d5) { /* |x| ~<= 9*pi/4 */
		if ix <= uint32(0x40afeddf) { /* |x| ~<= 7*pi/4 */
			if sign != 0 {
				v6 = float64(x3) + _t3pio2
			} else {
				v6 = float64(x3) - _t3pio2
			}
			return X__tandf(tls, v6, int32(1))
		} else {
			if sign != 0 {
				v7 = float64(x3) + _t4pio2
			} else {
				v7 = float64(x3) - _t4pio2
			}
			return X__tandf(tls, v7, 0)
		}
	}
	/* tan(Inf or NaN) is NaN */
	if ix >= uint32(0x7f800000) {
		return x3 - x3
	}
	/* argument reduction */
	n = uint32(X__rem_pio2f(tls, x3, bp))
	return X__tandf(tls, *(*float64)(unsafe.Pointer(bp)), int32(n&uint32(1)))
}

const M_PI_210 = 0

// C documentation
//
//	/* tanh(x) = (exp(x) - exp(-x))/(exp(x) + exp(-x))
//	 *         = (exp(2*x) - 1)/(exp(2*x) - 1 + 2)
//	 *         = (1 - exp(-2*x))/(exp(-2*x) - 1 + 2)
//	 */
func Xtanh(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var sign int32
	var t, v1 Tdouble_t
	var w Tuint32_t
	var y float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _ = sign, t, w, y, y1, y2, v1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	/* x = |x| */
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= uint64(-Int32FromInt32(1)) / Uint64FromInt32(2)
	x3 = *(*float64)(unsafe.Pointer(bp))
	w = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32))
	if w > uint32(0x3fe193ea) {
		/* |x| > log(3)/2 ~= 0.5493 or nan */
		if w > uint32(0x40340000) {
			/* |x| > 20 or nan */
			/* note: this branch avoids raising overflow */
			t = Float64FromInt32(1) - Float64FromInt32(0)/x3
		} else {
			t = Xexpm1(tls, Float64FromInt32(2)*x3)
			t = Float64FromInt32(1) - Float64FromInt32(2)/(t+Float64FromInt32(2))
		}
	} else {
		if w > uint32(0x3fd058ae) {
			/* |x| > log(5/3)/2 ~= 0.2554 */
			t = Xexpm1(tls, Float64FromInt32(2)*x3)
			t = t / (t + Float64FromInt32(2))
		} else {
			if w >= uint32(0x00100000) {
				/* |x| >= 0x1p-1022, up to 2ulp error in [0.1,0.2554] */
				t = Xexpm1(tls, float64(-Int32FromInt32(2))*x3)
				t = -t / (t + Float64FromInt32(2))
			} else {
				/* |x| is subnormal */
				/* note: the branch above would not raise underflow in [0x1p-1023,0x1p-1022) */
				if uint64(4) == uint64(4) {
					y = float32(x3)
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(float32(x3))
					} else {
						y2 = float64(float32(x3))
					}
				}
				t = x3
			}
		}
	}
	if sign != 0 {
		v1 = -t
	} else {
		v1 = t
	}
	return v1
}

func Xtanhf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var sign int32
	var t, y, v1 float32
	var w Tuint32_t
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _, _, _ = sign, t, w, y, y1, y2, v1
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	/* x = |x| */
	sign = int32(*(*Tuint32_t)(unsafe.Pointer(bp)) >> int32(31))
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= uint32(0x7fffffff)
	x3 = *(*float32)(unsafe.Pointer(bp))
	w = *(*Tuint32_t)(unsafe.Pointer(bp))
	if w > uint32(0x3f0c9f54) {
		/* |x| > log(3)/2 ~= 0.5493 or nan */
		if w > uint32(0x41200000) {
			/* |x| > 10 */
			t = Float32FromInt32(1) + Float32FromInt32(0)/x3
		} else {
			t = Xexpm1f(tls, Float32FromInt32(2)*x3)
			t = Float32FromInt32(1) - Float32FromInt32(2)/(t+Float32FromInt32(2))
		}
	} else {
		if w > uint32(0x3e82c578) {
			/* |x| > log(5/3)/2 ~= 0.2554 */
			t = Xexpm1f(tls, Float32FromInt32(2)*x3)
			t = t / (t + Float32FromInt32(2))
		} else {
			if w >= uint32(0x00800000) {
				/* |x| >= 0x1p-126 */
				t = Xexpm1f(tls, float32(-Int32FromInt32(2))*x3)
				t = -t / (t + Float32FromInt32(2))
			} else {
				/* |x| is subnormal */
				if uint64(4) == uint64(4) {
					y = x3 * x3
				} else {
					if uint64(4) == uint64(8) {
						y1 = float64(x3 * x3)
					} else {
						y2 = float64(x3 * x3)
					}
				}
				t = x3
			}
		}
	}
	if sign != 0 {
		v1 = -t
	} else {
		v1 = t
	}
	return v1
}

func Xtanhl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtanh(tls, x)
}

func Xtanl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtan(tls, x)
}

const N10 = 12

var _pi4 = float64(3.141592653589793)

// C documentation
//
//	/* sin(pi x) with x > 0x1p-100, if sin(pi*x)==0 the sign is arbitrary */
func _sinpi(tls *TLS, x float64) (r float64) {
	var n int32
	_ = n
	/* argument reduction: x = |x| mod 2 */
	/* spurious inexact when x is odd int */
	x = x * float64(0.5)
	x = Float64FromInt32(2) * (x - Xfloor(tls, x))
	/* reduce x into [-.25,.25] */
	n = int32(Float64FromInt32(4) * x)
	n = (n + int32(1)) / int32(2)
	x -= float64(n) * float64(0.5)
	x *= _pi4
	switch n {
	default: /* case 4 */
		fallthrough
	case 0:
		return X__sin(tls, x, Float64FromInt32(0), 0)
	case int32(1):
		return X__cos(tls, x, Float64FromInt32(0))
	case int32(2):
		return X__sin(tls, -x, Float64FromInt32(0), 0)
	case int32(3):
		return -X__cos(tls, x, Float64FromInt32(0))
	}
	return r
}

// C documentation
//
//	//static const double g = 6.024680040776729583740234375;
var _gmhalf = float64(5.52468004077673)
var _Snum = [13]float64{
	0:  float64(2.353137688041076e+10),
	1:  float64(4.29198036426491e+10),
	2:  float64(3.571195923735567e+10),
	3:  float64(1.792103442603721e+10),
	4:  float64(6.039542586352028e+09),
	5:  float64(1.4397204073117216e+09),
	6:  float64(2.4887455786205417e+08),
	7:  float64(3.1426415585400194e+07),
	8:  float64(2.8763706289353725e+06),
	9:  float64(186056.26539522348),
	10: float64(8071.672002365816),
	11: float64(210.82427775157936),
	12: float64(2.5066282746310002),
}
var _Sden = [13]float64{
	1:  Float64FromInt32(39916800),
	2:  Float64FromInt32(120543840),
	3:  Float64FromInt32(150917976),
	4:  Float64FromInt32(105258076),
	5:  Float64FromInt32(45995730),
	6:  Float64FromInt32(13339535),
	7:  Float64FromInt32(2637558),
	8:  Float64FromInt32(357423),
	9:  Float64FromInt32(32670),
	10: Float64FromInt32(1925),
	11: Float64FromInt32(66),
	12: Float64FromInt32(1),
}

// C documentation
//
//	/* n! for small integer n */
var _fact = [23]float64{
	0:  Float64FromInt32(1),
	1:  Float64FromInt32(1),
	2:  Float64FromInt32(2),
	3:  Float64FromInt32(6),
	4:  Float64FromInt32(24),
	5:  Float64FromInt32(120),
	6:  Float64FromInt32(720),
	7:  float64(5040),
	8:  float64(40320),
	9:  float64(362880),
	10: float64(3.6288e+06),
	11: float64(3.99168e+07),
	12: float64(4.790016e+08),
	13: float64(6.2270208e+09),
	14: float64(8.71782912e+10),
	15: float64(1.307674368e+12),
	16: float64(2.0922789888e+13),
	17: float64(3.55687428096e+14),
	18: float64(6.402373705728e+15),
	19: float64(1.21645100408832e+17),
	20: float64(2.43290200817664e+18),
	21: float64(5.109094217170944e+19),
	22: float64(1.1240007277776077e+21),
}

// C documentation
//
//	/* S(x) rational function for positive x */
func _S(tls *TLS, x float64) (r float64) {
	var den, num Tdouble_t
	var i int32
	_, _, _ = den, i, num
	num = Float64FromInt32(0)
	den = Float64FromInt32(0)
	/* to avoid overflow handle large x differently */
	if x < Float64FromInt32(8) {
		i = int32(N10)
		for {
			if !(i >= 0) {
				break
			}
			num = num*x + _Snum[i]
			den = den*x + _Sden[i]
			goto _1
		_1:
			;
			i--
		}
	} else {
		i = 0
		for {
			if !(i <= int32(N10)) {
				break
			}
			num = num/x + _Snum[i]
			den = den/x + _Sden[i]
			goto _2
		_2:
			;
			i++
		}
	}
	return num / den
}

func Xtgamma(tls *TLS, x3 float64) (r1 float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var absx, y1, y2, y3, v1 float64
	var dy, r, z Tdouble_t
	var ix Tuint32_t
	var sign int32
	var y float32
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _, _, _, _, _, _, _ = absx, dy, ix, r, sign, y, y1, y2, y3, z, v1
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	ix = uint32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(32) & uint64(0x7fffffff))
	sign = int32(*(*Tuint64_t)(unsafe.Pointer(bp)) >> int32(63))
	/* special cases */
	if ix >= uint32(0x7ff00000) {
		/* tgamma(nan)=nan, tgamma(inf)=inf, tgamma(-inf)=nan with invalid */
		return x3 + float64(X__builtin_inff(tls))
	}
	if ix < uint32((Int32FromInt32(0x3ff)-Int32FromInt32(54))<<Int32FromInt32(20)) {
		/* |x| < 2^-54: tgamma(x) ~ 1/x, +-0 raises div-by-zero */
		return Float64FromInt32(1) / x3
	}
	/* integer arguments */
	/* raise inexact when non-integer */
	if x3 == Xfloor(tls, x3) {
		if sign != 0 {
			return Float64FromInt32(0) / Float64FromFloat64(0)
		}
		if x3 <= float64(Uint64FromInt64(184)/Uint64FromInt64(8)) {
			return _fact[int32(x3)-int32(1)]
		}
	}
	/* x >= 172: tgamma(x)=inf with overflow */
	/* x =< -184: tgamma(x)=+-0 with underflow */
	if ix >= uint32(0x40670000) { /* |x| >= 184 */
		if sign != 0 {
			if uint64(4) == uint64(4) {
				y = float32(Float64FromFloat64(1.1754943508222875e-38) / x3)
			} else {
				if uint64(4) == uint64(8) {
					y1 = float64(float32(Float64FromFloat64(1.1754943508222875e-38) / x3))
				} else {
					y2 = float64(float32(Float64FromFloat64(1.1754943508222875e-38) / x3))
				}
			}
			if Xfloor(tls, x3)*float64(0.5) == Xfloor(tls, x3*float64(0.5)) {
				return Float64FromInt32(0)
			}
			return -Float64FromFloat64(0)
		}
		x3 *= float64(8.98846567431158e+307)
		return x3
	}
	if sign != 0 {
		v1 = -x3
	} else {
		v1 = x3
	}
	absx = v1
	/* handle the error of x + g - 0.5 */
	y3 = absx + _gmhalf
	if absx > _gmhalf {
		dy = y3 - absx
		dy -= _gmhalf
	} else {
		dy = y3 - _gmhalf
		dy -= absx
	}
	z = absx - float64(0.5)
	r = _S(tls, absx) * Xexp(tls, -y3)
	if x3 < Float64FromInt32(0) {
		/* reflection formula for negative x */
		/* sinpi(absx) is not 0, integers are already handled */
		r = -_pi4 / (_sinpi(tls, absx) * absx * r)
		dy = -dy
		z = -z
	}
	r += dy * (_gmhalf + Float64FromFloat64(0.5)) * r / y3
	z = Xpow(tls, y3, float64(0.5)*z)
	y3 = r * z * z
	return y3
}

func Xtgammaf(tls *TLS, x float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return float32(Xtgamma(tls, float64(x)))
}

func Xtgammal(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtgamma(tls, x)
}

func Xtrunc(tls *TLS, x3 float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var m Tuint64_t
	var y float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint64_t
		Ff float64
	}
	_, _, _, _, _ = e, m, y, y1, y2
	*(*struct {
		Fi [0]Tuint64_t
		Ff float64
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint64_t
		Ff float64
	}{}
	*(*float64)(unsafe.Pointer(bp)) = x3
	e = int32(*(*Tuint64_t)(unsafe.Pointer(bp))>>Int32FromInt32(52)&Uint64FromInt32(0x7ff)) - int32(0x3ff) + int32(12)
	if e >= Int32FromInt32(52)+Int32FromInt32(12) {
		return x3
	}
	if e < int32(12) {
		e = int32(1)
	}
	m = -Uint64FromUint64(1) >> e
	if *(*Tuint64_t)(unsafe.Pointer(bp))&m == uint64(0) {
		return x3
	}
	if uint64(8) == uint64(4) {
		y = float32(x3 + Float64FromFloat32(1.329227995784916e+36))
	} else {
		if uint64(8) == uint64(8) {
			y1 = x3 + Float64FromFloat32(1.329227995784916e+36)
		} else {
			y2 = x3 + Float64FromFloat32(1.329227995784916e+36)
		}
	}
	*(*Tuint64_t)(unsafe.Pointer(bp)) &= ^m
	return *(*float64)(unsafe.Pointer(bp))
}

func Xtruncf(tls *TLS, x3 float32) (r float32) {
	if __ccgo_strace {
		trc("tls=%v x3=%v, (%v:)", tls, x3, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var e int32
	var m Tuint32_t
	var y float32
	var y1, y2 float64
	var _ /* u at bp+0 */ struct {
		Fi [0]Tuint32_t
		Ff float32
	}
	_, _, _, _, _ = e, m, y, y1, y2
	*(*struct {
		Fi [0]Tuint32_t
		Ff float32
	})(unsafe.Pointer(bp)) = struct {
		Fi [0]Tuint32_t
		Ff float32
	}{}
	*(*float32)(unsafe.Pointer(bp)) = x3
	e = int32(*(*Tuint32_t)(unsafe.Pointer(bp))>>Int32FromInt32(23)&Uint32FromInt32(0xff)) - int32(0x7f) + int32(9)
	if e >= Int32FromInt32(23)+Int32FromInt32(9) {
		return x3
	}
	if e < int32(9) {
		e = int32(1)
	}
	m = -Uint32FromUint32(1) >> e
	if *(*Tuint32_t)(unsafe.Pointer(bp))&m == uint32(0) {
		return x3
	}
	if uint64(4) == uint64(4) {
		y = x3 + Float32FromFloat32(1.329227995784916e+36)
	} else {
		if uint64(4) == uint64(8) {
			y1 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
		} else {
			y2 = float64(x3 + Float32FromFloat32(1.329227995784916e+36))
		}
	}
	*(*Tuint32_t)(unsafe.Pointer(bp)) &= ^m
	return *(*float32)(unsafe.Pointer(bp))
}

func Xtruncl(tls *TLS, x float64) (r float64) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xtrunc(tls, x)
}

var _digits = [65]uint8{'.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

func Xa64l(tls *TLS, s uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d uintptr
	var e int32
	var x Tuint32_t
	_, _, _ = d, e, x
	x = uint32(0)
	e = 0
	for {
		if !(e < int32(36) && *(*uint8)(unsafe.Pointer(s)) != 0) {
			break
		}
		d = Xstrchr(tls, uintptr(unsafe.Pointer(&_digits)), int32(*(*uint8)(unsafe.Pointer(s))))
		if !(d != 0) {
			break
		}
		x |= uint32(int64(d)-t__predefined_ptrdiff_t(uintptr(unsafe.Pointer(&_digits)))) << e
		goto _1
	_1:
		;
		e += int32(6)
		s++
	}
	return int64(int32(x))
}

func Xl64a(tls *TLS, x0 int64) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v x0=%v, (%v:)", tls, x0, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p uintptr
	var x Tuint32_t
	_, _ = p, x
	x = uint32(x0)
	p = uintptr(unsafe.Pointer(&_s))
	for {
		if !(x != 0) {
			break
		}
		*(*uint8)(unsafe.Pointer(p)) = _digits[x&uint32(63)]
		goto _1
	_1:
		;
		p++
		x >>= uint32(6)
	}
	*(*uint8)(unsafe.Pointer(p)) = uint8(0)
	return uintptr(unsafe.Pointer(&_s))
}

var _s [7]uint8

func Xbasename(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i Tsize_t
	_ = i
	if !(s != 0) || !(*(*uint8)(unsafe.Pointer(s)) != 0) {
		return __ccgo_ts + 558
	}
	i = Xstrlen(tls, s) - uint64(1)
	for {
		if !(i != 0 && int32(*(*uint8)(unsafe.Pointer(s + uintptr(i)))) == int32('/')) {
			break
		}
		*(*uint8)(unsafe.Pointer(s + uintptr(i))) = uint8(0)
		goto _1
	_1:
		;
		i--
	}
	for {
		if !(i != 0 && int32(*(*uint8)(unsafe.Pointer(s + uintptr(i-uint64(1))))) != int32('/')) {
			break
		}
		goto _2
	_2:
		;
		i--
	}
	return s + uintptr(i)
}

func X__xpg_basename(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xbasename(tls, s)
}

func Xdirname(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i Tsize_t
	_ = i
	if !(s != 0) || !(*(*uint8)(unsafe.Pointer(s)) != 0) {
		return __ccgo_ts + 558
	}
	i = Xstrlen(tls, s) - uint64(1)
	for {
		if !(int32(*(*uint8)(unsafe.Pointer(s + uintptr(i)))) == int32('/')) {
			break
		}
		if !(i != 0) {
			return __ccgo_ts + 570
		}
		goto _1
	_1:
		;
		i--
	}
	for {
		if !(int32(*(*uint8)(unsafe.Pointer(s + uintptr(i)))) != int32('/')) {
			break
		}
		if !(i != 0) {
			return __ccgo_ts + 558
		}
		goto _2
	_2:
		;
		i--
	}
	for {
		if !(int32(*(*uint8)(unsafe.Pointer(s + uintptr(i)))) == int32('/')) {
			break
		}
		if !(i != 0) {
			return __ccgo_ts + 570
		}
		goto _3
	_3:
		;
		i--
	}
	*(*uint8)(unsafe.Pointer(s + uintptr(i+uint64(1)))) = uint8(0)
	return s
}

func Xffs(tls *TLS, i int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v i=%v, (%v:)", tls, i, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	_ = v1
	if i != 0 {
		v1 = _a_ctz_l(tls, uint64(i)) + int32(1)
	} else {
		v1 = 0
	}
	return v1
}

func Xffsl(tls *TLS, i int64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v i=%v, (%v:)", tls, i, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	_ = v1
	if i != 0 {
		v1 = _a_ctz_l(tls, uint64(i)) + int32(1)
	} else {
		v1 = 0
	}
	return v1
}

func Xffsll(tls *TLS, i int64) (r int32) {
	if __ccgo_strace {
		trc("tls=%v i=%v, (%v:)", tls, i, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v3 int32
	var v2 Tuint64_t
	_, _, _ = v1, v2, v3
	if i != 0 {
		v2 = uint64(i)
		// __asm__(
		//
		//	"	rbit %0, %1\n	clz %0, %0\n"
		//	: "=r"(x) : "r"(x));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 70, __ccgo_ts+572)
		v3 = int32(v2)
		goto _4
	_4:
		v1 = v3 + int32(1)
	} else {
		v1 = 0
	}
	return v1
}

const MM_APPL = 8
const MM_CONSOLE = 512
const MM_ERROR = 2
const MM_FIRM = 4
const MM_HALT = 1
const MM_HARD = 1
const MM_INFO = 4
const MM_NOCON = 4
const MM_NOMSG = 1
const MM_NOSEV = 0
const MM_NOTOK = -1
const MM_NRECOV = 128
const MM_NULLMC = 0
const MM_NULLSEV = 0
const MM_OK = 0
const MM_OPSYS = 32
const MM_PRINT = 256
const MM_RECOVER = 64
const MM_SOFT = 2
const MM_UTIL = 16
const MM_WARNING = 3

// C documentation
//
//	/*
//	 * If lstr is the first part of bstr, check that the next char in bstr
//	 * is either \0 or :
//	 */
func __strcolcmp(tls *TLS, lstr uintptr, bstr uintptr) (r int32) {
	var i Tsize_t
	_ = i
	i = uint64(0)
	for *(*uint8)(unsafe.Pointer(lstr + uintptr(i))) != 0 && *(*uint8)(unsafe.Pointer(bstr + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(bstr + uintptr(i)))) == int32(*(*uint8)(unsafe.Pointer(lstr + uintptr(i)))) {
		i++
	}
	if *(*uint8)(unsafe.Pointer(lstr + uintptr(i))) != 0 || *(*uint8)(unsafe.Pointer(bstr + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(bstr + uintptr(i)))) != int32(':') {
		return int32(1)
	}
	return 0
}

func Xfmtmsg(tls *TLS, classification int64, label uintptr, severity int32, text uintptr, action uintptr, tag uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v classification=%v label=%v severity=%v text=%v action=%v tag=%v, (%v:)", tls, classification, label, severity, text, action, tag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var cmsg, errstring, v1, v10, v11, v12, v13, v14, v15, v16, v17, v2, v3, v4, v5, v6, v7, v8 uintptr
	var consolefd, i, ret, verb int32
	var msgs [6]uintptr
	var _ /* cs at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = cmsg, consolefd, errstring, i, msgs, ret, verb, v1, v10, v11, v12, v13, v14, v15, v16, v17, v2, v3, v4, v5, v6, v7, v8
	ret = 0
	verb = 0
	errstring = uintptr(MM_NULLSEV)
	cmsg = Xgetenv(tls, __ccgo_ts+578)
	msgs = [6]uintptr{
		0: __ccgo_ts + 586,
		1: __ccgo_ts + 592,
		2: __ccgo_ts + 601,
		3: __ccgo_ts + 606,
		4: __ccgo_ts + 613,
		5: UintptrFromInt32(0),
	}
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	if severity == int32(MM_HALT) {
		errstring = __ccgo_ts + 617
	} else {
		if severity == int32(MM_ERROR) {
			errstring = __ccgo_ts + 624
		} else {
			if severity == int32(MM_WARNING) {
				errstring = __ccgo_ts + 632
			} else {
				if severity == int32(MM_INFO) {
					errstring = __ccgo_ts + 642
				}
			}
		}
	}
	if classification&int64(MM_CONSOLE) != 0 {
		consolefd = Xopen(tls, __ccgo_ts+649, int32(O_WRONLY), 0)
		if consolefd < 0 {
			ret = int32(MM_NOCON)
		} else {
			if label != 0 {
				v1 = label
			} else {
				v1 = __ccgo_ts
			}
			if label != 0 {
				v2 = __ccgo_ts + 289
			} else {
				v2 = __ccgo_ts
			}
			if severity != 0 {
				v3 = errstring
			} else {
				v3 = __ccgo_ts
			}
			if text != 0 {
				v4 = text
			} else {
				v4 = __ccgo_ts
			}
			if action != 0 {
				v5 = __ccgo_ts + 662
			} else {
				v5 = __ccgo_ts
			}
			if action != 0 {
				v6 = action
			} else {
				v6 = __ccgo_ts
			}
			if action != 0 {
				v7 = __ccgo_ts + 672
			} else {
				v7 = __ccgo_ts
			}
			if tag != 0 {
				v8 = tag
			} else {
				v8 = __ccgo_ts
			}
			if Xdprintf(tls, consolefd, __ccgo_ts+674, VaList(bp+16, v1, v2, v3, v4, v5, v6, v7, v8)) < int32(1) {
				ret = int32(MM_NOCON)
			}
			Xclose(tls, consolefd)
		}
	}
	if classification&int64(MM_PRINT) != 0 {
		for cmsg != 0 && *(*uint8)(unsafe.Pointer(cmsg)) != 0 {
			i = 0
			for {
				if !(msgs[i] != 0) {
					break
				}
				if !(__strcolcmp(tls, msgs[i], cmsg) != 0) {
					break
				}
				goto _9
			_9:
				;
				i++
			}
			if msgs[i] == UintptrFromInt32(0) {
				//ignore MSGVERB-unrecognized component
				verb = int32(0xFF)
				break
			} else {
				verb |= int32(1) << i
				cmsg = Xstrchr(tls, cmsg, int32(':'))
				if cmsg != 0 {
					cmsg++
				}
			}
		}
		if !(verb != 0) {
			verb = int32(0xFF)
		}
		if verb&int32(1) != 0 && label != 0 {
			v10 = label
		} else {
			v10 = __ccgo_ts
		}
		if verb&int32(1) != 0 && label != 0 {
			v11 = __ccgo_ts + 289
		} else {
			v11 = __ccgo_ts
		}
		if verb&int32(2) != 0 && severity != 0 {
			v12 = errstring
		} else {
			v12 = __ccgo_ts
		}
		if verb&int32(4) != 0 && text != 0 {
			v13 = text
		} else {
			v13 = __ccgo_ts
		}
		if verb&int32(8) != 0 && action != 0 {
			v14 = __ccgo_ts + 662
		} else {
			v14 = __ccgo_ts
		}
		if verb&int32(8) != 0 && action != 0 {
			v15 = action
		} else {
			v15 = __ccgo_ts
		}
		if verb&int32(8) != 0 && action != 0 {
			v16 = __ccgo_ts + 672
		} else {
			v16 = __ccgo_ts
		}
		if verb&int32(16) != 0 && tag != 0 {
			v17 = tag
		} else {
			v17 = __ccgo_ts
		}
		if Xdprintf(tls, int32(2), __ccgo_ts+674, VaList(bp+16, v10, v11, v12, v13, v14, v15, v16, v17)) < int32(1) {
			ret |= int32(MM_NOMSG)
		}
	}
	if ret&(Int32FromInt32(MM_NOCON)|Int32FromInt32(MM_NOMSG)) == Int32FromInt32(MM_NOCON)|Int32FromInt32(MM_NOMSG) {
		ret = -int32(1)
	}
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return ret
}

func Xget_current_dir_name(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var res uintptr
	var _ /* a at bp+0 */ Tstat
	var _ /* b at bp+128 */ Tstat
	_ = res
	res = Xgetenv(tls, __ccgo_ts+692)
	if res != 0 && *(*uint8)(unsafe.Pointer(res)) != 0 && !(Xstat(tls, res, bp) != 0) && !(Xstat(tls, __ccgo_ts+558, bp+128) != 0) && (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev == (*(*Tstat)(unsafe.Pointer(bp + 128))).Fst_dev && (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino == (*(*Tstat)(unsafe.Pointer(bp + 128))).Fst_ino {
		return Xstrdup(tls, res)
	}
	return Xgetcwd(tls, uintptr(0), uint64(0))
}

func X__getauxval(tls *TLS, item uint64) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v item=%v, (%v:)", tls, item, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var auxv uintptr
	_ = auxv
	auxv = X__libc.Fauxv
	if item == uint64(AT_SECURE) {
		return uint64(X__libc.Fsecure)
	}
	for {
		if !(*(*Tsize_t)(unsafe.Pointer(auxv)) != 0) {
			break
		}
		if *(*Tsize_t)(unsafe.Pointer(auxv)) == item {
			return *(*Tsize_t)(unsafe.Pointer(auxv + 1*8))
		}
		goto _1
	_1:
		;
		auxv += uintptr(2) * 8
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOENT)
	return uint64(0)
}

func Xgetauxval(tls *TLS, item uint64) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v item=%v, (%v:)", tls, item, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__getauxval(tls, item)
}

type Tutsname = struct {
	Fsysname    [65]uint8
	Fnodename   [65]uint8
	Frelease    [65]uint8
	Fversion    [65]uint8
	Fmachine    [65]uint8
	Fdomainname [65]uint8
}

func Xgetdomainname(tls *TLS, name uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v len1=%v, (%v:)", tls, name, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(400)
	defer tls.Free(400)
	var _ /* temp at bp+0 */ Tutsname
	Xuname(tls, bp)
	if !(len1 != 0) || Xstrlen(tls, bp+325) >= len1 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	Xstrcpy(tls, name, bp+325)
	return 0
}

func Xgetentropy(tls *TLS, buffer uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v buffer=%v len1=%v, (%v:)", tls, buffer, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var pos uintptr
	var ret int32
	var _ /* cs at bp+0 */ int32
	_, _ = pos, ret
	ret = 0
	pos = buffer
	if len1 > uint64(256) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EIO)
		return -int32(1)
	}
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	for len1 != 0 {
		ret = int32(Xgetrandom(tls, pos, len1, uint32(0)))
		if ret < 0 {
			if *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EINTR) {
				continue
			} else {
				break
			}
		}
		pos += uintptr(ret)
		len1 -= uint64(ret)
		ret = 0
	}
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return ret
}

func Xgethostid(tls *TLS) (r int64) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

const optpos = 0

type Tucontext_t3 = struct {
	Fuc_flags    uint64
	Fuc_link     uintptr
	Fuc_stack    Tstack_t
	Fuc_sigmask  Tsigset_t
	Fuc_mcontext Tmcontext_t1
}

type t__ucontext1 = Tucontext_t3

func X__getopt_msg(tls *TLS, a uintptr, b uintptr, c uintptr, l Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v a=%v b=%v c=%v l=%v, (%v:)", tls, a, b, c, l, origin(2))
	}
	var __need_unlock, v1 int32
	var f uintptr
	_, _, _ = __need_unlock, f, v1
	f = uintptr(unsafe.Pointer(&X__stderr_FILE))
	b = X__lctrans_cur(tls, b)
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	_ = Xfputs(tls, a, f) >= 0 && Xfwrite(tls, b, Xstrlen(tls, b), uint64(1), f) != 0 && Xfwrite(tls, c, uint64(1), l, f) == l && Xputc(tls, int32('\n'), f) != 0
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
}

func Xgetopt(tls *TLS, argc int32, argv uintptr, optstring uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v argc=%v argv=%v optstring=%v, (%v:)", tls, argc, argv, optstring, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, k, l, v1, v2, v3 int32
	var optchar uintptr
	var _ /* c at bp+0 */ Twchar_t
	var _ /* d at bp+4 */ Twchar_t
	_, _, _, _, _, _, _ = i, k, l, optchar, v1, v2, v3
	if !(Xoptind != 0) || Xoptreset != 0 {
		Xoptreset = 0
		X__optpos = 0
		Xoptind = int32(1)
	}
	if Xoptind >= argc || !(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) != 0) {
		return -int32(1)
	}
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8))))) != int32('-') {
		if int32(*(*uint8)(unsafe.Pointer(optstring))) == int32('-') {
			v1 = Xoptind
			Xoptind++
			Xoptarg = *(*uintptr)(unsafe.Pointer(argv + uintptr(v1)*8))
			return int32(1)
		}
		return -int32(1)
	}
	if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + 1)) != 0) {
		return -int32(1)
	}
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + 1))) == int32('-') && !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + 2)) != 0) {
		Xoptind++
		return -Int32FromInt32(1)
	}
	if !(X__optpos != 0) {
		X__optpos++
	}
	v2 = Xmbtowc(tls, bp, *(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8))+uintptr(X__optpos), uint64(MB_LEN_MAX))
	k = v2
	if v2 < 0 {
		k = int32(1)
		*(*Twchar_t)(unsafe.Pointer(bp)) = uint32(0xfffd) /* replacement char */
	}
	optchar = *(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + uintptr(X__optpos)
	X__optpos += k
	if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + uintptr(X__optpos))) != 0) {
		Xoptind++
		X__optpos = 0
	}
	if int32(*(*uint8)(unsafe.Pointer(optstring))) == int32('-') || int32(*(*uint8)(unsafe.Pointer(optstring))) == int32('+') {
		optstring++
	}
	i = 0
	*(*Twchar_t)(unsafe.Pointer(bp + 4)) = uint32(0)
	for cond := true; cond; cond = l != 0 && *(*Twchar_t)(unsafe.Pointer(bp + 4)) != *(*Twchar_t)(unsafe.Pointer(bp)) {
		l = Xmbtowc(tls, bp+4, optstring+uintptr(i), uint64(MB_LEN_MAX))
		if l > 0 {
			i += l
		} else {
			i++
		}
	}
	if *(*Twchar_t)(unsafe.Pointer(bp + 4)) != *(*Twchar_t)(unsafe.Pointer(bp)) || *(*Twchar_t)(unsafe.Pointer(bp)) == uint32(':') {
		Xoptopt = int32(*(*Twchar_t)(unsafe.Pointer(bp)))
		if int32(*(*uint8)(unsafe.Pointer(optstring))) != int32(':') && Xopterr != 0 {
			X__getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv)), __ccgo_ts+696, optchar, uint64(k))
		}
		return int32('?')
	}
	if int32(*(*uint8)(unsafe.Pointer(optstring + uintptr(i)))) == int32(':') {
		Xoptarg = uintptr(0)
		if int32(*(*uint8)(unsafe.Pointer(optstring + uintptr(i+int32(1))))) != int32(':') || X__optpos != 0 {
			v3 = Xoptind
			Xoptind++
			Xoptarg = *(*uintptr)(unsafe.Pointer(argv + uintptr(v3)*8))
			if X__optpos != 0 {
				Xoptarg += uintptr(X__optpos)
			}
			X__optpos = 0
		}
		if Xoptind > argc {
			Xoptopt = int32(*(*Twchar_t)(unsafe.Pointer(bp)))
			if int32(*(*uint8)(unsafe.Pointer(optstring))) == int32(':') {
				return int32(':')
			}
			if Xopterr != 0 {
				X__getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv)), __ccgo_ts+720, optchar, uint64(k))
			}
			return int32('?')
		}
	}
	return int32(*(*Twchar_t)(unsafe.Pointer(bp)))
}

func X__posix_getopt(tls *TLS, argc int32, argv uintptr, optstring uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v argc=%v argv=%v optstring=%v, (%v:)", tls, argc, argv, optstring, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetopt(tls, argc, argv, optstring)
}

const no_argument = 0
const optional_argument = 2
const required_argument = 1

type Toption = struct {
	Fname    uintptr
	Fhas_arg int32
	Fflag    uintptr
	Fval     int32
}

func _permute(tls *TLS, argv uintptr, dest int32, src int32) {
	var av, tmp uintptr
	var i int32
	_, _, _ = av, i, tmp
	av = argv
	tmp = *(*uintptr)(unsafe.Pointer(av + uintptr(src)*8))
	i = src
	for {
		if !(i > dest) {
			break
		}
		*(*uintptr)(unsafe.Pointer(av + uintptr(i)*8)) = *(*uintptr)(unsafe.Pointer(av + uintptr(i-int32(1))*8))
		goto _1
	_1:
		;
		i--
	}
	*(*uintptr)(unsafe.Pointer(av + uintptr(dest)*8)) = tmp
}

func ___getopt_long(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr, longonly int32) (r int32) {
	var cnt, i, i1, resumed, ret, skipped int32
	_, _, _, _, _, _ = cnt, i, i1, resumed, ret, skipped
	if !(Xoptind != 0) || Xoptreset != 0 {
		Xoptreset = 0
		X__optpos = 0
		Xoptind = int32(1)
	}
	if Xoptind >= argc || !(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) != 0) {
		return -int32(1)
	}
	skipped = Xoptind
	if int32(*(*uint8)(unsafe.Pointer(optstring))) != int32('+') && int32(*(*uint8)(unsafe.Pointer(optstring))) != int32('-') {
		i = Xoptind
		for {
			if i >= argc || !(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) != 0) {
				return -int32(1)
			}
			if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))) == int32('-') && *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) + 1)) != 0 {
				break
			}
			goto _1
		_1:
			;
			i++
		}
		Xoptind = i
	}
	resumed = Xoptind
	ret = ___getopt_long_core(tls, argc, argv, optstring, longopts, idx, longonly)
	if resumed > skipped {
		cnt = Xoptind - resumed
		i1 = 0
		for {
			if !(i1 < cnt) {
				break
			}
			_permute(tls, argv, skipped, Xoptind-int32(1))
			goto _2
		_2:
			;
			i1++
		}
		Xoptind = skipped + cnt
	}
	return ret
}

func ___getopt_long_core(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr, longonly int32) (r int32) {
	var arg, name, opt, start, v5, v6 uintptr
	var cnt, colon, i, j, l, match, v2 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _ = arg, cnt, colon, i, j, l, match, name, opt, start, v2, v5, v6
	Xoptarg = uintptr(0)
	if longopts != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8))))) == int32('-') && (longonly != 0 && *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + 1)) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + 1))) != int32('-') || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + 1))) == int32('-') && *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + 2)) != 0) {
		colon = BoolInt32(int32(*(*uint8)(unsafe.Pointer(optstring + BoolUintptr(int32(*(*uint8)(unsafe.Pointer(optstring))) == int32('+') || int32(*(*uint8)(unsafe.Pointer(optstring))) == int32('-'))))) == int32(':'))
		start = *(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + uintptr(1)
		v2 = Int32FromInt32(0)
		i = v2
		cnt = v2
		for {
			if !((*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname != 0) {
				break
			}
			name = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname
			opt = start
			if int32(*(*uint8)(unsafe.Pointer(opt))) == int32('-') {
				opt++
			}
			for *(*uint8)(unsafe.Pointer(opt)) != 0 && int32(*(*uint8)(unsafe.Pointer(opt))) != int32('=') && int32(*(*uint8)(unsafe.Pointer(opt))) == int32(*(*uint8)(unsafe.Pointer(name))) {
				name++
				opt++
			}
			if *(*uint8)(unsafe.Pointer(opt)) != 0 && int32(*(*uint8)(unsafe.Pointer(opt))) != int32('=') {
				goto _1
			}
			arg = opt
			match = i
			if !(*(*uint8)(unsafe.Pointer(name)) != 0) {
				cnt = int32(1)
				break
			}
			cnt++
			goto _1
		_1:
			;
			i++
		}
		if cnt == int32(1) && longonly != 0 && int64(arg)-int64(start) == int64(Xmblen(tls, start, uint64(MB_LEN_MAX))) {
			l = int32(int64(arg) - int64(start))
			i = 0
			for {
				if !(*(*uint8)(unsafe.Pointer(optstring + uintptr(i))) != 0) {
					break
				}
				j = 0
				for {
					if !(j < l && int32(*(*uint8)(unsafe.Pointer(start + uintptr(j)))) == int32(*(*uint8)(unsafe.Pointer(optstring + uintptr(i+j))))) {
						break
					}
					goto _4
				_4:
					;
					j++
				}
				if j == l {
					cnt++
					break
				}
				goto _3
			_3:
				;
				i++
			}
		}
		if cnt == int32(1) {
			i = match
			opt = arg
			Xoptind++
			if int32(*(*uint8)(unsafe.Pointer(opt))) == int32('=') {
				if !((*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fhas_arg != 0) {
					Xoptopt = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
					if colon != 0 || !(Xopterr != 0) {
						return int32('?')
					}
					X__getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv)), __ccgo_ts+752, (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname, Xstrlen(tls, (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname))
					return int32('?')
				}
				Xoptarg = opt + uintptr(1)
			} else {
				if (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fhas_arg == int32(required_argument) {
					v5 = *(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8))
					Xoptarg = v5
					if !(v5 != 0) {
						Xoptopt = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
						if colon != 0 {
							return int32(':')
						}
						if !(Xopterr != 0) {
							return int32('?')
						}
						X__getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv)), __ccgo_ts+720, (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname, Xstrlen(tls, (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fname))
						return int32('?')
					}
					Xoptind++
				}
			}
			if idx != 0 {
				*(*int32)(unsafe.Pointer(idx)) = i
			}
			if (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fflag != 0 {
				*(*int32)(unsafe.Pointer((*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fflag)) = (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
				return 0
			}
			return (*(*Toption)(unsafe.Pointer(longopts + uintptr(i)*32))).Fval
		}
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8)) + 1))) == int32('-') {
			Xoptopt = 0
			if !(colon != 0) && Xopterr != 0 {
				if cnt != 0 {
					v6 = __ccgo_ts + 789
				} else {
					v6 = __ccgo_ts + 696
				}
				X__getopt_msg(tls, *(*uintptr)(unsafe.Pointer(argv)), v6, *(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8))+uintptr(2), Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(Xoptind)*8))+uintptr(2)))
			}
			Xoptind++
			return int32('?')
		}
	}
	return Xgetopt(tls, argc, argv, optstring)
}

func Xgetopt_long(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v argc=%v argv=%v optstring=%v longopts=%v idx=%v, (%v:)", tls, argc, argv, optstring, longopts, idx, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return ___getopt_long(tls, argc, argv, optstring, longopts, idx, 0)
}

func Xgetopt_long_only(tls *TLS, argc int32, argv uintptr, optstring uintptr, longopts uintptr, idx uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v argc=%v argv=%v optstring=%v longopts=%v idx=%v, (%v:)", tls, argc, argv, optstring, longopts, idx, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return ___getopt_long(tls, argc, argv, optstring, longopts, idx, int32(1))
}

func Xgetpriority(tls *TLS, which int32, who Tid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v which=%v who=%v, (%v:)", tls, which, who, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int32
	_ = ret
	ret = int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_getpriority), int64(which), int64(who)))))
	if ret < 0 {
		return ret
	}
	return int32(20) - ret
}

func Xgetresgid(tls *TLS, rgid uintptr, egid uintptr, sgid uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v rgid=%v egid=%v sgid=%v, (%v:)", tls, rgid, egid, sgid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_getresgid), int64(rgid), int64(egid), int64(sgid)))))
}

func Xgetresuid(tls *TLS, ruid uintptr, euid uintptr, suid uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ruid=%v euid=%v suid=%v, (%v:)", tls, ruid, euid, suid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_getresuid), int64(ruid), int64(euid), int64(suid)))))
}

func Xgetrlimit(tls *TLS, resource int32, rlim uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v resource=%v rlim=%v, (%v:)", tls, resource, rlim, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ret int32
	var v1, v2 uint64
	var _ /* k_rlim at bp+0 */ [2]uint64
	_, _, _ = ret, v1, v2
	ret = int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_prlimit64), int64(Int32FromInt32(0)), int64(resource), int64(Int32FromInt32(0)), int64(rlim)))))
	if !(ret != 0) {
		if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur >= ^Uint64FromUint64(0) {
			(*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur = ^Uint64FromUint64(0)
		}
		if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_max >= ^Uint64FromUint64(0) {
			(*Trlimit)(unsafe.Pointer(rlim)).Frlim_max = ^Uint64FromUint64(0)
		}
	}
	if !(ret != 0) || *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(ENOSYS) {
		return ret
	}
	if X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_getrlimit), int64(resource), int64(bp)))) < 0 {
		return -int32(1)
	}
	if (*(*[2]uint64)(unsafe.Pointer(bp)))[0] == -Uint64FromUint64(1) {
		v1 = ^Uint64FromUint64(0)
	} else {
		v1 = (*(*[2]uint64)(unsafe.Pointer(bp)))[0]
	}
	(*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur = v1
	if (*(*[2]uint64)(unsafe.Pointer(bp)))[int32(1)] == -Uint64FromUint64(1) {
		v2 = ^Uint64FromUint64(0)
	} else {
		v2 = (*(*[2]uint64)(unsafe.Pointer(bp)))[int32(1)]
	}
	(*Trlimit)(unsafe.Pointer(rlim)).Frlim_max = v2
	if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur >= ^Uint64FromUint64(0) {
		(*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur = ^Uint64FromUint64(0)
	}
	if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_max >= ^Uint64FromUint64(0) {
		(*Trlimit)(unsafe.Pointer(rlim)).Frlim_max = ^Uint64FromUint64(0)
	}
	return 0
}

func Xgetrusage(tls *TLS, who int32, ru uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v who=%v ru=%v, (%v:)", tls, who, ru, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var dest uintptr
	var r int32
	var _ /* kru at bp+0 */ [4]int64
	_, _ = dest, r
	dest = ru + 32 - uintptr(Uint64FromInt32(4)*Uint64FromInt64(8))
	r = int32(X__syscall2(tls, int64(SYS_getrusage), int64(who), int64(dest)))
	if !(r != 0) && Bool(uint64(8) > uint64(8)) {
		Xmemcpy(tls, bp, dest, Uint64FromInt32(4)*Uint64FromInt64(8))
		(*Trusage)(unsafe.Pointer(ru)).Fru_utime = Ttimeval{
			Ftv_sec:  (*(*[4]int64)(unsafe.Pointer(bp)))[0],
			Ftv_usec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(1)],
		}
		(*Trusage)(unsafe.Pointer(ru)).Fru_stime = Ttimeval{
			Ftv_sec:  (*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)],
			Ftv_usec: (*(*[4]int64)(unsafe.Pointer(bp)))[int32(3)],
		}
	}
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xgetsubopt(tls *TLS, opt uintptr, keys uintptr, val uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v opt=%v keys=%v val=%v, (%v:)", tls, opt, keys, val, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i int32
	var l Tsize_t
	var s, v1, v2 uintptr
	_, _, _, _, _ = i, l, s, v1, v2
	s = *(*uintptr)(unsafe.Pointer(opt))
	*(*uintptr)(unsafe.Pointer(val)) = UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(opt)) = Xstrchr(tls, s, int32(','))
	if *(*uintptr)(unsafe.Pointer(opt)) != 0 {
		v2 = opt
		v1 = *(*uintptr)(unsafe.Pointer(v2))
		*(*uintptr)(unsafe.Pointer(v2))++
		*(*uint8)(unsafe.Pointer(v1)) = uint8(0)
	} else {
		*(*uintptr)(unsafe.Pointer(opt)) = s + uintptr(Xstrlen(tls, s))
	}
	i = 0
	for {
		if !(*(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)) != 0) {
			break
		}
		l = Xstrlen(tls, *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)))
		if Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8)), s, l) != 0 {
			goto _3
		}
		if int32(*(*uint8)(unsafe.Pointer(s + uintptr(l)))) == int32('=') {
			*(*uintptr)(unsafe.Pointer(val)) = s + uintptr(l) + uintptr(1)
		} else {
			if *(*uint8)(unsafe.Pointer(s + uintptr(l))) != 0 {
				goto _3
			}
		}
		return i
		goto _3
	_3:
		;
		i++
	}
	return -int32(1)
}

const R = 2
const W = 1
const WR = 3

type Tioctl_compat_map = struct {
	Fnew_req     int32
	Fold_req     int32
	Fold_size    uint8
	Fdir         uint8
	Fforce_align uint8
	Fnoffs       uint8
	Foffsets     [8]uint8
}

/* yields a type for a struct with original size n, with a misaligned
 * timeval/timespec expanded from 32- to 64-bit. for use with ioctl
 * number producing macros; only size of result is meaningful. */

type Tv4l2_event = struct {
	Fa  Tuint32_t
	Fb  [8]Tuint64_t
	Fc  [2]Tuint32_t
	Fts [2]Tuint32_t
	Fd  [9]Tuint32_t
}

var _compat_map = [20]Tioctl_compat_map{
	0: {
		Fnew_req:  int32(SIOCGSTAMP),
		Fold_req:  int32(SIOCGSTAMP_OLD),
		Fold_size: uint8(8),
		Fdir:      uint8(R),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			1: uint8(4),
		},
	},
	1: {
		Fnew_req:  int32(SIOCGSTAMPNS),
		Fold_req:  int32(SIOCGSTAMPNS_OLD),
		Fold_size: uint8(8),
		Fdir:      uint8(R),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			1: uint8(4),
		},
	},
	2: {
		Fnew_req:  int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('T')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x14))) | Uint64FromInt64(96)<<Int32FromInt32(16)),
		Fold_req:  int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('T')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x14))) | Uint64FromInt64(4)<<Int32FromInt32(16)),
		Fold_size: uint8(88),
		Fdir:      uint8(R),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			1: uint8(4),
		},
	},
	3: {
		Fnew_req:     int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x20))) | Uint64FromInt64(128)<<Int32FromInt32(16)),
		Fold_req:     int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x20))) | Uint64FromInt64(108)<<Int32FromInt32(16)),
		Fold_size:    uint8(108),
		Fdir:         uint8(R),
		Fforce_align: uint8(1),
		Fnoffs:       uint8(8),
		Foffsets: [8]uint8{
			0: uint8(4),
			1: uint8(8),
			2: uint8(12),
			3: uint8(16),
			4: uint8(52),
			5: uint8(56),
			6: uint8(60),
			7: uint8(64),
		},
	},
	4: {
		Fnew_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x24))) | Uint64FromInt64(128)<<Int32FromInt32(16)),
		Fold_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x24))) | Uint64FromInt64(108)<<Int32FromInt32(16)),
		Fold_size:    uint8(108),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
		Fnoffs:       uint8(8),
		Foffsets: [8]uint8{
			0: uint8(4),
			1: uint8(8),
			2: uint8(12),
			3: uint8(16),
			4: uint8(52),
			5: uint8(56),
			6: uint8(60),
			7: uint8(64),
		},
	},
	5: {
		Fnew_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('W')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x20))) | Uint64FromInt64(48)<<Int32FromInt32(16)),
		Fold_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('W')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x20))) | Uint64FromInt64(36)<<Int32FromInt32(16)),
		Fold_size:    uint8(36),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
		Fnoffs:       uint8(2),
		Foffsets: [8]uint8{
			0: uint8(4),
			1: uint8(8),
		},
	},
	6: {
		Fnew_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x23))) | Uint64FromInt64(136)<<Int32FromInt32(16)),
		Fold_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('A')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x23))) | Uint64FromInt64(132)<<Int32FromInt32(16)),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
	},
	7: {
		Fold_size:    uint8(4),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
	},
	8: {
		Fold_size:    uint8(32),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
		Fnoffs:       uint8(5),
		Foffsets: [8]uint8{
			0: uint8(8),
			1: uint8(12),
			2: uint8(16),
			3: uint8(24),
			4: uint8(28),
		},
	},
	9: {
		Fold_size:    uint8(4),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
	},
	10: {
		Fnew_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(9))) | Uint64FromInt64(80)<<Int32FromInt32(16)),
		Fold_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(9))) | Uint64FromInt64(68)<<Int32FromInt32(16)),
		Fold_size:    uint8(68),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
		Fnoffs:       uint8(2),
		Foffsets: [8]uint8{
			0: uint8(20),
			1: uint8(24),
		},
	},
	11: {
		Fnew_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(15))) | Uint64FromInt64(80)<<Int32FromInt32(16)),
		Fold_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(15))) | Uint64FromInt64(68)<<Int32FromInt32(16)),
		Fold_size:    uint8(68),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
		Fnoffs:       uint8(2),
		Foffsets: [8]uint8{
			0: uint8(20),
			1: uint8(24),
		},
	},
	12: {
		Fnew_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(17))) | Uint64FromInt64(80)<<Int32FromInt32(16)),
		Fold_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(17))) | Uint64FromInt64(68)<<Int32FromInt32(16)),
		Fold_size:    uint8(68),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
		Fnoffs:       uint8(2),
		Foffsets: [8]uint8{
			0: uint8(20),
			1: uint8(24),
		},
	},
	13: {
		Fnew_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(93))) | Uint64FromInt64(80)<<Int32FromInt32(16)),
		Fold_req:     int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(93))) | Uint64FromInt64(68)<<Int32FromInt32(16)),
		Fold_size:    uint8(68),
		Fdir:         uint8(WR),
		Fforce_align: uint8(1),
		Fnoffs:       uint8(2),
		Foffsets: [8]uint8{
			0: uint8(20),
			1: uint8(24),
		},
	},
	14: {
		Fnew_req:  int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(89))) | Uint64FromInt64(136)<<Int32FromInt32(16)),
		Fold_req:  int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(89))) | Uint64FromInt64(128)<<Int32FromInt32(16)),
		Fold_size: uint8(128),
		Fdir:      uint8(R),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			0: uint8(uint64(UintptrFromInt32(0) + 80)),
			1: uint8(uint64(UintptrFromInt32(0) + 80 + 1*4)),
		},
	},
	15: {
		Fnew_req:  int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(192)+Int32FromInt32(6))) | Uint64FromInt64(32)<<Int32FromInt32(16)),
		Fold_req:  int32(uint64((Uint32FromUint32(2)|Uint32FromUint32(1))<<Int32FromInt32(30)|uint32(Int32FromUint8('V')<<Int32FromInt32(8))|uint32(Int32FromInt32(192)+Int32FromInt32(6))) | Uint64FromInt64(24)<<Int32FromInt32(16)),
		Fold_size: uint8(22),
		Fdir:      uint8(WR),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			1: uint8(4),
		},
	},
	16: {
		Fnew_req:  int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('t')<<Int32FromInt32(8))|uint32(Int32FromInt32(63))) | Uint64FromInt64(16)<<Int32FromInt32(16)),
		Fold_req:  int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('t')<<Int32FromInt32(8))|uint32(Int32FromInt32(63))) | Uint64FromInt64(8)<<Int32FromInt32(16)),
		Fold_size: uint8(8),
		Fdir:      uint8(R),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			1: uint8(4),
		},
	},
	17: {
		Fnew_req:  int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('p')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x95))) | Uint64FromInt64(16)<<Int32FromInt32(16)),
		Fold_req:  int32(uint64(Uint32FromUint32(2)<<Int32FromInt32(30)|uint32(Int32FromUint8('p')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x95))) | Uint64FromInt64(8)<<Int32FromInt32(16)),
		Fold_size: uint8(8),
		Fdir:      uint8(R),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			1: uint8(4),
		},
	},
	18: {
		Fnew_req:  int32(uint64(Uint32FromUint32(1)<<Int32FromInt32(30)|uint32(Int32FromUint8('p')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x96))) | Uint64FromInt64(16)<<Int32FromInt32(16)),
		Fold_req:  int32(uint64(Uint32FromUint32(1)<<Int32FromInt32(30)|uint32(Int32FromUint8('p')<<Int32FromInt32(8))|uint32(Int32FromInt32(0x96))) | Uint64FromInt64(8)<<Int32FromInt32(16)),
		Fold_size: uint8(8),
		Fdir:      uint8(W),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			1: uint8(4),
		},
	},
	19: {
		Fnew_req:  int32(uint64(Uint32FromUint32(1)<<Int32FromInt32(30)|uint32(Int32FromInt32(0x6)<<Int32FromInt32(8))|uint32(Int32FromInt32(0xf))) | Uint64FromInt64(16)<<Int32FromInt32(16)),
		Fold_req:  int32(0x060f),
		Fold_size: uint8(8),
		Fdir:      uint8(W),
		Fnoffs:    uint8(2),
		Foffsets: [8]uint8{
			1: uint8(4),
		},
	},
}

func _convert_ioctl_struct(tls *TLS, map1 uintptr, old uintptr, new1 uintptr, dir int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var adj, align, i, len1, new_offset, old_offset, old_size, ts_offset int32
	var v2 uint64
	var _ /* new_ts at bp+0 */ int64
	var _ /* old_ts at bp+8 */ int64
	_, _, _, _, _, _, _, _, _ = adj, align, i, len1, new_offset, old_offset, old_size, ts_offset, v2
	new_offset = 0
	old_offset = 0
	old_size = int32((*Tioctl_compat_map)(unsafe.Pointer(map1)).Fold_size)
	if !(dir&int32((*Tioctl_compat_map)(unsafe.Pointer(map1)).Fdir) != 0) {
		return
	}
	if !((*Tioctl_compat_map)(unsafe.Pointer(map1)).Fold_size != 0) {
		/* offsets hard-coded for SNDRV_PCM_IOCTL_SYNC_PTR;
		 * if another exception appears this needs changing. */
		_convert_ioctl_struct(tls, map1+uintptr(1)*20, old, new1, dir)
		_convert_ioctl_struct(tls, map1+uintptr(2)*20, old+uintptr(4), new1+uintptr(8), dir)
		/* snd_pcm_mmap_control, special-cased due to kernel
		 * type definition having been botched. */
		adj = 0
		_convert_ioctl_struct(tls, map1+uintptr(3)*20, old+uintptr(68), new1+uintptr(72)+uintptr(adj), dir)
		_convert_ioctl_struct(tls, map1+uintptr(3)*20, old+uintptr(72), new1+uintptr(76)+uintptr(int32(3)*adj), dir)
		return
	}
	i = 0
	for {
		if !(i < int32((*Tioctl_compat_map)(unsafe.Pointer(map1)).Fnoffs)) {
			break
		}
		ts_offset = int32(*(*uint8)(unsafe.Pointer(map1 + 12 + uintptr(i))))
		len1 = ts_offset - old_offset
		if dir == int32(W) {
			Xmemcpy(tls, old+uintptr(old_offset), new1+uintptr(new_offset), uint64(len1))
		} else {
			Xmemcpy(tls, new1+uintptr(new_offset), old+uintptr(old_offset), uint64(len1))
		}
		new_offset += len1
		old_offset += len1
		if (*Tioctl_compat_map)(unsafe.Pointer(map1)).Fforce_align != 0 {
			v2 = uint64(8)
		} else {
			v2 = uint64(UintptrFromInt32(0) + 8)
		}
		align = int32(v2)
		new_offset += (align - int32(1)) & -new_offset
		if dir == int32(W) {
			Xmemcpy(tls, bp, new1+uintptr(new_offset), uint64(8))
			*(*int64)(unsafe.Pointer(bp + 8)) = *(*int64)(unsafe.Pointer(bp))
			Xmemcpy(tls, old+uintptr(old_offset), bp+8, uint64(8))
		} else {
			Xmemcpy(tls, bp+8, old+uintptr(old_offset), uint64(8))
			*(*int64)(unsafe.Pointer(bp)) = *(*int64)(unsafe.Pointer(bp + 8))
			Xmemcpy(tls, new1+uintptr(new_offset), bp, uint64(8))
		}
		new_offset = int32(uint64(new_offset) + Uint64FromInt64(8))
		old_offset = int32(uint64(old_offset) + Uint64FromInt64(8))
		goto _1
	_1:
		;
		i++
	}
	if dir == int32(W) {
		Xmemcpy(tls, old+uintptr(old_offset), new1+uintptr(new_offset), uint64(old_size-old_offset))
	} else {
		Xmemcpy(tls, new1+uintptr(new_offset), old+uintptr(old_offset), uint64(old_size-old_offset))
	}
}

func Xioctl(tls *TLS, fd int32, req int32, va uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v req=%v va=%v, (%v:)", tls, fd, req, va, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var ap Tva_list
	var arg uintptr
	var i, r int32
	var _ /* u at bp+0 */ struct {
		Fbuf         [0][256]uint8
		Falign       int64
		F__ccgo_pad2 [248]byte
	}
	_, _, _, _ = ap, arg, i, r
	ap = va
	arg = VaUintptr(&ap)
	_ = ap
	r = int32(X__syscall3(tls, int64(SYS_ioctl), int64(fd), int64(req), int64(arg)))
	if Bool(Bool(int32(SIOCGSTAMP) != int32(SIOCGSTAMP_OLD)) && req != 0) && r == -int32(ENOTTY) {
		i = 0
		for {
			if !(uint64(i) < Uint64FromInt64(400)/Uint64FromInt64(20)) {
				break
			}
			if _compat_map[i].Fnew_req != req {
				goto _1
			}
			_convert_ioctl_struct(tls, uintptr(unsafe.Pointer(&_compat_map))+uintptr(i)*20, bp, arg, int32(W))
			r = int32(X__syscall3(tls, int64(SYS_ioctl), int64(fd), int64(_compat_map[i].Fold_req), int64(bp)))
			if r < 0 {
				break
			}
			_convert_ioctl_struct(tls, uintptr(unsafe.Pointer(&_compat_map))+uintptr(i)*20, bp, arg, int32(R))
			break
			goto _1
		_1:
			;
			i++
		}
	}
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xissetugid(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__libc.Fsecure)
}

func Xlockf(tls *TLS, fd int32, op int32, size Toff_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v op=%v size=%v, (%v:)", tls, fd, op, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var _ /* l at bp+0 */ Tflock
	*(*Tflock)(unsafe.Pointer(bp)) = Tflock{
		Fl_type:   int16(F_WRLCK),
		Fl_whence: int16(1),
		Fl_len:    size,
	}
	switch op {
	case int32(F_TEST):
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_type = F_RDLCK
		if Xfcntl(tls, fd, int32(F_GETLK), VaList(bp+40, bp)) < 0 {
			return -int32(1)
		}
		if int32((*(*Tflock)(unsafe.Pointer(bp))).Fl_type) == int32(F_UNLCK) || (*(*Tflock)(unsafe.Pointer(bp))).Fl_pid == Xgetpid(tls) {
			return 0
		}
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EACCES)
		return -int32(1)
	case F_ULOCK:
		(*(*Tflock)(unsafe.Pointer(bp))).Fl_type = int16(F_UNLCK)
		fallthrough
	case int32(F_TLOCK):
		return Xfcntl(tls, fd, int32(F_SETLK), VaList(bp+40, bp))
	case int32(F_LOCK):
		return Xfcntl(tls, fd, int32(F_SETLKW), VaList(bp+40, bp))
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
	return -int32(1)
}

const ACCOUNTING = 9
const UTMP_FILE = "_PATH_UTMP"
const UTMP_FILENAME = "_PATH_UTMP"
const UT_HOSTSIZE = 256
const UT_LINESIZE = 32
const UT_NAMESIZE = 32
const WTMP_FILE = "_PATH_WTMP"
const WTMP_FILENAME = "_PATH_WTMP"
const _PATH_UTMP = "/dev/null/utmp"
const _PATH_WTMP = "/dev/null/wtmp"
const ut_name = 0
const utmp = 0

type Tlastlog = struct {
	Fll_time Ttime_t
	Fll_line [32]uint8
	Fll_host [256]uint8
}

func Xlogin_tty(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	Xsetsid(tls)
	if Xioctl(tls, fd, int32(TIOCSCTTY), VaList(bp+8, UintptrFromInt32(0))) != 0 {
		return -int32(1)
	}
	Xdup2(tls, fd, 0)
	Xdup2(tls, fd, int32(1))
	Xdup2(tls, fd, int32(2))
	if fd > int32(2) {
		Xclose(tls, fd)
	}
	return 0
}

const MNTOPT_DEFAULTS = "defaults"
const MNTOPT_NOAUTO = "noauto"
const MNTOPT_NOSUID = "nosuid"
const MNTOPT_RO = "ro"
const MNTOPT_RW = "rw"
const MNTOPT_SUID = "suid"
const MNTTYPE_IGNORE = "ignore"
const MNTTYPE_NFS = "nfs"
const MNTTYPE_SWAP = "swap"
const MOUNTED = "/etc/mtab"
const SENTINEL = 0

type Tmntent = struct {
	Fmnt_fsname uintptr
	Fmnt_dir    uintptr
	Fmnt_type   uintptr
	Fmnt_opts   uintptr
	Fmnt_freq   int32
	Fmnt_passno int32
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

var _internal_buf uintptr
var _internal_bufsize Tsize_t

func Xsetmntent(tls *TLS, name uintptr, mode uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v mode=%v, (%v:)", tls, name, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfopen(tls, name, mode)
}

func Xendmntent(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if f != 0 {
		Xfclose(tls, f)
	}
	return int32(1)
}

func _unescape_ent(tls *TLS, beg uintptr) (r uintptr) {
	var cval uint8
	var dest, src, val, v1, v2, v3, v4, v6, v7, v8, v9 uintptr
	var i int32
	_, _, _, _, _, _, _, _, _, _, _, _, _ = cval, dest, i, src, val, v1, v2, v3, v4, v6, v7, v8, v9
	dest = beg
	src = beg
	for *(*uint8)(unsafe.Pointer(src)) != 0 {
		cval = uint8(0)
		if int32(*(*uint8)(unsafe.Pointer(src))) != int32('\\') {
			v1 = dest
			dest++
			v2 = src
			src++
			*(*uint8)(unsafe.Pointer(v1)) = *(*uint8)(unsafe.Pointer(v2))
			continue
		}
		if int32(*(*uint8)(unsafe.Pointer(src + 1))) == int32('\\') {
			src++
			v3 = dest
			dest++
			v4 = src
			src++
			*(*uint8)(unsafe.Pointer(v3)) = *(*uint8)(unsafe.Pointer(v4))
			continue
		}
		val = src + uintptr(1)
		i = 0
		for {
			if !(i < int32(3)) {
				break
			}
			if int32(*(*uint8)(unsafe.Pointer(val))) >= int32('0') && int32(*(*uint8)(unsafe.Pointer(val))) <= int32('7') {
				cval = uint8(int32(cval) << Int32FromInt32(3))
				v6 = val
				val++
				cval = uint8(int32(cval) + (int32(*(*uint8)(unsafe.Pointer(v6))) - Int32FromUint8('0')))
			} else {
				break
			}
			goto _5
		_5:
			;
			i++
		}
		if cval != 0 {
			v7 = dest
			dest++
			*(*uint8)(unsafe.Pointer(v7)) = cval
			src = val
		} else {
			v8 = dest
			dest++
			v9 = src
			src++
			*(*uint8)(unsafe.Pointer(v8)) = *(*uint8)(unsafe.Pointer(v9))
		}
	}
	*(*uint8)(unsafe.Pointer(dest)) = uint8(0)
	return beg
}

func Xgetmntent_r(tls *TLS, f uintptr, mnt uintptr, linebuf uintptr, buflen int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v mnt=%v linebuf=%v buflen=%v, (%v:)", tls, f, mnt, linebuf, buflen, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var i, len1 Tsize_t
	var use_internal int32
	var _ /* n at bp+0 */ [8]int32
	_, _, _ = i, len1, use_internal
	use_internal = BoolInt32(linebuf == uintptr(unsafe.Pointer(&_internal_buf)))
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_freq = 0
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_passno = 0
	for cond := true; cond; cond = int32(*(*uint8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[0])))) == int32('#') || uint64((*(*[8]int32)(unsafe.Pointer(bp)))[int32(1)]) == len1 {
		if use_internal != 0 {
			Xgetline(tls, uintptr(unsafe.Pointer(&_internal_buf)), uintptr(unsafe.Pointer(&_internal_bufsize)), f)
			linebuf = _internal_buf
		} else {
			Xfgets(tls, linebuf, buflen, f)
		}
		if Xfeof(tls, f) != 0 || Xferror(tls, f) != 0 {
			return uintptr(0)
		}
		if !(Xstrchr(tls, linebuf, int32('\n')) != 0) {
			Xfscanf(tls, f, __ccgo_ts+813, 0)
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ERANGE)
			return uintptr(0)
		}
		len1 = Xstrlen(tls, linebuf)
		if len1 > uint64(INT_MAX) {
			continue
		}
		i = uint64(0)
		for {
			if !(i < Uint64FromInt64(32)/Uint64FromInt64(4)) {
				break
			}
			(*(*[8]int32)(unsafe.Pointer(bp)))[i] = int32(len1)
			goto _1
		_1:
			;
			i++
		}
		Xsscanf(tls, linebuf, __ccgo_ts+825, VaList(bp+40, bp, bp+uintptr(1)*4, bp+uintptr(2)*4, bp+uintptr(3)*4, bp+uintptr(4)*4, bp+uintptr(5)*4, bp+uintptr(6)*4, bp+uintptr(7)*4, mnt+32, mnt+36))
	}
	*(*uint8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(1)]))) = uint8(0)
	*(*uint8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(3)]))) = uint8(0)
	*(*uint8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(5)]))) = uint8(0)
	*(*uint8)(unsafe.Pointer(linebuf + uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(7)]))) = uint8(0)
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_fsname = _unescape_ent(tls, linebuf+uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[0]))
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_dir = _unescape_ent(tls, linebuf+uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(2)]))
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_type = _unescape_ent(tls, linebuf+uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(4)]))
	(*Tmntent)(unsafe.Pointer(mnt)).Fmnt_opts = _unescape_ent(tls, linebuf+uintptr((*(*[8]int32)(unsafe.Pointer(bp)))[int32(6)]))
	return mnt
}

func Xgetmntent(tls *TLS, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetmntent_r(tls, f, uintptr(unsafe.Pointer(&_mnt)), uintptr(unsafe.Pointer(&_internal_buf)), 0)
}

var _mnt Tmntent

func Xaddmntent(tls *TLS, f uintptr, mnt uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v mnt=%v, (%v:)", tls, f, mnt, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	if Xfseek(tls, f, 0, int32(2)) != 0 {
		return int32(1)
	}
	return BoolInt32(Xfprintf(tls, f, __ccgo_ts+880, VaList(bp+8, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_fsname, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_dir, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_type, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_opts, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_freq, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_passno)) < 0)
}

func Xhasmntopt(tls *TLS, mnt uintptr, opt uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v mnt=%v opt=%v, (%v:)", tls, mnt, opt, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrstr(tls, (*Tmntent)(unsafe.Pointer(mnt)).Fmnt_opts, opt)
}

type Thistory = struct {
	Fchain uintptr
	Fdev   Tdev_t
	Fino   Tino_t
	Flevel int32
	Fbase  int32
}

func _do_nftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32, flags int32, h uintptr) (r1 int32) {
	bp := tls.Alloc(176)
	defer tls.Free(176)
	var d, de, v10 uintptr
	var dfd, err, r, type1, v11, v12, v3, v4, v7 int32
	var j, k, l Tsize_t
	var v1 uint64
	var v13, v8 bool
	var v2 Tino_t
	var _ /* lev at bp+160 */ TFTW
	var _ /* new at bp+128 */ Thistory
	var _ /* st at bp+0 */ Tstat
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = d, de, dfd, err, j, k, l, r, type1, v1, v10, v11, v12, v13, v2, v3, v4, v7, v8
	l = Xstrlen(tls, path)
	if l != 0 && int32(*(*uint8)(unsafe.Pointer(path + uintptr(l-uint64(1))))) == int32('/') {
		v1 = l - uint64(1)
	} else {
		v1 = l
	}
	j = v1
	v2 = Uint64FromInt32(0)
	(*(*Tstat)(unsafe.Pointer(bp))).Fst_ino = v2
	(*(*Tstat)(unsafe.Pointer(bp))).Fst_dev = v2
	if flags&int32(FTW_PHYS) != 0 {
		v3 = Xlstat(tls, path, bp)
	} else {
		v3 = BoolInt32(Xstat(tls, path, bp) < 0)
	}
	if v3 != 0 {
		if !(flags&Int32FromInt32(FTW_PHYS) != 0) && *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(ENOENT) && !(Xlstat(tls, path, bp) != 0) {
			type1 = int32(FTW_SLN)
		} else {
			if *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(EACCES) {
				return -int32(1)
			} else {
				type1 = int32(FTW_NS)
			}
		}
	} else {
		if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(S_IFMT) == uint32(S_IFDIR) {
			if flags&int32(FTW_DEPTH) != 0 {
				type1 = int32(FTW_DP)
			} else {
				type1 = int32(FTW_D)
			}
		} else {
			if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(S_IFMT) == uint32(S_IFLNK) {
				if flags&int32(FTW_PHYS) != 0 {
					type1 = int32(FTW_SL)
				} else {
					type1 = int32(FTW_SLN)
				}
			} else {
				type1 = int32(FTW_F)
			}
		}
	}
	if flags&int32(FTW_MOUNT) != 0 && h != 0 && type1 != int32(FTW_NS) && (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev != (*Thistory)(unsafe.Pointer(h)).Fdev {
		return 0
	}
	(*(*Thistory)(unsafe.Pointer(bp + 128))).Fchain = h
	(*(*Thistory)(unsafe.Pointer(bp + 128))).Fdev = (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev
	(*(*Thistory)(unsafe.Pointer(bp + 128))).Fino = (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino
	if h != 0 {
		v4 = (*Thistory)(unsafe.Pointer(h)).Flevel + int32(1)
	} else {
		v4 = 0
	}
	(*(*Thistory)(unsafe.Pointer(bp + 128))).Flevel = v4
	(*(*Thistory)(unsafe.Pointer(bp + 128))).Fbase = int32(j + uint64(1))
	(*(*TFTW)(unsafe.Pointer(bp + 160))).Flevel = (*(*Thistory)(unsafe.Pointer(bp + 128))).Flevel
	if h != 0 {
		(*(*TFTW)(unsafe.Pointer(bp + 160))).Fbase = (*Thistory)(unsafe.Pointer(h)).Fbase
	} else {
		k = j
		for {
			if !(k != 0 && int32(*(*uint8)(unsafe.Pointer(path + uintptr(k)))) == int32('/')) {
				break
			}
			goto _5
		_5:
			;
			k--
		}
		for {
			if !(k != 0 && int32(*(*uint8)(unsafe.Pointer(path + uintptr(k-uint64(1))))) != int32('/')) {
				break
			}
			goto _6
		_6:
			;
			k--
		}
		(*(*TFTW)(unsafe.Pointer(bp + 160))).Fbase = int32(k)
	}
	if type1 == int32(FTW_D) || type1 == int32(FTW_DP) {
		dfd = Xopen(tls, path, O_RDONLY, 0)
		err = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
		if dfd < 0 && err == int32(EACCES) {
			type1 = int32(FTW_DNR)
		}
		if !(fd_limit != 0) {
			Xclose(tls, dfd)
		}
	}
	if v8 = !(flags&Int32FromInt32(FTW_DEPTH) != 0); v8 {
		v7 = (*(*func(*TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{fn})))(tls, path, bp, type1, bp+160)
		r = v7
	}
	if v8 && v7 != 0 {
		return r
	}
	for {
		if !(h != 0) {
			break
		}
		if (*Thistory)(unsafe.Pointer(h)).Fdev == (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev && (*Thistory)(unsafe.Pointer(h)).Fino == (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino {
			return 0
		}
		goto _9
	_9:
		;
		h = (*Thistory)(unsafe.Pointer(h)).Fchain
	}
	if (type1 == int32(FTW_D) || type1 == int32(FTW_DP)) && fd_limit != 0 {
		if dfd < 0 {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = err
			return -int32(1)
		}
		d = Xfdopendir(tls, dfd)
		if d != 0 {
			for {
				v10 = Xreaddir(tls, d)
				de = v10
				if !(v10 != 0) {
					break
				}
				if int32(*(*uint8)(unsafe.Pointer(de + 19))) == int32('.') && (!(*(*uint8)(unsafe.Pointer(de + 19 + 1)) != 0) || int32(*(*uint8)(unsafe.Pointer(de + 19 + 1))) == int32('.') && !(*(*uint8)(unsafe.Pointer(de + 19 + 2)) != 0)) {
					continue
				}
				if Xstrlen(tls, de+19) >= uint64(PATH_MAX)-l {
					*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENAMETOOLONG)
					Xclosedir(tls, d)
					return -int32(1)
				}
				*(*uint8)(unsafe.Pointer(path + uintptr(j))) = uint8('/')
				Xstrcpy(tls, path+uintptr(j)+uintptr(1), de+19)
				v11 = _do_nftw(tls, path, fn, fd_limit-int32(1), flags, bp+128)
				r = v11
				if v11 != 0 {
					Xclosedir(tls, d)
					return r
				}
			}
			Xclosedir(tls, d)
		} else {
			Xclose(tls, dfd)
			return -int32(1)
		}
	}
	*(*uint8)(unsafe.Pointer(path + uintptr(l))) = uint8(0)
	if v13 = flags&int32(FTW_DEPTH) != 0; v13 {
		v12 = (*(*func(*TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{fn})))(tls, path, bp, type1, bp+160)
		r = v12
	}
	if v13 && v12 != 0 {
		return r
	}
	return 0
}

func Xnftw(tls *TLS, path uintptr, fn uintptr, fd_limit int32, flags int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v fn=%v fd_limit=%v flags=%v, (%v:)", tls, path, fn, fd_limit, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(4112)
	defer tls.Free(4112)
	var l Tsize_t
	var r int32
	var _ /* cs at bp+0 */ int32
	var _ /* pathbuf at bp+4 */ [4097]uint8
	_, _ = l, r
	if fd_limit <= 0 {
		return 0
	}
	l = Xstrlen(tls, path)
	if l > uint64(PATH_MAX) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENAMETOOLONG)
		return -int32(1)
	}
	Xmemcpy(tls, bp+4, path, l+uint64(1))
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	r = _do_nftw(tls, bp+4, fn, fd_limit, flags, UintptrFromInt32(0))
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return r
}

/* Nonstandard, but vastly superior to the standard functions */

func Xopenpty(tls *TLS, pm uintptr, ps uintptr, name uintptr, tio uintptr, ws uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v pm=%v ps=%v name=%v tio=%v ws=%v, (%v:)", tls, pm, ps, name, tio, ws, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var m, s, v1 int32
	var _ /* buf at bp+8 */ [20]uint8
	var _ /* cs at bp+4 */ int32
	var _ /* n at bp+0 */ int32
	_, _, _ = m, s, v1
	*(*int32)(unsafe.Pointer(bp)) = 0
	m = Xopen(tls, __ccgo_ts+899, Int32FromInt32(O_RDWR)|Int32FromInt32(O_NOCTTY), 0)
	if m < 0 {
		return -int32(1)
	}
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+4)
	if Xioctl(tls, m, int32(TIOCSPTLCK), VaList(bp+40, bp)) != 0 || Xioctl(tls, m, Int32FromUint32(TIOCGPTN), VaList(bp+40, bp)) != 0 {
		goto fail
	}
	if !(name != 0) {
		name = bp + 8
	}
	Xsnprintf(tls, name, uint64(20), __ccgo_ts+909, VaList(bp+40, *(*int32)(unsafe.Pointer(bp))))
	v1 = Xopen(tls, name, Int32FromInt32(O_RDWR)|Int32FromInt32(O_NOCTTY), 0)
	s = v1
	if v1 < 0 {
		goto fail
	}
	if tio != 0 {
		Xtcsetattr(tls, s, TCSANOW, tio)
	}
	if ws != 0 {
		Xioctl(tls, s, int32(TIOCSWINSZ), VaList(bp+40, ws))
	}
	*(*int32)(unsafe.Pointer(pm)) = m
	*(*int32)(unsafe.Pointer(ps)) = s
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 4)), uintptr(0))
	return 0
	goto fail
fail:
	;
	Xclose(tls, m)
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 4)), uintptr(0))
	return -int32(1)
}

func Xptsname(tls *TLS, fd int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var err int32
	_ = err
	err = X__ptsname_r(tls, fd, uintptr(unsafe.Pointer(&_buf2)), uint64(22))
	if err != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = err
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_buf2))
}

var _buf2 [22]uint8

func Xposix_openpt(tls *TLS, flags int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v flags=%v, (%v:)", tls, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = Xopen(tls, __ccgo_ts+899, flags, 0)
	if r < 0 && *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(ENOSPC) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EAGAIN)
	}
	return r
}

func Xgrantpt(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func Xunlockpt(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* unlock at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = 0
	return Xioctl(tls, fd, int32(TIOCSPTLCK), VaList(bp+16, bp))
}

func X__ptsname_r(tls *TLS, fd int32, buf uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v len1=%v, (%v:)", tls, fd, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var err, v1 int32
	var _ /* pty at bp+0 */ int32
	_, _ = err, v1
	if !(buf != 0) {
		len1 = uint64(0)
	}
	v1 = int32(X__syscall3(tls, int64(SYS_ioctl), int64(fd), int64(Uint32FromUint32(TIOCGPTN)), int64(bp)))
	err = v1
	if v1 != 0 {
		return -err
	}
	if uint64(Xsnprintf(tls, buf, len1, __ccgo_ts+909, VaList(bp+16, *(*int32)(unsafe.Pointer(bp))))) >= len1 {
		return int32(ERANGE)
	}
	return 0
}

func Xptsname_r(tls *TLS, fd int32, buf uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v len1=%v, (%v:)", tls, fd, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__ptsname_r(tls, fd, buf, len1)
}

func _slash_len(tls *TLS, s uintptr) (r Tsize_t) {
	var s0 uintptr
	_ = s0
	s0 = s
	for int32(*(*uint8)(unsafe.Pointer(s))) == int32('/') {
		s++
	}
	return uint64(int64(s) - int64(s0))
}

func Xrealpath(tls *TLS, filename uintptr, resolved uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v filename=%v resolved=%v, (%v:)", tls, filename, resolved, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(8208)
	defer tls.Free(8208)
	var check_dir, up int32
	var cnt, l, l0, nup, p, q, v10, v11, v4, v5, v6, v7, v9 Tsize_t
	var k Tssize_t
	var z uintptr
	var _ /* output at bp+4097 */ [4096]uint8
	var _ /* stack at bp+0 */ [4097]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = check_dir, cnt, k, l, l0, nup, p, q, up, z, v10, v11, v4, v5, v6, v7, v9
	cnt = uint64(0)
	nup = uint64(0)
	check_dir = 0
	if !(filename != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	l = Xstrnlen(tls, filename, uint64(4097))
	if !(l != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOENT)
		return uintptr(0)
	}
	if l >= uint64(PATH_MAX) {
		goto toolong
	}
	p = uint64(4097) - l - uint64(1)
	q = uint64(0)
	Xmemcpy(tls, bp+uintptr(p), filename, l+uint64(1))
	/* Main loop. Each iteration pops the next part from stack of
	 * remaining path components and consumes any slashes that follow.
	 * If not a link, it's moved to output; if a link, contents are
	 * pushed to the stack. */
	goto restart
restart:
	;
_3:
	;
	/* If stack starts with /, the whole component is / or //
	 * and the output state must be reset. */
	if int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[p]) == int32('/') {
		check_dir = 0
		nup = uint64(0)
		q = uint64(0)
		v4 = q
		q++
		(*(*[4096]uint8)(unsafe.Pointer(bp + 4097)))[v4] = uint8('/')
		p++
		/* Initial // is special. */
		if int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[p]) == int32('/') && int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[p+uint64(1)]) != int32('/') {
			v5 = q
			q++
			(*(*[4096]uint8)(unsafe.Pointer(bp + 4097)))[v5] = uint8('/')
		}
		goto _2
	}
	z = X__strchrnul(tls, bp+uintptr(p), int32('/'))
	v6 = uint64(int64(z) - int64(bp+uintptr(p)))
	l = v6
	l0 = v6
	if !(l != 0) && !(check_dir != 0) {
		goto _1
	}
	/* Skip any . component but preserve check_dir status. */
	if l == uint64(1) && int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[p]) == int32('.') {
		p += l
		goto _2
	}
	/* Copy next component onto output at least temporarily, to
	 * call readlink, but wait to advance output position until
	 * determining it's not a link. */
	if q != 0 && int32((*(*[4096]uint8)(unsafe.Pointer(bp + 4097)))[q-uint64(1)]) != int32('/') {
		if !(p != 0) {
			goto toolong
		}
		p--
		v7 = p
		(*(*[4097]uint8)(unsafe.Pointer(bp)))[v7] = uint8('/')
		l++
	}
	if q+l >= uint64(PATH_MAX) {
		goto toolong
	}
	Xmemcpy(tls, bp+4097+uintptr(q), bp+uintptr(p), l)
	(*(*[4096]uint8)(unsafe.Pointer(bp + 4097)))[q+l] = uint8(0)
	p += l
	up = 0
	if l0 == uint64(2) && int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[p-uint64(2)]) == int32('.') && int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[p-uint64(1)]) == int32('.') {
		up = int32(1)
		/* Any non-.. path components we could cancel start
		 * after nup repetitions of the 3-byte string "../";
		 * if there are none, accumulate .. components to
		 * later apply to cwd, if needed. */
		if q <= uint64(3)*nup {
			nup++
			q += l
			goto _2
		}
		/* When previous components are already known to be
		 * directories, processing .. can skip readlink. */
		if !(check_dir != 0) {
			goto skip_readlink
		}
	}
	k = Xreadlink(tls, bp+4097, bp, p)
	if uint64(k) == p {
		goto toolong
	}
	if !(k != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOENT)
		return uintptr(0)
	}
	if !(k < 0) {
		goto _8
	}
	if *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(EINVAL) {
		return uintptr(0)
	}
	goto skip_readlink
skip_readlink:
	;
	check_dir = 0
	if up != 0 {
		for q != 0 && int32((*(*[4096]uint8)(unsafe.Pointer(bp + 4097)))[q-uint64(1)]) != int32('/') {
			q--
		}
		if q > uint64(1) && (q > uint64(2) || int32((*(*[4096]uint8)(unsafe.Pointer(bp + 4097)))[0]) != int32('/')) {
			q--
		}
		goto _2
	}
	if l0 != 0 {
		q += l
	}
	check_dir = int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[p])
	goto _2
_8:
	;
	cnt++
	v9 = cnt
	if v9 == uint64(SYMLOOP_MAX) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ELOOP)
		return uintptr(0)
	}
	/* If link contents end in /, strip any slashes already on
	 * stack to avoid /->// or //->/// or spurious toolong. */
	if int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[k-int64(1)]) == int32('/') {
		for int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[p]) == int32('/') {
			p++
		}
	}
	p -= uint64(k)
	Xmemmove(tls, bp+uintptr(p), bp, uint64(k))
	/* Skip the stack advancement in case we have a new
	 * absolute base path. */
	goto restart
	goto _2
_2:
	;
	p += _slash_len(tls, bp+uintptr(p))
	goto _3
	goto _1
_1:
	;
	(*(*[4096]uint8)(unsafe.Pointer(bp + 4097)))[q] = uint8(0)
	if int32((*(*[4096]uint8)(unsafe.Pointer(bp + 4097)))[0]) != int32('/') {
		if !(Xgetcwd(tls, bp, uint64(4097)) != 0) {
			return uintptr(0)
		}
		l = Xstrlen(tls, bp)
		/* Cancel any initial .. components. */
		p = uint64(0)
		for {
			v10 = nup
			nup--
			if !(v10 != 0) {
				break
			}
			for l > uint64(1) && int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[l-uint64(1)]) != int32('/') {
				l--
			}
			if l > uint64(1) {
				l--
			}
			p += uint64(2)
			if p < q {
				p++
			}
		}
		if q-p != 0 && int32((*(*[4097]uint8)(unsafe.Pointer(bp)))[l-uint64(1)]) != int32('/') {
			v11 = l
			l++
			(*(*[4097]uint8)(unsafe.Pointer(bp)))[v11] = uint8('/')
		}
		if l+(q-p)+uint64(1) >= uint64(PATH_MAX) {
			goto toolong
		}
		Xmemmove(tls, bp+4097+uintptr(l), bp+4097+uintptr(p), q-p+uint64(1))
		Xmemcpy(tls, bp+4097, bp, l)
		q = l + q - p
	}
	if resolved != 0 {
		return Xmemcpy(tls, resolved, bp+4097, q+uint64(1))
	} else {
		return Xstrdup(tls, bp+4097)
	}
	goto toolong
toolong:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENAMETOOLONG)
	return uintptr(0)
}

func Xsetdomainname(tls *TLS, name uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v len1=%v, (%v:)", tls, name, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_setdomainname), int64(name), int64(len1)))))
}

func Xsetpriority(tls *TLS, which int32, who Tid_t, prio int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v which=%v who=%v prio=%v, (%v:)", tls, which, who, prio, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_setpriority), int64(which), int64(who), int64(prio)))))
}

type Tctx = struct {
	Flim [2]uint64
	Fres int32
	Ferr int32
}

func _do_setrlimit(tls *TLS, p uintptr) {
	var c uintptr
	_ = c
	c = p
	if (*Tctx)(unsafe.Pointer(c)).Ferr > 0 {
		return
	}
	(*Tctx)(unsafe.Pointer(c)).Ferr = int32(-X__syscall2(tls, int64(SYS_setrlimit), int64((*Tctx)(unsafe.Pointer(c)).Fres), int64(c)))
}

func Xsetrlimit(tls *TLS, resource int32, rlim uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v resource=%v rlim=%v, (%v:)", tls, resource, rlim, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var ret int32
	var v1, v2 uint64
	var _ /* c at bp+16 */ Tctx
	var _ /* tmp at bp+0 */ Trlimit
	_, _, _ = ret, v1, v2
	if ^Uint64FromUint64(0) != ^Uint64FromUint64(0) {
		*(*Trlimit)(unsafe.Pointer(bp)) = *(*Trlimit)(unsafe.Pointer(rlim))
		if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur >= ^Uint64FromUint64(0) {
			(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_cur = ^Uint64FromUint64(0)
		}
		if (*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max >= ^Uint64FromUint64(0) {
			(*(*Trlimit)(unsafe.Pointer(bp))).Frlim_max = ^Uint64FromUint64(0)
		}
		rlim = bp
	}
	ret = int32(X__syscall4(tls, int64(SYS_prlimit64), int64(Int32FromInt32(0)), int64(resource), int64(rlim), int64(Int32FromInt32(0))))
	if ret != -int32(ENOSYS) {
		return int32(X__syscall_ret(tls, uint64(ret)))
	}
	if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur < ^Uint64FromUint64(0) {
		v1 = (*Trlimit)(unsafe.Pointer(rlim)).Frlim_cur
	} else {
		v1 = ^Uint64FromUint64(0)
	}
	if (*Trlimit)(unsafe.Pointer(rlim)).Frlim_max < ^Uint64FromUint64(0) {
		v2 = (*Trlimit)(unsafe.Pointer(rlim)).Frlim_max
	} else {
		v2 = ^Uint64FromUint64(0)
	}
	*(*Tctx)(unsafe.Pointer(bp + 16)) = Tctx{
		Flim: [2]uint64{
			0: v1,
			1: v2,
		},
		Fres: resource,
		Ferr: -int32(1),
	}
	___synccall(tls, __ccgo_fp(_do_setrlimit), bp+16)
	if (*(*Tctx)(unsafe.Pointer(bp + 16))).Ferr != 0 {
		if (*(*Tctx)(unsafe.Pointer(bp + 16))).Ferr > 0 {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = (*(*Tctx)(unsafe.Pointer(bp + 16))).Ferr
		}
		return -int32(1)
	}
	return 0
}

func Xsyscall(tls *TLS, n int64, va uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v n=%v va=%v, (%v:)", tls, n, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, b, c, d, e, f Tsyscall_arg_t
	var ap Tva_list
	_, _, _, _, _, _, _ = a, ap, b, c, d, e, f
	ap = va
	a = VaInt64(&ap)
	b = VaInt64(&ap)
	c = VaInt64(&ap)
	d = VaInt64(&ap)
	e = VaInt64(&ap)
	f = VaInt64(&ap)
	_ = ap
	return X__syscall_ret(tls, uint64(X__syscall6(tls, n, a, b, c, d, e, f)))
}

const AF_ALG = 38
const AF_APPLETALK = 5
const AF_ASH = 18
const AF_ATMPVC = 8
const AF_ATMSVC = 20
const AF_AX25 = 3
const AF_BLUETOOTH = 31
const AF_BRIDGE = 7
const AF_CAIF = 37
const AF_CAN = 29
const AF_DECnet = 12
const AF_ECONET = 19
const AF_FILE = 1
const AF_IB = 27
const AF_IEEE802154 = 36
const AF_INET = 2
const AF_INET6 = 10
const AF_IPX = 4
const AF_IRDA = 23
const AF_ISDN = 34
const AF_IUCV = 32
const AF_KCM = 41
const AF_KEY = 15
const AF_LLC = 26
const AF_LOCAL = 1
const AF_MAX = 45
const AF_MPLS = 28
const AF_NETBEUI = 13
const AF_NETLINK = 16
const AF_NETROM = 6
const AF_NFC = 39
const AF_PACKET = 17
const AF_PHONET = 35
const AF_PPPOX = 24
const AF_QIPCRTR = 42
const AF_RDS = 21
const AF_ROSE = 11
const AF_ROUTE = 16
const AF_RXRPC = 33
const AF_SECURITY = 14
const AF_SMC = 43
const AF_SNA = 22
const AF_TIPC = 30
const AF_UNIX = 1
const AF_UNSPEC = 0
const AF_VSOCK = 40
const AF_WANPIPE = 25
const AF_X25 = 9
const AF_XDP = 44
const LOG_ALERT = 1
const LOG_AUTH = 32
const LOG_AUTHPRIV = 80
const LOG_CONS = 2
const LOG_CRIT = 2
const LOG_CRON = 72
const LOG_DAEMON = 24
const LOG_DEBUG = 7
const LOG_EMERG = 0
const LOG_ERR = 3
const LOG_FACMASK = 1016
const LOG_FTP = 88
const LOG_INFO = 6
const LOG_KERN = 0
const LOG_LOCAL0 = 128
const LOG_LOCAL1 = 136
const LOG_LOCAL2 = 144
const LOG_LOCAL3 = 152
const LOG_LOCAL4 = 160
const LOG_LOCAL5 = 168
const LOG_LOCAL6 = 176
const LOG_LOCAL7 = 184
const LOG_LPR = 48
const LOG_MAIL = 16
const LOG_NDELAY = 8
const LOG_NEWS = 56
const LOG_NFACILITIES = 24
const LOG_NOTICE = 5
const LOG_NOWAIT = 16
const LOG_ODELAY = 4
const LOG_PERROR = 32
const LOG_PID = 1
const LOG_PRIMASK = 7
const LOG_SYSLOG = 40
const LOG_USER = 8
const LOG_UUCP = 64
const LOG_WARNING = 4
const MSG_BATCH = 262144
const MSG_CMSG_CLOEXEC = 1073741824
const MSG_CONFIRM = 2048
const MSG_CTRUNC = 8
const MSG_DONTROUTE = 4
const MSG_DONTWAIT = 64
const MSG_EOR = 128
const MSG_ERRQUEUE = 8192
const MSG_FASTOPEN = 536870912
const MSG_FIN = 512
const MSG_MORE = 32768
const MSG_NOSIGNAL = 16384
const MSG_OOB = 1
const MSG_PEEK = 2
const MSG_PROXY = 16
const MSG_RST = 4096
const MSG_SYN = 1024
const MSG_TRUNC = 32
const MSG_WAITALL = 256
const MSG_WAITFORONE = 65536
const MSG_ZEROCOPY = 67108864
const PF_ALG = 38
const PF_APPLETALK = 5
const PF_ASH = 18
const PF_ATMPVC = 8
const PF_ATMSVC = 20
const PF_AX25 = 3
const PF_BLUETOOTH = 31
const PF_BRIDGE = 7
const PF_CAIF = 37
const PF_CAN = 29
const PF_DECnet = 12
const PF_ECONET = 19
const PF_FILE = 1
const PF_IB = 27
const PF_IEEE802154 = 36
const PF_INET = 2
const PF_INET6 = 10
const PF_IPX = 4
const PF_IRDA = 23
const PF_ISDN = 34
const PF_IUCV = 32
const PF_KCM = 41
const PF_KEY = 15
const PF_LLC = 26
const PF_LOCAL = 1
const PF_MAX = 45
const PF_MPLS = 28
const PF_NETBEUI = 13
const PF_NETLINK = 16
const PF_NETROM = 6
const PF_NFC = 39
const PF_PACKET = 17
const PF_PHONET = 35
const PF_PPPOX = 24
const PF_QIPCRTR = 42
const PF_RDS = 21
const PF_ROSE = 11
const PF_ROUTE = 16
const PF_RXRPC = 33
const PF_SECURITY = 14
const PF_SMC = 43
const PF_SNA = 22
const PF_TIPC = 30
const PF_UNIX = 1
const PF_UNSPEC = 0
const PF_VSOCK = 40
const PF_WANPIPE = 25
const PF_X25 = 9
const PF_XDP = 44
const SCM_CREDENTIALS = 2
const SCM_RIGHTS = 1
const SCM_TIMESTAMP = 29
const SCM_TIMESTAMPING = 37
const SCM_TIMESTAMPING_OPT_STATS = 54
const SCM_TIMESTAMPING_PKTINFO = 58
const SCM_TIMESTAMPNS = 35
const SCM_TXTIME = 61
const SCM_WIFI_STATUS = 41
const SHUT_RD = 0
const SHUT_RDWR = 2
const SHUT_WR = 1
const SOCK_CLOEXEC = 524288
const SOCK_DCCP = 6
const SOCK_DGRAM = 2
const SOCK_NONBLOCK = 2048
const SOCK_PACKET = 10
const SOCK_RAW = 3
const SOCK_RDM = 4
const SOCK_SEQPACKET = 5
const SOCK_STREAM = 1
const SOL_AAL = 265
const SOL_ALG = 279
const SOL_ATM = 264
const SOL_BLUETOOTH = 274
const SOL_CAIF = 278
const SOL_DCCP = 269
const SOL_DECNET = 261
const SOL_ICMPV6 = 58
const SOL_IP = 0
const SOL_IPV6 = 41
const SOL_IRDA = 266
const SOL_IUCV = 277
const SOL_KCM = 281
const SOL_LLC = 268
const SOL_NETBEUI = 267
const SOL_NETLINK = 270
const SOL_NFC = 280
const SOL_PACKET = 263
const SOL_PNPIPE = 275
const SOL_PPPOL2TP = 273
const SOL_RAW = 255
const SOL_RDS = 276
const SOL_RXRPC = 272
const SOL_SOCKET = 1
const SOL_TIPC = 271
const SOL_TLS = 282
const SOL_X25 = 262
const SOL_XDP = 283
const SOMAXCONN = 128
const SO_ACCEPTCONN = 30
const SO_ATTACH_BPF = 50
const SO_ATTACH_FILTER = 26
const SO_ATTACH_REUSEPORT_CBPF = 51
const SO_ATTACH_REUSEPORT_EBPF = 52
const SO_BINDTODEVICE = 25
const SO_BINDTOIFINDEX = 62
const SO_BPF_EXTENSIONS = 48
const SO_BROADCAST = 6
const SO_BSDCOMPAT = 14
const SO_BUSY_POLL = 46
const SO_BUSY_POLL_BUDGET = 70
const SO_CNX_ADVICE = 53
const SO_COOKIE = 57
const SO_DEBUG = 1
const SO_DETACH_BPF = 27
const SO_DETACH_FILTER = 27
const SO_DETACH_REUSEPORT_BPF = 68
const SO_DOMAIN = 39
const SO_DONTROUTE = 5
const SO_ERROR = 4
const SO_GET_FILTER = 26
const SO_INCOMING_CPU = 49
const SO_INCOMING_NAPI_ID = 56
const SO_KEEPALIVE = 9
const SO_LINGER = 13
const SO_LOCK_FILTER = 44
const SO_MARK = 36
const SO_MAX_PACING_RATE = 47
const SO_MEMINFO = 55
const SO_NOFCS = 43
const SO_NO_CHECK = 11
const SO_OOBINLINE = 10
const SO_PASSCRED = 16
const SO_PASSSEC = 34
const SO_PEEK_OFF = 42
const SO_PEERCRED = 17
const SO_PEERGROUPS = 59
const SO_PEERNAME = 28
const SO_PEERSEC = 31
const SO_PREFER_BUSY_POLL = 69
const SO_PRIORITY = 12
const SO_PROTOCOL = 38
const SO_RCVBUF = 8
const SO_RCVBUFFORCE = 33
const SO_RCVLOWAT = 18
const SO_RCVTIMEO = 20
const SO_REUSEADDR = 2
const SO_REUSEPORT = 15
const SO_RXQ_OVFL = 40
const SO_SECURITY_AUTHENTICATION = 22
const SO_SECURITY_ENCRYPTION_NETWORK = 24
const SO_SECURITY_ENCRYPTION_TRANSPORT = 23
const SO_SELECT_ERR_QUEUE = 45
const SO_SNDBUF = 7
const SO_SNDBUFFORCE = 32
const SO_SNDLOWAT = 19
const SO_SNDTIMEO = 21
const SO_TIMESTAMP = 29
const SO_TIMESTAMPING = 37
const SO_TIMESTAMPNS = 35
const SO_TXTIME = 61
const SO_TYPE = 3
const SO_WIFI_STATUS = 41
const SO_ZEROCOPY = 60

type Tsocklen_t = uint32

type Tsa_family_t = uint16

type Tmsghdr = struct {
	Fmsg_name       uintptr
	Fmsg_namelen    Tsocklen_t
	Fmsg_iov        uintptr
	Fmsg_iovlen     int32
	F__pad1         int32
	Fmsg_control    uintptr
	Fmsg_controllen Tsocklen_t
	F__pad2         int32
	Fmsg_flags      int32
}

type Tcmsghdr = struct {
	Fcmsg_len   Tsocklen_t
	F__pad1     int32
	Fcmsg_level int32
	Fcmsg_type  int32
}

type Tlinger = struct {
	Fl_onoff  int32
	Fl_linger int32
}

type Tsockaddr = struct {
	Fsa_family Tsa_family_t
	Fsa_data   [14]uint8
}

type Tsockaddr_storage = struct {
	Fss_family    Tsa_family_t
	F__ss_padding [118]uint8
	F__ss_align   uint64
}

type t__ucontext2 = Tucontext_t2

var _lock2 [1]int32
var _log_ident [32]uint8
var _log_opt int32
var _log_facility = Int32FromInt32(1) << Int32FromInt32(3)
var _log_mask = int32(0xff)
var _log_fd = -int32(1)

func Xsetlogmask(tls *TLS, maskpri int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v maskpri=%v, (%v:)", tls, maskpri, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int32
	_ = ret
	___lock(tls, uintptr(unsafe.Pointer(&_lock2)))
	ret = _log_mask
	if maskpri != 0 {
		_log_mask = maskpri
	}
	___unlock(tls, uintptr(unsafe.Pointer(&_lock2)))
	return ret
}

var _log_addr = struct {
	Fsun_family int16
	Fsun_path   [9]uint8
}{
	Fsun_family: int16(PF_LOCAL),
	Fsun_path:   [9]uint8{'/', 'd', 'e', 'v', '/', 'l', 'o', 'g'},
}

func Xcloselog(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* cs at bp+0 */ int32
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	___lock(tls, uintptr(unsafe.Pointer(&_lock2)))
	Xclose(tls, _log_fd)
	_log_fd = -int32(1)
	___unlock(tls, uintptr(unsafe.Pointer(&_lock2)))
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
}

func ___openlog(tls *TLS) {
	_log_fd = Xsocket(tls, int32(PF_LOCAL), Int32FromInt32(SOCK_DGRAM)|Int32FromInt32(SOCK_CLOEXEC), 0)
	if _log_fd >= 0 {
		Xconnect(tls, _log_fd, uintptr(unsafe.Pointer(&_log_addr)), uint32(12))
	}
}

func Xopenlog(tls *TLS, ident uintptr, opt int32, facility int32) {
	if __ccgo_strace {
		trc("tls=%v ident=%v opt=%v facility=%v, (%v:)", tls, ident, opt, facility, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var n Tsize_t
	var _ /* cs at bp+0 */ int32
	_ = n
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	___lock(tls, uintptr(unsafe.Pointer(&_lock2)))
	if ident != 0 {
		n = Xstrnlen(tls, ident, Uint64FromInt64(32)-Uint64FromInt32(1))
		Xmemcpy(tls, uintptr(unsafe.Pointer(&_log_ident)), ident, n)
		_log_ident[n] = uint8(0)
	} else {
		_log_ident[0] = uint8(0)
	}
	_log_opt = opt
	_log_facility = facility
	if opt&int32(LOG_NDELAY) != 0 && _log_fd < 0 {
		___openlog(tls)
	}
	___unlock(tls, uintptr(unsafe.Pointer(&_lock2)))
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
}

func _is_lost_conn(tls *TLS, e int32) (r int32) {
	return BoolInt32(e == int32(ECONNREFUSED) || e == int32(ECONNRESET) || e == int32(ENOTCONN) || e == int32(EPIPE))
}

func __vsyslog(tls *TLS, priority int32, message uintptr, ap Tva_list) {
	bp := tls.Alloc(1184)
	defer tls.Free(1184)
	var errno_save, fd, l, l2, pid, v1, v2 int32
	var _ /* buf at bp+80 */ [1024]uint8
	var _ /* hlen at bp+1104 */ int32
	var _ /* now at bp+16 */ Ttime_t
	var _ /* timebuf at bp+0 */ [16]uint8
	var _ /* tm at bp+24 */ Ttm
	_, _, _, _, _, _, _ = errno_save, fd, l, l2, pid, v1, v2
	errno_save = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	if _log_fd < 0 {
		___openlog(tls)
	}
	if !(priority&Int32FromInt32(LOG_FACMASK) != 0) {
		priority |= _log_facility
	}
	*(*Ttime_t)(unsafe.Pointer(bp + 16)) = Xtime(tls, UintptrFromInt32(0))
	Xgmtime_r(tls, bp+16, bp+24)
	Xstrftime_l(tls, bp, uint64(16), __ccgo_ts+921, bp+24, uintptr(unsafe.Pointer(&X__c_locale)))
	if _log_opt&int32(LOG_PID) != 0 {
		v1 = Xgetpid(tls)
	} else {
		v1 = 0
	}
	pid = v1
	l = Xsnprintf(tls, bp+80, uint64(1024), __ccgo_ts+930, VaList(bp+1120, priority, bp, bp+1104, uintptr(unsafe.Pointer(&_log_ident)), __ccgo_ts+952+BoolUintptr(!(pid != 0)), pid, __ccgo_ts+954+BoolUintptr(!(pid != 0))))
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = errno_save
	l2 = Xvsnprintf(tls, bp+80+uintptr(l), uint64(1024)-uint64(l), message, ap)
	if l2 >= 0 {
		if uint64(l2) >= uint64(1024)-uint64(l) {
			l = int32(Uint64FromInt64(1024) - Uint64FromInt32(1))
		} else {
			l += l2
		}
		if int32((*(*[1024]uint8)(unsafe.Pointer(bp + 80)))[l-int32(1)]) != int32('\n') {
			v2 = l
			l++
			(*(*[1024]uint8)(unsafe.Pointer(bp + 80)))[v2] = uint8('\n')
		}
		if Xsend(tls, _log_fd, bp+80, uint64(l), 0) < 0 && (!(_is_lost_conn(tls, *(*int32)(unsafe.Pointer(X__errno_location(tls)))) != 0) || Xconnect(tls, _log_fd, uintptr(unsafe.Pointer(&_log_addr)), uint32(12)) < 0 || Xsend(tls, _log_fd, bp+80, uint64(l), 0) < 0) && _log_opt&int32(LOG_CONS) != 0 {
			fd = Xopen(tls, __ccgo_ts+649, Int32FromInt32(O_WRONLY)|Int32FromInt32(O_NOCTTY)|Int32FromInt32(O_CLOEXEC), 0)
			if fd >= 0 {
				Xdprintf(tls, fd, __ccgo_ts+956, VaList(bp+1120, l-*(*int32)(unsafe.Pointer(bp + 1104)), bp+80+uintptr(*(*int32)(unsafe.Pointer(bp + 1104)))))
				Xclose(tls, fd)
			}
		}
		if _log_opt&int32(LOG_PERROR) != 0 {
			Xdprintf(tls, int32(2), __ccgo_ts+956, VaList(bp+1120, l-*(*int32)(unsafe.Pointer(bp + 1104)), bp+80+uintptr(*(*int32)(unsafe.Pointer(bp + 1104)))))
		}
	}
}

func ___vsyslog(tls *TLS, priority int32, message uintptr, ap Tva_list) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* cs at bp+0 */ int32
	if !(_log_mask&(Int32FromInt32(1)<<(priority&Int32FromInt32(7))) != 0) || priority & ^Int32FromInt32(0x3ff) != 0 {
		return
	}
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	___lock(tls, uintptr(unsafe.Pointer(&_lock2)))
	__vsyslog(tls, priority, message, ap)
	___unlock(tls, uintptr(unsafe.Pointer(&_lock2)))
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
}

func Xsyslog(tls *TLS, priority int32, message uintptr, va uintptr) {
	if __ccgo_strace {
		trc("tls=%v priority=%v message=%v va=%v, (%v:)", tls, priority, message, va, origin(2))
	}
	var ap Tva_list
	_ = ap
	ap = va
	___vsyslog(tls, priority, message, ap)
	_ = ap
}

type Tutsname1 = struct {
	Fsysname      [65]uint8
	Fnodename     [65]uint8
	Frelease      [65]uint8
	Fversion      [65]uint8
	Fmachine      [65]uint8
	F__domainname [65]uint8
}

func Xuname(tls *TLS, uts uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v uts=%v, (%v:)", tls, uts, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_uname), int64(uts)))))
}

func X__madvise(tls *TLS, addr uintptr, len1 Tsize_t, advice int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v advice=%v, (%v:)", tls, addr, len1, advice, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_madvise), int64(addr), int64(len1), int64(advice)))))
}

func Xmadvise(tls *TLS, addr uintptr, len1 Tsize_t, advice int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v advice=%v, (%v:)", tls, addr, len1, advice, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__madvise(tls, addr, len1, advice)
}

func Xmincore(tls *TLS, addr uintptr, len1 Tsize_t, vec uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v vec=%v, (%v:)", tls, addr, len1, vec, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_mincore), int64(addr), int64(len1), int64(vec)))))
}

func Xmlock(tls *TLS, addr uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v, (%v:)", tls, addr, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_mlock), int64(addr), int64(len1)))))
}

func Xmlockall(tls *TLS, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v flags=%v, (%v:)", tls, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_mlockall), int64(flags)))))
}

const OFF_MASK = 4095
const UNIT = 4096

func _dummy5(tls *TLS) {
}

func X__mmap(tls *TLS, start uintptr, len1 Tsize_t, prot int32, flags int32, fd int32, off Toff_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v start=%v len1=%v prot=%v flags=%v fd=%v off=%v, (%v:)", tls, start, len1, prot, flags, fd, off, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int64
	_ = ret
	if uint64(off)&(-Uint64FromUint64(0x2000)<<(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1))|(Uint64FromUint64(4096)-Uint64FromInt32(1))) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(-Int32FromInt32(1))
	}
	if len1 >= uint64(Int64FromInt64(INT64_MAX)) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMEM)
		return uintptr(-Int32FromInt32(1))
	}
	if flags&int32(MAP_FIXED) != 0 {
		_dummy5(tls)
	}
	ret = X__syscall6(tls, int64(SYS_mmap), int64(start), int64(len1), int64(prot), int64(flags), int64(fd), off)
	/* Fixup incorrect EPERM from kernel. */
	if ret == int64(-int32(EPERM)) && !(start != 0) && flags&int32(MAP_ANON) != 0 && !(flags&Int32FromInt32(MAP_FIXED) != 0) {
		ret = int64(-int32(ENOMEM))
	}
	return uintptr(X__syscall_ret(tls, uint64(ret)))
}

func Xmmap(tls *TLS, start uintptr, len1 Tsize_t, prot int32, flags int32, fd int32, off Toff_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v start=%v len1=%v prot=%v flags=%v fd=%v off=%v, (%v:)", tls, start, len1, prot, flags, fd, off, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__mmap(tls, start, len1, prot, flags, fd, off)
}

func X__mprotect(tls *TLS, addr uintptr, len1 Tsize_t, prot int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v prot=%v, (%v:)", tls, addr, len1, prot, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var end, start Tsize_t
	_, _ = end, start
	start = uint64(addr) & -X__libc.Fpage_size
	end = uint64(addr+uintptr(len1)+uintptr(X__libc.Fpage_size)-UintptrFromInt32(1)) & -X__libc.Fpage_size
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_mprotect), int64(start), int64(end-start), int64(prot)))))
}

func Xmprotect(tls *TLS, addr uintptr, len1 Tsize_t, prot int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v prot=%v, (%v:)", tls, addr, len1, prot, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__mprotect(tls, addr, len1, prot)
}

func _dummy6(tls *TLS) {
}

func X__mremap(tls *TLS, old_addr uintptr, old_len Tsize_t, new_len Tsize_t, flags int32, va uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v old_addr=%v old_len=%v new_len=%v flags=%v va=%v, (%v:)", tls, old_addr, old_len, new_len, flags, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var new_addr uintptr
	_, _ = ap, new_addr
	new_addr = uintptr(0)
	if new_len >= uint64(Int64FromInt64(INT64_MAX)) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMEM)
		return uintptr(-Int32FromInt32(1))
	}
	if flags&int32(MREMAP_FIXED) != 0 {
		_dummy6(tls)
		ap = va
		new_addr = VaUintptr(&ap)
		_ = ap
	}
	return uintptr(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_mremap), int64(old_addr), int64(old_len), int64(new_len), int64(flags), int64(new_addr)))))
}

func Xmremap(tls *TLS, old_addr uintptr, old_len Tsize_t, new_len Tsize_t, flags int32, va uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v old_addr=%v old_len=%v new_len=%v flags=%v va=%v, (%v:)", tls, old_addr, old_len, new_len, flags, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__mremap(tls, old_addr, old_len, new_len, flags, va)
}

func Xmsync(tls *TLS, start uintptr, len1 Tsize_t, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v start=%v len1=%v flags=%v, (%v:)", tls, start, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_msync), int64(start), int64(len1), int64(flags), 0, 0, 0))))
}

func Xmunlock(tls *TLS, addr uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v, (%v:)", tls, addr, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_munlock), int64(addr), int64(len1)))))
}

func Xmunlockall(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall0(tls, int64(SYS_munlockall)))))
}

func _dummy7(tls *TLS) {
}

func X__munmap(tls *TLS, start uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v start=%v len1=%v, (%v:)", tls, start, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	_dummy7(tls)
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_munmap), int64(start), int64(len1)))))
}

func Xmunmap(tls *TLS, start uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v start=%v len1=%v, (%v:)", tls, start, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__munmap(tls, start, len1)
}

func Xposix_madvise(tls *TLS, addr uintptr, len1 Tsize_t, advice int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v addr=%v len1=%v advice=%v, (%v:)", tls, addr, len1, advice, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if advice == int32(MADV_DONTNEED) {
		return 0
	}
	return int32(-X__syscall3(tls, int64(SYS_madvise), int64(addr), int64(len1), int64(advice)))
}

func X__shm_mapname(tls *TLS, name uintptr, buf uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v buf=%v, (%v:)", tls, name, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p, v1 uintptr
	_, _ = p, v1
	for int32(*(*uint8)(unsafe.Pointer(name))) == int32('/') {
		name++
	}
	v1 = X__strchrnul(tls, name, int32('/'))
	p = v1
	if *(*uint8)(unsafe.Pointer(v1)) != 0 || p == name || int64(p)-int64(name) <= int64(2) && int32(*(*uint8)(unsafe.Pointer(name))) == int32('.') && int32(*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1))))) == int32('.') {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	if int64(p)-int64(name) > int64(NAME_MAX) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENAMETOOLONG)
		return uintptr(0)
	}
	Xmemcpy(tls, buf, __ccgo_ts+961, uint64(9))
	Xmemcpy(tls, buf+uintptr(9), name, uint64(int64(p)-int64(name)+int64(1)))
	return buf
}

func Xshm_open(tls *TLS, name uintptr, flag int32, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v flag=%v mode=%v, (%v:)", tls, name, flag, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(288)
	defer tls.Free(288)
	var fd int32
	var v1 uintptr
	var _ /* buf at bp+4 */ [265]uint8
	var _ /* cs at bp+0 */ int32
	_, _ = fd, v1
	v1 = X__shm_mapname(tls, name, bp+4)
	name = v1
	if !(v1 != 0) {
		return -int32(1)
	}
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	fd = Xopen(tls, name, flag|int32(O_NOFOLLOW)|int32(O_CLOEXEC)|int32(O_NONBLOCK), VaList(bp+280, mode))
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return fd
}

func Xshm_unlink(tls *TLS, name uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(272)
	defer tls.Free(272)
	var v1 uintptr
	var _ /* buf at bp+0 */ [265]uint8
	_ = v1
	v1 = X__shm_mapname(tls, name, bp)
	name = v1
	if !(v1 != 0) {
		return -int32(1)
	}
	return Xunlink(tls, name)
}

const SA = 194
const SB = 244
const bittab = 0

type Tucontext_t4 = struct {
	Fuc_flags    uint64
	Fuc_link     uintptr
	Fuc_stack    Tstack_t
	Fuc_sigmask  Tsigset_t
	Fuc_mcontext Tmcontext_t
}

func Xbtowc(tls *TLS, c int32) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var b, v3 int32
	var v1, v2 uint32
	_, _, _, _ = b, v1, v2, v3
	b = int32(uint8(c))
	if uint32(b) < uint32(128) {
		v1 = uint32(b)
	} else {
		if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
			v3 = int32(4)
		} else {
			v3 = int32(1)
		}
		if v3 == int32(1) && c != -int32(1) {
			v2 = uint32(Int32FromInt32(0xdfff) & int32(int8(c)))
		} else {
			v2 = uint32(0xffffffff)
		}
		v1 = v2
	}
	return v1
}

type Tchar16_t = uint16

type Tchar32_t = uint32

func Xc16rtomb(tls *TLS, s uintptr, c16 Tchar16_t, ps uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v c16=%v ps=%v, (%v:)", tls, s, c16, ps, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var wc Twchar_t
	var x uintptr
	_, _ = wc, x
	if !(ps != 0) {
		ps = uintptr(unsafe.Pointer(&_internal_state))
	}
	x = ps
	if !(s != 0) {
		if *(*uint32)(unsafe.Pointer(x)) != 0 {
			goto ilseq
		}
		return uint64(1)
	}
	if !(*(*uint32)(unsafe.Pointer(x)) != 0) && uint32(c16)-uint32(0xd800) < uint32(0x400) {
		*(*uint32)(unsafe.Pointer(x)) = uint32((int32(c16) - int32(0xd7c0)) << int32(10))
		return uint64(0)
	}
	if *(*uint32)(unsafe.Pointer(x)) != 0 {
		if uint32(c16)-uint32(0xdc00) >= uint32(0x400) {
			goto ilseq
		} else {
			wc = *(*uint32)(unsafe.Pointer(x)) + uint32(c16) - uint32(0xdc00)
		}
		*(*uint32)(unsafe.Pointer(x)) = uint32(0)
	} else {
		wc = uint32(c16)
	}
	return Xwcrtomb(tls, s, wc, uintptr(0))
	goto ilseq
ilseq:
	;
	*(*uint32)(unsafe.Pointer(x)) = uint32(0)
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EILSEQ)
	return uint64(-Int32FromInt32(1))
}

var _internal_state uint32

func Xc32rtomb(tls *TLS, s uintptr, c32 Tchar32_t, ps uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v c32=%v ps=%v, (%v:)", tls, s, c32, ps, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwcrtomb(tls, s, c32, ps)
}

func Xmblen(tls *TLS, s uintptr, n Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v, (%v:)", tls, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xmbtowc(tls, uintptr(0), s, n)
}

func Xmbrlen(tls *TLS, s uintptr, n Tsize_t, st uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v st=%v, (%v:)", tls, s, n, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 uintptr
	_ = v1
	if st != 0 {
		v1 = st
	} else {
		v1 = uintptr(unsafe.Pointer(&_internal))
	}
	return Xmbrtowc(tls, uintptr(0), s, n, v1)
}

var _internal uint32

func Xmbrtoc16(tls *TLS, pc16 uintptr, s uintptr, n Tsize_t, ps uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v pc16=%v s=%v n=%v ps=%v, (%v:)", tls, pc16, s, n, ps, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var pending uintptr
	var ret Tsize_t
	var _ /* wc at bp+0 */ Twchar_t
	_, _ = pending, ret
	if !(ps != 0) {
		ps = uintptr(unsafe.Pointer(&_internal_state1))
	}
	pending = ps
	if !(s != 0) {
		return Xmbrtoc16(tls, uintptr(0), __ccgo_ts, uint64(1), ps)
	}
	/* mbrtowc states for partial UTF-8 characters have the high bit set;
	 * we use nonzero states without high bit for pending surrogates. */
	if int32(*(*uint32)(unsafe.Pointer(pending))) > 0 {
		if pc16 != 0 {
			*(*Tchar16_t)(unsafe.Pointer(pc16)) = uint16(*(*uint32)(unsafe.Pointer(pending)))
		}
		*(*uint32)(unsafe.Pointer(pending)) = uint32(0)
		return uint64(-Int32FromInt32(3))
	}
	ret = Xmbrtowc(tls, bp, s, n, ps)
	if ret <= uint64(4) {
		if *(*Twchar_t)(unsafe.Pointer(bp)) >= uint32(0x10000) {
			*(*uint32)(unsafe.Pointer(pending)) = *(*Twchar_t)(unsafe.Pointer(bp))&uint32(0x3ff) + uint32(0xdc00)
			*(*Twchar_t)(unsafe.Pointer(bp)) = uint32(0xd7c0) + *(*Twchar_t)(unsafe.Pointer(bp))>>Int32FromInt32(10)
		}
		if pc16 != 0 {
			*(*Tchar16_t)(unsafe.Pointer(pc16)) = uint16(*(*Twchar_t)(unsafe.Pointer(bp)))
		}
	}
	return ret
}

var _internal_state1 uint32

func Xmbrtoc32(tls *TLS, pc32 uintptr, s uintptr, n Tsize_t, ps uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v pc32=%v s=%v n=%v ps=%v, (%v:)", tls, pc32, s, n, ps, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ret Tsize_t
	var _ /* wc at bp+0 */ Twchar_t
	_ = ret
	if !(ps != 0) {
		ps = uintptr(unsafe.Pointer(&_internal_state2))
	}
	if !(s != 0) {
		return Xmbrtoc32(tls, uintptr(0), __ccgo_ts, uint64(1), ps)
	}
	ret = Xmbrtowc(tls, bp, s, n, ps)
	if ret <= uint64(4) && pc32 != 0 {
		*(*Tchar32_t)(unsafe.Pointer(pc32)) = *(*Twchar_t)(unsafe.Pointer(bp))
	}
	return ret
}

var _internal_state2 uint32

func Xmbrtowc(tls *TLS, wc uintptr, src uintptr, n Tsize_t, st uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v wc=%v src=%v n=%v st=%v, (%v:)", tls, wc, src, n, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var N Tsize_t
	var c uint32
	var s, v3, v4 uintptr
	var v1 Twchar_t
	var v2 int32
	var _ /* dummy at bp+0 */ Twchar_t
	_, _, _, _, _, _, _ = N, c, s, v1, v2, v3, v4
	s = src
	N = n
	if !(st != 0) {
		st = uintptr(unsafe.Pointer(&_internal_state3))
	}
	c = *(*uint32)(unsafe.Pointer(st))
	if !(s != 0) {
		if c != 0 {
			goto ilseq
		}
		return uint64(0)
	} else {
		if !(wc != 0) {
			wc = bp
		}
	}
	if !(n != 0) {
		return uint64(-Int32FromInt32(2))
	}
	if !(c != 0) {
		if int32(*(*uint8)(unsafe.Pointer(s))) < int32(0x80) {
			v1 = uint32(*(*uint8)(unsafe.Pointer(s)))
			*(*Twchar_t)(unsafe.Pointer(wc)) = v1
			return BoolUint64(!!(v1 != 0))
		}
		if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
			v2 = int32(4)
		} else {
			v2 = int32(1)
		}
		if v2 == int32(1) {
			*(*Twchar_t)(unsafe.Pointer(wc)) = uint32(Int32FromInt32(0xdfff) & int32(int8(*(*uint8)(unsafe.Pointer(s)))))
			return Uint64FromInt32(1)
		}
		if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) > Uint32FromUint32(0xf4)-Uint32FromUint32(0xc2) {
			goto ilseq
		}
		v3 = s
		s++
		c = X__fsmu8[uint32(*(*uint8)(unsafe.Pointer(v3)))-uint32(0xc2)]
		n--
	}
	if n != 0 {
		if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(c)>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
			goto ilseq
		}
		goto loop
	loop:
		;
		v4 = s
		s++
		c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v4)))-int32(0x80))
		n--
		if !(c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
			*(*uint32)(unsafe.Pointer(st)) = uint32(0)
			*(*Twchar_t)(unsafe.Pointer(wc)) = c
			return N - n
		}
		if n != 0 {
			if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
				goto ilseq
			}
			goto loop
		}
	}
	*(*uint32)(unsafe.Pointer(st)) = c
	return uint64(-Int32FromInt32(2))
	goto ilseq
ilseq:
	;
	*(*uint32)(unsafe.Pointer(st)) = uint32(0)
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EILSEQ)
	return uint64(-Int32FromInt32(1))
}

var _internal_state3 uint32

func Xmbsinit(tls *TLS, st uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v st=%v, (%v:)", tls, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(!(st != 0) || !(*(*uint32)(unsafe.Pointer(st)) != 0))
}

func Xmbsnrtowcs(tls *TLS, wcs uintptr, src uintptr, n Tsize_t, wn Tsize_t, st uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v wcs=%v src=%v n=%v wn=%v st=%v, (%v:)", tls, wcs, src, n, wn, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(1040)
	defer tls.Free(1040)
	var cnt, l, n2, v1 Tsize_t
	var tmp_s, ws uintptr
	var v2 bool
	var v3 uint64
	var _ /* s at bp+1024 */ uintptr
	var _ /* wbuf at bp+0 */ [256]Twchar_t
	_, _, _, _, _, _, _, _ = cnt, l, n2, tmp_s, ws, v1, v2, v3
	cnt = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 1024)) = *(*uintptr)(unsafe.Pointer(src))
	if !(wcs != 0) {
		ws = bp
		wn = Uint64FromInt64(1024) / Uint64FromInt64(4)
	} else {
		ws = wcs
	}
	/* making sure output buffer size is at most n/4 will ensure
	 * that mbsrtowcs never reads more than n input bytes. thus
	 * we can use mbsrtowcs as long as it's practical.. */
	for {
		if v2 = *(*uintptr)(unsafe.Pointer(bp + 1024)) != 0 && wn != 0; v2 {
			v1 = n / Uint64FromInt32(4)
			n2 = v1
		}
		if !(v2 && (v1 >= wn || n2 > uint64(32))) {
			break
		}
		if n2 >= wn {
			n2 = wn
		}
		tmp_s = *(*uintptr)(unsafe.Pointer(bp + 1024))
		l = Xmbsrtowcs(tls, ws, bp+1024, n2, st)
		if !(l+Uint64FromInt32(1) != 0) {
			cnt = l
			wn = uint64(0)
			break
		}
		if ws != bp {
			ws += uintptr(l) * 4
			wn -= l
		}
		if *(*uintptr)(unsafe.Pointer(bp + 1024)) != 0 {
			v3 = n - uint64(int64(*(*uintptr)(unsafe.Pointer(bp + 1024)))-int64(tmp_s))
		} else {
			v3 = uint64(0)
		}
		n = v3
		cnt += l
	}
	if *(*uintptr)(unsafe.Pointer(bp + 1024)) != 0 {
		for wn != 0 && n != 0 {
			l = Xmbrtowc(tls, ws, *(*uintptr)(unsafe.Pointer(bp + 1024)), n, st)
			if l+uint64(2) <= uint64(2) {
				if !(l+Uint64FromInt32(1) != 0) {
					cnt = l
					break
				}
				if !(l != 0) {
					*(*uintptr)(unsafe.Pointer(bp + 1024)) = uintptr(0)
					break
				}
				/* have to roll back partial character */
				*(*uint32)(unsafe.Pointer(st)) = uint32(0)
				break
			}
			*(*uintptr)(unsafe.Pointer(bp + 1024)) += uintptr(l)
			n -= l
			/* safe - this loop runs fewer than sizeof(wbuf)/8 times */
			ws += 4
			wn--
			cnt++
		}
	}
	if wcs != 0 {
		*(*uintptr)(unsafe.Pointer(src)) = *(*uintptr)(unsafe.Pointer(bp + 1024))
	}
	return cnt
}

func Xmbsrtowcs(tls *TLS, ws uintptr, src uintptr, wn Tsize_t, st uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v ws=%v src=%v wn=%v st=%v, (%v:)", tls, ws, src, wn, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var c, v1 uint32
	var s, v12, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v5, v6 uintptr
	var wn0 Tsize_t
	var v2 bool
	var v3 int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, s, wn0, v1, v12, v16, v17, v18, v19, v2, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v3, v30, v5, v6
	s = *(*uintptr)(unsafe.Pointer(src))
	wn0 = wn
	c = uint32(0)
	if v2 = st != 0; v2 {
		v1 = *(*uint32)(unsafe.Pointer(st))
		c = v1
	}
	if v2 && v1 != 0 {
		if ws != 0 {
			*(*uint32)(unsafe.Pointer(st)) = uint32(0)
			goto resume
		} else {
			goto resume0
		}
	}
	if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
		v3 = int32(4)
	} else {
		v3 = int32(1)
	}
	if v3 == int32(1) {
		if !(ws != 0) {
			return Xstrlen(tls, s)
		}
		for {
			if !(wn != 0) {
				*(*uintptr)(unsafe.Pointer(src)) = s
				return wn0
			}
			if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
				break
			}
			v5 = s
			s++
			c = uint32(*(*uint8)(unsafe.Pointer(v5)))
			v6 = ws
			ws += 4
			*(*Twchar_t)(unsafe.Pointer(v6)) = uint32(Int32FromInt32(0xdfff) & int32(int8(c)))
			wn--
			goto _4
		_4:
		}
		*(*Twchar_t)(unsafe.Pointer(ws)) = uint32(0)
		*(*uintptr)(unsafe.Pointer(src)) = uintptr(0)
		return wn0 - wn
	}
	if !!(ws != 0) {
		goto _7
	}
_11:
	;
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(1) < uint32(0x7f) && uint64(s)%uint64(4) == uint64(0) {
		for !((*(*uint32)(unsafe.Pointer(s))|(*(*uint32)(unsafe.Pointer(s))-Uint32FromInt32(0x01010101)))&Uint32FromUint32(0x80808080) != 0) {
			s += uintptr(4)
			wn -= uint64(4)
		}
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(1) < uint32(0x7f) {
		s++
		wn--
		goto _10
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) > Uint32FromUint32(0xf4)-Uint32FromUint32(0xc2) {
		goto _9
	}
	v12 = s
	s++
	c = X__fsmu8[uint32(*(*uint8)(unsafe.Pointer(v12)))-uint32(0xc2)]
	goto resume0
resume0:
	;
	if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(c)>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
		s--
		goto _9
	}
	s++
	if c&(Uint32FromUint32(1)<<Int32FromInt32(25)) != 0 {
		if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
			s -= uintptr(2)
			goto _9
		}
		s++
		if c&(Uint32FromUint32(1)<<Int32FromInt32(19)) != 0 {
			if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
				s -= uintptr(3)
				goto _9
			}
			s++
		}
	}
	wn--
	c = uint32(0)
	goto _10
_10:
	;
	goto _11
	goto _9
_9:
	;
	goto _8
_7:
	;
_15:
	;
	if !(wn != 0) {
		*(*uintptr)(unsafe.Pointer(src)) = s
		return wn0
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(1) < uint32(0x7f) && uint64(s)%uint64(4) == uint64(0) {
		for wn >= uint64(5) && !((*(*uint32)(unsafe.Pointer(s))|(*(*uint32)(unsafe.Pointer(s))-Uint32FromInt32(0x01010101)))&Uint32FromUint32(0x80808080) != 0) {
			v16 = ws
			ws += 4
			v17 = s
			s++
			*(*Twchar_t)(unsafe.Pointer(v16)) = uint32(*(*uint8)(unsafe.Pointer(v17)))
			v18 = ws
			ws += 4
			v19 = s
			s++
			*(*Twchar_t)(unsafe.Pointer(v18)) = uint32(*(*uint8)(unsafe.Pointer(v19)))
			v20 = ws
			ws += 4
			v21 = s
			s++
			*(*Twchar_t)(unsafe.Pointer(v20)) = uint32(*(*uint8)(unsafe.Pointer(v21)))
			v22 = ws
			ws += 4
			v23 = s
			s++
			*(*Twchar_t)(unsafe.Pointer(v22)) = uint32(*(*uint8)(unsafe.Pointer(v23)))
			wn -= uint64(4)
		}
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(1) < uint32(0x7f) {
		v24 = ws
		ws += 4
		v25 = s
		s++
		*(*Twchar_t)(unsafe.Pointer(v24)) = uint32(*(*uint8)(unsafe.Pointer(v25)))
		wn--
		goto _14
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) > Uint32FromUint32(0xf4)-Uint32FromUint32(0xc2) {
		goto _13
	}
	v26 = s
	s++
	c = X__fsmu8[uint32(*(*uint8)(unsafe.Pointer(v26)))-uint32(0xc2)]
	goto resume
resume:
	;
	if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(c)>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
		s--
		goto _13
	}
	v27 = s
	s++
	c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v27)))-int32(0x80))
	if c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0 {
		if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
			s -= uintptr(2)
			goto _13
		}
		v28 = s
		s++
		c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v28)))-int32(0x80))
		if c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0 {
			if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
				s -= uintptr(3)
				goto _13
			}
			v29 = s
			s++
			c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v29)))-int32(0x80))
		}
	}
	v30 = ws
	ws += 4
	*(*Twchar_t)(unsafe.Pointer(v30)) = c
	wn--
	c = uint32(0)
	goto _14
_14:
	;
	goto _15
	goto _13
_13:
	;
_8:
	;
	if !(c != 0) && !(*(*uint8)(unsafe.Pointer(s)) != 0) {
		if ws != 0 {
			*(*Twchar_t)(unsafe.Pointer(ws)) = uint32(0)
			*(*uintptr)(unsafe.Pointer(src)) = uintptr(0)
		}
		return wn0 - wn
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EILSEQ)
	if ws != 0 {
		*(*uintptr)(unsafe.Pointer(src)) = s
	}
	return uint64(-Int32FromInt32(1))
}

func Xmbstowcs(tls *TLS, ws uintptr, _s uintptr, wn Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v ws=%v _s=%v wn=%v, (%v:)", tls, ws, _s, wn, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = _s
	return Xmbsrtowcs(tls, ws, bp, wn, uintptr(0))
}

func Xmbtowc(tls *TLS, wc uintptr, src uintptr, n Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v wc=%v src=%v n=%v, (%v:)", tls, wc, src, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c uint32
	var s, v3, v4, v5, v6 uintptr
	var v1 Twchar_t
	var v2 int32
	var _ /* dummy at bp+0 */ Twchar_t
	_, _, _, _, _, _, _, _ = c, s, v1, v2, v3, v4, v5, v6
	s = src
	if !(s != 0) {
		return 0
	}
	if !(n != 0) {
		goto ilseq
	}
	if !(wc != 0) {
		wc = bp
	}
	if int32(*(*uint8)(unsafe.Pointer(s))) < int32(0x80) {
		v1 = uint32(*(*uint8)(unsafe.Pointer(s)))
		*(*Twchar_t)(unsafe.Pointer(wc)) = v1
		return BoolInt32(!!(v1 != 0))
	}
	if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
		v2 = int32(4)
	} else {
		v2 = int32(1)
	}
	if v2 == int32(1) {
		*(*Twchar_t)(unsafe.Pointer(wc)) = uint32(Int32FromInt32(0xdfff) & int32(int8(*(*uint8)(unsafe.Pointer(s)))))
		return Int32FromInt32(1)
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0xc2) > Uint32FromUint32(0xf4)-Uint32FromUint32(0xc2) {
		goto ilseq
	}
	v3 = s
	s++
	c = X__fsmu8[uint32(*(*uint8)(unsafe.Pointer(v3)))-uint32(0xc2)]
	/* Avoid excessive checks against n: If shifting the state n-1
	 * times does not clear the high bit, then the value of n is
	 * insufficient to read a character */
	if n < uint64(4) && c<<(uint64(6)*n-uint64(6))&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0 {
		goto ilseq
	}
	if (int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)-int32(0x10)|(int32(*(*uint8)(unsafe.Pointer(s)))>>int32(3)+int32(c)>>Int32FromInt32(26))) & ^Int32FromInt32(7) != 0 {
		goto ilseq
	}
	v4 = s
	s++
	c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v4)))-int32(0x80))
	if !(c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
		*(*Twchar_t)(unsafe.Pointer(wc)) = c
		return int32(2)
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
		goto ilseq
	}
	v5 = s
	s++
	c = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v5)))-int32(0x80))
	if !(c&(Uint32FromUint32(1)<<Int32FromInt32(31)) != 0) {
		*(*Twchar_t)(unsafe.Pointer(wc)) = c
		return int32(3)
	}
	if uint32(*(*uint8)(unsafe.Pointer(s)))-uint32(0x80) >= uint32(0x40) {
		goto ilseq
	}
	v6 = s
	s++
	*(*Twchar_t)(unsafe.Pointer(wc)) = c<<int32(6) | uint32(int32(*(*uint8)(unsafe.Pointer(v6)))-int32(0x80))
	return int32(4)
	goto ilseq
ilseq:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EILSEQ)
	return -int32(1)
}

func Xwcrtomb(tls *TLS, s uintptr, wc Twchar_t, st uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v wc=%v st=%v, (%v:)", tls, s, wc, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	var v2, v3, v4, v5, v6, v7 uintptr
	_, _, _, _, _, _, _ = v1, v2, v3, v4, v5, v6, v7
	if !(s != 0) {
		return uint64(1)
	}
	if wc < uint32(0x80) {
		*(*uint8)(unsafe.Pointer(s)) = uint8(wc)
		return uint64(1)
	} else {
		if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
			v1 = int32(4)
		} else {
			v1 = int32(1)
		}
		if v1 == int32(1) {
			if !(wc-Uint32FromInt32(0xdf80) < Uint32FromInt32(0x80)) {
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EILSEQ)
				return uint64(-Int32FromInt32(1))
			}
			*(*uint8)(unsafe.Pointer(s)) = uint8(wc)
			return uint64(1)
		} else {
			if wc < uint32(0x800) {
				v2 = s
				s++
				*(*uint8)(unsafe.Pointer(v2)) = uint8(uint32(0xc0) | wc>>Int32FromInt32(6))
				*(*uint8)(unsafe.Pointer(s)) = uint8(uint32(0x80) | wc&uint32(0x3f))
				return uint64(2)
			} else {
				if wc < uint32(0xd800) || wc-uint32(0xe000) < uint32(0x2000) {
					v3 = s
					s++
					*(*uint8)(unsafe.Pointer(v3)) = uint8(uint32(0xe0) | wc>>Int32FromInt32(12))
					v4 = s
					s++
					*(*uint8)(unsafe.Pointer(v4)) = uint8(uint32(0x80) | wc>>Int32FromInt32(6)&uint32(0x3f))
					*(*uint8)(unsafe.Pointer(s)) = uint8(uint32(0x80) | wc&uint32(0x3f))
					return uint64(3)
				} else {
					if wc-uint32(0x10000) < uint32(0x100000) {
						v5 = s
						s++
						*(*uint8)(unsafe.Pointer(v5)) = uint8(uint32(0xf0) | wc>>Int32FromInt32(18))
						v6 = s
						s++
						*(*uint8)(unsafe.Pointer(v6)) = uint8(uint32(0x80) | wc>>Int32FromInt32(12)&uint32(0x3f))
						v7 = s
						s++
						*(*uint8)(unsafe.Pointer(v7)) = uint8(uint32(0x80) | wc>>Int32FromInt32(6)&uint32(0x3f))
						*(*uint8)(unsafe.Pointer(s)) = uint8(uint32(0x80) | wc&uint32(0x3f))
						return uint64(4)
					}
				}
			}
		}
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EILSEQ)
	return uint64(-Int32FromInt32(1))
}

func Xwcsnrtombs(tls *TLS, dst uintptr, wcs uintptr, wn Tsize_t, n Tsize_t, st uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v dst=%v wcs=%v wn=%v n=%v st=%v, (%v:)", tls, dst, wcs, wn, n, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var cnt, l Tsize_t
	var ws, v1 uintptr
	var _ /* tmp at bp+0 */ [4]uint8
	_, _, _, _ = cnt, l, ws, v1
	ws = *(*uintptr)(unsafe.Pointer(wcs))
	cnt = uint64(0)
	if !(dst != 0) {
		n = uint64(0)
	}
	for ws != 0 && wn != 0 {
		if n < uint64(MB_LEN_MAX) {
			v1 = bp
		} else {
			v1 = dst
		}
		l = Xwcrtomb(tls, v1, *(*Twchar_t)(unsafe.Pointer(ws)), uintptr(0))
		if l == uint64(-Int32FromInt32(1)) {
			cnt = uint64(-Int32FromInt32(1))
			break
		}
		if dst != 0 {
			if n < uint64(MB_LEN_MAX) {
				if l > n {
					break
				}
				Xmemcpy(tls, dst, bp, l)
			}
			dst += uintptr(l)
			n -= l
		}
		if !(*(*Twchar_t)(unsafe.Pointer(ws)) != 0) {
			ws = uintptr(0)
			break
		}
		ws += 4
		wn--
		cnt += l
	}
	if dst != 0 {
		*(*uintptr)(unsafe.Pointer(wcs)) = ws
	}
	return cnt
}

func Xwcsrtombs(tls *TLS, s uintptr, ws uintptr, n Tsize_t, st uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v ws=%v n=%v st=%v, (%v:)", tls, s, ws, n, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var N, l Tsize_t
	var ws2, v2, v3 uintptr
	var _ /* buf at bp+0 */ [4]uint8
	_, _, _, _, _ = N, l, ws2, v2, v3
	N = n
	if !(s != 0) {
		n = uint64(0)
		ws2 = *(*uintptr)(unsafe.Pointer(ws))
		for {
			if !(*(*Twchar_t)(unsafe.Pointer(ws2)) != 0) {
				break
			}
			if *(*Twchar_t)(unsafe.Pointer(ws2)) >= uint32(0x80) {
				l = Xwcrtomb(tls, bp, *(*Twchar_t)(unsafe.Pointer(ws2)), uintptr(0))
				if !(l+Uint64FromInt32(1) != 0) {
					return uint64(-Int32FromInt32(1))
				}
				n += l
			} else {
				n++
			}
			goto _1
		_1:
			;
			ws2 += 4
		}
		return n
	}
	for n >= uint64(4) {
		if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws))))-uint32(1) >= uint32(0x7f) {
			if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))) != 0) {
				*(*uint8)(unsafe.Pointer(s)) = uint8(0)
				*(*uintptr)(unsafe.Pointer(ws)) = uintptr(0)
				return N - n
			}
			l = Xwcrtomb(tls, s, *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			if !(l+Uint64FromInt32(1) != 0) {
				return uint64(-Int32FromInt32(1))
			}
			s += uintptr(l)
			n -= l
		} else {
			v2 = s
			s++
			*(*uint8)(unsafe.Pointer(v2)) = uint8(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))))
			n--
		}
		*(*uintptr)(unsafe.Pointer(ws)) += 4
	}
	for n != 0 {
		if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws))))-uint32(1) >= uint32(0x7f) {
			if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))) != 0) {
				*(*uint8)(unsafe.Pointer(s)) = uint8(0)
				*(*uintptr)(unsafe.Pointer(ws)) = uintptr(0)
				return N - n
			}
			l = Xwcrtomb(tls, bp, *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			if !(l+Uint64FromInt32(1) != 0) {
				return uint64(-Int32FromInt32(1))
			}
			if l > n {
				return N - n
			}
			Xwcrtomb(tls, s, *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))), uintptr(0))
			s += uintptr(l)
			n -= l
		} else {
			v3 = s
			s++
			*(*uint8)(unsafe.Pointer(v3)) = uint8(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ws)))))
			n--
		}
		*(*uintptr)(unsafe.Pointer(ws)) += 4
	}
	return N
}

func Xwcstombs(tls *TLS, s uintptr, ws uintptr, n Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v ws=%v n=%v, (%v:)", tls, s, ws, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = ws
	return Xwcsrtombs(tls, s, bp, n, uintptr(0))
}

func Xwctob(tls *TLS, c Twint_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	_ = v1
	if c < uint32(128) {
		return int32(c)
	}
	if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
		v1 = int32(4)
	} else {
		v1 = int32(1)
	}
	if v1 == int32(1) && c-uint32(0xdf80) < uint32(0x80) {
		return int32(uint8(c))
	}
	return -int32(1)
}

func Xwctomb(tls *TLS, s uintptr, wc Twchar_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v wc=%v, (%v:)", tls, s, wc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if !(s != 0) {
		return 0
	}
	return int32(Xwcrtomb(tls, s, wc, uintptr(0)))
}

func Xaccept(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v addr=%v len1=%v, (%v:)", tls, fd, addr, len1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_accept)
	_ = int32(__SC_accept)
	v2 = int64(fd)
	v3 = int64(addr)
	v4 = int64(len1)
	v5 = int64(Int32FromInt32(0))
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if int32(1) != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return int32(X__syscall_ret(tls, uint64(v8)))
}

type Tucred = struct {
	Fpid Tpid_t
	Fuid Tuid_t
	Fgid Tgid_t
}

type Tmmsghdr = struct {
	Fmsg_hdr Tmsghdr
	Fmsg_len uint32
}

func Xaccept4(tls *TLS, fd int32, addr uintptr, len1 uintptr, flg int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v addr=%v len1=%v flg=%v, (%v:)", tls, fd, addr, len1, flg, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var ret, v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _, _ = r, ret, v1, v2, v3, v4, v5, v6, v7, v8
	if !(flg != 0) {
		return Xaccept(tls, fd, addr, len1)
	}
	v1 = int32(SYS_accept4)
	_ = int32(__SC_accept4)
	v2 = int64(fd)
	v3 = int64(addr)
	v4 = int64(len1)
	v5 = int64(flg)
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if int32(1) != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	ret = int32(X__syscall_ret(tls, uint64(v8)))
	if ret >= 0 || *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(ENOSYS) && *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(EINVAL) {
		return ret
	}
	if flg & ^(Int32FromInt32(SOCK_CLOEXEC)|Int32FromInt32(SOCK_NONBLOCK)) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	ret = Xaccept(tls, fd, addr, len1)
	if ret < 0 {
		return ret
	}
	if flg&int32(SOCK_CLOEXEC) != 0 {
		X__syscall3(tls, int64(SYS_fcntl), int64(ret), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
	}
	if flg&int32(SOCK_NONBLOCK) != 0 {
		X__syscall3(tls, int64(SYS_fcntl), int64(ret), int64(Int32FromInt32(F_SETFL)), int64(Int32FromInt32(O_NONBLOCK)))
	}
	return ret
}

func Xbind(tls *TLS, fd int32, addr uintptr, len1 Tsocklen_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v addr=%v len1=%v, (%v:)", tls, fd, addr, len1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_bind)
	_ = int32(__SC_bind)
	v2 = int64(fd)
	v3 = int64(addr)
	v4 = int64(len1)
	v5 = int64(Int32FromInt32(0))
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return int32(X__syscall_ret(tls, uint64(v8)))
}

func Xconnect(tls *TLS, fd int32, addr uintptr, len1 Tsocklen_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v addr=%v len1=%v, (%v:)", tls, fd, addr, len1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_connect)
	_ = int32(__SC_connect)
	v2 = int64(fd)
	v3 = int64(addr)
	v4 = int64(len1)
	v5 = int64(Int32FromInt32(0))
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if int32(1) != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return int32(X__syscall_ret(tls, uint64(v8)))
}

const ADD = 0
const C_ANY = 0
const C_CHAOS = 0
const C_HS = 0
const C_IN = 0
const C_NONE = 0
const DELETE = 0
const FORMERR = 0
const GETLONG = 0
const GETSHORT = 0
const HFIXEDSZ = 12
const IN6ADDRSZ = 16
const INADDRSZ = 4
const INDIR_MASK = 192
const INET6_ADDRSTRLEN = 46
const INET_ADDRSTRLEN = 16
const INT16SZ = 2
const INT32SZ = 4
const INT8SZ = 1
const IN_CLASSA_HOST = 16777215
const IN_CLASSA_MAX = 128
const IN_CLASSA_NET = 4278190080
const IN_CLASSA_NSHIFT = 24
const IN_CLASSB_HOST = 65535
const IN_CLASSB_MAX = 65536
const IN_CLASSB_NET = 4294901760
const IN_CLASSB_NSHIFT = 16
const IN_CLASSC_HOST = 255
const IN_CLASSC_NET = 4294967040
const IN_CLASSC_NSHIFT = 8
const IN_LOOPBACKNET = 127
const IPPORT_RESERVED = 1024
const IPPROTO_AH = 51
const IPPROTO_BEETPH = 94
const IPPROTO_COMP = 108
const IPPROTO_DCCP = 33
const IPPROTO_DSTOPTS = 60
const IPPROTO_EGP = 8
const IPPROTO_ENCAP = 98
const IPPROTO_ESP = 50
const IPPROTO_ETHERNET = 143
const IPPROTO_FRAGMENT = 44
const IPPROTO_GRE = 47
const IPPROTO_HOPOPTS = 0
const IPPROTO_ICMP = 1
const IPPROTO_ICMPV6 = 58
const IPPROTO_IDP = 22
const IPPROTO_IGMP = 2
const IPPROTO_IP = 0
const IPPROTO_IPIP = 4
const IPPROTO_IPV6 = 41
const IPPROTO_MAX = 263
const IPPROTO_MH = 135
const IPPROTO_MPLS = 137
const IPPROTO_MPTCP = 262
const IPPROTO_MTP = 92
const IPPROTO_NONE = 59
const IPPROTO_PIM = 103
const IPPROTO_PUP = 12
const IPPROTO_RAW = 255
const IPPROTO_ROUTING = 43
const IPPROTO_RSVP = 46
const IPPROTO_SCTP = 132
const IPPROTO_TCP = 6
const IPPROTO_TP = 29
const IPPROTO_UDP = 17
const IPPROTO_UDPLITE = 136
const IPV6_2292DSTOPTS = 4
const IPV6_2292HOPLIMIT = 8
const IPV6_2292HOPOPTS = 3
const IPV6_2292PKTINFO = 2
const IPV6_2292PKTOPTIONS = 6
const IPV6_2292RTHDR = 5
const IPV6_ADDRFORM = 1
const IPV6_ADDR_PREFERENCES = 72
const IPV6_ADD_MEMBERSHIP = 20
const IPV6_AUTHHDR = 10
const IPV6_AUTOFLOWLABEL = 70
const IPV6_CHECKSUM = 7
const IPV6_DONTFRAG = 62
const IPV6_DROP_MEMBERSHIP = 21
const IPV6_DSTOPTS = 59
const IPV6_FREEBIND = 78
const IPV6_HDRINCL = 36
const IPV6_HOPLIMIT = 52
const IPV6_HOPOPTS = 54
const IPV6_IPSEC_POLICY = 34
const IPV6_JOIN_ANYCAST = 27
const IPV6_JOIN_GROUP = 20
const IPV6_LEAVE_ANYCAST = 28
const IPV6_LEAVE_GROUP = 21
const IPV6_MINHOPCOUNT = 73
const IPV6_MTU = 24
const IPV6_MTU_DISCOVER = 23
const IPV6_MULTICAST_ALL = 29
const IPV6_MULTICAST_HOPS = 18
const IPV6_MULTICAST_IF = 17
const IPV6_MULTICAST_LOOP = 19
const IPV6_NEXTHOP = 9
const IPV6_ORIGDSTADDR = 74
const IPV6_PATHMTU = 61
const IPV6_PKTINFO = 50
const IPV6_PMTUDISC_DO = 2
const IPV6_PMTUDISC_DONT = 0
const IPV6_PMTUDISC_INTERFACE = 4
const IPV6_PMTUDISC_OMIT = 5
const IPV6_PMTUDISC_PROBE = 3
const IPV6_PMTUDISC_WANT = 1
const IPV6_PREFER_SRC_CGA = 8
const IPV6_PREFER_SRC_COA = 4
const IPV6_PREFER_SRC_HOME = 1024
const IPV6_PREFER_SRC_NONCGA = 2048
const IPV6_PREFER_SRC_PUBLIC = 2
const IPV6_PREFER_SRC_PUBTMP_DEFAULT = 256
const IPV6_PREFER_SRC_TMP = 1
const IPV6_RECVDSTOPTS = 58
const IPV6_RECVERR = 25
const IPV6_RECVFRAGSIZE = 77
const IPV6_RECVHOPLIMIT = 51
const IPV6_RECVHOPOPTS = 53
const IPV6_RECVORIGDSTADDR = 74
const IPV6_RECVPATHMTU = 60
const IPV6_RECVPKTINFO = 49
const IPV6_RECVRTHDR = 56
const IPV6_RECVTCLASS = 66
const IPV6_ROUTER_ALERT = 22
const IPV6_ROUTER_ALERT_ISOLATE = 30
const IPV6_RTHDR = 57
const IPV6_RTHDRDSTOPTS = 55
const IPV6_RTHDR_LOOSE = 0
const IPV6_RTHDR_STRICT = 1
const IPV6_RTHDR_TYPE_0 = 0
const IPV6_RXDSTOPTS = 59
const IPV6_RXHOPOPTS = 54
const IPV6_TCLASS = 67
const IPV6_TRANSPARENT = 75
const IPV6_UNICAST_HOPS = 16
const IPV6_UNICAST_IF = 76
const IPV6_V6ONLY = 26
const IPV6_XFRM_POLICY = 35
const IP_ADD_MEMBERSHIP = 35
const IP_ADD_SOURCE_MEMBERSHIP = 39
const IP_BIND_ADDRESS_NO_PORT = 24
const IP_BLOCK_SOURCE = 38
const IP_CHECKSUM = 23
const IP_DEFAULT_MULTICAST_LOOP = 1
const IP_DEFAULT_MULTICAST_TTL = 1
const IP_DROP_MEMBERSHIP = 36
const IP_DROP_SOURCE_MEMBERSHIP = 40
const IP_FREEBIND = 15
const IP_HDRINCL = 3
const IP_IPSEC_POLICY = 16
const IP_MAX_MEMBERSHIPS = 20
const IP_MINTTL = 21
const IP_MSFILTER = 41
const IP_MTU = 14
const IP_MTU_DISCOVER = 10
const IP_MULTICAST_ALL = 49
const IP_MULTICAST_IF = 32
const IP_MULTICAST_LOOP = 34
const IP_MULTICAST_TTL = 33
const IP_NODEFRAG = 22
const IP_OPTIONS = 4
const IP_ORIGDSTADDR = 20
const IP_PASSSEC = 18
const IP_PKTINFO = 8
const IP_PKTOPTIONS = 9
const IP_PMTUDISC = 10
const IP_PMTUDISC_DO = 2
const IP_PMTUDISC_DONT = 0
const IP_PMTUDISC_INTERFACE = 4
const IP_PMTUDISC_OMIT = 5
const IP_PMTUDISC_PROBE = 3
const IP_PMTUDISC_WANT = 1
const IP_RECVERR = 11
const IP_RECVERR_RFC4884 = 26
const IP_RECVFRAGSIZE = 25
const IP_RECVOPTS = 6
const IP_RECVORIGDSTADDR = 20
const IP_RECVRETOPTS = 7
const IP_RECVTOS = 13
const IP_RECVTTL = 12
const IP_RETOPTS = 7
const IP_ROUTER_ALERT = 5
const IP_TOS = 1
const IP_TRANSPARENT = 19
const IP_TTL = 2
const IP_UNBLOCK_SOURCE = 37
const IP_UNICAST_IF = 50
const IP_XFRM_POLICY = 17
const IQUERY = 0
const LOCALDOMAINPARTS = 2
const MAXCDNAME = 255
const MAXDFLSRCH = 3
const MAXDNAME = 1025
const MAXDNSRCH = 6
const MAXLABEL = 63
const MAXNS = 3
const MAXRESOLVSORT = 10
const NAMESERVER_PORT = 53
const NOERROR = 0
const NOTAUTH = 0
const NOTIMP = 0
const NOTZONE = 0
const NS_ALG_DH = 2
const NS_ALG_DSA = 3
const NS_ALG_DSS = 3
const NS_ALG_EXPIRE_ONLY = 253
const NS_ALG_MD5RSA = 1
const NS_ALG_PRIVATE_OID = 254
const NS_CMPRSFLGS = 192
const NS_DEFAULTPORT = 53
const NS_DSA_MAX_BYTES = 405
const NS_DSA_MIN_SIZE = 213
const NS_DSA_SIG_SIZE = 41
const NS_HFIXEDSZ = 12
const NS_IN6ADDRSZ = 16
const NS_INADDRSZ = 4
const NS_INT16SZ = 2
const NS_INT32SZ = 4
const NS_INT8SZ = 1
const NS_KEY_EXTENDED_FLAGS = 4096
const NS_KEY_NAME_ENTITY = 512
const NS_KEY_NAME_RESERVED = 768
const NS_KEY_NAME_TYPE = 768
const NS_KEY_NAME_USER = 0
const NS_KEY_NAME_ZONE = 256
const NS_KEY_NO_AUTH = 32768
const NS_KEY_NO_CONF = 16384
const NS_KEY_PROT_ANY = 255
const NS_KEY_PROT_DNSSEC = 3
const NS_KEY_PROT_EMAIL = 2
const NS_KEY_PROT_IPSEC = 4
const NS_KEY_PROT_TLS = 1
const NS_KEY_RESERVED10 = 32
const NS_KEY_RESERVED11 = 16
const NS_KEY_RESERVED2 = 8192
const NS_KEY_RESERVED4 = 2048
const NS_KEY_RESERVED5 = 1024
const NS_KEY_RESERVED8 = 128
const NS_KEY_RESERVED9 = 64
const NS_KEY_RESERVED_BITMASK = 11504
const NS_KEY_RESERVED_BITMASK2 = 65535
const NS_KEY_SIGNATORYMASK = 15
const NS_KEY_TYPEMASK = 49152
const NS_KEY_TYPE_AUTH_CONF = 0
const NS_KEY_TYPE_AUTH_ONLY = 16384
const NS_KEY_TYPE_CONF_ONLY = 32768
const NS_KEY_TYPE_NO_KEY = 49152
const NS_MAXCDNAME = 255
const NS_MAXDNAME = 1025
const NS_MAXLABEL = 63
const NS_MAXMSG = 65535
const NS_MD5RSA_MAX_BASE64 = 10928
const NS_MD5RSA_MAX_BITS = 4096
const NS_MD5RSA_MAX_BYTES = 8195
const NS_MD5RSA_MAX_SIZE = 512
const NS_MD5RSA_MIN_BITS = 512
const NS_MD5RSA_MIN_SIZE = 64
const NS_NOTIFY_OP = 0
const NS_NXT_BITS = 8
const NS_NXT_MAX = 127
const NS_OPT_DNSSEC_OK = 32768
const NS_OPT_NSID = 3
const NS_PACKETSZ = 512
const NS_QFIXEDSZ = 4
const NS_RRFIXEDSZ = 10
const NS_SIG_ALG = 2
const NS_SIG_EXPIR = 8
const NS_SIG_FOOT = 16
const NS_SIG_LABELS = 3
const NS_SIG_OTTL = 4
const NS_SIG_SIGNED = 12
const NS_SIG_SIGNER = 18
const NS_SIG_TYPE = 0
const NS_TSIG_ALG_HMAC_MD5 = "HMAC-MD5.SIG-ALG.REG.INT"
const NS_TSIG_ERROR_FORMERR = -12
const NS_TSIG_ERROR_NO_SPACE = -11
const NS_TSIG_ERROR_NO_TSIG = -10
const NS_TSIG_FUDGE = 300
const NS_TSIG_TCP_COUNT = 100
const NS_UPDATE_OP = 0
const NXDOMAIN = 0
const NXRRSET = 0
const PACKETSZ = 512
const PRIX16 = "X"
const PRIX32 = "X"
const PRIX8 = "X"
const PRIXFAST16 = "X"
const PRIXFAST32 = "X"
const PRIXFAST8 = "X"
const PRIXLEAST16 = "X"
const PRIXLEAST32 = "X"
const PRIXLEAST8 = "X"
const PRId16 = "d"
const PRId32 = "d"
const PRId8 = "d"
const PRIdFAST16 = "d"
const PRIdFAST32 = "d"
const PRIdFAST8 = "d"
const PRIdLEAST16 = "d"
const PRIdLEAST32 = "d"
const PRIdLEAST8 = "d"
const PRIi16 = "i"
const PRIi32 = "i"
const PRIi8 = "i"
const PRIiFAST16 = "i"
const PRIiFAST32 = "i"
const PRIiFAST8 = "i"
const PRIiLEAST16 = "i"
const PRIiLEAST32 = "i"
const PRIiLEAST8 = "i"
const PRIo16 = "o"
const PRIo32 = "o"
const PRIo8 = "o"
const PRIoFAST16 = "o"
const PRIoFAST32 = "o"
const PRIoFAST8 = "o"
const PRIoLEAST16 = "o"
const PRIoLEAST32 = "o"
const PRIoLEAST8 = "o"
const PRIu16 = "u"
const PRIu32 = "u"
const PRIu8 = "u"
const PRIuFAST16 = "u"
const PRIuFAST32 = "u"
const PRIuFAST8 = "u"
const PRIuLEAST16 = "u"
const PRIuLEAST32 = "u"
const PRIuLEAST8 = "u"
const PRIx16 = "x"
const PRIx32 = "x"
const PRIx8 = "x"
const PRIxFAST16 = "x"
const PRIxFAST32 = "x"
const PRIxFAST8 = "x"
const PRIxLEAST16 = "x"
const PRIxLEAST32 = "x"
const PRIxLEAST8 = "x"
const PUTLONG = 0
const PUTSHORT = 0
const QFIXEDSZ = 4
const QUERY = 0
const REFUSED = 0
const RES_AAONLY = 4
const RES_BLAST = 131072
const RES_DEBUG = 2
const RES_DEFAULT = 524992
const RES_DEFNAMES = 128
const RES_DFLRETRY = 2
const RES_DNSRCH = 512
const RES_EXHAUSTIVE = 1
const RES_F_CONN = 2
const RES_F_EDNS0ERR = 4
const RES_F_VC = 1
const RES_IGNTC = 32
const RES_INIT = 1
const RES_INSECURE1 = 1024
const RES_INSECURE2 = 2048
const RES_KEEPTSIG = 65536
const RES_MAXNDOTS = 15
const RES_MAXRETRANS = 30
const RES_MAXRETRY = 5
const RES_MAXTIME = 65535
const RES_NOALIASES = 4096
const RES_NOCHECKNAME = 32768
const RES_NOIP6DOTINT = 524288
const RES_PRF_ADD = 128
const RES_PRF_ANS = 32
const RES_PRF_AUTH = 64
const RES_PRF_CLASS = 4
const RES_PRF_CMD = 8
const RES_PRF_HEAD1 = 256
const RES_PRF_HEAD2 = 512
const RES_PRF_HEADX = 2048
const RES_PRF_INIT = 16384
const RES_PRF_QUERY = 4096
const RES_PRF_QUES = 16
const RES_PRF_REPLY = 8192
const RES_PRF_STATS = 1
const RES_PRF_TTLID = 1024
const RES_PRF_UPDATE = 2
const RES_PRIMARY = 16
const RES_RECURSE = 64
const RES_ROTATE = 16384
const RES_SNGLKUP = 2097152
const RES_SNGLKUPREOP = 4194304
const RES_STAYOPEN = 256
const RES_TIMEOUT = 5
const RES_USEBSTRING = 262144
const RES_USEVC = 8
const RES_USE_DNSSEC = 8388608
const RES_USE_EDNS0 = 1048576
const RES_USE_INET6 = 8192
const RRFIXEDSZ = 10
const SCNd16 = "hd"
const SCNd32 = "d"
const SCNd8 = "hhd"
const SCNdFAST16 = "d"
const SCNdFAST32 = "d"
const SCNdFAST8 = "hhd"
const SCNdLEAST16 = "hd"
const SCNdLEAST32 = "d"
const SCNdLEAST8 = "hhd"
const SCNi16 = "hi"
const SCNi32 = "i"
const SCNi8 = "hhi"
const SCNiFAST16 = "i"
const SCNiFAST32 = "i"
const SCNiFAST8 = "hhi"
const SCNiLEAST16 = "hi"
const SCNiLEAST32 = "i"
const SCNiLEAST8 = "hhi"
const SCNo16 = "ho"
const SCNo32 = "o"
const SCNo8 = "hho"
const SCNoFAST16 = "o"
const SCNoFAST32 = "o"
const SCNoFAST8 = "hho"
const SCNoLEAST16 = "ho"
const SCNoLEAST32 = "o"
const SCNoLEAST8 = "hho"
const SCNu16 = "hu"
const SCNu32 = "u"
const SCNu8 = "hhu"
const SCNuFAST16 = "u"
const SCNuFAST32 = "u"
const SCNuFAST8 = "hhu"
const SCNuLEAST16 = "hu"
const SCNuLEAST32 = "u"
const SCNuLEAST8 = "hhu"
const SCNx16 = "hx"
const SCNx32 = "x"
const SCNx8 = "hhx"
const SCNxFAST16 = "x"
const SCNxFAST32 = "x"
const SCNxFAST8 = "hhx"
const SCNxLEAST16 = "hx"
const SCNxLEAST32 = "x"
const SCNxLEAST8 = "hhx"
const SERVFAIL = 0
const STATUS = 0
const S_ADDT = 0
const S_PREREQ = 0
const S_UPDATE = 0
const S_ZONE = 0
const T_A = 0
const T_A6 = 0
const T_AAAA = 0
const T_AFSDB = 0
const T_ANY = 0
const T_ATMA = 0
const T_AVC = 0
const T_AXFR = 0
const T_CAA = 0
const T_CDNSKEY = 0
const T_CDS = 0
const T_CNAME = 0
const T_CSYNC = 0
const T_DHCID = 0
const T_DLV = 0
const T_DNAME = 0
const T_DNSKEY = 0
const T_DS = 0
const T_EID = 0
const T_EUI48 = 0
const T_EUI64 = 0
const T_GID = 0
const T_GPOS = 0
const T_HINFO = 0
const T_HIP = 0
const T_IPSECKEY = 0
const T_ISDN = 0
const T_IXFR = 0
const T_KEY = 0
const T_L32 = 0
const T_L64 = 0
const T_LOC = 0
const T_LP = 0
const T_MAILA = 0
const T_MAILB = 0
const T_MB = 0
const T_MD = 0
const T_MF = 0
const T_MG = 0
const T_MINFO = 0
const T_MR = 0
const T_MX = 0
const T_NAPTR = 0
const T_NID = 0
const T_NIMLOC = 0
const T_NINFO = 0
const T_NS = 0
const T_NSAP = 0
const T_NSAP_PTR = 0
const T_NSEC = 0
const T_NSEC3 = 0
const T_NSEC3PARAM = 0
const T_NULL = 0
const T_NXT = 0
const T_OPENPGPKEY = 0
const T_PTR = 0
const T_PX = 0
const T_RKEY = 0
const T_RP = 0
const T_RRSIG = 0
const T_RT = 0
const T_SIG = 0
const T_SMIMEA = 0
const T_SOA = 0
const T_SPF = 0
const T_SRV = 0
const T_SSHFP = 0
const T_TA = 0
const T_TALINK = 0
const T_TKEY = 0
const T_TLSA = 0
const T_TSIG = 0
const T_TXT = 0
const T_UID = 0
const T_UINFO = 0
const T_UNSPEC = 0
const T_URI = 0
const T_WKS = 0
const T_X25 = 0
const YXDOMAIN = 0
const YXRRSET = 0
const _PATH_RESCONF = "/etc/resolv.conf"
const __BIND = 19950621
const __NAMESER = 19991006
const __PRI64 = "l"
const __PRIPTR = "l"
const __RES = 19960801
const __UAPI_DEF_IN6_ADDR = 0
const __UAPI_DEF_IN6_ADDR_ALT = 0
const __UAPI_DEF_IN6_PKTINFO = 0
const __UAPI_DEF_IN_ADDR = 0
const __UAPI_DEF_IN_CLASS = 0
const __UAPI_DEF_IN_IPPROTO = 0
const __UAPI_DEF_IN_PKTINFO = 0
const __UAPI_DEF_IP6_MTUINFO = 0
const __UAPI_DEF_IPPROTO_V6 = 0
const __UAPI_DEF_IPV6_MREQ = 0
const __UAPI_DEF_IPV6_OPTIONS = 0
const __UAPI_DEF_IP_MREQ = 0
const __UAPI_DEF_SOCKADDR_IN = 0
const __UAPI_DEF_SOCKADDR_IN6 = 0
const _res = 0

type Tns_sect = int32

type ___ns_sect = int32

const _ns_s_qd = 0
const _ns_s_zn = 0
const _ns_s_an = 1
const _ns_s_pr = 1
const _ns_s_ns = 2
const _ns_s_ud = 2
const _ns_s_ar = 3
const _ns_s_max = 4

type Tns_msg = struct {
	F_msg      uintptr
	F_eom      uintptr
	F_id       Tuint16_t
	F_flags    Tuint16_t
	F_counts   [4]Tuint16_t
	F_sections [4]uintptr
	F_sect     Tns_sect
	F_rrnum    int32
	F_msg_ptr  uintptr
}

type t__ns_msg = Tns_msg

type T_ns_flagdata = struct {
	Fmask  int32
	Fshift int32
}

type Tns_rr = struct {
	Fname     [1025]uint8
	Ftype1    Tuint16_t
	Frr_class Tuint16_t
	Fttl      Tuint32_t
	Frdlength Tuint16_t
	Frdata    uintptr
}

type t__ns_rr = Tns_rr

type Tns_flag = int32

type ___ns_flag = int32

const _ns_f_qr = 0
const _ns_f_opcode = 1
const _ns_f_aa = 2
const _ns_f_tc = 3
const _ns_f_rd = 4
const _ns_f_ra = 5
const _ns_f_z = 6
const _ns_f_ad = 7
const _ns_f_cd = 8
const _ns_f_rcode = 9
const _ns_f_max = 10

type Tns_opcode = int32

type ___ns_opcode = int32

const _ns_o_query = 0
const _ns_o_iquery = 1
const _ns_o_status = 2
const _ns_o_notify = 4
const _ns_o_update = 5
const _ns_o_max = 6

type Tns_rcode = int32

type ___ns_rcode = int32

const _ns_r_noerror = 0
const _ns_r_formerr = 1
const _ns_r_servfail = 2
const _ns_r_nxdomain = 3
const _ns_r_notimpl = 4
const _ns_r_refused = 5
const _ns_r_yxdomain = 6
const _ns_r_yxrrset = 7
const _ns_r_nxrrset = 8
const _ns_r_notauth = 9
const _ns_r_notzone = 10
const _ns_r_max = 11
const _ns_r_badvers = 16
const _ns_r_badsig = 16
const _ns_r_badkey = 17
const _ns_r_badtime = 18

type Tns_update_operation = int32

type ___ns_update_operation = int32

const _ns_uop_delete = 0
const _ns_uop_add = 1
const _ns_uop_max = 2

type Tns_tsig_key1 = struct {
	Fname [1025]uint8
	Falg  [1025]uint8
	Fdata uintptr
	Flen1 int32
}

type Tns_tsig_key = struct {
	Fname [1025]uint8
	Falg  [1025]uint8
	Fdata uintptr
	Flen1 int32
}

type Tns_tcp_tsig_state1 = struct {
	Fcounter int32
	Fkey     uintptr
	Fctx     uintptr
	Fsig     [512]uint8
	Fsiglen  int32
}

type Tns_tcp_tsig_state = struct {
	Fcounter int32
	Fkey     uintptr
	Fctx     uintptr
	Fsig     [512]uint8
	Fsiglen  int32
}

type Tns_type = int32

type ___ns_type = int32

const _ns_t_invalid = 0
const _ns_t_a = 1
const _ns_t_ns = 2
const _ns_t_md = 3
const _ns_t_mf = 4
const _ns_t_cname = 5
const _ns_t_soa = 6
const _ns_t_mb = 7
const _ns_t_mg = 8
const _ns_t_mr = 9
const _ns_t_null = 10
const _ns_t_wks = 11
const _ns_t_ptr = 12
const _ns_t_hinfo = 13
const _ns_t_minfo = 14
const _ns_t_mx = 15
const _ns_t_txt = 16
const _ns_t_rp = 17
const _ns_t_afsdb = 18
const _ns_t_x25 = 19
const _ns_t_isdn = 20
const _ns_t_rt = 21
const _ns_t_nsap = 22
const _ns_t_nsap_ptr = 23
const _ns_t_sig = 24
const _ns_t_key = 25
const _ns_t_px = 26
const _ns_t_gpos = 27
const _ns_t_aaaa = 28
const _ns_t_loc = 29
const _ns_t_nxt = 30
const _ns_t_eid = 31
const _ns_t_nimloc = 32
const _ns_t_srv = 33
const _ns_t_atma = 34
const _ns_t_naptr = 35
const _ns_t_kx = 36
const _ns_t_cert = 37
const _ns_t_a6 = 38
const _ns_t_dname = 39
const _ns_t_sink = 40
const _ns_t_opt = 41
const _ns_t_apl = 42
const _ns_t_ds = 43
const _ns_t_sshfp = 44
const _ns_t_ipseckey = 45
const _ns_t_rrsig = 46
const _ns_t_nsec = 47
const _ns_t_dnskey = 48
const _ns_t_dhcid = 49
const _ns_t_nsec3 = 50
const _ns_t_nsec3param = 51
const _ns_t_tlsa = 52
const _ns_t_smimea = 53
const _ns_t_hip = 55
const _ns_t_ninfo = 56
const _ns_t_rkey = 57
const _ns_t_talink = 58
const _ns_t_cds = 59
const _ns_t_cdnskey = 60
const _ns_t_openpgpkey = 61
const _ns_t_csync = 62
const _ns_t_spf = 99
const _ns_t_uinfo = 100
const _ns_t_uid = 101
const _ns_t_gid = 102
const _ns_t_unspec = 103
const _ns_t_nid = 104
const _ns_t_l32 = 105
const _ns_t_l64 = 106
const _ns_t_lp = 107
const _ns_t_eui48 = 108
const _ns_t_eui64 = 109
const _ns_t_tkey = 249
const _ns_t_tsig = 250
const _ns_t_ixfr = 251
const _ns_t_axfr = 252
const _ns_t_mailb = 253
const _ns_t_maila = 254
const _ns_t_any = 255
const _ns_t_zxfr = 256
const _ns_t_uri = 256
const _ns_t_caa = 257
const _ns_t_avc = 258
const _ns_t_ta = 32768
const _ns_t_dlv = 32769
const _ns_t_max = 65536

type Tns_class = int32

type ___ns_class = int32

const _ns_c_invalid = 0
const _ns_c_in = 1
const _ns_c_2 = 2
const _ns_c_chaos = 3
const _ns_c_hs = 4
const _ns_c_none = 254
const _ns_c_any = 255
const _ns_c_max = 65536

type Tns_key_types = int32

type ___ns_key_types = int32

const _ns_kt_rsa = 1
const _ns_kt_dh = 2
const _ns_kt_dsa = 3
const _ns_kt_private = 254

type Tns_cert_types = int32

type ___ns_cert_types = int32

const _cert_t_pkix = 1
const _cert_t_spki = 2
const _cert_t_pgp = 3
const _cert_t_url = 253
const _cert_t_oid = 254

type THEADER = struct {
	F__ccgo0 uint32
	F__ccgo4 uint32
	F__ccgo8 uint32
}

type Timaxdiv_t = struct {
	Fquot Tintmax_t
	Frem  Tintmax_t
}

type Tin_port_t = uint16

type Tin_addr_t = uint32

type Tin_addr = struct {
	Fs_addr Tin_addr_t
}

type Tsockaddr_in = struct {
	Fsin_family Tsa_family_t
	Fsin_port   Tin_port_t
	Fsin_addr   Tin_addr
	Fsin_zero   [8]Tuint8_t
}

type Tin6_addr = struct {
	F__in6_union struct {
		F__s6_addr16 [0][8]Tuint16_t
		F__s6_addr32 [0][4]Tuint32_t
		F__s6_addr   [16]Tuint8_t
	}
}

type Tsockaddr_in6 = struct {
	Fsin6_family   Tsa_family_t
	Fsin6_port     Tin_port_t
	Fsin6_flowinfo Tuint32_t
	Fsin6_addr     Tin6_addr
	Fsin6_scope_id Tuint32_t
}

type Tipv6_mreq = struct {
	Fipv6mr_multiaddr Tin6_addr
	Fipv6mr_interface uint32
}

type Tip_opts = struct {
	Fip_dst  Tin_addr
	Fip_opts [40]uint8
}

type Tres_state = uintptr

type t__res_state = struct {
	Fretrans     int32
	Fretry       int32
	Foptions     uint64
	Fnscount     int32
	Fnsaddr_list [3]Tsockaddr_in
	Fid          uint16
	Fdnsrch      [7]uintptr
	Fdefdname    [256]uint8
	Fpfcode      uint64
	F__ccgo392   uint32
	Fsort_list   [10]struct {
		Faddr Tin_addr
		Fmask Tuint32_t
	}
	Fqhook       uintptr
	Frhook       uintptr
	Fres_h_errno int32
	F_vcsock     int32
	F_flags      uint32
	F_u          struct {
		F_ext [0]struct {
			Fnscount    Tuint16_t
			Fnsmap      [3]Tuint16_t
			Fnssocks    [3]int32
			Fnscount6   Tuint16_t
			Fnsinit     Tuint16_t
			Fnsaddrs    [3]uintptr
			F_initstamp [2]uint32
		}
		Fpad         [52]uint8
		F__ccgo_pad2 [4]byte
	}
}

type Tres_sym = struct {
	Fnumber    int32
	Fname      uintptr
	Fhumanname uintptr
}

/* RFC 1035 message compression */

// C documentation
//
//	/* label start offsets of a compressed domain name s */
func _getoffs(tls *TLS, offs uintptr, base uintptr, s uintptr) (r int32) {
	var i, v2 int32
	_, _ = i, v2
	i = 0
	for {
		for int32(*(*uint8)(unsafe.Pointer(s)))&int32(0xc0) != 0 {
			if int32(*(*uint8)(unsafe.Pointer(s)))&int32(0xc0) != int32(0xc0) {
				return 0
			}
			s = base + uintptr(int32(*(*uint8)(unsafe.Pointer(s)))&Int32FromInt32(0x3f)<<Int32FromInt32(8)|int32(*(*uint8)(unsafe.Pointer(s + 1))))
		}
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			return i
		}
		if int64(s)-int64(base) >= int64(0x4000) {
			return 0
		}
		v2 = i
		i++
		*(*int16)(unsafe.Pointer(offs + uintptr(v2)*2)) = int16(int64(s) - int64(base))
		s += uintptr(int32(*(*uint8)(unsafe.Pointer(s))) + int32(1))
		goto _1
	_1:
	}
	return r
}

// C documentation
//
//	/* label lengths of an ascii domain name s */
func _getlens(tls *TLS, lens uintptr, s uintptr, l int32) (r int32) {
	var i, j, k, v3, v4 int32
	_, _, _, _, _ = i, j, k, v3, v4
	i = 0
	j = 0
	k = 0
	for {
		for {
			if !(j < l && int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) != int32('.')) {
				break
			}
			goto _2
		_2:
			;
			j++
		}
		if uint32(j-k)-uint32(1) > uint32(62) {
			return 0
		}
		v3 = i
		i++
		*(*uint8)(unsafe.Pointer(lens + uintptr(v3))) = uint8(j - k)
		if j == l {
			return i
		}
		j++
		v4 = j
		k = v4
		goto _1
	_1:
	}
	return r
}

// C documentation
//
//	/* longest suffix match of an ascii domain with a compressed domain name dn */
func _match(tls *TLS, offset uintptr, base uintptr, dn uintptr, end uintptr, lens uintptr, nlen int32) (r int32) {
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var l, m, noff, o, v2, v3 int32
	var _ /* offs at bp+0 */ [128]int16
	_, _, _, _, _, _ = l, m, noff, o, v2, v3
	m = 0
	noff = _getoffs(tls, bp, base, dn)
	if !(noff != 0) {
		return 0
	}
	for {
		nlen--
		v2 = nlen
		l = int32(*(*uint8)(unsafe.Pointer(lens + uintptr(v2))))
		noff--
		v3 = noff
		o = int32((*(*[128]int16)(unsafe.Pointer(bp)))[v3])
		end -= uintptr(l)
		if l != int32(*(*uint8)(unsafe.Pointer(base + uintptr(o)))) || Xmemcmp(tls, base+uintptr(o)+uintptr(1), end, uint64(l)) != 0 {
			return m
		}
		*(*int32)(unsafe.Pointer(offset)) = o
		m += l
		if nlen != 0 {
			m++
		}
		if !(nlen != 0) || !(noff != 0) {
			return m
		}
		end--
		goto _1
	_1:
	}
	return r
}

func Xdn_comp(tls *TLS, src uintptr, dst uintptr, space int32, dnptrs uintptr, lastdnptr uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v src=%v dst=%v space=%v dnptrs=%v lastdnptr=%v, (%v:)", tls, src, dst, space, dnptrs, lastdnptr, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var bestlen, bestoff, i, j, m, n, v3, v4, v5, v6, v7 int32
	var end, p, v8 uintptr
	var l Tsize_t
	var _ /* lens at bp+4 */ [127]uint8
	var _ /* offset at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bestlen, bestoff, end, i, j, l, m, n, p, v3, v4, v5, v6, v7, v8
	m = 0
	bestlen = 0
	l = Xstrnlen(tls, src, uint64(255))
	if l != 0 && int32(*(*uint8)(unsafe.Pointer(src + uintptr(l-uint64(1))))) == int32('.') {
		l--
	}
	if l > uint64(253) || space <= 0 {
		return -int32(1)
	}
	if !(l != 0) {
		*(*uint8)(unsafe.Pointer(dst)) = uint8(0)
		return int32(1)
	}
	end = src + uintptr(l)
	n = _getlens(tls, bp+4, src, int32(l))
	if !(n != 0) {
		return -int32(1)
	}
	p = dnptrs
	if p != 0 && *(*uintptr)(unsafe.Pointer(p)) != 0 {
		p += 8
		for {
			if !(*(*uintptr)(unsafe.Pointer(p)) != 0) {
				break
			}
			m = _match(tls, bp, *(*uintptr)(unsafe.Pointer(dnptrs)), *(*uintptr)(unsafe.Pointer(p)), end, bp+4, n)
			if m > bestlen {
				bestlen = m
				bestoff = *(*int32)(unsafe.Pointer(bp))
				if uint64(m) == l {
					break
				}
			}
			goto _1
		_1:
			;
			p += 8
		}
	}
	/* encode unmatched part */
	if uint64(space) < l-uint64(bestlen)+uint64(2)+BoolUint64(uint64(bestlen-Int32FromInt32(1)) < l-Uint64FromInt32(1)) {
		return -int32(1)
	}
	Xmemcpy(tls, dst+uintptr(1), src, l-uint64(bestlen))
	v3 = Int32FromInt32(0)
	j = v3
	i = v3
	for {
		if !(uint64(i) < l-uint64(bestlen)) {
			break
		}
		*(*uint8)(unsafe.Pointer(dst + uintptr(i))) = (*(*[127]uint8)(unsafe.Pointer(bp + 4)))[j]
		goto _2
	_2:
		;
		v4 = j
		j++
		i += int32((*(*[127]uint8)(unsafe.Pointer(bp + 4)))[v4]) + int32(1)
	}
	/* add tail */
	if bestlen != 0 {
		v5 = i
		i++
		*(*uint8)(unsafe.Pointer(dst + uintptr(v5))) = uint8(int32(0xc0) | bestoff>>int32(8))
		v6 = i
		i++
		*(*uint8)(unsafe.Pointer(dst + uintptr(v6))) = uint8(bestoff)
	} else {
		v7 = i
		i++
		*(*uint8)(unsafe.Pointer(dst + uintptr(v7))) = uint8(0)
	}
	/* save dst pointer */
	if i > int32(2) && lastdnptr != 0 && dnptrs != 0 && *(*uintptr)(unsafe.Pointer(dnptrs)) != 0 {
		for *(*uintptr)(unsafe.Pointer(p)) != 0 {
			p += 8
		}
		if p+uintptr(1)*8 < lastdnptr {
			v8 = p
			p += 8
			*(*uintptr)(unsafe.Pointer(v8)) = dst
			*(*uintptr)(unsafe.Pointer(p)) = uintptr(0)
		}
	}
	return i
}

func X__dn_expand(tls *TLS, base uintptr, end uintptr, src uintptr, dest uintptr, space int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v base=%v end=%v src=%v dest=%v space=%v, (%v:)", tls, base, end, src, dest, space, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var dbegin, dend, p, v3, v4, v6, v7 uintptr
	var i, j, len1, v1, v5 int32
	_, _, _, _, _, _, _, _, _, _, _, _ = dbegin, dend, i, j, len1, p, v1, v3, v4, v5, v6, v7
	p = src
	dbegin = dest
	len1 = -int32(1)
	if p == end || space <= 0 {
		return -int32(1)
	}
	if space > int32(254) {
		v1 = int32(254)
	} else {
		v1 = space
	}
	dend = dest + uintptr(v1)
	/* detect reference loop using an iteration counter */
	i = 0
	for {
		if !(int64(i) < int64(end)-int64(base)) {
			break
		}
		/* loop invariants: p<end, dest<dend */
		if int32(*(*uint8)(unsafe.Pointer(p)))&int32(0xc0) != 0 {
			if p+uintptr(1) == end {
				return -int32(1)
			}
			j = int32(*(*uint8)(unsafe.Pointer(p)))&int32(0x3f)<<int32(8) | int32(*(*uint8)(unsafe.Pointer(p + 1)))
			if len1 < 0 {
				len1 = int32(int64(p+uintptr(2)) - int64(src))
			}
			if int64(j) >= int64(end)-int64(base) {
				return -int32(1)
			}
			p = base + uintptr(j)
		} else {
			if *(*uint8)(unsafe.Pointer(p)) != 0 {
				if dest != dbegin {
					v3 = dest
					dest++
					*(*uint8)(unsafe.Pointer(v3)) = uint8('.')
				}
				v4 = p
				p++
				j = int32(*(*uint8)(unsafe.Pointer(v4)))
				if int64(j) >= int64(end)-int64(p) || int64(j) >= int64(dend)-int64(dest) {
					return -int32(1)
				}
				for {
					v5 = j
					j--
					if !(v5 != 0) {
						break
					}
					v6 = dest
					dest++
					v7 = p
					p++
					*(*uint8)(unsafe.Pointer(v6)) = *(*uint8)(unsafe.Pointer(v7))
				}
			} else {
				*(*uint8)(unsafe.Pointer(dest)) = uint8(0)
				if len1 < 0 {
					len1 = int32(int64(p+uintptr(1)) - int64(src))
				}
				return len1
			}
		}
		goto _2
	_2:
		;
		i += int32(2)
	}
	return -int32(1)
}

func Xdn_expand(tls *TLS, base uintptr, end uintptr, src uintptr, dest uintptr, space int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v base=%v end=%v src=%v dest=%v space=%v, (%v:)", tls, base, end, src, dest, space, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__dn_expand(tls, base, end, src, dest, space)
}

func Xdn_skipname(tls *TLS, s uintptr, end uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v end=%v, (%v:)", tls, s, end, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p uintptr
	_ = p
	p = s
	for p < end {
		if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			return int32(int64(p) - int64(s) + int64(1))
		} else {
			if int32(*(*uint8)(unsafe.Pointer(p))) >= int32(192) {
				if p+uintptr(1) < end {
					return int32(int64(p) - int64(s) + int64(2))
				} else {
					break
				}
			} else {
				if int64(end)-int64(p) < int64(int32(*(*uint8)(unsafe.Pointer(p)))+int32(1)) {
					break
				} else {
					p += uintptr(int32(*(*uint8)(unsafe.Pointer(p))) + int32(1))
				}
			}
		}
	}
	return -int32(1)
}

const AI_ADDRCONFIG = 32
const AI_ALL = 16
const AI_CANONNAME = 2
const AI_NUMERICHOST = 4
const AI_NUMERICSERV = 1024
const AI_PASSIVE = 1
const AI_V4MAPPED = 8
const EAI_AGAIN = -3
const EAI_BADFLAGS = -1
const EAI_FAIL = -4
const EAI_FAMILY = -6
const EAI_MEMORY = -10
const EAI_NODATA = -5
const EAI_NONAME = -2
const EAI_OVERFLOW = -12
const EAI_SERVICE = -8
const EAI_SOCKTYPE = -7
const EAI_SYSTEM = -11
const MAXADDRS = 48
const MAXSERVS = 2
const NI_DGRAM = 16
const NI_NAMEREQD = 8
const NI_NOFQDN = 4
const NI_NUMERICHOST = 1
const NI_NUMERICSCOPE = 256
const NI_NUMERICSERV = 2

type Taddrinfo = struct {
	Fai_flags     int32
	Fai_family    int32
	Fai_socktype  int32
	Fai_protocol  int32
	Fai_addrlen   Tsocklen_t
	Fai_addr      uintptr
	Fai_canonname uintptr
	Fai_next      uintptr
}

type Tnetent = struct {
	Fn_name     uintptr
	Fn_aliases  uintptr
	Fn_addrtype int32
	Fn_net      Tuint32_t
}

type Thostent = struct {
	Fh_name      uintptr
	Fh_aliases   uintptr
	Fh_addrtype  int32
	Fh_length    int32
	Fh_addr_list uintptr
}

type Tservent = struct {
	Fs_name    uintptr
	Fs_aliases uintptr
	Fs_port    int32
	Fs_proto   uintptr
}

type Tprotoent = struct {
	Fp_name    uintptr
	Fp_aliases uintptr
	Fp_proto   int32
}

type Taibuf = struct {
	Fai   Taddrinfo
	Fsa   Tsa
	Flock [1]int32
	Fslot int16
	Fref  int16
}

type Taddress = struct {
	Ffamily  int32
	Fscopeid uint32
	Faddr    [16]Tuint8_t
	Fsortkey int32
}

type Tservice = struct {
	Fport     Tuint16_t
	Fproto    uint8
	Fsocktype uint8
}

type Tresolvconf = struct {
	Fns       [3]Taddress
	Fnns      uint32
	Fattempts uint32
	Fndots    uint32
	Ftimeout  uint32
}

func X__dns_parse(tls *TLS, r uintptr, rlen int32, callback uintptr, ctx uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v r=%v rlen=%v callback=%v ctx=%v, (%v:)", tls, r, rlen, callback, ctx, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var ancount, len1, qdcount, v1, v2 int32
	var p uintptr
	_, _, _, _, _, _ = ancount, len1, p, qdcount, v1, v2
	if rlen < int32(12) {
		return -int32(1)
	}
	if int32(*(*uint8)(unsafe.Pointer(r + 3)))&int32(15) != 0 {
		return 0
	}
	p = r + uintptr(12)
	qdcount = int32(*(*uint8)(unsafe.Pointer(r + 4)))*int32(256) + int32(*(*uint8)(unsafe.Pointer(r + 5)))
	ancount = int32(*(*uint8)(unsafe.Pointer(r + 6)))*int32(256) + int32(*(*uint8)(unsafe.Pointer(r + 7)))
	for {
		v1 = qdcount
		qdcount--
		if !(v1 != 0) {
			break
		}
		for int64(p)-int64(r) < int64(rlen) && uint32(*(*uint8)(unsafe.Pointer(p)))-uint32(1) < uint32(127) {
			p++
		}
		if p > r+uintptr(rlen)-uintptr(6) {
			return -int32(1)
		}
		p += uintptr(int32(5) + BoolInt32(!!(*(*uint8)(unsafe.Pointer(p)) != 0)))
	}
	for {
		v2 = ancount
		ancount--
		if !(v2 != 0) {
			break
		}
		for int64(p)-int64(r) < int64(rlen) && uint32(*(*uint8)(unsafe.Pointer(p)))-uint32(1) < uint32(127) {
			p++
		}
		if p > r+uintptr(rlen)-uintptr(12) {
			return -int32(1)
		}
		p += uintptr(int32(1) + BoolInt32(!!(*(*uint8)(unsafe.Pointer(p)) != 0)))
		len1 = int32(*(*uint8)(unsafe.Pointer(p + 8)))*int32(256) + int32(*(*uint8)(unsafe.Pointer(p + 9)))
		if int64(len1+int32(10)) > int64(r+uintptr(rlen))-int64(p) {
			return -int32(1)
		}
		if (*(*func(*TLS, uintptr, int32, uintptr, int32, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{callback})))(tls, ctx, int32(*(*uint8)(unsafe.Pointer(p + 1))), p+uintptr(10), len1, r, rlen) < 0 {
			return -int32(1)
		}
		p += uintptr(int32(10) + len1)
	}
	return 0
}

type Tsa = struct {
	Fsin6        [0]Tsockaddr_in6
	Fsin         Tsockaddr_in
	F__ccgo_pad2 [12]byte
}

func Xsethostent(tls *TLS, x int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
	}
}

func Xgethostent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(0)
}

func Xgetnetent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(0)
}

func Xendhostent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
}

func Xendnetent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	Xendhostent(tls)
}

func Xsetnetent(tls *TLS, x int32) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
	}
	Xsethostent(tls, x)
}

const ARPD_FLUSH = 3
const ARPD_LOOKUP = 2
const ARPD_UPDATE = 1
const ARPHRD_6LOWPAN = 825
const ARPHRD_ADAPT = 264
const ARPHRD_APPLETLK = 8
const ARPHRD_ARCNET = 7
const ARPHRD_ASH = 781
const ARPHRD_ATM = 19
const ARPHRD_AX25 = 3
const ARPHRD_BIF = 775
const ARPHRD_CAIF = 822
const ARPHRD_CAN = 280
const ARPHRD_CHAOS = 5
const ARPHRD_CISCO = 513
const ARPHRD_CSLIP = 257
const ARPHRD_CSLIP6 = 259
const ARPHRD_DDCMP = 517
const ARPHRD_DLCI = 15
const ARPHRD_ECONET = 782
const ARPHRD_EETHER = 2
const ARPHRD_ETHER = 1
const ARPHRD_EUI64 = 27
const ARPHRD_FCAL = 785
const ARPHRD_FCFABRIC = 787
const ARPHRD_FCPL = 786
const ARPHRD_FCPP = 784
const ARPHRD_FDDI = 774
const ARPHRD_FRAD = 770
const ARPHRD_HDLC = 513
const ARPHRD_HIPPI = 780
const ARPHRD_HWX25 = 272
const ARPHRD_IEEE1394 = 24
const ARPHRD_IEEE802 = 6
const ARPHRD_IEEE80211 = 801
const ARPHRD_IEEE80211_PRISM = 802
const ARPHRD_IEEE80211_RADIOTAP = 803
const ARPHRD_IEEE802154 = 804
const ARPHRD_IEEE802154_MONITOR = 805
const ARPHRD_IEEE802_TR = 800
const ARPHRD_INFINIBAND = 32
const ARPHRD_IP6GRE = 823
const ARPHRD_IPDDP = 777
const ARPHRD_IPGRE = 778
const ARPHRD_IRDA = 783
const ARPHRD_LAPB = 516
const ARPHRD_LOCALTLK = 773
const ARPHRD_LOOPBACK = 772
const ARPHRD_METRICOM = 23
const ARPHRD_NETLINK = 824
const ARPHRD_NETROM = 0
const ARPHRD_NONE = 65534
const ARPHRD_PHONET = 820
const ARPHRD_PHONET_PIPE = 821
const ARPHRD_PIMREG = 779
const ARPHRD_PPP = 512
const ARPHRD_PRONET = 4
const ARPHRD_RAWHDLC = 518
const ARPHRD_RAWIP = 519
const ARPHRD_ROSE = 270
const ARPHRD_RSRVD = 260
const ARPHRD_SIT = 776
const ARPHRD_SKIP = 771
const ARPHRD_SLIP = 256
const ARPHRD_SLIP6 = 258
const ARPHRD_TUNNEL = 768
const ARPHRD_TUNNEL6 = 769
const ARPHRD_VOID = 65535
const ARPHRD_VSOCKMON = 826
const ARPHRD_X25 = 271
const ARPOP_InREPLY = 9
const ARPOP_InREQUEST = 8
const ARPOP_NAK = 10
const ARPOP_REPLY = 2
const ARPOP_REQUEST = 1
const ARPOP_RREPLY = 4
const ARPOP_RREQUEST = 3
const ATF_COM = 2
const ATF_DONTPUB = 64
const ATF_MAGIC = 128
const ATF_NETMASK = 32
const ATF_PERM = 4
const ATF_PUBL = 8
const ATF_USETRAILERS = 16
const ETHERMIN = 46
const ETHERMTU = 1500
const ETHERTYPE_AARP = 33011
const ETHERTYPE_ARP = 2054
const ETHERTYPE_AT = 32923
const ETHERTYPE_IP = 2048
const ETHERTYPE_IPV6 = 34525
const ETHERTYPE_IPX = 33079
const ETHERTYPE_LOOPBACK = 36864
const ETHERTYPE_NTRAILER = 16
const ETHERTYPE_PUP = 512
const ETHERTYPE_REVARP = 32821
const ETHERTYPE_SPRITE = 1280
const ETHERTYPE_TRAIL = 4096
const ETHERTYPE_VLAN = 33024
const ETHER_ADDR_LEN = 6
const ETHER_CRC_LEN = 4
const ETHER_HDR_LEN = 14
const ETHER_MAX_LEN = 1518
const ETHER_MIN_LEN = 64
const ETHER_TYPE_LEN = 2
const ETH_ALEN = 6
const ETH_DATA_LEN = 1500
const ETH_FCS_LEN = 4
const ETH_FRAME_LEN = 1514
const ETH_HLEN = 14
const ETH_MAX_MTU = 65535
const ETH_MIN_MTU = 68
const ETH_P_1588 = 35063
const ETH_P_8021AD = 34984
const ETH_P_8021AH = 35047
const ETH_P_8021Q = 33024
const ETH_P_80221 = 35095
const ETH_P_802_2 = 4
const ETH_P_802_3 = 1
const ETH_P_802_3_MIN = 1536
const ETH_P_802_EX1 = 34997
const ETH_P_AARP = 33011
const ETH_P_AF_IUCV = 64507
const ETH_P_ALL = 3
const ETH_P_AOE = 34978
const ETH_P_ARCNET = 26
const ETH_P_ARP = 2054
const ETH_P_ATALK = 32923
const ETH_P_ATMFATE = 34948
const ETH_P_ATMMPOA = 34892
const ETH_P_AX25 = 2
const ETH_P_BATMAN = 17157
const ETH_P_BPQ = 2303
const ETH_P_CAIF = 247
const ETH_P_CAN = 12
const ETH_P_CANFD = 13
const ETH_P_CFM = 35074
const ETH_P_CONTROL = 22
const ETH_P_CUST = 24582
const ETH_P_DDCMP = 6
const ETH_P_DEC = 24576
const ETH_P_DIAG = 24581
const ETH_P_DNA_DL = 24577
const ETH_P_DNA_RC = 24578
const ETH_P_DNA_RT = 24579
const ETH_P_DSA = 27
const ETH_P_DSA_8021Q = 56027
const ETH_P_ECONET = 24
const ETH_P_EDSA = 56026
const ETH_P_ERSPAN = 35006
const ETH_P_ERSPAN2 = 8939
const ETH_P_FCOE = 35078
const ETH_P_FIP = 35092
const ETH_P_HDLC = 25
const ETH_P_HSR = 35119
const ETH_P_IBOE = 35093
const ETH_P_IEEE802154 = 246
const ETH_P_IEEEPUP = 2560
const ETH_P_IEEEPUPAT = 2561
const ETH_P_IFE = 60734
const ETH_P_IP = 2048
const ETH_P_IPV6 = 34525
const ETH_P_IPX = 33079
const ETH_P_IRDA = 23
const ETH_P_LAT = 24580
const ETH_P_LINK_CTL = 34924
const ETH_P_LLDP = 35020
const ETH_P_LOCALTALK = 9
const ETH_P_LOOP = 96
const ETH_P_LOOPBACK = 36864
const ETH_P_MACSEC = 35045
const ETH_P_MAP = 249
const ETH_P_MOBITEX = 21
const ETH_P_MPLS_MC = 34888
const ETH_P_MPLS_UC = 34887
const ETH_P_MRP = 35043
const ETH_P_MVRP = 35061
const ETH_P_NCSI = 35064
const ETH_P_NSH = 35151
const ETH_P_PAE = 34958
const ETH_P_PAUSE = 34824
const ETH_P_PHONET = 245
const ETH_P_PPPTALK = 16
const ETH_P_PPP_DISC = 34915
const ETH_P_PPP_MP = 8
const ETH_P_PPP_SES = 34916
const ETH_P_PREAUTH = 35015
const ETH_P_PRP = 35067
const ETH_P_PUP = 512
const ETH_P_PUPAT = 513
const ETH_P_QINQ1 = 37120
const ETH_P_QINQ2 = 37376
const ETH_P_QINQ3 = 37632
const ETH_P_RARP = 32821
const ETH_P_SCA = 24583
const ETH_P_SLOW = 34825
const ETH_P_SNAP = 5
const ETH_P_TDLS = 35085
const ETH_P_TEB = 25944
const ETH_P_TIPC = 35018
const ETH_P_TRAILER = 28
const ETH_P_TR_802_2 = 17
const ETH_P_TSN = 8944
const ETH_P_WAN_PPP = 7
const ETH_P_WCCP = 34878
const ETH_P_X25 = 2053
const ETH_P_XDSA = 248
const ETH_TLEN = 2
const ETH_ZLEN = 60
const MAX_ADDR_LEN = 7
const __UAPI_DEF_ETHHDR = 0

type Tethhdr = struct {
	Fh_dest   [6]Tuint8_t
	Fh_source [6]Tuint8_t
	Fh_proto  Tuint16_t
}

type Tether_addr = struct {
	Fether_addr_octet [6]Tuint8_t
}

type Tether_header = struct {
	Fether_dhost [6]Tuint8_t
	Fether_shost [6]Tuint8_t
	Fether_type  Tuint16_t
}

type Tarphdr = struct {
	Far_hrd Tuint16_t
	Far_pro Tuint16_t
	Far_hln Tuint8_t
	Far_pln Tuint8_t
	Far_op  Tuint16_t
}

type Tarpreq = struct {
	Farp_pa      Tsockaddr
	Farp_ha      Tsockaddr
	Farp_flags   int32
	Farp_netmask Tsockaddr
	Farp_dev     [16]uint8
}

type Tarpreq_old = struct {
	Farp_pa      Tsockaddr
	Farp_ha      Tsockaddr
	Farp_flags   int32
	Farp_netmask Tsockaddr
}

type Tarpd_request = struct {
	Freq     uint16
	Fip      Tuint32_t
	Fdev     uint64
	Fstamp   uint64
	Fupdated uint64
	Fha      [7]uint8
}

type Tether_arp = struct {
	Fea_hdr  Tarphdr
	Farp_sha [6]Tuint8_t
	Farp_spa [4]Tuint8_t
	Farp_tha [6]Tuint8_t
	Farp_tpa [4]Tuint8_t
}

func Xether_aton_r(tls *TLS, x uintptr, p_a uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v x=%v p_a=%v, (%v:)", tls, x, p_a, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ii int32
	var n uint64
	var _ /* a at bp+0 */ Tether_addr
	var _ /* y at bp+8 */ uintptr
	_, _ = ii, n
	ii = 0
	for {
		if !(ii < int32(6)) {
			break
		}
		if ii != 0 {
			if int32(*(*uint8)(unsafe.Pointer(x))) != int32(':') {
				return uintptr(0)
			} else {
				x++
			}
		}
		n = Xstrtoul(tls, x, bp+8, int32(16))
		x = *(*uintptr)(unsafe.Pointer(bp + 8))
		if n > uint64(0xFF) {
			return uintptr(0)
		} /* bad byte */
		*(*Tuint8_t)(unsafe.Pointer(bp + uintptr(ii))) = uint8(n)
		goto _1
	_1:
		;
		ii++
	}
	if int32(*(*uint8)(unsafe.Pointer(x))) != 0 {
		return uintptr(0)
	} /* bad format */
	*(*Tether_addr)(unsafe.Pointer(p_a)) = *(*Tether_addr)(unsafe.Pointer(bp))
	return p_a
}

func Xether_aton(tls *TLS, x uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v x=%v, (%v:)", tls, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xether_aton_r(tls, x, uintptr(unsafe.Pointer(&_a)))
}

var _a Tether_addr

func Xether_ntoa_r(tls *TLS, p_a uintptr, x uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v p_a=%v x=%v, (%v:)", tls, p_a, x, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ii int32
	var y, v2 uintptr
	_, _, _ = ii, y, v2
	y = x
	ii = 0
	for {
		if !(ii < int32(6)) {
			break
		}
		if ii == 0 {
			v2 = __ccgo_ts + 971
		} else {
			v2 = __ccgo_ts + 976
		}
		x += uintptr(Xsprintf(tls, x, v2, VaList(bp+8, int32(*(*Tuint8_t)(unsafe.Pointer(p_a + uintptr(ii)))))))
		goto _1
	_1:
		;
		ii++
	}
	return y
}

func Xether_ntoa(tls *TLS, p_a uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v p_a=%v, (%v:)", tls, p_a, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xether_ntoa_r(tls, p_a, uintptr(unsafe.Pointer(&_x)))
}

var _x [18]uint8

func Xether_line(tls *TLS, l uintptr, e uintptr, hostname uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v e=%v hostname=%v, (%v:)", tls, l, e, hostname, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return -int32(1)
}

func Xether_ntohost(tls *TLS, hostname uintptr, e uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v hostname=%v e=%v, (%v:)", tls, hostname, e, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return -int32(1)
}

func Xether_hostton(tls *TLS, hostname uintptr, e uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v hostname=%v e=%v, (%v:)", tls, hostname, e, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return -int32(1)
}

func Xfreeaddrinfo(tls *TLS, p uintptr) {
	if __ccgo_strace {
		trc("tls=%v p=%v, (%v:)", tls, p, origin(2))
	}
	var b, p2 uintptr
	var cnt Tsize_t
	_, _, _ = b, cnt, p2
	cnt = uint64(1)
	for {
		if !((*Taddrinfo)(unsafe.Pointer(p)).Fai_next != 0) {
			break
		}
		goto _1
	_1:
		;
		cnt++
		p = (*Taddrinfo)(unsafe.Pointer(p)).Fai_next
	}
	b = p - uintptr(uint64(UintptrFromInt32(0)))
	b -= uintptr((*Taibuf)(unsafe.Pointer(b)).Fslot) * 88
	___lock(tls, b+76)
	p2 = b + 82
	*(*int16)(unsafe.Pointer(p2)) = int16(uint64(*(*int16)(unsafe.Pointer(p2))) - cnt)
	if !(*(*int16)(unsafe.Pointer(p2)) != 0) {
		Xfree(tls, b)
	} else {
		___unlock(tls, b+76)
	}
}

var _msgs = [252]uint8{'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'f', 'l', 'a', 'g', 's', 0, 'N', 'a', 'm', 'e', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r', 'e', 's', 'o', 'l', 'v', 'e', 0, 'T', 'r', 'y', ' ', 'a', 'g', 'a', 'i', 'n', 0, 'N', 'o', 'n', '-', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'a', 'b', 'l', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'N', 'a', 'm', 'e', ' ', 'h', 'a', 's', ' ', 'n', 'o', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 'f', 'a', 'm', 'i', 'l', 'y', ' ', 'o', 'r', ' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'e', 'n', 'g', 't', 'h', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 's', 'o', 'c', 'k', 'e', 't', ' ', 't', 'y', 'p', 'e', 0, 'U', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 's', 'e', 'r', 'v', 'i', 'c', 'e', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0, 'S', 'y', 's', 't', 'e', 'm', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'O', 'v', 'e', 'r', 'f', 'l', 'o', 'w', 0, 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r'}

func Xgai_strerror(tls *TLS, ecode int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ecode=%v, (%v:)", tls, ecode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var s uintptr
	_ = s
	s = uintptr(unsafe.Pointer(&_msgs))
	ecode++
	for {
		if !(ecode != 0 && *(*uint8)(unsafe.Pointer(s)) != 0) {
			break
		}
		for {
			if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
				break
			}
			goto _2
		_2:
			;
			s++
		}
		goto _1
	_1:
		;
		ecode++
		s++
	}
	if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
		s++
	}
	return X__lctrans_cur(tls, s)
}

func Xgetaddrinfo(tls *TLS, host uintptr, serv uintptr, hint uintptr, res uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v host=%v serv=%v hint=%v res=%v, (%v:)", tls, host, serv, hint, res, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(1616)
	defer tls.Free(1616)
	var canon_len, family, flags, i, j, k, mask, naddrs, nais, no_family, nservs, proto, r, s, saved_errno, socktype, v3 int32
	var out, outcanon uintptr
	var ta [2]uintptr
	var tf [2]int32
	var tl [2]Tsocklen_t
	var v5 uint64
	var _ /* addrs at bp+8 */ [48]Taddress
	var _ /* canon at bp+1352 */ [256]uint8
	var _ /* cs at bp+1608 */ int32
	var _ /* ports at bp+0 */ [2]Tservice
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = canon_len, family, flags, i, j, k, mask, naddrs, nais, no_family, nservs, out, outcanon, proto, r, s, saved_errno, socktype, ta, tf, tl, v3, v5
	family = PF_UNSPEC
	flags = 0
	proto = 0
	socktype = 0
	no_family = 0
	if !(host != 0) && !(serv != 0) {
		return -int32(2)
	}
	if hint != 0 {
		family = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_family
		flags = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_flags
		proto = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_protocol
		socktype = (*Taddrinfo)(unsafe.Pointer(hint)).Fai_socktype
		mask = Int32FromInt32(AI_PASSIVE) | Int32FromInt32(AI_CANONNAME) | Int32FromInt32(AI_NUMERICHOST) | Int32FromInt32(AI_V4MAPPED) | Int32FromInt32(AI_ALL) | Int32FromInt32(AI_ADDRCONFIG) | Int32FromInt32(AI_NUMERICSERV)
		if flags&mask != flags {
			return -int32(1)
		}
		switch family {
		case int32(PF_INET):
			fallthrough
		case int32(PF_INET6):
			fallthrough
		case PF_UNSPEC:
		default:
			return -int32(6)
		}
	}
	if flags&int32(AI_ADDRCONFIG) != 0 {
		tf = [2]int32{
			0: int32(PF_INET),
			1: int32(PF_INET6),
		}
		ta = [2]uintptr{
			0: uintptr(unsafe.Pointer(&_lo4)),
			1: uintptr(unsafe.Pointer(&_lo6)),
		}
		tl = [2]Tsocklen_t{
			0: uint32(16),
			1: uint32(28),
		}
		i = 0
		for {
			if !(i < int32(2)) {
				break
			}
			if family == tf[int32(1)-i] {
				goto _1
			}
			s = Xsocket(tls, tf[i], Int32FromInt32(SOCK_CLOEXEC)|Int32FromInt32(SOCK_DGRAM), int32(IPPROTO_UDP))
			if s >= 0 {
				_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+1608)
				r = Xconnect(tls, s, ta[i], tl[i])
				saved_errno = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
				_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 1608)), uintptr(0))
				Xclose(tls, s)
				if !(r != 0) {
					goto _1
				}
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = saved_errno
			}
			switch *(*int32)(unsafe.Pointer(X__errno_location(tls))) {
			case int32(EADDRNOTAVAIL):
				fallthrough
			case int32(EAFNOSUPPORT):
				fallthrough
			case int32(EHOSTUNREACH):
				fallthrough
			case int32(ENETDOWN):
				fallthrough
			case int32(ENETUNREACH):
			default:
				return -int32(11)
			}
			if family == tf[i] {
				no_family = int32(1)
			}
			family = tf[int32(1)-i]
			goto _1
		_1:
			;
			i++
		}
	}
	nservs = X__lookup_serv(tls, bp, serv, proto, socktype, flags)
	if nservs < 0 {
		return nservs
	}
	naddrs = X__lookup_name(tls, bp+8, bp+1352, host, family, flags)
	if naddrs < 0 {
		return naddrs
	}
	if no_family != 0 {
		return -int32(5)
	}
	nais = nservs * naddrs
	canon_len = int32(Xstrlen(tls, bp+1352))
	out = Xcalloc(tls, uint64(1), uint64(nais)*uint64(88)+uint64(canon_len)+uint64(1))
	if !(out != 0) {
		return -int32(10)
	}
	if canon_len != 0 {
		outcanon = out + uintptr(nais)*88
		Xmemcpy(tls, outcanon, bp+1352, uint64(canon_len+int32(1)))
	} else {
		outcanon = uintptr(0)
	}
	v3 = Int32FromInt32(0)
	i = v3
	k = v3
	for {
		if !(i < naddrs) {
			break
		}
		j = 0
		for {
			if !(j < nservs) {
				break
			}
			(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fslot = int16(k)
			if (*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Ffamily == int32(PF_INET) {
				v5 = uint64(16)
			} else {
				v5 = uint64(28)
			}
			(*(*Taibuf)(unsafe.Pointer(out + uintptr(k)*88))).Fai = Taddrinfo{
				Fai_family:    (*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Ffamily,
				Fai_socktype:  int32((*(*[2]Tservice)(unsafe.Pointer(bp)))[j].Fsocktype),
				Fai_protocol:  int32((*(*[2]Tservice)(unsafe.Pointer(bp)))[j].Fproto),
				Fai_addrlen:   uint32(v5),
				Fai_addr:      out + uintptr(k)*88 + 48,
				Fai_canonname: outcanon,
			}
			if k != 0 {
				(*(*Taibuf)(unsafe.Pointer(out + uintptr(k-int32(1))*88))).Fai.Fai_next = out + uintptr(k)*88
			}
			switch (*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Ffamily {
			case int32(PF_INET):
				*(*Tsa_family_t)(unsafe.Pointer(out + uintptr(k)*88 + 48)) = uint16(PF_INET)
				*(*Tin_port_t)(unsafe.Pointer(out + uintptr(k)*88 + 48 + 2)) = Xhtons(tls, (*(*[2]Tservice)(unsafe.Pointer(bp)))[j].Fport)
				Xmemcpy(tls, out+uintptr(k)*88+48+4, bp+8+uintptr(i)*28+8, uint64(4))
			case int32(PF_INET6):
				*(*Tsa_family_t)(unsafe.Pointer(out + uintptr(k)*88 + 48)) = uint16(PF_INET6)
				*(*Tin_port_t)(unsafe.Pointer(out + uintptr(k)*88 + 48 + 2)) = Xhtons(tls, (*(*[2]Tservice)(unsafe.Pointer(bp)))[j].Fport)
				*(*Tuint32_t)(unsafe.Pointer(out + uintptr(k)*88 + 48 + 24)) = (*(*[48]Taddress)(unsafe.Pointer(bp + 8)))[i].Fscopeid
				Xmemcpy(tls, out+uintptr(k)*88+48+8, bp+8+uintptr(i)*28+8, uint64(16))
				break
			}
			goto _4
		_4:
			;
			j++
			k++
		}
		goto _2
	_2:
		;
		i++
	}
	(*(*Taibuf)(unsafe.Pointer(out))).Fref = int16(nais)
	*(*uintptr)(unsafe.Pointer(res)) = out
	return 0
}

/* Define the "an address is configured" condition for address
 * families via ability to create a socket for the family plus
 * routability of the loopback address for the family. */
var _lo4 = Tsockaddr_in{
	Fsin_family: uint16(PF_INET),
	Fsin_port:   uint16(65535),
	Fsin_addr: Tin_addr{
		Fs_addr: uint32(0x0100007f),
	},
}

var _lo6 = Tsockaddr_in6{
	Fsin6_family: uint16(PF_INET6),
	Fsin6_port:   uint16(65535),
	Fsin6_addr: Tin6_addr{
		F__in6_union: *(*struct {
			F__s6_addr16 [0][8]Tuint16_t
			F__s6_addr32 [0][4]Tuint32_t
			F__s6_addr   [16]Tuint8_t
		})(unsafe.Pointer(&[16]Tuint8_t{
			15: uint8(1),
		})),
	},
}

const EAI_ADDRFAMILY = -9
const EAI_ALLDONE = -103
const EAI_CANCELED = -101
const EAI_IDN_ENCODE = -105
const EAI_INPROGRESS = -100
const EAI_INTR = -104
const EAI_NOTCANCELED = -102
const HOST_NOT_FOUND = 1
const MCAST_BLOCK_SOURCE = 43
const MCAST_EXCLUDE = 0
const MCAST_INCLUDE = 1
const MCAST_JOIN_GROUP = 42
const MCAST_JOIN_SOURCE_GROUP = 46
const MCAST_LEAVE_GROUP = 45
const MCAST_LEAVE_SOURCE_GROUP = 47
const MCAST_MSFILTER = 48
const MCAST_UNBLOCK_SOURCE = 44
const NI_MAXHOST = 255
const NI_MAXSERV = 32
const NO_ADDRESS = 4
const NO_DATA = 4
const NO_RECOVERY = 3
const TRY_AGAIN = 2
const h_errno = 0

type Tip_mreq = struct {
	Fimr_multiaddr Tin_addr
	Fimr_interface Tin_addr
}

type Tip_mreqn = struct {
	Fimr_multiaddr Tin_addr
	Fimr_address   Tin_addr
	Fimr_ifindex   int32
}

type Tip_mreq_source = struct {
	Fimr_multiaddr  Tin_addr
	Fimr_interface  Tin_addr
	Fimr_sourceaddr Tin_addr
}

type Tip_msfilter = struct {
	Fimsf_multiaddr Tin_addr
	Fimsf_interface Tin_addr
	Fimsf_fmode     Tuint32_t
	Fimsf_numsrc    Tuint32_t
	Fimsf_slist     [1]Tin_addr
}

type Tgroup_req = struct {
	Fgr_interface Tuint32_t
	Fgr_group     Tsockaddr_storage
}

type Tgroup_source_req = struct {
	Fgsr_interface Tuint32_t
	Fgsr_group     Tsockaddr_storage
	Fgsr_source    Tsockaddr_storage
}

type Tgroup_filter = struct {
	Fgf_interface Tuint32_t
	Fgf_group     Tsockaddr_storage
	Fgf_fmode     Tuint32_t
	Fgf_numsrc    Tuint32_t
	Fgf_slist     [1]Tsockaddr_storage
}

type Tin_pktinfo = struct {
	Fipi_ifindex  int32
	Fipi_spec_dst Tin_addr
	Fipi_addr     Tin_addr
}

type Tin6_pktinfo = struct {
	Fipi6_addr    Tin6_addr
	Fipi6_ifindex uint32
}

type Tip6_mtuinfo = struct {
	Fip6m_addr Tsockaddr_in6
	Fip6m_mtu  Tuint32_t
}

func Xgethostbyaddr(tls *TLS, a uintptr, l Tsocklen_t, af int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v a=%v l=%v af=%v, (%v:)", tls, a, l, af, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var err int32
	var size Tsize_t
	var _ /* res at bp+0 */ uintptr
	_, _ = err, size
	size = uint64(63)
	for cond := true; cond; cond = err == int32(ERANGE) {
		Xfree(tls, _h)
		size += size + uint64(1)
		_h = Xmalloc(tls, size)
		if !(_h != 0) {
			*(*int32)(unsafe.Pointer(X__h_errno_location(tls))) = int32(NO_RECOVERY)
			return uintptr(0)
		}
		err = Xgethostbyaddr_r(tls, a, l, af, _h, _h+UintptrFromInt32(1)*32, size-uint64(32), bp, X__h_errno_location(tls))
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

var _h uintptr

func Xgethostbyaddr_r(tls *TLS, a uintptr, l Tsocklen_t, af int32, h uintptr, buf uintptr, buflen Tsize_t, res uintptr, err uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v l=%v af=%v h=%v buf=%v buflen=%v res=%v err=%v, (%v:)", tls, a, l, af, h, buf, buflen, res, err, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i int32
	var sl Tsocklen_t
	var v1 uint64
	var _ /* sa at bp+0 */ struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}
	_, _, _ = i, sl, v1
	*(*struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	})(unsafe.Pointer(bp)) = struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}{}
	*(*uint16)(unsafe.Pointer(bp)) = uint16(af)
	if af == int32(PF_INET6) {
		v1 = uint64(28)
	} else {
		v1 = uint64(16)
	}
	sl = uint32(v1)
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	/* Load address argument into sockaddr structure */
	if af == int32(PF_INET6) && l == uint32(16) {
		Xmemcpy(tls, bp+8, a, uint64(16))
	} else {
		if af == int32(PF_INET) && l == uint32(4) {
			Xmemcpy(tls, bp+4, a, uint64(4))
		} else {
			*(*int32)(unsafe.Pointer(err)) = int32(NO_RECOVERY)
			return int32(EINVAL)
		}
	}
	/* Align buffer and check for space for pointers and ip address */
	i = int32(uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1)))
	if !(i != 0) {
		i = int32(8)
	}
	if buflen <= Uint64FromInt32(5)*Uint64FromInt64(8)-uint64(i)+uint64(l) {
		return int32(ERANGE)
	}
	buf += uintptr(uint64(8) - uint64(i))
	buflen -= Uint64FromInt32(5)*Uint64FromInt64(8) - uint64(i) + uint64(l)
	(*Thostent)(unsafe.Pointer(h)).Fh_addr_list = buf
	buf += uintptr(Uint64FromInt32(2) * Uint64FromInt64(8))
	(*Thostent)(unsafe.Pointer(h)).Fh_aliases = buf
	buf += uintptr(Uint64FromInt32(2) * Uint64FromInt64(8))
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list)) = buf
	Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list)), a, uint64(l))
	buf += uintptr(l)
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + 1*8)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases)) = buf
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8)) = uintptr(0)
	switch Xgetnameinfo(tls, bp, sl, buf, uint32(buflen), uintptr(0), uint32(0), 0) {
	case -int32(3):
		*(*int32)(unsafe.Pointer(err)) = int32(TRY_AGAIN)
		return int32(EAGAIN)
	case -int32(12):
		return int32(ERANGE)
	default:
		fallthrough
	case -int32(4):
		*(*int32)(unsafe.Pointer(err)) = int32(NO_RECOVERY)
		return int32(EBADMSG)
	case -int32(11):
		*(*int32)(unsafe.Pointer(err)) = int32(NO_RECOVERY)
		return *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	case 0:
		break
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_addrtype = af
	(*Thostent)(unsafe.Pointer(h)).Fh_length = int32(l)
	(*Thostent)(unsafe.Pointer(h)).Fh_name = *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases))
	*(*uintptr)(unsafe.Pointer(res)) = h
	return 0
}

func Xgethostbyname(tls *TLS, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgethostbyname2(tls, name, int32(PF_INET))
}

func Xgethostbyname2(tls *TLS, name uintptr, af int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v af=%v, (%v:)", tls, name, af, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var err int32
	var size Tsize_t
	var _ /* res at bp+0 */ uintptr
	_, _ = err, size
	size = uint64(63)
	for cond := true; cond; cond = err == int32(ERANGE) {
		Xfree(tls, _h1)
		size += size + uint64(1)
		_h1 = Xmalloc(tls, size)
		if !(_h1 != 0) {
			*(*int32)(unsafe.Pointer(X__h_errno_location(tls))) = int32(NO_RECOVERY)
			return uintptr(0)
		}
		err = Xgethostbyname2_r(tls, name, af, _h1, _h1+UintptrFromInt32(1)*32, size-uint64(32), bp, X__h_errno_location(tls))
	}
	return *(*uintptr)(unsafe.Pointer(bp))
}

var _h1 uintptr

func Xgethostbyname2_r(tls *TLS, name uintptr, af int32, h uintptr, buf uintptr, buflen Tsize_t, res uintptr, err uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v af=%v h=%v buf=%v buflen=%v res=%v err=%v, (%v:)", tls, name, af, h, buf, buflen, res, err, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(1600)
	defer tls.Free(1600)
	var align, need Tsize_t
	var cnt, i, v1 int32
	var v3 uintptr
	var _ /* addrs at bp+0 */ [48]Taddress
	var _ /* canon at bp+1344 */ [256]uint8
	_, _, _, _, _, _ = align, cnt, i, need, v1, v3
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	cnt = X__lookup_name(tls, bp, bp+1344, name, af, int32(AI_CANONNAME))
	if cnt < 0 {
		switch cnt {
		case -int32(2):
			*(*int32)(unsafe.Pointer(err)) = int32(HOST_NOT_FOUND)
			return 0
		case -int32(5):
			*(*int32)(unsafe.Pointer(err)) = int32(NO_DATA)
			return 0
		case -int32(3):
			*(*int32)(unsafe.Pointer(err)) = int32(TRY_AGAIN)
			return int32(EAGAIN)
		default:
			fallthrough
		case -int32(4):
			*(*int32)(unsafe.Pointer(err)) = int32(NO_RECOVERY)
			return int32(EBADMSG)
		case -int32(11):
			*(*int32)(unsafe.Pointer(err)) = int32(NO_RECOVERY)
			return *(*int32)(unsafe.Pointer(X__errno_location(tls)))
		}
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_addrtype = af
	if af == int32(PF_INET6) {
		v1 = int32(16)
	} else {
		v1 = int32(4)
	}
	(*Thostent)(unsafe.Pointer(h)).Fh_length = v1
	/* Align buffer */
	align = -uint64(buf) & (Uint64FromInt64(8) - Uint64FromInt32(1))
	need = Uint64FromInt32(4) * Uint64FromInt64(8)
	need += uint64(cnt+Int32FromInt32(1)) * (uint64(8) + uint64((*Thostent)(unsafe.Pointer(h)).Fh_length))
	need += Xstrlen(tls, name) + uint64(1)
	need += Xstrlen(tls, bp+1344) + uint64(1)
	need += align
	if need > buflen {
		return int32(ERANGE)
	}
	buf += uintptr(align)
	(*Thostent)(unsafe.Pointer(h)).Fh_aliases = buf
	buf += uintptr(Uint64FromInt32(3) * Uint64FromInt64(8))
	(*Thostent)(unsafe.Pointer(h)).Fh_addr_list = buf
	buf += uintptr(uint64(cnt+Int32FromInt32(1)) * uint64(8))
	i = 0
	for {
		if !(i < cnt) {
			break
		}
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)) = buf
		buf += uintptr((*Thostent)(unsafe.Pointer(h)).Fh_length)
		Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)), bp+uintptr(i)*28+8, uint64((*Thostent)(unsafe.Pointer(h)).Fh_length))
		goto _2
	_2:
		;
		i++
	}
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_addr_list + uintptr(i)*8)) = uintptr(0)
	v3 = buf
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases)) = v3
	(*Thostent)(unsafe.Pointer(h)).Fh_name = v3
	Xstrcpy(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name, bp+1344)
	buf += uintptr(Xstrlen(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name) + uint64(1))
	if Xstrcmp(tls, (*Thostent)(unsafe.Pointer(h)).Fh_name, name) != 0 {
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8)) = buf
		Xstrcpy(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8)), name)
		buf += uintptr(Xstrlen(tls, *(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8))) + uint64(1))
	} else {
		*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 1*8)) = uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer((*Thostent)(unsafe.Pointer(h)).Fh_aliases + 2*8)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(res)) = h
	return 0
}

func Xgethostbyname_r(tls *TLS, name uintptr, h uintptr, buf uintptr, buflen Tsize_t, res uintptr, err uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v h=%v buf=%v buflen=%v res=%v err=%v, (%v:)", tls, name, h, buf, buflen, res, err, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgethostbyname2_r(tls, name, int32(PF_INET), h, buf, buflen, res, err)
}

const IFADDRS_HASH_SIZE = 64
const IFA_ADDRESS = 1
const IFA_BROADCAST = 4
const IFA_LABEL = 3
const IFA_LOCAL = 2
const IFF_ALLMULTI = 512
const IFF_AUTOMEDIA = 16384
const IFF_BROADCAST = 2
const IFF_DEBUG = 4
const IFF_DORMANT = 131072
const IFF_DYNAMIC = 32768
const IFF_ECHO = 262144
const IFF_LOOPBACK = 8
const IFF_LOWER_UP = 65536
const IFF_MASTER = 1024
const IFF_MULTICAST = 4096
const IFF_NOARP = 128
const IFF_NOTRAILERS = 32
const IFF_POINTOPOINT = 16
const IFF_PORTSEL = 8192
const IFF_PROMISC = 256
const IFF_RUNNING = 64
const IFF_SLAVE = 2048
const IFF_UP = 1
const IFF_VOLATILE = 461914
const IFHWADDRLEN = 6
const IFLA_ADDRESS = 1
const IFLA_BROADCAST = 2
const IFLA_IFNAME = 3
const IFLA_STATS = 7
const IFNAMSIZ = 16
const IF_NAMESIZE = 16
const NETLINK_ROUTE = 0
const NLMSG_DONE = 3
const NLMSG_ERROR = 2
const NLMSG_NOOP = 1
const NLMSG_OVERRUN = 4
const NLM_F_ACK = 4
const NLM_F_ATOMIC = 1024
const NLM_F_DUMP = 768
const NLM_F_MATCH = 512
const NLM_F_MULTI = 2
const NLM_F_REQUEST = 1
const NLM_F_ROOT = 256
const RTM_GETADDR = 22
const RTM_GETLINK = 18
const RTM_NEWADDR = 20
const RTM_NEWLINK = 16
const __UAPI_DEF_IF_IFCONF = 0
const __UAPI_DEF_IF_IFMAP = 0
const __UAPI_DEF_IF_IFNAMSIZ = 0
const __UAPI_DEF_IF_IFREQ = 0
const __UAPI_DEF_IF_NET_DEVICE_FLAGS = 0
const __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO = 0

type Tifaddrs = struct {
	Fifa_next    uintptr
	Fifa_name    uintptr
	Fifa_flags   uint32
	Fifa_addr    uintptr
	Fifa_netmask uintptr
	Fifa_ifu     struct {
		Fifu_dstaddr   [0]uintptr
		Fifu_broadaddr uintptr
	}
	Fifa_data uintptr
}

type Tif_nameindex = struct {
	Fif_index uint32
	Fif_name  uintptr
}

type Tifaddr = struct {
	Fifa_addr Tsockaddr
	Fifa_ifu  struct {
		Fifu_dstaddr   [0]Tsockaddr
		Fifu_broadaddr Tsockaddr
	}
	Fifa_ifp  uintptr
	Fifa_next uintptr
}

type Tifmap = struct {
	Fmem_start uint64
	Fmem_end   uint64
	Fbase_addr uint16
	Firq       uint8
	Fdma       uint8
	Fport      uint8
}

type Tifreq = struct {
	Fifr_ifrn struct {
		Fifrn_name [16]uint8
	}
	Fifr_ifru struct {
		Fifru_dstaddr   [0]Tsockaddr
		Fifru_broadaddr [0]Tsockaddr
		Fifru_netmask   [0]Tsockaddr
		Fifru_hwaddr    [0]Tsockaddr
		Fifru_flags     [0]int16
		Fifru_ivalue    [0]int32
		Fifru_mtu       [0]int32
		Fifru_map       [0]Tifmap
		Fifru_slave     [0][16]uint8
		Fifru_newname   [0][16]uint8
		Fifru_data      [0]uintptr
		Fifru_addr      Tsockaddr
		F__ccgo_pad12   [8]byte
	}
}

type Tifconf = struct {
	Fifc_len  int32
	Fifc_ifcu struct {
		Fifcu_req [0]uintptr
		Fifcu_buf uintptr
	}
}

type Tnlmsghdr = struct {
	Fnlmsg_len   Tuint32_t
	Fnlmsg_type  Tuint16_t
	Fnlmsg_flags Tuint16_t
	Fnlmsg_seq   Tuint32_t
	Fnlmsg_pid   Tuint32_t
}

type Trtattr = struct {
	Frta_len  uint16
	Frta_type uint16
}

type Trtgenmsg = struct {
	Frtgen_family uint8
}

type Tifinfomsg = struct {
	Fifi_family uint8
	F__ifi_pad  uint8
	Fifi_type   uint16
	Fifi_index  int32
	Fifi_flags  uint32
	Fifi_change uint32
}

type Tifaddrmsg = struct {
	Fifa_family    Tuint8_t
	Fifa_prefixlen Tuint8_t
	Fifa_flags     Tuint8_t
	Fifa_scope     Tuint8_t
	Fifa_index     Tuint32_t
}

/* getifaddrs() reports hardware addresses with PF_PACKET that implies
 * struct sockaddr_ll.  But e.g. Infiniband socket address length is
 * longer than sockaddr_ll.ssl_addr[8] can hold. Use this hack struct
 * to extend ssl_addr - callers should be able to still use it. */
type Tsockaddr_ll_hack = struct {
	Fsll_family   uint16
	Fsll_protocol uint16
	Fsll_ifindex  int32
	Fsll_hatype   uint16
	Fsll_pkttype  uint8
	Fsll_halen    uint8
	Fsll_addr     [24]uint8
}

type Tsockany = struct {
	Fll          [0]Tsockaddr_ll_hack
	Fv4          [0]Tsockaddr_in
	Fv6          [0]Tsockaddr_in6
	Fsa          Tsockaddr
	F__ccgo_pad4 [20]byte
}

type Tifaddrs_storage = struct {
	Fifa       Tifaddrs
	Fhash_next uintptr
	Faddr      Tsockany
	Fnetmask   Tsockany
	Fifu       Tsockany
	Findex     uint32
	Fname      [17]uint8
}

type Tifaddrs_ctx = struct {
	Ffirst uintptr
	Flast  uintptr
	Fhash  [64]uintptr
}

func Xfreeifaddrs(tls *TLS, ifp uintptr) {
	if __ccgo_strace {
		trc("tls=%v ifp=%v, (%v:)", tls, ifp, origin(2))
	}
	var n uintptr
	_ = n
	for ifp != 0 {
		n = (*Tifaddrs)(unsafe.Pointer(ifp)).Fifa_next
		Xfree(tls, ifp)
		ifp = n
	}
}

func _copy_addr(tls *TLS, r uintptr, af int32, sa uintptr, addr uintptr, addrlen Tsize_t, ifindex int32) {
	var dst uintptr
	var len1 int32
	_, _ = dst, len1
	switch af {
	case int32(PF_INET):
		dst = sa + 4
		len1 = int32(4)
	case int32(PF_INET6):
		dst = sa + 8
		len1 = int32(16)
		if int32(*(*Tuint8_t)(unsafe.Pointer(addr))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(addr + 1)))&int32(0xc0) == int32(0x80) || int32(*(*Tuint8_t)(unsafe.Pointer(addr))) == int32(0xff) && int32(*(*Tuint8_t)(unsafe.Pointer(addr + 1)))&int32(0xf) == int32(0x2) {
			(*(*Tsockaddr_in6)(unsafe.Pointer(sa))).Fsin6_scope_id = uint32(ifindex)
		}
	default:
		return
	}
	if addrlen < uint64(len1) {
		return
	}
	(*Tsockany)(unsafe.Pointer(sa)).Fsa.Fsa_family = uint16(af)
	Xmemcpy(tls, dst, addr, uint64(len1))
	*(*uintptr)(unsafe.Pointer(r)) = sa
}

func _gen_netmask(tls *TLS, r uintptr, af int32, sa uintptr, prefixlen int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, v1 int32
	var _ /* addr at bp+0 */ [16]Tuint8_t
	_, _ = i, v1
	*(*[16]Tuint8_t)(unsafe.Pointer(bp)) = [16]Tuint8_t{}
	if uint64(prefixlen) > Uint64FromInt32(8)*Uint64FromInt64(16) {
		prefixlen = int32(Uint64FromInt32(8) * Uint64FromInt64(16))
	}
	i = prefixlen / int32(8)
	Xmemset(tls, bp, int32(0xff), uint64(i))
	if uint64(i) < uint64(16) {
		v1 = i
		i++
		(*(*[16]Tuint8_t)(unsafe.Pointer(bp)))[v1] = uint8(int32(0xff) << (int32(8) - prefixlen%int32(8)))
	}
	_copy_addr(tls, r, af, sa, bp, uint64(16), 0)
}

func _copy_lladdr(tls *TLS, r uintptr, sa uintptr, addr uintptr, addrlen Tsize_t, ifindex int32, hatype uint16) {
	if addrlen > uint64(24) {
		return
	}
	(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_family = uint16(PF_PACKET)
	(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_ifindex = ifindex
	(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_hatype = hatype
	(*(*Tsockaddr_ll_hack)(unsafe.Pointer(sa))).Fsll_halen = uint8(addrlen)
	Xmemcpy(tls, sa+12, addr, addrlen)
	*(*uintptr)(unsafe.Pointer(r)) = sa
}

func _netlink_msg_to_ifaddr(tls *TLS, pctx uintptr, h uintptr) (r int32) {
	var bucket uint32
	var ctx, ifa, ifi, ifs, ifs0, rta uintptr
	var stats_len int32
	_, _, _, _, _, _, _, _ = bucket, ctx, ifa, ifi, ifs, ifs0, rta, stats_len
	ctx = pctx
	ifi = h + UintptrFromInt64(16)
	ifa = h + UintptrFromInt64(16)
	stats_len = 0
	if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(RTM_NEWLINK) {
		rta = h + UintptrFromInt64(16) + uintptr((Uint64FromInt64(16)+Uint64FromInt32(3))&uint64(^Int32FromInt32(3)))
		for {
			if !(uint64(int64(h+uintptr((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len))-int64(rta)) >= uint64(4)) {
				break
			}
			if int32((*Trtattr)(unsafe.Pointer(rta)).Frta_type) != int32(IFLA_STATS) {
				goto _1
			}
			stats_len = int32(uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len) - Uint64FromInt64(4))
			break
			goto _1
		_1:
			;
			rta = rta + uintptr((int32((*Trtattr)(unsafe.Pointer(rta)).Frta_len)+Int32FromInt32(3)) & ^Int32FromInt32(3))
		}
	} else {
		ifs0 = *(*uintptr)(unsafe.Pointer(ctx + 16 + uintptr((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index%uint32(IFADDRS_HASH_SIZE))*8))
		for {
			if !(ifs0 != 0) {
				break
			}
			if (*Tifaddrs_storage)(unsafe.Pointer(ifs0)).Findex == (*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index {
				break
			}
			goto _2
		_2:
			;
			ifs0 = (*Tifaddrs_storage)(unsafe.Pointer(ifs0)).Fhash_next
		}
		if !(ifs0 != 0) {
			return 0
		}
	}
	ifs = Xcalloc(tls, uint64(1), uint64(200)+uint64(stats_len))
	if ifs == uintptr(0) {
		return -int32(1)
	}
	if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(RTM_NEWLINK) {
		(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Findex = uint32((*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_index)
		(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_flags = (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_flags
		rta = h + UintptrFromInt64(16) + uintptr((Uint64FromInt64(16)+Uint64FromInt32(3))&uint64(^Int32FromInt32(3)))
		for {
			if !(uint64(int64(h+uintptr((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len))-int64(rta)) >= uint64(4)) {
				break
			}
			switch int32((*Trtattr)(unsafe.Pointer(rta)).Frta_type) {
			case int32(IFLA_IFNAME):
				if uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-uint64(4) < uint64(17) {
					Xmemcpy(tls, ifs+176, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4))
					(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name = ifs + 176
				}
			case int32(IFLA_ADDRESS):
				_copy_lladdr(tls, ifs+24, ifs+64, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_index, (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_type)
			case int32(IFLA_BROADCAST):
				_copy_lladdr(tls, ifs+40, ifs+136, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_index, (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_type)
			case int32(IFLA_STATS):
				(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_data = ifs + UintptrFromInt32(1)*200
				Xmemcpy(tls, (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_data, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4))
				break
			}
			goto _3
		_3:
			;
			rta = rta + uintptr((int32((*Trtattr)(unsafe.Pointer(rta)).Frta_len)+Int32FromInt32(3)) & ^Int32FromInt32(3))
		}
		if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name != 0 {
			bucket = (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Findex % uint32(IFADDRS_HASH_SIZE)
			(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fhash_next = *(*uintptr)(unsafe.Pointer(ctx + 16 + uintptr(bucket)*8))
			*(*uintptr)(unsafe.Pointer(ctx + 16 + uintptr(bucket)*8)) = ifs
		}
	} else {
		(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name = (*Tifaddrs_storage)(unsafe.Pointer(ifs0)).Fifa.Fifa_name
		(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_flags = (*Tifaddrs_storage)(unsafe.Pointer(ifs0)).Fifa.Fifa_flags
		rta = h + UintptrFromInt64(16) + uintptr((Uint64FromInt64(8)+Uint64FromInt32(3))&uint64(^Int32FromInt32(3)))
		for {
			if !(uint64(int64(h+uintptr((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len))-int64(rta)) >= uint64(4)) {
				break
			}
			switch int32((*Trtattr)(unsafe.Pointer(rta)).Frta_type) {
			case int32(IFA_ADDRESS):
				/* If ifa_addr is already set we, received an IFA_LOCAL before
				 * so treat this as destination address */
				if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr != 0 {
					_copy_addr(tls, ifs+40, int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+136, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index))
				} else {
					_copy_addr(tls, ifs+24, int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+64, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index))
				}
			case int32(IFA_BROADCAST):
				_copy_addr(tls, ifs+40, int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+136, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index))
			case int32(IFA_LOCAL):
				/* If ifa_addr is set and we get IFA_LOCAL, assume we have
				 * a point-to-point network. Move address to correct field. */
				if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr != 0 {
					(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifu = (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Faddr
					*(*uintptr)(unsafe.Pointer(ifs + 40)) = ifs + 136
					Xmemset(tls, ifs+64, 0, uint64(36))
				}
				_copy_addr(tls, ifs+24, int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+64, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4), int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index))
			case int32(IFA_LABEL):
				if uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-uint64(4) < uint64(17) {
					Xmemcpy(tls, ifs+176, rta+UintptrFromInt64(4), uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len)-Uint64FromInt64(4))
					(*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name = ifs + 176
				}
				break
			}
			goto _4
		_4:
			;
			rta = rta + uintptr((int32((*Trtattr)(unsafe.Pointer(rta)).Frta_len)+Int32FromInt32(3)) & ^Int32FromInt32(3))
		}
		if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_addr != 0 {
			_gen_netmask(tls, ifs+32, int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_family), ifs+100, int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_prefixlen))
		}
	}
	if (*Tifaddrs_storage)(unsafe.Pointer(ifs)).Fifa.Fifa_name != 0 {
		if !((*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Ffirst != 0) {
			(*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Ffirst = ifs
		}
		if (*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Flast != 0 {
			(*Tifaddrs)(unsafe.Pointer((*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Flast)).Fifa_next = ifs
		}
		(*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Flast = ifs
	} else {
		Xfree(tls, ifs)
	}
	return 0
}

func Xgetifaddrs(tls *TLS, ifap uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v ifap=%v, (%v:)", tls, ifap, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(528)
	defer tls.Free(528)
	var ctx uintptr
	var r int32
	var _ /* _ctx at bp+0 */ Tifaddrs_ctx
	_, _ = ctx, r
	ctx = bp
	Xmemset(tls, ctx, 0, uint64(528))
	r = X__rtnetlink_enumerate(tls, PF_UNSPEC, PF_UNSPEC, __ccgo_fp(_netlink_msg_to_ifaddr), ctx)
	if r == 0 {
		*(*uintptr)(unsafe.Pointer(ifap)) = (*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Ffirst
	} else {
		Xfreeifaddrs(tls, (*Tifaddrs_ctx)(unsafe.Pointer(ctx)).Ffirst)
	}
	return r
}

const RR_PTR = 12

func _itoa(tls *TLS, p uintptr, x uint32) (r uintptr) {
	var v1, v2 uintptr
	_, _ = v1, v2
	p += uintptr(Uint64FromInt32(3) * Uint64FromInt64(4))
	p--
	v1 = p
	*(*uint8)(unsafe.Pointer(v1)) = uint8(0)
	for cond := true; cond; cond = x != 0 {
		p--
		v2 = p
		*(*uint8)(unsafe.Pointer(v2)) = uint8(uint32('0') + x%uint32(10))
		x /= uint32(10)
	}
	return p
}

func _mkptr4(tls *TLS, s uintptr, ip uintptr) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	Xsprintf(tls, s, __ccgo_ts+982, VaList(bp+8, int32(*(*uint8)(unsafe.Pointer(ip + 3))), int32(*(*uint8)(unsafe.Pointer(ip + 2))), int32(*(*uint8)(unsafe.Pointer(ip + 1))), int32(*(*uint8)(unsafe.Pointer(ip)))))
}

func _mkptr6(tls *TLS, s uintptr, ip uintptr) {
	var i int32
	var v2, v3, v4, v5 uintptr
	_, _, _, _, _ = i, v2, v3, v4, v5
	i = int32(15)
	for {
		if !(i >= 0) {
			break
		}
		v2 = s
		s++
		*(*uint8)(unsafe.Pointer(v2)) = _xdigits[int32(*(*uint8)(unsafe.Pointer(ip + uintptr(i))))&int32(15)]
		v3 = s
		s++
		*(*uint8)(unsafe.Pointer(v3)) = uint8('.')
		v4 = s
		s++
		*(*uint8)(unsafe.Pointer(v4)) = _xdigits[int32(*(*uint8)(unsafe.Pointer(ip + uintptr(i))))>>int32(4)]
		v5 = s
		s++
		*(*uint8)(unsafe.Pointer(v5)) = uint8('.')
		goto _1
	_1:
		;
		i--
	}
	Xstrcpy(tls, s, __ccgo_ts+1007)
}

var _xdigits = [17]uint8{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}

func _reverse_hosts(tls *TLS, buf uintptr, a uintptr, scopeid uint32, family int32) {
	bp := tls.Alloc(1824)
	defer tls.Free(1824)
	var f, p, z, v1, v2, v8 uintptr
	var v10, v11, v15, v16, v4, v5 int32
	var v13, v18, v7 bool
	var _ /* _buf at bp+512 */ [1032]uint8
	var _ /* _f at bp+1592 */ TFILE
	var _ /* atmp at bp+1544 */ [16]uint8
	var _ /* iplit at bp+1560 */ Taddress
	var _ /* line at bp+0 */ [512]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = f, p, z, v1, v10, v11, v13, v15, v16, v18, v2, v4, v5, v7, v8
	f = X__fopen_rb_ca(tls, __ccgo_ts+1016, bp+1592, bp+512, uint64(1032))
	if !(f != 0) {
		return
	}
	if family == int32(PF_INET) {
		Xmemcpy(tls, bp+1544+uintptr(12), a, uint64(4))
		Xmemcpy(tls, bp+1544, __ccgo_ts+1027, uint64(12))
		a = bp + 1544
	}
	for Xfgets(tls, bp, int32(512), f) != 0 {
		v1 = Xstrchr(tls, bp, int32('#'))
		p = v1
		if v1 != 0 {
			v2 = p
			p++
			*(*uint8)(unsafe.Pointer(v2)) = uint8('\n')
			*(*uint8)(unsafe.Pointer(p)) = Uint8FromInt32(0)
		}
		p = bp
		for {
			if v7 = *(*uint8)(unsafe.Pointer(p)) != 0; v7 {
				v4 = int32(*(*uint8)(unsafe.Pointer(p)))
				v5 = BoolInt32(v4 == int32(' ') || uint32(v4)-uint32('\t') < uint32(5))
				goto _6
			_6:
			}
			if !(v7 && !(v5 != 0)) {
				break
			}
			goto _3
		_3:
			;
			p++
		}
		if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			continue
		}
		v8 = p
		p++
		*(*uint8)(unsafe.Pointer(v8)) = uint8(0)
		if X__lookup_ipliteral(tls, bp+1560, bp, PF_UNSPEC) <= 0 {
			continue
		}
		if (*(*Taddress)(unsafe.Pointer(bp + 1560))).Ffamily == int32(PF_INET) {
			Xmemcpy(tls, bp+1560+8+uintptr(12), bp+1560+8, uint64(4))
			Xmemcpy(tls, bp+1560+8, __ccgo_ts+1027, uint64(12))
			(*(*Taddress)(unsafe.Pointer(bp + 1560))).Fscopeid = uint32(0)
		}
		if Xmemcmp(tls, a, bp+1560+8, uint64(16)) != 0 || (*(*Taddress)(unsafe.Pointer(bp + 1560))).Fscopeid != scopeid {
			continue
		}
		for {
			if v13 = *(*uint8)(unsafe.Pointer(p)) != 0; v13 {
				v10 = int32(*(*uint8)(unsafe.Pointer(p)))
				v11 = BoolInt32(v10 == int32(' ') || uint32(v10)-uint32('\t') < uint32(5))
				goto _12
			_12:
			}
			if !(v13 && v11 != 0) {
				break
			}
			goto _9
		_9:
			;
			p++
		}
		z = p
		for {
			if v18 = *(*uint8)(unsafe.Pointer(z)) != 0; v18 {
				v15 = int32(*(*uint8)(unsafe.Pointer(z)))
				v16 = BoolInt32(v15 == int32(' ') || uint32(v15)-uint32('\t') < uint32(5))
				goto _17
			_17:
			}
			if !(v18 && !(v16 != 0)) {
				break
			}
			goto _14
		_14:
			;
			z++
		}
		*(*uint8)(unsafe.Pointer(z)) = uint8(0)
		if int64(z)-int64(p) < int64(256) {
			Xmemcpy(tls, buf, p, uint64(int64(z)-int64(p)+int64(1)))
			break
		}
	}
	X__fclose_ca(tls, f)
}

func _reverse_services(tls *TLS, buf uintptr, port int32, dgram int32) {
	bp := tls.Alloc(1408)
	defer tls.Free(1408)
	var f, p, v1, v2, v8 uintptr
	var svport uint64
	var v4, v5 int32
	var v7 bool
	var _ /* _buf at bp+136 */ [1032]uint8
	var _ /* _f at bp+1168 */ TFILE
	var _ /* line at bp+0 */ [128]uint8
	var _ /* z at bp+128 */ uintptr
	_, _, _, _, _, _, _, _, _ = f, p, svport, v1, v2, v4, v5, v7, v8
	f = X__fopen_rb_ca(tls, __ccgo_ts+1040, bp+1168, bp+136, uint64(1032))
	if !(f != 0) {
		return
	}
	for Xfgets(tls, bp, int32(128), f) != 0 {
		v1 = Xstrchr(tls, bp, int32('#'))
		p = v1
		if v1 != 0 {
			v2 = p
			p++
			*(*uint8)(unsafe.Pointer(v2)) = uint8('\n')
			*(*uint8)(unsafe.Pointer(p)) = Uint8FromInt32(0)
		}
		p = bp
		for {
			if v7 = *(*uint8)(unsafe.Pointer(p)) != 0; v7 {
				v4 = int32(*(*uint8)(unsafe.Pointer(p)))
				v5 = BoolInt32(v4 == int32(' ') || uint32(v4)-uint32('\t') < uint32(5))
				goto _6
			_6:
			}
			if !(v7 && !(v5 != 0)) {
				break
			}
			goto _3
		_3:
			;
			p++
		}
		if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			continue
		}
		v8 = p
		p++
		*(*uint8)(unsafe.Pointer(v8)) = uint8(0)
		svport = Xstrtoul(tls, p, bp+128, int32(10))
		if svport != uint64(port) || *(*uintptr)(unsafe.Pointer(bp + 128)) == p {
			continue
		}
		if dgram != 0 && Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), __ccgo_ts+1054, uint64(4)) != 0 {
			continue
		}
		if !(dgram != 0) && Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), __ccgo_ts+1059, uint64(4)) != 0 {
			continue
		}
		if int64(p)-t__predefined_ptrdiff_t(bp) > int64(32) {
			continue
		}
		Xmemcpy(tls, buf, bp, uint64(int64(p)-t__predefined_ptrdiff_t(bp)))
		break
	}
	X__fclose_ca(tls, f)
}

func _dns_parse_callback(tls *TLS, c uintptr, rr int32, data uintptr, len1 int32, packet uintptr, plen int32) (r int32) {
	if rr != int32(RR_PTR) {
		return 0
	}
	if X__dn_expand(tls, packet, packet+uintptr(plen), data, c, int32(256)) <= 0 {
		*(*uint8)(unsafe.Pointer(c)) = uint8(0)
	}
	return 0
}

func Xgetnameinfo(tls *TLS, sa uintptr, sl Tsocklen_t, node uintptr, nodelen Tsocklen_t, serv uintptr, servlen Tsocklen_t, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v sa=%v sl=%v node=%v nodelen=%v serv=%v servlen=%v flags=%v, (%v:)", tls, sa, sl, node, nodelen, serv, servlen, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(976)
	defer tls.Free(976)
	var a, p, p1, v1 uintptr
	var af, port, qlen, rlen int32
	var scopeid uint32
	var _ /* buf at bp+78 */ [256]uint8
	var _ /* num at bp+334 */ [13]uint8
	var _ /* ptr at bp+0 */ [78]uint8
	var _ /* query at bp+347 */ [96]uint8
	var _ /* reply at bp+443 */ [512]uint8
	var _ /* tmp at bp+955 */ [17]uint8
	_, _, _, _, _, _, _, _, _ = a, af, p, p1, port, qlen, rlen, scopeid, v1
	af = int32((*Tsockaddr)(unsafe.Pointer(sa)).Fsa_family)
	switch af {
	case int32(PF_INET):
		a = sa + 4
		if uint64(sl) < uint64(16) {
			return -int32(6)
		}
		_mkptr4(tls, bp, a)
		scopeid = uint32(0)
	case int32(PF_INET6):
		a = sa + 8
		if uint64(sl) < uint64(28) {
			return -int32(6)
		}
		if Xmemcmp(tls, a, __ccgo_ts+1027, uint64(12)) != 0 {
			_mkptr6(tls, bp, a)
		} else {
			_mkptr4(tls, bp, a+uintptr(12))
		}
		scopeid = (*Tsockaddr_in6)(unsafe.Pointer(sa)).Fsin6_scope_id
	default:
		return -int32(6)
	}
	if node != 0 && nodelen != 0 {
		(*(*[256]uint8)(unsafe.Pointer(bp + 78)))[0] = uint8(0)
		if !(flags&Int32FromInt32(NI_NUMERICHOST) != 0) {
			_reverse_hosts(tls, bp+78, a, scopeid, af)
		}
		if !(*(*uint8)(unsafe.Pointer(bp + 78)) != 0) && !(flags&Int32FromInt32(NI_NUMERICHOST) != 0) {
			qlen = X__res_mkquery(tls, 0, bp, int32(1), int32(RR_PTR), uintptr(0), 0, uintptr(0), bp+347, int32(96))
			(*(*[96]uint8)(unsafe.Pointer(bp + 347)))[int32(3)] = uint8(0) /* don't need AD flag */
			rlen = X__res_send(tls, bp+347, qlen, bp+443, int32(512))
			(*(*[256]uint8)(unsafe.Pointer(bp + 78)))[0] = uint8(0)
			if rlen > 0 {
				if uint64(rlen) > uint64(512) {
					rlen = int32(512)
				}
				X__dns_parse(tls, bp+443, rlen, __ccgo_fp(_dns_parse_callback), bp+78)
			}
		}
		if !(*(*uint8)(unsafe.Pointer(bp + 78)) != 0) {
			if flags&int32(NI_NAMEREQD) != 0 {
				return -int32(2)
			}
			Xinet_ntop(tls, af, a, bp+78, uint32(256))
			if scopeid != 0 {
				p = uintptr(0)
				if !(flags&Int32FromInt32(NI_NUMERICSCOPE) != 0) && (int32(*(*Tuint8_t)(unsafe.Pointer(a))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(a + 1)))&int32(0xc0) == int32(0x80) || int32(*(*Tuint8_t)(unsafe.Pointer(a))) == int32(0xff) && int32(*(*Tuint8_t)(unsafe.Pointer(a + 1)))&int32(0xf) == int32(0x2)) {
					p = Xif_indextoname(tls, scopeid, bp+955+uintptr(1))
				}
				if !(p != 0) {
					p = _itoa(tls, bp+334, scopeid)
				}
				p--
				v1 = p
				*(*uint8)(unsafe.Pointer(v1)) = uint8('%')
				Xstrcat(tls, bp+78, p)
			}
		}
		if Xstrlen(tls, bp+78) >= uint64(nodelen) {
			return -int32(12)
		}
		Xstrcpy(tls, node, bp+78)
	}
	if serv != 0 && servlen != 0 {
		p1 = bp + 78
		port = int32(Xntohs(tls, (*Tsockaddr_in)(unsafe.Pointer(sa)).Fsin_port))
		(*(*[256]uint8)(unsafe.Pointer(bp + 78)))[0] = uint8(0)
		if !(flags&Int32FromInt32(NI_NUMERICSERV) != 0) {
			_reverse_services(tls, bp+78, port, flags&int32(NI_DGRAM))
		}
		if !(*(*uint8)(unsafe.Pointer(p1)) != 0) {
			p1 = _itoa(tls, bp+334, uint32(port))
		}
		if Xstrlen(tls, p1) >= uint64(servlen) {
			return -int32(12)
		}
		Xstrcpy(tls, serv, p1)
	}
	return 0
}

func Xgetpeername(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v addr=%v len1=%v, (%v:)", tls, fd, addr, len1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_getpeername)
	_ = int32(__SC_getpeername)
	v2 = int64(fd)
	v3 = int64(addr)
	v4 = int64(len1)
	v5 = int64(Int32FromInt32(0))
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return int32(X__syscall_ret(tls, uint64(v8)))
}

func Xgetservbyname(tls *TLS, name uintptr, prots uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v prots=%v, (%v:)", tls, name, prots, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* res at bp+0 */ uintptr
	if Xgetservbyname_r(tls, name, prots, uintptr(unsafe.Pointer(&_se)), uintptr(unsafe.Pointer(&_buf3)), uint64(16), bp) != 0 {
		return uintptr(0)
	}
	return uintptr(unsafe.Pointer(&_se))
}

var _se Tservent

var _buf3 [2]uintptr

const ALIGN = 0

func Xgetservbyname_r(tls *TLS, name uintptr, prots uintptr, se uintptr, buf uintptr, buflen Tsize_t, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v prots=%v se=%v buf=%v buflen=%v res=%v, (%v:)", tls, name, prots, se, buf, buflen, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var align, cnt, proto int32
	var v1 uintptr
	var _ /* end at bp+8 */ uintptr
	var _ /* servs at bp+0 */ [2]Tservice
	_, _, _, _ = align, cnt, proto, v1
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	/* Don't treat numeric port number strings as service records. */
	*(*uintptr)(unsafe.Pointer(bp + 8)) = __ccgo_ts
	Xstrtoul(tls, name, bp+8, int32(10))
	if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0) {
		return int32(ENOENT)
	}
	/* Align buffer */
	align = int32(-uint64(buf) & (Uint64FromInt64(16) - Uint64FromInt64(8) - Uint64FromInt32(1)))
	if buflen < Uint64FromInt32(2)*Uint64FromInt64(8)+uint64(align) {
		return int32(ERANGE)
	}
	buf += uintptr(align)
	if !(prots != 0) {
		proto = 0
	} else {
		if !(Xstrcmp(tls, prots, __ccgo_ts+1064) != 0) {
			proto = int32(IPPROTO_TCP)
		} else {
			if !(Xstrcmp(tls, prots, __ccgo_ts+1068) != 0) {
				proto = int32(IPPROTO_UDP)
			} else {
				return int32(EINVAL)
			}
		}
	}
	cnt = X__lookup_serv(tls, bp, name, proto, 0, 0)
	if cnt < 0 {
		switch cnt {
		case -int32(10):
			fallthrough
		case -int32(11):
			return int32(ENOMEM)
		default:
			return int32(ENOENT)
		}
	}
	(*Tservent)(unsafe.Pointer(se)).Fs_name = name
	(*Tservent)(unsafe.Pointer(se)).Fs_aliases = buf
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases)) = (*Tservent)(unsafe.Pointer(se)).Fs_name
	*(*uintptr)(unsafe.Pointer((*Tservent)(unsafe.Pointer(se)).Fs_aliases + 1*8)) = uintptr(0)
	(*Tservent)(unsafe.Pointer(se)).Fs_port = int32(Xhtons(tls, (*(*[2]Tservice)(unsafe.Pointer(bp)))[0].Fport))
	if int32((*(*[2]Tservice)(unsafe.Pointer(bp)))[0].Fproto) == int32(IPPROTO_TCP) {
		v1 = __ccgo_ts + 1064
	} else {
		v1 = __ccgo_ts + 1068
	}
	(*Tservent)(unsafe.Pointer(se)).Fs_proto = v1
	*(*uintptr)(unsafe.Pointer(res)) = se
	return 0
}

func Xgetsockname(tls *TLS, fd int32, addr uintptr, len1 uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v addr=%v len1=%v, (%v:)", tls, fd, addr, len1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_getsockname)
	_ = int32(__SC_getsockname)
	v2 = int64(fd)
	v3 = int64(addr)
	v4 = int64(len1)
	v5 = int64(Int32FromInt32(0))
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return int32(X__syscall_ret(tls, uint64(v8)))
}

func Xgetsockopt(tls *TLS, fd int32, level int32, optname int32, optval uintptr, optlen uintptr) (r2 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v level=%v optname=%v optval=%v optlen=%v, (%v:)", tls, fd, level, optname, optval, optlen, origin(2))
		defer func() { trc("-> %v", r2) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var r, v17, v26, v8 int64
	var r1, v1, v10, v19 int32
	var tv uintptr
	var v11, v12, v13, v14, v15, v16, v2, v20, v21, v22, v23, v24, v25, v3, v4, v5, v6, v7 Tsyscall_arg_t
	var _ /* tv32 at bp+8 */ [2]int64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = r, r1, tv, v1, v10, v11, v12, v13, v14, v15, v16, v17, v19, v2, v20, v21, v22, v23, v24, v25, v26, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_getsockopt)
	_ = int32(__SC_getsockopt)
	v2 = int64(fd)
	v3 = int64(level)
	v4 = int64(optname)
	v5 = int64(optval)
	v6 = int64(optlen)
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	r1 = int32(v8)
	if r1 == -int32(ENOPROTOOPT) {
		switch level {
		case int32(SOL_SOCKET):
			switch optname {
			case int32(SO_RCVTIMEO):
				fallthrough
			case int32(SO_SNDTIMEO):
				if true {
					break
				}
				if uint64(*(*Tsocklen_t)(unsafe.Pointer(optlen))) < uint64(16) {
					return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
				}
				if optname == int32(SO_RCVTIMEO) {
					optname = int32(SO_RCVTIMEO_OLD)
				}
				if optname == int32(SO_SNDTIMEO) {
					optname = int32(SO_SNDTIMEO_OLD)
				}
				*(*[1]Tsocklen_t)(unsafe.Pointer(bp)) = [1]Tsocklen_t{
					0: uint32(16),
				}
				v10 = int32(SYS_getsockopt)
				_ = int32(__SC_getsockopt)
				v11 = int64(fd)
				v12 = int64(level)
				v13 = int64(optname)
				v14 = int64(bp + 8)
				v15 = int64(bp)
				v16 = int64(Int32FromInt32(0))
				if 0 != 0 {
					r = ___syscall_cp(tls, int64(v10), v11, v12, v13, v14, v15, v16)
				} else {
					r = X__syscall6(tls, int64(v10), v11, v12, v13, v14, v15, v16)
				}
				if r != int64(-Int32FromInt32(ENOSYS)) {
					v17 = r
					goto _18
				}
				v17 = r
				goto _18
			_18:
				r1 = int32(v17)
				if r1 < 0 {
					break
				}
				tv = optval
				(*Ttimeval)(unsafe.Pointer(tv)).Ftv_sec = (*(*[2]int64)(unsafe.Pointer(bp + 8)))[0]
				(*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec = (*(*[2]int64)(unsafe.Pointer(bp + 8)))[int32(1)]
				*(*Tsocklen_t)(unsafe.Pointer(optlen)) = uint32(16)
			case int32(SO_TIMESTAMP):
				fallthrough
			case int32(SO_TIMESTAMPNS):
				if true {
					break
				}
				if optname == int32(SO_TIMESTAMP) {
					optname = int32(SO_TIMESTAMP_OLD)
				}
				if optname == int32(SO_TIMESTAMPNS) {
					optname = int32(SO_TIMESTAMPNS_OLD)
				}
				v19 = int32(SYS_getsockopt)
				_ = int32(__SC_getsockopt)
				v20 = int64(fd)
				v21 = int64(level)
				v22 = int64(optname)
				v23 = int64(optval)
				v24 = int64(optlen)
				v25 = int64(Int32FromInt32(0))
				if 0 != 0 {
					r = ___syscall_cp(tls, int64(v19), v20, v21, v22, v23, v24, v25)
				} else {
					r = X__syscall6(tls, int64(v19), v20, v21, v22, v23, v24, v25)
				}
				if r != int64(-Int32FromInt32(ENOSYS)) {
					v26 = r
					goto _27
				}
				v26 = r
				goto _27
			_27:
				r1 = int32(v26)
				break
			}
		}
	}
	return int32(X__syscall_ret(tls, uint64(r1)))
}

func X__h_errno_location(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if !((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Fstack != 0) {
		return uintptr(unsafe.Pointer(&Xh_errno))
	}
	return ___get_tp(tls) + 144
}

func Xherror(tls *TLS, msg uintptr) {
	if __ccgo_strace {
		trc("tls=%v msg=%v, (%v:)", tls, msg, origin(2))
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var v1, v2 uintptr
	_, _ = v1, v2
	if msg != 0 {
		v1 = msg
	} else {
		v1 = __ccgo_ts
	}
	if msg != 0 {
		v2 = __ccgo_ts + 289
	} else {
		v2 = __ccgo_ts
	}
	Xfprintf(tls, uintptr(unsafe.Pointer(&X__stderr_FILE)), __ccgo_ts+1072, VaList(bp+8, v1, v2, Xhstrerror(tls, *(*int32)(unsafe.Pointer(X__h_errno_location(tls))))))
}

type Tcpu_set_t1 = struct {
	F__bits [16]uint64
}

type Tucontext_t5 = struct {
	Fuc_flags    uint64
	Fuc_link     uintptr
	Fuc_stack    Tstack_t
	Fuc_sigmask  Tsigset_t
	Fuc_mcontext Tmcontext_t1
}

var _msgs1 = [84]uint8{'H', 'o', 's', 't', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'T', 'r', 'y', ' ', 'a', 'g', 'a', 'i', 'n', 0, 'N', 'o', 'n', '-', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'a', 'b', 'l', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'A', 'd', 'd', 'r', 'e', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r'}

func Xhstrerror(tls *TLS, ecode int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v ecode=%v, (%v:)", tls, ecode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var s uintptr
	_ = s
	s = uintptr(unsafe.Pointer(&_msgs1))
	ecode--
	for {
		if !(ecode != 0 && *(*uint8)(unsafe.Pointer(s)) != 0) {
			break
		}
		for {
			if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
				break
			}
			goto _2
		_2:
			;
			s++
		}
		goto _1
	_1:
		;
		ecode--
		s++
	}
	if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
		s++
	}
	return X__lctrans_cur(tls, s)
}
func Xhtonl(tls *TLS, n Tuint32_t) (r Tuint32_t) {
	if __ccgo_strace {
		trc("tls=%v n=%v, (%v:)", tls, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var u struct {
		Fc [0]uint8
		Fi int32
	}
	var v1 uint32
	var v2, v3 Tuint32_t
	_, _, _, _ = u, v1, v2, v3
	u = *(*struct {
		Fc [0]uint8
		Fi int32
	})(unsafe.Pointer(&struct{ f int32 }{f: int32(1)}))
	if *(*uint8)(unsafe.Pointer(&u)) != 0 {
		v2 = n
		v3 = v2>>int32(24) | v2>>int32(8)&uint32(0xff00) | v2<<int32(8)&uint32(0xff0000) | v2<<int32(24)
		goto _4
	_4:
		v1 = v3
	} else {
		v1 = n
	}
	return v1
}

func Xhtons(tls *TLS, n Tuint16_t) (r Tuint16_t) {
	if __ccgo_strace {
		trc("tls=%v n=%v, (%v:)", tls, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var u struct {
		Fc [0]uint8
		Fi int32
	}
	var v1 int32
	var v2, v3 Tuint16_t
	_, _, _, _ = u, v1, v2, v3
	u = *(*struct {
		Fc [0]uint8
		Fi int32
	})(unsafe.Pointer(&struct{ f int32 }{f: int32(1)}))
	if *(*uint8)(unsafe.Pointer(&u)) != 0 {
		v2 = n
		v3 = uint16(int32(v2)<<int32(8) | int32(v2)>>int32(8))
		goto _4
	_4:
		v1 = int32(v3)
	} else {
		v1 = int32(n)
	}
	return uint16(v1)
}

func Xif_freenameindex(tls *TLS, idx uintptr) {
	if __ccgo_strace {
		trc("tls=%v idx=%v, (%v:)", tls, idx, origin(2))
	}
	Xfree(tls, idx)
}

func Xif_indextoname(tls *TLS, index uint32, name uintptr) (r1 uintptr) {
	if __ccgo_strace {
		trc("tls=%v index=%v name=%v, (%v:)", tls, index, name, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var fd, r, v1 int32
	var _ /* ifr at bp+0 */ Tifreq
	_, _, _ = fd, r, v1
	v1 = Xsocket(tls, int32(PF_LOCAL), Int32FromInt32(SOCK_DGRAM)|Int32FromInt32(SOCK_CLOEXEC), 0)
	fd = v1
	if v1 < 0 {
		return uintptr(0)
	}
	*(*int32)(unsafe.Pointer(bp + 16)) = int32(index)
	r = Xioctl(tls, fd, int32(SIOCGIFNAME), VaList(bp+48, bp))
	X__syscall1(tls, int64(SYS_close), int64(fd))
	if r < 0 {
		if *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(ENODEV) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENXIO)
		}
		return uintptr(0)
	}
	return Xstrncpy(tls, name, bp, uint64(IF_NAMESIZE))
}

type Tifnamemap = struct {
	Fhash_next uint32
	Findex     uint32
	Fnamelen   uint8
	Fname      [16]uint8
}

type Tifnameindexctx = struct {
	Fnum       uint32
	Fallocated uint32
	Fstr_bytes uint32
	Flist      uintptr
	Fhash      [64]uint32
}

func _netlink_msg_to_nameindex(tls *TLS, pctx uintptr, h uintptr) (r int32) {
	var a Tsize_t
	var bucket, index, namelen, type1 int32
	var ctx, ifa, ifi, map1, rta uintptr
	var i, v2 uint32
	_, _, _, _, _, _, _, _, _, _, _, _ = a, bucket, ctx, i, ifa, ifi, index, map1, namelen, rta, type1, v2
	ctx = pctx
	if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(RTM_NEWLINK) {
		ifi = h + UintptrFromInt64(16)
		index = (*Tifinfomsg)(unsafe.Pointer(ifi)).Fifi_index
		type1 = int32(IFLA_IFNAME)
		rta = h + UintptrFromInt64(16) + uintptr((Uint64FromInt64(16)+Uint64FromInt32(3))&uint64(^Int32FromInt32(3)))
	} else {
		ifa = h + UintptrFromInt64(16)
		index = int32((*Tifaddrmsg)(unsafe.Pointer(ifa)).Fifa_index)
		type1 = int32(IFA_LABEL)
		rta = h + UintptrFromInt64(16) + uintptr((Uint64FromInt64(8)+Uint64FromInt32(3))&uint64(^Int32FromInt32(3)))
	}
	for {
		if !(uint64(int64(h+uintptr((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len))-int64(rta)) >= uint64(4)) {
			break
		}
		if int32((*Trtattr)(unsafe.Pointer(rta)).Frta_type) != type1 {
			goto _1
		}
		namelen = int32(uint64((*Trtattr)(unsafe.Pointer(rta)).Frta_len) - uint64(4) - uint64(1))
		if namelen > int32(IF_NAMESIZE) {
			return 0
		}
		/* suppress duplicates */
		bucket = index % int32(IFADDRS_HASH_SIZE)
		i = *(*uint32)(unsafe.Pointer(ctx + 24 + uintptr(bucket)*4))
		for i != 0 {
			map1 = (*Tifnameindexctx)(unsafe.Pointer(ctx)).Flist + uintptr(i-uint32(1))*28
			if (*Tifnamemap)(unsafe.Pointer(map1)).Findex == uint32(index) && int32((*Tifnamemap)(unsafe.Pointer(map1)).Fnamelen) == namelen && Xmemcmp(tls, map1+9, rta+UintptrFromInt64(4), uint64(namelen)) == 0 {
				return 0
			}
			i = (*Tifnamemap)(unsafe.Pointer(map1)).Fhash_next
		}
		if (*Tifnameindexctx)(unsafe.Pointer(ctx)).Fnum >= (*Tifnameindexctx)(unsafe.Pointer(ctx)).Fallocated {
			if (*Tifnameindexctx)(unsafe.Pointer(ctx)).Fallocated != 0 {
				v2 = (*Tifnameindexctx)(unsafe.Pointer(ctx)).Fallocated*uint32(2) + uint32(1)
			} else {
				v2 = uint32(8)
			}
			a = uint64(v2)
			if a > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt64(28) {
				return -int32(1)
			}
			map1 = Xrealloc(tls, (*Tifnameindexctx)(unsafe.Pointer(ctx)).Flist, a*uint64(28))
			if !(map1 != 0) {
				return -int32(1)
			}
			(*Tifnameindexctx)(unsafe.Pointer(ctx)).Flist = map1
			(*Tifnameindexctx)(unsafe.Pointer(ctx)).Fallocated = uint32(a)
		}
		map1 = (*Tifnameindexctx)(unsafe.Pointer(ctx)).Flist + uintptr((*Tifnameindexctx)(unsafe.Pointer(ctx)).Fnum)*28
		(*Tifnamemap)(unsafe.Pointer(map1)).Findex = uint32(index)
		(*Tifnamemap)(unsafe.Pointer(map1)).Fnamelen = uint8(namelen)
		Xmemcpy(tls, map1+9, rta+UintptrFromInt64(4), uint64(namelen))
		*(*uint32)(unsafe.Pointer(ctx + 8)) += uint32(namelen + int32(1))
		(*Tifnameindexctx)(unsafe.Pointer(ctx)).Fnum++
		(*Tifnamemap)(unsafe.Pointer(map1)).Fhash_next = *(*uint32)(unsafe.Pointer(ctx + 24 + uintptr(bucket)*4))
		*(*uint32)(unsafe.Pointer(ctx + 24 + uintptr(bucket)*4)) = (*Tifnameindexctx)(unsafe.Pointer(ctx)).Fnum
		return 0
		goto _1
	_1:
		;
		rta = rta + uintptr((int32((*Trtattr)(unsafe.Pointer(rta)).Frta_len)+Int32FromInt32(3)) & ^Int32FromInt32(3))
	}
	return 0
}

func Xif_nameindex(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(288)
	defer tls.Free(288)
	var ctx, d, ifs, p, s, v2 uintptr
	var i int32
	var _ /* _ctx at bp+0 */ Tifnameindexctx
	var _ /* cs at bp+280 */ int32
	_, _, _, _, _, _, _ = ctx, d, i, ifs, p, s, v2
	ctx = bp
	ifs = uintptr(0)
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+280)
	Xmemset(tls, ctx, 0, uint64(280))
	if X__rtnetlink_enumerate(tls, PF_UNSPEC, int32(PF_INET), __ccgo_fp(_netlink_msg_to_nameindex), ctx) < 0 {
		goto err
	}
	ifs = Xmalloc(tls, uint64((*Tifnameindexctx)(unsafe.Pointer(ctx)).Fnum+Uint32FromInt32(1))*16+uint64((*Tifnameindexctx)(unsafe.Pointer(ctx)).Fstr_bytes))
	if !(ifs != 0) {
		goto err
	}
	p = ifs + uintptr((*Tifnameindexctx)(unsafe.Pointer(ctx)).Fnum)*16 + UintptrFromInt32(1)*16
	i = int32((*Tifnameindexctx)(unsafe.Pointer(ctx)).Fnum)
	d = ifs
	s = (*Tifnameindexctx)(unsafe.Pointer(ctx)).Flist
	for {
		if !(i != 0) {
			break
		}
		(*Tif_nameindex)(unsafe.Pointer(d)).Fif_index = (*Tifnamemap)(unsafe.Pointer(s)).Findex
		(*Tif_nameindex)(unsafe.Pointer(d)).Fif_name = p
		Xmemcpy(tls, p, s+9, uint64((*Tifnamemap)(unsafe.Pointer(s)).Fnamelen))
		p += uintptr((*Tifnamemap)(unsafe.Pointer(s)).Fnamelen)
		v2 = p
		p++
		*(*uint8)(unsafe.Pointer(v2)) = uint8(0)
		goto _1
	_1:
		;
		i--
		s += 28
		d += 16
	}
	(*Tif_nameindex)(unsafe.Pointer(d)).Fif_index = uint32(0)
	(*Tif_nameindex)(unsafe.Pointer(d)).Fif_name = uintptr(0)
	goto err
err:
	;
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 280)), uintptr(0))
	Xfree(tls, (*Tifnameindexctx)(unsafe.Pointer(ctx)).Flist)
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOBUFS)
	return ifs
}

func Xif_nametoindex(tls *TLS, name uintptr) (r1 uint32) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var fd, r, v1, v2 int32
	var _ /* ifr at bp+0 */ Tifreq
	_, _, _, _ = fd, r, v1, v2
	v1 = Xsocket(tls, int32(PF_LOCAL), Int32FromInt32(SOCK_DGRAM)|Int32FromInt32(SOCK_CLOEXEC), 0)
	fd = v1
	if v1 < 0 {
		return uint32(0)
	}
	Xstrncpy(tls, bp, name, uint64(16))
	r = Xioctl(tls, fd, int32(SIOCGIFINDEX), VaList(bp+48, bp))
	X__syscall1(tls, int64(SYS_close), int64(fd))
	if r < 0 {
		v2 = 0
	} else {
		v2 = *(*int32)(unsafe.Pointer(bp + 16))
	}
	return uint32(v2)
}

func Xinet_addr(tls *TLS, p uintptr) (r Tin_addr_t) {
	if __ccgo_strace {
		trc("tls=%v p=%v, (%v:)", tls, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* a at bp+0 */ Tin_addr
	if !(X__inet_aton(tls, p, bp) != 0) {
		return uint32(-Int32FromInt32(1))
	}
	return (*(*Tin_addr)(unsafe.Pointer(bp))).Fs_addr
}

func X__inet_aton(tls *TLS, s0 uintptr, dest uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s0=%v dest=%v, (%v:)", tls, s0, dest, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var d, s uintptr
	var i int32
	var _ /* a at bp+0 */ [4]uint64
	var _ /* z at bp+32 */ uintptr
	_, _, _ = d, i, s
	s = s0
	d = dest
	*(*[4]uint64)(unsafe.Pointer(bp)) = [4]uint64{}
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		(*(*[4]uint64)(unsafe.Pointer(bp)))[i] = Xstrtoul(tls, s, bp+32, 0)
		if *(*uintptr)(unsafe.Pointer(bp + 32)) == s || *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32))))) != int32('.') || !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			return 0
		}
		if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))) != 0) {
			break
		}
		s = *(*uintptr)(unsafe.Pointer(bp + 32)) + uintptr(1)
		goto _1
	_1:
		;
		i++
	}
	if i == int32(4) {
		return 0
	}
	switch i {
	case 0:
		(*(*[4]uint64)(unsafe.Pointer(bp)))[int32(1)] = (*(*[4]uint64)(unsafe.Pointer(bp)))[0] & uint64(0xffffff)
		*(*uint64)(unsafe.Pointer(bp)) >>= uint64(24)
		fallthrough
	case int32(1):
		(*(*[4]uint64)(unsafe.Pointer(bp)))[int32(2)] = (*(*[4]uint64)(unsafe.Pointer(bp)))[int32(1)] & uint64(0xffff)
		*(*uint64)(unsafe.Pointer(bp + 1*8)) >>= uint64(16)
		fallthrough
	case int32(2):
		(*(*[4]uint64)(unsafe.Pointer(bp)))[int32(3)] = (*(*[4]uint64)(unsafe.Pointer(bp)))[int32(2)] & uint64(0xff)
		*(*uint64)(unsafe.Pointer(bp + 2*8)) >>= uint64(8)
	}
	i = 0
	for {
		if !(i < int32(4)) {
			break
		}
		if (*(*[4]uint64)(unsafe.Pointer(bp)))[i] > uint64(255) {
			return 0
		}
		*(*uint8)(unsafe.Pointer(d + uintptr(i))) = uint8((*(*[4]uint64)(unsafe.Pointer(bp)))[i])
		goto _2
	_2:
		;
		i++
	}
	return int32(1)
}

func Xinet_aton(tls *TLS, s0 uintptr, dest uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s0=%v dest=%v, (%v:)", tls, s0, dest, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__inet_aton(tls, s0, dest)
}

func Xinet_network(tls *TLS, p uintptr) (r Tin_addr_t) {
	if __ccgo_strace {
		trc("tls=%v p=%v, (%v:)", tls, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xntohl(tls, Xinet_addr(tls, p))
}

func Xinet_makeaddr(tls *TLS, n Tin_addr_t, h Tin_addr_t) (r Tin_addr) {
	if __ccgo_strace {
		trc("tls=%v n=%v h=%v, (%v:)", tls, n, h, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if n < uint32(256) {
		h |= n << int32(24)
	} else {
		if n < uint32(65536) {
			h |= n << int32(16)
		} else {
			h |= n << int32(8)
		}
	}
	return Tin_addr{
		Fs_addr: h,
	}
}

func Xinet_lnaof(tls *TLS, in Tin_addr) (r Tin_addr_t) {
	if __ccgo_strace {
		trc("tls=%v in=%v, (%v:)", tls, in, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var h Tuint32_t
	_ = h
	h = in.Fs_addr
	if h>>int32(24) < uint32(128) {
		return h & uint32(0xffffff)
	}
	if h>>int32(24) < uint32(192) {
		return h & uint32(0xffff)
	}
	return h & uint32(0xff)
}

func Xinet_netof(tls *TLS, in Tin_addr) (r Tin_addr_t) {
	if __ccgo_strace {
		trc("tls=%v in=%v, (%v:)", tls, in, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var h Tuint32_t
	_ = h
	h = in.Fs_addr
	if h>>int32(24) < uint32(128) {
		return h >> int32(24)
	}
	if h>>int32(24) < uint32(192) {
		return h >> int32(16)
	}
	return h >> int32(8)
}

func Xinet_ntoa(tls *TLS, _in Tin_addr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v _in=%v, (%v:)", tls, _in, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	*(*Tin_addr)(unsafe.Pointer(bp)) = _in
	var a uintptr
	_ = a
	a = bp
	Xsnprintf(tls, uintptr(unsafe.Pointer(&_buf4)), uint64(16), __ccgo_ts+1080, VaList(bp+16, int32(*(*uint8)(unsafe.Pointer(a))), int32(*(*uint8)(unsafe.Pointer(a + 1))), int32(*(*uint8)(unsafe.Pointer(a + 2))), int32(*(*uint8)(unsafe.Pointer(a + 3)))))
	return uintptr(unsafe.Pointer(&_buf4))
}

var _buf4 [16]uint8

func Xinet_ntop(tls *TLS, af int32, a0 uintptr, s uintptr, l Tsocklen_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v af=%v a0=%v s=%v l=%v, (%v:)", tls, af, a0, s, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(192)
	defer tls.Free(192)
	var a uintptr
	var best, i, j, max, v2 int32
	var v3 uint8
	var _ /* buf at bp+0 */ [100]uint8
	_, _, _, _, _, _, _ = a, best, i, j, max, v2, v3
	a = a0
	switch af {
	case int32(PF_INET):
		if uint32(Xsnprintf(tls, s, uint64(l), __ccgo_ts+1080, VaList(bp+112, int32(*(*uint8)(unsafe.Pointer(a))), int32(*(*uint8)(unsafe.Pointer(a + 1))), int32(*(*uint8)(unsafe.Pointer(a + 2))), int32(*(*uint8)(unsafe.Pointer(a + 3)))))) < l {
			return s
		}
	case int32(PF_INET6):
		if Xmemcmp(tls, a, __ccgo_ts+1027, uint64(12)) != 0 {
			Xsnprintf(tls, bp, uint64(100), __ccgo_ts+1092, VaList(bp+112, int32(256)*int32(*(*uint8)(unsafe.Pointer(a)))+int32(*(*uint8)(unsafe.Pointer(a + 1))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 2)))+int32(*(*uint8)(unsafe.Pointer(a + 3))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 4)))+int32(*(*uint8)(unsafe.Pointer(a + 5))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 6)))+int32(*(*uint8)(unsafe.Pointer(a + 7))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 8)))+int32(*(*uint8)(unsafe.Pointer(a + 9))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 10)))+int32(*(*uint8)(unsafe.Pointer(a + 11))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 12)))+int32(*(*uint8)(unsafe.Pointer(a + 13))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 14)))+int32(*(*uint8)(unsafe.Pointer(a + 15)))))
		} else {
			Xsnprintf(tls, bp, uint64(100), __ccgo_ts+1116, VaList(bp+112, int32(256)*int32(*(*uint8)(unsafe.Pointer(a)))+int32(*(*uint8)(unsafe.Pointer(a + 1))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 2)))+int32(*(*uint8)(unsafe.Pointer(a + 3))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 4)))+int32(*(*uint8)(unsafe.Pointer(a + 5))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 6)))+int32(*(*uint8)(unsafe.Pointer(a + 7))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 8)))+int32(*(*uint8)(unsafe.Pointer(a + 9))), int32(256)*int32(*(*uint8)(unsafe.Pointer(a + 10)))+int32(*(*uint8)(unsafe.Pointer(a + 11))), int32(*(*uint8)(unsafe.Pointer(a + 12))), int32(*(*uint8)(unsafe.Pointer(a + 13))), int32(*(*uint8)(unsafe.Pointer(a + 14))), int32(*(*uint8)(unsafe.Pointer(a + 15)))))
		}
		/* Replace longest /(^0|:)[:0]{2,}/ with "::" */
		v2 = Int32FromInt32(0)
		best = v2
		i = v2
		max = Int32FromInt32(2)
		for {
			if !((*(*[100]uint8)(unsafe.Pointer(bp)))[i] != 0) {
				break
			}
			if i != 0 && int32((*(*[100]uint8)(unsafe.Pointer(bp)))[i]) != int32(':') {
				goto _1
			}
			j = int32(Xstrspn(tls, bp+uintptr(i), __ccgo_ts+1146))
			if j > max {
				best = i
				max = j
			}
			goto _1
		_1:
			;
			i++
		}
		if max > int32(3) {
			v3 = Uint8FromUint8(':')
			(*(*[100]uint8)(unsafe.Pointer(bp)))[best+int32(1)] = v3
			(*(*[100]uint8)(unsafe.Pointer(bp)))[best] = v3
			Xmemmove(tls, bp+uintptr(best)+uintptr(2), bp+uintptr(best)+uintptr(max), uint64(i-best-max+int32(1)))
		}
		if Xstrlen(tls, bp) < uint64(l) {
			Xstrcpy(tls, s, bp)
			return s
		}
	default:
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EAFNOSUPPORT)
		return uintptr(0)
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOSPC)
	return uintptr(0)
}

func _hexval(tls *TLS, c uint32) (r int32) {
	if c-uint32('0') < uint32(10) {
		return int32(c - uint32('0'))
	}
	c |= uint32(32)
	if c-uint32('a') < uint32(6) {
		return int32(c - uint32('a') + uint32(10))
	}
	return -int32(1)
}

func Xinet_pton(tls *TLS, af int32, s uintptr, a0 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v af=%v s=%v a0=%v, (%v:)", tls, af, s, a0, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var a, v14, v15, v4, v7 uintptr
	var brk, d, i, j, need_v4, v, v10, v3, v9 int32
	var v11, v5 bool
	var _ /* ip at bp+0 */ [8]Tuint16_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, brk, d, i, j, need_v4, v, v10, v11, v14, v15, v3, v4, v5, v7, v9
	a = a0
	brk = -int32(1)
	need_v4 = 0
	if af == int32(PF_INET) {
		i = 0
		for {
			if !(i < int32(4)) {
				break
			}
			v3 = Int32FromInt32(0)
			j = v3
			v = v3
			for {
				if !(j < int32(3) && BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s + uintptr(j))))-uint32('0') < uint32(10)) != 0) {
					break
				}
				v = int32(10)*v + int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) - int32('0')
				goto _2
			_2:
				;
				j++
			}
			if j == 0 || j > int32(1) && int32(*(*uint8)(unsafe.Pointer(s))) == int32('0') || v > int32(255) {
				return 0
			}
			*(*uint8)(unsafe.Pointer(a + uintptr(i))) = uint8(v)
			if int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) == 0 && i == int32(3) {
				return int32(1)
			}
			if int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) != int32('.') {
				return 0
			}
			s += uintptr(j + int32(1))
			goto _1
		_1:
			;
			i++
		}
		return 0
	} else {
		if af != int32(PF_INET6) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EAFNOSUPPORT)
			return -int32(1)
		}
	}
	if v5 = int32(*(*uint8)(unsafe.Pointer(s))) == int32(':'); v5 {
		s++
		v4 = s
	}
	if v5 && int32(*(*uint8)(unsafe.Pointer(v4))) != int32(':') {
		return 0
	}
	i = 0
	for {
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32(':') && brk < 0 {
			brk = i
			(*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[i&int32(7)] = uint16(0)
			s++
			v7 = s
			if !(*(*uint8)(unsafe.Pointer(v7)) != 0) {
				break
			}
			if i == int32(7) {
				return 0
			}
			goto _6
		}
		v9 = Int32FromInt32(0)
		j = v9
		v = v9
		for {
			if v11 = j < int32(4); v11 {
				v10 = _hexval(tls, uint32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))))
				d = v10
			}
			if !(v11 && v10 >= 0) {
				break
			}
			v = int32(16)*v + d
			goto _8
		_8:
			;
			j++
		}
		if j == 0 {
			return 0
		}
		(*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[i&int32(7)] = uint16(v)
		if !(*(*uint8)(unsafe.Pointer(s + uintptr(j))) != 0) && (brk >= 0 || i == int32(7)) {
			break
		}
		if i == int32(7) {
			return 0
		}
		if int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) != int32(':') {
			if int32(*(*uint8)(unsafe.Pointer(s + uintptr(j)))) != int32('.') || i < int32(6) && brk < 0 {
				return 0
			}
			need_v4 = int32(1)
			i++
			(*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[i&int32(7)] = uint16(0)
			break
		}
		s += uintptr(j + int32(1))
		goto _6
	_6:
		;
		i++
	}
	if brk >= 0 {
		Xmemmove(tls, bp+uintptr(brk)*2+uintptr(7)*2-uintptr(i)*2, bp+uintptr(brk)*2, uint64(int32(2)*(i+int32(1)-brk)))
		j = 0
		for {
			if !(j < int32(7)-i) {
				break
			}
			(*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[brk+j] = uint16(0)
			goto _12
		_12:
			;
			j++
		}
	}
	j = 0
	for {
		if !(j < int32(8)) {
			break
		}
		v14 = a
		a++
		*(*uint8)(unsafe.Pointer(v14)) = uint8(int32((*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[j]) >> int32(8))
		v15 = a
		a++
		*(*uint8)(unsafe.Pointer(v15)) = uint8((*(*[8]Tuint16_t)(unsafe.Pointer(bp)))[j])
		goto _13
	_13:
		;
		j++
	}
	if need_v4 != 0 && Xinet_pton(tls, int32(PF_INET), s, a-uintptr(4)) <= 0 {
		return 0
	}
	return int32(1)
}

func Xlisten(tls *TLS, fd int32, backlog int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v backlog=%v, (%v:)", tls, fd, backlog, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_listen)
	_ = int32(__SC_listen)
	v2 = int64(fd)
	v3 = int64(backlog)
	v4 = int64(Int32FromInt32(0))
	v5 = int64(Int32FromInt32(0))
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return int32(X__syscall_ret(tls, uint64(v8)))
}

func X__lookup_ipliteral(tls *TLS, buf uintptr, name uintptr, family int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v buf=%v name=%v family=%v, (%v:)", tls, buf, name, family, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var p, v1 uintptr
	var scopeid uint64
	var _ /* a4 at bp+0 */ Tin_addr
	var _ /* a6 at bp+4 */ Tin6_addr
	var _ /* tmp at bp+20 */ [64]uint8
	var _ /* z at bp+88 */ uintptr
	_, _, _ = p, scopeid, v1
	if X__inet_aton(tls, name, bp) > 0 {
		if family == int32(PF_INET6) { /* wrong family */
			return -int32(5)
		}
		Xmemcpy(tls, buf+8, bp, uint64(4))
		(*(*Taddress)(unsafe.Pointer(buf))).Ffamily = int32(PF_INET)
		(*(*Taddress)(unsafe.Pointer(buf))).Fscopeid = uint32(0)
		return int32(1)
	}
	p = Xstrchr(tls, name, int32('%'))
	scopeid = uint64(0)
	if p != 0 && int64(p)-int64(name) < int64(64) {
		Xmemcpy(tls, bp+20, name, uint64(int64(p)-int64(name)))
		(*(*[64]uint8)(unsafe.Pointer(bp + 20)))[int64(p)-int64(name)] = uint8(0)
		name = bp + 20
	}
	if Xinet_pton(tls, int32(PF_INET6), name, bp+4) <= 0 {
		return 0
	}
	if family == int32(PF_INET) { /* wrong family */
		return -int32(5)
	}
	Xmemcpy(tls, buf+8, bp+4, uint64(16))
	(*(*Taddress)(unsafe.Pointer(buf))).Ffamily = int32(PF_INET6)
	if p != 0 {
		p++
		v1 = p
		if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(v1)))-uint32('0') < uint32(10)) != 0 {
			scopeid = Xstrtoull(tls, p, bp+88, int32(10))
		} else {
			*(*uintptr)(unsafe.Pointer(bp + 88)) = p - uintptr(1)
		}
		if *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88)))) != 0 {
			if !(int32(*(*Tuint8_t)(unsafe.Pointer(bp + 4))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(bp + 4 + 1)))&int32(0xc0) == int32(0x80)) && !(int32(*(*Tuint8_t)(unsafe.Pointer(bp + 4))) == int32(0xff) && int32(*(*Tuint8_t)(unsafe.Pointer(bp + 4 + 1)))&int32(0xf) == int32(0x2)) {
				return -int32(2)
			}
			scopeid = uint64(Xif_nametoindex(tls, p))
			if !(scopeid != 0) {
				return -int32(2)
			}
		}
		if scopeid > uint64(0xffffffff) {
			return -int32(2)
		}
	}
	(*(*Taddress)(unsafe.Pointer(buf))).Fscopeid = uint32(scopeid)
	return int32(1)
}

const ABUF_SIZE = 4800
const DAS_MATCHINGLABEL = 268435456
const DAS_MATCHINGSCOPE = 536870912
const DAS_ORDER_SHIFT = 0
const DAS_PREC_SHIFT = 20
const DAS_PREFIX_SHIFT = 8
const DAS_SCOPE_SHIFT = 16
const DAS_USABLE = 1073741824
const RR_A = 1
const RR_AAAA = 28
const RR_CNAME = 5

func _is_valid_hostname(tls *TLS, host uintptr) (r int32) {
	var s uintptr
	_ = s
	if Xstrnlen(tls, host, uint64(255))-uint64(1) >= uint64(254) || Xmbstowcs(tls, uintptr(0), host, uint64(0)) == uint64(-Int32FromInt32(1)) {
		return 0
	}
	s = host
	for {
		if !(int32(*(*uint8)(unsafe.Pointer(s))) >= int32(0x80) || int32(*(*uint8)(unsafe.Pointer(s))) == int32('.') || int32(*(*uint8)(unsafe.Pointer(s))) == int32('-') || Xisalnum(tls, int32(*(*uint8)(unsafe.Pointer(s)))) != 0) {
			break
		}
		goto _1
	_1:
		;
		s++
	}
	return BoolInt32(!(*(*uint8)(unsafe.Pointer(s)) != 0))
}

func _name_from_null(tls *TLS, buf uintptr, name uintptr, family int32, flags int32) (r int32) {
	var cnt, v1, v2, v3, v4 int32
	_, _, _, _, _ = cnt, v1, v2, v3, v4
	cnt = 0
	if name != 0 {
		return 0
	}
	if flags&int32(AI_PASSIVE) != 0 {
		if family != int32(PF_INET6) {
			v1 = cnt
			cnt++
			*(*Taddress)(unsafe.Pointer(buf + uintptr(v1)*28)) = Taddress{
				Ffamily: int32(PF_INET),
			}
		}
		if family != int32(PF_INET) {
			v2 = cnt
			cnt++
			*(*Taddress)(unsafe.Pointer(buf + uintptr(v2)*28)) = Taddress{
				Ffamily: int32(PF_INET6),
			}
		}
	} else {
		if family != int32(PF_INET6) {
			v3 = cnt
			cnt++
			*(*Taddress)(unsafe.Pointer(buf + uintptr(v3)*28)) = Taddress{
				Ffamily: int32(PF_INET),
				Faddr: [16]Tuint8_t{
					0: uint8(127),
					3: uint8(1),
				},
			}
		}
		if family != int32(PF_INET) {
			v4 = cnt
			cnt++
			*(*Taddress)(unsafe.Pointer(buf + uintptr(v4)*28)) = Taddress{
				Ffamily: int32(PF_INET6),
				Faddr: [16]Tuint8_t{
					15: uint8(1),
				},
			}
		}
	}
	return cnt
}

func _name_from_numeric(tls *TLS, buf uintptr, name uintptr, family int32) (r int32) {
	return X__lookup_ipliteral(tls, buf, name, family)
}

func _name_from_hosts(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32) (r int32) {
	bp := tls.Alloc(1776)
	defer tls.Free(1776)
	var badfam, cnt, have_canon, v14, v15, v20, v21, v25, v26, v29, v5, v6, v8, v9 int32
	var f, p, z, v1, v18, v2, v4 uintptr
	var l Tsize_t
	var v11, v12, v17, v23, v28 bool
	var _ /* _buf at bp+512 */ [1032]uint8
	var _ /* _f at bp+1544 */ TFILE
	var _ /* line at bp+0 */ [512]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = badfam, cnt, f, have_canon, l, p, z, v1, v11, v12, v14, v15, v17, v18, v2, v20, v21, v23, v25, v26, v28, v29, v4, v5, v6, v8, v9
	l = Xstrlen(tls, name)
	cnt = 0
	badfam = 0
	have_canon = 0
	f = X__fopen_rb_ca(tls, __ccgo_ts+1016, bp+1544, bp+512, uint64(1032))
	if !(f != 0) {
		switch *(*int32)(unsafe.Pointer(X__errno_location(tls))) {
		case int32(ENOENT):
			fallthrough
		case int32(ENOTDIR):
			fallthrough
		case int32(EACCES):
			return 0
		default:
			return -int32(11)
		}
	}
	for Xfgets(tls, bp, int32(512), f) != 0 && cnt < int32(MAXADDRS) {
		v1 = Xstrchr(tls, bp, int32('#'))
		p = v1
		if v1 != 0 {
			v2 = p
			p++
			*(*uint8)(unsafe.Pointer(v2)) = uint8('\n')
			*(*uint8)(unsafe.Pointer(p)) = Uint8FromInt32(0)
		}
		p = bp + uintptr(1)
		for {
			v4 = Xstrstr(tls, p, name)
			p = v4
			if v12 = v4 != 0; v12 {
				v5 = int32(*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1)))))
				v6 = BoolInt32(v5 == int32(' ') || uint32(v5)-uint32('\t') < uint32(5))
				goto _7
			_7:
				;
				if v11 = !(v6 != 0); !v11 {
					v8 = int32(*(*uint8)(unsafe.Pointer(p + uintptr(l))))
					v9 = BoolInt32(v8 == int32(' ') || uint32(v8)-uint32('\t') < uint32(5))
					goto _10
				_10:
				}
			}
			if !(v12 && (v11 || !(v9 != 0))) {
				break
			}
			goto _3
		_3:
			;
			p++
		}
		if !(p != 0) {
			continue
		}
		/* Isolate IP address to parse */
		p = bp
		for {
			if v17 = *(*uint8)(unsafe.Pointer(p)) != 0; v17 {
				v14 = int32(*(*uint8)(unsafe.Pointer(p)))
				v15 = BoolInt32(v14 == int32(' ') || uint32(v14)-uint32('\t') < uint32(5))
				goto _16
			_16:
			}
			if !(v17 && !(v15 != 0)) {
				break
			}
			goto _13
		_13:
			;
			p++
		}
		v18 = p
		p++
		*(*uint8)(unsafe.Pointer(v18)) = uint8(0)
		switch _name_from_numeric(tls, buf+uintptr(cnt)*28, bp, family) {
		case int32(1):
			cnt++
		case 0:
			continue
		default:
			badfam = -int32(5)
			break
		}
		if have_canon != 0 {
			continue
		}
		/* Extract first name as canonical name */
		for {
			if v23 = *(*uint8)(unsafe.Pointer(p)) != 0; v23 {
				v20 = int32(*(*uint8)(unsafe.Pointer(p)))
				v21 = BoolInt32(v20 == int32(' ') || uint32(v20)-uint32('\t') < uint32(5))
				goto _22
			_22:
			}
			if !(v23 && v21 != 0) {
				break
			}
			goto _19
		_19:
			;
			p++
		}
		z = p
		for {
			if v28 = *(*uint8)(unsafe.Pointer(z)) != 0; v28 {
				v25 = int32(*(*uint8)(unsafe.Pointer(z)))
				v26 = BoolInt32(v25 == int32(' ') || uint32(v25)-uint32('\t') < uint32(5))
				goto _27
			_27:
			}
			if !(v28 && !(v26 != 0)) {
				break
			}
			goto _24
		_24:
			;
			z++
		}
		*(*uint8)(unsafe.Pointer(z)) = uint8(0)
		if _is_valid_hostname(tls, p) != 0 {
			have_canon = int32(1)
			Xmemcpy(tls, canon, p, uint64(int64(z)-int64(p)+int64(1)))
		}
	}
	X__fclose_ca(tls, f)
	if cnt != 0 {
		v29 = cnt
	} else {
		v29 = badfam
	}
	return v29
}

type Tdpc_ctx = struct {
	Faddrs  uintptr
	Fcanon  uintptr
	Fcnt    int32
	Frrtype int32
}

func _dns_parse_callback1(tls *TLS, c uintptr, rr int32, data uintptr, len1 int32, packet uintptr, plen int32) (r int32) {
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var ctx, v2 uintptr
	var family, v1 int32
	var _ /* tmp at bp+0 */ [256]uint8
	_, _, _, _ = ctx, family, v1, v2
	ctx = c
	if rr == int32(RR_CNAME) {
		if X__dn_expand(tls, packet, packet+uintptr(plen), data, bp, int32(256)) > 0 && _is_valid_hostname(tls, bp) != 0 {
			Xstrcpy(tls, (*Tdpc_ctx)(unsafe.Pointer(ctx)).Fcanon, bp)
		}
		return 0
	}
	if (*Tdpc_ctx)(unsafe.Pointer(ctx)).Fcnt >= int32(MAXADDRS) {
		return 0
	}
	if rr != (*Tdpc_ctx)(unsafe.Pointer(ctx)).Frrtype {
		return 0
	}
	switch rr {
	case int32(RR_A):
		if len1 != int32(4) {
			return -int32(1)
		}
		family = int32(PF_INET)
	case int32(RR_AAAA):
		if len1 != int32(16) {
			return -int32(1)
		}
		family = int32(PF_INET6)
		break
	}
	(*(*Taddress)(unsafe.Pointer((*Tdpc_ctx)(unsafe.Pointer(ctx)).Faddrs + uintptr((*Tdpc_ctx)(unsafe.Pointer(ctx)).Fcnt)*28))).Ffamily = family
	(*(*Taddress)(unsafe.Pointer((*Tdpc_ctx)(unsafe.Pointer(ctx)).Faddrs + uintptr((*Tdpc_ctx)(unsafe.Pointer(ctx)).Fcnt)*28))).Fscopeid = uint32(0)
	v2 = ctx + 16
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	Xmemcpy(tls, (*Tdpc_ctx)(unsafe.Pointer(ctx)).Faddrs+uintptr(v1)*28+8, data, uint64(len1))
	return 0
}

func _name_from_dns(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32, conf uintptr) (r int32) {
	bp := tls.Alloc(10240)
	defer tls.Free(10240)
	var i, nq int32
	var qtypes [2]int32
	var _ /* abuf at bp+560 */ [2][4800]uint8
	var _ /* alens at bp+10200 */ [2]int32
	var _ /* ap at bp+10176 */ [2]uintptr
	var _ /* ctx at bp+10208 */ Tdpc_ctx
	var _ /* qbuf at bp+0 */ [2][280]uint8
	var _ /* qlens at bp+10192 */ [2]int32
	var _ /* qp at bp+10160 */ [2]uintptr
	_, _, _ = i, nq, qtypes
	*(*[2]uintptr)(unsafe.Pointer(bp + 10160)) = [2]uintptr{
		0: bp,
		1: bp + 1*280,
	}
	*(*[2]uintptr)(unsafe.Pointer(bp + 10176)) = [2]uintptr{
		0: bp + 560,
		1: bp + 560 + 1*4800,
	}
	nq = 0
	*(*Tdpc_ctx)(unsafe.Pointer(bp + 10208)) = Tdpc_ctx{
		Faddrs: buf,
		Fcanon: canon,
	}
	i = 0
	for {
		if !(i < int32(2)) {
			break
		}
		if family != _afrr[i].Faf {
			(*(*[2]int32)(unsafe.Pointer(bp + 10192)))[nq] = X__res_mkquery(tls, 0, name, int32(1), _afrr[i].Frr, uintptr(0), 0, uintptr(0), bp+uintptr(nq)*280, int32(280))
			if (*(*[2]int32)(unsafe.Pointer(bp + 10192)))[nq] == -int32(1) {
				return 0
			}
			qtypes[nq] = _afrr[i].Frr
			*(*uint8)(unsafe.Pointer(bp + uintptr(nq)*280 + 3)) = uint8(0) /* don't need AD flag */
			/* Ensure query IDs are distinct. */
			if nq != 0 && int32(*(*uint8)(unsafe.Pointer(bp + uintptr(nq)*280))) == int32(*(*uint8)(unsafe.Pointer(bp))) {
				*(*uint8)(unsafe.Pointer(bp + uintptr(nq)*280))++
			}
			nq++
		}
		goto _1
	_1:
		;
		i++
	}
	if X__res_msend_rc(tls, nq, bp+10160, bp+10192, bp+10176, bp+10200, int32(4800), conf) < 0 {
		return -int32(11)
	}
	i = 0
	for {
		if !(i < nq) {
			break
		}
		if (*(*[2]int32)(unsafe.Pointer(bp + 10200)))[i] < int32(4) || int32(*(*uint8)(unsafe.Pointer(bp + 560 + uintptr(i)*4800 + 3)))&int32(15) == int32(2) {
			return -int32(3)
		}
		if int32(*(*uint8)(unsafe.Pointer(bp + 560 + uintptr(i)*4800 + 3)))&int32(15) == int32(3) {
			return 0
		}
		if int32(*(*uint8)(unsafe.Pointer(bp + 560 + uintptr(i)*4800 + 3)))&int32(15) != 0 {
			return -int32(4)
		}
		goto _2
	_2:
		;
		i++
	}
	i = nq - int32(1)
	for {
		if !(i >= 0) {
			break
		}
		(*(*Tdpc_ctx)(unsafe.Pointer(bp + 10208))).Frrtype = qtypes[i]
		if uint64((*(*[2]int32)(unsafe.Pointer(bp + 10200)))[i]) > uint64(4800) {
			(*(*[2]int32)(unsafe.Pointer(bp + 10200)))[i] = int32(4800)
		}
		X__dns_parse(tls, bp+560+uintptr(i)*4800, (*(*[2]int32)(unsafe.Pointer(bp + 10200)))[i], __ccgo_fp(_dns_parse_callback1), bp+10208)
		goto _3
	_3:
		;
		i--
	}
	if (*(*Tdpc_ctx)(unsafe.Pointer(bp + 10208))).Fcnt != 0 {
		return (*(*Tdpc_ctx)(unsafe.Pointer(bp + 10208))).Fcnt
	}
	return -int32(5)
}

var _afrr = [2]struct {
	Faf int32
	Frr int32
}{
	0: {
		Faf: int32(PF_INET6),
		Frr: int32(RR_A),
	},
	1: {
		Faf: int32(PF_INET),
		Frr: int32(RR_AAAA),
	},
}

func _name_from_dns_search(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32) (r int32) {
	bp := tls.Alloc(368)
	defer tls.Free(368)
	var cnt, v10, v5, v6, v9 int32
	var dots, l, v2 Tsize_t
	var p, z uintptr
	var v12 bool
	var _ /* conf at bp+256 */ Tresolvconf
	var _ /* search at bp+0 */ [256]uint8
	_, _, _, _, _, _, _, _, _, _, _ = cnt, dots, l, p, z, v10, v12, v2, v5, v6, v9
	if X__get_resolv_conf(tls, bp+256, bp, uint64(256)) < 0 {
		return -int32(1)
	}
	/* Count dots, suppress search when >=ndots or name ends in
	 * a dot, which is an explicit request for global scope. */
	v2 = Uint64FromInt32(0)
	l = v2
	dots = v2
	for {
		if !(*(*uint8)(unsafe.Pointer(name + uintptr(l))) != 0) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(name + uintptr(l)))) == int32('.') {
			dots++
		}
		goto _1
	_1:
		;
		l++
	}
	if dots >= uint64((*(*Tresolvconf)(unsafe.Pointer(bp + 256))).Fndots) || int32(*(*uint8)(unsafe.Pointer(name + uintptr(l-uint64(1))))) == int32('.') {
		*(*uint8)(unsafe.Pointer(bp)) = uint8(0)
	}
	/* Strip final dot for canon, fail if multiple trailing dots. */
	if int32(*(*uint8)(unsafe.Pointer(name + uintptr(l-uint64(1))))) == int32('.') {
		l--
	}
	if !(l != 0) || int32(*(*uint8)(unsafe.Pointer(name + uintptr(l-uint64(1))))) == int32('.') {
		return -int32(2)
	}
	/* This can never happen; the caller already checked length. */
	if l >= uint64(256) {
		return -int32(2)
	}
	/* Name with search domain appended is setup in canon[]. This both
	 * provides the desired default canonical name (if the requested
	 * name is not a CNAME record) and serves as a buffer for passing
	 * the full requested name to name_from_dns. */
	Xmemcpy(tls, canon, name, l)
	*(*uint8)(unsafe.Pointer(canon + uintptr(l))) = uint8('.')
	p = bp
	for {
		if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			break
		}
		for {
			v5 = int32(*(*uint8)(unsafe.Pointer(p)))
			v6 = BoolInt32(v5 == int32(' ') || uint32(v5)-uint32('\t') < uint32(5))
			goto _7
		_7:
			if !(v6 != 0) {
				break
			}
			goto _4
		_4:
			;
			p++
		}
		z = p
		for {
			if v12 = *(*uint8)(unsafe.Pointer(z)) != 0; v12 {
				v9 = int32(*(*uint8)(unsafe.Pointer(z)))
				v10 = BoolInt32(v9 == int32(' ') || uint32(v9)-uint32('\t') < uint32(5))
				goto _11
			_11:
			}
			if !(v12 && !(v10 != 0)) {
				break
			}
			goto _8
		_8:
			;
			z++
		}
		if z == p {
			break
		}
		if uint64(int64(z)-int64(p)) < uint64(256)-l-uint64(1) {
			Xmemcpy(tls, canon+uintptr(l)+uintptr(1), p, uint64(int64(z)-int64(p)))
			*(*uint8)(unsafe.Pointer(canon + uintptr(uint64(int64(z)-int64(p)+int64(1))+l))) = uint8(0)
			cnt = _name_from_dns(tls, buf, canon, canon, family, bp+256)
			if cnt != 0 {
				return cnt
			}
		}
		goto _3
	_3:
		;
		p = z
	}
	*(*uint8)(unsafe.Pointer(canon + uintptr(l))) = uint8(0)
	return _name_from_dns(tls, buf, canon, name, family, bp+256)
}

type Tpolicy = struct {
	Faddr  [16]uint8
	Flen1  uint8
	Fmask  uint8
	Fprec  uint8
	Flabel uint8
}

var _defpolicy = [6]Tpolicy{
	0: {
		Faddr: [16]uint8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
		Flen1: uint8(15),
		Fmask: uint8(0xff),
		Fprec: uint8(50),
	},
	1: {
		Faddr:  [16]uint8{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255},
		Flen1:  uint8(11),
		Fmask:  uint8(0xff),
		Fprec:  uint8(35),
		Flabel: uint8(4),
	},
	2: {
		Faddr:  [16]uint8{' ', 2},
		Flen1:  uint8(1),
		Fmask:  uint8(0xff),
		Fprec:  uint8(30),
		Flabel: uint8(2),
	},
	3: {
		Faddr:  [16]uint8{' ', 1},
		Flen1:  uint8(3),
		Fmask:  uint8(0xff),
		Fprec:  uint8(5),
		Flabel: uint8(5),
	},
	4: {
		Faddr:  [16]uint8{252},
		Fmask:  uint8(0xfe),
		Fprec:  uint8(3),
		Flabel: uint8(13),
	},
	5: {
		Faddr:  [16]uint8{},
		Fprec:  uint8(40),
		Flabel: uint8(1),
	},
}

func _policyof(tls *TLS, a uintptr) (r uintptr) {
	var i int32
	_ = i
	i = 0
	for {
		if Xmemcmp(tls, a, uintptr(unsafe.Pointer(&_defpolicy))+uintptr(i)*20, uint64(_defpolicy[i].Flen1)) != 0 {
			goto _1
		}
		if int32(*(*Tuint8_t)(unsafe.Pointer(a + uintptr(_defpolicy[i].Flen1))))&int32(_defpolicy[i].Fmask) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_defpolicy)) + uintptr(i)*20 + uintptr(_defpolicy[i].Flen1)))) {
			goto _1
		}
		return uintptr(unsafe.Pointer(&_defpolicy)) + uintptr(i)*20
		goto _1
	_1:
		;
		i++
	}
	return r
}

func _labelof(tls *TLS, a uintptr) (r int32) {
	return int32((*Tpolicy)(unsafe.Pointer(_policyof(tls, a))).Flabel)
}

func _scopeof(tls *TLS, a uintptr) (r int32) {
	if int32(*(*Tuint8_t)(unsafe.Pointer(a))) == int32(0xff) {
		return int32(*(*Tuint8_t)(unsafe.Pointer(a + 1))) & int32(15)
	}
	if int32(*(*Tuint8_t)(unsafe.Pointer(a))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(a + 1)))&int32(0xc0) == int32(0x80) {
		return int32(2)
	}
	if *(*Tuint32_t)(unsafe.Pointer(a)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(a + 1*4)) == uint32(0) && *(*Tuint32_t)(unsafe.Pointer(a + 2*4)) == uint32(0) && int32(*(*Tuint8_t)(unsafe.Pointer(a + 12))) == 0 && int32(*(*Tuint8_t)(unsafe.Pointer(a + 13))) == 0 && int32(*(*Tuint8_t)(unsafe.Pointer(a + 14))) == 0 && int32(*(*Tuint8_t)(unsafe.Pointer(a + 15))) == int32(1) {
		return int32(2)
	}
	if int32(*(*Tuint8_t)(unsafe.Pointer(a))) == int32(0xfe) && int32(*(*Tuint8_t)(unsafe.Pointer(a + 1)))&int32(0xc0) == int32(0xc0) {
		return int32(5)
	}
	return int32(14)
}

func _prefixmatch(tls *TLS, s uintptr, d uintptr) (r int32) {
	var i uint32
	_ = i
	i = uint32(0)
	for {
		if !(i < uint32(128) && !((int32(*(*Tuint8_t)(unsafe.Pointer(s + uintptr(i/uint32(8)))))^int32(*(*Tuint8_t)(unsafe.Pointer(d + uintptr(i/uint32(8))))))&(Int32FromInt32(128)>>(i%Uint32FromInt32(8))) != 0)) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(i)
}

func _addrcmp(tls *TLS, _a uintptr, _b uintptr) (r int32) {
	var a, b uintptr
	_, _ = a, b
	a = _a
	b = _b
	return (*Taddress)(unsafe.Pointer(b)).Fsortkey - (*Taddress)(unsafe.Pointer(a)).Fsortkey
}

func X__lookup_name(tls *TLS, buf uintptr, canon uintptr, name uintptr, family int32, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v buf=%v canon=%v name=%v family=%v flags=%v, (%v:)", tls, buf, canon, name, family, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var cnt, dlabel, dprec, dscope, family1, fd, i, j, key, prefixlen, v1, v4, v5 int32
	var da, dpolicy, sa uintptr
	var dalen Tsocklen_t
	var l Tsize_t
	var _ /* cs at bp+0 */ int32
	var _ /* da4 at bp+76 */ Tsockaddr_in
	var _ /* da6 at bp+32 */ Tsockaddr_in6
	var _ /* sa4 at bp+60 */ Tsockaddr_in
	var _ /* sa6 at bp+4 */ Tsockaddr_in6
	var _ /* salen at bp+92 */ Tsocklen_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = cnt, da, dalen, dlabel, dpolicy, dprec, dscope, family1, fd, i, j, key, l, prefixlen, sa, v1, v4, v5
	cnt = 0
	*(*uint8)(unsafe.Pointer(canon)) = uint8(0)
	if name != 0 {
		/* reject empty name and check len so it fits into temp bufs */
		l = Xstrnlen(tls, name, uint64(255))
		if l-uint64(1) >= uint64(254) {
			return -int32(2)
		}
		Xmemcpy(tls, canon, name, l+uint64(1))
	}
	/* Procedurally, a request for v6 addresses with the v4-mapped
	 * flag set is like a request for unspecified family, followed
	 * by filtering of the results. */
	if flags&int32(AI_V4MAPPED) != 0 {
		if family == int32(PF_INET6) {
			family = PF_UNSPEC
		} else {
			flags -= int32(AI_V4MAPPED)
		}
	}
	/* Try each backend until there's at least one result. */
	cnt = _name_from_null(tls, buf, name, family, flags)
	if !(cnt != 0) {
		cnt = _name_from_numeric(tls, buf, name, family)
	}
	if !(cnt != 0) && !(flags&Int32FromInt32(AI_NUMERICHOST) != 0) {
		cnt = _name_from_hosts(tls, buf, canon, name, family)
		if !(cnt != 0) {
			cnt = _name_from_dns_search(tls, buf, canon, name, family)
		}
	}
	if cnt <= 0 {
		if cnt != 0 {
			v1 = cnt
		} else {
			v1 = -int32(2)
		}
		return v1
	}
	/* Filter/transform results for v4-mapped lookup, if requested. */
	if flags&int32(AI_V4MAPPED) != 0 {
		if !(flags&Int32FromInt32(AI_ALL) != 0) {
			/* If any v6 results exist, remove v4 results. */
			i = 0
			for {
				if !(i < cnt && (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily != int32(PF_INET6)) {
					break
				}
				goto _2
			_2:
				;
				i++
			}
			if i < cnt {
				j = 0
				for {
					if !(i < cnt) {
						break
					}
					if (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily == int32(PF_INET6) {
						v4 = j
						j++
						*(*Taddress)(unsafe.Pointer(buf + uintptr(v4)*28)) = *(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))
					}
					goto _3
				_3:
					;
					i++
				}
				v5 = j
				i = v5
				cnt = v5
			}
		}
		/* Translate any remaining v4 results to v6 */
		i = 0
		for {
			if !(i < cnt) {
				break
			}
			if (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily != int32(PF_INET) {
				goto _6
			}
			Xmemcpy(tls, buf+uintptr(i)*28+8+uintptr(12), buf+uintptr(i)*28+8, uint64(4))
			Xmemcpy(tls, buf+uintptr(i)*28+8, __ccgo_ts+1027, uint64(12))
			(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily = int32(PF_INET6)
			goto _6
		_6:
			;
			i++
		}
	}
	/* No further processing is needed if there are fewer than 2
	 * results or if there are only IPv4 results. */
	if cnt < int32(2) || family == int32(PF_INET) {
		return cnt
	}
	i = 0
	for {
		if !(i < cnt) {
			break
		}
		if (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily != int32(PF_INET) {
			break
		}
		goto _7
	_7:
		;
		i++
	}
	if i == cnt {
		return cnt
	}
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	/* The following implements a subset of RFC 3484/6724 destination
	 * address selection by generating a single 31-bit sort key for
	 * each address. Rules 3, 4, and 7 are omitted for having
	 * excessive runtime and code size cost and dubious benefit.
	 * So far the label/precedence table cannot be customized. */
	i = 0
	for {
		if !(i < cnt) {
			break
		}
		family1 = (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Ffamily
		key = 0
		*(*Tsockaddr_in6)(unsafe.Pointer(bp + 4)) = Tsockaddr_in6{}
		*(*Tsockaddr_in6)(unsafe.Pointer(bp + 32)) = Tsockaddr_in6{
			Fsin6_family:   uint16(PF_INET6),
			Fsin6_port:     uint16(65535),
			Fsin6_scope_id: (*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Fscopeid,
		}
		*(*Tsockaddr_in)(unsafe.Pointer(bp + 60)) = Tsockaddr_in{}
		*(*Tsockaddr_in)(unsafe.Pointer(bp + 76)) = Tsockaddr_in{
			Fsin_family: uint16(PF_INET),
			Fsin_port:   uint16(65535),
		}
		if family1 == int32(PF_INET6) {
			Xmemcpy(tls, bp+32+8, buf+uintptr(i)*28+8, uint64(16))
			da = bp + 32
			dalen = uint32(28)
			sa = bp + 4
			*(*Tsocklen_t)(unsafe.Pointer(bp + 92)) = uint32(28)
		} else {
			Xmemcpy(tls, bp+4+8, __ccgo_ts+1027, uint64(12))
			Xmemcpy(tls, bp+32+8+uintptr(12), buf+uintptr(i)*28+8, uint64(4))
			Xmemcpy(tls, bp+32+8, __ccgo_ts+1027, uint64(12))
			Xmemcpy(tls, bp+32+8+uintptr(12), buf+uintptr(i)*28+8, uint64(4))
			Xmemcpy(tls, bp+76+4, buf+uintptr(i)*28+8, uint64(4))
			da = bp + 76
			dalen = uint32(16)
			sa = bp + 60
			*(*Tsocklen_t)(unsafe.Pointer(bp + 92)) = uint32(16)
		}
		dpolicy = _policyof(tls, bp+32+8)
		dscope = _scopeof(tls, bp+32+8)
		dlabel = int32((*Tpolicy)(unsafe.Pointer(dpolicy)).Flabel)
		dprec = int32((*Tpolicy)(unsafe.Pointer(dpolicy)).Fprec)
		prefixlen = 0
		fd = Xsocket(tls, family1, Int32FromInt32(SOCK_DGRAM)|Int32FromInt32(SOCK_CLOEXEC), int32(IPPROTO_UDP))
		if fd >= 0 {
			if !(Xconnect(tls, fd, da, dalen) != 0) {
				key |= int32(DAS_USABLE)
				if !(Xgetsockname(tls, fd, sa, bp+92) != 0) {
					if family1 == int32(PF_INET) {
						Xmemcpy(tls, bp+4+8+uintptr(12), bp+60+4, uint64(4))
					}
					if dscope == _scopeof(tls, bp+4+8) {
						key |= int32(DAS_MATCHINGSCOPE)
					}
					if dlabel == _labelof(tls, bp+4+8) {
						key |= int32(DAS_MATCHINGLABEL)
					}
					prefixlen = _prefixmatch(tls, bp+4+8, bp+32+8)
				}
			}
			Xclose(tls, fd)
		}
		key |= dprec << int32(DAS_PREC_SHIFT)
		key |= (int32(15) - dscope) << int32(DAS_SCOPE_SHIFT)
		key |= prefixlen << int32(DAS_PREFIX_SHIFT)
		key |= (int32(MAXADDRS) - i) << DAS_ORDER_SHIFT
		(*(*Taddress)(unsafe.Pointer(buf + uintptr(i)*28))).Fsortkey = key
		goto _8
	_8:
		;
		i++
	}
	Xqsort(tls, buf, uint64(cnt), uint64(28), __ccgo_fp(_addrcmp))
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	return cnt
}

func X__lookup_serv(tls *TLS, buf uintptr, name uintptr, proto int32, socktype int32, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v buf=%v name=%v proto=%v socktype=%v flags=%v, (%v:)", tls, buf, name, proto, socktype, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(1408)
	defer tls.Free(1408)
	var cnt, v1, v11, v12, v16, v17, v2, v20, v21, v22, v7, v8 int32
	var f, p, v3, v4, v6 uintptr
	var l Tsize_t
	var port uint64
	var v10, v14, v19 bool
	var _ /* _buf at bp+136 */ [1032]uint8
	var _ /* _f at bp+1168 */ TFILE
	var _ /* line at bp+0 */ [128]uint8
	var _ /* z at bp+128 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = cnt, f, l, p, port, v1, v10, v11, v12, v14, v16, v17, v19, v2, v20, v21, v22, v3, v4, v6, v7, v8
	cnt = 0
	*(*uintptr)(unsafe.Pointer(bp + 128)) = __ccgo_ts
	port = uint64(0)
	switch socktype {
	case int32(SOCK_STREAM):
		switch proto {
		case 0:
			proto = int32(IPPROTO_TCP)
			fallthrough
		case int32(IPPROTO_TCP):
		default:
			return -int32(8)
		}
	case int32(SOCK_DGRAM):
		switch proto {
		case 0:
			proto = int32(IPPROTO_UDP)
			fallthrough
		case int32(IPPROTO_UDP):
		default:
			return -int32(8)
		}
		fallthrough
	case 0:
	default:
		if name != 0 {
			return -int32(8)
		}
		(*(*Tservice)(unsafe.Pointer(buf))).Fport = uint16(0)
		(*(*Tservice)(unsafe.Pointer(buf))).Fproto = uint8(proto)
		(*(*Tservice)(unsafe.Pointer(buf))).Fsocktype = uint8(socktype)
		return int32(1)
	}
	if name != 0 {
		if !(*(*uint8)(unsafe.Pointer(name)) != 0) {
			return -int32(8)
		}
		port = Xstrtoul(tls, name, bp+128, int32(10))
	}
	if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 128)))) != 0) {
		if port > uint64(65535) {
			return -int32(8)
		}
		if proto != int32(IPPROTO_UDP) {
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fport = uint16(port)
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fsocktype = uint8(SOCK_STREAM)
			v1 = cnt
			cnt++
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(v1)*4))).Fproto = uint8(IPPROTO_TCP)
		}
		if proto != int32(IPPROTO_TCP) {
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fport = uint16(port)
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fsocktype = uint8(SOCK_DGRAM)
			v2 = cnt
			cnt++
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(v2)*4))).Fproto = uint8(IPPROTO_UDP)
		}
		return cnt
	}
	if flags&int32(AI_NUMERICSERV) != 0 {
		return -int32(2)
	}
	l = Xstrlen(tls, name)
	f = X__fopen_rb_ca(tls, __ccgo_ts+1040, bp+1168, bp+136, uint64(1032))
	if !(f != 0) {
		switch *(*int32)(unsafe.Pointer(X__errno_location(tls))) {
		case int32(ENOENT):
			fallthrough
		case int32(ENOTDIR):
			fallthrough
		case int32(EACCES):
			return -int32(8)
		default:
			return -int32(11)
		}
	}
	for Xfgets(tls, bp, int32(128), f) != 0 && cnt < int32(MAXSERVS) {
		v3 = Xstrchr(tls, bp, int32('#'))
		p = v3
		if v3 != 0 {
			v4 = p
			p++
			*(*uint8)(unsafe.Pointer(v4)) = uint8('\n')
			*(*uint8)(unsafe.Pointer(p)) = Uint8FromInt32(0)
		}
		/* Find service name */
		p = bp
		for {
			v6 = Xstrstr(tls, p, name)
			p = v6
			if !(v6 != 0) {
				break
			}
			if v10 = p > bp; v10 {
				v7 = int32(*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1)))))
				v8 = BoolInt32(v7 == int32(' ') || uint32(v7)-uint32('\t') < uint32(5))
				goto _9
			_9:
			}
			if v10 && !(v8 != 0) {
				goto _5
			}
			if v14 = *(*uint8)(unsafe.Pointer(p + uintptr(l))) != 0; v14 {
				v11 = int32(*(*uint8)(unsafe.Pointer(p + uintptr(l))))
				v12 = BoolInt32(v11 == int32(' ') || uint32(v11)-uint32('\t') < uint32(5))
				goto _13
			_13:
			}
			if v14 && !(v12 != 0) {
				goto _5
			}
			break
			goto _5
		_5:
			;
			p++
		}
		if !(p != 0) {
			continue
		}
		/* Skip past canonical name at beginning of line */
		p = bp
		for {
			if v19 = *(*uint8)(unsafe.Pointer(p)) != 0; v19 {
				v16 = int32(*(*uint8)(unsafe.Pointer(p)))
				v17 = BoolInt32(v16 == int32(' ') || uint32(v16)-uint32('\t') < uint32(5))
				goto _18
			_18:
			}
			if !(v19 && !(v17 != 0)) {
				break
			}
			goto _15
		_15:
			;
			p++
		}
		port = Xstrtoul(tls, p, bp+128, int32(10))
		if port > uint64(65535) || *(*uintptr)(unsafe.Pointer(bp + 128)) == p {
			continue
		}
		if !(Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), __ccgo_ts+1054, uint64(4)) != 0) {
			if proto == int32(IPPROTO_TCP) {
				continue
			}
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fport = uint16(port)
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fsocktype = uint8(SOCK_DGRAM)
			v20 = cnt
			cnt++
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(v20)*4))).Fproto = uint8(IPPROTO_UDP)
		}
		if !(Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(bp + 128)), __ccgo_ts+1059, uint64(4)) != 0) {
			if proto == int32(IPPROTO_UDP) {
				continue
			}
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fport = uint16(port)
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(cnt)*4))).Fsocktype = uint8(SOCK_STREAM)
			v21 = cnt
			cnt++
			(*(*Tservice)(unsafe.Pointer(buf + uintptr(v21)*4))).Fproto = uint8(IPPROTO_TCP)
		}
	}
	X__fclose_ca(tls, f)
	if cnt > 0 {
		v22 = cnt
	} else {
		v22 = -int32(8)
	}
	return v22
}

func ___netlink_enumerate(tls *TLS, fd int32, seq uint32, type1 int32, af int32, cb uintptr, ctx uintptr) (r1 int32) {
	bp := tls.Alloc(8192)
	defer tls.Free(8192)
	var h uintptr
	var r, ret int32
	var _ /* u at bp+0 */ struct {
		Freq [0]struct {
			Fnlh Tnlmsghdr
			Fg   Trtgenmsg
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	}
	_, _, _ = h, r, ret
	Xmemset(tls, bp, 0, uint64(20))
	(*(*struct {
		Fnlh Tnlmsghdr
		Fg   Trtgenmsg
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh Tnlmsghdr
			Fg   Trtgenmsg
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fnlh.Fnlmsg_len = uint32(20)
	(*(*struct {
		Fnlh Tnlmsghdr
		Fg   Trtgenmsg
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh Tnlmsghdr
			Fg   Trtgenmsg
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fnlh.Fnlmsg_type = uint16(type1)
	(*(*struct {
		Fnlh Tnlmsghdr
		Fg   Trtgenmsg
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh Tnlmsghdr
			Fg   Trtgenmsg
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fnlh.Fnlmsg_flags = uint16(Int32FromInt32(NLM_F_ROOT) | Int32FromInt32(NLM_F_MATCH) | Int32FromInt32(NLM_F_REQUEST))
	(*(*struct {
		Fnlh Tnlmsghdr
		Fg   Trtgenmsg
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh Tnlmsghdr
			Fg   Trtgenmsg
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fnlh.Fnlmsg_seq = seq
	(*(*struct {
		Fnlh Tnlmsghdr
		Fg   Trtgenmsg
	})(unsafe.Pointer(&*(*struct {
		Freq [0]struct {
			Fnlh Tnlmsghdr
			Fg   Trtgenmsg
		}
		Freply [0]Tnlmsghdr
		Fbuf   [8192]Tuint8_t
	})(unsafe.Pointer(bp))))).Fg.Frtgen_family = uint8(af)
	r = int32(Xsend(tls, fd, bp, uint64(20), 0))
	if r < 0 {
		return r
	}
	for int32(1) != 0 {
		r = int32(Xrecv(tls, fd, bp, uint64(8192), int32(MSG_DONTWAIT)))
		if r <= 0 {
			return -int32(1)
		}
		h = bp
		for {
			if !(uint64(int64(bp+uintptr(r))-int64(h)) >= uint64(16)) {
				break
			}
			if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(NLMSG_DONE) {
				return 0
			}
			if int32((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_type) == int32(NLMSG_ERROR) {
				return -int32(1)
			}
			ret = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cb})))(tls, ctx, h)
			if ret != 0 {
				return ret
			}
			goto _1
		_1:
			;
			h = h + uintptr(((*Tnlmsghdr)(unsafe.Pointer(h)).Fnlmsg_len+Uint32FromInt32(3))&uint32(^Int32FromInt32(3)))
		}
	}
	return r1
}

func X__rtnetlink_enumerate(tls *TLS, link_af int32, addr_af int32, cb uintptr, ctx uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v link_af=%v addr_af=%v cb=%v ctx=%v, (%v:)", tls, link_af, addr_af, cb, ctx, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var fd, r int32
	_, _ = fd, r
	fd = Xsocket(tls, int32(PF_NETLINK), Int32FromInt32(SOCK_RAW)|Int32FromInt32(SOCK_CLOEXEC), NETLINK_ROUTE)
	if fd < 0 {
		return -int32(1)
	}
	r = ___netlink_enumerate(tls, fd, uint32(1), int32(RTM_GETLINK), link_af, cb, ctx)
	if !(r != 0) {
		r = ___netlink_enumerate(tls, fd, uint32(2), int32(RTM_GETADDR), addr_af, cb, ctx)
	}
	X__syscall1(tls, int64(SYS_close), int64(fd))
	return r
}

func Xgetnetbyaddr(tls *TLS, net Tuint32_t, type1 int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v net=%v type1=%v, (%v:)", tls, net, type1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(0)
}

func Xgetnetbyname(tls *TLS, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(0)
}

func Xns_get16(tls *TLS, cp uintptr) (r uint32) {
	if __ccgo_strace {
		trc("tls=%v cp=%v, (%v:)", tls, cp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint32(int32(*(*uint8)(unsafe.Pointer(cp)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(cp + 1))))
}

func Xns_get32(tls *TLS, cp uintptr) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v cp=%v, (%v:)", tls, cp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint64(uint32(*(*uint8)(unsafe.Pointer(cp)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(cp + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(cp + 2)))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(cp + 3))))
}

func Xns_put16(tls *TLS, s uint32, cp uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v cp=%v, (%v:)", tls, s, cp, origin(2))
	}
	var v1, v2 uintptr
	_, _ = v1, v2
	v1 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v1)) = uint8(s >> int32(8))
	v2 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v2)) = uint8(s)
}

func Xns_put32(tls *TLS, l uint64, cp uintptr) {
	if __ccgo_strace {
		trc("tls=%v l=%v cp=%v, (%v:)", tls, l, cp, origin(2))
	}
	var v1, v2, v3, v4 uintptr
	_, _, _, _ = v1, v2, v3, v4
	v1 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v1)) = uint8(l >> int32(24))
	v2 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v2)) = uint8(l >> int32(16))
	v3 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v3)) = uint8(l >> int32(8))
	v4 = cp
	cp++
	*(*uint8)(unsafe.Pointer(v4)) = uint8(l)
}

func Xns_initparse(tls *TLS, msg uintptr, msglen int32, handle uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v msg=%v msglen=%v handle=%v, (%v:)", tls, msg, msglen, handle, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var i, r int32
	_, _ = i, r
	(*Tns_msg)(unsafe.Pointer(handle)).F_msg = msg
	(*Tns_msg)(unsafe.Pointer(handle)).F_eom = msg + uintptr(msglen)
	if msglen < (Int32FromInt32(2)+int32(_ns_s_max))*Int32FromInt32(NS_INT16SZ) {
		goto bad
	}
	msg += uintptr(2)
	(*Tns_msg)(unsafe.Pointer(handle)).F_id = uint16(Xns_get16(tls, msg-uintptr(2)))
	msg += uintptr(2)
	(*Tns_msg)(unsafe.Pointer(handle)).F_flags = uint16(Xns_get16(tls, msg-uintptr(2)))
	i = 0
	for {
		if !(i < int32(_ns_s_max)) {
			break
		}
		msg += uintptr(2)
		*(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(i)*2)) = uint16(Xns_get16(tls, msg-uintptr(2)))
		goto _1
	_1:
		;
		i++
	}
	i = 0
	for {
		if !(i < int32(_ns_s_max)) {
			break
		}
		if *(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(i)*2)) != 0 {
			*(*uintptr)(unsafe.Pointer(handle + 32 + uintptr(i)*8)) = msg
			r = Xns_skiprr(tls, msg, (*Tns_msg)(unsafe.Pointer(handle)).F_eom, i, int32(*(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(i)*2))))
			if r < 0 {
				return -int32(1)
			}
			msg += uintptr(r)
		} else {
			*(*uintptr)(unsafe.Pointer(handle + 32 + uintptr(i)*8)) = UintptrFromInt32(0)
		}
		goto _2
	_2:
		;
		i++
	}
	if msg != (*Tns_msg)(unsafe.Pointer(handle)).F_eom {
		goto bad
	}
	(*Tns_msg)(unsafe.Pointer(handle)).F_sect = int32(_ns_s_max)
	(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = -int32(1)
	(*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr = UintptrFromInt32(0)
	return 0
	goto bad
bad:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EMSGSIZE)
	return -int32(1)
}

func Xns_skiprr(tls *TLS, ptr uintptr, eom uintptr, section Tns_sect, count int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v ptr=%v eom=%v section=%v count=%v, (%v:)", tls, ptr, eom, section, count, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var p uintptr
	var r, v1 int32
	_, _, _ = p, r, v1
	p = ptr
	for {
		v1 = count
		count--
		if !(v1 != 0) {
			break
		}
		r = Xdn_skipname(tls, p, eom)
		if r < 0 {
			goto bad
		}
		if int64(r+Int32FromInt32(2)*Int32FromInt32(NS_INT16SZ)) > int64(eom)-int64(p) {
			goto bad
		}
		p += uintptr(r + Int32FromInt32(2)*Int32FromInt32(NS_INT16SZ))
		if section != int32(_ns_s_qd) {
			if int64(Int32FromInt32(NS_INT32SZ)+Int32FromInt32(NS_INT16SZ)) > int64(eom)-int64(p) {
				goto bad
			}
			p += uintptr(NS_INT32SZ)
			p += uintptr(2)
			r = int32(Xns_get16(tls, p-uintptr(2)))
			if int64(r) > int64(eom)-int64(p) {
				goto bad
			}
			p += uintptr(r)
		}
	}
	return int32(int64(p) - int64(ptr))
	goto bad
bad:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EMSGSIZE)
	return -int32(1)
}

func Xns_parserr(tls *TLS, handle uintptr, section Tns_sect, rrnum int32, rr uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v handle=%v section=%v rrnum=%v rr=%v, (%v:)", tls, handle, section, rrnum, rr, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	var p1, p2, p3, p4 uintptr
	_, _, _, _, _ = r, p1, p2, p3, p4
	if section < 0 || section >= int32(_ns_s_max) {
		goto bad
	}
	if section != (*Tns_msg)(unsafe.Pointer(handle)).F_sect {
		(*Tns_msg)(unsafe.Pointer(handle)).F_sect = section
		(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = 0
		(*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr = *(*uintptr)(unsafe.Pointer(handle + 32 + uintptr(section)*8))
	}
	if rrnum == -int32(1) {
		rrnum = (*Tns_msg)(unsafe.Pointer(handle)).F_rrnum
	}
	if rrnum < 0 || rrnum >= int32(*(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(section)*2))) {
		goto bad
	}
	if rrnum < (*Tns_msg)(unsafe.Pointer(handle)).F_rrnum {
		(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = 0
		(*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr = *(*uintptr)(unsafe.Pointer(handle + 32 + uintptr(section)*8))
	}
	if rrnum > (*Tns_msg)(unsafe.Pointer(handle)).F_rrnum {
		r = Xns_skiprr(tls, (*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr, (*Tns_msg)(unsafe.Pointer(handle)).F_eom, section, rrnum-(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum)
		if r < 0 {
			return -int32(1)
		}
		*(*uintptr)(unsafe.Pointer(handle + 72)) += uintptr(r)
		(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = rrnum
	}
	r = Xns_name_uncompress(tls, (*Tns_msg)(unsafe.Pointer(handle)).F_msg, (*Tns_msg)(unsafe.Pointer(handle)).F_eom, (*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr, rr, uint64(NS_MAXDNAME))
	if r < 0 {
		return -int32(1)
	}
	*(*uintptr)(unsafe.Pointer(handle + 72)) += uintptr(r)
	if int64(Int32FromInt32(2)*Int32FromInt32(NS_INT16SZ)) > int64((*Tns_msg)(unsafe.Pointer(handle)).F_eom)-int64((*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr) {
		goto size
	}
	p1 = handle + 72
	*(*uintptr)(unsafe.Pointer(p1)) += uintptr(2)
	(*Tns_rr)(unsafe.Pointer(rr)).Ftype1 = uint16(Xns_get16(tls, *(*uintptr)(unsafe.Pointer(p1))-uintptr(2)))
	p2 = handle + 72
	*(*uintptr)(unsafe.Pointer(p2)) += uintptr(2)
	(*Tns_rr)(unsafe.Pointer(rr)).Frr_class = uint16(Xns_get16(tls, *(*uintptr)(unsafe.Pointer(p2))-uintptr(2)))
	if section != int32(_ns_s_qd) {
		if int64(Int32FromInt32(NS_INT32SZ)+Int32FromInt32(NS_INT16SZ)) > int64((*Tns_msg)(unsafe.Pointer(handle)).F_eom)-int64((*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr) {
			goto size
		}
		p3 = handle + 72
		*(*uintptr)(unsafe.Pointer(p3)) += uintptr(4)
		(*Tns_rr)(unsafe.Pointer(rr)).Fttl = uint32(Xns_get32(tls, *(*uintptr)(unsafe.Pointer(p3))-uintptr(4)))
		p4 = handle + 72
		*(*uintptr)(unsafe.Pointer(p4)) += uintptr(2)
		(*Tns_rr)(unsafe.Pointer(rr)).Frdlength = uint16(Xns_get16(tls, *(*uintptr)(unsafe.Pointer(p4))-uintptr(2)))
		if int64((*Tns_rr)(unsafe.Pointer(rr)).Frdlength) > int64((*Tns_msg)(unsafe.Pointer(handle)).F_eom)-int64((*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr) {
			goto size
		}
		(*Tns_rr)(unsafe.Pointer(rr)).Frdata = (*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr
		*(*uintptr)(unsafe.Pointer(handle + 72)) += uintptr((*Tns_rr)(unsafe.Pointer(rr)).Frdlength)
	} else {
		(*Tns_rr)(unsafe.Pointer(rr)).Fttl = uint32(0)
		(*Tns_rr)(unsafe.Pointer(rr)).Frdlength = uint16(0)
		(*Tns_rr)(unsafe.Pointer(rr)).Frdata = UintptrFromInt32(0)
	}
	(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum++
	if (*Tns_msg)(unsafe.Pointer(handle)).F_rrnum > int32(*(*Tuint16_t)(unsafe.Pointer(handle + 20 + uintptr(section)*2))) {
		(*Tns_msg)(unsafe.Pointer(handle)).F_sect = section + int32(1)
		if (*Tns_msg)(unsafe.Pointer(handle)).F_sect == int32(_ns_s_max) {
			(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = -int32(1)
			(*Tns_msg)(unsafe.Pointer(handle)).F_msg_ptr = UintptrFromInt32(0)
		} else {
			(*Tns_msg)(unsafe.Pointer(handle)).F_rrnum = 0
		}
	}
	return 0
	goto bad
bad:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENODEV)
	return -int32(1)
	goto size
size:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EMSGSIZE)
	return -int32(1)
}

func Xns_name_uncompress(tls *TLS, msg uintptr, eom uintptr, src uintptr, dst uintptr, dstsiz Tsize_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v msg=%v eom=%v src=%v dst=%v dstsiz=%v, (%v:)", tls, msg, eom, src, dst, dstsiz, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = Xdn_expand(tls, msg, eom, src, dst, int32(dstsiz))
	if r < 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EMSGSIZE)
	}
	return r
}

func Xntohl(tls *TLS, n Tuint32_t) (r Tuint32_t) {
	if __ccgo_strace {
		trc("tls=%v n=%v, (%v:)", tls, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var u struct {
		Fc [0]uint8
		Fi int32
	}
	var v1 uint32
	var v2, v3 Tuint32_t
	_, _, _, _ = u, v1, v2, v3
	u = *(*struct {
		Fc [0]uint8
		Fi int32
	})(unsafe.Pointer(&struct{ f int32 }{f: int32(1)}))
	if *(*uint8)(unsafe.Pointer(&u)) != 0 {
		v2 = n
		v3 = v2>>int32(24) | v2>>int32(8)&uint32(0xff00) | v2<<int32(8)&uint32(0xff0000) | v2<<int32(24)
		goto _4
	_4:
		v1 = v3
	} else {
		v1 = n
	}
	return v1
}

func Xntohs(tls *TLS, n Tuint16_t) (r Tuint16_t) {
	if __ccgo_strace {
		trc("tls=%v n=%v, (%v:)", tls, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var u struct {
		Fc [0]uint8
		Fi int32
	}
	var v1 int32
	var v2, v3 Tuint16_t
	_, _, _, _ = u, v1, v2, v3
	u = *(*struct {
		Fc [0]uint8
		Fi int32
	})(unsafe.Pointer(&struct{ f int32 }{f: int32(1)}))
	if *(*uint8)(unsafe.Pointer(&u)) != 0 {
		v2 = n
		v3 = uint16(int32(v2)<<int32(8) | int32(v2)>>int32(8))
		goto _4
	_4:
		v1 = int32(v3)
	} else {
		v1 = int32(n)
	}
	return uint16(v1)
}

/* do we really need all these?? */

var _idx int32
var _protos = [239]uint8{0, 'i', 'p', 0, 1, 'i', 'c', 'm', 'p', 0, 2, 'i', 'g', 'm', 'p', 0, 3, 'g', 'g', 'p', 0, 4, 'i', 'p', 'e', 'n', 'c', 'a', 'p', 0, 5, 's', 't', 0, 6, 't', 'c', 'p', 0, 8, 'e', 'g', 'p', 0, 12, 'p', 'u', 'p', 0, 17, 'u', 'd', 'p', 0, 20, 'h', 'm', 'p', 0, 22, 'x', 'n', 's', '-', 'i', 'd', 'p', 0, 27, 'r', 'd', 'p', 0, 29, 'i', 's', 'o', '-', 't', 'p', '4', 0, '$', 'x', 't', 'p', 0, '%', 'd', 'd', 'p', 0, '&', 'i', 'd', 'p', 'r', '-', 'c', 'm', 't', 'p', 0, ')', 'i', 'p', 'v', '6', 0, '+', 'i', 'p', 'v', '6', '-', 'r', 'o', 'u', 't', 'e', 0, ',', 'i', 'p', 'v', '6', '-', 'f', 'r', 'a', 'g', 0, '-', 'i', 'd', 'r', 'p', 0, '.', 'r', 's', 'v', 'p', 0, '/', 'g', 'r', 'e', 0, '2', 'e', 's', 'p', 0, '3', 'a', 'h', 0, '9', 's', 'k', 'i', 'p', 0, ':', 'i', 'p', 'v', '6', '-', 'i', 'c', 'm', 'p', 0, ';', 'i', 'p', 'v', '6', '-', 'n', 'o', 'n', 'x', 't', 0, '<', 'i', 'p', 'v', '6', '-', 'o', 'p', 't', 's', 0, 'I', 'r', 's', 'p', 'f', 0, 'Q', 'v', 'm', 't', 'p', 0, 'Y', 'o', 's', 'p', 'f', 0, '^', 'i', 'p', 'i', 'p', 0, 'b', 'e', 'n', 'c', 'a', 'p', 0, 'g', 'p', 'i', 'm', 0, 255, 'r', 'a', 'w'}

func Xendprotoent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	_idx = 0
}

func Xsetprotoent(tls *TLS, stayopen int32) {
	if __ccgo_strace {
		trc("tls=%v stayopen=%v, (%v:)", tls, stayopen, origin(2))
	}
	_idx = 0
}

func Xgetprotoent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if uint64(_idx) >= uint64(239) {
		return UintptrFromInt32(0)
	}
	_p.Fp_proto = int32(_protos[_idx])
	_p.Fp_name = uintptr(unsafe.Pointer(&_protos)) + uintptr(_idx+int32(1))
	_p.Fp_aliases = uintptr(unsafe.Pointer(&_aliases))
	_idx = int32(uint64(_idx) + (Xstrlen(tls, _p.Fp_name) + Uint64FromInt32(2)))
	return uintptr(unsafe.Pointer(&_p))
}

var _p Tprotoent

var _aliases uintptr

func Xgetprotobyname(tls *TLS, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p uintptr
	_ = p
	Xendprotoent(tls)
	for cond := true; cond; cond = p != 0 && Xstrcmp(tls, name, (*Tprotoent)(unsafe.Pointer(p)).Fp_name) != 0 {
		p = Xgetprotoent(tls)
	}
	return p
}

func Xgetprotobynumber(tls *TLS, num int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v num=%v, (%v:)", tls, num, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p uintptr
	_ = p
	Xendprotoent(tls)
	for cond := true; cond; cond = p != 0 && (*Tprotoent)(unsafe.Pointer(p)).Fp_proto != num {
		p = Xgetprotoent(tls)
	}
	return p
}

func Xrecv(tls *TLS, fd int32, buf uintptr, len1 Tsize_t, flags int32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v len1=%v flags=%v, (%v:)", tls, fd, buf, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xrecvfrom(tls, fd, buf, len1, flags, uintptr(0), uintptr(0))
}

func Xrecvfrom(tls *TLS, fd int32, buf uintptr, len1 Tsize_t, flags int32, addr uintptr, alen uintptr) (r1 Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v len1=%v flags=%v addr=%v alen=%v, (%v:)", tls, fd, buf, len1, flags, addr, alen, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_recvfrom)
	_ = int32(__SC_recvfrom)
	v2 = int64(fd)
	v3 = int64(buf)
	v4 = int64(len1)
	v5 = int64(flags)
	v6 = int64(addr)
	v7 = int64(alen)
	if int32(1) != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return X__syscall_ret(tls, uint64(v8))
}

func Xrecvmmsg(tls *TLS, fd int32, msgvec uintptr, vlen uint32, flags uint32, timeout uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v msgvec=%v vlen=%v flags=%v timeout=%v, (%v:)", tls, fd, msgvec, vlen, flags, timeout, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i uint32
	var mh uintptr
	var v2 int32
	_, _, _ = i, mh, v2
	mh = msgvec
	i = vlen
	for {
		if !(i != 0) {
			break
		}
		v2 = Int32FromInt32(0)
		(*Tmmsghdr)(unsafe.Pointer(mh)).Fmsg_hdr.F__pad2 = v2
		(*Tmmsghdr)(unsafe.Pointer(mh)).Fmsg_hdr.F__pad1 = v2
		goto _1
	_1:
		;
		i--
		mh += 64
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_recvmmsg), int64(fd), int64(msgvec), int64(vlen), int64(flags), int64(timeout), 0))))
}

func X__convert_scm_timestamps(tls *TLS, msg uintptr, csize Tsocklen_t) {
	if __ccgo_strace {
		trc("tls=%v msg=%v csize=%v, (%v:)", tls, msg, csize, origin(2))
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var cmsg, last, v2, v6, v8, p7 uintptr
	var type1 int32
	var _ /* tmp at bp+0 */ int64
	var _ /* tvts at bp+8 */ [2]int64
	_, _, _, _, _, _, _ = cmsg, last, type1, v2, v6, v8, p7
	if true {
		return
	}
	if !((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_control != 0) || !((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen != 0) {
		return
	}
	last = uintptr(0)
	type1 = 0
	if uint64((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen) >= uint64(16) {
		v2 = (*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_control
	} else {
		v2 = UintptrFromInt32(0)
	}
	cmsg = v2
	for {
		if !(cmsg != 0) {
			break
		}
		if (*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_level == int32(SOL_SOCKET) {
			switch (*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_type {
			case int32(SO_TIMESTAMP_OLD):
				goto _3
			case int32(SO_TIMESTAMPNS_OLD):
				goto _4
			}
			goto _5
		_3:
			;
			if type1 != 0 {
				goto _5
			}
			type1 = int32(SO_TIMESTAMP)
			goto common
		_4:
			;
			type1 = int32(SO_TIMESTAMPNS)
			goto common
		common:
			;
			Xmemcpy(tls, bp, cmsg+UintptrFromInt32(1)*16, uint64(8))
			(*(*[2]int64)(unsafe.Pointer(bp + 8)))[0] = *(*int64)(unsafe.Pointer(bp))
			Xmemcpy(tls, bp, cmsg+UintptrFromInt32(1)*16+uintptr(8), uint64(8))
			(*(*[2]int64)(unsafe.Pointer(bp + 8)))[int32(1)] = *(*int64)(unsafe.Pointer(bp))
			goto _5
		_5:
		}
		last = cmsg
		goto _1
	_1:
		;
		if uint64((*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_len) < uint64(16) || (uint64((*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_len)+uint64(8)-uint64(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1)))+uint64(16) >= uint64(int64((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_control+uintptr((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen))-int64(cmsg)) {
			v6 = uintptr(0)
		} else {
			v6 = cmsg + uintptr((uint64((*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_len)+Uint64FromInt64(8)-Uint64FromInt32(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1))))
		}
		cmsg = v6
	}
	if !(last != 0) || !(type1 != 0) {
		return
	}
	if (Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1)) + (Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1)) > uint64(csize-(*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen) {
		*(*int32)(unsafe.Pointer(msg + 48)) |= int32(MSG_CTRUNC)
		return
	}
	p7 = msg + 40
	*(*Tsocklen_t)(unsafe.Pointer(p7)) = Tsocklen_t(uint64(*(*Tsocklen_t)(unsafe.Pointer(p7))) + ((Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1)) + (Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1))))
	if uint64((*Tcmsghdr)(unsafe.Pointer(last)).Fcmsg_len) < uint64(16) || (uint64((*Tcmsghdr)(unsafe.Pointer(last)).Fcmsg_len)+uint64(8)-uint64(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1)))+uint64(16) >= uint64(int64((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_control+uintptr((*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen))-int64(last)) {
		v8 = uintptr(0)
	} else {
		v8 = last + uintptr((uint64((*Tcmsghdr)(unsafe.Pointer(last)).Fcmsg_len)+Uint64FromInt64(8)-Uint64FromInt32(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1))))
	}
	cmsg = v8
	(*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_level = int32(SOL_SOCKET)
	(*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_type = type1
	(*Tcmsghdr)(unsafe.Pointer(cmsg)).Fcmsg_len = uint32((Uint64FromInt64(16)+Uint64FromInt64(8)-Uint64FromInt32(1)) & ^(Uint64FromInt64(8)-Uint64FromInt32(1)) + Uint64FromInt64(16))
	Xmemcpy(tls, cmsg+UintptrFromInt32(1)*16, bp+8, uint64(16))
}

func Xrecvmsg(tls *TLS, fd int32, msg uintptr, flags int32) (r2 Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v msg=%v flags=%v, (%v:)", tls, fd, msg, flags, origin(2))
		defer func() { trc("-> %v", r2) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var orig uintptr
	var orig_controllen Tsocklen_t
	var r, v9 int64
	var r1 Tssize_t
	var v1, v2 int32
	var v3, v4, v5, v6, v7, v8 Tsyscall_arg_t
	var _ /* h at bp+0 */ Tmsghdr
	_, _, _, _, _, _, _, _, _, _, _, _, _ = orig, orig_controllen, r, r1, v1, v2, v3, v4, v5, v6, v7, v8, v9
	orig_controllen = (*Tmsghdr)(unsafe.Pointer(msg)).Fmsg_controllen
	orig = msg
	if msg != 0 {
		*(*Tmsghdr)(unsafe.Pointer(bp)) = *(*Tmsghdr)(unsafe.Pointer(msg))
		v1 = Int32FromInt32(0)
		(*(*Tmsghdr)(unsafe.Pointer(bp))).F__pad2 = v1
		(*(*Tmsghdr)(unsafe.Pointer(bp))).F__pad1 = v1
		msg = bp
	}
	v2 = int32(SYS_recvmsg)
	_ = int32(__SC_recvmsg)
	v3 = int64(fd)
	v4 = int64(msg)
	v5 = int64(flags)
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	v8 = int64(Int32FromInt32(0))
	if int32(1) != 0 {
		r = ___syscall_cp(tls, int64(v2), v3, v4, v5, v6, v7, v8)
	} else {
		r = X__syscall6(tls, int64(v2), v3, v4, v5, v6, v7, v8)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v9 = r
		goto _10
	}
	v9 = r
	goto _10
_10:
	r1 = X__syscall_ret(tls, uint64(v9))
	if r1 >= 0 {
		X__convert_scm_timestamps(tls, msg, orig_controllen)
	}
	if orig != 0 {
		*(*Tmsghdr)(unsafe.Pointer(orig)) = *(*Tmsghdr)(unsafe.Pointer(bp))
	}
	return r1
}

func Xres_init(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func X__res_mkquery(tls *TLS, op int32, dname uintptr, class int32, type1 int32, data uintptr, datalen int32, newrr uintptr, buf uintptr, buflen int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v op=%v dname=%v class=%v type1=%v data=%v datalen=%v newrr=%v buf=%v buflen=%v, (%v:)", tls, op, dname, class, type1, data, datalen, newrr, buf, buflen, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(304)
	defer tls.Free(304)
	var i, id, j, n int32
	var l Tsize_t
	var _ /* q at bp+0 */ [280]uint8
	var _ /* ts at bp+280 */ Ttimespec
	_, _, _, _, _ = i, id, j, l, n
	l = Xstrnlen(tls, dname, uint64(255))
	if l != 0 && int32(*(*uint8)(unsafe.Pointer(dname + uintptr(l-uint64(1))))) == int32('.') {
		l--
	}
	if l != 0 && int32(*(*uint8)(unsafe.Pointer(dname + uintptr(l-uint64(1))))) == int32('.') {
		return -int32(1)
	}
	n = int32(uint64(17) + l + BoolUint64(!!(l != 0)))
	if l > uint64(253) || buflen < n || uint32(op) > uint32(15) || uint32(class) > uint32(255) || uint32(type1) > uint32(255) {
		return -int32(1)
	}
	/* Construct query template - ID will be filled later */
	Xmemset(tls, bp, 0, uint64(n))
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(2)] = uint8(op*int32(8) + int32(1))
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(3)] = uint8(32) /* AD */
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(5)] = uint8(1)
	Xmemcpy(tls, bp+uintptr(13), dname, l)
	i = int32(13)
	for {
		if !((*(*[280]uint8)(unsafe.Pointer(bp)))[i] != 0) {
			break
		}
		j = i
		for {
			if !((*(*[280]uint8)(unsafe.Pointer(bp)))[j] != 0 && int32((*(*[280]uint8)(unsafe.Pointer(bp)))[j]) != int32('.')) {
				break
			}
			goto _2
		_2:
			;
			j++
		}
		if uint32(j-i)-uint32(1) > uint32(62) {
			return -int32(1)
		}
		(*(*[280]uint8)(unsafe.Pointer(bp)))[i-int32(1)] = uint8(j - i)
		goto _1
	_1:
		;
		i = j + int32(1)
	}
	(*(*[280]uint8)(unsafe.Pointer(bp)))[i+int32(1)] = uint8(type1)
	(*(*[280]uint8)(unsafe.Pointer(bp)))[i+int32(3)] = uint8(class)
	/* Make a reasonably unpredictable id */
	Xclock_gettime(tls, CLOCK_REALTIME, bp+280)
	id = int32((uint64((*(*Ttimespec)(unsafe.Pointer(bp + 280))).Ftv_nsec) + uint64((*(*Ttimespec)(unsafe.Pointer(bp + 280))).Ftv_nsec)/uint64(65536)) & uint64(0xffff))
	(*(*[280]uint8)(unsafe.Pointer(bp)))[0] = uint8(id / int32(256))
	(*(*[280]uint8)(unsafe.Pointer(bp)))[int32(1)] = uint8(id)
	Xmemcpy(tls, buf, bp, uint64(n))
	return n
}

func Xres_mkquery(tls *TLS, op int32, dname uintptr, class int32, type1 int32, data uintptr, datalen int32, newrr uintptr, buf uintptr, buflen int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v op=%v dname=%v class=%v type1=%v data=%v datalen=%v newrr=%v buf=%v buflen=%v, (%v:)", tls, op, dname, class, type1, data, datalen, newrr, buf, buflen, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__res_mkquery(tls, op, dname, class, type1, data, datalen, newrr, buf, buflen)
}

const POLLERR = 8
const POLLHUP = 16
const POLLIN = 1
const POLLMSG = 1024
const POLLNVAL = 32
const POLLOUT = 4
const POLLPRI = 2
const POLLRDBAND = 128
const POLLRDHUP = 8192
const POLLRDNORM = 64
const POLLWRBAND = 512
const POLLWRNORM = 256
const TCP_CC_INFO = 26
const TCP_CLOSE = 7
const TCP_CLOSE_WAIT = 8
const TCP_CLOSING = 11
const TCP_CM_INQ = 36
const TCP_CONGESTION = 13
const TCP_CORK = 3
const TCP_DEFER_ACCEPT = 9
const TCP_ESTABLISHED = 1
const TCP_FASTOPEN = 23
const TCP_FASTOPEN_CONNECT = 30
const TCP_FASTOPEN_KEY = 33
const TCP_FASTOPEN_NO_COOKIE = 34
const TCP_FIN_WAIT1 = 4
const TCP_FIN_WAIT2 = 5
const TCP_INFO = 11
const TCP_INQ = 36
const TCP_KEEPCNT = 6
const TCP_KEEPIDLE = 4
const TCP_KEEPINTVL = 5
const TCP_LAST_ACK = 9
const TCP_LINGER2 = 8
const TCP_LISTEN = 10
const TCP_MAXSEG = 2
const TCP_MD5SIG = 14
const TCP_MD5SIG_EXT = 32
const TCP_NODELAY = 1
const TCP_NOTSENT_LOWAT = 25
const TCP_QUEUE_SEQ = 21
const TCP_QUICKACK = 12
const TCP_REPAIR = 19
const TCP_REPAIR_OPTIONS = 22
const TCP_REPAIR_QUEUE = 20
const TCP_REPAIR_WINDOW = 29
const TCP_SAVED_SYN = 28
const TCP_SAVE_SYN = 27
const TCP_SYNCNT = 7
const TCP_SYN_RECV = 3
const TCP_SYN_SENT = 2
const TCP_THIN_DUPACK = 17
const TCP_THIN_LINEAR_TIMEOUTS = 16
const TCP_TIMESTAMP = 24
const TCP_TIME_WAIT = 6
const TCP_TX_DELAY = 37
const TCP_ULP = 31
const TCP_USER_TIMEOUT = 18
const TCP_WINDOW_CLAMP = 10
const TCP_ZEROCOPY_RECEIVE = 35

const _TCP_NLA_PAD = 0
const _TCP_NLA_BUSY = 1
const _TCP_NLA_RWND_LIMITED = 2
const _TCP_NLA_SNDBUF_LIMITED = 3
const _TCP_NLA_DATA_SEGS_OUT = 4
const _TCP_NLA_TOTAL_RETRANS = 5
const _TCP_NLA_PACING_RATE = 6
const _TCP_NLA_DELIVERY_RATE = 7
const _TCP_NLA_SND_CWND = 8
const _TCP_NLA_REORDERING = 9
const _TCP_NLA_MIN_RTT = 10
const _TCP_NLA_RECUR_RETRANS = 11
const _TCP_NLA_DELIVERY_RATE_APP_LMT = 12
const _TCP_NLA_SNDQ_SIZE = 13
const _TCP_NLA_CA_STATE = 14
const _TCP_NLA_SND_SSTHRESH = 15
const _TCP_NLA_DELIVERED = 16
const _TCP_NLA_DELIVERED_CE = 17
const _TCP_NLA_BYTES_SENT = 18
const _TCP_NLA_BYTES_RETRANS = 19
const _TCP_NLA_DSACK_DUPS = 20
const _TCP_NLA_REORD_SEEN = 21
const _TCP_NLA_SRTT = 22
const _TCP_NLA_TIMEOUT_REHASH = 23
const _TCP_NLA_BYTES_NOTSENT = 24
const _TCP_NLA_EDT = 25
const _TCP_NLA_TTL = 26

type Tnfds_t = uint64

type Tpollfd = struct {
	Ffd      int32
	Fevents  int16
	Frevents int16
}

func _cleanup(tls *TLS, p uintptr) {
	var i int32
	var pfd uintptr
	_, _ = i, pfd
	pfd = p
	i = 0
	for {
		if !((*(*Tpollfd)(unsafe.Pointer(pfd + uintptr(i)*8))).Ffd >= -int32(1)) {
			break
		}
		if (*(*Tpollfd)(unsafe.Pointer(pfd + uintptr(i)*8))).Ffd >= 0 {
			X__syscall1(tls, int64(SYS_close), int64((*(*Tpollfd)(unsafe.Pointer(pfd + uintptr(i)*8))).Ffd))
		}
		goto _1
	_1:
		;
		i++
	}
}

func _mtime(tls *TLS) (r uint64) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* ts at bp+0 */ Ttimespec
	if Xclock_gettime(tls, int32(CLOCK_MONOTONIC), bp) < 0 && *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(ENOSYS) {
		Xclock_gettime(tls, CLOCK_REALTIME, bp)
	}
	return uint64((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec)*uint64(1000) + uint64((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec/int64(1000000))
}

func _start_tcp(tls *TLS, pfd uintptr, family int32, sa uintptr, sl Tsocklen_t, q uintptr, ql int32) (r1 int32) {
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var fd, r int32
	var _ /* mh at bp+40 */ Tmsghdr
	_, _ = fd, r
	*(*[2]Tuint8_t)(unsafe.Pointer(bp + 32)) = [2]Tuint8_t{
		0: uint8(ql >> int32(8)),
		1: uint8(ql),
	}
	*(*[2]Tiovec)(unsafe.Pointer(bp)) = [2]Tiovec{
		0: {
			Fiov_base: bp + 32,
			Fiov_len:  uint64(2),
		},
		1: {
			Fiov_base: q,
			Fiov_len:  uint64(ql),
		},
	}
	*(*Tmsghdr)(unsafe.Pointer(bp + 40)) = Tmsghdr{
		Fmsg_name:    sa,
		Fmsg_namelen: sl,
		Fmsg_iov:     bp,
		Fmsg_iovlen:  int32(2),
	}
	fd = Xsocket(tls, family, Int32FromInt32(SOCK_STREAM)|Int32FromInt32(SOCK_CLOEXEC)|Int32FromInt32(SOCK_NONBLOCK), 0)
	(*Tpollfd)(unsafe.Pointer(pfd)).Ffd = fd
	(*Tpollfd)(unsafe.Pointer(pfd)).Fevents = int16(POLLOUT)
	*(*int32)(unsafe.Pointer(bp + 36)) = int32(1)
	if !(Xsetsockopt(tls, fd, int32(IPPROTO_TCP), int32(TCP_FASTOPEN_CONNECT), bp+36, uint32(4)) != 0) {
		r = int32(Xsendmsg(tls, fd, bp+40, Int32FromInt32(MSG_FASTOPEN)|Int32FromInt32(MSG_NOSIGNAL)))
		if r == ql+int32(2) {
			(*Tpollfd)(unsafe.Pointer(pfd)).Fevents = int16(POLLIN)
		}
		if r >= 0 {
			return r
		}
		if *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EINPROGRESS) {
			return 0
		}
	}
	r = Xconnect(tls, fd, sa, sl)
	if !(r != 0) || *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EINPROGRESS) {
		return 0
	}
	Xclose(tls, fd)
	(*Tpollfd)(unsafe.Pointer(pfd)).Ffd = -int32(1)
	return -int32(1)
}

func _step_mh(tls *TLS, mh uintptr, n Tsize_t) {
	/* Adjust iovec in msghdr to skip first n bytes. */
	for (*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iovlen != 0 && n >= (*Tiovec)(unsafe.Pointer((*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iov)).Fiov_len {
		n -= (*Tiovec)(unsafe.Pointer((*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iov)).Fiov_len
		(*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iov += 16
		(*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iovlen--
	}
	if !((*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iovlen != 0) {
		return
	}
	(*Tiovec)(unsafe.Pointer((*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iov)).Fiov_base = (*Tiovec)(unsafe.Pointer((*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iov)).Fiov_base + uintptr(n)
	*(*Tsize_t)(unsafe.Pointer((*Tmsghdr)(unsafe.Pointer(mh)).Fmsg_iov + 8)) -= n
}

/* Internal contract for __res_msend[_rc]: asize must be >=512, nqueries
 * must be sufficiently small to be safe as VLA size. In practice it's
 * either 1 or 2, anyway. */

func X__res_msend_rc(tls *TLS, nqueries int32, queries uintptr, qlens uintptr, answers uintptr, alens uintptr, asize int32, conf uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v nqueries=%v queries=%v qlens=%v answers=%v alens=%v asize=%v conf=%v, (%v:)", tls, nqueries, queries, qlens, answers, alens, asize, conf, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(400)
	defer tls.Free(400)
	var alen, attempts, family, fd, i, j, next, nns, r, rcode, retry_interval, rlen, servfail_retry, timeout, v17, v6 int32
	var alen_buf, apos, iplit, pfd, qpos uintptr
	var sl Tsocklen_t
	var t0, t1, t2, v10 uint64
	var v1, v2, v3, v4 t__predefined_size_t
	var v18 bool
	var _ /* __cb at bp+208 */ t__ptcb
	var _ /* cs at bp+200 */ int32
	var _ /* mh at bp+232 */ Tmsghdr
	var _ /* mh at bp+288 */ Tmsghdr
	var _ /* mh at bp+344 */ Tmsghdr
	var _ /* ns at bp+116 */ [3]struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}
	var _ /* sa at bp+88 */ struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = alen, alen_buf, apos, attempts, family, fd, i, iplit, j, next, nns, pfd, qpos, r, rcode, retry_interval, rlen, servfail_retry, sl, t0, t1, t2, timeout, v1, v10, v17, v18, v2, v3, v4, v6
	defer func() {
		Xrealloc(tls, alen_buf, 0)
		Xrealloc(tls, apos, 0)
		Xrealloc(tls, pfd, 0)
		Xrealloc(tls, qpos, 0)
	}()
	*(*struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	})(unsafe.Pointer(bp + 88)) = struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}{}
	*(*uint16)(unsafe.Pointer(bp + 88)) = uint16(0)
	*(*[3]struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	})(unsafe.Pointer(bp + 116)) = [3]struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	}{}
	sl = uint32(16)
	nns = 0
	family = int32(PF_INET)
	v1 = uint64(nqueries+int32(2)) * 8
	pfd = Xrealloc(tls, pfd, v1)
	v2 = uint64(nqueries) * 4
	qpos = Xrealloc(tls, qpos, v2)
	v3 = uint64(nqueries) * 4
	apos = Xrealloc(tls, apos, v3)
	v4 = uint64(nqueries) * 2
	alen_buf = Xrealloc(tls, alen_buf, v4)
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+200)
	timeout = int32(uint32(1000) * (*Tresolvconf)(unsafe.Pointer(conf)).Ftimeout)
	attempts = int32((*Tresolvconf)(unsafe.Pointer(conf)).Fattempts)
	nns = 0
	for {
		if !(uint32(nns) < (*Tresolvconf)(unsafe.Pointer(conf)).Fnns) {
			break
		}
		iplit = conf + uintptr(nns)*28
		if (*Taddress)(unsafe.Pointer(iplit)).Ffamily == int32(PF_INET) {
			Xmemcpy(tls, bp+116+uintptr(nns)*28+4, iplit+8, uint64(4))
			(*(*[3]struct {
				Fsin6        [0]Tsockaddr_in6
				Fsin         Tsockaddr_in
				F__ccgo_pad2 [12]byte
			})(unsafe.Pointer(bp + 116)))[nns].Fsin.Fsin_port = Xhtons(tls, uint16(53))
			(*(*[3]struct {
				Fsin6        [0]Tsockaddr_in6
				Fsin         Tsockaddr_in
				F__ccgo_pad2 [12]byte
			})(unsafe.Pointer(bp + 116)))[nns].Fsin.Fsin_family = uint16(PF_INET)
		} else {
			sl = uint32(28)
			Xmemcpy(tls, bp+116+uintptr(nns)*28+8, iplit+8, uint64(16))
			(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 116 + uintptr(nns)*28))).Fsin6_port = Xhtons(tls, uint16(53))
			(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 116 + uintptr(nns)*28))).Fsin6_scope_id = (*Taddress)(unsafe.Pointer(iplit)).Fscopeid
			v6 = Int32FromInt32(PF_INET6)
			family = v6
			(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 116 + uintptr(nns)*28))).Fsin6_family = uint16(v6)
		}
		goto _5
	_5:
		;
		nns++
	}
	/* Get local address and open/bind a socket */
	fd = Xsocket(tls, family, Int32FromInt32(SOCK_DGRAM)|Int32FromInt32(SOCK_CLOEXEC)|Int32FromInt32(SOCK_NONBLOCK), 0)
	/* Handle case where system lacks IPv6 support */
	if fd < 0 && family == int32(PF_INET6) && *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EAFNOSUPPORT) {
		i = 0
		for {
			if !(i < nns && (*(*Taddress)(unsafe.Pointer(conf + uintptr(nns)*28))).Ffamily == int32(PF_INET6)) {
				break
			}
			goto _7
		_7:
			;
			i++
		}
		if i == nns {
			_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 200)), uintptr(0))
			return -int32(1)
		}
		fd = Xsocket(tls, int32(PF_INET), Int32FromInt32(SOCK_DGRAM)|Int32FromInt32(SOCK_CLOEXEC)|Int32FromInt32(SOCK_NONBLOCK), 0)
		family = int32(PF_INET)
		sl = uint32(16)
	}
	/* Convert any IPv4 addresses in a mixed environment to v4-mapped */
	if fd >= 0 && family == int32(PF_INET6) {
		*(*int32)(unsafe.Pointer(bp)) = 0
		Xsetsockopt(tls, fd, int32(IPPROTO_IPV6), int32(IPV6_V6ONLY), bp, uint32(4))
		i = 0
		for {
			if !(i < nns) {
				break
			}
			if int32((*(*[3]struct {
				Fsin6        [0]Tsockaddr_in6
				Fsin         Tsockaddr_in
				F__ccgo_pad2 [12]byte
			})(unsafe.Pointer(bp + 116)))[i].Fsin.Fsin_family) != int32(PF_INET) {
				goto _8
			}
			Xmemcpy(tls, bp+116+uintptr(i)*28+8+uintptr(12), bp+116+uintptr(i)*28+4, uint64(4))
			Xmemcpy(tls, bp+116+uintptr(i)*28+8, __ccgo_ts+1027, uint64(12))
			(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 116 + uintptr(i)*28))).Fsin6_family = uint16(PF_INET6)
			(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 116 + uintptr(i)*28))).Fsin6_flowinfo = uint32(0)
			(*(*Tsockaddr_in6)(unsafe.Pointer(bp + 116 + uintptr(i)*28))).Fsin6_scope_id = uint32(0)
			goto _8
		_8:
			;
			i++
		}
	}
	(*(*struct {
		Fsin6        [0]Tsockaddr_in6
		Fsin         Tsockaddr_in
		F__ccgo_pad2 [12]byte
	})(unsafe.Pointer(bp + 88))).Fsin.Fsin_family = uint16(family)
	if fd < 0 || Xbind(tls, fd, bp+88, sl) < 0 {
		if fd >= 0 {
			Xclose(tls, fd)
		}
		_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 200)), uintptr(0))
		return -int32(1)
	}
	/* Past this point, there are no errors. Each individual query will
	 * yield either no reply (indicated by zero length) or an answer
	 * packet which is up to the caller to interpret. */
	i = 0
	for {
		if !(i < nqueries) {
			break
		}
		(*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), i*8))).Ffd = -int32(1)
		goto _9
	_9:
		;
		i++
	}
	(*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), nqueries*8))).Ffd = fd
	(*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), nqueries*8))).Fevents = int16(POLLIN)
	(*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), (nqueries+int32(1))*8))).Ffd = -int32(2)
	__pthread_cleanup_push(tls, bp+208, __ccgo_fp(_cleanup), pfd)
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 200)), uintptr(0))
	Xmemset(tls, alens, 0, uint64(4)*uint64(nqueries))
	retry_interval = timeout / attempts
	next = 0
	v10 = _mtime(tls)
	t2 = v10
	t0 = v10
	t1 = t2 - uint64(retry_interval)
	for {
		if !(t2-t0 < uint64(timeout)) {
			break
		}
		/* This is the loop exit condition: that all queries
		 * have an accepted answer. */
		i = 0
		for {
			if !(i < nqueries && *(*int32)(unsafe.Pointer(alens + uintptr(i)*4)) > 0) {
				break
			}
			goto _12
		_12:
			;
			i++
		}
		if i == nqueries {
			break
		}
		if t2-t1 >= uint64(retry_interval) {
			/* Query all configured namservers in parallel */
			i = 0
			for {
				if !(i < nqueries) {
					break
				}
				if !(*(*int32)(unsafe.Pointer(alens + uintptr(i)*4)) != 0) {
					j = 0
					for {
						if !(j < nns) {
							break
						}
						Xsendto(tls, fd, *(*uintptr)(unsafe.Pointer(queries + uintptr(i)*8)), uint64(*(*int32)(unsafe.Pointer(qlens + uintptr(i)*4))), int32(MSG_NOSIGNAL), bp+116+uintptr(j)*28, sl)
						goto _14
					_14:
						;
						j++
					}
				}
				goto _13
			_13:
				;
				i++
			}
			t1 = t2
			servfail_retry = int32(2) * nqueries
		}
		/* Wait for a response, or until time to retry */
		if Xpoll(tls, pfd, uint64(nqueries+int32(1)), int32(t1+uint64(retry_interval)-t2)) <= 0 {
			goto _11
		}
		for next < nqueries {
			*(*[1]Tiovec)(unsafe.Pointer(bp + 8)) = [1]Tiovec{
				0: {
					Fiov_base: *(*uintptr)(unsafe.Pointer(answers + uintptr(next)*8)),
					Fiov_len:  uint64(asize),
				},
			}
			*(*Tmsghdr)(unsafe.Pointer(bp + 232)) = Tmsghdr{
				Fmsg_name:    bp + 88,
				Fmsg_namelen: sl,
				Fmsg_iov:     bp + 8,
				Fmsg_iovlen:  int32(1),
			}
			rlen = int32(Xrecvmsg(tls, fd, bp+232, 0))
			if rlen < 0 {
				break
			}
			/* Ignore non-identifiable packets */
			if rlen < int32(4) {
				continue
			}
			/* Ignore replies from addresses we didn't send to */
			j = 0
			for {
				if !(j < nns && Xmemcmp(tls, bp+116+uintptr(j)*28, bp+88, uint64(sl)) != 0) {
					break
				}
				goto _15
			_15:
				;
				j++
			}
			if j == nns {
				continue
			}
			/* Find which query this answer goes with, if any */
			i = next
			for {
				if !(i < nqueries && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(answers + uintptr(next)*8))))) != int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(queries + uintptr(i)*8))))) || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(answers + uintptr(next)*8)) + 1))) != int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(queries + uintptr(i)*8)) + 1))))) {
					break
				}
				goto _16
			_16:
				;
				i++
			}
			if i == nqueries {
				continue
			}
			if *(*int32)(unsafe.Pointer(alens + uintptr(i)*4)) != 0 {
				continue
			}
			/* Only accept positive or negative responses;
			 * retry immediately on server failure, and ignore
			 * all other codes such as refusal. */
			switch int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(answers + uintptr(next)*8)) + 3))) & Int32FromInt32(15) {
			case 0:
				fallthrough
			case int32(3):
			case int32(2):
				if v18 = servfail_retry != 0; v18 {
					v17 = servfail_retry
					servfail_retry--
				}
				if v18 && v17 != 0 {
					Xsendto(tls, fd, *(*uintptr)(unsafe.Pointer(queries + uintptr(i)*8)), uint64(*(*int32)(unsafe.Pointer(qlens + uintptr(i)*4))), int32(MSG_NOSIGNAL), bp+116+uintptr(j)*28, sl)
				}
				fallthrough
			default:
				continue
			}
			/* Store answer in the right slot, or update next
			 * available temp slot if it's already in place. */
			*(*int32)(unsafe.Pointer(alens + uintptr(i)*4)) = rlen
			if i == next {
				for {
					if !(next < nqueries && *(*int32)(unsafe.Pointer(alens + uintptr(next)*4)) != 0) {
						break
					}
					goto _19
				_19:
					;
					next++
				}
			} else {
				Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(answers + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(answers + uintptr(next)*8)), uint64(rlen))
			}
			/* Ignore further UDP if all slots full or TCP-mode */
			if next == nqueries {
				(*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), nqueries*8))).Fevents = 0
			}
			/* If answer is truncated (TC bit), fallback to TCP */
			if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(answers + uintptr(i)*8)) + 2)))&int32(2) != 0 || (*(*Tmsghdr)(unsafe.Pointer(bp + 232))).Fmsg_flags&int32(MSG_TRUNC) != 0 {
				*(*int32)(unsafe.Pointer(alens + uintptr(i)*4)) = -int32(1)
				_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), uintptr(0))
				r = _start_tcp(tls, pfd+uintptr(i)*8, family, bp+116+uintptr(j)*28, sl, *(*uintptr)(unsafe.Pointer(queries + uintptr(i)*8)), *(*int32)(unsafe.Pointer(qlens + uintptr(i)*4)))
				_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 200)), uintptr(0))
				if r >= 0 {
					*(*int32)(unsafe.Add(unsafe.Pointer(qpos), i*4)) = r
					*(*int32)(unsafe.Add(unsafe.Pointer(apos), i*4)) = 0
				}
				continue
			}
		}
		i = 0
		for {
			if !(i < nqueries) {
				break
			}
			if int32((*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), i*8))).Frevents)&int32(POLLOUT) != 0 {
				*(*[2]Tuint8_t)(unsafe.Pointer(bp + 52)) = [2]Tuint8_t{
					0: uint8(*(*int32)(unsafe.Pointer(qlens + uintptr(i)*4)) >> int32(8)),
					1: uint8(*(*int32)(unsafe.Pointer(qlens + uintptr(i)*4))),
				}
				*(*[2]Tiovec)(unsafe.Pointer(bp + 24)) = [2]Tiovec{
					0: {
						Fiov_base: bp + 52,
						Fiov_len:  uint64(2),
					},
					1: {
						Fiov_base: *(*uintptr)(unsafe.Pointer(queries + uintptr(i)*8)),
						Fiov_len:  uint64(*(*int32)(unsafe.Pointer(qlens + uintptr(i)*4))),
					},
				}
				*(*Tmsghdr)(unsafe.Pointer(bp + 288)) = Tmsghdr{
					Fmsg_iov:    bp + 24,
					Fmsg_iovlen: int32(2),
				}
				_step_mh(tls, bp+288, uint64(*(*int32)(unsafe.Add(unsafe.Pointer(qpos), i*4))))
				r = int32(Xsendmsg(tls, (*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), i*8))).Ffd, bp+288, int32(MSG_NOSIGNAL)))
				if r < 0 {
					goto out
				}
				*(*int32)(unsafe.Pointer(qpos + uintptr(i)*4)) += r
				if *(*int32)(unsafe.Add(unsafe.Pointer(qpos), i*4)) == *(*int32)(unsafe.Pointer(qlens + uintptr(i)*4))+int32(2) {
					(*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), i*8))).Fevents = int16(POLLIN)
				}
			}
			goto _20
		_20:
			;
			i++
		}
		i = 0
		for {
			if !(i < nqueries) {
				break
			}
			if int32((*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), i*8))).Frevents)&int32(POLLIN) != 0 {
				*(*[2]Tiovec)(unsafe.Pointer(bp + 56)) = [2]Tiovec{
					0: {
						Fiov_base: alen_buf + uintptr(i)*2,
						Fiov_len:  uint64(2),
					},
					1: {
						Fiov_base: *(*uintptr)(unsafe.Pointer(answers + uintptr(i)*8)),
						Fiov_len:  uint64(asize),
					},
				}
				*(*Tmsghdr)(unsafe.Pointer(bp + 344)) = Tmsghdr{
					Fmsg_iov:    bp + 56,
					Fmsg_iovlen: int32(2),
				}
				_step_mh(tls, bp+344, uint64(*(*int32)(unsafe.Add(unsafe.Pointer(apos), i*4))))
				r = int32(Xrecvmsg(tls, (*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), i*8))).Ffd, bp+344, 0))
				if r <= 0 {
					goto out
				}
				*(*int32)(unsafe.Pointer(apos + uintptr(i)*4)) += r
				if *(*int32)(unsafe.Add(unsafe.Pointer(apos), i*4)) < int32(2) {
					goto _21
				}
				alen = int32(*(*uint8)(unsafe.Pointer(alen_buf + uintptr(i)*2)))*int32(256) + int32(*(*uint8)(unsafe.Pointer(alen_buf + uintptr(i)*2 + 1)))
				if alen < int32(13) {
					goto out
				}
				if *(*int32)(unsafe.Add(unsafe.Pointer(apos), i*4)) < alen+int32(2) && *(*int32)(unsafe.Add(unsafe.Pointer(apos), i*4)) < asize+int32(2) {
					goto _21
				}
				rcode = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(answers + uintptr(i)*8)) + 3))) & int32(15)
				if rcode != 0 && rcode != int32(3) {
					goto out
				}
				/* Storing the length here commits the accepted answer.
				 * Immediately close TCP socket so as not to consume
				 * resources we no longer need. */
				*(*int32)(unsafe.Pointer(alens + uintptr(i)*4)) = alen
				X__syscall1(tls, int64(SYS_close), int64((*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), i*8))).Ffd))
				(*(*Tpollfd)(unsafe.Add(unsafe.Pointer(pfd), i*8))).Ffd = -int32(1)
			}
			goto _21
		_21:
			;
			i++
		}
		goto _11
	_11:
		;
		t2 = _mtime(tls)
	}
	goto out
out:
	;
	__pthread_cleanup_pop(tls, bp+208, int32(1))
	/* Disregard any incomplete TCP results */
	i = 0
	for {
		if !(i < nqueries) {
			break
		}
		if *(*int32)(unsafe.Pointer(alens + uintptr(i)*4)) < 0 {
			*(*int32)(unsafe.Pointer(alens + uintptr(i)*4)) = 0
		}
		goto _22
	_22:
		;
		i++
	}
	return 0
}

func X__res_msend(tls *TLS, nqueries int32, queries uintptr, qlens uintptr, answers uintptr, alens uintptr, asize int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v nqueries=%v queries=%v qlens=%v answers=%v alens=%v asize=%v, (%v:)", tls, nqueries, queries, qlens, answers, alens, asize, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var _ /* conf at bp+0 */ Tresolvconf
	if X__get_resolv_conf(tls, bp, uintptr(0), uint64(0)) < 0 {
		return -int32(1)
	}
	return X__res_msend_rc(tls, nqueries, queries, qlens, answers, alens, asize, bp)
}

func X__res_send(tls *TLS, _msg uintptr, _msglen int32, _answer uintptr, _anslen int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v _msg=%v _msglen=%v _answer=%v _anslen=%v, (%v:)", tls, _msg, _msglen, _answer, _anslen, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(544)
	defer tls.Free(544)
	*(*uintptr)(unsafe.Pointer(bp)) = _msg
	*(*int32)(unsafe.Pointer(bp + 8)) = _msglen
	*(*uintptr)(unsafe.Pointer(bp + 16)) = _answer
	*(*int32)(unsafe.Pointer(bp + 24)) = _anslen
	var r, v1, v2 int32
	var _ /* buf at bp+28 */ [512]uint8
	_, _, _ = r, v1, v2
	if *(*int32)(unsafe.Pointer(bp + 24)) < int32(512) {
		r = X__res_send(tls, *(*uintptr)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 8)), bp+28, int32(512))
		if r >= 0 {
			if r < *(*int32)(unsafe.Pointer(bp + 24)) {
				v1 = r
			} else {
				v1 = *(*int32)(unsafe.Pointer(bp + 24))
			}
			Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(bp + 16)), bp+28, uint64(v1))
		}
		return r
	}
	r = X__res_msend(tls, int32(1), bp, bp+8, bp+16, bp+24, *(*int32)(unsafe.Pointer(bp + 24)))
	if r < 0 || !(*(*int32)(unsafe.Pointer(bp + 24)) != 0) {
		v2 = -int32(1)
	} else {
		v2 = *(*int32)(unsafe.Pointer(bp + 24))
	}
	return v2
}

func Xres_send(tls *TLS, _msg uintptr, _msglen int32, _answer uintptr, _anslen int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v _msg=%v _msglen=%v _answer=%v _anslen=%v, (%v:)", tls, _msg, _msglen, _answer, _anslen, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__res_send(tls, _msg, _msglen, _answer, _anslen)
}

/* This is completely unused, and exists purely to satisfy broken apps. */

func X__res_state(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(unsafe.Pointer(&_res1))
}

var _res1 t__res_state

func X__get_resolv_conf(tls *TLS, conf uintptr, search uintptr, search_sz Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v conf=%v search=%v search_sz=%v, (%v:)", tls, conf, search, search_sz, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(752)
	defer tls.Free(752)
	var c, nns, v1, v13, v14, v17, v18, v2, v21, v22, v26, v27, v8, v9 int32
	var f, p uintptr
	var l Tsize_t
	var x, x1, x2, v5, v6, v7 uint64
	var v11, v20, v24, v4 bool
	var _ /* _buf at bp+256 */ [256]uint8
	var _ /* _f at bp+512 */ TFILE
	var _ /* line at bp+0 */ [256]uint8
	var _ /* z at bp+744 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, f, l, nns, p, x, x1, x2, v1, v11, v13, v14, v17, v18, v2, v20, v21, v22, v24, v26, v27, v4, v5, v6, v7, v8, v9
	nns = 0
	(*Tresolvconf)(unsafe.Pointer(conf)).Fndots = uint32(1)
	(*Tresolvconf)(unsafe.Pointer(conf)).Ftimeout = uint32(5)
	(*Tresolvconf)(unsafe.Pointer(conf)).Fattempts = uint32(2)
	if search != 0 {
		*(*uint8)(unsafe.Pointer(search)) = uint8(0)
	}
	f = X__fopen_rb_ca(tls, __ccgo_ts+1149, bp+512, bp+256, uint64(256))
	if !(f != 0) {
		switch *(*int32)(unsafe.Pointer(X__errno_location(tls))) {
		case int32(ENOENT):
			fallthrough
		case int32(ENOTDIR):
			fallthrough
		case int32(EACCES):
			goto no_resolv_conf
		default:
			return -int32(1)
		}
	}
	for Xfgets(tls, bp, int32(256), f) != 0 {
		if !(Xstrchr(tls, bp, int32('\n')) != 0) && !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_EOF) != 0) {
			for cond := true; cond; cond = c != int32('\n') && c != -int32(1) {
				c = Xgetc(tls, f)
			}
			continue
		}
		if v4 = !(Xstrncmp(tls, bp, __ccgo_ts+1166, uint64(7)) != 0); v4 {
			v1 = int32((*(*[256]uint8)(unsafe.Pointer(bp)))[int32(7)])
			v2 = BoolInt32(v1 == int32(' ') || uint32(v1)-uint32('\t') < uint32(5))
			goto _3
		_3:
		}
		if v4 && v2 != 0 {
			p = Xstrstr(tls, bp, __ccgo_ts+1174)
			if p != 0 && BoolInt32(uint32(*(*uint8)(unsafe.Pointer(p + 6)))-uint32('0') < uint32(10)) != 0 {
				p += uintptr(6)
				x = Xstrtoul(tls, p, bp+744, int32(10))
				if *(*uintptr)(unsafe.Pointer(bp + 744)) != p {
					if x > uint64(15) {
						v5 = uint64(15)
					} else {
						v5 = x
					}
					(*Tresolvconf)(unsafe.Pointer(conf)).Fndots = uint32(v5)
				}
			}
			p = Xstrstr(tls, bp, __ccgo_ts+1181)
			if p != 0 && BoolInt32(uint32(*(*uint8)(unsafe.Pointer(p + 9)))-uint32('0') < uint32(10)) != 0 {
				p += uintptr(9)
				x1 = Xstrtoul(tls, p, bp+744, int32(10))
				if *(*uintptr)(unsafe.Pointer(bp + 744)) != p {
					if x1 > uint64(10) {
						v6 = uint64(10)
					} else {
						v6 = x1
					}
					(*Tresolvconf)(unsafe.Pointer(conf)).Fattempts = uint32(v6)
				}
			}
			p = Xstrstr(tls, bp, __ccgo_ts+1191)
			if p != 0 && (BoolInt32(uint32(*(*uint8)(unsafe.Pointer(p + 8)))-uint32('0') < uint32(10)) != 0 || int32(*(*uint8)(unsafe.Pointer(p + 8))) == int32('.')) {
				p += uintptr(8)
				x2 = Xstrtoul(tls, p, bp+744, int32(10))
				if *(*uintptr)(unsafe.Pointer(bp + 744)) != p {
					if x2 > uint64(60) {
						v7 = uint64(60)
					} else {
						v7 = x2
					}
					(*Tresolvconf)(unsafe.Pointer(conf)).Ftimeout = uint32(v7)
				}
			}
			continue
		}
		if v11 = !(Xstrncmp(tls, bp, __ccgo_ts+1200, uint64(10)) != 0); v11 {
			v8 = int32((*(*[256]uint8)(unsafe.Pointer(bp)))[int32(10)])
			v9 = BoolInt32(v8 == int32(' ') || uint32(v8)-uint32('\t') < uint32(5))
			goto _10
		_10:
		}
		if v11 && v9 != 0 {
			if nns >= int32(MAXNS) {
				continue
			}
			p = bp + uintptr(11)
			for {
				v13 = int32(*(*uint8)(unsafe.Pointer(p)))
				v14 = BoolInt32(v13 == int32(' ') || uint32(v13)-uint32('\t') < uint32(5))
				goto _15
			_15:
				if !(v14 != 0) {
					break
				}
				goto _12
			_12:
				;
				p++
			}
			*(*uintptr)(unsafe.Pointer(bp + 744)) = p
			for {
				if v20 = *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 744)))) != 0; v20 {
					v17 = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 744)))))
					v18 = BoolInt32(v17 == int32(' ') || uint32(v17)-uint32('\t') < uint32(5))
					goto _19
				_19:
				}
				if !(v20 && !(v18 != 0)) {
					break
				}
				goto _16
			_16:
				;
				*(*uintptr)(unsafe.Pointer(bp + 744))++
			}
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 744)))) = uint8(0)
			if X__lookup_ipliteral(tls, conf+uintptr(nns)*28, p, PF_UNSPEC) > 0 {
				nns++
			}
			continue
		}
		if !(search != 0) {
			continue
		}
		if v24 = Xstrncmp(tls, bp, __ccgo_ts+1211, uint64(6)) != 0 && Xstrncmp(tls, bp, __ccgo_ts+1218, uint64(6)) != 0; !v24 {
			v21 = int32((*(*[256]uint8)(unsafe.Pointer(bp)))[int32(6)])
			v22 = BoolInt32(v21 == int32(' ') || uint32(v21)-uint32('\t') < uint32(5))
			goto _23
		_23:
		}
		if v24 || !(v22 != 0) {
			continue
		}
		p = bp + uintptr(7)
		for {
			v26 = int32(*(*uint8)(unsafe.Pointer(p)))
			v27 = BoolInt32(v26 == int32(' ') || uint32(v26)-uint32('\t') < uint32(5))
			goto _28
		_28:
			if !(v27 != 0) {
				break
			}
			goto _25
		_25:
			;
			p++
		}
		l = Xstrlen(tls, p)
		/* This can never happen anyway with chosen buffer sizes. */
		if l >= search_sz {
			continue
		}
		Xmemcpy(tls, search, p, l+uint64(1))
	}
	X__fclose_ca(tls, f)
	goto no_resolv_conf
no_resolv_conf:
	;
	if !(nns != 0) {
		X__lookup_ipliteral(tls, conf, __ccgo_ts+1225, PF_UNSPEC)
		nns = int32(1)
	}
	(*Tresolvconf)(unsafe.Pointer(conf)).Fnns = uint32(nns)
	return 0
}

func Xsend(tls *TLS, fd int32, buf uintptr, len1 Tsize_t, flags int32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v len1=%v flags=%v, (%v:)", tls, fd, buf, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsendto(tls, fd, buf, len1, flags, uintptr(0), uint32(0))
}

func Xsendmmsg(tls *TLS, fd int32, msgvec uintptr, vlen uint32, flags uint32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v msgvec=%v vlen=%v flags=%v, (%v:)", tls, fd, msgvec, vlen, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var i, v2 int32
	var r Tssize_t
	_, _, _ = i, r, v2
	if vlen > uint32(IOV_MAX) {
		vlen = uint32(IOV_MAX)
	} /* This matches the kernel. */
	if !(vlen != 0) {
		return 0
	}
	i = 0
	for {
		if !(uint32(i) < vlen) {
			break
		}
		/* As an unfortunate inconsistency, the sendmmsg API uses
		 * unsigned int for the resulting msg_len, despite sendmsg
		 * returning ssize_t. However Linux limits the total bytes
		 * sent by sendmsg to INT_MAX, so the assignment is safe. */
		r = Xsendmsg(tls, fd, msgvec+uintptr(i)*64, int32(flags))
		if r < 0 {
			goto error
		}
		(*(*Tmmsghdr)(unsafe.Pointer(msgvec + uintptr(i)*64))).Fmsg_len = uint32(r)
		goto _1
	_1:
		;
		i++
	}
	goto error
error:
	;
	if i != 0 {
		v2 = i
	} else {
		v2 = -int32(1)
	}
	return v2
	return r1
}

func Xsendmsg(tls *TLS, fd int32, msg uintptr, flags int32) (r1 Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v msg=%v flags=%v, (%v:)", tls, fd, msg, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(1120)
	defer tls.Free(1120)
	var c1, v3, v4 uintptr
	var r, v12 int64
	var v1, v5 int32
	var v10, v11, v6, v7, v8, v9 Tsyscall_arg_t
	var _ /* chbuf at bp+56 */ [66]Tcmsghdr
	var _ /* h at bp+0 */ Tmsghdr
	_, _, _, _, _, _, _, _, _, _, _, _, _ = c1, r, v1, v10, v11, v12, v3, v4, v5, v6, v7, v8, v9
	if msg != 0 {
		*(*Tmsghdr)(unsafe.Pointer(bp)) = *(*Tmsghdr)(unsafe.Pointer(msg))
		v1 = Int32FromInt32(0)
		(*(*Tmsghdr)(unsafe.Pointer(bp))).F__pad2 = v1
		(*(*Tmsghdr)(unsafe.Pointer(bp))).F__pad1 = v1
		msg = bp
		if (*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_controllen != 0 {
			if uint64((*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_controllen) > uint64(1056) {
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMEM)
				return int64(-int32(1))
			}
			Xmemcpy(tls, bp+56, (*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_control, uint64((*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_controllen))
			(*(*Tmsghdr)(unsafe.Pointer(bp))).Fmsg_control = bp + 56
			if uint64((*Tmsghdr)(unsafe.Pointer(bp)).Fmsg_controllen) >= uint64(16) {
				v3 = (*Tmsghdr)(unsafe.Pointer(bp)).Fmsg_control
			} else {
				v3 = UintptrFromInt32(0)
			}
			c1 = v3
			for {
				if !(c1 != 0) {
					break
				}
				(*Tcmsghdr)(unsafe.Pointer(c1)).F__pad1 = 0
				goto _2
			_2:
				;
				if uint64((*Tcmsghdr)(unsafe.Pointer(c1)).Fcmsg_len) < uint64(16) || (uint64((*Tcmsghdr)(unsafe.Pointer(c1)).Fcmsg_len)+uint64(8)-uint64(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1)))+uint64(16) >= uint64(int64((*Tmsghdr)(unsafe.Pointer(bp)).Fmsg_control+uintptr((*Tmsghdr)(unsafe.Pointer(bp)).Fmsg_controllen))-int64(c1)) {
					v4 = uintptr(0)
				} else {
					v4 = c1 + uintptr((uint64((*Tcmsghdr)(unsafe.Pointer(c1)).Fcmsg_len)+Uint64FromInt64(8)-Uint64FromInt32(1))&uint64(^int64(Uint64FromInt64(8)-Uint64FromInt32(1))))
				}
				c1 = v4
			}
		}
	}
	v5 = int32(SYS_sendmsg)
	_ = int32(__SC_sendmsg)
	v6 = int64(fd)
	v7 = int64(msg)
	v8 = int64(flags)
	v9 = int64(Int32FromInt32(0))
	v10 = int64(Int32FromInt32(0))
	v11 = int64(Int32FromInt32(0))
	if int32(1) != 0 {
		r = ___syscall_cp(tls, int64(v5), v6, v7, v8, v9, v10, v11)
	} else {
		r = X__syscall6(tls, int64(v5), v6, v7, v8, v9, v10, v11)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v12 = r
		goto _13
	}
	v12 = r
	goto _13
_13:
	return X__syscall_ret(tls, uint64(v12))
}

func Xsendto(tls *TLS, fd int32, buf uintptr, len1 Tsize_t, flags int32, addr uintptr, alen Tsocklen_t) (r1 Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v len1=%v flags=%v addr=%v alen=%v, (%v:)", tls, fd, buf, len1, flags, addr, alen, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_sendto)
	_ = int32(__SC_sendto)
	v2 = int64(fd)
	v3 = int64(buf)
	v4 = int64(len1)
	v5 = int64(flags)
	v6 = int64(addr)
	v7 = int64(alen)
	if int32(1) != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return X__syscall_ret(tls, uint64(v8))
}

func Xendservent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
}

func Xsetservent(tls *TLS, stayopen int32) {
	if __ccgo_strace {
		trc("tls=%v stayopen=%v, (%v:)", tls, stayopen, origin(2))
	}
}

func Xgetservent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(0)
}

func Xsetsockopt(tls *TLS, fd int32, level int32, optname int32, optval uintptr, optlen Tsocklen_t) (r2 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v level=%v optname=%v optval=%v optlen=%v, (%v:)", tls, fd, level, optname, optval, optlen, origin(2))
		defer func() { trc("-> %v", r2) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r, v18, v27, v8 int64
	var r1, v1, v11, v20 int32
	var s Ttime_t
	var tv uintptr
	var us Tsuseconds_t
	var v10 uint64
	var v12, v13, v14, v15, v16, v17, v2, v21, v22, v23, v24, v25, v26, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = r, r1, s, tv, us, v1, v10, v11, v12, v13, v14, v15, v16, v17, v18, v2, v20, v21, v22, v23, v24, v25, v26, v27, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_setsockopt)
	_ = int32(__SC_setsockopt)
	v2 = int64(fd)
	v3 = int64(level)
	v4 = int64(optname)
	v5 = int64(optval)
	v6 = int64(optlen)
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	r1 = int32(v8)
	if r1 == -int32(ENOPROTOOPT) {
		switch level {
		case int32(SOL_SOCKET):
			switch optname {
			case int32(SO_RCVTIMEO):
				fallthrough
			case int32(SO_SNDTIMEO):
				if true {
					break
				}
				if uint64(optlen) < uint64(16) {
					return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
				}
				tv = optval
				s = (*Ttimeval)(unsafe.Pointer(tv)).Ftv_sec
				us = (*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec
				if !!((uint64(s)+Uint64FromUint64(0x80000000))>>Int32FromInt32(32) != 0) {
					return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EOPNOTSUPP))))
				}
				if optname == int32(SO_RCVTIMEO) {
					optname = int32(SO_RCVTIMEO_OLD)
				}
				if optname == int32(SO_SNDTIMEO) {
					optname = int32(SO_SNDTIMEO_OLD)
				}
				if !((uint64(us)+Uint64FromUint64(0x80000000))>>Int32FromInt32(32) != 0) {
					v10 = uint64(us)
				} else {
					v10 = uint64(0x7fffffff) + (0+uint64(us))>>int32(63)
				}
				*(*[2]int64)(unsafe.Pointer(bp)) = [2]int64{
					0: s,
					1: int64(int32(v10)),
				}
				v11 = int32(SYS_setsockopt)
				_ = int32(__SC_setsockopt)
				v12 = int64(fd)
				v13 = int64(level)
				v14 = int64(optname)
				v15 = int64(bp)
				v16 = int64(Uint64FromInt32(2) * Uint64FromInt64(8))
				v17 = int64(Int32FromInt32(0))
				if 0 != 0 {
					r = ___syscall_cp(tls, int64(v11), v12, v13, v14, v15, v16, v17)
				} else {
					r = X__syscall6(tls, int64(v11), v12, v13, v14, v15, v16, v17)
				}
				if r != int64(-Int32FromInt32(ENOSYS)) {
					v18 = r
					goto _19
				}
				v18 = r
				goto _19
			_19:
				r1 = int32(v18)
			case int32(SO_TIMESTAMP):
				fallthrough
			case int32(SO_TIMESTAMPNS):
				if true {
					break
				}
				if optname == int32(SO_TIMESTAMP) {
					optname = int32(SO_TIMESTAMP_OLD)
				}
				if optname == int32(SO_TIMESTAMPNS) {
					optname = int32(SO_TIMESTAMPNS_OLD)
				}
				v20 = int32(SYS_setsockopt)
				_ = int32(__SC_setsockopt)
				v21 = int64(fd)
				v22 = int64(level)
				v23 = int64(optname)
				v24 = int64(optval)
				v25 = int64(optlen)
				v26 = int64(Int32FromInt32(0))
				if 0 != 0 {
					r = ___syscall_cp(tls, int64(v20), v21, v22, v23, v24, v25, v26)
				} else {
					r = X__syscall6(tls, int64(v20), v21, v22, v23, v24, v25, v26)
				}
				if r != int64(-Int32FromInt32(ENOSYS)) {
					v27 = r
					goto _28
				}
				v27 = r
				goto _28
			_28:
				r1 = int32(v27)
				break
			}
		}
	}
	return int32(X__syscall_ret(tls, uint64(r1)))
}

func Xshutdown(tls *TLS, fd int32, how int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v how=%v, (%v:)", tls, fd, how, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v8 int64
	var v1 int32
	var v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _ = r, v1, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_shutdown)
	_ = int32(__SC_shutdown)
	v2 = int64(fd)
	v3 = int64(how)
	v4 = int64(Int32FromInt32(0))
	v5 = int64(Int32FromInt32(0))
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	return int32(X__syscall_ret(tls, uint64(v8)))
}

func Xsockatmark(tls *TLS, s int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* ret at bp+0 */ int32
	if Xioctl(tls, s, int32(SIOCATMARK), VaList(bp+16, bp)) < 0 {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func Xsocket(tls *TLS, domain int32, type1 int32, protocol int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v domain=%v type1=%v protocol=%v, (%v:)", tls, domain, type1, protocol, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v17, v8 int64
	var s, v1, v10 int32
	var v11, v12, v13, v14, v15, v16, v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = r, s, v1, v10, v11, v12, v13, v14, v15, v16, v17, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_socket)
	_ = int32(__SC_socket)
	v2 = int64(domain)
	v3 = int64(type1)
	v4 = int64(protocol)
	v5 = int64(Int32FromInt32(0))
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	s = int32(v8)
	if (s == -int32(EINVAL) || s == -int32(EPROTONOSUPPORT)) && type1&(Int32FromInt32(SOCK_CLOEXEC)|Int32FromInt32(SOCK_NONBLOCK)) != 0 {
		v10 = int32(SYS_socket)
		_ = int32(__SC_socket)
		v11 = int64(domain)
		v12 = int64(type1 & ^(Int32FromInt32(SOCK_CLOEXEC) | Int32FromInt32(SOCK_NONBLOCK)))
		v13 = int64(protocol)
		v14 = int64(Int32FromInt32(0))
		v15 = int64(Int32FromInt32(0))
		v16 = int64(Int32FromInt32(0))
		if 0 != 0 {
			r = ___syscall_cp(tls, int64(v10), v11, v12, v13, v14, v15, v16)
		} else {
			r = X__syscall6(tls, int64(v10), v11, v12, v13, v14, v15, v16)
		}
		if r != int64(-Int32FromInt32(ENOSYS)) {
			v17 = r
			goto _18
		}
		v17 = r
		goto _18
	_18:
		s = int32(v17)
		if s < 0 {
			return int32(X__syscall_ret(tls, uint64(s)))
		}
		if type1&int32(SOCK_CLOEXEC) != 0 {
			X__syscall3(tls, int64(SYS_fcntl), int64(s), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
		}
		if type1&int32(SOCK_NONBLOCK) != 0 {
			X__syscall3(tls, int64(SYS_fcntl), int64(s), int64(Int32FromInt32(F_SETFL)), int64(Int32FromInt32(O_NONBLOCK)))
		}
	}
	return int32(X__syscall_ret(tls, uint64(s)))
}

func Xsocketpair(tls *TLS, domain int32, type1 int32, protocol int32, fd uintptr) (r2 int32) {
	if __ccgo_strace {
		trc("tls=%v domain=%v type1=%v protocol=%v fd=%v, (%v:)", tls, domain, type1, protocol, fd, origin(2))
		defer func() { trc("-> %v", r2) }()
	}
	var r, v17, v8 int64
	var r1, v1, v10 int32
	var v11, v12, v13, v14, v15, v16, v2, v3, v4, v5, v6, v7 Tsyscall_arg_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = r, r1, v1, v10, v11, v12, v13, v14, v15, v16, v17, v2, v3, v4, v5, v6, v7, v8
	v1 = int32(SYS_socketpair)
	_ = int32(__SC_socketpair)
	v2 = int64(domain)
	v3 = int64(type1)
	v4 = int64(protocol)
	v5 = int64(fd)
	v6 = int64(Int32FromInt32(0))
	v7 = int64(Int32FromInt32(0))
	if 0 != 0 {
		r = ___syscall_cp(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	} else {
		r = X__syscall6(tls, int64(v1), v2, v3, v4, v5, v6, v7)
	}
	if r != int64(-Int32FromInt32(ENOSYS)) {
		v8 = r
		goto _9
	}
	v8 = r
	goto _9
_9:
	r1 = int32(X__syscall_ret(tls, uint64(v8)))
	if r1 < 0 && (*(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EINVAL) || *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EPROTONOSUPPORT)) && type1&(Int32FromInt32(SOCK_CLOEXEC)|Int32FromInt32(SOCK_NONBLOCK)) != 0 {
		v10 = int32(SYS_socketpair)
		_ = int32(__SC_socketpair)
		v11 = int64(domain)
		v12 = int64(type1 & ^(Int32FromInt32(SOCK_CLOEXEC) | Int32FromInt32(SOCK_NONBLOCK)))
		v13 = int64(protocol)
		v14 = int64(fd)
		v15 = int64(Int32FromInt32(0))
		v16 = int64(Int32FromInt32(0))
		if 0 != 0 {
			r = ___syscall_cp(tls, int64(v10), v11, v12, v13, v14, v15, v16)
		} else {
			r = X__syscall6(tls, int64(v10), v11, v12, v13, v14, v15, v16)
		}
		if r != int64(-Int32FromInt32(ENOSYS)) {
			v17 = r
			goto _18
		}
		v17 = r
		goto _18
	_18:
		r1 = int32(X__syscall_ret(tls, uint64(v17)))
		if r1 < 0 {
			return r1
		}
		if type1&int32(SOCK_CLOEXEC) != 0 {
			X__syscall3(tls, int64(SYS_fcntl), int64(*(*int32)(unsafe.Pointer(fd))), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
			X__syscall3(tls, int64(SYS_fcntl), int64(*(*int32)(unsafe.Pointer(fd + 1*4))), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
		}
		if type1&int32(SOCK_NONBLOCK) != 0 {
			X__syscall3(tls, int64(SYS_fcntl), int64(*(*int32)(unsafe.Pointer(fd))), int64(Int32FromInt32(F_SETFL)), int64(Int32FromInt32(O_NONBLOCK)))
			X__syscall3(tls, int64(SYS_fcntl), int64(*(*int32)(unsafe.Pointer(fd + 1*4))), int64(Int32FromInt32(F_SETFL)), int64(Int32FromInt32(O_NONBLOCK)))
		}
	}
	return r1
}

const SHADOW = "/etc/shadow"

type Tgroup = struct {
	Fgr_name   uintptr
	Fgr_passwd uintptr
	Fgr_gid    Tgid_t
	Fgr_mem    uintptr
}

type Tspwd = struct {
	Fsp_namp   uintptr
	Fsp_pwdp   uintptr
	Fsp_lstchg int64
	Fsp_min    int64
	Fsp_max    int64
	Fsp_warn   int64
	Fsp_inact  int64
	Fsp_expire int64
	Fsp_flag   uint64
}

func Xfgetgrent(tls *TLS, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* nmem at bp+16 */ Tsize_t
	var _ /* res at bp+0 */ uintptr
	var _ /* size at bp+8 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(0)
	X__getgrent_a(tls, f, uintptr(unsafe.Pointer(&_gr)), uintptr(unsafe.Pointer(&_line1)), bp+8, uintptr(unsafe.Pointer(&_mem)), bp+16, bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

var _line1 uintptr

var _mem uintptr

var _gr Tgroup

func Xfgetpwent(tls *TLS, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* res at bp+8 */ uintptr
	var _ /* size at bp+0 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp)) = uint64(0)
	X__getpwent_a(tls, f, uintptr(unsafe.Pointer(&_pw)), uintptr(unsafe.Pointer(&_line2)), bp, bp+8)
	return *(*uintptr)(unsafe.Pointer(bp + 8))
}

var _line2 uintptr

var _pw Tpasswd

const GETGRBYGID = 3
const GETGRBYNAME = 2
const GETINITGR = 15
const GETPWBYNAME = 0
const GETPWBYUID = 1
const GRFOUND = 1
const GRGID = 4
const GRMEMCNT = 5
const GRNAMELEN = 2
const GRPASSWDLEN = 3
const GRVERSION = 0
const GR_LEN = 6
const INITGRFOUND = 1
const INITGRNGRPS = 2
const INITGRVERSION = 0
const INITGR_LEN = 3
const NSCDVERSION = 2
const PWDIRLEN = 7
const PWFOUND = 1
const PWGECOSLEN = 6
const PWGID = 5
const PWNAMELEN = 2
const PWPASSWDLEN = 3
const PWSHELLLEN = 8
const PWUID = 4
const PWVERSION = 0
const PW_LEN = 9
const REQKEYLEN = 2
const REQTYPE = 1
const REQVERSION = 0
const REQ_LEN = 3

func _itoa1(tls *TLS, p uintptr, x Tuint32_t) (r uintptr) {
	var v1, v2 uintptr
	_, _ = v1, v2
	// number of digits in a uint32_t + NUL
	p += uintptr(11)
	p--
	v1 = p
	*(*uint8)(unsafe.Pointer(v1)) = uint8(0)
	for cond := true; cond; cond = x != 0 {
		p--
		v2 = p
		*(*uint8)(unsafe.Pointer(v2)) = uint8(uint32('0') + x%uint32(10))
		x /= uint32(10)
	}
	return p
}

func X__getgr_a(tls *TLS, name uintptr, gid Tgid_t, gr uintptr, buf uintptr, size uintptr, mem uintptr, nmem uintptr, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v gid=%v gr=%v buf=%v size=%v mem=%v nmem=%v res=%v, (%v:)", tls, name, gid, gr, buf, size, mem, nmem, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var f, key, ptr, tmp, tmp1 uintptr
	var grlist_len, len1 Tsize_t
	var i, req, v10 Tint32_t
	var rv, v1, v2, v4, v8 int32
	var v5, v6 Tuint32_t
	var _ /* cs at bp+0 */ int32
	var _ /* gidbuf at bp+28 */ [11]uint8
	var _ /* groupbuf at bp+4 */ [6]Tint32_t
	var _ /* name_len at bp+44 */ Tuint32_t
	var _ /* swap at bp+40 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = f, grlist_len, i, key, len1, ptr, req, rv, tmp, tmp1, v1, v10, v2, v4, v5, v6, v8
	rv = 0
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp)
	f = Xfopen(tls, __ccgo_ts+1235, __ccgo_ts+315)
	if !(f != 0) {
		rv = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
		goto done
	}
	for {
		v1 = X__getgrent_a(tls, f, gr, buf, size, mem, nmem, res)
		rv = v1
		if !(!(v1 != 0) && *(*uintptr)(unsafe.Pointer(res)) != 0) {
			break
		}
		if name != 0 && !(Xstrcmp(tls, name, (*Tgroup)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(res)))).Fgr_name) != 0) || !(name != 0) && (*Tgroup)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(res)))).Fgr_gid == gid {
			break
		}
	}
	Xfclose(tls, f)
	if !(*(*uintptr)(unsafe.Pointer(res)) != 0) && (rv == 0 || rv == int32(ENOENT) || rv == int32(ENOTDIR)) {
		if name != 0 {
			v2 = int32(GETGRBYNAME)
		} else {
			v2 = int32(GETGRBYGID)
		}
		req = v2
		*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)) = [6]Tint32_t{}
		len1 = uint64(0)
		grlist_len = uint64(0)
		*(*[11]uint8)(unsafe.Pointer(bp + 28)) = [11]uint8{}
		*(*int32)(unsafe.Pointer(bp + 40)) = 0
		if name != 0 {
			key = name
		} else {
			if gid < uint32(0) || gid > uint32(0xffffffff) {
				rv = 0
				goto done
			}
			key = _itoa1(tls, bp+28, gid)
		}
		f = X__nscd_query(tls, req, key, bp+4, uint64(24), bp+40)
		if !(f != 0) {
			rv = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
			goto done
		}
		if !((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRFOUND)] != 0) {
			rv = 0
			goto cleanup_f
		}
		if !((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRNAMELEN)] != 0) || !((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRPASSWDLEN)] != 0) {
			rv = int32(EIO)
			goto cleanup_f
		}
		if uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRNAMELEN)]) > uint64(0xffffffffffffffff)-uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRPASSWDLEN)]) {
			rv = int32(ENOMEM)
			goto cleanup_f
		}
		len1 = uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRNAMELEN)] + (*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRPASSWDLEN)])
		i = 0
		for {
			if !(i < (*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRMEMCNT)]) {
				break
			}
			if Xfread(tls, bp+44, uint64(4), uint64(1), f) < uint64(1) {
				if Xferror(tls, f) != 0 {
					v4 = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
				} else {
					v4 = int32(EIO)
				}
				rv = v4
				goto cleanup_f
			}
			if *(*int32)(unsafe.Pointer(bp + 40)) != 0 {
				v5 = *(*Tuint32_t)(unsafe.Pointer(bp + 44))
				v6 = v5>>int32(24) | v5>>int32(8)&uint32(0xff00) | v5<<int32(8)&uint32(0xff0000) | v5<<int32(24)
				goto _7
			_7:
				*(*Tuint32_t)(unsafe.Pointer(bp + 44)) = v6
			}
			if uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 44))) > uint64(0xffffffffffffffff)-grlist_len || uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 44))) > uint64(0xffffffffffffffff)-len1 {
				rv = int32(ENOMEM)
				goto cleanup_f
			}
			len1 += uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 44)))
			grlist_len += uint64(*(*Tuint32_t)(unsafe.Pointer(bp + 44)))
			goto _3
		_3:
			;
			i++
		}
		if len1 > *(*Tsize_t)(unsafe.Pointer(size)) || !(*(*uintptr)(unsafe.Pointer(buf)) != 0) {
			tmp = Xrealloc(tls, *(*uintptr)(unsafe.Pointer(buf)), len1)
			if !(tmp != 0) {
				rv = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
				goto cleanup_f
			}
			*(*uintptr)(unsafe.Pointer(buf)) = tmp
			*(*Tsize_t)(unsafe.Pointer(size)) = len1
		}
		if !(Xfread(tls, *(*uintptr)(unsafe.Pointer(buf)), len1, uint64(1), f) != 0) {
			if Xferror(tls, f) != 0 {
				v8 = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
			} else {
				v8 = int32(EIO)
			}
			rv = v8
			goto cleanup_f
		}
		if uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRMEMCNT)]+int32(1)) > *(*Tsize_t)(unsafe.Pointer(nmem)) {
			if uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRMEMCNT)]+int32(1)) > Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt64(8) {
				rv = int32(ENOMEM)
				goto cleanup_f
			}
			tmp1 = Xrealloc(tls, *(*uintptr)(unsafe.Pointer(mem)), uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRMEMCNT)]+Int32FromInt32(1))*uint64(8))
			if !(tmp1 != 0) {
				rv = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
				goto cleanup_f
			}
			*(*uintptr)(unsafe.Pointer(mem)) = tmp1
			*(*Tsize_t)(unsafe.Pointer(nmem)) = uint64((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRMEMCNT)] + int32(1))
		}
		if (*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRMEMCNT)] != 0 {
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)))) = *(*uintptr)(unsafe.Pointer(buf)) + uintptr((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRNAMELEN)]) + uintptr((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRPASSWDLEN)])
			ptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem))))
			i = Int32FromInt32(0)
			for {
				if !(ptr != *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem))))+uintptr(grlist_len)) {
					break
				}
				if !(*(*uint8)(unsafe.Pointer(ptr)) != 0) {
					i++
					v10 = i
					*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)) + uintptr(v10)*8)) = ptr + uintptr(1)
				}
				goto _9
			_9:
				;
				ptr++
			}
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)) + uintptr(i)*8)) = uintptr(0)
			if i != (*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRMEMCNT)] {
				rv = int32(EIO)
				goto cleanup_f
			}
		} else {
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)))) = uintptr(0)
		}
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_name = *(*uintptr)(unsafe.Pointer(buf))
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd = (*Tgroup)(unsafe.Pointer(gr)).Fgr_name + uintptr((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRNAMELEN)])
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_gid = uint32((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRGID)])
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_mem = *(*uintptr)(unsafe.Pointer(mem))
		if *(*uint8)(unsafe.Pointer((*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd + uintptr(-Int32FromInt32(1)))) != 0 || *(*uint8)(unsafe.Pointer((*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd + uintptr((*(*[6]Tint32_t)(unsafe.Pointer(bp + 4)))[int32(GRPASSWDLEN)]-int32(1)))) != 0 {
			rv = int32(EIO)
			goto cleanup_f
		}
		if name != 0 && Xstrcmp(tls, name, (*Tgroup)(unsafe.Pointer(gr)).Fgr_name) != 0 || !(name != 0) && gid != (*Tgroup)(unsafe.Pointer(gr)).Fgr_gid {
			rv = int32(EIO)
			goto cleanup_f
		}
		*(*uintptr)(unsafe.Pointer(res)) = gr
		goto cleanup_f
	cleanup_f:
		;
		Xfclose(tls, f)
		goto done
	}
	goto done
done:
	;
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp)), uintptr(0))
	if rv != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = rv
	}
	return rv
}

func _getgr_r(tls *TLS, name uintptr, gid Tgid_t, gr uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	bp := tls.Alloc(48)
	defer tls.Free(48)
	var i Tsize_t
	var rv int32
	var _ /* cs at bp+32 */ int32
	var _ /* len at bp+8 */ Tsize_t
	var _ /* line at bp+0 */ uintptr
	var _ /* mem at bp+16 */ uintptr
	var _ /* nmem at bp+24 */ Tsize_t
	_, _ = i, rv
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 16)) = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 24)) = uint64(0)
	rv = 0
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+32)
	rv = X__getgr_a(tls, name, gid, gr, bp, bp+8, bp+16, bp+24, res)
	if *(*uintptr)(unsafe.Pointer(res)) != 0 && size < *(*Tsize_t)(unsafe.Pointer(bp + 8))+(*(*Tsize_t)(unsafe.Pointer(bp + 24))+uint64(1))*uint64(8)+uint64(32) {
		*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
		rv = int32(ERANGE)
	}
	if *(*uintptr)(unsafe.Pointer(res)) != 0 {
		buf += uintptr((uint64(16) - uint64(buf)) % uint64(16))
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_mem = buf
		buf += uintptr((*(*Tsize_t)(unsafe.Pointer(bp + 24)) + uint64(1)) * uint64(8))
		Xmemcpy(tls, buf, *(*uintptr)(unsafe.Pointer(bp)), *(*Tsize_t)(unsafe.Pointer(bp + 8)))
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_name = uintptr(int64((*Tgroup)(unsafe.Pointer(gr)).Fgr_name)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd = uintptr(int64((*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		i = uint64(0)
		for {
			if !(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(i)*8)) != 0) {
				break
			}
			*(*uintptr)(unsafe.Pointer((*Tgroup)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8)) = uintptr(int64(*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)) + uintptr(i)*8)))-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
			goto _1
		_1:
			;
			i++
		}
		*(*uintptr)(unsafe.Pointer((*Tgroup)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8)) = uintptr(0)
	}
	Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))
	Xfree(tls, *(*uintptr)(unsafe.Pointer(bp)))
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 32)), uintptr(0))
	if rv != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = rv
	}
	return rv
}

func Xgetgrnam_r(tls *TLS, name uintptr, gr uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v gr=%v buf=%v size=%v res=%v, (%v:)", tls, name, gr, buf, size, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _getgr_r(tls, name, uint32(0), gr, buf, size, res)
}

func Xgetgrgid_r(tls *TLS, gid Tgid_t, gr uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v gid=%v gr=%v buf=%v size=%v res=%v, (%v:)", tls, gid, gr, buf, size, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _getgr_r(tls, uintptr(0), gid, gr, buf, size, res)
}

var _f1 uintptr
var _line3 uintptr
var _mem1 uintptr
var _gr1 Tgroup

func Xsetgrent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	if _f1 != 0 {
		Xfclose(tls, _f1)
	}
	_f1 = uintptr(0)
}

func Xgetgrent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* nmem at bp+16 */ Tsize_t
	var _ /* res at bp+0 */ uintptr
	var _ /* size at bp+8 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(0)
	if !(_f1 != 0) {
		_f1 = Xfopen(tls, __ccgo_ts+1235, __ccgo_ts+315)
	}
	if !(_f1 != 0) {
		return uintptr(0)
	}
	X__getgrent_a(tls, _f1, uintptr(unsafe.Pointer(&_gr1)), uintptr(unsafe.Pointer(&_line3)), bp+8, uintptr(unsafe.Pointer(&_mem1)), bp+16, bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func Xgetgrgid(tls *TLS, gid Tgid_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v gid=%v, (%v:)", tls, gid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* nmem at bp+16 */ Tsize_t
	var _ /* res at bp+0 */ uintptr
	var _ /* size at bp+8 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(0)
	X__getgr_a(tls, uintptr(0), gid, uintptr(unsafe.Pointer(&_gr1)), uintptr(unsafe.Pointer(&_line3)), bp+8, uintptr(unsafe.Pointer(&_mem1)), bp+16, bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func Xgetgrnam(tls *TLS, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* nmem at bp+16 */ Tsize_t
	var _ /* res at bp+0 */ uintptr
	var _ /* size at bp+8 */ Tsize_t
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 16)) = uint64(0)
	X__getgr_a(tls, name, uint32(0), uintptr(unsafe.Pointer(&_gr1)), uintptr(unsafe.Pointer(&_line3)), bp+8, uintptr(unsafe.Pointer(&_mem1)), bp+16, bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func Xendgrent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	Xsetgrent(tls)
}

func _atou(tls *TLS, s uintptr) (r uint32) {
	var x uint32
	_ = x
	x = uint32(0)
	for {
		if !(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-int32('0')) < uint32(10)) {
			break
		}
		x = uint32(10)*x + uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-Int32FromUint8('0'))
		goto _1
	_1:
		;
		*(*uintptr)(unsafe.Pointer(s))++
	}
	return x
}

func X__getgrent_a(tls *TLS, f uintptr, gr uintptr, line uintptr, size uintptr, mem uintptr, nmem uintptr, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v gr=%v line=%v size=%v mem=%v nmem=%v res=%v, (%v:)", tls, f, gr, line, size, mem, nmem, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i, v13, v14 Tsize_t
	var l, v2 Tssize_t
	var mems, v12, v4, v5, v6, v7, v8, v9 uintptr
	var rv, v3 int32
	var _ /* cs at bp+8 */ int32
	var _ /* s at bp+0 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, l, mems, rv, v12, v13, v14, v2, v3, v4, v5, v6, v7, v8, v9
	rv = 0
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+8)
	for {
		v2 = Xgetline(tls, line, size, f)
		l = v2
		if v2 < 0 {
			if Xferror(tls, f) != 0 {
				v3 = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
			} else {
				v3 = 0
			}
			rv = v3
			Xfree(tls, *(*uintptr)(unsafe.Pointer(line)))
			*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
			gr = uintptr(0)
			goto end
		}
		*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(line)) + uintptr(l-int64(1)))) = uint8(0)
		*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(line))
		v4 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_name = v4
		v5 = Xstrchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v5
		if !(v5 != 0) {
			goto _1
		}
		v6 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v6)) = uint8(0)
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd = *(*uintptr)(unsafe.Pointer(bp))
		v7 = Xstrchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v7
		if !(v7 != 0) {
			goto _1
		}
		v8 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v8)) = uint8(0)
		(*Tgroup)(unsafe.Pointer(gr)).Fgr_gid = _atou(tls, bp)
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
			goto _1
		}
		v9 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v9)) = uint8(0)
		mems = *(*uintptr)(unsafe.Pointer(bp))
		break
		goto _1
	_1:
	}
	*(*Tsize_t)(unsafe.Pointer(nmem)) = BoolUint64(!!(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0))
	for {
		if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32(',') {
			*(*Tsize_t)(unsafe.Pointer(nmem))++
		}
		goto _10
	_10:
		;
		*(*uintptr)(unsafe.Pointer(bp))++
	}
	Xfree(tls, *(*uintptr)(unsafe.Pointer(mem)))
	*(*uintptr)(unsafe.Pointer(mem)) = Xcalloc(tls, uint64(8), *(*Tsize_t)(unsafe.Pointer(nmem))+uint64(1))
	if !(*(*uintptr)(unsafe.Pointer(mem)) != 0) {
		rv = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
		Xfree(tls, *(*uintptr)(unsafe.Pointer(line)))
		*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
		gr = uintptr(0)
		goto end
	}
	if *(*uint8)(unsafe.Pointer(mems)) != 0 {
		*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)))) = mems
		*(*uintptr)(unsafe.Pointer(bp)) = mems
		i = Uint64FromInt32(0)
		for {
			if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0) {
				break
			}
			if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32(',') {
				v12 = *(*uintptr)(unsafe.Pointer(bp))
				*(*uintptr)(unsafe.Pointer(bp))++
				*(*uint8)(unsafe.Pointer(v12)) = uint8(0)
				i++
				v13 = i
				*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)) + uintptr(v13)*8)) = *(*uintptr)(unsafe.Pointer(bp))
			}
			goto _11
		_11:
			;
			*(*uintptr)(unsafe.Pointer(bp))++
		}
		i++
		v14 = i
		*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)) + uintptr(v14)*8)) = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(mem)))) = uintptr(0)
	}
	(*Tgroup)(unsafe.Pointer(gr)).Fgr_mem = *(*uintptr)(unsafe.Pointer(mem))
	goto end
end:
	;
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 8)), uintptr(0))
	*(*uintptr)(unsafe.Pointer(res)) = gr
	if rv != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = rv
	}
	return rv
}

func Xgetgrouplist(tls *TLS, user uintptr, gid Tgid_t, groups uintptr, ngroups uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v user=%v gid=%v groups=%v ngroups=%v, (%v:)", tls, user, gid, groups, ngroups, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(96)
	defer tls.Free(96)
	var f, nscdbuf, v1, v10, v13 uintptr
	var i, n, v12, v9 Tssize_t
	var nbytes Tsize_t
	var nlim, ret, rv, v6 int32
	var v14 int64
	var v3, v4 Tuint32_t
	var _ /* buf at bp+56 */ uintptr
	var _ /* gr at bp+0 */ Tgroup
	var _ /* mem at bp+64 */ uintptr
	var _ /* nmem at bp+72 */ Tsize_t
	var _ /* res at bp+32 */ uintptr
	var _ /* resp at bp+44 */ [3]Tint32_t
	var _ /* size at bp+80 */ Tsize_t
	var _ /* swap at bp+40 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = f, i, n, nbytes, nlim, nscdbuf, ret, rv, v1, v10, v12, v13, v14, v3, v4, v6, v9
	ret = -int32(1)
	n = int64(1)
	*(*int32)(unsafe.Pointer(bp + 40)) = 0
	nscdbuf = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 56)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 64)) = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 72)) = uint64(0)
	nlim = *(*int32)(unsafe.Pointer(ngroups))
	if nlim >= int32(1) {
		v1 = groups
		groups += 4
		*(*Tgid_t)(unsafe.Pointer(v1)) = gid
	}
	f = X__nscd_query(tls, int32(GETINITGR), user, bp+44, uint64(12), bp+40)
	if !(f != 0) {
		goto cleanup
	}
	if (*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(INITGRFOUND)] != 0 {
		nscdbuf = Xcalloc(tls, uint64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(INITGRNGRPS)]), uint64(4))
		if !(nscdbuf != 0) {
			goto cleanup
		}
		nbytes = uint64(4) * uint64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(INITGRNGRPS)])
		if nbytes != 0 && !(Xfread(tls, nscdbuf, nbytes, uint64(1), f) != 0) {
			if !(Xferror(tls, f) != 0) {
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EIO)
			}
			goto cleanup
		}
		if *(*int32)(unsafe.Pointer(bp + 40)) != 0 {
			i = 0
			for {
				if !(i < int64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(INITGRNGRPS)])) {
					break
				}
				v3 = *(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4))
				v4 = v3>>int32(24) | v3>>int32(8)&uint32(0xff00) | v3<<int32(8)&uint32(0xff0000) | v3<<int32(24)
				goto _5
			_5:
				*(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)) = v4
				goto _2
			_2:
				;
				i++
			}
		}
	}
	Xfclose(tls, f)
	f = Xfopen(tls, __ccgo_ts+1235, __ccgo_ts+315)
	if !(f != 0) && *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(ENOENT) && *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(ENOTDIR) {
		goto cleanup
	}
	if f != 0 {
		for {
			v6 = X__getgrent_a(tls, f, bp, bp+56, bp+80, bp+64, bp+72, bp+32)
			rv = v6
			if !(!(v6 != 0) && *(*uintptr)(unsafe.Pointer(bp + 32)) != 0) {
				break
			}
			if nscdbuf != 0 {
				i = 0
				for {
					if !(i < int64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(INITGRNGRPS)])) {
						break
					}
					if *(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)) == (*(*Tgroup)(unsafe.Pointer(bp))).Fgr_gid {
						*(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)) = gid
					}
					goto _7
				_7:
					;
					i++
				}
			}
			i = 0
			for {
				if !(*(*uintptr)(unsafe.Pointer((*(*Tgroup)(unsafe.Pointer(bp))).Fgr_mem + uintptr(i)*8)) != 0 && Xstrcmp(tls, user, *(*uintptr)(unsafe.Pointer((*(*Tgroup)(unsafe.Pointer(bp))).Fgr_mem + uintptr(i)*8))) != 0) {
					break
				}
				goto _8
			_8:
				;
				i++
			}
			if !(*(*uintptr)(unsafe.Pointer((*(*Tgroup)(unsafe.Pointer(bp))).Fgr_mem + uintptr(i)*8)) != 0) {
				continue
			}
			n++
			v9 = n
			if v9 <= int64(nlim) {
				v10 = groups
				groups += 4
				*(*Tgid_t)(unsafe.Pointer(v10)) = (*(*Tgroup)(unsafe.Pointer(bp))).Fgr_gid
			}
		}
		if rv != 0 {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = rv
			goto cleanup
		}
	}
	if nscdbuf != 0 {
		i = 0
		for {
			if !(i < int64((*(*[3]Tint32_t)(unsafe.Pointer(bp + 44)))[int32(INITGRNGRPS)])) {
				break
			}
			if *(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4)) != gid {
				n++
				v12 = n
				if v12 <= int64(nlim) {
					v13 = groups
					groups += 4
					*(*Tgid_t)(unsafe.Pointer(v13)) = *(*Tuint32_t)(unsafe.Pointer(nscdbuf + uintptr(i)*4))
				}
			}
			goto _11
		_11:
			;
			i++
		}
	}
	if n > int64(nlim) {
		v14 = int64(-int32(1))
	} else {
		v14 = n
	}
	ret = int32(v14)
	*(*int32)(unsafe.Pointer(ngroups)) = int32(n)
	goto cleanup
cleanup:
	;
	if f != 0 {
		Xfclose(tls, f)
	}
	Xfree(tls, nscdbuf)
	Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 56)))
	Xfree(tls, *(*uintptr)(unsafe.Pointer(bp + 64)))
	return ret
}

func _itoa2(tls *TLS, p uintptr, x Tuint32_t) (r uintptr) {
	var v1, v2 uintptr
	_, _ = v1, v2
	// number of digits in a uint32_t + NUL
	p += uintptr(11)
	p--
	v1 = p
	*(*uint8)(unsafe.Pointer(v1)) = uint8(0)
	for cond := true; cond; cond = x != 0 {
		p--
		v2 = p
		*(*uint8)(unsafe.Pointer(v2)) = uint8(uint32('0') + x%uint32(10))
		x /= uint32(10)
	}
	return p
}

func X__getpw_a(tls *TLS, name uintptr, uid Tuid_t, pw uintptr, buf uintptr, size uintptr, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v uid=%v pw=%v buf=%v size=%v res=%v, (%v:)", tls, name, uid, pw, buf, size, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var f, key, tmp uintptr
	var len1 Tsize_t
	var req Tint32_t
	var rv, v1, v2, v3 int32
	var _ /* cs at bp+4 */ int32
	var _ /* passwdbuf at bp+8 */ [9]Tint32_t
	var _ /* uidbuf at bp+44 */ [11]uint8
	_, _, _, _, _, _, _, _, _ = f, key, len1, req, rv, tmp, v1, v2, v3
	rv = 0
	*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+4)
	f = Xfopen(tls, __ccgo_ts+1246, __ccgo_ts+315)
	if !(f != 0) {
		rv = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
		goto done
	}
	for {
		v1 = X__getpwent_a(tls, f, pw, buf, size, res)
		rv = v1
		if !(!(v1 != 0) && *(*uintptr)(unsafe.Pointer(res)) != 0) {
			break
		}
		if name != 0 && !(Xstrcmp(tls, name, (*Tpasswd)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(res)))).Fpw_name) != 0) || !(name != 0) && (*Tpasswd)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(res)))).Fpw_uid == uid {
			break
		}
	}
	Xfclose(tls, f)
	if !(*(*uintptr)(unsafe.Pointer(res)) != 0) && (rv == 0 || rv == int32(ENOENT) || rv == int32(ENOTDIR)) {
		if name != 0 {
			v2 = GETPWBYNAME
		} else {
			v2 = int32(GETPWBYUID)
		}
		req = v2
		*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)) = [9]Tint32_t{}
		len1 = uint64(0)
		*(*[11]uint8)(unsafe.Pointer(bp + 44)) = [11]uint8{}
		if name != 0 {
			key = name
		} else {
			/* uid outside of this range can't be queried with the
			 * nscd interface, but might happen if uid_t ever
			 * happens to be a larger type (this is not true as of
			 * now)
			 */
			if uid < uint32(0) || uid > uint32(0xffffffff) {
				rv = 0
				goto done
			}
			key = _itoa2(tls, bp+44, uid)
		}
		*(*[1]int32)(unsafe.Pointer(bp)) = [1]int32{}
		f = X__nscd_query(tls, req, key, bp+8, uint64(36), bp)
		if !(f != 0) {
			rv = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
			goto done
		}
		if !((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWFOUND)] != 0) {
			rv = 0
			goto cleanup_f
		}
		/* A zero length response from nscd is invalid. We ignore
		 * invalid responses and just report an error, rather than
		 * trying to do something with them.
		 */
		if !((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWNAMELEN)] != 0) || !((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWPASSWDLEN)] != 0) || !((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWGECOSLEN)] != 0) || !((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWDIRLEN)] != 0) || !((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWSHELLLEN)] != 0) {
			rv = int32(EIO)
			goto cleanup_f
		}
		if uint64((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWNAMELEN)]|(*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWPASSWDLEN)]|(*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWGECOSLEN)]|(*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWDIRLEN)]|(*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWSHELLLEN)]) >= Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(8) {
			rv = int32(ENOMEM)
			goto cleanup_f
		}
		len1 = uint64((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWNAMELEN)] + (*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWPASSWDLEN)] + (*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWGECOSLEN)] + (*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWDIRLEN)] + (*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWSHELLLEN)])
		if len1 > *(*Tsize_t)(unsafe.Pointer(size)) || !(*(*uintptr)(unsafe.Pointer(buf)) != 0) {
			tmp = Xrealloc(tls, *(*uintptr)(unsafe.Pointer(buf)), len1)
			if !(tmp != 0) {
				rv = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
				goto cleanup_f
			}
			*(*uintptr)(unsafe.Pointer(buf)) = tmp
			*(*Tsize_t)(unsafe.Pointer(size)) = len1
		}
		if !(Xfread(tls, *(*uintptr)(unsafe.Pointer(buf)), len1, uint64(1), f) != 0) {
			if Xferror(tls, f) != 0 {
				v3 = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
			} else {
				v3 = int32(EIO)
			}
			rv = v3
			goto cleanup_f
		}
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_name = *(*uintptr)(unsafe.Pointer(buf))
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd = (*Tpasswd)(unsafe.Pointer(pw)).Fpw_name + uintptr((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWNAMELEN)])
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos = (*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd + uintptr((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWPASSWDLEN)])
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir = (*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos + uintptr((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWGECOSLEN)])
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell = (*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir + uintptr((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWDIRLEN)])
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid = uint32((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWUID)])
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gid = uint32((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWGID)])
		/* Don't assume that nscd made sure to null terminate strings.
		 * It's supposed to, but malicious nscd should be ignored
		 * rather than causing a crash.
		 */
		if *(*uint8)(unsafe.Pointer((*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd + uintptr(-Int32FromInt32(1)))) != 0 || *(*uint8)(unsafe.Pointer((*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos + uintptr(-Int32FromInt32(1)))) != 0 || *(*uint8)(unsafe.Pointer((*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir + uintptr(-Int32FromInt32(1)))) != 0 || *(*uint8)(unsafe.Pointer((*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell + uintptr((*(*[9]Tint32_t)(unsafe.Pointer(bp + 8)))[int32(PWSHELLLEN)]-int32(1)))) != 0 {
			rv = int32(EIO)
			goto cleanup_f
		}
		if name != 0 && Xstrcmp(tls, name, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_name) != 0 || !(name != 0) && uid != (*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid {
			rv = int32(EIO)
			goto cleanup_f
		}
		*(*uintptr)(unsafe.Pointer(res)) = pw
		goto cleanup_f
	cleanup_f:
		;
		Xfclose(tls, f)
		goto done
	}
	goto done
done:
	;
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 4)), uintptr(0))
	if rv != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = rv
	}
	return rv
}

func _getpw_r(tls *TLS, name uintptr, uid Tuid_t, pw uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var rv int32
	var _ /* cs at bp+16 */ int32
	var _ /* len at bp+8 */ Tsize_t
	var _ /* line at bp+0 */ uintptr
	_ = rv
	*(*uintptr)(unsafe.Pointer(bp)) = uintptr(0)
	*(*Tsize_t)(unsafe.Pointer(bp + 8)) = uint64(0)
	rv = 0
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+16)
	rv = X__getpw_a(tls, name, uid, pw, bp, bp+8, res)
	if *(*uintptr)(unsafe.Pointer(res)) != 0 && size < *(*Tsize_t)(unsafe.Pointer(bp + 8)) {
		*(*uintptr)(unsafe.Pointer(res)) = uintptr(0)
		rv = int32(ERANGE)
	}
	if *(*uintptr)(unsafe.Pointer(res)) != 0 {
		Xmemcpy(tls, buf, *(*uintptr)(unsafe.Pointer(bp)), *(*Tsize_t)(unsafe.Pointer(bp + 8)))
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_name = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_name)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell = uintptr(int64((*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell)-int64(*(*uintptr)(unsafe.Pointer(bp)))) + buf
	}
	Xfree(tls, *(*uintptr)(unsafe.Pointer(bp)))
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 16)), uintptr(0))
	if rv != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = rv
	}
	return rv
}

func Xgetpwnam_r(tls *TLS, name uintptr, pw uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v pw=%v buf=%v size=%v res=%v, (%v:)", tls, name, pw, buf, size, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _getpw_r(tls, name, uint32(0), pw, buf, size, res)
}

func Xgetpwuid_r(tls *TLS, uid Tuid_t, pw uintptr, buf uintptr, size Tsize_t, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v uid=%v pw=%v buf=%v size=%v res=%v, (%v:)", tls, uid, pw, buf, size, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _getpw_r(tls, uintptr(0), uid, pw, buf, size, res)
}

var _f2 uintptr
var _line4 uintptr
var _pw1 Tpasswd
var _size Tsize_t

func Xsetpwent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	if _f2 != 0 {
		Xfclose(tls, _f2)
	}
	_f2 = uintptr(0)
}

func Xgetpwent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* res at bp+0 */ uintptr
	if !(_f2 != 0) {
		_f2 = Xfopen(tls, __ccgo_ts+1246, __ccgo_ts+315)
	}
	if !(_f2 != 0) {
		return uintptr(0)
	}
	X__getpwent_a(tls, _f2, uintptr(unsafe.Pointer(&_pw1)), uintptr(unsafe.Pointer(&_line4)), uintptr(unsafe.Pointer(&_size)), bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func Xgetpwuid(tls *TLS, uid Tuid_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v uid=%v, (%v:)", tls, uid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* res at bp+0 */ uintptr
	X__getpw_a(tls, uintptr(0), uid, uintptr(unsafe.Pointer(&_pw1)), uintptr(unsafe.Pointer(&_line4)), uintptr(unsafe.Pointer(&_size)), bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func Xgetpwnam(tls *TLS, name uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v name=%v, (%v:)", tls, name, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* res at bp+0 */ uintptr
	X__getpw_a(tls, name, uint32(0), uintptr(unsafe.Pointer(&_pw1)), uintptr(unsafe.Pointer(&_line4)), uintptr(unsafe.Pointer(&_size)), bp)
	return *(*uintptr)(unsafe.Pointer(bp))
}

func Xendpwent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	Xsetpwent(tls)
}

func _atou1(tls *TLS, s uintptr) (r uint32) {
	var x uint32
	_ = x
	x = uint32(0)
	for {
		if !(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-int32('0')) < uint32(10)) {
			break
		}
		x = uint32(10)*x + uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-Int32FromUint8('0'))
		goto _1
	_1:
		;
		*(*uintptr)(unsafe.Pointer(s))++
	}
	return x
}

func X__getpwent_a(tls *TLS, f uintptr, pw uintptr, line uintptr, size uintptr, res uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v pw=%v line=%v size=%v res=%v, (%v:)", tls, f, pw, line, size, res, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var l, v2 Tssize_t
	var rv, v3 int32
	var v10, v11, v12, v13, v14, v4, v5, v6, v7, v8, v9 uintptr
	var _ /* cs at bp+8 */ int32
	var _ /* s at bp+0 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = l, rv, v10, v11, v12, v13, v14, v2, v3, v4, v5, v6, v7, v8, v9
	rv = 0
	_pthread_setcancelstate(tls, int32(PTHREAD_CANCEL_DISABLE), bp+8)
	for {
		v2 = Xgetline(tls, line, size, f)
		l = v2
		if v2 < 0 {
			if Xferror(tls, f) != 0 {
				v3 = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
			} else {
				v3 = 0
			}
			rv = v3
			Xfree(tls, *(*uintptr)(unsafe.Pointer(line)))
			*(*uintptr)(unsafe.Pointer(line)) = uintptr(0)
			pw = uintptr(0)
			break
		}
		*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(line)) + uintptr(l-int64(1)))) = uint8(0)
		*(*uintptr)(unsafe.Pointer(bp)) = *(*uintptr)(unsafe.Pointer(line))
		v4 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_name = v4
		v5 = Xstrchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v5
		if !(v5 != 0) {
			goto _1
		}
		v6 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v6)) = uint8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd = *(*uintptr)(unsafe.Pointer(bp))
		v7 = Xstrchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v7
		if !(v7 != 0) {
			goto _1
		}
		v8 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v8)) = uint8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid = _atou1(tls, bp)
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
			goto _1
		}
		v9 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v9)) = uint8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gid = _atou1(tls, bp)
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32(':') {
			goto _1
		}
		v10 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v10)) = uint8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos = *(*uintptr)(unsafe.Pointer(bp))
		v11 = Xstrchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v11
		if !(v11 != 0) {
			goto _1
		}
		v12 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v12)) = uint8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir = *(*uintptr)(unsafe.Pointer(bp))
		v13 = Xstrchr(tls, *(*uintptr)(unsafe.Pointer(bp)), int32(':'))
		*(*uintptr)(unsafe.Pointer(bp)) = v13
		if !(v13 != 0) {
			goto _1
		}
		v14 = *(*uintptr)(unsafe.Pointer(bp))
		*(*uintptr)(unsafe.Pointer(bp))++
		*(*uint8)(unsafe.Pointer(v14)) = uint8(0)
		(*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell = *(*uintptr)(unsafe.Pointer(bp))
		break
		goto _1
	_1:
	}
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 8)), uintptr(0))
	*(*uintptr)(unsafe.Pointer(res)) = pw
	if rv != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = rv
	}
	return rv
}

func Xsetspent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
}

func Xendspent(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
}

func Xgetspent(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uintptr(0)
}

func Xlckpwdf(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func Xulckpwdf(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

var _addr = struct {
	Fsun_family int16
	Fsun_path   [21]uint8
}{
	Fsun_family: int16(PF_LOCAL),
	Fsun_path:   [21]uint8{'/', 'v', 'a', 'r', '/', 'r', 'u', 'n', '/', 'n', 's', 'c', 'd', '/', 's', 'o', 'c', 'k', 'e', 't'},
}

func X__nscd_query(tls *TLS, req Tint32_t, key uintptr, buf uintptr, len1 Tsize_t, swap uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v req=%v key=%v buf=%v len1=%v swap=%v, (%v:)", tls, req, key, buf, len1, swap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var errno_save, fd int32
	var f, v1 uintptr
	var i Tsize_t
	var v3, v4, v7, v8 Tuint32_t
	var _ /* msg at bp+48 */ Tmsghdr
	var _ /* req_buf at bp+32 */ [3]Tint32_t
	_, _, _, _, _, _, _, _, _ = errno_save, f, fd, i, v1, v3, v4, v7, v8
	f = uintptr(0)
	*(*[3]Tint32_t)(unsafe.Pointer(bp + 32)) = [3]Tint32_t{
		0: int32(NSCDVERSION),
		1: req,
		2: int32(Xstrnlen(tls, key, uint64(LOGIN_NAME_MAX)) + uint64(1)),
	}
	*(*[2]Tiovec)(unsafe.Pointer(bp)) = [2]Tiovec{
		0: {
			Fiov_base: bp + 32,
			Fiov_len:  uint64(12),
		},
		1: {
			Fiov_base: key,
			Fiov_len:  Xstrlen(tls, key) + uint64(1),
		},
	}
	*(*Tmsghdr)(unsafe.Pointer(bp + 48)) = Tmsghdr{
		Fmsg_iov:    bp,
		Fmsg_iovlen: int32(2),
	}
	errno_save = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	*(*int32)(unsafe.Pointer(swap)) = 0
	goto retry
retry:
	;
	Xmemset(tls, buf, 0, len1)
	*(*Tint32_t)(unsafe.Pointer(buf)) = int32(NSCDVERSION)
	fd = Xsocket(tls, int32(PF_LOCAL), Int32FromInt32(SOCK_STREAM)|Int32FromInt32(SOCK_CLOEXEC), 0)
	if fd < 0 {
		if *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EAFNOSUPPORT) {
			f = Xfopen(tls, __ccgo_ts+1258, __ccgo_ts+1268)
			if f != 0 {
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = errno_save
			}
			return f
		}
		return uintptr(0)
	}
	v1 = Xfdopen(tls, fd, __ccgo_ts+1271)
	f = v1
	if !(v1 != 0) {
		Xclose(tls, fd)
		return uintptr(0)
	}
	if (*(*[3]Tint32_t)(unsafe.Pointer(bp + 32)))[int32(2)] > int32(LOGIN_NAME_MAX) {
		return f
	}
	if Xconnect(tls, fd, uintptr(unsafe.Pointer(&_addr)), uint32(24)) < 0 {
		/* If there isn't a running nscd we simulate a "not found"
		 * result and the caller is responsible for calling
		 * fclose on the (unconnected) socket. The value of
		 * errno must be left unchanged in this case.  */
		if *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EACCES) || *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(ECONNREFUSED) || *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(ENOENT) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = errno_save
			return f
		}
		goto error
	}
	if Xsendmsg(tls, fd, bp+48, int32(MSG_NOSIGNAL)) < 0 {
		goto error
	}
	if !(Xfread(tls, buf, len1, uint64(1), f) != 0) {
		/* If the VERSION entry mismatches nscd will disconnect. The
		 * most likely cause is that the endianness mismatched. So, we
		 * byteswap and try once more. (if we already swapped, just
		 * fail out)
		 */
		if Xferror(tls, f) != 0 {
			goto error
		}
		if !(*(*int32)(unsafe.Pointer(swap)) != 0) {
			Xfclose(tls, f)
			i = uint64(0)
			for {
				if !(i < Uint64FromInt64(12)/Uint64FromInt64(4)) {
					break
				}
				v3 = uint32((*(*[3]Tint32_t)(unsafe.Pointer(bp + 32)))[i])
				v4 = v3>>int32(24) | v3>>int32(8)&uint32(0xff00) | v3<<int32(8)&uint32(0xff0000) | v3<<int32(24)
				goto _5
			_5:
				(*(*[3]Tint32_t)(unsafe.Pointer(bp + 32)))[i] = int32(v4)
				goto _2
			_2:
				;
				i++
			}
			*(*int32)(unsafe.Pointer(swap)) = int32(1)
			goto retry
		} else {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EIO)
			goto error
		}
	}
	if *(*int32)(unsafe.Pointer(swap)) != 0 {
		i = uint64(0)
		for {
			if !(i < len1/uint64(4)) {
				break
			}
			v7 = uint32(*(*Tint32_t)(unsafe.Pointer(buf + uintptr(i)*4)))
			v8 = v7>>int32(24) | v7>>int32(8)&uint32(0xff00) | v7<<int32(8)&uint32(0xff0000) | v7<<int32(24)
			goto _9
		_9:
			*(*Tint32_t)(unsafe.Pointer(buf + uintptr(i)*4)) = int32(v8)
			goto _6
		_6:
			;
			i++
		}
	}
	/* The first entry in every nscd response is the version number. This
	 * really shouldn't happen, and is evidence of some form of malformed
	 * response.
	 */
	if *(*Tint32_t)(unsafe.Pointer(buf)) != int32(NSCDVERSION) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EIO)
		goto error
	}
	return f
	goto error
error:
	;
	Xfclose(tls, f)
	return uintptr(0)
}

func Xputgrent(tls *TLS, gr uintptr, f uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v gr=%v f=%v, (%v:)", tls, gr, f, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i Tsize_t
	var r, v1, v3, v5 int32
	var v4 uintptr
	_, _, _, _, _, _ = i, r, v1, v3, v4, v5
	Xflockfile(tls, f)
	v1 = Xfprintf(tls, f, __ccgo_ts+1273, VaList(bp+8, (*Tgroup)(unsafe.Pointer(gr)).Fgr_name, (*Tgroup)(unsafe.Pointer(gr)).Fgr_passwd, (*Tgroup)(unsafe.Pointer(gr)).Fgr_gid))
	r = v1
	if v1 < 0 {
		goto done
	}
	if (*Tgroup)(unsafe.Pointer(gr)).Fgr_mem != 0 {
		i = uint64(0)
		for {
			if !(*(*uintptr)(unsafe.Pointer((*Tgroup)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8)) != 0) {
				break
			}
			if i != 0 {
				v4 = __ccgo_ts + 1283
			} else {
				v4 = __ccgo_ts
			}
			v3 = Xfprintf(tls, f, __ccgo_ts+1285, VaList(bp+8, v4, *(*uintptr)(unsafe.Pointer((*Tgroup)(unsafe.Pointer(gr)).Fgr_mem + uintptr(i)*8))))
			r = v3
			if v3 < 0 {
				goto done
			}
			goto _2
		_2:
			;
			i++
		}
	}
	r = Xfputc(tls, int32('\n'), f)
	goto done
done:
	;
	Xfunlockfile(tls, f)
	if r < 0 {
		v5 = -int32(1)
	} else {
		v5 = 0
	}
	return v5
}

func Xputpwent(tls *TLS, pw uintptr, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v pw=%v f=%v, (%v:)", tls, pw, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var v1 int32
	_ = v1
	if Xfprintf(tls, f, __ccgo_ts+1290, VaList(bp+8, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_name, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_passwd, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_uid, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_gid, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_gecos, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_dir, (*Tpasswd)(unsafe.Pointer(pw)).Fpw_shell)) < 0 {
		v1 = -int32(1)
	} else {
		v1 = 0
	}
	return v1
}

func Xputspent(tls *TLS, sp uintptr, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v sp=%v f=%v, (%v:)", tls, sp, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(144)
	defer tls.Free(144)
	var v1, v10, v12, v14, v16, v4, v6, v8 int32
	var v11, v13, v15, v5, v7, v9 int64
	var v17 uint64
	var v2, v3 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = v1, v10, v11, v12, v13, v14, v15, v16, v17, v2, v3, v4, v5, v6, v7, v8, v9
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_namp != 0 {
		v2 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_namp
	} else {
		v2 = __ccgo_ts
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_pwdp != 0 {
		v3 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_pwdp
	} else {
		v3 = __ccgo_ts
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_lstchg == int64(-int32(1)) {
		v4 = 0
	} else {
		v4 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_lstchg == int64(-int32(1)) {
		v5 = 0
	} else {
		v5 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_lstchg
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_min == int64(-int32(1)) {
		v6 = 0
	} else {
		v6 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_min == int64(-int32(1)) {
		v7 = 0
	} else {
		v7 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_min
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_max == int64(-int32(1)) {
		v8 = 0
	} else {
		v8 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_max == int64(-int32(1)) {
		v9 = 0
	} else {
		v9 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_max
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_warn == int64(-int32(1)) {
		v10 = 0
	} else {
		v10 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_warn == int64(-int32(1)) {
		v11 = 0
	} else {
		v11 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_warn
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_inact == int64(-int32(1)) {
		v12 = 0
	} else {
		v12 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_inact == int64(-int32(1)) {
		v13 = 0
	} else {
		v13 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_inact
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_expire == int64(-int32(1)) {
		v14 = 0
	} else {
		v14 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_expire == int64(-int32(1)) {
		v15 = 0
	} else {
		v15 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_expire
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_flag == uint64(-Int32FromInt32(1)) {
		v16 = 0
	} else {
		v16 = -int32(1)
	}
	if (*Tspwd)(unsafe.Pointer(sp)).Fsp_flag == uint64(-Int32FromInt32(1)) {
		v17 = uint64(0)
	} else {
		v17 = (*Tspwd)(unsafe.Pointer(sp)).Fsp_flag
	}
	if Xfprintf(tls, f, __ccgo_ts+1312, VaList(bp+8, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)) < 0 {
		v1 = -int32(1)
	} else {
		v1 = 0
	}
	return v1
}

func X__rand48_step(tls *TLS, xi uintptr, lc uintptr) (r Tuint64_t) {
	if __ccgo_strace {
		trc("tls=%v xi=%v lc=%v, (%v:)", tls, xi, lc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, x Tuint64_t
	_, _ = a, x
	x = uint64(uint32(*(*uint16)(unsafe.Pointer(xi)))|(uint32(*(*uint16)(unsafe.Pointer(xi + 1*2)))+0)<<int32(16)) | (uint64(*(*uint16)(unsafe.Pointer(xi + 2*2)))+0)<<int32(32)
	a = uint64(uint32(*(*uint16)(unsafe.Pointer(lc)))|(uint32(*(*uint16)(unsafe.Pointer(lc + 1*2)))+0)<<int32(16)) | (uint64(*(*uint16)(unsafe.Pointer(lc + 2*2)))+0)<<int32(32)
	x = a*x + uint64(*(*uint16)(unsafe.Pointer(lc + 3*2)))
	*(*uint16)(unsafe.Pointer(xi)) = uint16(x)
	*(*uint16)(unsafe.Pointer(xi + 1*2)) = uint16(x >> int32(16))
	*(*uint16)(unsafe.Pointer(xi + 2*2)) = uint16(x >> int32(32))
	return x & uint64(0xffffffffffff)
}

func Xerand48(tls *TLS, s uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* x at bp+0 */ struct {
		Ff [0]float64
		Fu Tuint64_t
	}
	*(*struct {
		Ff [0]float64
		Fu Tuint64_t
	})(unsafe.Pointer(bp)) = struct {
		Ff [0]float64
		Fu Tuint64_t
	}{}
	*(*uint64)(unsafe.Pointer(bp)) = uint64(0x3ff0000000000000) | X__rand48_step(tls, s, uintptr(unsafe.Pointer(&X__seed48))+uintptr(3)*2)<<int32(4)
	return *(*float64)(unsafe.Pointer(bp)) - float64(1)
}

func Xdrand48(tls *TLS) (r float64) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xerand48(tls, uintptr(unsafe.Pointer(&X__seed48)))
}

func Xlcong48(tls *TLS, p uintptr) {
	if __ccgo_strace {
		trc("tls=%v p=%v, (%v:)", tls, p, origin(2))
	}
	Xmemcpy(tls, uintptr(unsafe.Pointer(&X__seed48)), p, uint64(14))
}

func Xnrand48(tls *TLS, s uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(X__rand48_step(tls, s, uintptr(unsafe.Pointer(&X__seed48))+uintptr(3)*2) >> int32(17))
}

func Xlrand48(tls *TLS) (r int64) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xnrand48(tls, uintptr(unsafe.Pointer(&X__seed48)))
}

func Xjrand48(tls *TLS, s uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(int32(X__rand48_step(tls, s, uintptr(unsafe.Pointer(&X__seed48))+uintptr(3)*2) >> Int32FromInt32(16)))
}

func Xmrand48(tls *TLS) (r int64) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xjrand48(tls, uintptr(unsafe.Pointer(&X__seed48)))
}

var _seed Tuint64_t

func Xsrand(tls *TLS, s uint32) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
	}
	_seed = uint64(s - uint32(1))
}

func Xrand(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	_seed = uint64(6364136223846793005)*_seed + uint64(1)
	return int32(_seed >> int32(33))
}

func _temper(tls *TLS, x uint32) (r uint32) {
	x ^= x >> int32(11)
	x ^= x << int32(7) & uint32(0x9D2C5680)
	x ^= x << int32(15) & uint32(0xEFC60000)
	x ^= x >> int32(18)
	return x
}

func Xrand_r(tls *TLS, seed uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v seed=%v, (%v:)", tls, seed, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 uint32
	_ = v1
	v1 = *(*uint32)(unsafe.Pointer(seed))*Uint32FromInt32(1103515245) + Uint32FromInt32(12345)
	*(*uint32)(unsafe.Pointer(seed)) = v1
	return int32(_temper(tls, v1) / uint32(2))
}

/*
this code uses the same lagged fibonacci generator as the
original bsd random implementation except for the seeding
which was broken in the original
*/

var _init = [32]Tuint32_t{
	1:  uint32(0x5851f42d),
	2:  uint32(0xc0b18ccf),
	3:  uint32(0xcbb5f646),
	4:  uint32(0xc7033129),
	5:  uint32(0x30705b04),
	6:  uint32(0x20fd5db4),
	7:  uint32(0x9a8b7f78),
	8:  uint32(0x502959d8),
	9:  uint32(0xab894868),
	10: uint32(0x6c0356a7),
	11: uint32(0x88cdb7ff),
	12: uint32(0xb477d43f),
	13: uint32(0x70a3a52b),
	14: uint32(0xa8e4baf1),
	15: uint32(0xfd8341fc),
	16: uint32(0x8ae16fd9),
	17: uint32(0x742d2f7a),
	18: uint32(0x0d1f0796),
	19: uint32(0x76035e09),
	20: uint32(0x40f7702c),
	21: uint32(0x6fa72ca5),
	22: uint32(0xaaa84157),
	23: uint32(0x58a0df74),
	24: uint32(0xc74a0364),
	25: uint32(0xae533cc4),
	26: uint32(0x04185faf),
	27: uint32(0x6de3b115),
	28: uint32(0x0cab8628),
	29: uint32(0xf043bfa4),
	30: uint32(0x398150e9),
	31: uint32(0x37521657),
}

var _n = int32(31)
var _i = int32(3)
var _j = int32(0)
var _x1 = uintptr(unsafe.Pointer(&_init)) + uintptr(1)*4
var _lock3 [1]int32

func _lcg31(tls *TLS, x Tuint32_t) (r Tuint32_t) {
	return (uint32(1103515245)*x + uint32(12345)) & uint32(0x7fffffff)
}

func _lcg64(tls *TLS, x Tuint64_t) (r Tuint64_t) {
	return uint64(6364136223846793005)*x + uint64(1)
}

func _savestate(tls *TLS) (r uintptr) {
	*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(-Int32FromInt32(1))*4)) = uint32(_n<<int32(16) | _i<<int32(8) | _j)
	return _x1 - uintptr(1)*4
}

func _loadstate(tls *TLS, state uintptr) {
	_x1 = state + uintptr(1)*4
	_n = int32(*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(-Int32FromInt32(1))*4)) >> int32(16))
	_i = int32(*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(-Int32FromInt32(1))*4)) >> Int32FromInt32(8) & uint32(0xff))
	_j = int32(*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(-Int32FromInt32(1))*4)) & uint32(0xff))
}

func ___srandom(tls *TLS, seed uint32) {
	var k, v1 int32
	var s Tuint64_t
	_, _, _ = k, s, v1
	s = uint64(seed)
	if _n == 0 {
		*(*Tuint32_t)(unsafe.Pointer(_x1)) = uint32(s)
		return
	}
	if _n == int32(31) || _n == int32(7) {
		v1 = int32(3)
	} else {
		v1 = int32(1)
	}
	_i = v1
	_j = 0
	k = 0
	for {
		if !(k < _n) {
			break
		}
		s = _lcg64(tls, s)
		*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(k)*4)) = uint32(s >> int32(32))
		goto _2
	_2:
		;
		k++
	}
	/* make sure x contains at least one odd number */
	*(*Tuint32_t)(unsafe.Pointer(_x1)) |= uint32(1)
}

func Xsrandom(tls *TLS, seed uint32) {
	if __ccgo_strace {
		trc("tls=%v seed=%v, (%v:)", tls, seed, origin(2))
	}
	___lock(tls, uintptr(unsafe.Pointer(&_lock3)))
	___srandom(tls, seed)
	___unlock(tls, uintptr(unsafe.Pointer(&_lock3)))
}

func Xinitstate(tls *TLS, seed uint32, state uintptr, size Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v seed=%v state=%v size=%v, (%v:)", tls, seed, state, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var old uintptr
	_ = old
	if size < uint64(8) {
		return uintptr(0)
	}
	___lock(tls, uintptr(unsafe.Pointer(&_lock3)))
	old = _savestate(tls)
	if size < uint64(32) {
		_n = 0
	} else {
		if size < uint64(64) {
			_n = int32(7)
		} else {
			if size < uint64(128) {
				_n = int32(15)
			} else {
				if size < uint64(256) {
					_n = int32(31)
				} else {
					_n = int32(63)
				}
			}
		}
	}
	_x1 = state + uintptr(1)*4
	___srandom(tls, seed)
	_savestate(tls)
	___unlock(tls, uintptr(unsafe.Pointer(&_lock3)))
	return old
}

func Xsetstate(tls *TLS, state uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v state=%v, (%v:)", tls, state, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var old uintptr
	_ = old
	___lock(tls, uintptr(unsafe.Pointer(&_lock3)))
	old = _savestate(tls)
	_loadstate(tls, state)
	___unlock(tls, uintptr(unsafe.Pointer(&_lock3)))
	return old
}

func Xrandom(tls *TLS) (r int64) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var k int64
	var v1 Tuint32_t
	var v2, v3 int32
	_, _, _, _ = k, v1, v2, v3
	___lock(tls, uintptr(unsafe.Pointer(&_lock3)))
	if _n == 0 {
		v1 = _lcg31(tls, *(*Tuint32_t)(unsafe.Pointer(_x1)))
		*(*Tuint32_t)(unsafe.Pointer(_x1)) = v1
		k = int64(v1)
		goto end
	}
	*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(_i)*4)) += *(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(_j)*4))
	k = int64(*(*Tuint32_t)(unsafe.Pointer(_x1 + uintptr(_i)*4)) >> int32(1))
	_i++
	v2 = _i
	if v2 == _n {
		_i = 0
	}
	_j++
	v3 = _j
	if v3 == _n {
		_j = 0
	}
	goto end
end:
	;
	___unlock(tls, uintptr(unsafe.Pointer(&_lock3)))
	return k
}

func Xseed48(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	Xmemcpy(tls, uintptr(unsafe.Pointer(&_p1)), uintptr(unsafe.Pointer(&X__seed48)), uint64(6))
	Xmemcpy(tls, uintptr(unsafe.Pointer(&X__seed48)), s, uint64(6))
	return uintptr(unsafe.Pointer(&_p1))
}

var _p1 [3]uint16

func Xsrand48(tls *TLS, seed int64) {
	if __ccgo_strace {
		trc("tls=%v seed=%v, (%v:)", tls, seed, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*[3]uint16)(unsafe.Pointer(bp)) = [3]uint16{
		0: uint16(0x330e),
		1: uint16(seed),
		2: uint16(seed >> int32(16)),
	}
	Xseed48(tls, bp)
}

func Xexecl(tls *TLS, path uintptr, argv0 uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v argv0=%v va=%v, (%v:)", tls, path, argv0, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var argc, i int32
	var argv uintptr
	var v2 t__predefined_size_t
	_, _, _, _, _ = ap, argc, argv, i, v2
	defer func() { Xrealloc(tls, argv, 0) }()
	ap = va
	argc = int32(1)
	for {
		if !(VaUintptr(&ap) != 0) {
			break
		}
		goto _1
	_1:
		;
		argc++
	}
	_ = ap
	v2 = uint64(argc+int32(1)) * 8
	argv = Xrealloc(tls, argv, v2)
	ap = va
	*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), 0*8)) = argv0
	i = int32(1)
	for {
		if !(i < argc) {
			break
		}
		*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = VaUintptr(&ap)
		goto _3
	_3:
		;
		i++
	}
	*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = UintptrFromInt32(0)
	_ = ap
	return Xexecv(tls, path, argv)
	return r
}

func Xexecle(tls *TLS, path uintptr, argv0 uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v argv0=%v va=%v, (%v:)", tls, path, argv0, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var argc, i int32
	var argv, envp uintptr
	var v2 t__predefined_size_t
	_, _, _, _, _, _ = ap, argc, argv, envp, i, v2
	defer func() { Xrealloc(tls, argv, 0) }()
	ap = va
	argc = int32(1)
	for {
		if !(VaUintptr(&ap) != 0) {
			break
		}
		goto _1
	_1:
		;
		argc++
	}
	_ = ap
	v2 = uint64(argc+int32(1)) * 8
	argv = Xrealloc(tls, argv, v2)
	ap = va
	*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), 0*8)) = argv0
	i = int32(1)
	for {
		if !(i <= argc) {
			break
		}
		*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = VaUintptr(&ap)
		goto _3
	_3:
		;
		i++
	}
	envp = VaUintptr(&ap)
	_ = ap
	return Xexecve(tls, path, argv, envp)
	return r
}

func Xexeclp(tls *TLS, file uintptr, argv0 uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v file=%v argv0=%v va=%v, (%v:)", tls, file, argv0, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var argc, i int32
	var argv uintptr
	var v2 t__predefined_size_t
	_, _, _, _, _ = ap, argc, argv, i, v2
	defer func() { Xrealloc(tls, argv, 0) }()
	ap = va
	argc = int32(1)
	for {
		if !(VaUintptr(&ap) != 0) {
			break
		}
		goto _1
	_1:
		;
		argc++
	}
	_ = ap
	v2 = uint64(argc+int32(1)) * 8
	argv = Xrealloc(tls, argv, v2)
	ap = va
	*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), 0*8)) = argv0
	i = int32(1)
	for {
		if !(i < argc) {
			break
		}
		*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = VaUintptr(&ap)
		goto _3
	_3:
		;
		i++
	}
	*(*uintptr)(unsafe.Add(unsafe.Pointer(argv), i*8)) = UintptrFromInt32(0)
	_ = ap
	return Xexecvp(tls, file, argv)
	return r
}

func Xexecv(tls *TLS, path uintptr, argv uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v argv=%v, (%v:)", tls, path, argv, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xexecve(tls, path, argv, Xenviron)
}

func Xexecve(tls *TLS, path uintptr, argv uintptr, envp uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v argv=%v envp=%v, (%v:)", tls, path, argv, envp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* do we need to use environ if envp is null? */
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_execve), int64(path), int64(argv), int64(envp)))))
}

func X__execvpe(tls *TLS, file uintptr, argv uintptr, envp uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v file=%v argv=%v envp=%v, (%v:)", tls, file, argv, envp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var b, p, path, z, v3, v4 uintptr
	var k, l Tsize_t
	var seen_eacces int32
	var v2 t__predefined_size_t
	_, _, _, _, _, _, _, _, _, _ = b, k, l, p, path, seen_eacces, z, v2, v3, v4
	defer func() { Xrealloc(tls, b, 0) }()
	path = Xgetenv(tls, __ccgo_ts+1361)
	seen_eacces = 0
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOENT)
	if !(*(*uint8)(unsafe.Pointer(file)) != 0) {
		return -int32(1)
	}
	if Xstrchr(tls, file, int32('/')) != 0 {
		return Xexecve(tls, file, argv, envp)
	}
	if !(path != 0) {
		path = __ccgo_ts + 1366
	}
	k = Xstrnlen(tls, file, uint64(Int32FromInt32(NAME_MAX)+Int32FromInt32(1)))
	if k > uint64(NAME_MAX) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENAMETOOLONG)
		return -int32(1)
	}
	l = Xstrnlen(tls, path, uint64(Int32FromInt32(PATH_MAX)-Int32FromInt32(1))) + uint64(1)
	p = path
	for {
		v2 = l + k + uint64(1)
		b = Xrealloc(tls, b, v2)
		z = X__strchrnul(tls, p, int32(':'))
		if uint64(int64(z)-int64(p)) >= l {
			v3 = z
			z++
			if !(*(*uint8)(unsafe.Pointer(v3)) != 0) {
				break
			}
			goto _1
		}
		Xmemcpy(tls, b, p, uint64(int64(z)-int64(p)))
		*(*uint8)(unsafe.Add(unsafe.Pointer(b), int64(z)-int64(p))) = uint8('/')
		Xmemcpy(tls, b+uintptr(int64(z)-int64(p))+BoolUintptr(z > p), file, k+uint64(1))
		Xexecve(tls, b, argv, envp)
		switch *(*int32)(unsafe.Pointer(X__errno_location(tls))) {
		case int32(EACCES):
			seen_eacces = int32(1)
			fallthrough
		case int32(ENOENT):
			fallthrough
		case int32(ENOTDIR):
		default:
			return -int32(1)
		}
		v4 = z
		z++
		if !(*(*uint8)(unsafe.Pointer(v4)) != 0) {
			break
		}
		goto _1
	_1:
		;
		p = z
	}
	if seen_eacces != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EACCES)
	}
	return -int32(1)
}

func Xexecvp(tls *TLS, file uintptr, argv uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v file=%v argv=%v, (%v:)", tls, file, argv, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__execvpe(tls, file, argv, Xenviron)
}

func Xexecvpe(tls *TLS, file uintptr, argv uintptr, envp uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v file=%v argv=%v envp=%v, (%v:)", tls, file, argv, envp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__execvpe(tls, file, argv, envp)
}

func Xfexecve(tls *TLS, fd int32, argv uintptr, envp uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v argv=%v envp=%v, (%v:)", tls, fd, argv, envp, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var r int32
	var _ /* buf at bp+0 */ [27]uint8
	_ = r
	r = int32(X__syscall5(tls, int64(SYS_execveat), int64(fd), int64(__ccgo_ts), int64(argv), int64(envp), int64(Int32FromInt32(AT_EMPTY_PATH))))
	if r != -int32(ENOSYS) {
		return int32(X__syscall_ret(tls, uint64(r)))
	}
	X__procfdname(tls, bp, uint32(fd))
	Xexecve(tls, bp, argv, envp)
	if *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(ENOENT) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EBADF)
	}
	return -int32(1)
}

var _dummy_lockptr = uintptr(0)

var _atfork_locks = [10]uintptr{
	0: uintptr(unsafe.Pointer(&X__at_quick_exit_lockptr)),
	1: uintptr(unsafe.Pointer(&_dummy_lockptr)),
	2: uintptr(unsafe.Pointer(&X__gettext_lockptr)),
	3: uintptr(unsafe.Pointer(&X__locale_lockptr)),
	4: uintptr(unsafe.Pointer(&X__random_lockptr)),
	5: uintptr(unsafe.Pointer(&_dummy_lockptr)),
	6: uintptr(unsafe.Pointer(&X__stdio_ofl_lockptr)),
	7: uintptr(unsafe.Pointer(&X__syslog_lockptr)),
	8: uintptr(unsafe.Pointer(&X__timezone_lockptr)),
	9: uintptr(unsafe.Pointer(&_dummy_lockptr)),
}

func _dummy8(tls *TLS, x int32) {
}

func _dummy_0(tls *TLS) {
}

const FDOP_CHDIR = 4
const FDOP_CLOSE = 1
const FDOP_DUP2 = 2
const FDOP_FCHDIR = 5
const FDOP_OPEN = 3
const POSIX_SPAWN_RESETIDS = 1
const POSIX_SPAWN_SETPGROUP = 2
const POSIX_SPAWN_SETSCHEDPARAM = 16
const POSIX_SPAWN_SETSCHEDULER = 32
const POSIX_SPAWN_SETSID = 128
const POSIX_SPAWN_SETSIGDEF = 4
const POSIX_SPAWN_SETSIGMASK = 8
const POSIX_SPAWN_USEVFORK = 64

type Tposix_spawnattr_t = struct {
	F__flags int32
	F__pgrp  Tpid_t
	F__def   Tsigset_t
	F__mask  Tsigset_t
	F__prio  int32
	F__pol   int32
	F__fn    uintptr
	F__pad   [56]uint8
}

type Tposix_spawn_file_actions_t = struct {
	F__pad0    [2]int32
	F__actions uintptr
	F__pad     [16]int32
}

type Tfdop = struct {
	Fnext  uintptr
	Fprev  uintptr
	Fcmd   int32
	Ffd    int32
	Fsrcfd int32
	Foflag int32
	Fmode  Tmode_t
}

func Xposix_spawn_file_actions_addchdir_np(tls *TLS, fa uintptr, path uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fa=%v path=%v, (%v:)", tls, fa, path, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var op, v1 uintptr
	_, _ = op, v1
	op = Xmalloc(tls, uint64(40)+Xstrlen(tls, path)+uint64(1))
	if !(op != 0) {
		return int32(ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(FDOP_CHDIR)
	(*Tfdop)(unsafe.Pointer(op)).Ffd = -int32(1)
	Xstrcpy(tls, op+36, path)
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return 0
}

func Xposix_spawn_file_actions_addclose(tls *TLS, fa uintptr, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fa=%v fd=%v, (%v:)", tls, fa, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var op, v1 uintptr
	_, _ = op, v1
	if fd < 0 {
		return int32(EBADF)
	}
	op = Xmalloc(tls, uint64(40))
	if !(op != 0) {
		return int32(ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(FDOP_CLOSE)
	(*Tfdop)(unsafe.Pointer(op)).Ffd = fd
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return 0
}

func Xposix_spawn_file_actions_adddup2(tls *TLS, fa uintptr, srcfd int32, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fa=%v srcfd=%v fd=%v, (%v:)", tls, fa, srcfd, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var op, v1 uintptr
	_, _ = op, v1
	if srcfd < 0 || fd < 0 {
		return int32(EBADF)
	}
	op = Xmalloc(tls, uint64(40))
	if !(op != 0) {
		return int32(ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(FDOP_DUP2)
	(*Tfdop)(unsafe.Pointer(op)).Fsrcfd = srcfd
	(*Tfdop)(unsafe.Pointer(op)).Ffd = fd
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return 0
}

func Xposix_spawn_file_actions_addfchdir_np(tls *TLS, fa uintptr, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fa=%v fd=%v, (%v:)", tls, fa, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var op, v1 uintptr
	_, _ = op, v1
	if fd < 0 {
		return int32(EBADF)
	}
	op = Xmalloc(tls, uint64(40))
	if !(op != 0) {
		return int32(ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(FDOP_FCHDIR)
	(*Tfdop)(unsafe.Pointer(op)).Ffd = fd
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return 0
}

func Xposix_spawn_file_actions_addopen(tls *TLS, fa uintptr, fd int32, path uintptr, flags int32, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fa=%v fd=%v path=%v flags=%v mode=%v, (%v:)", tls, fa, fd, path, flags, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var op, v1 uintptr
	_, _ = op, v1
	if fd < 0 {
		return int32(EBADF)
	}
	op = Xmalloc(tls, uint64(40)+Xstrlen(tls, path)+uint64(1))
	if !(op != 0) {
		return int32(ENOMEM)
	}
	(*Tfdop)(unsafe.Pointer(op)).Fcmd = int32(FDOP_OPEN)
	(*Tfdop)(unsafe.Pointer(op)).Ffd = fd
	(*Tfdop)(unsafe.Pointer(op)).Foflag = flags
	(*Tfdop)(unsafe.Pointer(op)).Fmode = mode
	Xstrcpy(tls, op+36, path)
	v1 = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	(*Tfdop)(unsafe.Pointer(op)).Fnext = v1
	if v1 != 0 {
		(*Tfdop)(unsafe.Pointer((*Tfdop)(unsafe.Pointer(op)).Fnext)).Fprev = op
	}
	(*Tfdop)(unsafe.Pointer(op)).Fprev = uintptr(0)
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = op
	return 0
}

func Xposix_spawn_file_actions_destroy(tls *TLS, fa uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fa=%v, (%v:)", tls, fa, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var next, op uintptr
	_, _ = next, op
	op = (*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions
	for op != 0 {
		next = (*Tfdop)(unsafe.Pointer(op)).Fnext
		Xfree(tls, op)
		op = next
	}
	return 0
}

func Xposix_spawn_file_actions_init(tls *TLS, fa uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fa=%v, (%v:)", tls, fa, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	(*Tposix_spawn_file_actions_t)(unsafe.Pointer(fa)).F__actions = uintptr(0)
	return 0
}

func Xposix_spawnattr_destroy(tls *TLS, attr uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v, (%v:)", tls, attr, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func Xposix_spawnattr_getflags(tls *TLS, attr uintptr, flags uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v flags=%v, (%v:)", tls, attr, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	*(*int16)(unsafe.Pointer(flags)) = int16((*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__flags)
	return 0
}

func Xposix_spawnattr_getpgroup(tls *TLS, attr uintptr, pgrp uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v pgrp=%v, (%v:)", tls, attr, pgrp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	*(*Tpid_t)(unsafe.Pointer(pgrp)) = (*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__pgrp
	return 0
}

func Xposix_spawnattr_getsigdefault(tls *TLS, attr uintptr, def uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v def=%v, (%v:)", tls, attr, def, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	*(*Tsigset_t)(unsafe.Pointer(def)) = (*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__def
	return 0
}

func Xposix_spawnattr_getsigmask(tls *TLS, attr uintptr, mask uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v mask=%v, (%v:)", tls, attr, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	*(*Tsigset_t)(unsafe.Pointer(mask)) = (*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__mask
	return 0
}

func Xposix_spawnattr_init(tls *TLS, attr uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v, (%v:)", tls, attr, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	*(*Tposix_spawnattr_t)(unsafe.Pointer(attr)) = Tposix_spawnattr_t{}
	return 0
}

func Xposix_spawnattr_getschedparam(tls *TLS, attr uintptr, schedparam uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v schedparam=%v, (%v:)", tls, attr, schedparam, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(ENOSYS)
}

func Xposix_spawnattr_setschedparam(tls *TLS, attr uintptr, schedparam uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v schedparam=%v, (%v:)", tls, attr, schedparam, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(ENOSYS)
}

func Xposix_spawnattr_getschedpolicy(tls *TLS, attr uintptr, policy uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v policy=%v, (%v:)", tls, attr, policy, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(ENOSYS)
}

func Xposix_spawnattr_setschedpolicy(tls *TLS, attr uintptr, policy int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v policy=%v, (%v:)", tls, attr, policy, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(ENOSYS)
}

func Xposix_spawnattr_setflags(tls *TLS, attr uintptr, flags int16) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v flags=%v, (%v:)", tls, attr, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var all_flags uint32
	_ = all_flags
	all_flags = uint32(Int32FromInt32(POSIX_SPAWN_RESETIDS) | Int32FromInt32(POSIX_SPAWN_SETPGROUP) | Int32FromInt32(POSIX_SPAWN_SETSIGDEF) | Int32FromInt32(POSIX_SPAWN_SETSIGMASK) | Int32FromInt32(POSIX_SPAWN_SETSCHEDPARAM) | Int32FromInt32(POSIX_SPAWN_SETSCHEDULER) | Int32FromInt32(POSIX_SPAWN_USEVFORK) | Int32FromInt32(POSIX_SPAWN_SETSID))
	if uint32(flags) & ^all_flags != 0 {
		return int32(EINVAL)
	}
	(*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__flags = int32(flags)
	return 0
}

func Xposix_spawnattr_setpgroup(tls *TLS, attr uintptr, pgrp Tpid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v pgrp=%v, (%v:)", tls, attr, pgrp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	(*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__pgrp = pgrp
	return 0
}

func Xposix_spawnattr_setsigdefault(tls *TLS, attr uintptr, def uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v def=%v, (%v:)", tls, attr, def, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	(*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__def = *(*Tsigset_t)(unsafe.Pointer(def))
	return 0
}

func Xposix_spawnattr_setsigmask(tls *TLS, attr uintptr, mask uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v attr=%v mask=%v, (%v:)", tls, attr, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	(*Tposix_spawnattr_t)(unsafe.Pointer(attr)).F__mask = *(*Tsigset_t)(unsafe.Pointer(mask))
	return 0
}

func Xvfork(tls *TLS) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* vfork syscall cannot be made from C code */
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_clone), int64(Int32FromInt32(SIGCHLD)), int64(Int32FromInt32(0))))))
}
func Xwait(tls *TLS, status uintptr) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v status=%v, (%v:)", tls, status, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwaitpid(tls, -Int32FromInt32(1), status, 0)
}

func Xwaitid(tls *TLS, type1 Tidtype_t, id Tid_t, info uintptr, options int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v type1=%v id=%v info=%v options=%v, (%v:)", tls, type1, id, info, options, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_waitid), int64(type1), int64(id), int64(info), int64(options), int64(Int32FromInt32(0)), 0))))
}

func Xwaitpid(tls *TLS, pid Tpid_t, status uintptr, options int32) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v pid=%v status=%v options=%v, (%v:)", tls, pid, status, options, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_wait4), int64(pid), int64(status), int64(options), int64(Int32FromInt32(0)), 0, 0))))
}

const BRACKET = -3
const END = 0
const FNM_CASEFOLD = 16
const FNM_FILE_NAME = 1
const FNM_LEADING_DIR = 8
const FNM_NOESCAPE = 2
const FNM_NOMATCH = 1
const FNM_NOSYS = -1
const FNM_PATHNAME = 1
const FNM_PERIOD = 4
const QUESTION = -4
const STAR = -5
const UNMATCHABLE = -2

func _str_next(tls *TLS, str uintptr, n Tsize_t, step uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var k int32
	var _ /* wc at bp+0 */ Twchar_t
	_ = k
	if !(n != 0) {
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(0)
		return 0
	}
	if uint32(*(*uint8)(unsafe.Pointer(str))) >= uint32(128) {
		k = Xmbtowc(tls, bp, str, n)
		if k < 0 {
			*(*Tsize_t)(unsafe.Pointer(step)) = uint64(1)
			return -int32(1)
		}
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(k)
		return int32(*(*Twchar_t)(unsafe.Pointer(bp)))
	}
	*(*Tsize_t)(unsafe.Pointer(step)) = uint64(1)
	return int32(*(*uint8)(unsafe.Pointer(str)))
}

func _pat_next(tls *TLS, pat uintptr, m Tsize_t, step uintptr, flags int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var esc, k1, z int32
	var k Tsize_t
	var _ /* wc at bp+0 */ Twchar_t
	_, _, _, _ = esc, k, k1, z
	esc = 0
	if !(m != 0) || !(*(*uint8)(unsafe.Pointer(pat)) != 0) {
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(0)
		return END
	}
	*(*Tsize_t)(unsafe.Pointer(step)) = uint64(1)
	if int32(*(*uint8)(unsafe.Pointer(pat))) == int32('\\') && *(*uint8)(unsafe.Pointer(pat + 1)) != 0 && !(flags&Int32FromInt32(FNM_NOESCAPE) != 0) {
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(2)
		pat++
		esc = int32(1)
		goto escaped
	}
	if int32(*(*uint8)(unsafe.Pointer(pat))) == int32('[') {
		k = uint64(1)
		if k < m {
			if int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k)))) == int32('^') || int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k)))) == int32('!') {
				k++
			}
		}
		if k < m {
			if int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k)))) == int32(']') {
				k++
			}
		}
		for {
			if !(k < m && *(*uint8)(unsafe.Pointer(pat + uintptr(k))) != 0 && int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k)))) != int32(']')) {
				break
			}
			if k+uint64(1) < m && *(*uint8)(unsafe.Pointer(pat + uintptr(k+uint64(1)))) != 0 && int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k)))) == int32('[') && (int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k+uint64(1))))) == int32(':') || int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k+uint64(1))))) == int32('.') || int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k+uint64(1))))) == int32('=')) {
				z = int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k+uint64(1)))))
				k += uint64(2)
				if k < m && *(*uint8)(unsafe.Pointer(pat + uintptr(k))) != 0 {
					k++
				}
				for k < m && *(*uint8)(unsafe.Pointer(pat + uintptr(k))) != 0 && (int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k-uint64(1))))) != z || int32(*(*uint8)(unsafe.Pointer(pat + uintptr(k)))) != int32(']')) {
					k++
				}
				if k == m || !(*(*uint8)(unsafe.Pointer(pat + uintptr(k))) != 0) {
					break
				}
			}
			goto _1
		_1:
			;
			k++
		}
		if k == m || !(*(*uint8)(unsafe.Pointer(pat + uintptr(k))) != 0) {
			*(*Tsize_t)(unsafe.Pointer(step)) = uint64(1)
			return int32('[')
		}
		*(*Tsize_t)(unsafe.Pointer(step)) = k + uint64(1)
		return -int32(3)
	}
	if int32(*(*uint8)(unsafe.Pointer(pat))) == int32('*') {
		return -int32(5)
	}
	if int32(*(*uint8)(unsafe.Pointer(pat))) == int32('?') {
		return -int32(4)
	}
	goto escaped
escaped:
	;
	if uint32(*(*uint8)(unsafe.Pointer(pat))) >= uint32(128) {
		k1 = Xmbtowc(tls, bp, pat, m)
		if k1 < 0 {
			*(*Tsize_t)(unsafe.Pointer(step)) = uint64(0)
			return -int32(2)
		}
		*(*Tsize_t)(unsafe.Pointer(step)) = uint64(k1 + esc)
		return int32(*(*Twchar_t)(unsafe.Pointer(bp)))
	}
	return int32(*(*uint8)(unsafe.Pointer(pat)))
}

func _casefold(tls *TLS, k int32) (r int32) {
	var c int32
	var v1 uint32
	_, _ = c, v1
	c = int32(Xtowupper(tls, uint32(k)))
	if c == k {
		v1 = Xtowlower(tls, uint32(k))
	} else {
		v1 = uint32(c)
	}
	return int32(v1)
}

func _match_bracket(tls *TLS, p uintptr, k int32, kfold int32) (r int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var inv, l, l1, z int32
	var p0 uintptr
	var _ /* buf at bp+8 */ [16]uint8
	var _ /* wc at bp+0 */ Twchar_t
	var _ /* wc2 at bp+4 */ Twchar_t
	_, _, _, _, _ = inv, l, l1, p0, z
	inv = 0
	p++
	if int32(*(*uint8)(unsafe.Pointer(p))) == int32('^') || int32(*(*uint8)(unsafe.Pointer(p))) == int32('!') {
		inv = int32(1)
		p++
	}
	if int32(*(*uint8)(unsafe.Pointer(p))) == int32(']') {
		if k == int32(']') {
			return BoolInt32(!(inv != 0))
		}
		p++
	} else {
		if int32(*(*uint8)(unsafe.Pointer(p))) == int32('-') {
			if k == int32('-') {
				return BoolInt32(!(inv != 0))
			}
			p++
		}
	}
	*(*Twchar_t)(unsafe.Pointer(bp)) = uint32(*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1)))))
	for {
		if !(int32(*(*uint8)(unsafe.Pointer(p))) != int32(']')) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(p))) == int32('-') && int32(*(*uint8)(unsafe.Pointer(p + 1))) != int32(']') {
			l = Xmbtowc(tls, bp+4, p+uintptr(1), uint64(4))
			if l < 0 {
				return 0
			}
			if *(*Twchar_t)(unsafe.Pointer(bp)) <= *(*Twchar_t)(unsafe.Pointer(bp + 4)) {
				if uint32(k)-*(*Twchar_t)(unsafe.Pointer(bp)) <= *(*Twchar_t)(unsafe.Pointer(bp + 4))-*(*Twchar_t)(unsafe.Pointer(bp)) || uint32(kfold)-*(*Twchar_t)(unsafe.Pointer(bp)) <= *(*Twchar_t)(unsafe.Pointer(bp + 4))-*(*Twchar_t)(unsafe.Pointer(bp)) {
					return BoolInt32(!(inv != 0))
				}
			}
			p += uintptr(l - int32(1))
			goto _1
		}
		if int32(*(*uint8)(unsafe.Pointer(p))) == int32('[') && (int32(*(*uint8)(unsafe.Pointer(p + 1))) == int32(':') || int32(*(*uint8)(unsafe.Pointer(p + 1))) == int32('.') || int32(*(*uint8)(unsafe.Pointer(p + 1))) == int32('=')) {
			p0 = p + uintptr(2)
			z = int32(*(*uint8)(unsafe.Pointer(p + 1)))
			p += uintptr(3)
			for int32(*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1))))) != z || int32(*(*uint8)(unsafe.Pointer(p))) != int32(']') {
				p++
			}
			if z == int32(':') && int64(p-uintptr(1))-int64(p0) < int64(16) {
				Xmemcpy(tls, bp+8, p0, uint64(int64(p-uintptr(1))-int64(p0)))
				(*(*[16]uint8)(unsafe.Pointer(bp + 8)))[int64(p-uintptr(1))-int64(p0)] = uint8(0)
				if Xiswctype(tls, uint32(k), Xwctype(tls, bp+8)) != 0 || Xiswctype(tls, uint32(kfold), Xwctype(tls, bp+8)) != 0 {
					return BoolInt32(!(inv != 0))
				}
			}
			goto _1
		}
		if uint32(*(*uint8)(unsafe.Pointer(p))) < uint32(128) {
			*(*Twchar_t)(unsafe.Pointer(bp)) = uint32(*(*uint8)(unsafe.Pointer(p)))
		} else {
			l1 = Xmbtowc(tls, bp, p, uint64(4))
			if l1 < 0 {
				return 0
			}
			p += uintptr(l1 - int32(1))
		}
		if *(*Twchar_t)(unsafe.Pointer(bp)) == uint32(k) || *(*Twchar_t)(unsafe.Pointer(bp)) == uint32(kfold) {
			return BoolInt32(!(inv != 0))
		}
		goto _1
	_1:
		;
		p++
	}
	return inv
}

func _fnmatch_internal(tls *TLS, pat uintptr, m Tsize_t, str uintptr, n Tsize_t, flags int32) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, k, kfold, v12, v13, v15, v2, v3, v4, v8 int32
	var endpat, endstr, p, ptail, s, stail, v10, v6 uintptr
	var tailcnt Tsize_t
	var v9 bool
	var _ /* pinc at bp+0 */ Tsize_t
	var _ /* sinc at bp+8 */ Tsize_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, endpat, endstr, k, kfold, p, ptail, s, stail, tailcnt, v10, v12, v13, v15, v2, v3, v4, v6, v8, v9
	tailcnt = uint64(0)
	if flags&int32(FNM_PERIOD) != 0 {
		if int32(*(*uint8)(unsafe.Pointer(str))) == int32('.') && int32(*(*uint8)(unsafe.Pointer(pat))) != int32('.') {
			return int32(FNM_NOMATCH)
		}
	}
	for {
		v2 = _pat_next(tls, pat, m, bp, flags)
		c = v2
		switch v2 {
		case -int32(2):
			return int32(FNM_NOMATCH)
		case -int32(5):
			pat++
			m--
		default:
			k = _str_next(tls, str, n, bp+8)
			if k <= 0 {
				if c == END {
					v3 = 0
				} else {
					v3 = int32(FNM_NOMATCH)
				}
				return v3
			}
			str += uintptr(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
			n -= *(*Tsize_t)(unsafe.Pointer(bp + 8))
			if flags&int32(FNM_CASEFOLD) != 0 {
				v4 = _casefold(tls, k)
			} else {
				v4 = k
			}
			kfold = v4
			if c == -int32(3) {
				if !(_match_bracket(tls, pat, k, kfold) != 0) {
					return int32(FNM_NOMATCH)
				}
			} else {
				if c != -int32(4) && k != c && kfold != c {
					return int32(FNM_NOMATCH)
				}
			}
			pat += uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
			m -= *(*Tsize_t)(unsafe.Pointer(bp))
			goto _1
		}
		break
		goto _1
	_1:
	}
	/* Compute real pat length if it was initially unknown/-1 */
	m = Xstrnlen(tls, pat, m)
	endpat = pat + uintptr(m)
	/* Find the last * in pat and count chars needed after it */
	v6 = pat
	ptail = v6
	p = v6
	for {
		if !(p < endpat) {
			break
		}
		switch _pat_next(tls, p, uint64(int64(endpat)-int64(p)), bp, flags) {
		case -int32(2):
			return int32(FNM_NOMATCH)
		case -int32(5):
			tailcnt = uint64(0)
			ptail = p + uintptr(1)
		default:
			tailcnt++
			break
		}
		goto _5
	_5:
		;
		p += uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
	}
	/* Past this point we need not check for UNMATCHABLE in pat,
	 * because all of pat has already been parsed once. */
	/* Compute real str length if it was initially unknown/-1 */
	n = Xstrnlen(tls, str, n)
	endstr = str + uintptr(n)
	if n < tailcnt {
		return int32(FNM_NOMATCH)
	}
	/* Find the final tailcnt chars of str, accounting for UTF-8.
	 * On illegal sequences we may get it wrong, but in that case
	 * we necessarily have a matching failure anyway. */
	s = endstr
	for {
		if !(s > str && tailcnt != 0) {
			break
		}
		if v9 = uint32(*(*uint8)(unsafe.Pointer(s + uintptr(-Int32FromInt32(1))))) < uint32(128); !v9 {
			if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
				v8 = int32(4)
			} else {
				v8 = int32(1)
			}
		}
		if v9 || v8 == int32(1) {
			s--
		} else {
			for {
				s--
				v10 = s
				if !(uint32(*(*uint8)(unsafe.Pointer(v10)))-uint32(0x80) < uint32(0x40) && s > str) {
					break
				}
			}
		}
		goto _7
	_7:
		;
		tailcnt--
	}
	if tailcnt != 0 {
		return int32(FNM_NOMATCH)
	}
	stail = s
	/* Check that the pat and str tails match */
	p = ptail
	for {
		c = _pat_next(tls, p, uint64(int64(endpat)-int64(p)), bp, flags)
		p += uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
		v12 = _str_next(tls, s, uint64(int64(endstr)-int64(s)), bp+8)
		k = v12
		if v12 <= 0 {
			if c != END {
				return int32(FNM_NOMATCH)
			}
			break
		}
		s += uintptr(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
		if flags&int32(FNM_CASEFOLD) != 0 {
			v13 = _casefold(tls, k)
		} else {
			v13 = k
		}
		kfold = v13
		if c == -int32(3) {
			if !(_match_bracket(tls, p-uintptr(*(*Tsize_t)(unsafe.Pointer(bp))), k, kfold) != 0) {
				return int32(FNM_NOMATCH)
			}
		} else {
			if c != -int32(4) && k != c && kfold != c {
				return int32(FNM_NOMATCH)
			}
		}
		goto _11
	_11:
	}
	/* We're all done with the tails now, so throw them out */
	endstr = stail
	endpat = ptail
	/* Match pattern components until there are none left */
	for pat < endpat {
		p = pat
		s = str
		for {
			c = _pat_next(tls, p, uint64(int64(endpat)-int64(p)), bp, flags)
			p += uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
			/* Encountering * completes/commits a component */
			if c == -int32(5) {
				pat = p
				str = s
				break
			}
			k = _str_next(tls, s, uint64(int64(endstr)-int64(s)), bp+8)
			if !(k != 0) {
				return int32(FNM_NOMATCH)
			}
			if flags&int32(FNM_CASEFOLD) != 0 {
				v15 = _casefold(tls, k)
			} else {
				v15 = k
			}
			kfold = v15
			if c == -int32(3) {
				if !(_match_bracket(tls, p-uintptr(*(*Tsize_t)(unsafe.Pointer(bp))), k, kfold) != 0) {
					break
				}
			} else {
				if c != -int32(4) && k != c && kfold != c {
					break
				}
			}
			s += uintptr(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
			goto _14
		_14:
		}
		if c == -int32(5) {
			continue
		}
		/* If we failed, advance str, by 1 char if it's a valid
		 * char, or past all invalid bytes otherwise. */
		k = _str_next(tls, str, uint64(int64(endstr)-int64(str)), bp+8)
		if k > 0 {
			str += uintptr(*(*Tsize_t)(unsafe.Pointer(bp + 8)))
		} else {
			str++
			for {
				if !(_str_next(tls, str, uint64(int64(endstr)-int64(str)), bp+8) < 0) {
					break
				}
				goto _16
			_16:
				;
				str++
			}
		}
	}
	return 0
}

func Xfnmatch(tls *TLS, pat uintptr, str uintptr, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v pat=%v str=%v flags=%v, (%v:)", tls, pat, str, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, v4 int32
	var p, s uintptr
	var _ /* inc at bp+0 */ Tsize_t
	_, _, _, _ = c, p, s, v4
	if flags&int32(FNM_PATHNAME) != 0 {
		for {
			s = str
			for {
				if !(*(*uint8)(unsafe.Pointer(s)) != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != int32('/')) {
					break
				}
				goto _2
			_2:
				;
				s++
			}
			p = pat
			for {
				v4 = _pat_next(tls, p, uint64(-Int32FromInt32(1)), bp, flags)
				c = v4
				if !(v4 != END && c != int32('/')) {
					break
				}
				goto _3
			_3:
				;
				p += uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
			}
			if c != int32(*(*uint8)(unsafe.Pointer(s))) && (!(*(*uint8)(unsafe.Pointer(s)) != 0) || !(flags&Int32FromInt32(FNM_LEADING_DIR) != 0)) {
				return int32(FNM_NOMATCH)
			}
			if _fnmatch_internal(tls, pat, uint64(int64(p)-int64(pat)), str, uint64(int64(s)-int64(str)), flags) != 0 {
				return int32(FNM_NOMATCH)
			}
			if !(c != 0) {
				return 0
			}
			str = s + uintptr(1)
			pat = p + uintptr(*(*Tsize_t)(unsafe.Pointer(bp)))
			goto _1
		_1:
		}
	} else {
		if flags&int32(FNM_LEADING_DIR) != 0 {
			s = str
			for {
				if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
					break
				}
				if int32(*(*uint8)(unsafe.Pointer(s))) != int32('/') {
					goto _5
				}
				if !(_fnmatch_internal(tls, pat, uint64(-Int32FromInt32(1)), str, uint64(int64(s)-int64(str)), flags) != 0) {
					return 0
				}
				goto _5
			_5:
				;
				s++
			}
		}
	}
	return _fnmatch_internal(tls, pat, uint64(-Int32FromInt32(1)), str, uint64(-Int32FromInt32(1)), flags)
}

const GLOB_ABORTED = 2
const GLOB_APPEND = 32
const GLOB_DOOFFS = 8
const GLOB_ERR = 1
const GLOB_MARK = 2
const GLOB_NOCHECK = 16
const GLOB_NOESCAPE = 64
const GLOB_NOMATCH = 3
const GLOB_NOSORT = 4
const GLOB_NOSPACE = 1
const GLOB_NOSYS = 4
const GLOB_PERIOD = 128
const GLOB_TILDE = 4096
const GLOB_TILDE_CHECK = 16384

type Tglob_t = struct {
	Fgl_pathc Tsize_t
	Fgl_pathv uintptr
	Fgl_offs  Tsize_t
	F__dummy1 int32
	F__dummy2 [5]uintptr
}

type Tmatch = struct {
	Fnext uintptr
}

func _append(tls *TLS, tail uintptr, name uintptr, len1 Tsize_t, mark int32) (r int32) {
	var new1 uintptr
	_ = new1
	new1 = Xmalloc(tls, uint64(8)+len1+uint64(2))
	if !(new1 != 0) {
		return -int32(1)
	}
	(*Tmatch)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(tail)))).Fnext = new1
	(*Tmatch)(unsafe.Pointer(new1)).Fnext = UintptrFromInt32(0)
	Xmemcpy(tls, new1+8, name, len1+uint64(1))
	if mark != 0 && len1 != 0 && int32(*(*uint8)(unsafe.Pointer(name + uintptr(len1-uint64(1))))) != int32('/') {
		*(*uint8)(unsafe.Pointer(new1 + 8 + uintptr(len1))) = uint8('/')
		*(*uint8)(unsafe.Pointer(new1 + 8 + uintptr(len1+uint64(1)))) = uint8(0)
	}
	*(*uintptr)(unsafe.Pointer(tail)) = new1
	return 0
}

func _do_glob(tls *TLS, buf uintptr, pos Tsize_t, type1 int32, pat uintptr, flags int32, errfunc uintptr, tail uintptr) (r1 int32) {
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var de, dir, p, p2, v11, v2, v7, v8 uintptr
	var fnm_flags, in_bracket, old_errno, overflow, r, readerr, v10, v9 int32
	var i, j, v4, v5 Tptrdiff_t
	var l, v1 Tsize_t
	var saved_sep uint8
	var _ /* st at bp+0 */ Tstat
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = de, dir, fnm_flags, i, in_bracket, j, l, old_errno, overflow, p, p2, r, readerr, saved_sep, v1, v10, v11, v2, v4, v5, v7, v8, v9
	/* If GLOB_MARK is unused, we don't care about type. */
	if !(type1 != 0) && !(flags&Int32FromInt32(GLOB_MARK) != 0) {
		type1 = int32(DT_REG)
	}
	/* Special-case the remaining pattern being all slashes, in
	 * which case we can use caller-passed type if it's a dir. */
	if *(*uint8)(unsafe.Pointer(pat)) != 0 && type1 != int32(DT_DIR) {
		type1 = 0
	}
	for pos+uint64(1) < uint64(PATH_MAX) && int32(*(*uint8)(unsafe.Pointer(pat))) == int32('/') {
		v1 = pos
		pos++
		v2 = pat
		pat++
		*(*uint8)(unsafe.Pointer(buf + uintptr(v1))) = *(*uint8)(unsafe.Pointer(v2))
	}
	/* Consume maximal [escaped-]literal prefix of pattern, copying
	 * and un-escaping it to the running buffer as we go. */
	i = 0
	j = 0
	in_bracket = 0
	overflow = 0
	for {
		if !(int32(*(*uint8)(unsafe.Pointer(pat + uintptr(i)))) != int32('*') && int32(*(*uint8)(unsafe.Pointer(pat + uintptr(i)))) != int32('?') && (!(in_bracket != 0) || int32(*(*uint8)(unsafe.Pointer(pat + uintptr(i)))) != int32(']'))) {
			break
		}
		if !(*(*uint8)(unsafe.Pointer(pat + uintptr(i))) != 0) {
			if overflow != 0 {
				return 0
			}
			pat += uintptr(i)
			pos += uint64(j)
			v4 = Int64FromInt32(0)
			j = v4
			i = v4
			break
		} else {
			if int32(*(*uint8)(unsafe.Pointer(pat + uintptr(i)))) == int32('[') {
				in_bracket = int32(1)
			} else {
				if int32(*(*uint8)(unsafe.Pointer(pat + uintptr(i)))) == int32('\\') && !(flags&Int32FromInt32(GLOB_NOESCAPE) != 0) {
					/* Backslashes inside a bracket are (at least by
					 * our interpretation) non-special, so if next
					 * char is ']' we have a complete expression. */
					if in_bracket != 0 && int32(*(*uint8)(unsafe.Pointer(pat + uintptr(i+int64(1))))) == int32(']') {
						break
					}
					/* Unpaired final backslash never matches. */
					if !(*(*uint8)(unsafe.Pointer(pat + uintptr(i+int64(1)))) != 0) {
						return 0
					}
					i++
				}
			}
		}
		if int32(*(*uint8)(unsafe.Pointer(pat + uintptr(i)))) == int32('/') {
			if overflow != 0 {
				return 0
			}
			in_bracket = 0
			pat += uintptr(i + int64(1))
			i = int64(-int32(1))
			pos += uint64(j + int64(1))
			j = int64(-int32(1))
		}
		/* Only store a character if it fits in the buffer, but if
		 * a potential bracket expression is open, the overflow
		 * must be remembered and handled later only if the bracket
		 * is unterminated (and thereby a literal), so as not to
		 * disallow long bracket expressions with short matches. */
		if pos+uint64(j+Int64FromInt32(1)) < uint64(PATH_MAX) {
			v5 = j
			j++
			*(*uint8)(unsafe.Pointer(buf + uintptr(pos+uint64(v5)))) = *(*uint8)(unsafe.Pointer(pat + uintptr(i)))
		} else {
			if in_bracket != 0 {
				overflow = int32(1)
			} else {
				return 0
			}
		}
		/* If we consume any new components, the caller-passed type
		 * or dummy type from above is no longer valid. */
		type1 = 0
		goto _3
	_3:
		;
		i++
	}
	*(*uint8)(unsafe.Pointer(buf + uintptr(pos))) = uint8(0)
	if !(*(*uint8)(unsafe.Pointer(pat)) != 0) {
		if flags&int32(GLOB_MARK) != 0 && (!(type1 != 0) || type1 == int32(DT_LNK)) && !(Xstat(tls, buf, bp) != 0) {
			if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(S_IFMT) == uint32(S_IFDIR) {
				type1 = int32(DT_DIR)
			} else {
				type1 = int32(DT_REG)
			}
		}
		if !(type1 != 0) && Xlstat(tls, buf, bp) != 0 {
			if *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(ENOENT) && ((*(*func(*TLS, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{errfunc})))(tls, buf, *(*int32)(unsafe.Pointer(X__errno_location(tls)))) != 0 || flags&int32(GLOB_ERR) != 0) {
				return int32(GLOB_ABORTED)
			}
			return 0
		}
		if _append(tls, tail, buf, pos, BoolInt32(flags&int32(GLOB_MARK) != 0 && type1 == int32(DT_DIR))) != 0 {
			return int32(GLOB_NOSPACE)
		}
		return 0
	}
	p2 = Xstrchr(tls, pat, int32('/'))
	saved_sep = uint8('/')
	/* Check if the '/' was escaped and, if so, remove the escape char
	 * so that it will not be unpaired when passed to fnmatch. */
	if p2 != 0 && !(flags&Int32FromInt32(GLOB_NOESCAPE) != 0) {
		p = p2
		for {
			if !(p > pat && int32(*(*uint8)(unsafe.Pointer(p + uintptr(-Int32FromInt32(1))))) == int32('\\')) {
				break
			}
			goto _6
		_6:
			;
			p--
		}
		if (int64(p2)-int64(p))%int64(2) != 0 {
			p2--
			saved_sep = uint8('\\')
		}
	}
	if pos != 0 {
		v7 = buf
	} else {
		v7 = __ccgo_ts + 558
	}
	dir = Xopendir(tls, v7)
	if !(dir != 0) {
		if (*(*func(*TLS, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{errfunc})))(tls, buf, *(*int32)(unsafe.Pointer(X__errno_location(tls)))) != 0 || flags&int32(GLOB_ERR) != 0 {
			return int32(GLOB_ABORTED)
		}
		return 0
	}
	old_errno = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	for {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = 0
		v8 = Xreaddir(tls, dir)
		de = v8
		if !(v8 != 0) {
			break
		}
		/* Quickly skip non-directories when there's pattern left. */
		if p2 != 0 && (*Tdirent)(unsafe.Pointer(de)).Fd_type != 0 && int32((*Tdirent)(unsafe.Pointer(de)).Fd_type) != int32(DT_DIR) && int32((*Tdirent)(unsafe.Pointer(de)).Fd_type) != int32(DT_LNK) {
			continue
		}
		l = Xstrlen(tls, de+19)
		if l >= uint64(PATH_MAX)-pos {
			continue
		}
		if p2 != 0 {
			*(*uint8)(unsafe.Pointer(p2)) = uint8(0)
		}
		if flags&int32(GLOB_NOESCAPE) != 0 {
			v9 = int32(FNM_NOESCAPE)
		} else {
			v9 = 0
		}
		if !(flags&Int32FromInt32(GLOB_PERIOD) != 0) {
			v10 = int32(FNM_PERIOD)
		} else {
			v10 = 0
		}
		fnm_flags = v9 | v10
		if Xfnmatch(tls, pat, de+19, fnm_flags) != 0 {
			continue
		}
		/* With GLOB_PERIOD, don't allow matching . or .. unless
		 * fnmatch would match them with FNM_PERIOD rules in effect. */
		if p2 != 0 && flags&int32(GLOB_PERIOD) != 0 && int32(*(*uint8)(unsafe.Pointer(de + 19))) == int32('.') && (!(*(*uint8)(unsafe.Pointer(de + 19 + 1)) != 0) || int32(*(*uint8)(unsafe.Pointer(de + 19 + 1))) == int32('.') && !(*(*uint8)(unsafe.Pointer(de + 19 + 2)) != 0)) && Xfnmatch(tls, pat, de+19, fnm_flags|int32(FNM_PERIOD)) != 0 {
			continue
		}
		Xmemcpy(tls, buf+uintptr(pos), de+19, l+uint64(1))
		if p2 != 0 {
			*(*uint8)(unsafe.Pointer(p2)) = saved_sep
		}
		if p2 != 0 {
			v11 = p2
		} else {
			v11 = __ccgo_ts
		}
		r = _do_glob(tls, buf, pos+l, int32((*Tdirent)(unsafe.Pointer(de)).Fd_type), v11, flags, errfunc, tail)
		if r != 0 {
			Xclosedir(tls, dir)
			return r
		}
	}
	readerr = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	if p2 != 0 {
		*(*uint8)(unsafe.Pointer(p2)) = saved_sep
	}
	Xclosedir(tls, dir)
	if readerr != 0 && ((*(*func(*TLS, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{errfunc})))(tls, buf, *(*int32)(unsafe.Pointer(X__errno_location(tls)))) != 0 || flags&int32(GLOB_ERR) != 0) {
		return int32(GLOB_ABORTED)
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = old_errno
	return 0
}

func _ignore_err(tls *TLS, path uintptr, err int32) (r int32) {
	return 0
}

func _freelist(tls *TLS, head uintptr) {
	var match, next uintptr
	_, _ = match, next
	match = (*Tmatch)(unsafe.Pointer(head)).Fnext
	for {
		if !(match != 0) {
			break
		}
		next = (*Tmatch)(unsafe.Pointer(match)).Fnext
		Xfree(tls, match)
		goto _1
	_1:
		;
		match = next
	}
}

func _sort(tls *TLS, a uintptr, b uintptr) (r int32) {
	return Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(a)), *(*uintptr)(unsafe.Pointer(b)))
}

func _expand_tilde(tls *TLS, pat uintptr, buf uintptr, pos uintptr) (r int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var delim, v1, v12 uint8
	var home, name_end, p, v11, v2, v3 uintptr
	var i, v10, v13 Tsize_t
	var v4 int32
	var _ /* pw at bp+0 */ Tpasswd
	var _ /* res at bp+48 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _ = delim, home, i, name_end, p, v1, v10, v11, v12, v13, v2, v3, v4
	p = *(*uintptr)(unsafe.Pointer(pat)) + uintptr(1)
	i = uint64(0)
	name_end = X__strchrnul(tls, p, int32('/'))
	v1 = *(*uint8)(unsafe.Pointer(name_end))
	delim = v1
	if v1 != 0 {
		v2 = name_end
		name_end++
		*(*uint8)(unsafe.Pointer(v2)) = uint8(0)
	}
	*(*uintptr)(unsafe.Pointer(pat)) = name_end
	if *(*uint8)(unsafe.Pointer(p)) != 0 {
		v3 = UintptrFromInt32(0)
	} else {
		v3 = Xgetenv(tls, __ccgo_ts+1395)
	}
	home = v3
	if !(home != 0) {
		if *(*uint8)(unsafe.Pointer(p)) != 0 {
			v4 = Xgetpwnam_r(tls, p, bp, buf, uint64(PATH_MAX), bp+48)
		} else {
			v4 = Xgetpwuid_r(tls, Xgetuid(tls), bp, buf, uint64(PATH_MAX), bp+48)
		}
		switch v4 {
		case int32(ENOMEM):
			goto _5
		default:
			goto _6
		case 0:
			goto _7
		}
		goto _8
	_5:
		;
		return int32(GLOB_NOSPACE)
	_7:
		;
		if !!(*(*uintptr)(unsafe.Pointer(bp + 48)) != 0) {
			goto _9
		}
	_6:
		;
		return int32(GLOB_NOMATCH)
	_9:
		;
	_8:
		;
		home = (*(*Tpasswd)(unsafe.Pointer(bp))).Fpw_dir
	}
	for i < uint64(Int32FromInt32(PATH_MAX)-Int32FromInt32(2)) && *(*uint8)(unsafe.Pointer(home)) != 0 {
		v10 = i
		i++
		v11 = home
		home++
		*(*uint8)(unsafe.Pointer(buf + uintptr(v10))) = *(*uint8)(unsafe.Pointer(v11))
	}
	if *(*uint8)(unsafe.Pointer(home)) != 0 {
		return int32(GLOB_NOMATCH)
	}
	v12 = delim
	*(*uint8)(unsafe.Pointer(buf + uintptr(i))) = v12
	if v12 != 0 {
		i++
		v13 = i
		*(*uint8)(unsafe.Pointer(buf + uintptr(v13))) = uint8(0)
	}
	*(*Tsize_t)(unsafe.Pointer(pos)) = i
	return 0
}

func Xglob(tls *TLS, pat uintptr, flags int32, errfunc uintptr, g uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v pat=%v flags=%v errfunc=%v g=%v, (%v:)", tls, pat, flags, errfunc, g, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(4128)
	defer tls.Free(4128)
	var cnt, i, offs Tsize_t
	var error1 int32
	var p, pathv uintptr
	var v1 uint64
	var _ /* buf at bp+16 */ [4096]uint8
	var _ /* head at bp+0 */ Tmatch
	var _ /* pos at bp+4112 */ Tsize_t
	var _ /* s at bp+4120 */ uintptr
	var _ /* tail at bp+8 */ uintptr
	_, _, _, _, _, _, _ = cnt, error1, i, offs, p, pathv, v1
	*(*Tmatch)(unsafe.Pointer(bp)) = struct {
		Fnext uintptr
	}{}
	*(*uintptr)(unsafe.Pointer(bp + 8)) = bp
	if flags&int32(GLOB_DOOFFS) != 0 {
		v1 = (*Tglob_t)(unsafe.Pointer(g)).Fgl_offs
	} else {
		v1 = uint64(0)
	}
	offs = v1
	error1 = 0
	if !(errfunc != 0) {
		errfunc = __ccgo_fp(_ignore_err)
	}
	if !(flags&Int32FromInt32(GLOB_APPEND) != 0) {
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_offs = offs
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc = uint64(0)
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv = UintptrFromInt32(0)
	}
	if *(*uint8)(unsafe.Pointer(pat)) != 0 {
		p = Xstrdup(tls, pat)
		if !(p != 0) {
			return int32(GLOB_NOSPACE)
		}
		(*(*[4096]uint8)(unsafe.Pointer(bp + 16)))[0] = uint8(0)
		*(*Tsize_t)(unsafe.Pointer(bp + 4112)) = uint64(0)
		*(*uintptr)(unsafe.Pointer(bp + 4120)) = p
		if flags&(Int32FromInt32(GLOB_TILDE)|Int32FromInt32(GLOB_TILDE_CHECK)) != 0 && int32(*(*uint8)(unsafe.Pointer(p))) == int32('~') {
			error1 = _expand_tilde(tls, bp+4120, bp+16, bp+4112)
		}
		if !(error1 != 0) {
			error1 = _do_glob(tls, bp+16, *(*Tsize_t)(unsafe.Pointer(bp + 4112)), 0, *(*uintptr)(unsafe.Pointer(bp + 4120)), flags, errfunc, bp+8)
		}
		Xfree(tls, p)
	}
	if error1 == int32(GLOB_NOSPACE) {
		_freelist(tls, bp)
		return error1
	}
	cnt = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = (*(*Tmatch)(unsafe.Pointer(bp))).Fnext
	for {
		if !(*(*uintptr)(unsafe.Pointer(bp + 8)) != 0) {
			break
		}
		goto _2
	_2:
		;
		*(*uintptr)(unsafe.Pointer(bp + 8)) = (*Tmatch)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fnext
		cnt++
	}
	if !(cnt != 0) {
		if flags&int32(GLOB_NOCHECK) != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 8)) = bp
			if _append(tls, bp+8, pat, Xstrlen(tls, pat), 0) != 0 {
				return int32(GLOB_NOSPACE)
			}
			cnt++
		} else {
			if !(error1 != 0) {
				return int32(GLOB_NOMATCH)
			}
		}
	}
	if flags&int32(GLOB_APPEND) != 0 {
		pathv = Xrealloc(tls, (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv, (offs+(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc+cnt+uint64(1))*uint64(8))
		if !(pathv != 0) {
			_freelist(tls, bp)
			return int32(GLOB_NOSPACE)
		}
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv = pathv
		offs += (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc
	} else {
		(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv = Xmalloc(tls, (offs+cnt+uint64(1))*uint64(8))
		if !((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv != 0) {
			_freelist(tls, bp)
			return int32(GLOB_NOSPACE)
		}
		i = uint64(0)
		for {
			if !(i < offs) {
				break
			}
			*(*uintptr)(unsafe.Pointer((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv + uintptr(i)*8)) = UintptrFromInt32(0)
			goto _3
		_3:
			;
			i++
		}
	}
	i = uint64(0)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = (*(*Tmatch)(unsafe.Pointer(bp))).Fnext
	for {
		if !(i < cnt) {
			break
		}
		*(*uintptr)(unsafe.Pointer((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv + uintptr(offs+i)*8)) = *(*uintptr)(unsafe.Pointer(bp + 8)) + 8
		goto _4
	_4:
		;
		*(*uintptr)(unsafe.Pointer(bp + 8)) = (*Tmatch)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))).Fnext
		i++
	}
	*(*uintptr)(unsafe.Pointer((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv + uintptr(offs+i)*8)) = UintptrFromInt32(0)
	*(*Tsize_t)(unsafe.Pointer(g)) += cnt
	if !(flags&Int32FromInt32(GLOB_NOSORT) != 0) {
		Xqsort(tls, (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv+uintptr(offs)*8, cnt, uint64(8), __ccgo_fp(_sort))
	}
	return error1
}

func Xglobfree(tls *TLS, g uintptr) {
	if __ccgo_strace {
		trc("tls=%v g=%v, (%v:)", tls, g, origin(2))
	}
	var i Tsize_t
	_ = i
	i = uint64(0)
	for {
		if !(i < (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc) {
			break
		}
		Xfree(tls, *(*uintptr)(unsafe.Pointer((*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv + uintptr((*Tglob_t)(unsafe.Pointer(g)).Fgl_offs+i)*8))-uintptr(uint64(UintptrFromInt32(0)+8)))
		goto _1
	_1:
		;
		i++
	}
	Xfree(tls, (*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv)
	(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathc = uint64(0)
	(*Tglob_t)(unsafe.Pointer(g)).Fgl_pathv = UintptrFromInt32(0)
}

const ASSERTION = -2
const ASSERT_AT_BOL = 1
const ASSERT_AT_BOW = 16
const ASSERT_AT_EOL = 2
const ASSERT_AT_EOW = 32
const ASSERT_AT_WB = 64
const ASSERT_AT_WB_NEG = 128
const ASSERT_BACKREF = 256
const ASSERT_CHAR_CLASS = 4
const ASSERT_CHAR_CLASS_NEG = 8
const ASSERT_LAST = 256
const BACKREF = -4
const COPY_MAXIMIZE_FIRST_TAG = 2
const COPY_REMOVE_TAGS = 1
const EMPTY1 = -1
const MAX_NEG_CLASSES = 64
const REG_BADBR = 10
const REG_BADPAT = 2
const REG_BADRPT = 13
const REG_EBRACE = 9
const REG_EBRACK = 7
const REG_ECOLLATE = 3
const REG_ECTYPE = 4
const REG_EESCAPE = 5
const REG_ENOSYS = -1
const REG_EPAREN = 8
const REG_ERANGE = 11
const REG_ESPACE = 12
const REG_ESUBREG = 6
const REG_EXTENDED = 1
const REG_ICASE = 2
const REG_NEWLINE = 4
const REG_NOMATCH = 1
const REG_NOSUB = 8
const REG_NOTBOL = 1
const REG_NOTEOL = 2
const REG_OK = 0
const TAG = -3
const TRE_CHAR_MAX = 1114111
const TRE_MEM_BLOCK_SIZE = 1024
const TRE_REGEX_T_FIELD = 0
const tre_ctype = 0
const tre_isalnum = 0
const tre_isalpha = 0
const tre_isblank = 0
const tre_iscntrl = 0
const tre_isctype = 0
const tre_isdigit = 0
const tre_isgraph = 0
const tre_islower = 0
const tre_isprint = 0
const tre_ispunct = 0
const tre_isspace = 0
const tre_isupper = 0
const tre_isxdigit = 0
const tre_mem_alloc_impl = 0
const tre_mem_destroy = 0
const tre_mem_new_impl = 0
const tre_strlen = 0
const tre_tolower = 0
const tre_toupper = 0
const xcalloc = 0
const xfree = 0
const xmalloc = 0
const xrealloc = 0

type Tregoff_t = int64

type Tregex_t = struct {
	Fre_nsub    Tsize_t
	F__opaque   uintptr
	F__padding  [4]uintptr
	F__nsub2    Tsize_t
	F__padding2 uint8
}

type Tre_pattern_buffer = Tregex_t

type Tregmatch_t = struct {
	Frm_so Tregoff_t
	Frm_eo Tregoff_t
}

type Treg_errcode_t = int32

type Ttre_char_t = uint32

type Ttre_cint_t = uint32

type Ttre_ctype_t = uint64

type Ttre_tnfa_transition_t = struct {
	Fcode_min   Ttre_cint_t
	Fcode_max   Ttre_cint_t
	Fstate      uintptr
	Fstate_id   int32
	Ftags       uintptr
	Fassertions int32
	Fu          struct {
		Fbackref [0]int32
		Fclass   Ttre_ctype_t
	}
	Fneg_classes uintptr
}

type Ttnfa_transition = Ttre_tnfa_transition_t

type Ttre_tag_direction_t = int32

const _TRE_TAG_MINIMIZE = 0
const _TRE_TAG_MAXIMIZE = 1

type Ttre_submatch_data = struct {
	Fso_tag  int32
	Feo_tag  int32
	Fparents uintptr
}

type Ttre_submatch_data_t = struct {
	Fso_tag  int32
	Feo_tag  int32
	Fparents uintptr
}

type Ttre_tnfa_t = struct {
	Ftransitions     uintptr
	Fnum_transitions uint32
	Finitial         uintptr
	Ffinal           uintptr
	Fsubmatch_data   uintptr
	Ffirstpos_chars  uintptr
	Ffirst_char      int32
	Fnum_submatches  uint32
	Ftag_directions  uintptr
	Fminimal_tags    uintptr
	Fnum_tags        int32
	Fnum_minimals    int32
	Fend_tag         int32
	Fnum_states      int32
	Fcflags          int32
	Fhave_backrefs   int32
	Fhave_approx     int32
}

type Ttnfa = Ttre_tnfa_t

type Ttre_list_t = struct {
	Fdata uintptr
	Fnext uintptr
}

type Ttre_list = Ttre_list_t

type Ttre_mem_t = uintptr

type Ttre_mem_struct = struct {
	Fblocks   uintptr
	Fcurrent  uintptr
	Fptr      uintptr
	Fn        Tsize_t
	Ffailed   int32
	Fprovided uintptr
}

/***********************************************************************
 from tre-compile.h
***********************************************************************/

type Ttre_pos_and_tags_t = struct {
	Fposition    int32
	Fcode_min    int32
	Fcode_max    int32
	Ftags        uintptr
	Fassertions  int32
	Fclass       Ttre_ctype_t
	Fneg_classes uintptr
	Fbackref     int32
}

/***********************************************************************
 from tre-ast.c and tre-ast.h
***********************************************************************/

// C documentation
//
//	/* The different AST node types. */
type Ttre_ast_type_t = int32

const _LITERAL = 0
const _CATENATION = 1
const _ITERATION = 2
const _UNION = 3

/* Special subtypes of TRE_LITERAL. */

// C documentation
//
//	/* A generic AST node.  All AST nodes consist of this node on the top
//	   level with `obj' pointing to the actual content. */
type Ttre_ast_node_t = struct {
	Ftype1          Ttre_ast_type_t
	Fobj            uintptr
	Fnullable       int32
	Fsubmatch_id    int32
	Fnum_submatches int32
	Fnum_tags       int32
	Ffirstpos       uintptr
	Flastpos        uintptr
}

// C documentation
//
//	/* A "literal" node.  These are created for assertions, back references,
//	   tags, matching parameter settings, and all expressions that match one
//	   character. */
type Ttre_literal_t = struct {
	Fcode_min    int64
	Fcode_max    int64
	Fposition    int32
	Fclass       Ttre_ctype_t
	Fneg_classes uintptr
}

// C documentation
//
//	/* A "catenation" node.	 These are created when two regexps are concatenated.
//	   If there are more than one subexpressions in sequence, the `left' part
//	   holds all but the last, and `right' part holds the last subexpression
//	   (catenation is left associative). */
type Ttre_catenation_t = struct {
	Fleft  uintptr
	Fright uintptr
}

// C documentation
//
//	/* An "iteration" node.	 These are created for the "*", "+", "?", and "{m,n}"
//	   operators. */
type Ttre_iteration_t = struct {
	Farg      uintptr
	Fmin      int32
	Fmax      int32
	F__ccgo16 uint8
}

// C documentation
//
//	/* An "union" node.  These are created for the "|" operator. */
type Ttre_union_t = struct {
	Fleft  uintptr
	Fright uintptr
}

func _tre_ast_new_node(tls *TLS, mem Ttre_mem_t, type1 int32, obj uintptr) (r uintptr) {
	var node uintptr
	_ = node
	node = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(48))
	if !(node != 0) || !(obj != 0) {
		return uintptr(0)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = obj
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = type1
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id = -int32(1)
	return node
}

func _tre_ast_new_literal(tls *TLS, mem Ttre_mem_t, code_min int32, code_max int32, position int32) (r uintptr) {
	var lit, node uintptr
	_, _ = lit, node
	lit = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(40))
	node = _tre_ast_new_node(tls, mem, int32(_LITERAL), lit)
	if !(node != 0) {
		return uintptr(0)
	}
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(code_min)
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(code_max)
	(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = position
	return node
}

func _tre_ast_new_iter(tls *TLS, mem Ttre_mem_t, arg uintptr, min int32, max int32, minimal int32) (r uintptr) {
	var iter, node uintptr
	_, _ = iter, node
	iter = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(24))
	node = _tre_ast_new_node(tls, mem, int32(_ITERATION), iter)
	if !(node != 0) {
		return uintptr(0)
	}
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg = arg
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin = min
	(*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax = max
	SetBitFieldPtr8Uint32(iter+16, uint32(minimal), 0, 0x1)
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(arg)).Fnum_submatches
	return node
}

func _tre_ast_new_union(tls *TLS, mem Ttre_mem_t, left uintptr, right uintptr) (r uintptr) {
	var node, un uintptr
	_, _ = node, un
	if !(left != 0) {
		return right
	}
	un = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(16))
	node = _tre_ast_new_node(tls, mem, int32(_UNION), un)
	if !(node != 0) || !(right != 0) {
		return uintptr(0)
	}
	(*Ttre_union_t)(unsafe.Pointer(un)).Fleft = left
	(*Ttre_union_t)(unsafe.Pointer(un)).Fright = right
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_submatches + (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_submatches
	return node
}

func _tre_ast_new_catenation(tls *TLS, mem Ttre_mem_t, left uintptr, right uintptr) (r uintptr) {
	var cat, node uintptr
	_, _ = cat, node
	if !(left != 0) {
		return right
	}
	cat = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(16))
	node = _tre_ast_new_node(tls, mem, int32(_CATENATION), cat)
	if !(node != 0) {
		return uintptr(0)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft = left
	(*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright = right
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_submatches + (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_submatches
	return node
}

/***********************************************************************
 from tre-stack.c and tre-stack.h
***********************************************************************/

type Ttre_stack_t = struct {
	Fsize      int32
	Fmax_size  int32
	Fincrement int32
	Fptr       int32
	Fstack     uintptr
}

/***********************************************************************
 from tre-stack.c and tre-stack.h
***********************************************************************/

type Ttre_stack_rec = Ttre_stack_t

/* Just to save some typing. */

type Ttre_stack_item = struct {
	Fint_value     [0]int32
	Fvoidptr_value uintptr
}

func _tre_stack_new(tls *TLS, size int32, max_size int32, increment int32) (r uintptr) {
	var s uintptr
	_ = s
	s = Xmalloc(tls, uint64(24))
	if s != UintptrFromInt32(0) {
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fstack = Xmalloc(tls, uint64(8)*uint64(size))
		if (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack == UintptrFromInt32(0) {
			Xfree(tls, s)
			return UintptrFromInt32(0)
		}
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fsize = size
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size = max_size
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fincrement = increment
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fptr = 0
	}
	return s
}

func _tre_stack_destroy(tls *TLS, s uintptr) {
	Xfree(tls, (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack)
	Xfree(tls, s)
}

func _tre_stack_num_objects(tls *TLS, s uintptr) (r int32) {
	return (*Ttre_stack_t)(unsafe.Pointer(s)).Fptr
}

func _tre_stack_push(tls *TLS, s uintptr, value Ttre_stack_item) (r Treg_errcode_t) {
	var new_buffer uintptr
	var new_size int32
	_, _ = new_buffer, new_size
	if (*Ttre_stack_t)(unsafe.Pointer(s)).Fptr < (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize {
		*(*Ttre_stack_item)(unsafe.Pointer((*Ttre_stack_t)(unsafe.Pointer(s)).Fstack + uintptr((*Ttre_stack_t)(unsafe.Pointer(s)).Fptr)*8)) = value
		(*Ttre_stack_t)(unsafe.Pointer(s)).Fptr++
	} else {
		if (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize >= (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size {
			return int32(REG_ESPACE)
		} else {
			new_size = (*Ttre_stack_t)(unsafe.Pointer(s)).Fsize + (*Ttre_stack_t)(unsafe.Pointer(s)).Fincrement
			if new_size > (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size {
				new_size = (*Ttre_stack_t)(unsafe.Pointer(s)).Fmax_size
			}
			new_buffer = Xrealloc(tls, (*Ttre_stack_t)(unsafe.Pointer(s)).Fstack, uint64(8)*uint64(new_size))
			if new_buffer == UintptrFromInt32(0) {
				return int32(REG_ESPACE)
			}
			(*Ttre_stack_t)(unsafe.Pointer(s)).Fsize = new_size
			(*Ttre_stack_t)(unsafe.Pointer(s)).Fstack = new_buffer
			_tre_stack_push(tls, s, value)
		}
	}
	return REG_OK
}

func _tre_stack_push_int(tls *TLS, s uintptr, value int32) (r Treg_errcode_t) {
	var item Ttre_stack_item
	_ = item
	*(*int32)(unsafe.Pointer(&item)) = value
	return _tre_stack_push(tls, s, item)
}

func _tre_stack_push_voidptr(tls *TLS, s uintptr, value uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* item at bp+0 */ Ttre_stack_item
	*(*uintptr)(unsafe.Pointer(bp)) = value
	return _tre_stack_push(tls, s, *(*Ttre_stack_item)(unsafe.Pointer(bp)))
}

func _tre_stack_pop_int(tls *TLS, s uintptr) (r int32) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	v2 = s + 12
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	return *(*int32)(unsafe.Pointer(&*(*Ttre_stack_item)(unsafe.Pointer((*Ttre_stack_t)(unsafe.Pointer(s)).Fstack + uintptr(v1)*8))))
}

func _tre_stack_pop_voidptr(tls *TLS, s uintptr) (r uintptr) {
	var v1 int32
	var v2 uintptr
	_, _ = v1, v2
	v2 = s + 12
	*(*int32)(unsafe.Pointer(v2))--
	v1 = *(*int32)(unsafe.Pointer(v2))
	return *(*uintptr)(unsafe.Pointer((*Ttre_stack_t)(unsafe.Pointer(s)).Fstack + uintptr(v1)*8))
}

/***********************************************************************
 from tre-parse.c and tre-parse.h
***********************************************************************/

// C documentation
//
//	/* Parse context. */
type Ttre_parse_ctx_t = struct {
	Fmem         Ttre_mem_t
	Fstack       uintptr
	Fn           uintptr
	Fs           uintptr
	Fstart       uintptr
	Fsubmatch_id int32
	Fposition    int32
	Fmax_backref int32
	Fcflags      int32
}

// C documentation
//
//	/* Some macros for expanding \w, \s, etc. */
var _tre_macros = [13]struct {
	Fc         uint8
	Fexpansion uintptr
}{
	0: {
		Fc:         uint8('t'),
		Fexpansion: __ccgo_ts + 1400,
	},
	1: {
		Fc:         uint8('n'),
		Fexpansion: __ccgo_ts + 301,
	},
	2: {
		Fc:         uint8('r'),
		Fexpansion: __ccgo_ts + 1402,
	},
	3: {
		Fc:         uint8('f'),
		Fexpansion: __ccgo_ts + 1404,
	},
	4: {
		Fc:         uint8('a'),
		Fexpansion: __ccgo_ts + 1406,
	},
	5: {
		Fc:         uint8('e'),
		Fexpansion: __ccgo_ts + 1408,
	},
	6: {
		Fc:         uint8('w'),
		Fexpansion: __ccgo_ts + 1410,
	},
	7: {
		Fc:         uint8('W'),
		Fexpansion: __ccgo_ts + 1423,
	},
	8: {
		Fc:         uint8('s'),
		Fexpansion: __ccgo_ts + 1437,
	},
	9: {
		Fc:         uint8('S'),
		Fexpansion: __ccgo_ts + 1449,
	},
	10: {
		Fc:         uint8('d'),
		Fexpansion: __ccgo_ts + 1462,
	},
	11: {
		Fc:         uint8('D'),
		Fexpansion: __ccgo_ts + 1474,
	},
	12: {},
}

// C documentation
//
//	/* Expands a macro delimited by `regex' and `regex_end' to `buf', which
//	   must have at least `len' items.  Sets buf[0] to zero if the there
//	   is no match in `tre_macros'. */
func _tre_expand_macro(tls *TLS, s uintptr) (r uintptr) {
	var i int32
	_ = i
	i = 0
	for {
		if !(_tre_macros[i].Fc != 0 && int32(_tre_macros[i].Fc) != int32(*(*uint8)(unsafe.Pointer(s)))) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	return _tre_macros[i].Fexpansion
}

func _tre_compare_lit(tls *TLS, a uintptr, b uintptr) (r int32) {
	var la, lb uintptr
	_, _ = la, lb
	la = a
	lb = b
	/* assumes the range of valid code_min is < INT_MAX */
	return int32((*Ttre_literal_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(la)))).Fcode_min - (*Ttre_literal_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(lb)))).Fcode_min)
}

type Tliterals = struct {
	Fmem  Ttre_mem_t
	Fa    uintptr
	Flen1 int32
	Fcap1 int32
}

func _tre_new_lit(tls *TLS, p uintptr) (r uintptr) {
	var a, v2 uintptr
	var v1 int32
	_, _, _ = a, v1, v2
	if (*Tliterals)(unsafe.Pointer(p)).Flen1 >= (*Tliterals)(unsafe.Pointer(p)).Fcap1 {
		if (*Tliterals)(unsafe.Pointer(p)).Fcap1 >= Int32FromInt32(1)<<Int32FromInt32(15) {
			return uintptr(0)
		}
		*(*int32)(unsafe.Pointer(p + 20)) *= int32(2)
		a = Xrealloc(tls, (*Tliterals)(unsafe.Pointer(p)).Fa, uint64((*Tliterals)(unsafe.Pointer(p)).Fcap1)*uint64(8))
		if !(a != 0) {
			return uintptr(0)
		}
		(*Tliterals)(unsafe.Pointer(p)).Fa = a
	}
	v2 = p + 16
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	a = (*Tliterals)(unsafe.Pointer(p)).Fa + uintptr(v1)*8
	*(*uintptr)(unsafe.Pointer(a)) = X__tre_mem_alloc_impl(tls, (*Tliterals)(unsafe.Pointer(p)).Fmem, 0, UintptrFromInt32(0), int32(1), uint64(40))
	return *(*uintptr)(unsafe.Pointer(a))
}

func _add_icase_literals(tls *TLS, ls uintptr, min int32, max int32) (r int32) {
	var b, c, e, v2, v4 int32
	var lit uintptr
	_, _, _, _, _, _ = b, c, e, lit, v2, v4
	c = min
	for {
		if !(c <= max) {
			break
		}
		/* assumes islower(c) and isupper(c) are exclusive
		   and toupper(c)!=c if islower(c).
		   multiple opposite case characters are not supported */
		if Xiswlower(tls, uint32(c)) != 0 {
			v2 = int32(Xtowupper(tls, uint32(c)))
			e = v2
			b = v2
			c++
			e++
			for {
				if !(c <= max) {
					break
				}
				if Xtowupper(tls, uint32(c)) != uint32(e) {
					break
				}
				goto _3
			_3:
				;
				c++
				e++
			}
		} else {
			if Xiswupper(tls, uint32(c)) != 0 {
				v4 = int32(Xtowlower(tls, uint32(c)))
				e = v4
				b = v4
				c++
				e++
				for {
					if !(c <= max) {
						break
					}
					if Xtowlower(tls, uint32(c)) != uint32(e) {
						break
					}
					goto _5
				_5:
					;
					c++
					e++
				}
			} else {
				c++
				goto _1
			}
		}
		lit = _tre_new_lit(tls, ls)
		if !(lit != 0) {
			return -int32(1)
		}
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(b)
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(e - int32(1))
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = -int32(1)
		goto _1
	_1:
	}
	return 0
}

/* Maximum number of character classes in a negated bracket expression. */

type Tneg = struct {
	Fnegate int32
	Flen1   int32
	Fa      [64]Ttre_ctype_t
}

// TODO: parse bracket into a set of non-overlapping [lo,hi] ranges

/*
bracket grammar:
Bracket  =  '[' List ']'  |  '[^' List ']'
List     =  Term  |  List Term
Term     =  Char  |  Range  |  Chclass  |  Eqclass
Range    =  Char '-' Char  |  Char '-' '-'
Char     =  Coll  |  coll_single
Meta     =  ']'  |  '-'
Coll     =  '[.' coll_single '.]'  |  '[.' coll_multi '.]'  |  '[.' Meta '.]'
Eqclass  =  '[=' coll_single '=]'  |  '[=' coll_multi '=]'
Chclass  =  '[:' class ':]'

coll_single is a single char collating element but it can be
 '-' only at the beginning or end of a List and
 ']' only at the beginning of a List and
 '^' anywhere except after the openning '['
*/

func _parse_bracket_terms(tls *TLS, ctx uintptr, s uintptr, ls uintptr, neg uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var class Ttre_ctype_t
	var len1, max, min, v2, v4, v5 int32
	var lit, start, v6 uintptr
	var _ /* tmp at bp+4 */ [15]uint8
	var _ /* wc at bp+0 */ Twchar_t
	_, _, _, _, _, _, _, _, _, _ = class, len1, lit, max, min, start, v2, v4, v5, v6
	start = s
	for {
		class = uint64(0)
		len1 = Xmbtowc(tls, bp, s, uint64(-Int32FromInt32(1)))
		if len1 <= 0 {
			if *(*uint8)(unsafe.Pointer(s)) != 0 {
				v2 = int32(REG_BADPAT)
			} else {
				v2 = int32(REG_EBRACK)
			}
			return v2
		}
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32(']') && s != start {
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fs = s + uintptr(1)
			return REG_OK
		}
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32('-') && s != start && int32(*(*uint8)(unsafe.Pointer(s + 1))) != int32(']') && (int32(*(*uint8)(unsafe.Pointer(s + 1))) != int32('-') || int32(*(*uint8)(unsafe.Pointer(s + 2))) == int32(']')) {
			return int32(REG_ERANGE)
		}
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32('[') && (int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32('.') || int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32('=')) {
			/* collating symbols and equivalence classes are not supported */
			return int32(REG_ECOLLATE)
		}
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32('[') && int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32(':') {
			s += uintptr(2)
			len1 = 0
			for {
				if !(len1 < int32(CHARCLASS_NAME_MAX) && *(*uint8)(unsafe.Pointer(s + uintptr(len1))) != 0) {
					break
				}
				if int32(*(*uint8)(unsafe.Pointer(s + uintptr(len1)))) == int32(':') {
					Xmemcpy(tls, bp+4, s, uint64(len1))
					(*(*[15]uint8)(unsafe.Pointer(bp + 4)))[len1] = uint8(0)
					class = Xwctype(tls, bp+4)
					break
				}
				goto _3
			_3:
				;
				len1++
			}
			if !(class != 0) || int32(*(*uint8)(unsafe.Pointer(s + uintptr(len1+int32(1))))) != int32(']') {
				return int32(REG_ECTYPE)
			}
			min = 0
			max = int32(TRE_CHAR_MAX)
			s += uintptr(len1 + int32(2))
		} else {
			v4 = int32(*(*Twchar_t)(unsafe.Pointer(bp)))
			max = v4
			min = v4
			s += uintptr(len1)
			if int32(*(*uint8)(unsafe.Pointer(s))) == int32('-') && int32(*(*uint8)(unsafe.Pointer(s + 1))) != int32(']') {
				s++
				len1 = Xmbtowc(tls, bp, s, uint64(-Int32FromInt32(1)))
				max = int32(*(*Twchar_t)(unsafe.Pointer(bp)))
				/* XXX - Should use collation order instead of
				   encoding values in character ranges. */
				if len1 <= 0 || min > max {
					return int32(REG_ERANGE)
				}
				s += uintptr(len1)
			}
		}
		if class != 0 && (*Tneg)(unsafe.Pointer(neg)).Fnegate != 0 {
			if (*Tneg)(unsafe.Pointer(neg)).Flen1 >= int32(MAX_NEG_CLASSES) {
				return int32(REG_ESPACE)
			}
			v6 = neg + 4
			v5 = *(*int32)(unsafe.Pointer(v6))
			*(*int32)(unsafe.Pointer(v6))++
			*(*Ttre_ctype_t)(unsafe.Pointer(neg + 8 + uintptr(v5)*8)) = class
		} else {
			lit = _tre_new_lit(tls, ls)
			if !(lit != 0) {
				return int32(REG_ESPACE)
			}
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(min)
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(max)
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fclass = class
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = -int32(1)
			/* Add opposite-case codepoints if REG_ICASE is present.
			   It seems that POSIX requires that bracket negation
			   should happen before case-folding, but most practical
			   implementations do it the other way around. Changing
			   the order would need efficient representation of
			   case-fold ranges and bracket range sets even with
			   simple patterns so this is ok for now. */
			if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(REG_ICASE) != 0 && !(class != 0) {
				if _add_icase_literals(tls, ls, min, max) != 0 {
					return int32(REG_ESPACE)
				}
			}
		}
		goto _1
	_1:
	}
	return r
}

func _parse_bracket(tls *TLS, ctx uintptr, s uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(544)
	defer tls.Free(544)
	var err Treg_errcode_t
	var i, max, min, negmax, negmin, v1, v3 int32
	var lit, n, nc, node uintptr
	var _ /* ls at bp+0 */ Tliterals
	var _ /* neg at bp+24 */ Tneg
	_, _, _, _, _, _, _, _, _, _, _, _ = err, i, lit, max, min, n, nc, negmax, negmin, node, v1, v3
	node = uintptr(0)
	nc = uintptr(0)
	(*(*Tliterals)(unsafe.Pointer(bp))).Fmem = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem
	(*(*Tliterals)(unsafe.Pointer(bp))).Flen1 = 0
	(*(*Tliterals)(unsafe.Pointer(bp))).Fcap1 = int32(32)
	(*(*Tliterals)(unsafe.Pointer(bp))).Fa = Xmalloc(tls, uint64((*(*Tliterals)(unsafe.Pointer(bp))).Fcap1)*uint64(8))
	if !((*(*Tliterals)(unsafe.Pointer(bp))).Fa != 0) {
		return int32(REG_ESPACE)
	}
	(*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1 = 0
	(*(*Tneg)(unsafe.Pointer(bp + 24))).Fnegate = BoolInt32(int32(*(*uint8)(unsafe.Pointer(s))) == int32('^'))
	if (*(*Tneg)(unsafe.Pointer(bp + 24))).Fnegate != 0 {
		s++
	}
	err = _parse_bracket_terms(tls, ctx, s, bp, bp+24)
	if err != REG_OK {
		goto parse_bracket_done
	}
	if (*(*Tneg)(unsafe.Pointer(bp + 24))).Fnegate != 0 {
		/*
		 * With REG_NEWLINE, POSIX requires that newlines are not matched by
		 * any form of a non-matching list.
		 */
		if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(REG_NEWLINE) != 0 {
			lit = _tre_new_lit(tls, bp)
			if !(lit != 0) {
				err = int32(REG_ESPACE)
				goto parse_bracket_done
			}
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64('\n')
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64('\n')
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = -int32(1)
		}
		/* Sort the array if we need to negate it. */
		Xqsort(tls, (*(*Tliterals)(unsafe.Pointer(bp))).Fa, uint64((*(*Tliterals)(unsafe.Pointer(bp))).Flen1), uint64(8), __ccgo_fp(_tre_compare_lit))
		/* extra lit for the last negated range */
		lit = _tre_new_lit(tls, bp)
		if !(lit != 0) {
			err = int32(REG_ESPACE)
			goto parse_bracket_done
		}
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(Int32FromInt32(TRE_CHAR_MAX) + Int32FromInt32(1))
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(Int32FromInt32(TRE_CHAR_MAX) + Int32FromInt32(1))
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = -int32(1)
		/* negated classes */
		if (*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1 != 0 {
			nc = X__tre_mem_alloc_impl(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, 0, UintptrFromInt32(0), 0, uint64((*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1+Int32FromInt32(1))*uint64(8))
			if !(nc != 0) {
				err = int32(REG_ESPACE)
				goto parse_bracket_done
			}
			Xmemcpy(tls, nc, bp+24+8, uint64((*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1)*uint64(8))
			*(*Ttre_ctype_t)(unsafe.Pointer(nc + uintptr((*(*Tneg)(unsafe.Pointer(bp + 24))).Flen1)*8)) = uint64(0)
		}
	}
	/* Build a union of the items in the array, negated if necessary. */
	v1 = Int32FromInt32(0)
	negmin = v1
	negmax = v1
	i = 0
	for {
		if !(i < (*(*Tliterals)(unsafe.Pointer(bp))).Flen1) {
			break
		}
		lit = *(*uintptr)(unsafe.Pointer((*(*Tliterals)(unsafe.Pointer(bp))).Fa + uintptr(i)*8))
		min = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min)
		max = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
		if (*(*Tneg)(unsafe.Pointer(bp + 24))).Fnegate != 0 {
			if min <= negmin {
				/* Overlap. */
				if max+int32(1) >= negmin {
					v3 = max + int32(1)
				} else {
					v3 = negmin
				}
				negmin = v3
				goto _2
			}
			negmax = min - int32(1)
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min = int64(negmin)
			(*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max = int64(negmax)
			negmin = max + int32(1)
		}
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition
		(*Ttre_literal_t)(unsafe.Pointer(lit)).Fneg_classes = nc
		n = _tre_ast_new_node(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(_LITERAL), lit)
		node = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, node, n)
		if !(node != 0) {
			err = int32(REG_ESPACE)
			break
		}
		goto _2
	_2:
		;
		i++
	}
	goto parse_bracket_done
parse_bracket_done:
	;
	Xfree(tls, (*(*Tliterals)(unsafe.Pointer(bp))).Fa)
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = node
	return err
}

func _parse_dup_count(tls *TLS, s uintptr, n uintptr) (r uintptr) {
	*(*int32)(unsafe.Pointer(n)) = -int32(1)
	if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
		return s
	}
	*(*int32)(unsafe.Pointer(n)) = 0
	for {
		*(*int32)(unsafe.Pointer(n)) = int32(10)**(*int32)(unsafe.Pointer(n)) + (int32(*(*uint8)(unsafe.Pointer(s))) - int32('0'))
		s++
		if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) || *(*int32)(unsafe.Pointer(n)) > int32(RE_DUP_MAX) {
			break
		}
		goto _1
	_1:
	}
	return s
}

func _parse_dup(tls *TLS, s uintptr, ere int32, pmin uintptr, pmax uintptr) (r uintptr) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1, v4 uintptr
	var v2, v3, v5 bool
	var _ /* max at bp+4 */ int32
	var _ /* min at bp+0 */ int32
	_, _, _, _, _ = v1, v2, v3, v4, v5
	s = _parse_dup_count(tls, s, bp)
	if int32(*(*uint8)(unsafe.Pointer(s))) == int32(',') {
		s = _parse_dup_count(tls, s+uintptr(1), bp+4)
	} else {
		*(*int32)(unsafe.Pointer(bp + 4)) = *(*int32)(unsafe.Pointer(bp))
	}
	if v3 = *(*int32)(unsafe.Pointer(bp + 4)) < *(*int32)(unsafe.Pointer(bp)) && *(*int32)(unsafe.Pointer(bp + 4)) >= 0 || *(*int32)(unsafe.Pointer(bp + 4)) > int32(RE_DUP_MAX) || *(*int32)(unsafe.Pointer(bp)) > int32(RE_DUP_MAX) || *(*int32)(unsafe.Pointer(bp)) < 0; !v3 {
		if v2 = !(ere != 0); v2 {
			v1 = s
			s++
		}
	}
	if v5 = v3 || v2 && int32(*(*uint8)(unsafe.Pointer(v1))) != int32('\\'); !v5 {
		v4 = s
		s++
	}
	if v5 || int32(*(*uint8)(unsafe.Pointer(v4))) != int32('}') {
		return uintptr(0)
	}
	*(*int32)(unsafe.Pointer(pmin)) = *(*int32)(unsafe.Pointer(bp))
	*(*int32)(unsafe.Pointer(pmax)) = *(*int32)(unsafe.Pointer(bp + 4))
	return s
}

func _hexval1(tls *TLS, c uint32) (r int32) {
	if c-uint32('0') < uint32(10) {
		return int32(c - uint32('0'))
	}
	c |= uint32(32)
	if c-uint32('a') < uint32(6) {
		return int32(c - uint32('a') + uint32(10))
	}
	return -int32(1)
}

func _marksub(tls *TLS, ctx uintptr, node uintptr, subid int32) (r Treg_errcode_t) {
	var n uintptr
	_ = n
	if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id >= 0 {
		n = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
		if !(n != 0) {
			return int32(REG_ESPACE)
		}
		n = _tre_ast_new_catenation(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, n, node)
		if !(n != 0) {
			return int32(REG_ESPACE)
		}
		(*Ttre_ast_node_t)(unsafe.Pointer(n)).Fnum_submatches = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches
		node = n
	}
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id = subid
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches++
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = node
	return REG_OK
}

/*
BRE grammar:
Regex  =  Branch  |  '^'  |  '$'  |  '^$'  |  '^' Branch  |  Branch '$'  |  '^' Branch '$'
Branch =  Atom  |  Branch Atom
Atom   =  char  |  quoted_char  |  '.'  |  Bracket  |  Atom Dup  |  '\(' Branch '\)'  |  back_ref
Dup    =  '*'  |  '\{' Count '\}'  |  '\{' Count ',\}'  |  '\{' Count ',' Count '\}'

(leading ^ and trailing $ in a sub expr may be an anchor or literal as well)

ERE grammar:
Regex  =  Branch  |  Regex '|' Branch
Branch =  Atom  |  Branch Atom
Atom   =  char  |  quoted_char  |  '.'  |  Bracket  |  Atom Dup  |  '(' Regex ')'  |  '^'  |  '$'
Dup    =  '*'  |  '+'  |  '?'  |  '{' Count '}'  |  '{' Count ',}'  |  '{' Count ',' Count '}'

(a*+?, ^*, $+, \X, {, (|a) are unspecified)
*/

func _parse_atom(tls *TLS, ctx uintptr, s uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, ere, i, len1, v, val, v16, v18, v20, v21, v23, v25 int32
	var err Treg_errcode_t
	var node, p, tmp1, tmp11, tmp2, tmp21, v14, v17, v19, v22, v24, v26 uintptr
	var _ /* wc at bp+0 */ Twchar_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, ere, err, i, len1, node, p, tmp1, tmp11, tmp2, tmp21, v, val, v14, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26
	ere = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags & int32(REG_EXTENDED)
	switch int32(*(*uint8)(unsafe.Pointer(s))) {
	case int32('['):
		goto _1
	case int32('\\'):
		goto _2
	case int32('.'):
		goto _3
	case int32('^'):
		goto _4
	case int32('$'):
		goto _5
	case int32('?'):
		goto _6
	case int32('+'):
		goto _7
	case int32('{'):
		goto _8
	case int32('*'):
		goto _9
	case int32('|'):
		goto _10
	case 0:
		goto _11
	default:
		goto _12
	}
	goto _13
_1:
	;
	return _parse_bracket(tls, ctx, s+uintptr(1))
_2:
	;
	p = _tre_expand_macro(tls, s+uintptr(1))
	if p != 0 {
		/* assume \X expansion is a single atom */
		err = _parse_atom(tls, ctx, p)
		(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fs = s + uintptr(2)
		return err
	}
	/* extensions: \b, \B, \<, \>, \xHH \x{HHHH} */
	s++
	v14 = s
	switch int32(*(*uint8)(unsafe.Pointer(v14))) {
	case 0:
		return int32(REG_EESCAPE)
	case int32('b'):
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(ASSERT_AT_WB), -int32(1))
	case int32('B'):
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(ASSERT_AT_WB_NEG), -int32(1))
	case int32('<'):
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(ASSERT_AT_BOW), -int32(1))
	case int32('>'):
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(ASSERT_AT_EOW), -int32(1))
	case int32('x'):
		s++
		v = 0
		len1 = int32(2)
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32('{') {
			len1 = int32(8)
			s++
		}
		i = 0
		for {
			if !(i < len1 && v < int32(0x110000)) {
				break
			}
			c = _hexval1(tls, uint32(*(*uint8)(unsafe.Pointer(s + uintptr(i)))))
			if c < 0 {
				break
			}
			v = int32(16)*v + c
			goto _15
		_15:
			;
			i++
		}
		s += uintptr(i)
		if len1 == int32(8) {
			if int32(*(*uint8)(unsafe.Pointer(s))) != int32('}') {
				return int32(REG_EBRACE)
			}
			s++
		}
		v17 = ctx + 44
		v16 = *(*int32)(unsafe.Pointer(v17))
		*(*int32)(unsafe.Pointer(v17))++
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, v, v, v16)
		s--
	case int32('{'):
		fallthrough
	case int32('+'):
		fallthrough
	case int32('?'):
		/* extension: treat \+, \? as repetitions in BRE */
		/* reject repetitions after empty expression in BRE */
		if !(ere != 0) {
			return int32(REG_BADRPT)
		}
		fallthrough
	case int32('|'):
		/* extension: treat \| as alternation in BRE */
		if !(ere != 0) {
			node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			s--
			goto end
		}
		/* fallthrough */
		fallthrough
	default:
		if !(ere != 0) && uint32(*(*uint8)(unsafe.Pointer(s)))-uint32('1') < uint32(9) {
			/* back reference */
			val = int32(*(*uint8)(unsafe.Pointer(s))) - int32('0')
			v19 = ctx + 44
			v18 = *(*int32)(unsafe.Pointer(v19))
			*(*int32)(unsafe.Pointer(v19))++
			node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(4), val, v18)
			if val >= (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref {
				v20 = val
			} else {
				v20 = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref
			}
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmax_backref = v20
		} else {
			/* extension: accept unknown escaped char
			   as a literal */
			goto parse_literal
		}
	}
	s++
	goto _13
_3:
	;
	if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(REG_NEWLINE) != 0 {
		v22 = ctx + 44
		v21 = *(*int32)(unsafe.Pointer(v22))
		*(*int32)(unsafe.Pointer(v22))++
		tmp1 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, 0, Int32FromUint8('\n')-Int32FromInt32(1), v21)
		v24 = ctx + 44
		v23 = *(*int32)(unsafe.Pointer(v24))
		*(*int32)(unsafe.Pointer(v24))++
		tmp2 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, Int32FromUint8('\n')+Int32FromInt32(1), int32(TRE_CHAR_MAX), v23)
		if tmp1 != 0 && tmp2 != 0 {
			node = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, tmp1, tmp2)
		} else {
			node = uintptr(0)
		}
	} else {
		v26 = ctx + 44
		v25 = *(*int32)(unsafe.Pointer(v26))
		*(*int32)(unsafe.Pointer(v26))++
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, 0, int32(TRE_CHAR_MAX), v25)
	}
	s++
	goto _13
_4:
	;
	/* '^' has a special meaning everywhere in EREs, and at beginning of BRE. */
	if !(ere != 0) && s != (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart {
		goto parse_literal
	}
	node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(ASSERT_AT_BOL), -int32(1))
	s++
	goto _13
_5:
	;
	/* '$' is special everywhere in EREs, and at the end of a BRE subexpression. */
	if !(ere != 0) && *(*uint8)(unsafe.Pointer(s + 1)) != 0 && (int32(*(*uint8)(unsafe.Pointer(s + 1))) != int32('\\') || int32(*(*uint8)(unsafe.Pointer(s + 2))) != int32(')') && int32(*(*uint8)(unsafe.Pointer(s + 2))) != int32('|')) {
		goto parse_literal
	}
	node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(2), int32(ASSERT_AT_EOL), -int32(1))
	s++
	goto _13
_9:
	;
_8:
	;
_7:
	;
_6:
	;
	/* reject repetitions after empty expression in ERE */
	if ere != 0 {
		return int32(REG_BADRPT)
	}
_10:
	;
	if !(ere != 0) {
		goto parse_literal
	}
_11:
	;
	node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
	goto _13
_12:
	;
	goto parse_literal
parse_literal:
	;
	len1 = Xmbtowc(tls, bp, s, uint64(-Int32FromInt32(1)))
	if len1 < 0 {
		return int32(REG_BADPAT)
	}
	if (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags&int32(REG_ICASE) != 0 && (Xiswupper(tls, *(*Twchar_t)(unsafe.Pointer(bp))) != 0 || Xiswlower(tls, *(*Twchar_t)(unsafe.Pointer(bp))) != 0) {
		/* multiple opposite case characters are not supported */
		tmp11 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(Xtowupper(tls, *(*Twchar_t)(unsafe.Pointer(bp)))), int32(Xtowupper(tls, *(*Twchar_t)(unsafe.Pointer(bp)))), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
		tmp21 = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(Xtowlower(tls, *(*Twchar_t)(unsafe.Pointer(bp)))), int32(Xtowlower(tls, *(*Twchar_t)(unsafe.Pointer(bp)))), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
		if tmp11 != 0 && tmp21 != 0 {
			node = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, tmp11, tmp21)
		} else {
			node = uintptr(0)
		}
	} else {
		node = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, int32(*(*Twchar_t)(unsafe.Pointer(bp))), int32(*(*Twchar_t)(unsafe.Pointer(bp))), (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition)
	}
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fposition++
	s += uintptr(len1)
	goto _13
_13:
	;
	goto end
end:
	;
	if !(node != 0) {
		return int32(REG_ESPACE)
	}
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = node
	(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fs = s
	return REG_OK
}

func _tre_parse(tls *TLS, ctx uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c, depth, ere, subid, v2, v7 int32
	var err, v1, v4, v5, v6 Treg_errcode_t
	var nbranch, nunion, s, stack, v8 uintptr
	var _ /* max at bp+4 */ int32
	var _ /* min at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, depth, ere, err, nbranch, nunion, s, stack, subid, v1, v2, v4, v5, v6, v7, v8
	nbranch = uintptr(0)
	nunion = uintptr(0)
	ere = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fcflags & int32(REG_EXTENDED)
	s = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart
	subid = 0
	depth = 0
	stack = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstack
	v2 = subid
	subid++
	v1 = _tre_stack_push_int(tls, stack, v2)
	err = v1
	if v1 != REG_OK {
		return err
	}
	for {
		if !(ere != 0) && int32(*(*uint8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32('(') || ere != 0 && int32(*(*uint8)(unsafe.Pointer(s))) == int32('(') {
			v4 = _tre_stack_push_voidptr(tls, stack, nunion)
			err = v4
			if v4 != REG_OK {
				return err
			}
			v5 = _tre_stack_push_voidptr(tls, stack, nbranch)
			err = v5
			if v5 != REG_OK {
				return err
			}
			v7 = subid
			subid++
			v6 = _tre_stack_push_int(tls, stack, v7)
			err = v6
			if v6 != REG_OK {
				return err
			}
			s++
			if !(ere != 0) {
				s++
			}
			depth++
			v8 = UintptrFromInt32(0)
			nunion = v8
			nbranch = v8
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart = s
			goto _3
		}
		if !(ere != 0) && int32(*(*uint8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32(')') || ere != 0 && int32(*(*uint8)(unsafe.Pointer(s))) == int32(')') && depth != 0 {
			(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn != 0) {
				return int32(REG_ESPACE)
			}
		} else {
			err = _parse_atom(tls, ctx, s)
			if err != REG_OK {
				return err
			}
			s = (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fs
		}
		goto parse_iter
	parse_iter:
		;
		for {
			if int32(*(*uint8)(unsafe.Pointer(s))) != int32('\\') && int32(*(*uint8)(unsafe.Pointer(s))) != int32('*') {
				if !(ere != 0) {
					break
				}
				if int32(*(*uint8)(unsafe.Pointer(s))) != int32('+') && int32(*(*uint8)(unsafe.Pointer(s))) != int32('?') && int32(*(*uint8)(unsafe.Pointer(s))) != int32('{') {
					break
				}
			}
			if int32(*(*uint8)(unsafe.Pointer(s))) == int32('\\') && ere != 0 {
				break
			}
			/* extension: treat \+, \? as repetitions in BRE */
			if int32(*(*uint8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*uint8)(unsafe.Pointer(s + 1))) != int32('+') && int32(*(*uint8)(unsafe.Pointer(s + 1))) != int32('?') && int32(*(*uint8)(unsafe.Pointer(s + 1))) != int32('{') {
				break
			}
			if int32(*(*uint8)(unsafe.Pointer(s))) == int32('\\') {
				s++
			}
			/* handle ^* at the start of a BRE. */
			if !(ere != 0) && s == (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart+uintptr(1) && int32(*(*uint8)(unsafe.Pointer(s + uintptr(-Int32FromInt32(1))))) == int32('^') {
				break
			}
			/* extension: multiple consecutive *+?{,} is unspecified,
			   but (a+)+ has to be supported so accepting a++ makes
			   sense, note however that the RE_DUP_MAX limit can be
			   circumvented: (a{255}){255} uses a lot of memory.. */
			if int32(*(*uint8)(unsafe.Pointer(s))) == int32('{') {
				s = _parse_dup(tls, s+uintptr(1), ere, bp, bp+4)
				if !(s != 0) {
					return int32(REG_BADBR)
				}
			} else {
				*(*int32)(unsafe.Pointer(bp)) = 0
				*(*int32)(unsafe.Pointer(bp + 4)) = -int32(1)
				if int32(*(*uint8)(unsafe.Pointer(s))) == int32('+') {
					*(*int32)(unsafe.Pointer(bp)) = int32(1)
				}
				if int32(*(*uint8)(unsafe.Pointer(s))) == int32('?') {
					*(*int32)(unsafe.Pointer(bp + 4)) = int32(1)
				}
				s++
			}
			if *(*int32)(unsafe.Pointer(bp + 4)) == 0 {
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = _tre_ast_new_literal(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, -int32(1), -int32(1), -int32(1))
			} else {
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn = _tre_ast_new_iter(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn, *(*int32)(unsafe.Pointer(bp)), *(*int32)(unsafe.Pointer(bp + 4)), 0)
			}
			if !((*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn != 0) {
				return int32(REG_ESPACE)
			}
			goto _9
		_9:
		}
		nbranch = _tre_ast_new_catenation(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, nbranch, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fn)
		if ere != 0 && int32(*(*uint8)(unsafe.Pointer(s))) == int32('|') || ere != 0 && int32(*(*uint8)(unsafe.Pointer(s))) == int32(')') && depth != 0 || !(ere != 0) && int32(*(*uint8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32(')') || !(ere != 0) && int32(*(*uint8)(unsafe.Pointer(s))) == int32('\\') && int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32('|') || !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			/* extension: empty branch is unspecified (), (|a), (a|)
			   here they are not rejected but match on empty string */
			c = int32(*(*uint8)(unsafe.Pointer(s)))
			nunion = _tre_ast_new_union(tls, (*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fmem, nunion, nbranch)
			nbranch = uintptr(0)
			if c == int32('\\') && int32(*(*uint8)(unsafe.Pointer(s + 1))) == int32('|') {
				s += uintptr(2)
				(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart = s
			} else {
				if c == int32('|') {
					s++
					(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fstart = s
				} else {
					if c == int32('\\') {
						if !(depth != 0) {
							return int32(REG_EPAREN)
						}
						s += uintptr(2)
					} else {
						if c == int32(')') {
							s++
						}
					}
					depth--
					err = _marksub(tls, ctx, nunion, _tre_stack_pop_int(tls, stack))
					if err != REG_OK {
						return err
					}
					if !(c != 0) && depth < 0 {
						(*Ttre_parse_ctx_t)(unsafe.Pointer(ctx)).Fsubmatch_id = subid
						return REG_OK
					}
					if !(c != 0) || depth < 0 {
						return int32(REG_EPAREN)
					}
					nbranch = _tre_stack_pop_voidptr(tls, stack)
					nunion = _tre_stack_pop_voidptr(tls, stack)
					goto parse_iter
				}
			}
		}
		goto _3
	_3:
	}
	return r
}

/***********************************************************************
 from tre-compile.c
***********************************************************************/

/*
  TODO:
   - Fix tre_ast_to_tnfa() to recurse using a stack instead of recursive
     function calls.
*/

/*
  Algorithms to setup tags so that submatch addressing can be done.
*/

// C documentation
//
//	/* Inserts a catenation node to the root of the tree given in `node'.
//	   As the left child a new tag with number `tag_id' to `node' is added,
//	   and the right child is the old root. */
func _tre_add_tag_left(tls *TLS, mem Ttre_mem_t, node uintptr, tag_id int32) (r Treg_errcode_t) {
	var c uintptr
	_ = c
	c = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(16))
	if c == UintptrFromInt32(0) {
		return int32(REG_ESPACE)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft = _tre_ast_new_literal(tls, mem, -int32(3), tag_id, -int32(1))
	if (*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft == UintptrFromInt32(0) {
		return int32(REG_ESPACE)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fright = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(48))
	if (*Ttre_catenation_t)(unsafe.Pointer(c)).Fright == UintptrFromInt32(0) {
		return int32(REG_ESPACE)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fobj = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Ftype1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fnullable = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fsubmatch_id = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Ffirstpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Flastpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fnum_tags = 0
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fright)).Fnum_submatches = 0
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = c
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = int32(_CATENATION)
	return REG_OK
}

// C documentation
//
//	/* Inserts a catenation node to the root of the tree given in `node'.
//	   As the right child a new tag with number `tag_id' to `node' is added,
//	   and the left child is the old root. */
func _tre_add_tag_right(tls *TLS, mem Ttre_mem_t, node uintptr, tag_id int32) (r Treg_errcode_t) {
	var c uintptr
	_ = c
	c = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(16))
	if c == UintptrFromInt32(0) {
		return int32(REG_ESPACE)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fright = _tre_ast_new_literal(tls, mem, -int32(3), tag_id, -int32(1))
	if (*Ttre_catenation_t)(unsafe.Pointer(c)).Fright == UintptrFromInt32(0) {
		return int32(REG_ESPACE)
	}
	(*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(48))
	if (*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft == UintptrFromInt32(0) {
		return int32(REG_ESPACE)
	}
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fobj = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Ftype1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fnullable = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fsubmatch_id = -int32(1)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Ffirstpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Flastpos = UintptrFromInt32(0)
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fnum_tags = 0
	(*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(c)).Fleft)).Fnum_submatches = 0
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = c
	(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = int32(_CATENATION)
	return REG_OK
}

type Ttre_addtags_symbol_t = int32

const _ADDTAGS_RECURSE = 0
const _ADDTAGS_AFTER_ITERATION = 1
const _ADDTAGS_AFTER_UNION_LEFT = 2
const _ADDTAGS_AFTER_UNION_RIGHT = 3
const _ADDTAGS_AFTER_CAT_LEFT = 4
const _ADDTAGS_AFTER_CAT_RIGHT = 5
const _ADDTAGS_SET_SUBMATCH_END = 6

type Ttre_tag_states_t = struct {
	Ftag      int32
	Fnext_tag int32
}

// C documentation
//
//	/* Go through `regset' and set submatch data for submatches that are
//	   using this tag. */
func _tre_purge_regset(tls *TLS, regset uintptr, tnfa uintptr, tag int32) {
	var i, id, start int32
	_, _, _ = i, id, start
	i = 0
	for {
		if !(*(*int32)(unsafe.Pointer(regset + uintptr(i)*4)) >= 0) {
			break
		}
		id = *(*int32)(unsafe.Pointer(regset + uintptr(i)*4)) / int32(2)
		start = BoolInt32(!(*(*int32)(unsafe.Pointer(regset + uintptr(i)*4))%Int32FromInt32(2) != 0))
		if start != 0 {
			(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id)*16))).Fso_tag = tag
		} else {
			(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id)*16))).Feo_tag = tag
		}
		goto _1
	_1:
		;
		i++
	}
	*(*int32)(unsafe.Pointer(regset)) = -int32(1)
}

// C documentation
//
//	/* Adds tags to appropriate locations in the parse tree in `tree', so that
//	   subexpressions marked for submatch addressing can be traced. */
func _tre_add_tags(tls *TLS, mem Ttre_mem_t, stack uintptr, tree uintptr, tnfa uintptr) (r Treg_errcode_t) {
	var added_tags, bottom, enter_tag, first_pass, i1, i2, i3, i4, i5, i6, i7, id, id1, left_tag, minimal, minimal_tag, new_tag, next_tag, num_minimals, num_tags, reserved_tag, right_tag, tag, tag_left, tag_right, v22 int32
	var cat, iter, left, left1, left2, lit, node, orig_regset, p, parents, regset, right, right1, right2, saved_states, uni uintptr
	var direction Ttre_tag_direction_t
	var i uint32
	var status Treg_errcode_t
	var symbol Ttre_addtags_symbol_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = added_tags, bottom, cat, direction, enter_tag, first_pass, i, i1, i2, i3, i4, i5, i6, i7, id, id1, iter, left, left1, left2, left_tag, lit, minimal, minimal_tag, new_tag, next_tag, node, num_minimals, num_tags, orig_regset, p, parents, regset, reserved_tag, right, right1, right2, right_tag, saved_states, status, symbol, tag, tag_left, tag_right, uni, v22
	status = REG_OK
	node = tree /* Tree node we are currently looking at. */
	bottom = _tre_stack_num_objects(tls, stack)
	/* True for first pass (counting number of needed tags) */
	first_pass = BoolInt32(mem == UintptrFromInt32(0) || tnfa == UintptrFromInt32(0))
	num_tags = 0        /* Total number of tags. */
	num_minimals = 0    /* Number of special minimal tags. */
	tag = 0             /* The tag that is to be added next. */
	next_tag = int32(1) /* Stack of submatches the current submatch is
	   contained in. */
	minimal_tag = -int32(1)
	direction = int32(_TRE_TAG_MINIMIZE)
	if !(first_pass != 0) {
		(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag = 0
		*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags)) = -int32(1)
	}
	regset = Xmalloc(tls, uint64(4)*uint64(((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1))*Uint32FromInt32(2)))
	if regset == UintptrFromInt32(0) {
		return int32(REG_ESPACE)
	}
	*(*int32)(unsafe.Pointer(regset)) = -int32(1)
	orig_regset = regset
	parents = Xmalloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1)))
	if parents == UintptrFromInt32(0) {
		Xfree(tls, regset)
		return int32(REG_ESPACE)
	}
	*(*int32)(unsafe.Pointer(parents)) = -int32(1)
	saved_states = Xmalloc(tls, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches+Uint32FromInt32(1)))
	if saved_states == UintptrFromInt32(0) {
		Xfree(tls, regset)
		Xfree(tls, parents)
		return int32(REG_ESPACE)
	} else {
		i = uint32(0)
		for {
			if !(i <= (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches) {
				break
			}
			(*(*Ttre_tag_states_t)(unsafe.Pointer(saved_states + uintptr(i)*8))).Ftag = -int32(1)
			goto _1
		_1:
			;
			i++
		}
	}
	status = _tre_stack_push_voidptr(tls, stack, node)
	status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
	for _tre_stack_num_objects(tls, stack) > bottom {
		if status != REG_OK {
			break
		}
		symbol = _tre_stack_pop_int(tls, stack)
		switch symbol {
		case int32(_ADDTAGS_SET_SUBMATCH_END):
			goto _2
		case int32(_ADDTAGS_RECURSE):
			goto _3
		case int32(_ADDTAGS_AFTER_ITERATION):
			goto _4
		case int32(_ADDTAGS_AFTER_CAT_LEFT):
			goto _5
		case int32(_ADDTAGS_AFTER_CAT_RIGHT):
			goto _6
		case int32(_ADDTAGS_AFTER_UNION_LEFT):
			goto _7
		case int32(_ADDTAGS_AFTER_UNION_RIGHT):
			goto _8
		default:
			goto _9
		}
		goto _10
	_2:
		;
		id = _tre_stack_pop_int(tls, stack)
		/* Add end of this submatch to regset. */
		i1 = 0
		for {
			if !(*(*int32)(unsafe.Pointer(regset + uintptr(i1)*4)) >= 0) {
				break
			}
			goto _11
		_11:
			;
			i1++
		}
		*(*int32)(unsafe.Pointer(regset + uintptr(i1)*4)) = id*int32(2) + int32(1)
		*(*int32)(unsafe.Pointer(regset + uintptr(i1+int32(1))*4)) = -int32(1)
		/* Pop this submatch from the parents stack. */
		i1 = 0
		for {
			if !(*(*int32)(unsafe.Pointer(parents + uintptr(i1)*4)) >= 0) {
				break
			}
			goto _12
		_12:
			;
			i1++
		}
		*(*int32)(unsafe.Pointer(parents + uintptr(i1-int32(1))*4)) = -int32(1)
		goto _10
	_3:
		;
		node = _tre_stack_pop_voidptr(tls, stack)
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id >= 0 {
			id1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id
			/* Add start of this submatch to regset. */
			i2 = 0
			for {
				if !(*(*int32)(unsafe.Pointer(regset + uintptr(i2)*4)) >= 0) {
					break
				}
				goto _13
			_13:
				;
				i2++
			}
			*(*int32)(unsafe.Pointer(regset + uintptr(i2)*4)) = id1 * int32(2)
			*(*int32)(unsafe.Pointer(regset + uintptr(i2+int32(1))*4)) = -int32(1)
			if !(first_pass != 0) {
				i2 = 0
				for {
					if !(*(*int32)(unsafe.Pointer(parents + uintptr(i2)*4)) >= 0) {
						break
					}
					goto _14
				_14:
					;
					i2++
				}
				(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id1)*16))).Fparents = UintptrFromInt32(0)
				if i2 > 0 {
					p = Xmalloc(tls, uint64(4)*uint64(i2+Int32FromInt32(1)))
					if p == UintptrFromInt32(0) {
						status = int32(REG_ESPACE)
						goto _10
					}
					(*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(id1)*16))).Fparents = p
					i2 = 0
					for {
						if !(*(*int32)(unsafe.Pointer(parents + uintptr(i2)*4)) >= 0) {
							break
						}
						*(*int32)(unsafe.Pointer(p + uintptr(i2)*4)) = *(*int32)(unsafe.Pointer(parents + uintptr(i2)*4))
						goto _15
					_15:
						;
						i2++
					}
					*(*int32)(unsafe.Pointer(p + uintptr(i2)*4)) = -int32(1)
				}
			}
			/* Add end of this submatch to regset after processing this
			node. */
			status = _tre_stack_push_int(tls, stack, (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id)
			if status != REG_OK {
				goto _10
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_SET_SUBMATCH_END))
			if status != REG_OK {
				goto _10
			}
		}
		switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
		case int32(_LITERAL):
			lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
				if *(*int32)(unsafe.Pointer(regset)) >= 0 {
					/* Regset is not empty, so add a tag before the
					   literal or backref. */
					if !(first_pass != 0) {
						status = _tre_add_tag_left(tls, mem, node, tag)
						*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
						if minimal_tag >= 0 {
							i3 = 0
							for {
								if !(*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i3)*4)) >= 0) {
									break
								}
								goto _16
							_16:
								;
								i3++
							}
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i3)*4)) = tag
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i3+int32(1))*4)) = minimal_tag
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i3+int32(2))*4)) = -int32(1)
							minimal_tag = -int32(1)
							num_minimals++
						}
						_tre_purge_regset(tls, regset, tnfa, tag)
					} else {
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = int32(1)
					}
					*(*int32)(unsafe.Pointer(regset)) = -int32(1)
					tag = next_tag
					num_tags++
					next_tag++
				}
			} else {
			}
		case int32(_CATENATION):
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			left = (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft
			right = (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright
			reserved_tag = -int32(1)
			/* After processing right child. */
			status = _tre_stack_push_voidptr(tls, stack, node)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_CAT_RIGHT))
			if status != REG_OK {
				break
			}
			/* Process right child. */
			status = _tre_stack_push_voidptr(tls, stack, right)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
			if status != REG_OK {
				break
			}
			/* After processing left child. */
			status = _tre_stack_push_int(tls, stack, next_tag+(*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_tags)
			if status != REG_OK {
				break
			}
			if (*Ttre_ast_node_t)(unsafe.Pointer(left)).Fnum_tags > 0 && (*Ttre_ast_node_t)(unsafe.Pointer(right)).Fnum_tags > 0 {
				/* Reserve the next tag to the right child. */
				reserved_tag = next_tag
				next_tag++
			}
			status = _tre_stack_push_int(tls, stack, reserved_tag)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_CAT_LEFT))
			if status != REG_OK {
				break
			}
			/* Process left child. */
			status = _tre_stack_push_voidptr(tls, stack, left)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
			if status != REG_OK {
				break
			}
		case int32(_ITERATION):
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if first_pass != 0 {
				status = _tre_stack_push_int(tls, stack, BoolInt32(*(*int32)(unsafe.Pointer(regset)) >= 0 || int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)) != 0))
				if status != REG_OK {
					break
				}
			} else {
				status = _tre_stack_push_int(tls, stack, tag)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)))
				if status != REG_OK {
					break
				}
			}
			status = _tre_stack_push_voidptr(tls, stack, node)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_ITERATION))
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
			if status != REG_OK {
				break
			}
			/* Regset is not empty, so add a tag here. */
			if *(*int32)(unsafe.Pointer(regset)) >= 0 || int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)) != 0 {
				if !(first_pass != 0) {
					status = _tre_add_tag_left(tls, mem, node, tag)
					if int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)) != 0 {
						*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = int32(_TRE_TAG_MAXIMIZE)
					} else {
						*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
					}
					if minimal_tag >= 0 {
						i4 = 0
						for {
							if !(*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i4)*4)) >= 0) {
								break
							}
							goto _17
						_17:
							;
							i4++
						}
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i4)*4)) = tag
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i4+int32(1))*4)) = minimal_tag
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i4+int32(2))*4)) = -int32(1)
						minimal_tag = -int32(1)
						num_minimals++
					}
					_tre_purge_regset(tls, regset, tnfa, tag)
				}
				*(*int32)(unsafe.Pointer(regset)) = -int32(1)
				tag = next_tag
				num_tags++
				next_tag++
			}
			direction = int32(_TRE_TAG_MINIMIZE)
		case int32(_UNION):
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			left1 = (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft
			right1 = (*Ttre_union_t)(unsafe.Pointer(uni)).Fright
			if *(*int32)(unsafe.Pointer(regset)) >= 0 {
				left_tag = next_tag
				right_tag = next_tag + int32(1)
			} else {
				left_tag = tag
				right_tag = next_tag
			}
			/* After processing right child. */
			status = _tre_stack_push_int(tls, stack, right_tag)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, left_tag)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_voidptr(tls, stack, regset)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, BoolInt32(*(*int32)(unsafe.Pointer(regset)) >= 0))
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_voidptr(tls, stack, node)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_voidptr(tls, stack, right1)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_voidptr(tls, stack, left1)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_UNION_RIGHT))
			if status != REG_OK {
				break
			}
			/* Process right child. */
			status = _tre_stack_push_voidptr(tls, stack, right1)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
			if status != REG_OK {
				break
			}
			/* After processing left child. */
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_AFTER_UNION_LEFT))
			if status != REG_OK {
				break
			}
			/* Process left child. */
			status = _tre_stack_push_voidptr(tls, stack, left1)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_int(tls, stack, int32(_ADDTAGS_RECURSE))
			if status != REG_OK {
				break
			}
			/* Regset is not empty, so add a tag here. */
			if *(*int32)(unsafe.Pointer(regset)) >= 0 {
				if !(first_pass != 0) {
					status = _tre_add_tag_left(tls, mem, node, tag)
					*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag)*4)) = direction
					if minimal_tag >= 0 {
						i5 = 0
						for {
							if !(*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i5)*4)) >= 0) {
								break
							}
							goto _18
						_18:
							;
							i5++
						}
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i5)*4)) = tag
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i5+int32(1))*4)) = minimal_tag
						*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i5+int32(2))*4)) = -int32(1)
						minimal_tag = -int32(1)
						num_minimals++
					}
					_tre_purge_regset(tls, regset, tnfa, tag)
				}
				*(*int32)(unsafe.Pointer(regset)) = -int32(1)
				tag = next_tag
				num_tags++
				next_tag++
			}
			if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > 0 {
				/* The next two tags are reserved for markers. */
				next_tag++
				tag = next_tag
				next_tag++
			}
			break
		}
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id >= 0 {
			/* Push this submatch on the parents stack. */
			i6 = 0
			for {
				if !(*(*int32)(unsafe.Pointer(parents + uintptr(i6)*4)) >= 0) {
					break
				}
				goto _19
			_19:
				;
				i6++
			}
			*(*int32)(unsafe.Pointer(parents + uintptr(i6)*4)) = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fsubmatch_id
			*(*int32)(unsafe.Pointer(parents + uintptr(i6+int32(1))*4)) = -int32(1)
		}
		goto _10 /* end case: ADDTAGS_RECURSE */
	_4:
		;
		minimal = 0
		node = _tre_stack_pop_voidptr(tls, stack)
		if first_pass != 0 {
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Farg)).Fnum_tags + _tre_stack_pop_int(tls, stack)
			minimal_tag = -int32(1)
		} else {
			minimal = _tre_stack_pop_int(tls, stack)
			enter_tag = _tre_stack_pop_int(tls, stack)
			if minimal != 0 {
				minimal_tag = enter_tag
			}
		}
		if !(first_pass != 0) {
			if minimal != 0 {
				direction = int32(_TRE_TAG_MINIMIZE)
			} else {
				direction = int32(_TRE_TAG_MAXIMIZE)
			}
		}
		goto _10
	_5:
		;
		new_tag = _tre_stack_pop_int(tls, stack)
		next_tag = _tre_stack_pop_int(tls, stack)
		if new_tag >= 0 {
			tag = new_tag
		}
		goto _10
	_6:
		;
		node = _tre_stack_pop_voidptr(tls, stack)
		if first_pass != 0 {
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)).Fnum_tags + (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)).Fnum_tags
		}
		goto _10
	_7:
		;
		/* Lift the bottom of the `regset' array so that when processing
		   the right operand the items currently in the array are
		   invisible.	 The original bottom was saved at ADDTAGS_UNION and
		   will be restored at ADDTAGS_AFTER_UNION_RIGHT below. */
	_21:
		;
		if !(*(*int32)(unsafe.Pointer(regset)) >= 0) {
			goto _20
		}
		regset += 4
		goto _21
	_20:
		;
		goto _10
	_8:
		;
		left2 = _tre_stack_pop_voidptr(tls, stack)
		right2 = _tre_stack_pop_voidptr(tls, stack)
		node = _tre_stack_pop_voidptr(tls, stack)
		added_tags = _tre_stack_pop_int(tls, stack)
		if first_pass != 0 {
			if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > 0 {
				v22 = int32(2)
			} else {
				v22 = 0
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_tags = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)).Fnum_tags + (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)).Fnum_tags + added_tags + v22
		}
		regset = _tre_stack_pop_voidptr(tls, stack)
		tag_left = _tre_stack_pop_int(tls, stack)
		tag_right = _tre_stack_pop_int(tls, stack)
		/* Add tags after both children, the left child gets a smaller
		   tag than the right child.  This guarantees that we prefer
		   the left child over the right child. */
		/* XXX - This is not always necessary (if the children have
		   tags which must be seen for every match of that child). */
		/* XXX - Check if this is the only place where tre_add_tag_right
		   is used.	 If so, use tre_add_tag_left (putting the tag before
		   the child as opposed after the child) and throw away
		   tre_add_tag_right. */
		if (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnum_submatches > 0 {
			if !(first_pass != 0) {
				status = _tre_add_tag_right(tls, mem, left2, tag_left)
				*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag_left)*4)) = int32(_TRE_TAG_MAXIMIZE)
				if status == REG_OK {
					status = _tre_add_tag_right(tls, mem, right2, tag_right)
				}
				*(*Ttre_tag_direction_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions + uintptr(tag_right)*4)) = int32(_TRE_TAG_MAXIMIZE)
			}
			num_tags += int32(2)
		}
		direction = int32(_TRE_TAG_MAXIMIZE)
		goto _10
	_9:
		;
		goto _10
	_10:
		/* end switch(symbol) */
	} /* end while(tre_stack_num_objects(stack) > bottom) */
	if !(first_pass != 0) {
		_tre_purge_regset(tls, regset, tnfa, tag)
	}
	if !(first_pass != 0) && minimal_tag >= 0 {
		i7 = 0
		for {
			if !(*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i7)*4)) >= 0) {
				break
			}
			goto _23
		_23:
			;
			i7++
		}
		*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i7)*4)) = tag
		*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i7+int32(1))*4)) = minimal_tag
		*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i7+int32(2))*4)) = -int32(1)
		minimal_tag = -int32(1)
		num_minimals++
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag = num_tags
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags = num_tags
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_minimals = num_minimals
	Xfree(tls, orig_regset)
	Xfree(tls, parents)
	Xfree(tls, saved_states)
	return status
}

/*
  AST to TNFA compilation routines.
*/

type Ttre_copyast_symbol_t = int32

const _COPY_RECURSE = 0
const _COPY_SET_RESULT_PTR = 1

/* Flags for tre_copy_ast(). */

func _tre_copy_ast(tls *TLS, mem Ttre_mem_t, stack uintptr, ast uintptr, flags int32, pos_add uintptr, tag_directions uintptr, copy1 uintptr, max_pos uintptr) (r Treg_errcode_t) {
	var bottom, first_tag, max, min, num_copied, pos, v1 int32
	var cat, iter, lit, node, p, result, tmp, tmp1, uni uintptr
	var status Treg_errcode_t
	var symbol Ttre_copyast_symbol_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bottom, cat, first_tag, iter, lit, max, min, node, num_copied, p, pos, result, status, symbol, tmp, tmp1, uni, v1
	status = REG_OK
	bottom = _tre_stack_num_objects(tls, stack)
	num_copied = 0
	first_tag = int32(1)
	result = copy1
	status = _tre_stack_push_voidptr(tls, stack, ast)
	status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
	for status == REG_OK && _tre_stack_num_objects(tls, stack) > bottom {
		if status != REG_OK {
			break
		}
		symbol = _tre_stack_pop_int(tls, stack)
		switch symbol {
		case int32(_COPY_SET_RESULT_PTR):
			result = _tre_stack_pop_voidptr(tls, stack)
		case int32(_COPY_RECURSE):
			node = _tre_stack_pop_voidptr(tls, stack)
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				pos = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition
				min = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min)
				max = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
				if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					/* XXX - e.g. [ab] has only one position but two
					   nodes, so we are creating holes in the state space
					   here.  Not fatal, just wastes memory. */
					pos += *(*int32)(unsafe.Pointer(pos_add))
					num_copied++
				} else {
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(3)) && flags&int32(COPY_REMOVE_TAGS) != 0 {
						/* Change this tag to empty. */
						min = -int32(1)
						v1 = -Int32FromInt32(1)
						pos = v1
						max = v1
					} else {
						if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(3)) && flags&int32(COPY_MAXIMIZE_FIRST_TAG) != 0 && first_tag != 0 {
							/* Maximize the first tag. */
							*(*Ttre_tag_direction_t)(unsafe.Pointer(tag_directions + uintptr(max)*4)) = int32(_TRE_TAG_MAXIMIZE)
							first_tag = 0
						}
					}
				}
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_literal(tls, mem, min, max, pos)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(REG_ESPACE)
				} else {
					p = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
					(*Ttre_literal_t)(unsafe.Pointer(p)).Fclass = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fclass
					(*Ttre_literal_t)(unsafe.Pointer(p)).Fneg_classes = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fneg_classes
				}
				if pos > *(*int32)(unsafe.Pointer(max_pos)) {
					*(*int32)(unsafe.Pointer(max_pos)) = pos
				}
			case int32(_UNION):
				uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_union(tls, mem, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(REG_ESPACE)
					break
				}
				tmp = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				result = tmp
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_voidptr(tls, stack, tmp+8)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_COPY_SET_RESULT_PTR))
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
				if status != REG_OK {
					break
				}
			case int32(_CATENATION):
				cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_catenation(tls, mem, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(REG_ESPACE)
					break
				}
				tmp1 = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				(*Ttre_catenation_t)(unsafe.Pointer(tmp1)).Fleft = UintptrFromInt32(0)
				(*Ttre_catenation_t)(unsafe.Pointer(tmp1)).Fright = UintptrFromInt32(0)
				result = tmp1
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_voidptr(tls, stack, tmp1+8)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_COPY_SET_RESULT_PTR))
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
				if status != REG_OK {
					break
				}
			case int32(_ITERATION):
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_COPY_RECURSE))
				if status != REG_OK {
					break
				}
				*(*uintptr)(unsafe.Pointer(result)) = _tre_ast_new_iter(tls, mem, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax, int32(uint32(*(*uint8)(unsafe.Pointer(iter + 16))&0x1>>0)))
				if *(*uintptr)(unsafe.Pointer(result)) == UintptrFromInt32(0) {
					status = int32(REG_ESPACE)
					break
				}
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(result)))).Fobj
				result = iter
			default:
				break
			}
			break
		}
	}
	*(*int32)(unsafe.Pointer(pos_add)) += num_copied
	return status
}

type Ttre_expand_ast_symbol_t = int32

const _EXPAND_RECURSE = 0
const _EXPAND_AFTER_ITER = 1

// C documentation
//
//	/* Expands each iteration node that has a finite nonzero minimum or maximum
//	   iteration count to a catenated sequence of copies of the node. */
func _tre_expand_ast(tls *TLS, mem Ttre_mem_t, stack uintptr, ast uintptr, position uintptr, tag_directions uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _status, _status1, status Treg_errcode_t
	var bottom, flags, iter_depth, j, pos_add_last, pos_add_save, pos_add_total, v2 int32
	var cat, iter, iter1, lit, node, seq1, tmp, uni uintptr
	var symbol Ttre_expand_ast_symbol_t
	var _ /* copy at bp+16 */ uintptr
	var _ /* copy at bp+24 */ uintptr
	var _ /* max_pos at bp+4 */ int32
	var _ /* pos_add at bp+0 */ int32
	var _ /* seq2 at bp+8 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _status, _status1, bottom, cat, flags, iter, iter1, iter_depth, j, lit, node, pos_add_last, pos_add_save, pos_add_total, seq1, status, symbol, tmp, uni, v2
	status = REG_OK
	bottom = _tre_stack_num_objects(tls, stack)
	*(*int32)(unsafe.Pointer(bp)) = 0
	pos_add_total = 0
	*(*int32)(unsafe.Pointer(bp + 4)) = 0
	iter_depth = 0
	_status = _tre_stack_push_voidptr(tls, stack, ast)
	if _status != REG_OK {
		return _status
	}
	_status1 = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
	if _status1 != REG_OK {
		return _status1
	}
	for status == REG_OK && _tre_stack_num_objects(tls, stack) > bottom {
		if status != REG_OK {
			break
		}
		symbol = _tre_stack_pop_int(tls, stack)
		node = _tre_stack_pop_voidptr(tls, stack)
		switch symbol {
		case int32(_EXPAND_RECURSE):
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				if !((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < Int64FromInt32(0)) || (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					*(*int32)(unsafe.Pointer(lit + 16)) += *(*int32)(unsafe.Pointer(bp))
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition > *(*int32)(unsafe.Pointer(bp + 4)) {
						*(*int32)(unsafe.Pointer(bp + 4)) = (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition
					}
				}
			case int32(_UNION):
				uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
				if status != REG_OK {
					break
				}
			case int32(_CATENATION):
				cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
				if status != REG_OK {
					break
				}
			case int32(_ITERATION):
				iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				status = _tre_stack_push_int(tls, stack, *(*int32)(unsafe.Pointer(bp)))
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_voidptr(tls, stack, node)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_EXPAND_AFTER_ITER))
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
				if status != REG_OK {
					break
				}
				status = _tre_stack_push_int(tls, stack, int32(_EXPAND_RECURSE))
				if status != REG_OK {
					break
				}
				/* If we are going to expand this node at EXPAND_AFTER_ITER
				   then don't increase the `pos' fields of the nodes now, it
				   will get done when expanding. */
				if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin > int32(1) || (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax > int32(1) {
					*(*int32)(unsafe.Pointer(bp)) = 0
				}
				iter_depth++
			default:
				break
			}
		case int32(_EXPAND_AFTER_ITER):
			iter1 = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			*(*int32)(unsafe.Pointer(bp)) = _tre_stack_pop_int(tls, stack)
			pos_add_last = *(*int32)(unsafe.Pointer(bp))
			if (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin > int32(1) || (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax > int32(1) {
				seq1 = UintptrFromInt32(0)
				*(*uintptr)(unsafe.Pointer(bp + 8)) = UintptrFromInt32(0)
				pos_add_save = *(*int32)(unsafe.Pointer(bp))
				/* Create a catenated sequence of copies of the node. */
				j = 0
				for {
					if !(j < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin) {
						break
					}
					if j+int32(1) < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin {
						v2 = int32(COPY_REMOVE_TAGS)
					} else {
						v2 = int32(COPY_MAXIMIZE_FIRST_TAG)
					}
					/* Remove tags from all but the last copy. */
					flags = v2
					pos_add_save = *(*int32)(unsafe.Pointer(bp))
					status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, flags, bp, tag_directions, bp+16, bp+4)
					if status != REG_OK {
						return status
					}
					if seq1 != UintptrFromInt32(0) {
						seq1 = _tre_ast_new_catenation(tls, mem, seq1, *(*uintptr)(unsafe.Pointer(bp + 16)))
					} else {
						seq1 = *(*uintptr)(unsafe.Pointer(bp + 16))
					}
					if seq1 == UintptrFromInt32(0) {
						return int32(REG_ESPACE)
					}
					goto _1
				_1:
					;
					j++
				}
				if (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax == -int32(1) {
					/* No upper limit. */
					pos_add_save = *(*int32)(unsafe.Pointer(bp))
					status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, 0, bp, UintptrFromInt32(0), bp+8, bp+4)
					if status != REG_OK {
						return status
					}
					*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_iter(tls, mem, *(*uintptr)(unsafe.Pointer(bp + 8)), 0, -int32(1), 0)
					if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
						return int32(REG_ESPACE)
					}
				} else {
					j = (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmin
					for {
						if !(j < (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Fmax) {
							break
						}
						pos_add_save = *(*int32)(unsafe.Pointer(bp))
						status = _tre_copy_ast(tls, mem, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter1)).Farg, 0, bp, UintptrFromInt32(0), bp+24, bp+4)
						if status != REG_OK {
							return status
						}
						if *(*uintptr)(unsafe.Pointer(bp + 8)) != UintptrFromInt32(0) {
							*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_catenation(tls, mem, *(*uintptr)(unsafe.Pointer(bp + 24)), *(*uintptr)(unsafe.Pointer(bp + 8)))
						} else {
							*(*uintptr)(unsafe.Pointer(bp + 8)) = *(*uintptr)(unsafe.Pointer(bp + 24))
						}
						if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
							return int32(REG_ESPACE)
						}
						tmp = _tre_ast_new_literal(tls, mem, -int32(1), -int32(1), -int32(1))
						if tmp == UintptrFromInt32(0) {
							return int32(REG_ESPACE)
						}
						*(*uintptr)(unsafe.Pointer(bp + 8)) = _tre_ast_new_union(tls, mem, tmp, *(*uintptr)(unsafe.Pointer(bp + 8)))
						if *(*uintptr)(unsafe.Pointer(bp + 8)) == UintptrFromInt32(0) {
							return int32(REG_ESPACE)
						}
						goto _3
					_3:
						;
						j++
					}
				}
				*(*int32)(unsafe.Pointer(bp)) = pos_add_save
				if seq1 == UintptrFromInt32(0) {
					seq1 = *(*uintptr)(unsafe.Pointer(bp + 8))
				} else {
					if *(*uintptr)(unsafe.Pointer(bp + 8)) != UintptrFromInt32(0) {
						seq1 = _tre_ast_new_catenation(tls, mem, seq1, *(*uintptr)(unsafe.Pointer(bp + 8)))
					}
				}
				if seq1 == UintptrFromInt32(0) {
					return int32(REG_ESPACE)
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj = (*Ttre_ast_node_t)(unsafe.Pointer(seq1)).Fobj
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 = (*Ttre_ast_node_t)(unsafe.Pointer(seq1)).Ftype1
			}
			iter_depth--
			pos_add_total += *(*int32)(unsafe.Pointer(bp)) - pos_add_last
			if iter_depth == 0 {
				*(*int32)(unsafe.Pointer(bp)) = pos_add_total
			}
		default:
			break
		}
	}
	*(*int32)(unsafe.Pointer(position)) += pos_add_total
	/* `max_pos' should never be larger than `*position' if the above
	   code works, but just an extra safeguard let's make sure
	   `*position' is set large enough so enough memory will be
	   allocated for the transition table. */
	if *(*int32)(unsafe.Pointer(bp + 4)) > *(*int32)(unsafe.Pointer(position)) {
		*(*int32)(unsafe.Pointer(position)) = *(*int32)(unsafe.Pointer(bp + 4))
	}
	return status
}

func _tre_set_empty(tls *TLS, mem Ttre_mem_t) (r uintptr) {
	var new_set uintptr
	_ = new_set
	new_set = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(56))
	if new_set == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fposition = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fcode_min = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fcode_max = -int32(1)
	return new_set
}

func _tre_set_one(tls *TLS, mem Ttre_mem_t, position int32, code_min int32, code_max int32, class Ttre_ctype_t, neg_classes uintptr, backref int32) (r uintptr) {
	var new_set uintptr
	_ = new_set
	new_set = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), Uint64FromInt64(56)*Uint64FromInt32(2))
	if new_set == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fposition = position
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fcode_min = code_min
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fcode_max = code_max
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fclass = class
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fneg_classes = neg_classes
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set))).Fbackref = backref
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + 1*56))).Fposition = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + 1*56))).Fcode_min = -int32(1)
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + 1*56))).Fcode_max = -int32(1)
	return new_set
}

func _tre_set_union(tls *TLS, mem Ttre_mem_t, set1 uintptr, set2 uintptr, tags uintptr, assertions int32) (r uintptr) {
	var i, j, num_tags, s1, s2 int32
	var new_set, new_tags uintptr
	_, _, _, _, _, _, _ = i, j, new_set, new_tags, num_tags, s1, s2
	num_tags = 0
	for {
		if !(tags != UintptrFromInt32(0) && *(*int32)(unsafe.Pointer(tags + uintptr(num_tags)*4)) >= 0) {
			break
		}
		goto _1
	_1:
		;
		num_tags++
	}
	s1 = 0
	for {
		if !((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fposition >= 0) {
			break
		}
		goto _2
	_2:
		;
		s1++
	}
	s2 = 0
	for {
		if !((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fposition >= 0) {
			break
		}
		goto _3
	_3:
		;
		s2++
	}
	new_set = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), int32(1), uint64(56)*uint64(s1+s2+Int32FromInt32(1)))
	if !(new_set != 0) {
		return UintptrFromInt32(0)
	}
	s1 = 0
	for {
		if !((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fposition >= 0) {
			break
		}
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fposition = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fposition
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fcode_min = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fcode_min
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fcode_max = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fcode_max
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fassertions = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fassertions | assertions
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fclass = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fclass
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fneg_classes = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fneg_classes
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Fbackref = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Fbackref
		if (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Ftags == UintptrFromInt32(0) && tags == UintptrFromInt32(0) {
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Ftags = UintptrFromInt32(0)
		} else {
			i = 0
			for {
				if !((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Ftags != UintptrFromInt32(0) && *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Ftags + uintptr(i)*4)) >= 0) {
					break
				}
				goto _5
			_5:
				;
				i++
			}
			new_tags = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, Uint64FromInt64(4)*uint64(i+num_tags+Int32FromInt32(1)))
			if new_tags == UintptrFromInt32(0) {
				return UintptrFromInt32(0)
			}
			j = 0
			for {
				if !(j < i) {
					break
				}
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set1 + uintptr(s1)*56))).Ftags + uintptr(j)*4))
				goto _6
			_6:
				;
				j++
			}
			i = 0
			for {
				if !(i < num_tags) {
					break
				}
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j+i)*4)) = *(*int32)(unsafe.Pointer(tags + uintptr(i)*4))
				goto _7
			_7:
				;
				i++
			}
			*(*int32)(unsafe.Pointer(new_tags + uintptr(j+i)*4)) = -int32(1)
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1)*56))).Ftags = new_tags
		}
		goto _4
	_4:
		;
		s1++
	}
	s2 = 0
	for {
		if !((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fposition >= 0) {
			break
		}
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fposition = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fposition
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fcode_min = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fcode_min
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fcode_max = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fcode_max
		/* XXX - why not | assertions here as well? */
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fassertions = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fassertions
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fclass = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fclass
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fneg_classes = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fneg_classes
		(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fbackref = (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Fbackref
		if (*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Ftags == UintptrFromInt32(0) {
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Ftags = UintptrFromInt32(0)
		} else {
			i = 0
			for {
				if !(*(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Ftags + uintptr(i)*4)) >= 0) {
					break
				}
				goto _9
			_9:
				;
				i++
			}
			new_tags = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(4)*uint64(i+Int32FromInt32(1)))
			if new_tags == UintptrFromInt32(0) {
				return UintptrFromInt32(0)
			}
			j = 0
			for {
				if !(j < i) {
					break
				}
				*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = *(*int32)(unsafe.Pointer((*(*Ttre_pos_and_tags_t)(unsafe.Pointer(set2 + uintptr(s2)*56))).Ftags + uintptr(j)*4))
				goto _10
			_10:
				;
				j++
			}
			*(*int32)(unsafe.Pointer(new_tags + uintptr(j)*4)) = -int32(1)
			(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Ftags = new_tags
		}
		goto _8
	_8:
		;
		s2++
	}
	(*(*Ttre_pos_and_tags_t)(unsafe.Pointer(new_set + uintptr(s1+s2)*56))).Fposition = -int32(1)
	return new_set
}

// C documentation
//
//	/* Finds the empty path through `node' which is the one that should be
//	   taken according to POSIX.2 rules, and adds the tags on that path to
//	   `tags'.   `tags' may be NULL.  If `num_tags_seen' is not NULL, it is
//	   set to the number of tags seen on the path. */
func _tre_match_empty(tls *TLS, stack uintptr, node uintptr, tags uintptr, assertions uintptr, num_tags_seen uintptr) (r Treg_errcode_t) {
	var bottom, i int32
	var cat, iter, lit, uni, p2 uintptr
	var status Treg_errcode_t
	_, _, _, _, _, _, _, _ = bottom, cat, i, iter, lit, status, uni, p2
	bottom = _tre_stack_num_objects(tls, stack)
	status = REG_OK
	if num_tags_seen != 0 {
		*(*int32)(unsafe.Pointer(num_tags_seen)) = 0
	}
	status = _tre_stack_push_voidptr(tls, stack, node)
	/* Walk through the tree recursively. */
	for status == REG_OK && _tre_stack_num_objects(tls, stack) > bottom {
		node = _tre_stack_pop_voidptr(tls, stack)
		switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
		case int32(_LITERAL):
			lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			switch (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min {
			case int64(-int32(3)):
				if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max >= 0 {
					if tags != UintptrFromInt32(0) {
						/* Add the tag to `tags'. */
						i = 0
						for {
							if !(*(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) >= 0) {
								break
							}
							if int64(*(*int32)(unsafe.Pointer(tags + uintptr(i)*4))) == (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max {
								break
							}
							goto _1
						_1:
							;
							i++
						}
						if *(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) < 0 {
							*(*int32)(unsafe.Pointer(tags + uintptr(i)*4)) = int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
							*(*int32)(unsafe.Pointer(tags + uintptr(i+int32(1))*4)) = -int32(1)
						}
					}
					if num_tags_seen != 0 {
						*(*int32)(unsafe.Pointer(num_tags_seen))++
					}
				}
			case int64(-int32(2)):
				if assertions != UintptrFromInt32(0) {
					p2 = assertions
					*(*int32)(unsafe.Pointer(p2)) = int32(int64(*(*int32)(unsafe.Pointer(p2))) | (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max)
				}
			case int64(-int32(1)):
			default:
				break
			}
		case int32(_UNION):
			/* Subexpressions starting earlier take priority over ones
			   starting later, so we prefer the left subexpression over the
			   right subexpression. */
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Fnullable != 0 {
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)
				if status != REG_OK {
					break
				}
			} else {
				if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Fnullable != 0 {
					status = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright)
					if status != REG_OK {
						break
					}
				} else {
				}
			}
		case int32(_CATENATION):
			/* The path must go through both children. */
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)
			if status != REG_OK {
				break
			}
			status = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)
			if status != REG_OK {
				break
			}
		case int32(_ITERATION):
			/* A match with an empty string is preferred over no match at
			   all, so we go through the argument if possible. */
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Fnullable != 0 {
				status = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)
				if status != REG_OK {
					break
				}
			}
		default:
			break
		}
	}
	return status
}

type Ttre_nfl_stack_symbol_t = int32

const _NFL_RECURSE = 0
const _NFL_POST_UNION = 1
const _NFL_POST_CATENATION = 2
const _NFL_POST_ITERATION = 3

// C documentation
//
//	/* Computes and fills in the fields `nullable', `firstpos', and `lastpos' for
//	   the nodes of the AST `tree'. */
func _tre_compute_nfl(tls *TLS, mem Ttre_mem_t, stack uintptr, tree uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _status, _status1, _status10, _status11, _status12, _status13, _status14, _status15, _status16, _status17, _status2, _status3, _status4, _status5, _status6, _status7, _status8, _status9, status Treg_errcode_t
	var bottom int32
	var cat, iter, lit, node, tags, uni uintptr
	var symbol Ttre_nfl_stack_symbol_t
	var _ /* assertions at bp+4 */ int32
	var _ /* num_tags at bp+0 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = _status, _status1, _status10, _status11, _status12, _status13, _status14, _status15, _status16, _status17, _status2, _status3, _status4, _status5, _status6, _status7, _status8, _status9, bottom, cat, iter, lit, node, status, symbol, tags, uni
	bottom = _tre_stack_num_objects(tls, stack)
	_status = _tre_stack_push_voidptr(tls, stack, tree)
	if _status != REG_OK {
		return _status
	}
	_status1 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
	if _status1 != REG_OK {
		return _status1
	}
	for _tre_stack_num_objects(tls, stack) > bottom {
		symbol = _tre_stack_pop_int(tls, stack)
		node = _tre_stack_pop_voidptr(tls, stack)
		switch symbol {
		case int32(_NFL_RECURSE):
			switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
			case int32(_LITERAL):
				lit = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
				if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min == int64(-int32(4)) {
					/* Back references: nullable = false, firstpos = {i},
					   lastpos = {i}. */
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = 0
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, 0, int32(TRE_CHAR_MAX), uint64(0), UintptrFromInt32(0), -int32(1))
					if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
						return int32(REG_ESPACE)
					}
					(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, 0, int32(TRE_CHAR_MAX), uint64(0), UintptrFromInt32(0), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max))
					if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
						return int32(REG_ESPACE)
					}
				} else {
					if (*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min < 0 {
						/* Tags, empty strings, params, and zero width assertions:
						   nullable = true, firstpos = {}, and lastpos = {}. */
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(1)
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_empty(tls, mem)
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
							return int32(REG_ESPACE)
						}
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_empty(tls, mem)
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
							return int32(REG_ESPACE)
						}
					} else {
						/* Literal at position i: nullable = false, firstpos = {i},
						   lastpos = {i}. */
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = 0
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max), uint64(0), UintptrFromInt32(0), -int32(1))
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
							return int32(REG_ESPACE)
						}
						(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_one(tls, mem, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fposition, int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_min), int32((*Ttre_literal_t)(unsafe.Pointer(lit)).Fcode_max), (*Ttre_literal_t)(unsafe.Pointer(lit)).Fclass, (*Ttre_literal_t)(unsafe.Pointer(lit)).Fneg_classes, -int32(1))
						if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
							return int32(REG_ESPACE)
						}
					}
				}
			case int32(_UNION):
				/* Compute the attributes for the two subtrees, and after that
				for this node. */
				_status2 = _tre_stack_push_voidptr(tls, stack, node)
				if _status2 != REG_OK {
					return _status2
				}
				_status3 = _tre_stack_push_int(tls, stack, int32(_NFL_POST_UNION))
				if _status3 != REG_OK {
					return _status3
				}
				_status4 = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)
				if _status4 != REG_OK {
					return _status4
				}
				_status5 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
				if _status5 != REG_OK {
					return _status5
				}
				_status6 = _tre_stack_push_voidptr(tls, stack, (*Ttre_union_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)
				if _status6 != REG_OK {
					return _status6
				}
				_status7 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
				if _status7 != REG_OK {
					return _status7
				}
			case int32(_CATENATION):
				/* Compute the attributes for the two subtrees, and after that
				for this node. */
				_status8 = _tre_stack_push_voidptr(tls, stack, node)
				if _status8 != REG_OK {
					return _status8
				}
				_status9 = _tre_stack_push_int(tls, stack, int32(_NFL_POST_CATENATION))
				if _status9 != REG_OK {
					return _status9
				}
				_status10 = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fright)
				if _status10 != REG_OK {
					return _status10
				}
				_status11 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
				if _status11 != REG_OK {
					return _status11
				}
				_status12 = _tre_stack_push_voidptr(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Fleft)
				if _status12 != REG_OK {
					return _status12
				}
				_status13 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
				if _status13 != REG_OK {
					return _status13
				}
			case int32(_ITERATION):
				/* Compute the attributes for the subtree, and after that for
				this node. */
				_status14 = _tre_stack_push_voidptr(tls, stack, node)
				if _status14 != REG_OK {
					return _status14
				}
				_status15 = _tre_stack_push_int(tls, stack, int32(_NFL_POST_ITERATION))
				if _status15 != REG_OK {
					return _status15
				}
				_status16 = _tre_stack_push_voidptr(tls, stack, (*Ttre_iteration_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj)).Farg)
				if _status16 != REG_OK {
					return _status16
				}
				_status17 = _tre_stack_push_int(tls, stack, int32(_NFL_RECURSE))
				if _status17 != REG_OK {
					return _status17
				}
				break
			}
		case int32(_NFL_POST_UNION):
			uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = BoolInt32((*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Fnullable != 0 || (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Fnullable != 0)
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Ffirstpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Ffirstpos, UintptrFromInt32(0), 0)
			if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
				return int32(REG_ESPACE)
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_union_t)(unsafe.Pointer(uni)).Fright)).Flastpos, UintptrFromInt32(0), 0)
			if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
				return int32(REG_ESPACE)
			}
		case int32(_NFL_POST_ITERATION):
			iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmin == 0 || (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Fnullable != 0 {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = int32(1)
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = 0
			}
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Ffirstpos
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Flastpos
		case int32(_NFL_POST_CATENATION):
			cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
			(*Ttre_ast_node_t)(unsafe.Pointer(node)).Fnullable = BoolInt32((*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Fnullable != 0 && (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Fnullable != 0)
			/* Compute firstpos. */
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Fnullable != 0 {
				/* The left side matches the empty string.  Make a first pass
				   with tre_match_empty() to get the number of tags and
				   parameters. */
				status = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, UintptrFromInt32(0), UintptrFromInt32(0), bp)
				if status != REG_OK {
					return status
				}
				/* Allocate arrays for the tags and parameters. */
				tags = Xmalloc(tls, uint64(4)*uint64(*(*int32)(unsafe.Pointer(bp))+Int32FromInt32(1)))
				if !(tags != 0) {
					return int32(REG_ESPACE)
				}
				*(*int32)(unsafe.Pointer(tags)) = -int32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = 0
				/* Second pass with tre_mach_empty() to get the list of
				   tags and parameters. */
				status = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, tags, bp+4, UintptrFromInt32(0))
				if status != REG_OK {
					Xfree(tls, tags)
					return status
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Ffirstpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Ffirstpos, tags, *(*int32)(unsafe.Pointer(bp + 4)))
				Xfree(tls, tags)
				if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos != 0) {
					return int32(REG_ESPACE)
				}
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Ffirstpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Ffirstpos
			}
			/* Compute lastpos. */
			if (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Fnullable != 0 {
				/* The right side matches the empty string.  Make a first pass
				   with tre_match_empty() to get the number of tags and
				   parameters. */
				status = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, UintptrFromInt32(0), UintptrFromInt32(0), bp)
				if status != REG_OK {
					return status
				}
				/* Allocate arrays for the tags and parameters. */
				tags = Xmalloc(tls, uint64(4)*uint64(*(*int32)(unsafe.Pointer(bp))+Int32FromInt32(1)))
				if !(tags != 0) {
					return int32(REG_ESPACE)
				}
				*(*int32)(unsafe.Pointer(tags)) = -int32(1)
				*(*int32)(unsafe.Pointer(bp + 4)) = 0
				/* Second pass with tre_mach_empty() to get the list of
				   tags and parameters. */
				status = _tre_match_empty(tls, stack, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, tags, bp+4, UintptrFromInt32(0))
				if status != REG_OK {
					Xfree(tls, tags)
					return status
				}
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = _tre_set_union(tls, mem, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Flastpos, tags, *(*int32)(unsafe.Pointer(bp + 4)))
				Xfree(tls, tags)
				if !((*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos != 0) {
					return int32(REG_ESPACE)
				}
			} else {
				(*Ttre_ast_node_t)(unsafe.Pointer(node)).Flastpos = (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Flastpos
			}
		default:
			break
		}
	}
	return REG_OK
}

// C documentation
//
//	/* Adds a transition from each position in `p1' to each position in `p2'. */
func _tre_make_trans(tls *TLS, p1 uintptr, p2 uintptr, transitions uintptr, counts uintptr, offs uintptr) (r Treg_errcode_t) {
	var dup, i, j, k, l, prev_p2_pos, v1, v2, v6 int32
	var orig_p2, trans uintptr
	_, _, _, _, _, _, _, _, _, _, _ = dup, i, j, k, l, orig_p2, prev_p2_pos, trans, v1, v2, v6
	orig_p2 = p2
	if transitions != UintptrFromInt32(0) {
		for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition >= 0 {
			p2 = orig_p2
			prev_p2_pos = -int32(1)
			for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition >= 0 {
				/* Optimization: if this position was already handled, skip it. */
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition == prev_p2_pos {
					p2 += 56
					continue
				}
				prev_p2_pos = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition
				/* Set `trans' to point to the next unused transition from
				   position `p1->position'. */
				trans = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition)*4)))*56
				for (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate != UintptrFromInt32(0) {
					trans += 56
				}
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate == UintptrFromInt32(0) {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans + UintptrFromInt32(1)*56)).Fstate = UintptrFromInt32(0)
				}
				/* Use the character ranges, assertions, etc. from `p1' for
				   the transition from `p1' to `p2'. */
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fcode_min = uint32((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fcode_min)
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fcode_max = uint32((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fcode_max)
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition)*4)))*56
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate_id = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fclass != 0 {
					v1 = int32(ASSERT_CHAR_CLASS)
				} else {
					v1 = 0
				}
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes != UintptrFromInt32(0) {
					v2 = int32(ASSERT_CHAR_CLASS_NEG)
				} else {
					v2 = 0
				}
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fassertions = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fassertions | (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fassertions | v1 | v2
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fbackref >= 0 {
					*(*int32)(unsafe.Pointer(&(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fu)) = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fbackref
					*(*int32)(unsafe.Pointer(trans + 32)) |= int32(ASSERT_BACKREF)
				} else {
					*(*Ttre_ctype_t)(unsafe.Pointer(trans + 40)) = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fclass
				}
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes != UintptrFromInt32(0) {
					i = 0
					for {
						if !(*(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*8)) != Uint64FromInt32(0)) {
							break
						}
						goto _3
					_3:
						;
						i++
					}
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes = Xmalloc(tls, uint64(8)*uint64(i+Int32FromInt32(1)))
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes == UintptrFromInt32(0) {
						return int32(REG_ESPACE)
					}
					i = 0
					for {
						if !(*(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*8)) != Uint64FromInt32(0)) {
							break
						}
						*(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes + uintptr(i)*8)) = *(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fneg_classes + uintptr(i)*8))
						goto _4
					_4:
						;
						i++
					}
					*(*Ttre_ctype_t)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes + uintptr(i)*8)) = Uint64FromInt32(0)
				} else {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fneg_classes = UintptrFromInt32(0)
				}
				/* Find out how many tags this transition has. */
				i = 0
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags != UintptrFromInt32(0) {
					for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4)) >= 0 {
						i++
					}
				}
				j = 0
				if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags != UintptrFromInt32(0) {
					for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) >= 0 {
						j++
					}
				}
				/* If we are overwriting a transition, free the old tag array. */
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != UintptrFromInt32(0) {
					Xfree(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags)
				}
				(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags = UintptrFromInt32(0)
				/* If there were any tags, allocate an array and fill it. */
				if i+j > 0 {
					(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags = Xmalloc(tls, uint64(4)*uint64(i+j+Int32FromInt32(1)))
					if !((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != 0) {
						return int32(REG_ESPACE)
					}
					i = 0
					if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4)) >= 0 {
							*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Ftags + uintptr(i)*4))
							i++
						}
					}
					l = i
					j = 0
					if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) >= 0 {
							/* Don't add duplicates. */
							dup = 0
							k = 0
							for {
								if !(k < i) {
									break
								}
								if *(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(k)*4)) == *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4)) {
									dup = int32(1)
									break
								}
								goto _5
							_5:
								;
								k++
							}
							if !(dup != 0) {
								v6 = l
								l++
								*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(v6)*4)) = *(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Ftags + uintptr(j)*4))
							}
							j++
						}
					}
					*(*int32)(unsafe.Pointer((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags + uintptr(l)*4)) = -int32(1)
				}
				p2 += 56
			}
			p1 += 56
		}
	} else {
		/* Compute a maximum limit for the number of transitions leaving
		   from each state. */
		for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition >= 0 {
			p2 = orig_p2
			for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p2)).Fposition >= 0 {
				*(*int32)(unsafe.Pointer(counts + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p1)).Fposition)*4))++
				p2 += 56
			}
			p1 += 56
		}
	}
	return REG_OK
}

// C documentation
//
//	/* Converts the syntax tree to a TNFA.	All the transitions in the TNFA are
//	   labelled with one character range (there are no transitions on empty
//	   strings).  The TNFA takes O(n^2) space in the worst case, `n' is size of
//	   the regexp. */
func _tre_ast_to_tnfa(tls *TLS, node uintptr, transitions uintptr, counts uintptr, offs uintptr) (r Treg_errcode_t) {
	var cat, iter, uni uintptr
	var errcode Treg_errcode_t
	_, _, _, _ = cat, errcode, iter, uni
	errcode = REG_OK
	/* XXX - recurse using a stack!. */
	switch (*Ttre_ast_node_t)(unsafe.Pointer(node)).Ftype1 {
	case int32(_LITERAL):
	case int32(_UNION):
		uni = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_union_t)(unsafe.Pointer(uni)).Fleft, transitions, counts, offs)
		if errcode != REG_OK {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_union_t)(unsafe.Pointer(uni)).Fright, transitions, counts, offs)
	case int32(_CATENATION):
		cat = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		/* Add a transition from each position in cat->left->lastpos
		to each position in cat->right->firstpos. */
		errcode = _tre_make_trans(tls, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright)).Ffirstpos, transitions, counts, offs)
		if errcode != REG_OK {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fleft, transitions, counts, offs)
		if errcode != REG_OK {
			return errcode
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_catenation_t)(unsafe.Pointer(cat)).Fright, transitions, counts, offs)
	case int32(_ITERATION):
		iter = (*Ttre_ast_node_t)(unsafe.Pointer(node)).Fobj
		if (*Ttre_iteration_t)(unsafe.Pointer(iter)).Fmax == -int32(1) {
			/* Add a transition from each last position in the iterated
			   expression to each first position. */
			errcode = _tre_make_trans(tls, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Flastpos, (*Ttre_ast_node_t)(unsafe.Pointer((*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg)).Ffirstpos, transitions, counts, offs)
			if errcode != REG_OK {
				return errcode
			}
		}
		errcode = _tre_ast_to_tnfa(tls, (*Ttre_iteration_t)(unsafe.Pointer(iter)).Farg, transitions, counts, offs)
		break
	}
	return errcode
}

func Xregcomp(tls *TLS, preg uintptr, regex uintptr, cflags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v preg=%v regex=%v cflags=%v, (%v:)", tls, preg, regex, cflags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var add, i, j, v1 int32
	var counts, initial, offs, p, stack, submatch_data, tag_directions, tmp_ast_l, tmp_ast_r, tnfa, transitions, tree, v2 uintptr
	var errcode Treg_errcode_t
	var mem Ttre_mem_t
	var _ /* parse_ctx at bp+0 */ Ttre_parse_ctx_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = add, counts, errcode, i, initial, j, mem, offs, p, stack, submatch_data, tag_directions, tmp_ast_l, tmp_ast_r, tnfa, transitions, tree, v1, v2
	counts = UintptrFromInt32(0)
	offs = UintptrFromInt32(0)
	add = 0
	tnfa = UintptrFromInt32(0)
	tag_directions = UintptrFromInt32(0)
	/* Allocate a stack used throughout the compilation process for various
	   purposes. */
	stack = _tre_stack_new(tls, int32(512), int32(1024000), int32(128))
	if !(stack != 0) {
		return int32(REG_ESPACE)
	}
	/* Allocate a fast memory allocator. */
	mem = X__tre_mem_new_impl(tls, 0, UintptrFromInt32(0))
	if !(mem != 0) {
		_tre_stack_destroy(tls, stack)
		return int32(REG_ESPACE)
	}
	/* Parse the regexp. */
	Xmemset(tls, bp, 0, uint64(56))
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmem = mem
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fstack = stack
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fstart = regex
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fcflags = cflags
	(*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref = -int32(1)
	errcode = _tre_parse(tls, bp)
	if errcode != REG_OK {
		errcode = errcode
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Tregex_t)(unsafe.Pointer(preg)).Fre_nsub = uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id - int32(1))
	tree = (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fn
	/* Referring to nonexistent subexpressions is illegal. */
	if (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref > int32((*Tregex_t)(unsafe.Pointer(preg)).Fre_nsub) {
		errcode = int32(REG_ESUBREG)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	/* Allocate the TNFA struct. */
	tnfa = Xcalloc(tls, uint64(1), uint64(104))
	if tnfa == UintptrFromInt32(0) {
		errcode = int32(REG_ESPACE)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs = BoolInt32((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fmax_backref >= 0)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_approx = 0
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches = uint32((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id)
	/* Set up tags for submatch addressing.  If REG_NOSUB is set and the
	   regexp does not have back references, this can be skipped. */
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs != 0 || !(cflags&Int32FromInt32(REG_NOSUB) != 0) {
		/* Figure out how many tags we will need. */
		errcode = _tre_add_tags(tls, UintptrFromInt32(0), stack, tree, tnfa)
		if errcode != REG_OK {
			errcode = errcode
			if int32(1) != 0 {
				goto error_exit
			}
		}
		if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags > 0 {
			tag_directions = Xmalloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags+Int32FromInt32(1)))
			if tag_directions == UintptrFromInt32(0) {
				errcode = int32(REG_ESPACE)
				if int32(1) != 0 {
					goto error_exit
				}
			}
			(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions = tag_directions
			Xmemset(tls, tag_directions, -int32(1), uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags+Int32FromInt32(1)))
		}
		(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags = Xcalloc(tls, uint64(uint32((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags)*uint32(2)+uint32(1)), uint64(4))
		if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags == UintptrFromInt32(0) {
			errcode = int32(REG_ESPACE)
			if int32(1) != 0 {
				goto error_exit
			}
		}
		submatch_data = Xcalloc(tls, uint64(uint32((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fsubmatch_id)), uint64(16))
		if submatch_data == UintptrFromInt32(0) {
			errcode = int32(REG_ESPACE)
			if int32(1) != 0 {
				goto error_exit
			}
		}
		(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data = submatch_data
		errcode = _tre_add_tags(tls, mem, stack, tree, tnfa)
		if errcode != REG_OK {
			errcode = errcode
			if int32(1) != 0 {
				goto error_exit
			}
		}
	}
	/* Expand iteration nodes. */
	errcode = _tre_expand_ast(tls, mem, stack, tree, bp+44, tag_directions)
	if errcode != REG_OK {
		errcode = errcode
		if int32(1) != 0 {
			goto error_exit
		}
	}
	/* Add a dummy node for the final state.
	     XXX - For certain patterns this dummy node can be optimized away,
		   for example "a*" or "ab*".	Figure out a simple way to detect
		   this possibility. */
	tmp_ast_l = tree
	v2 = bp + 44
	v1 = *(*int32)(unsafe.Pointer(v2))
	*(*int32)(unsafe.Pointer(v2))++
	tmp_ast_r = _tre_ast_new_literal(tls, mem, 0, 0, v1)
	if tmp_ast_r == UintptrFromInt32(0) {
		errcode = int32(REG_ESPACE)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	tree = _tre_ast_new_catenation(tls, mem, tmp_ast_l, tmp_ast_r)
	if tree == UintptrFromInt32(0) {
		errcode = int32(REG_ESPACE)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	errcode = _tre_compute_nfl(tls, mem, stack, tree)
	if errcode != REG_OK {
		errcode = errcode
		if int32(1) != 0 {
			goto error_exit
		}
	}
	counts = Xmalloc(tls, uint64(4)*uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition))
	if counts == UintptrFromInt32(0) {
		errcode = int32(REG_ESPACE)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	offs = Xmalloc(tls, uint64(4)*uint64((*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition))
	if offs == UintptrFromInt32(0) {
		errcode = int32(REG_ESPACE)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	i = 0
	for {
		if !(i < (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition) {
			break
		}
		*(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) = 0
		goto _3
	_3:
		;
		i++
	}
	_tre_ast_to_tnfa(tls, tree, UintptrFromInt32(0), counts, UintptrFromInt32(0))
	add = 0
	i = 0
	for {
		if !(i < (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition) {
			break
		}
		*(*int32)(unsafe.Pointer(offs + uintptr(i)*4)) = add
		add += *(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) + int32(1)
		*(*int32)(unsafe.Pointer(counts + uintptr(i)*4)) = 0
		goto _4
	_4:
		;
		i++
	}
	transitions = Xcalloc(tls, uint64(uint32(add)+uint32(1)), uint64(56))
	if transitions == UintptrFromInt32(0) {
		errcode = int32(REG_ESPACE)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions = transitions
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions = uint32(add)
	errcode = _tre_ast_to_tnfa(tls, tree, transitions, counts, offs)
	if errcode != REG_OK {
		errcode = errcode
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffirstpos_chars = UintptrFromInt32(0)
	p = (*Ttre_ast_node_t)(unsafe.Pointer(tree)).Ffirstpos
	i = 0
	for (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition >= 0 {
		i++
		p += 56
	}
	initial = Xcalloc(tls, uint64(uint32(i)+uint32(1)), uint64(56))
	if initial == UintptrFromInt32(0) {
		errcode = int32(REG_ESPACE)
		if int32(1) != 0 {
			goto error_exit
		}
	}
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial = initial
	i = 0
	p = (*Ttre_ast_node_t)(unsafe.Pointer(tree)).Ffirstpos
	for {
		if !((*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition >= 0) {
			break
		}
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Fstate = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition)*4)))*56
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Fstate_id = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fposition
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Ftags = UintptrFromInt32(0)
		/* Copy the arrays p->tags, and p->params, they are allocated
		from a tre_mem object. */
		if (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags != 0 {
			j = 0
			for {
				if !(*(*int32)(unsafe.Pointer((*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags + uintptr(j)*4)) >= 0) {
					break
				}
				goto _6
			_6:
				;
				j++
			}
			(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Ftags = Xmalloc(tls, uint64(4)*uint64(j+Int32FromInt32(1)))
			if !((*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Ftags != 0) {
				errcode = int32(REG_ESPACE)
				if int32(1) != 0 {
					goto error_exit
				}
			}
			Xmemcpy(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Ftags, (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Ftags, uint64(4)*uint64(j+Int32FromInt32(1)))
		}
		(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Fassertions = (*Ttre_pos_and_tags_t)(unsafe.Pointer(p)).Fassertions
		i++
		goto _5
	_5:
		;
		p += 56
	}
	(*(*Ttre_tnfa_transition_t)(unsafe.Pointer(initial + uintptr(i)*56))).Fstate = UintptrFromInt32(0)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions = uint32(add)
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal = transitions + uintptr(*(*int32)(unsafe.Pointer(offs + uintptr((*(*Ttre_pos_and_tags_t)(unsafe.Pointer((*Ttre_ast_node_t)(unsafe.Pointer(tree)).Flastpos))).Fposition)*4)))*56
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states = (*(*Ttre_parse_ctx_t)(unsafe.Pointer(bp))).Fposition
	(*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags = cflags
	X__tre_mem_destroy(tls, mem)
	_tre_stack_destroy(tls, stack)
	Xfree(tls, counts)
	Xfree(tls, offs)
	(*Tregex_t)(unsafe.Pointer(preg)).F__opaque = tnfa
	return REG_OK
	goto error_exit
error_exit:
	;
	/* Free everything that was allocated and return the error code. */
	X__tre_mem_destroy(tls, mem)
	if stack != UintptrFromInt32(0) {
		_tre_stack_destroy(tls, stack)
	}
	if counts != UintptrFromInt32(0) {
		Xfree(tls, counts)
	}
	if offs != UintptrFromInt32(0) {
		Xfree(tls, offs)
	}
	(*Tregex_t)(unsafe.Pointer(preg)).F__opaque = tnfa
	Xregfree(tls, preg)
	return errcode
}

func Xregfree(tls *TLS, preg uintptr) {
	if __ccgo_strace {
		trc("tls=%v preg=%v, (%v:)", tls, preg, origin(2))
	}
	var i uint32
	var tnfa, trans uintptr
	_, _, _ = i, tnfa, trans
	tnfa = (*Tregex_t)(unsafe.Pointer(preg)).F__opaque
	if !(tnfa != 0) {
		return
	}
	i = uint32(0)
	for {
		if !(i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_transitions) {
			break
		}
		if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Fstate != 0 {
			if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Ftags != 0 {
				Xfree(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Ftags)
			}
			if (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Fneg_classes != 0 {
				Xfree(tls, (*(*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions + uintptr(i)*56))).Fneg_classes)
			}
		}
		goto _1
	_1:
		;
		i++
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions != 0 {
		Xfree(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftransitions)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial != 0 {
		trans = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial
		for {
			if !((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Fstate != 0) {
				break
			}
			if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags != 0 {
				Xfree(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans)).Ftags)
			}
			goto _2
		_2:
			;
			trans += 56
		}
		Xfree(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data != 0 {
		i = uint32(0)
		for {
			if !(i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches) {
				break
			}
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(i)*16))).Fparents != 0 {
				Xfree(tls, (*(*Ttre_submatch_data_t)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data + uintptr(i)*16))).Fparents)
			}
			goto _3
		_3:
			;
			i++
		}
		Xfree(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions != 0 {
		Xfree(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffirstpos_chars != 0 {
		Xfree(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffirstpos_chars)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags != 0 {
		Xfree(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags)
	}
	Xfree(tls, tnfa)
}

/* Error message strings for error codes listed in `regex.h'.  This list
   needs to be in sync with the codes listed there, naturally. */

/* Converted to single string by Rich Felker to remove the need for
 * data relocations at runtime, 27 Feb 2006. */

var _messages = [286]uint8{'N', 'o', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'N', 'o', ' ', 'm', 'a', 't', 'c', 'h', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 'g', 'e', 'x', 'p', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'c', 'o', 'l', 'l', 'a', 't', 'i', 'n', 'g', ' ', 'e', 'l', 'e', 'm', 'e', 'n', 't', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'c', 'l', 'a', 's', 's', ' ', 'n', 'a', 'm', 'e', 0, 'T', 'r', 'a', 'i', 'l', 'i', 'n', 'g', ' ', 'b', 'a', 'c', 'k', 's', 'l', 'a', 's', 'h', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'b', 'a', 'c', 'k', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', '\'', ']', '\'', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', '\'', ')', '\'', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', '\'', '}', '\'', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'o', 'n', 't', 'e', 'n', 't', 's', ' ', 'o', 'f', ' ', '{', '}', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'r', 'a', 'n', 'g', 'e', 0, 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0, 'R', 'e', 'p', 'e', 't', 'i', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e', 'd', ' ', 'b', 'y', ' ', 'v', 'a', 'l', 'i', 'd', ' ', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r'}

func Xregerror(tls *TLS, e int32, preg uintptr, buf uintptr, size Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v e=%v preg=%v buf=%v size=%v, (%v:)", tls, e, preg, buf, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var s uintptr
	_ = s
	s = uintptr(unsafe.Pointer(&_messages))
	for {
		if !(e != 0 && *(*uint8)(unsafe.Pointer(s)) != 0) {
			break
		}
		goto _1
	_1:
		;
		e--
		s += uintptr(Xstrlen(tls, s) + uint64(1))
	}
	if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
		s++
	}
	s = X__lctrans_cur(tls, s)
	return uint64(int32(1) + Xsnprintf(tls, buf, size, __ccgo_ts+15, VaList(bp+8, s)))
}

const tre_bt_mem_alloc = 0
const tre_bt_mem_destroy = 0
const tre_bt_mem_new = 0

/***********************************************************************
 from tre-match-utils.h
***********************************************************************/

// C documentation
//
//	/* Returns 1 if `t1' wins `t2', 0 otherwise. */
func _tre_tag_order(tls *TLS, num_tags int32, tag_directions uintptr, t1 uintptr, t2 uintptr) (r int32) {
	var i int32
	_ = i
	i = 0
	for {
		if !(i < num_tags) {
			break
		}
		if *(*Ttre_tag_direction_t)(unsafe.Pointer(tag_directions + uintptr(i)*4)) == int32(_TRE_TAG_MINIMIZE) {
			if *(*Tregoff_t)(unsafe.Pointer(t1 + uintptr(i)*8)) < *(*Tregoff_t)(unsafe.Pointer(t2 + uintptr(i)*8)) {
				return int32(1)
			}
			if *(*Tregoff_t)(unsafe.Pointer(t1 + uintptr(i)*8)) > *(*Tregoff_t)(unsafe.Pointer(t2 + uintptr(i)*8)) {
				return 0
			}
		} else {
			if *(*Tregoff_t)(unsafe.Pointer(t1 + uintptr(i)*8)) > *(*Tregoff_t)(unsafe.Pointer(t2 + uintptr(i)*8)) {
				return int32(1)
			}
			if *(*Tregoff_t)(unsafe.Pointer(t1 + uintptr(i)*8)) < *(*Tregoff_t)(unsafe.Pointer(t2 + uintptr(i)*8)) {
				return 0
			}
		}
		goto _1
	_1:
		;
		i++
	}
	/*  assert(0);*/
	return 0
}

func _tre_neg_char_classes_match(tls *TLS, classes uintptr, wc Ttre_cint_t, icase int32) (r int32) {
	for *(*Ttre_ctype_t)(unsafe.Pointer(classes)) != Uint64FromInt32(0) {
		if !(icase != 0) && Xiswctype(tls, wc, *(*Ttre_ctype_t)(unsafe.Pointer(classes))) != 0 || icase != 0 && (Xiswctype(tls, Xtowupper(tls, wc), *(*Ttre_ctype_t)(unsafe.Pointer(classes))) != 0 || Xiswctype(tls, Xtowlower(tls, wc), *(*Ttre_ctype_t)(unsafe.Pointer(classes))) != 0) {
			return int32(1)
		} else {
			classes += 8
		}
	}
	return 0 /* No match. */
}

/***********************************************************************
 from tre-match-parallel.c
***********************************************************************/

/*
  This algorithm searches for matches basically by reading characters
  in the searched string one by one, starting at the beginning.	 All
  matching paths in the TNFA are traversed in parallel.	 When two or
  more paths reach the same state, exactly one is chosen according to
  tag ordering rules; if returning submatches is not required it does
  not matter which path is chosen.

  The worst case time required for finding the leftmost and longest
  match, or determining that there is no match, is always linearly
  dependent on the length of the text being searched.

  This algorithm cannot handle TNFAs with back referencing nodes.
  See `tre-match-backtrack.c'.
*/

type Ttre_tnfa_reach_t = struct {
	Fstate uintptr
	Ftags  uintptr
}

type Ttre_reach_pos_t = struct {
	Fpos  Tregoff_t
	Ftags uintptr
}

func _tre_tnfa_run_parallel(tls *TLS, tnfa uintptr, string1 uintptr, match_tags uintptr, eflags int32, match_end_ofs uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var buf, reach, reach_i, reach_next, reach_next_i, reach_pos, str_byte, tag_i, tmp_buf, tmp_iptr, tmp_tags, trans_i uintptr
	var end, i, new_match, num_tags, reg_newline, reg_notbol, reg_noteol, skip, start, v18 int32
	var match_eo, pos, pos_add_next, v10, v7 Tregoff_t
	var pbytes, rbytes, tbytes, total_bytes, xbytes Tsize_t
	var prev_c Ttre_char_t
	var ret Treg_errcode_t
	var v1, v2, v3, v4 uint64
	var _ /* next_c at bp+0 */ Ttre_char_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = buf, end, i, match_eo, new_match, num_tags, pbytes, pos, pos_add_next, prev_c, rbytes, reach, reach_i, reach_next, reach_next_i, reach_pos, reg_newline, reg_notbol, reg_noteol, ret, skip, start, str_byte, tag_i, tbytes, tmp_buf, tmp_iptr, tmp_tags, total_bytes, trans_i, xbytes, v1, v10, v18, v2, v3, v4, v7
	/* State variables required by GET_NEXT_WCHAR. */
	prev_c = uint32(0)
	*(*Ttre_char_t)(unsafe.Pointer(bp)) = uint32(0)
	str_byte = string1
	pos = int64(-int32(1))
	pos_add_next = int64(1)
	reg_notbol = eflags & int32(REG_NOTBOL)
	reg_noteol = eflags & int32(REG_NOTEOL)
	reg_newline = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags & int32(REG_NEWLINE)
	match_eo = int64(-int32(1)) /* end offset of match (-1 if no match found yet) */
	new_match = 0
	tmp_tags = UintptrFromInt32(0)
	if !(match_tags != 0) {
		num_tags = 0
	} else {
		num_tags = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags
	}
	/* Allocate memory for temporary data required for matching.	This needs to
	   be done for every matching operation to be thread safe.  This allocates
	   everything in a single large block with calloc(). */
	/* Ensure that tbytes and xbytes*num_states cannot overflow, and that
	 * they don't contribute more than 1/8 of SIZE_MAX to total_bytes. */
	if uint64(num_tags) > uint64(0xffffffffffffffff)/(Uint64FromInt32(8)*Uint64FromInt64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states)) {
		return int32(REG_ESPACE)
	}
	/* Likewise check rbytes. */
	if uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states+int32(1)) > Uint64FromUint64(0xffffffffffffffff)/(Uint64FromInt32(8)*Uint64FromInt64(16)) {
		return int32(REG_ESPACE)
	}
	/* Likewise check pbytes. */
	if uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states) > Uint64FromUint64(0xffffffffffffffff)/(Uint64FromInt32(8)*Uint64FromInt64(16)) {
		return int32(REG_ESPACE)
	}
	/* Compute the length of the block we need. */
	tbytes = uint64(8) * uint64(num_tags)
	rbytes = uint64(16) * uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states+Int32FromInt32(1))
	pbytes = uint64(16) * uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states)
	xbytes = uint64(8) * uint64(num_tags)
	total_bytes = (Uint64FromInt64(8)-Uint64FromInt32(1))*Uint64FromInt32(4) + (rbytes+xbytes*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states))*uint64(2) + tbytes + pbytes
	/* Allocate the memory. */
	buf = Xcalloc(tls, total_bytes, uint64(1))
	if buf == UintptrFromInt32(0) {
		return int32(REG_ESPACE)
	}
	/* Get the various pointers within tmp_buf (properly aligned). */
	tmp_tags = buf
	tmp_buf = buf + uintptr(tbytes)
	if uint64(int64(tmp_buf))%uint64(8) != 0 {
		v1 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
	} else {
		v1 = uint64(0)
	}
	tmp_buf += uintptr(v1)
	reach_next = tmp_buf
	tmp_buf += uintptr(rbytes)
	if uint64(int64(tmp_buf))%uint64(8) != 0 {
		v2 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
	} else {
		v2 = uint64(0)
	}
	tmp_buf += uintptr(v2)
	reach = tmp_buf
	tmp_buf += uintptr(rbytes)
	if uint64(int64(tmp_buf))%uint64(8) != 0 {
		v3 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
	} else {
		v3 = uint64(0)
	}
	tmp_buf += uintptr(v3)
	reach_pos = tmp_buf
	tmp_buf += uintptr(pbytes)
	if uint64(int64(tmp_buf))%uint64(8) != 0 {
		v4 = uint64(8) - uint64(int64(tmp_buf))%uint64(8)
	} else {
		v4 = uint64(0)
	}
	tmp_buf += uintptr(v4)
	i = 0
	for {
		if !(i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states) {
			break
		}
		(*(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach + uintptr(i)*16))).Ftags = tmp_buf
		tmp_buf += uintptr(xbytes)
		(*(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next + uintptr(i)*16))).Ftags = tmp_buf
		tmp_buf += uintptr(xbytes)
		goto _5
	_5:
		;
		i++
	}
	i = 0
	for {
		if !(i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states) {
			break
		}
		(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr(i)*16))).Fpos = int64(-int32(1))
		goto _6
	_6:
		;
		i++
	}
	prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
	pos += pos_add_next
	v7 = int64(Xmbtowc(tls, bp, str_byte, uint64(MB_LEN_MAX)))
	pos_add_next = v7
	if v7 <= 0 {
		if pos_add_next < 0 {
			ret = int32(REG_NOMATCH)
			goto error_exit
		} else {
			pos_add_next++
		}
	}
	str_byte += uintptr(pos_add_next)
	pos = 0
	reach_next_i = reach_next
	for int32(1) != 0 {
		/* If no match found yet, add the initial states to `reach_next'. */
		if match_eo < 0 {
			trans_i = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial
			for (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != UintptrFromInt32(0) {
				if (*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos < pos {
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_BOL) != 0 && (pos > 0 || reg_notbol != 0) && (prev_c != uint32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_EOL) != 0 && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\000') || reg_noteol != 0) && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_BOW) != 0 && (prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0 || !(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_EOW) != 0 && (!(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) || (*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_WB) != 0 && (pos != 0 && *(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\000') && BoolInt32(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) == BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_WB_NEG) != 0 && (pos == 0 || *(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('\000') || BoolInt32(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) != BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0))) {
						trans_i += 56
						continue
					}
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
					i = 0
					for {
						if !(i < num_tags) {
							break
						}
						*(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*8)) = int64(-int32(1))
						goto _8
					_8:
						;
						i++
					}
					tag_i = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
					if tag_i != 0 {
						for *(*int32)(unsafe.Pointer(tag_i)) >= 0 {
							if *(*int32)(unsafe.Pointer(tag_i)) < num_tags {
								*(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(*(*int32)(unsafe.Pointer(tag_i)))*8)) = pos
							}
							tag_i += 4
						}
					}
					if (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
						match_eo = pos
						new_match = int32(1)
						i = 0
						for {
							if !(i < num_tags) {
								break
							}
							*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i)*8)) = *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*8))
							goto _9
						_9:
							;
							i++
						}
					}
					(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos = pos
					(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags = reach_next_i + 8
					reach_next_i += 16
				}
				trans_i += 56
			}
			(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = UintptrFromInt32(0)
		} else {
			if num_tags == 0 || reach_next_i == reach_next {
				/* We have found a match. */
				break
			}
		}
		/* Check for end of string. */
		if !(*(*Ttre_char_t)(unsafe.Pointer(bp)) != 0) {
			break
		}
		prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
		pos += pos_add_next
		v10 = int64(Xmbtowc(tls, bp, str_byte, uint64(MB_LEN_MAX)))
		pos_add_next = v10
		if v10 <= 0 {
			if pos_add_next < 0 {
				ret = int32(REG_NOMATCH)
				goto error_exit
			} else {
				pos_add_next++
			}
		}
		str_byte += uintptr(pos_add_next)
		/* Swap `reach' and `reach_next'. */
		reach_i = reach
		reach = reach_next
		reach_next = reach_i
		/* For each state in `reach', weed out states that don't fulfill the
		minimal matching conditions. */
		if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_minimals != 0 && new_match != 0 {
			new_match = 0
			reach_next_i = reach_next
			reach_i = reach
			for {
				if !((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate != 0) {
					break
				}
				skip = 0
				i = 0
				for {
					if !(*(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i)*4)) >= 0) {
						break
					}
					end = *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i)*4))
					start = *(*int32)(unsafe.Pointer((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fminimal_tags + uintptr(i+int32(1))*4))
					if end >= num_tags {
						skip = int32(1)
						break
					} else {
						if *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags + uintptr(start)*8)) == *(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(start)*8)) && *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags + uintptr(end)*8)) < *(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(end)*8)) {
							skip = int32(1)
							break
						}
					}
					goto _12
				_12:
					;
					i += int32(2)
				}
				if !(skip != 0) {
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate
					tmp_iptr = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags
					(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags = tmp_iptr
					reach_next_i += 16
				}
				goto _11
			_11:
				;
				reach_i += 16
			}
			(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = UintptrFromInt32(0)
			/* Swap `reach' and `reach_next'. */
			reach_i = reach
			reach = reach_next
			reach_next = reach_i
		}
		/* For each state in `reach' see if there is a transition leaving with
		the current input symbol to a state not yet in `reach_next', and
		add the destination states to `reach_next'. */
		reach_next_i = reach_next
		reach_i = reach
		for {
			if !((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate != 0) {
				break
			}
			trans_i = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Fstate
			for {
				if !((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0) {
					break
				}
				/* Does this transition match the input symbol? */
				if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_min <= prev_c && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_max >= prev_c {
					if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_BOL) != 0 && (pos > 0 || reg_notbol != 0) && (prev_c != uint32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_EOL) != 0 && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\000') || reg_noteol != 0) && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_BOW) != 0 && (prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0 || !(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_EOW) != 0 && (!(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) || (*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_WB) != 0 && (pos != 0 && *(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\000') && BoolInt32(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) == BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_WB_NEG) != 0 && (pos == 0 || *(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('\000') || BoolInt32(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) != BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_CHAR_CLASS) != 0 && !((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&Int32FromInt32(REG_ICASE) != 0) && !(Xiswctype(tls, prev_c, *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_CHAR_CLASS) != 0 && (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(REG_ICASE) != 0 && !(Xiswctype(tls, Xtowlower(tls, prev_c), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) && !(Xiswctype(tls, Xtowupper(tls, prev_c), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_CHAR_CLASS_NEG) != 0 && _tre_neg_char_classes_match(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fneg_classes, prev_c, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(REG_ICASE)) != 0)) {
						goto _14
					}
					/* Compute the tags after this transition. */
					i = 0
					for {
						if !(i < num_tags) {
							break
						}
						*(*Tregoff_t)(unsafe.Pointer(tmp_tags + uintptr(i)*8)) = *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_i)).Ftags + uintptr(i)*8))
						goto _15
					_15:
						;
						i++
					}
					tag_i = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
					if tag_i != UintptrFromInt32(0) {
						for *(*int32)(unsafe.Pointer(tag_i)) >= 0 {
							if *(*int32)(unsafe.Pointer(tag_i)) < num_tags {
								*(*Tregoff_t)(unsafe.Pointer(tmp_tags + uintptr(*(*int32)(unsafe.Pointer(tag_i)))*8)) = pos
							}
							tag_i += 4
						}
					}
					if (*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos < pos {
						/* Found an unvisited node. */
						(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
						tmp_iptr = (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags
						(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags = tmp_tags
						tmp_tags = tmp_iptr
						(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Fpos = pos
						(*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags = reach_next_i + 8
						if (*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal && (match_eo == int64(-int32(1)) || num_tags > 0 && *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags)) <= *(*Tregoff_t)(unsafe.Pointer(match_tags))) {
							match_eo = pos
							new_match = int32(1)
							i = 0
							for {
								if !(i < num_tags) {
									break
								}
								*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i)*8)) = *(*Tregoff_t)(unsafe.Pointer((*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Ftags + uintptr(i)*8))
								goto _16
							_16:
								;
								i++
							}
						}
						reach_next_i += 16
					} else {
						/* Another path has also reached this state.  We choose
						the winner by examining the tag values for both
						paths. */
						if _tre_tag_order(tls, num_tags, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions, tmp_tags, *(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags))) != 0 {
							/* The new path wins. */
							tmp_iptr = *(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags))
							*(*uintptr)(unsafe.Pointer((*(*Ttre_reach_pos_t)(unsafe.Pointer(reach_pos + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*16))).Ftags)) = tmp_tags
							if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
								match_eo = pos
								new_match = int32(1)
								i = 0
								for {
									if !(i < num_tags) {
										break
									}
									*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i)*8)) = *(*Tregoff_t)(unsafe.Pointer(tmp_tags + uintptr(i)*8))
									goto _17
								_17:
									;
									i++
								}
							}
							tmp_tags = tmp_iptr
						}
					}
				}
				goto _14
			_14:
				;
				trans_i += 56
			}
			goto _13
		_13:
			;
			reach_i += 16
		}
		(*Ttre_tnfa_reach_t)(unsafe.Pointer(reach_next_i)).Fstate = UintptrFromInt32(0)
	}
	*(*Tregoff_t)(unsafe.Pointer(match_end_ofs)) = match_eo
	if match_eo >= 0 {
		v18 = REG_OK
	} else {
		v18 = int32(REG_NOMATCH)
	}
	ret = v18
	goto error_exit
error_exit:
	;
	Xfree(tls, buf)
	return ret
}

/***********************************************************************
 from tre-match-backtrack.c
***********************************************************************/

/*
  This matcher is for regexps that use back referencing.  Regexp matching
  with back referencing is an NP-complete problem on the number of back
  references.  The easiest way to match them is to use a backtracking
  routine which basically goes through all possible paths in the TNFA
  and chooses the one which results in the best (leftmost and longest)
  match.  This can be spectacularly expensive and may run out of stack
  space, but there really is no better known generic algorithm.	 Quoting
  Henry Spencer from comp.compilers:
  <URL: http://compilers.iecc.com/comparch/article/93-03-102>

    POSIX.2 REs require longest match, which is really exciting to
    implement since the obsolete ("basic") variant also includes
    \<digit>.  I haven't found a better way of tackling this than doing
    a preliminary match using a DFA (or simulation) on a modified RE
    that just replicates subREs for \<digit>, and then doing a
    backtracking match to determine whether the subRE matches were
    right.  This can be rather slow, but I console myself with the
    thought that people who use \<digit> deserve very slow execution.
    (Pun unintentional but very appropriate.)

*/

type Ttre_backtrack_item_t = struct {
	Fpos      Tregoff_t
	Fstr_byte uintptr
	Fstate    uintptr
	Fstate_id int32
	Fnext_c   int32
	Ftags     uintptr
}

type Ttre_backtrack_t = uintptr

type Ttre_backtrack_struct = struct {
	Fitem Ttre_backtrack_item_t
	Fprev uintptr
	Fnext uintptr
}

func _tre_tnfa_run_backtrack(tls *TLS, tnfa uintptr, string1 uintptr, match_tags uintptr, eflags int32, match_end_ofs uintptr) (r Treg_errcode_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var bt, empty_br_match, i, i1, i2, i3, i4, next_c_start, reg_newline, reg_notbol, reg_noteol, result, ret, v20 int32
	var bt_len, eo, match_eo, pos, pos_add_next, pos_start, so, v11, v12, v3 Tregoff_t
	var mem Ttre_mem_t
	var next_state, next_tags, pmatch, state, states_seen, str_byte, str_byte_start, tags, tmp, tmp1, trans_i, v18, v6 uintptr
	var prev_c Ttre_char_t
	var s, s1, stack Ttre_backtrack_t
	var _ /* next_c at bp+0 */ Ttre_char_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = bt, bt_len, empty_br_match, eo, i, i1, i2, i3, i4, match_eo, mem, next_c_start, next_state, next_tags, pmatch, pos, pos_add_next, pos_start, prev_c, reg_newline, reg_notbol, reg_noteol, result, ret, s, s1, so, stack, state, states_seen, str_byte, str_byte_start, tags, tmp, tmp1, trans_i, v11, v12, v18, v20, v3, v6
	/* State variables required by GET_NEXT_WCHAR. */
	prev_c = uint32(0)
	*(*Ttre_char_t)(unsafe.Pointer(bp)) = uint32(0)
	str_byte = string1
	pos = 0
	pos_add_next = int64(1)
	reg_notbol = eflags & int32(REG_NOTBOL)
	reg_noteol = eflags & int32(REG_NOTEOL)
	reg_newline = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags & int32(REG_NEWLINE)
	pos_start = int64(-int32(1))
	/* End offset of best match so far, or -1 if no match found yet. */
	match_eo = int64(-int32(1))
	tags = UintptrFromInt32(0)
	states_seen = UintptrFromInt32(0)
	/* Memory allocator to for allocating the backtracking stack. */
	mem = X__tre_mem_new_impl(tls, 0, UintptrFromInt32(0))
	pmatch = UintptrFromInt32(0)
	if !(mem != 0) {
		return int32(REG_ESPACE)
	}
	stack = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(56))
	if !(stack != 0) {
		ret = int32(REG_ESPACE)
		goto error_exit
	}
	(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev = UintptrFromInt32(0)
	(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = UintptrFromInt32(0)
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags != 0 {
		tags = Xmalloc(tls, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
		if !(tags != 0) {
			ret = int32(REG_ESPACE)
			goto error_exit
		}
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches != 0 {
		pmatch = Xmalloc(tls, uint64(16)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches))
		if !(pmatch != 0) {
			ret = int32(REG_ESPACE)
			goto error_exit
		}
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states != 0 {
		states_seen = Xmalloc(tls, uint64(4)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states))
		if !(states_seen != 0) {
			ret = int32(REG_ESPACE)
			goto error_exit
		}
	}
	goto retry
retry:
	;
	i = 0
	for {
		if !(i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags) {
			break
		}
		*(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i)*8)) = int64(-int32(1))
		if match_tags != 0 {
			*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i)*8)) = int64(-int32(1))
		}
		goto _1
	_1:
		;
		i++
	}
	i = 0
	for {
		if !(i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_states) {
			break
		}
		*(*int32)(unsafe.Pointer(states_seen + uintptr(i)*4)) = 0
		goto _2
	_2:
		;
		i++
	}
	state = UintptrFromInt32(0)
	pos = pos_start
	prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
	pos += pos_add_next
	v3 = int64(Xmbtowc(tls, bp, str_byte, uint64(MB_LEN_MAX)))
	pos_add_next = v3
	if v3 <= 0 {
		if pos_add_next < 0 {
			ret = int32(REG_NOMATCH)
			goto error_exit
		} else {
			pos_add_next++
		}
	}
	str_byte += uintptr(pos_add_next)
	pos_start = pos
	next_c_start = int32(*(*Ttre_char_t)(unsafe.Pointer(bp)))
	str_byte_start = str_byte
	/* Handle initial states. */
	next_tags = UintptrFromInt32(0)
	trans_i = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Finitial
	for {
		if !((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0) {
			break
		}
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_BOL) != 0 && (pos > 0 || reg_notbol != 0) && (prev_c != uint32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_EOL) != 0 && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\000') || reg_noteol != 0) && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_BOW) != 0 && (prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0 || !(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_EOW) != 0 && (!(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) || (*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_WB) != 0 && (pos != 0 && *(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\000') && BoolInt32(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) == BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_WB_NEG) != 0 && (pos == 0 || *(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('\000') || BoolInt32(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) != BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0))) {
			goto _4
		}
		if state == UintptrFromInt32(0) {
			/* Start from this state. */
			state = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
			next_tags = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
		} else {
			/* Backtrack to this state. */
			if !((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext != 0) {
				s = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(56))
				if !(s != 0) {
					X__tre_mem_destroy(tls, mem)
					if tags != 0 {
						Xfree(tls, tags)
					}
					if pmatch != 0 {
						Xfree(tls, pmatch)
					}
					if states_seen != 0 {
						Xfree(tls, states_seen)
					}
					return int32(REG_ESPACE)
				}
				(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fprev = stack
				(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fnext = UintptrFromInt32(0)
				(*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fitem.Ftags = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
				if !((*Ttre_backtrack_struct)(unsafe.Pointer(s)).Fitem.Ftags != 0) {
					X__tre_mem_destroy(tls, mem)
					if tags != 0 {
						Xfree(tls, tags)
					}
					if pmatch != 0 {
						Xfree(tls, pmatch)
					}
					if states_seen != 0 {
						Xfree(tls, states_seen)
					}
					return int32(REG_ESPACE)
				}
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = s
				stack = s
			} else {
				stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext
			}
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos = pos
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte = str_byte
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id
			(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c = int32(*(*Ttre_char_t)(unsafe.Pointer(bp)))
			i1 = 0
			for {
				if !(i1 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags) {
					break
				}
				*(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i1)*8)) = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i1)*8))
				goto _5
			_5:
				;
				i1++
			}
			tmp = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
			if tmp != 0 {
				for *(*int32)(unsafe.Pointer(tmp)) >= 0 {
					v6 = tmp
					tmp += 4
					*(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(*(*int32)(unsafe.Pointer(v6)))*8)) = pos
				}
			}
		}
		goto _4
	_4:
		;
		trans_i += 56
	}
	if next_tags != 0 {
		for {
			if !(*(*int32)(unsafe.Pointer(next_tags)) >= 0) {
				break
			}
			*(*Tregoff_t)(unsafe.Pointer(tags + uintptr(*(*int32)(unsafe.Pointer(next_tags)))*8)) = pos
			goto _7
		_7:
			;
			next_tags += 4
		}
	}
	if state == UintptrFromInt32(0) {
		goto backtrack
	}
_9:
	;
	if !(int32(1) != 0) {
		goto _8
	}
	if state == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ffinal {
		if match_eo < pos || match_eo == pos && match_tags != 0 && _tre_tag_order(tls, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Ftag_directions, tags, match_tags) != 0 {
			/* This match wins the previous match. */
			match_eo = pos
			if match_tags != 0 {
				i2 = 0
				for {
					if !(i2 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags) {
						break
					}
					*(*Tregoff_t)(unsafe.Pointer(match_tags + uintptr(i2)*8)) = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i2)*8))
					goto _10
				_10:
					;
					i2++
				}
			}
		}
		/* Our TNFAs never have transitions leaving from the final state,
		   so we jump right to backtracking. */
		goto backtrack
	}
	/* Go to the next character in the input string. */
	empty_br_match = 0
	trans_i = state
	if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0 && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_BACKREF) != 0 {
		bt = *(*int32)(unsafe.Pointer(&(*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fu))
		/* Get the substring we need to match against.  Remember to
		   turn off REG_NOSUB temporarily. */
		_tre_fill_pmatch(tls, uint64(bt+int32(1)), pmatch, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags & ^Int32FromInt32(REG_NOSUB), tnfa, tags, pos)
		so = (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(bt)*16))).Frm_so
		eo = (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(bt)*16))).Frm_eo
		bt_len = eo - so
		result = Xstrncmp(tls, string1+uintptr(so), str_byte-uintptr(1), uint64(bt_len))
		if result == 0 {
			/* Back reference matched.  Check for infinite loop. */
			if bt_len == 0 {
				empty_br_match = int32(1)
			}
			if empty_br_match != 0 && *(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*4)) != 0 {
				goto backtrack
			}
			*(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id)*4)) = empty_br_match
			/* Advance in input string and resync `prev_c', `next_c'
			and pos. */
			str_byte += uintptr(bt_len - int64(1))
			pos += bt_len - int64(1)
			prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
			pos += pos_add_next
			v11 = int64(Xmbtowc(tls, bp, str_byte, uint64(MB_LEN_MAX)))
			pos_add_next = v11
			if v11 <= 0 {
				if pos_add_next < 0 {
					ret = int32(REG_NOMATCH)
					goto error_exit
				} else {
					pos_add_next++
				}
			}
			str_byte += uintptr(pos_add_next)
		} else {
			goto backtrack
		}
	} else {
		/* Check for end of string. */
		if *(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('\000') {
			goto backtrack
		}
		/* Read the next character. */
		prev_c = *(*Ttre_char_t)(unsafe.Pointer(bp))
		pos += pos_add_next
		v12 = int64(Xmbtowc(tls, bp, str_byte, uint64(MB_LEN_MAX)))
		pos_add_next = v12
		if v12 <= 0 {
			if pos_add_next < 0 {
				ret = int32(REG_NOMATCH)
				goto error_exit
			} else {
				pos_add_next++
			}
		}
		str_byte += uintptr(pos_add_next)
	}
	next_state = UintptrFromInt32(0)
	trans_i = state
	for {
		if !((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate != 0) {
			break
		}
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_min <= prev_c && (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fcode_max >= prev_c {
			if (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions != 0 && ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_BOL) != 0 && (pos > 0 || reg_notbol != 0) && (prev_c != uint32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_EOL) != 0 && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\000') || reg_noteol != 0) && (*(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\n') || !(reg_newline != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_BOW) != 0 && (prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0 || !(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_EOW) != 0 && (!(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) || (*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_WB) != 0 && (pos != 0 && *(*Ttre_char_t)(unsafe.Pointer(bp)) != uint32('\000') && BoolInt32(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) == BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_AT_WB_NEG) != 0 && (pos == 0 || *(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('\000') || BoolInt32(prev_c == uint32('_') || Xiswalnum(tls, prev_c) != 0) != BoolInt32(*(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('_') || Xiswalnum(tls, *(*Ttre_char_t)(unsafe.Pointer(bp))) != 0)) || ((*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_CHAR_CLASS) != 0 && !((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&Int32FromInt32(REG_ICASE) != 0) && !(Xiswctype(tls, prev_c, *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_CHAR_CLASS) != 0 && (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(REG_ICASE) != 0 && !(Xiswctype(tls, Xtowlower(tls, prev_c), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) && !(Xiswctype(tls, Xtowupper(tls, prev_c), *(*Ttre_ctype_t)(unsafe.Pointer(trans_i + 40))) != 0) || (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fassertions&int32(ASSERT_CHAR_CLASS_NEG) != 0 && _tre_neg_char_classes_match(tls, (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fneg_classes, prev_c, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(REG_ICASE)) != 0)) {
				goto _13
			}
			if next_state == UintptrFromInt32(0) {
				/* First matching transition. */
				next_state = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
				next_tags = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
			} else {
				/* Second matching transition.  We may need to backtrack here
				   to take this transition instead of the first one, so we
				   push this transition in the backtracking stack so we can
				   jump back here if needed. */
				if !((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext != 0) {
					s1 = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(56))
					if !(s1 != 0) {
						X__tre_mem_destroy(tls, mem)
						if tags != 0 {
							Xfree(tls, tags)
						}
						if pmatch != 0 {
							Xfree(tls, pmatch)
						}
						if states_seen != 0 {
							Xfree(tls, states_seen)
						}
						return int32(REG_ESPACE)
					}
					(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fprev = stack
					(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fnext = UintptrFromInt32(0)
					(*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fitem.Ftags = X__tre_mem_alloc_impl(tls, mem, 0, UintptrFromInt32(0), 0, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
					if !((*Ttre_backtrack_struct)(unsafe.Pointer(s1)).Fitem.Ftags != 0) {
						X__tre_mem_destroy(tls, mem)
						if tags != 0 {
							Xfree(tls, tags)
						}
						if pmatch != 0 {
							Xfree(tls, pmatch)
						}
						if states_seen != 0 {
							Xfree(tls, states_seen)
						}
						return int32(REG_ESPACE)
					}
					(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext = s1
					stack = s1
				} else {
					stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fnext
				}
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos = pos
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte = str_byte
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Fstate_id
				(*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c = int32(*(*Ttre_char_t)(unsafe.Pointer(bp)))
				i3 = 0
				for {
					if !(i3 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags) {
						break
					}
					*(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i3)*8)) = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i3)*8))
					goto _14
				_14:
					;
					i3++
				}
				tmp1 = (*Ttre_tnfa_transition_t)(unsafe.Pointer(trans_i)).Ftags
				for {
					if !(tmp1 != 0 && *(*int32)(unsafe.Pointer(tmp1)) >= 0) {
						break
					}
					*(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(*(*int32)(unsafe.Pointer(tmp1)))*8)) = pos
					goto _15
				_15:
					;
					tmp1 += 4
				}
			}
		}
		goto _13
	_13:
		;
		trans_i += 56
	}
	if !(next_state != UintptrFromInt32(0)) {
		goto _16
	}
	/* Matching transitions were found.  Take the first one. */
	state = next_state
	/* Update the tag values. */
	if next_tags != 0 {
		for *(*int32)(unsafe.Pointer(next_tags)) >= 0 {
			v18 = next_tags
			next_tags += 4
			*(*Tregoff_t)(unsafe.Pointer(tags + uintptr(*(*int32)(unsafe.Pointer(v18)))*8)) = pos
		}
	}
	goto _17
_16:
	;
	goto backtrack
backtrack:
	;
	/* A matching transition was not found.  Try to backtrack. */
	if (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev != 0 {
		if (*Ttre_tnfa_transition_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate)).Fassertions&int32(ASSERT_BACKREF) != 0 {
			*(*int32)(unsafe.Pointer(states_seen + uintptr((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate_id)*4)) = 0
		}
		pos = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fpos
		str_byte = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstr_byte
		state = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fstate
		*(*Ttre_char_t)(unsafe.Pointer(bp)) = uint32((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Fnext_c)
		i4 = 0
		for {
			if !(i4 < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags) {
				break
			}
			*(*Tregoff_t)(unsafe.Pointer(tags + uintptr(i4)*8)) = *(*Tregoff_t)(unsafe.Pointer((*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fitem.Ftags + uintptr(i4)*8))
			goto _19
		_19:
			;
			i4++
		}
		stack = (*Ttre_backtrack_struct)(unsafe.Pointer(stack)).Fprev
	} else {
		if match_eo < 0 {
			/* Try starting from a later position in the input string. */
			/* Check for end of string. */
			if *(*Ttre_char_t)(unsafe.Pointer(bp)) == uint32('\000') {
				goto _8
			}
			*(*Ttre_char_t)(unsafe.Pointer(bp)) = uint32(next_c_start)
			str_byte = str_byte_start
			goto retry
		} else {
			goto _8
		}
	}
_17:
	;
	goto _9
_8:
	;
	if match_eo >= 0 {
		v20 = REG_OK
	} else {
		v20 = int32(REG_NOMATCH)
	}
	ret = v20
	*(*Tregoff_t)(unsafe.Pointer(match_end_ofs)) = match_eo
	goto error_exit
error_exit:
	;
	X__tre_mem_destroy(tls, mem)
	if tags != 0 {
		Xfree(tls, tags)
	}
	if pmatch != 0 {
		Xfree(tls, pmatch)
	}
	if states_seen != 0 {
		Xfree(tls, states_seen)
	}
	return ret
}

/***********************************************************************
 from regexec.c
***********************************************************************/

// C documentation
//
//	/* Fills the POSIX.2 regmatch_t array according to the TNFA tag and match
//	   endpoint values. */
func _tre_fill_pmatch(tls *TLS, nmatch Tsize_t, pmatch uintptr, cflags int32, tnfa uintptr, tags uintptr, match_eo Tregoff_t) {
	var i, j uint32
	var parents, submatch_data uintptr
	var v1, v3 Tregoff_t
	_, _, _, _, _, _ = i, j, parents, submatch_data, v1, v3
	i = uint32(0)
	if match_eo >= 0 && !(cflags&Int32FromInt32(REG_NOSUB) != 0) {
		/* Construct submatch offsets from the tags. */
		submatch_data = (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fsubmatch_data
		for i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches && uint64(i) < nmatch {
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fso_tag == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = match_eo
			} else {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr((*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fso_tag)*8))
			}
			if (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Feo_tag == (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fend_tag {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = match_eo
			} else {
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = *(*Tregoff_t)(unsafe.Pointer(tags + uintptr((*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Feo_tag)*8))
			}
			/* If either of the endpoints were not used, this submatch
			   was not part of the match. */
			if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so == int64(-int32(1)) || (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo == int64(-int32(1)) {
				v1 = int64(-Int32FromInt32(1))
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = v1
				(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = v1
			}
			i++
		}
		/* Reset all submatches that are not within all of their parent
		submatches. */
		i = uint32(0)
		for i < (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_submatches && uint64(i) < nmatch {
			if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo == int64(-int32(1)) {
			}
			parents = (*(*Ttre_submatch_data_t)(unsafe.Pointer(submatch_data + uintptr(i)*16))).Fparents
			if parents != UintptrFromInt32(0) {
				j = uint32(0)
				for {
					if !(*(*int32)(unsafe.Pointer(parents + uintptr(j)*4)) >= 0) {
						break
					}
					if (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so < (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(*(*int32)(unsafe.Pointer(parents + uintptr(j)*4)))*16))).Frm_so || (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo > (*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(*(*int32)(unsafe.Pointer(parents + uintptr(j)*4)))*16))).Frm_eo {
						v3 = int64(-Int32FromInt32(1))
						(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = v3
						(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = v3
					}
					goto _2
				_2:
					;
					j++
				}
			}
			i++
		}
	}
	for uint64(i) < nmatch {
		(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_so = int64(-int32(1))
		(*(*Tregmatch_t)(unsafe.Pointer(pmatch + uintptr(i)*16))).Frm_eo = int64(-int32(1))
		i++
	}
}

/*
  Wrapper functions for POSIX compatible regexp matching.
*/

func Xregexec(tls *TLS, preg uintptr, string1 uintptr, nmatch Tsize_t, pmatch uintptr, eflags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v preg=%v string1=%v nmatch=%v pmatch=%v eflags=%v, (%v:)", tls, preg, string1, nmatch, pmatch, eflags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var status Treg_errcode_t
	var tags, tnfa uintptr
	var _ /* eo at bp+0 */ Tregoff_t
	_, _, _ = status, tags, tnfa
	tnfa = (*Tregex_t)(unsafe.Pointer(preg)).F__opaque
	tags = UintptrFromInt32(0)
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags&int32(REG_NOSUB) != 0 {
		nmatch = uint64(0)
	}
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags > 0 && nmatch > uint64(0) {
		tags = Xmalloc(tls, uint64(8)*uint64((*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fnum_tags))
		if tags == UintptrFromInt32(0) {
			return int32(REG_ESPACE)
		}
	}
	/* Dispatch to the appropriate matcher. */
	if (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fhave_backrefs != 0 {
		/* The regex has back references, use the backtracking matcher. */
		status = _tre_tnfa_run_backtrack(tls, tnfa, string1, tags, eflags, bp)
	} else {
		/* Exact matching, no back references, use the parallel matcher. */
		status = _tre_tnfa_run_parallel(tls, tnfa, string1, tags, eflags, bp)
	}
	if status == REG_OK {
		/* A match was found, so fill the submatch registers. */
		_tre_fill_pmatch(tls, nmatch, pmatch, (*Ttre_tnfa_t)(unsafe.Pointer(tnfa)).Fcflags, tnfa, tags, *(*Tregoff_t)(unsafe.Pointer(bp)))
	}
	if tags != 0 {
		Xfree(tls, tags)
	}
	return status
}

/*
  This memory allocator is for allocating small memory blocks efficiently
  in terms of memory overhead and execution speed.  The allocated blocks
  cannot be freed individually, only all at once.  There can be multiple
  allocators, though.
*/

// C documentation
//
//	/* Returns a new memory allocator or NULL if out of memory. */
func X__tre_mem_new_impl(tls *TLS, provided int32, provided_block uintptr) (r Ttre_mem_t) {
	if __ccgo_strace {
		trc("tls=%v provided=%v provided_block=%v, (%v:)", tls, provided, provided_block, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var mem Ttre_mem_t
	_ = mem
	if provided != 0 {
		mem = provided_block
		Xmemset(tls, mem, 0, uint64(48))
	} else {
		mem = Xcalloc(tls, uint64(1), uint64(48))
	}
	if mem == UintptrFromInt32(0) {
		return UintptrFromInt32(0)
	}
	return mem
}

// C documentation
//
//	/* Frees the memory allocator and all memory allocated with it. */
func X__tre_mem_destroy(tls *TLS, mem Ttre_mem_t) {
	if __ccgo_strace {
		trc("tls=%v mem=%v, (%v:)", tls, mem, origin(2))
	}
	var l, tmp uintptr
	_, _ = l, tmp
	l = (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks
	for l != UintptrFromInt32(0) {
		Xfree(tls, (*Ttre_list_t)(unsafe.Pointer(l)).Fdata)
		tmp = (*Ttre_list_t)(unsafe.Pointer(l)).Fnext
		Xfree(tls, l)
		l = tmp
	}
	Xfree(tls, mem)
}

// C documentation
//
//	/* Allocates a block of `size' bytes from `mem'.  Returns a pointer to the
//	   allocated block or NULL if an underlying malloc() failed. */
func X__tre_mem_alloc_impl(tls *TLS, mem Ttre_mem_t, provided int32, provided_block uintptr, zero int32, size Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v mem=%v provided=%v provided_block=%v zero=%v size=%v, (%v:)", tls, mem, provided, provided_block, zero, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var block_size int32
	var l, ptr uintptr
	var v1 uint64
	_, _, _, _ = block_size, l, ptr, v1
	if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed != 0 {
		return UintptrFromInt32(0)
	}
	if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn < size {
		if provided != 0 {
			if provided_block == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr = provided_block
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn = uint64(TRE_MEM_BLOCK_SIZE)
		} else {
			if size*uint64(8) > uint64(TRE_MEM_BLOCK_SIZE) {
				block_size = int32(size * uint64(8))
			} else {
				block_size = int32(TRE_MEM_BLOCK_SIZE)
			}
			l = Xmalloc(tls, uint64(16))
			if l == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_list_t)(unsafe.Pointer(l)).Fdata = Xmalloc(tls, uint64(block_size))
			if (*Ttre_list_t)(unsafe.Pointer(l)).Fdata == UintptrFromInt32(0) {
				Xfree(tls, l)
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Ffailed = int32(1)
				return UintptrFromInt32(0)
			}
			(*Ttre_list_t)(unsafe.Pointer(l)).Fnext = UintptrFromInt32(0)
			if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent != UintptrFromInt32(0) {
				(*Ttre_list_t)(unsafe.Pointer((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent)).Fnext = l
			}
			if (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks == UintptrFromInt32(0) {
				(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fblocks = l
			}
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fcurrent = l
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr = (*Ttre_list_t)(unsafe.Pointer(l)).Fdata
			(*Ttre_mem_struct)(unsafe.Pointer(mem)).Fn = uint64(block_size)
		}
	}
	/* Make sure the next pointer will be aligned. */
	if (uint64(int64((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr))+size)%uint64(8) != 0 {
		v1 = uint64(8) - (uint64(int64((*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr))+size)%uint64(8)
	} else {
		v1 = uint64(0)
	}
	size += v1
	/* Allocate from current block. */
	ptr = (*Ttre_mem_struct)(unsafe.Pointer(mem)).Fptr
	*(*uintptr)(unsafe.Pointer(mem + 16)) += uintptr(size)
	*(*Tsize_t)(unsafe.Pointer(mem + 24)) -= size
	/* Set to zero if needed. */
	if zero != 0 {
		Xmemset(tls, ptr, 0, size)
	}
	return ptr
}

const MAXSIZE = 1
const MINSIZE = 8

type TACTION = int32

const _FIND = 0
const _ENTER = 1

type TVISIT = int32

const _preorder = 0
const _postorder = 1
const _endorder = 2
const _leaf = 3

type TENTRY = struct {
	Fkey  uintptr
	Fdata uintptr
}

type Tentry = TENTRY

type Thsearch_data = struct {
	F__tab     uintptr
	F__unused1 uint32
	F__unused2 uint32
}

type Tqelem = struct {
	Fq_forw uintptr
	Fq_back uintptr
	Fq_data [1]uint8
}

/*
open addressing hash table with 2^n table size
quadratic probing is used in case of hash collision
tab indices and hash are size_t
after resize fails with ENOMEM the state of tab is still usable

with the posix api items cannot be iterated and length cannot be queried
*/

type t__tab = struct {
	Fentries uintptr
	Fmask    Tsize_t
	Fused    Tsize_t
}

var _htab Thsearch_data

func _keyhash(tls *TLS, k uintptr) (r Tsize_t) {
	var h Tsize_t
	var p, v1 uintptr
	_, _, _ = h, p, v1
	p = k
	h = uint64(0)
	for *(*uint8)(unsafe.Pointer(p)) != 0 {
		v1 = p
		p++
		h = uint64(31)*h + uint64(*(*uint8)(unsafe.Pointer(v1)))
	}
	return h
}

func _resize(tls *TLS, nel Tsize_t, htab uintptr) (r int32) {
	var e, newe, oldtab uintptr
	var i, j, newsize, oldsize, v4 Tsize_t
	_, _, _, _, _, _, _, _ = e, i, j, newe, newsize, oldsize, oldtab, v4
	oldsize = (*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask + uint64(1)
	oldtab = (*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries
	if nel > uint64(-Int32FromInt32(1))/Uint64FromInt32(2)+Uint64FromInt32(1) {
		nel = uint64(-Int32FromInt32(1))/Uint64FromInt32(2) + Uint64FromInt32(1)
	}
	newsize = uint64(MINSIZE)
	for {
		if !(newsize < nel) {
			break
		}
		goto _1
	_1:
		;
		newsize *= uint64(2)
	}
	(*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries = Xcalloc(tls, newsize, uint64(16))
	if !((*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries != 0) {
		(*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries = oldtab
		return 0
	}
	(*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask = newsize - uint64(1)
	if !(oldtab != 0) {
		return int32(1)
	}
	e = oldtab
	for {
		if !(e < oldtab+uintptr(oldsize)*16) {
			break
		}
		if (*TENTRY)(unsafe.Pointer(e)).Fkey != 0 {
			i = _keyhash(tls, (*TENTRY)(unsafe.Pointer(e)).Fkey)
			j = Uint64FromInt32(1)
			for {
				newe = (*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries + uintptr(i&(*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask)*16
				if !((*TENTRY)(unsafe.Pointer(newe)).Fkey != 0) {
					break
				}
				goto _3
			_3:
				;
				v4 = j
				j++
				i += v4
			}
			*(*TENTRY)(unsafe.Pointer(newe)) = *(*TENTRY)(unsafe.Pointer(e))
		}
		goto _2
	_2:
		;
		e += 16
	}
	Xfree(tls, oldtab)
	return int32(1)
}

func Xhcreate(tls *TLS, nel Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v nel=%v, (%v:)", tls, nel, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return ___hcreate_r(tls, nel, uintptr(unsafe.Pointer(&_htab)))
}

func Xhdestroy(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	___hdestroy_r(tls, uintptr(unsafe.Pointer(&_htab)))
}

func _lookup(tls *TLS, key uintptr, hash Tsize_t, htab uintptr) (r uintptr) {
	var e uintptr
	var i, j, v2 Tsize_t
	_, _, _, _ = e, i, j, v2
	i = hash
	j = Uint64FromInt32(1)
	for {
		e = (*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries + uintptr(i&(*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask)*16
		if !((*TENTRY)(unsafe.Pointer(e)).Fkey != 0) || Xstrcmp(tls, (*TENTRY)(unsafe.Pointer(e)).Fkey, key) == 0 {
			break
		}
		goto _1
	_1:
		;
		v2 = j
		j++
		i += v2
	}
	return e
}

func Xhsearch(tls *TLS, item TENTRY, action TACTION) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v item=%v action=%v, (%v:)", tls, item, action, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* e at bp+0 */ uintptr
	___hsearch_r(tls, item, action, bp, uintptr(unsafe.Pointer(&_htab)))
	return *(*uintptr)(unsafe.Pointer(bp))
}

func ___hcreate_r(tls *TLS, nel Tsize_t, htab uintptr) (r1 int32) {
	var r int32
	_ = r
	(*Thsearch_data)(unsafe.Pointer(htab)).F__tab = Xcalloc(tls, uint64(1), uint64(24))
	if !((*Thsearch_data)(unsafe.Pointer(htab)).F__tab != 0) {
		return 0
	}
	r = _resize(tls, nel, htab)
	if r == 0 {
		Xfree(tls, (*Thsearch_data)(unsafe.Pointer(htab)).F__tab)
		(*Thsearch_data)(unsafe.Pointer(htab)).F__tab = uintptr(0)
	}
	return r
}

func ___hdestroy_r(tls *TLS, htab uintptr) {
	if (*Thsearch_data)(unsafe.Pointer(htab)).F__tab != 0 {
		Xfree(tls, (*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fentries)
	}
	Xfree(tls, (*Thsearch_data)(unsafe.Pointer(htab)).F__tab)
	(*Thsearch_data)(unsafe.Pointer(htab)).F__tab = uintptr(0)
}

func ___hsearch_r(tls *TLS, item TENTRY, action TACTION, retval uintptr, htab uintptr) (r int32) {
	var e, v2 uintptr
	var hash, v1 Tsize_t
	_, _, _, _ = e, hash, v1, v2
	hash = _keyhash(tls, item.Fkey)
	e = _lookup(tls, item.Fkey, hash, htab)
	if (*TENTRY)(unsafe.Pointer(e)).Fkey != 0 {
		*(*uintptr)(unsafe.Pointer(retval)) = e
		return int32(1)
	}
	if action == int32(_FIND) {
		*(*uintptr)(unsafe.Pointer(retval)) = uintptr(0)
		return 0
	}
	*(*TENTRY)(unsafe.Pointer(e)) = item
	v2 = (*Thsearch_data)(unsafe.Pointer(htab)).F__tab + 16
	*(*Tsize_t)(unsafe.Pointer(v2))++
	v1 = *(*Tsize_t)(unsafe.Pointer(v2))
	if v1 > (*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask-(*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fmask/uint64(4) {
		if !(_resize(tls, uint64(2)*(*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fused, htab) != 0) {
			(*t__tab)(unsafe.Pointer((*Thsearch_data)(unsafe.Pointer(htab)).F__tab)).Fused--
			(*TENTRY)(unsafe.Pointer(e)).Fkey = uintptr(0)
			*(*uintptr)(unsafe.Pointer(retval)) = uintptr(0)
			return 0
		}
		e = _lookup(tls, item.Fkey, hash, htab)
	}
	*(*uintptr)(unsafe.Pointer(retval)) = e
	return int32(1)
}

type Tnode = struct {
	Fnext uintptr
	Fprev uintptr
}

func Xinsque(tls *TLS, element uintptr, pred uintptr) {
	if __ccgo_strace {
		trc("tls=%v element=%v pred=%v, (%v:)", tls, element, pred, origin(2))
	}
	var e, p, v1 uintptr
	_, _, _ = e, p, v1
	e = element
	p = pred
	if !(p != 0) {
		v1 = UintptrFromInt32(0)
		(*Tnode)(unsafe.Pointer(e)).Fprev = v1
		(*Tnode)(unsafe.Pointer(e)).Fnext = v1
		return
	}
	(*Tnode)(unsafe.Pointer(e)).Fnext = (*Tnode)(unsafe.Pointer(p)).Fnext
	(*Tnode)(unsafe.Pointer(e)).Fprev = p
	(*Tnode)(unsafe.Pointer(p)).Fnext = e
	if (*Tnode)(unsafe.Pointer(e)).Fnext != 0 {
		(*Tnode)(unsafe.Pointer((*Tnode)(unsafe.Pointer(e)).Fnext)).Fprev = e
	}
}

func Xremque(tls *TLS, element uintptr) {
	if __ccgo_strace {
		trc("tls=%v element=%v, (%v:)", tls, element, origin(2))
	}
	var e uintptr
	_ = e
	e = element
	if (*Tnode)(unsafe.Pointer(e)).Fnext != 0 {
		(*Tnode)(unsafe.Pointer((*Tnode)(unsafe.Pointer(e)).Fnext)).Fprev = (*Tnode)(unsafe.Pointer(e)).Fprev
	}
	if (*Tnode)(unsafe.Pointer(e)).Fprev != 0 {
		(*Tnode)(unsafe.Pointer((*Tnode)(unsafe.Pointer(e)).Fprev)).Fnext = (*Tnode)(unsafe.Pointer(e)).Fnext
	}
}

func Xlsearch(tls *TLS, key uintptr, base uintptr, nelp uintptr, width Tsize_t, compar uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v base=%v nelp=%v width=%v compar=%v, (%v:)", tls, key, base, nelp, width, compar, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i, n Tsize_t
	var p uintptr
	var v1 t__predefined_size_t
	_, _, _, _ = i, n, p, v1
	defer func() {}()
	v1 = width
	p = base
	n = *(*Tsize_t)(unsafe.Pointer(nelp))
	i = uint64(0)
	for {
		if !(i < n) {
			break
		}
		if (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{compar})))(tls, key, p+uintptr(i)*uintptr(v1)) == 0 {
			return p + uintptr(i)*uintptr(v1)
		}
		goto _2
	_2:
		;
		i++
	}
	*(*Tsize_t)(unsafe.Pointer(nelp)) = n + uint64(1)
	return Xmemcpy(tls, p+uintptr(n)*uintptr(v1), key, width)
}

func Xlfind(tls *TLS, key uintptr, base uintptr, nelp uintptr, width Tsize_t, compar uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v base=%v nelp=%v width=%v compar=%v, (%v:)", tls, key, base, nelp, width, compar, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i, n Tsize_t
	var p uintptr
	var v1 t__predefined_size_t
	_, _, _, _ = i, n, p, v1
	defer func() {}()
	v1 = width
	p = base
	n = *(*Tsize_t)(unsafe.Pointer(nelp))
	i = uint64(0)
	for {
		if !(i < n) {
			break
		}
		if (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{compar})))(tls, key, p+uintptr(i)*uintptr(v1)) == 0 {
			return p + uintptr(i)*uintptr(v1)
		}
		goto _2
	_2:
		;
		i++
	}
	return uintptr(0)
}

const MAXH = 0

type Tnode1 = struct {
	Fkey uintptr
	Fa   [2]uintptr
	Fh   int32
}

func Xtdelete(tls *TLS, key uintptr, rootp uintptr, cmp uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v rootp=%v cmp=%v, (%v:)", tls, key, rootp, cmp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a [97]uintptr
	var c, i, v1, v2, v4, v5, v6, v7, v8 int32
	var child, deleted, n, parent uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, c, child, deleted, i, n, parent, v1, v2, v4, v5, v6, v7, v8
	if !(rootp != 0) {
		return uintptr(0)
	}
	n = *(*uintptr)(unsafe.Pointer(rootp))
	i = 0
	/* *a[0] is an arbitrary non-null pointer that is returned when
	   the root node is deleted.  */
	v1 = i
	i++
	a[v1] = rootp
	v2 = i
	i++
	a[v2] = rootp
	for {
		if !(n != 0) {
			return uintptr(0)
		}
		c = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, (*Tnode1)(unsafe.Pointer(n)).Fkey)
		if !(c != 0) {
			break
		}
		v4 = i
		i++
		a[v4] = n + 8 + BoolUintptr(c > 0)*8
		n = *(*uintptr)(unsafe.Pointer(n + 8 + BoolUintptr(c > 0)*8))
		goto _3
	_3:
	}
	parent = *(*uintptr)(unsafe.Pointer(a[i-int32(2)]))
	if *(*uintptr)(unsafe.Pointer(n + 8)) != 0 {
		/* free the preceding node instead of the deleted one.  */
		deleted = n
		v5 = i
		i++
		a[v5] = n + 8
		n = *(*uintptr)(unsafe.Pointer(n + 8))
		for *(*uintptr)(unsafe.Pointer(n + 8 + 1*8)) != 0 {
			v6 = i
			i++
			a[v6] = n + 8 + 1*8
			n = *(*uintptr)(unsafe.Pointer(n + 8 + 1*8))
		}
		(*Tnode1)(unsafe.Pointer(deleted)).Fkey = (*Tnode1)(unsafe.Pointer(n)).Fkey
		child = *(*uintptr)(unsafe.Pointer(n + 8))
	} else {
		child = *(*uintptr)(unsafe.Pointer(n + 8 + 1*8))
	}
	/* freed node has at most one child, move it up and rebalance.  */
	Xfree(tls, n)
	i--
	v7 = i
	*(*uintptr)(unsafe.Pointer(a[v7])) = child
	for {
		i--
		v8 = i
		if !(v8 != 0 && X__tsearch_balance(tls, a[i]) != 0) {
			break
		}
	}
	return parent
}

func Xtdestroy(tls *TLS, root uintptr, freekey uintptr) {
	if __ccgo_strace {
		trc("tls=%v root=%v freekey=%v, (%v:)", tls, root, freekey, origin(2))
	}
	var r uintptr
	_ = r
	r = root
	if r == uintptr(0) {
		return
	}
	Xtdestroy(tls, *(*uintptr)(unsafe.Pointer(r + 8)), freekey)
	Xtdestroy(tls, *(*uintptr)(unsafe.Pointer(r + 8 + 1*8)), freekey)
	if freekey != 0 {
		(*(*func(*TLS, uintptr))(unsafe.Pointer(&struct{ uintptr }{freekey})))(tls, (*Tnode1)(unsafe.Pointer(r)).Fkey)
	}
	Xfree(tls, r)
}

func Xtfind(tls *TLS, key uintptr, rootp uintptr, cmp uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v rootp=%v cmp=%v, (%v:)", tls, key, rootp, cmp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var c int32
	var n uintptr
	_, _ = c, n
	if !(rootp != 0) {
		return uintptr(0)
	}
	n = *(*uintptr)(unsafe.Pointer(rootp))
	for {
		if !(n != 0) {
			break
		}
		c = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, (*Tnode1)(unsafe.Pointer(n)).Fkey)
		if !(c != 0) {
			break
		}
		n = *(*uintptr)(unsafe.Pointer(n + 8 + BoolUintptr(c > 0)*8))
		goto _1
	_1:
	}
	return n
}

func _height(tls *TLS, n uintptr) (r int32) {
	var v1 int32
	_ = v1
	if n != 0 {
		v1 = (*Tnode1)(unsafe.Pointer(n)).Fh
	} else {
		v1 = 0
	}
	return v1
}

func _rot(tls *TLS, p uintptr, x uintptr, dir int32) (r int32) {
	var hx, hz int32
	var y, z uintptr
	_, _, _, _ = hx, hz, y, z
	y = *(*uintptr)(unsafe.Pointer(x + 8 + uintptr(dir)*8))
	z = *(*uintptr)(unsafe.Pointer(y + 8 + BoolUintptr(!(dir != 0))*8))
	hx = (*Tnode1)(unsafe.Pointer(x)).Fh
	hz = _height(tls, z)
	if hz > _height(tls, *(*uintptr)(unsafe.Pointer(y + 8 + uintptr(dir)*8))) {
		/*
		 *   x
		 *  / \ dir          z
		 * A   y            / 		 *    / \   -->    x   y
		 *   z   D        /|   |		 *  / \          A B   C D
		 * B   C
		 */
		*(*uintptr)(unsafe.Pointer(x + 8 + uintptr(dir)*8)) = *(*uintptr)(unsafe.Pointer(z + 8 + BoolUintptr(!(dir != 0))*8))
		*(*uintptr)(unsafe.Pointer(y + 8 + BoolUintptr(!(dir != 0))*8)) = *(*uintptr)(unsafe.Pointer(z + 8 + uintptr(dir)*8))
		*(*uintptr)(unsafe.Pointer(z + 8 + BoolUintptr(!(dir != 0))*8)) = x
		*(*uintptr)(unsafe.Pointer(z + 8 + uintptr(dir)*8)) = y
		(*Tnode1)(unsafe.Pointer(x)).Fh = hz
		(*Tnode1)(unsafe.Pointer(y)).Fh = hz
		(*Tnode1)(unsafe.Pointer(z)).Fh = hz + int32(1)
	} else {
		/*
		 *   x               y
		 *  / \             / 		 * A   y    -->    x   D
		 *    / \         / 		 *   z   D       A   z
		 */
		*(*uintptr)(unsafe.Pointer(x + 8 + uintptr(dir)*8)) = z
		*(*uintptr)(unsafe.Pointer(y + 8 + BoolUintptr(!(dir != 0))*8)) = x
		(*Tnode1)(unsafe.Pointer(x)).Fh = hz + int32(1)
		(*Tnode1)(unsafe.Pointer(y)).Fh = hz + int32(2)
		z = y
	}
	*(*uintptr)(unsafe.Pointer(p)) = z
	return (*Tnode1)(unsafe.Pointer(z)).Fh - hx
}

// C documentation
//
//	/* balance *p, return 0 if height is unchanged.  */
func X__tsearch_balance(tls *TLS, p uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v p=%v, (%v:)", tls, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var h0, h1, old, v1 int32
	var n uintptr
	_, _, _, _, _ = h0, h1, n, old, v1
	n = *(*uintptr)(unsafe.Pointer(p))
	h0 = _height(tls, *(*uintptr)(unsafe.Pointer(n + 8)))
	h1 = _height(tls, *(*uintptr)(unsafe.Pointer(n + 8 + 1*8)))
	if uint32(h0-h1)+uint32(1) < uint32(3) {
		old = (*Tnode1)(unsafe.Pointer(n)).Fh
		if h0 < h1 {
			v1 = h1 + int32(1)
		} else {
			v1 = h0 + int32(1)
		}
		(*Tnode1)(unsafe.Pointer(n)).Fh = v1
		return (*Tnode1)(unsafe.Pointer(n)).Fh - old
	}
	return _rot(tls, p, n, BoolInt32(h0 < h1))
}

func Xtsearch(tls *TLS, key uintptr, rootp uintptr, cmp uintptr) (r1 uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v rootp=%v cmp=%v, (%v:)", tls, key, rootp, cmp, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var a [96]uintptr
	var c, i, v1, v3, v5, v6 int32
	var n, r, v4 uintptr
	var v7 bool
	_, _, _, _, _, _, _, _, _, _, _ = a, c, i, n, r, v1, v3, v4, v5, v6, v7
	if !(rootp != 0) {
		return uintptr(0)
	}
	n = *(*uintptr)(unsafe.Pointer(rootp))
	i = 0
	v1 = i
	i++
	a[v1] = rootp
	for {
		if !(n != 0) {
			break
		}
		c = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, (*Tnode1)(unsafe.Pointer(n)).Fkey)
		if !(c != 0) {
			return n
		}
		v3 = i
		i++
		a[v3] = n + 8 + BoolUintptr(c > 0)*8
		n = *(*uintptr)(unsafe.Pointer(n + 8 + BoolUintptr(c > 0)*8))
		goto _2
	_2:
	}
	r = Xmalloc(tls, uint64(32))
	if !(r != 0) {
		return uintptr(0)
	}
	(*Tnode1)(unsafe.Pointer(r)).Fkey = key
	v4 = UintptrFromInt32(0)
	*(*uintptr)(unsafe.Pointer(r + 8 + 1*8)) = v4
	*(*uintptr)(unsafe.Pointer(r + 8)) = v4
	(*Tnode1)(unsafe.Pointer(r)).Fh = int32(1)
	/* insert new node, rebalance ancestors.  */
	i--
	v5 = i
	*(*uintptr)(unsafe.Pointer(a[v5])) = r
	for {
		if v7 = i != 0; v7 {
			i--
			v6 = i
		}
		if !(v7 && X__tsearch_balance(tls, a[v6]) != 0) {
			break
		}
	}
	return r
}

func _walk(tls *TLS, r uintptr, action uintptr, d int32) {
	if !(r != 0) {
		return
	}
	if (*Tnode1)(unsafe.Pointer(r)).Fh == int32(1) {
		(*(*func(*TLS, uintptr, TVISIT, int32))(unsafe.Pointer(&struct{ uintptr }{action})))(tls, r, _leaf, d)
	} else {
		(*(*func(*TLS, uintptr, TVISIT, int32))(unsafe.Pointer(&struct{ uintptr }{action})))(tls, r, _preorder, d)
		_walk(tls, *(*uintptr)(unsafe.Pointer(r + 8)), action, d+int32(1))
		(*(*func(*TLS, uintptr, TVISIT, int32))(unsafe.Pointer(&struct{ uintptr }{action})))(tls, r, _postorder, d)
		_walk(tls, *(*uintptr)(unsafe.Pointer(r + 8 + 1*8)), action, d+int32(1))
		(*(*func(*TLS, uintptr, TVISIT, int32))(unsafe.Pointer(&struct{ uintptr }{action})))(tls, r, _endorder, d)
	}
}

func Xtwalk(tls *TLS, root uintptr, action uintptr) {
	if __ccgo_strace {
		trc("tls=%v root=%v action=%v, (%v:)", tls, root, action, origin(2))
	}
	_walk(tls, root, action, 0)
}

func Xpoll(tls *TLS, fds uintptr, n Tnfds_t, timeout int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fds=%v n=%v timeout=%v, (%v:)", tls, fds, n, timeout, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 uintptr
	_ = v1
	if timeout >= 0 {
		*(*[2]int64)(unsafe.Pointer(bp)) = [2]int64{
			0: int64(timeout / int32(1000)),
			1: int64(timeout % int32(1000) * int32(1000000)),
		}
		v1 = bp
	} else {
		v1 = uintptr(0)
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_ppoll), int64(fds), int64(n), int64(v1), int64(Int32FromInt32(0)), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)), 0))))
}

type t__ucontext3 = Tucontext_t5

func Xppoll(tls *TLS, fds uintptr, n Tnfds_t, to uintptr, mask uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fds=%v n=%v to=%v mask=%v, (%v:)", tls, fds, n, to, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var ns, v1, v2 int64
	var s Ttime_t
	var v3 uintptr
	_, _, _, _, _ = ns, s, v1, v2, v3
	if to != 0 {
		v1 = (*Ttimespec)(unsafe.Pointer(to)).Ftv_sec
	} else {
		v1 = 0
	}
	s = v1
	if to != 0 {
		v2 = (*Ttimespec)(unsafe.Pointer(to)).Ftv_nsec
	} else {
		v2 = 0
	}
	ns = v2
	if to != 0 {
		*(*[2]int64)(unsafe.Pointer(bp)) = [2]int64{
			0: s,
			1: ns,
		}
		v3 = bp
	} else {
		v3 = uintptr(0)
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_ppoll), int64(fds), int64(n), int64(v3), int64(mask), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)), 0))))
}

type t__ucontext4 = Tucontext_t4

func Xpselect(tls *TLS, n int32, rfds uintptr, wfds uintptr, efds uintptr, ts uintptr, mask uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v n=%v rfds=%v wfds=%v efds=%v ts=%v mask=%v, (%v:)", tls, n, rfds, wfds, efds, ts, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ns, v1, v2 int64
	var s Ttime_t
	var v3 uintptr
	var _ /* data at bp+16 */ [2]Tsyscall_arg_t
	_, _, _, _, _ = ns, s, v1, v2, v3
	*(*[2]Tsyscall_arg_t)(unsafe.Pointer(bp + 16)) = [2]Tsyscall_arg_t{
		0: int64(uint64(mask)),
		1: int64(Int32FromInt32(_NSIG) / Int32FromInt32(8)),
	}
	if ts != 0 {
		v1 = (*Ttimespec)(unsafe.Pointer(ts)).Ftv_sec
	} else {
		v1 = 0
	}
	s = v1
	if ts != 0 {
		v2 = (*Ttimespec)(unsafe.Pointer(ts)).Ftv_nsec
	} else {
		v2 = 0
	}
	ns = v2
	if ts != 0 {
		*(*[2]int64)(unsafe.Pointer(bp)) = [2]int64{
			0: s,
			1: ns,
		}
		v3 = bp
	} else {
		v3 = uintptr(0)
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_pselect6), int64(n), int64(rfds), int64(wfds), int64(efds), int64(v3), int64(bp+16)))))
}

type Tucontext_t6 = struct {
	Fuc_flags    uint64
	Fuc_link     uintptr
	Fuc_stack    Tstack_t
	Fuc_sigmask  Tsigset_t
	Fuc_mcontext Tmcontext_t
}

func Xselect(tls *TLS, n int32, rfds uintptr, wfds uintptr, efds uintptr, tv uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v n=%v rfds=%v wfds=%v efds=%v tv=%v, (%v:)", tls, n, rfds, wfds, efds, tv, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var max_time, s Ttime_t
	var ns, v1, v2 int64
	var us Tsuseconds_t
	var v3 uintptr
	_, _, _, _, _, _, _ = max_time, ns, s, us, v1, v2, v3
	if tv != 0 {
		v1 = (*Ttimeval)(unsafe.Pointer(tv)).Ftv_sec
	} else {
		v1 = 0
	}
	s = v1
	if tv != 0 {
		v2 = (*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec
	} else {
		v2 = 0
	}
	us = v2
	max_time = int64(Uint64FromUint64(1)<<(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1)) - Uint64FromInt32(1))
	if s < 0 || us < 0 {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
	}
	if us/int64(1000000) > max_time-s {
		s = max_time
		us = int64(999999)
		ns = int64(999999999)
	} else {
		s += us / int64(1000000)
		us %= int64(1000000)
		ns = us * int64(1000)
	}
	if tv != 0 {
		*(*[2]int64)(unsafe.Pointer(bp)) = [2]int64{
			0: s,
			1: ns,
		}
		v3 = bp
	} else {
		v3 = uintptr(0)
	}
	*(*[2]Tsyscall_arg_t)(unsafe.Pointer(bp + 16)) = [2]Tsyscall_arg_t{
		1: int64(Int32FromInt32(_NSIG) / Int32FromInt32(8)),
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_pselect6), int64(n), int64(rfds), int64(wfds), int64(efds), int64(v3), int64(bp+16)))))
}

var _all_mask = [1]uint64{
	0: -Uint64FromUint64(1),
}

var _app_mask = [1]uint64{
	0: uint64(0xfffffffc7fffffff),
}

func X__block_all_sigs(tls *TLS, set uintptr) {
	if __ccgo_strace {
		trc("tls=%v set=%v, (%v:)", tls, set, origin(2))
	}
	X__syscall4(tls, int64(SYS_rt_sigprocmask), int64(Int32FromInt32(SIG_BLOCK)), int64(uintptr(unsafe.Pointer(&_all_mask))), int64(set), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)))
}

func X__block_app_sigs(tls *TLS, set uintptr) {
	if __ccgo_strace {
		trc("tls=%v set=%v, (%v:)", tls, set, origin(2))
	}
	X__syscall4(tls, int64(SYS_rt_sigprocmask), int64(Int32FromInt32(SIG_BLOCK)), int64(uintptr(unsafe.Pointer(&_app_mask))), int64(set), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)))
}

func X__restore_sigs(tls *TLS, set uintptr) {
	if __ccgo_strace {
		trc("tls=%v set=%v, (%v:)", tls, set, origin(2))
	}
	X__syscall4(tls, int64(SYS_rt_sigprocmask), int64(Int32FromInt32(SIG_SETMASK)), int64(set), int64(Int32FromInt32(0)), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)))
}

func Xgetitimer(tls *TLS, which int32, old uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v which=%v old=%v, (%v:)", tls, which, old, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var r int32
	var _ /* old32 at bp+0 */ [4]int64
	_ = r
	if uint64(8) > uint64(8) {
		r = int32(X__syscall2(tls, int64(SYS_getitimer), int64(which), int64(bp)))
		if !(r != 0) {
			(*Titimerval)(unsafe.Pointer(old)).Fit_interval.Ftv_sec = (*(*[4]int64)(unsafe.Pointer(bp)))[0]
			(*Titimerval)(unsafe.Pointer(old)).Fit_interval.Ftv_usec = (*(*[4]int64)(unsafe.Pointer(bp)))[int32(1)]
			(*Titimerval)(unsafe.Pointer(old)).Fit_value.Ftv_sec = (*(*[4]int64)(unsafe.Pointer(bp)))[int32(2)]
			(*Titimerval)(unsafe.Pointer(old)).Fit_value.Ftv_usec = (*(*[4]int64)(unsafe.Pointer(bp)))[int32(3)]
		}
		return int32(X__syscall_ret(tls, uint64(r)))
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_getitimer), int64(which), int64(old)))))
}

func Xkill(tls *TLS, pid Tpid_t, sig int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v pid=%v sig=%v, (%v:)", tls, pid, sig, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_kill), int64(pid), int64(sig)))))
}

func Xkillpg(tls *TLS, pgid Tpid_t, sig int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v pgid=%v sig=%v, (%v:)", tls, pgid, sig, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if pgid < 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	return Xkill(tls, -pgid, sig)
}

func Xpsiginfo(tls *TLS, si uintptr, msg uintptr) {
	if __ccgo_strace {
		trc("tls=%v si=%v msg=%v, (%v:)", tls, si, msg, origin(2))
	}
	Xpsignal(tls, (*Tsiginfo_t)(unsafe.Pointer(si)).Fsi_signo, msg)
}

func Xpsignal(tls *TLS, sig int32, msg uintptr) {
	if __ccgo_strace {
		trc("tls=%v sig=%v msg=%v, (%v:)", tls, sig, msg, origin(2))
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var __need_unlock, old_errno, old_mode, v1 int32
	var f, old_locale, s, v2, v3 uintptr
	_, _, _, _, _, _, _, _, _ = __need_unlock, f, old_errno, old_locale, old_mode, s, v1, v2, v3
	f = uintptr(unsafe.Pointer(&X__stderr_FILE))
	s = Xstrsignal(tls, sig)
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	/* Save stderr's orientation and encoding rule, since psignal is not
	 * permitted to change them. Save errno and restore it if there is no
	 * error since fprintf might change it even on success but psignal is
	 * not permitted to do so. */
	old_locale = (*TFILE)(unsafe.Pointer(f)).Flocale
	old_mode = (*TFILE)(unsafe.Pointer(f)).Fmode
	old_errno = *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	if msg != 0 {
		v2 = msg
	} else {
		v2 = __ccgo_ts
	}
	if msg != 0 {
		v3 = __ccgo_ts + 289
	} else {
		v3 = __ccgo_ts
	}
	if Xfprintf(tls, f, __ccgo_ts+1072, VaList(bp+8, v2, v3, s)) >= 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = old_errno
	}
	(*TFILE)(unsafe.Pointer(f)).Fmode = old_mode
	(*TFILE)(unsafe.Pointer(f)).Flocale = old_locale
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
}

func Xraise(tls *TLS, sig int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v sig=%v, (%v:)", tls, sig, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var ret int32
	var _ /* set at bp+0 */ Tsigset_t
	_ = ret
	X__block_app_sigs(tls, bp)
	ret = int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_tkill), int64((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid), int64(sig)))))
	X__restore_sigs(tls, bp)
	return ret
}

/* These functions will not work, but suffice for targets where the
 * kernel sigaction structure does not actually use sa_restorer. */
func X__restore(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
}

func X__restore_rt(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
}

func Xsetitimer(tls *TLS, which int32, new1 uintptr, old uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v which=%v new1=%v old=%v, (%v:)", tls, which, new1, old, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var is, vs Ttime_t
	var ius, vus int64
	var r int32
	var _ /* old32 at bp+32 */ [4]int64
	_, _, _, _, _ = is, ius, r, vs, vus
	if uint64(8) > uint64(8) {
		is = (*Titimerval)(unsafe.Pointer(new1)).Fit_interval.Ftv_sec
		vs = (*Titimerval)(unsafe.Pointer(new1)).Fit_value.Ftv_sec
		ius = (*Titimerval)(unsafe.Pointer(new1)).Fit_interval.Ftv_usec
		vus = (*Titimerval)(unsafe.Pointer(new1)).Fit_value.Ftv_usec
		if !!((uint64(is)+Uint64FromUint64(0x80000000))>>Int32FromInt32(32) != 0) || !!((uint64(vs)+Uint64FromUint64(0x80000000))>>Int32FromInt32(32) != 0) {
			return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EOPNOTSUPP))))
		}
		*(*[4]int64)(unsafe.Pointer(bp)) = [4]int64{
			0: is,
			1: ius,
			2: vs,
			3: vus,
		}
		r = int32(X__syscall3(tls, int64(SYS_setitimer), int64(which), int64(bp), int64(bp+32)))
		if !(r != 0) && old != 0 {
			(*Titimerval)(unsafe.Pointer(old)).Fit_interval.Ftv_sec = (*(*[4]int64)(unsafe.Pointer(bp + 32)))[0]
			(*Titimerval)(unsafe.Pointer(old)).Fit_interval.Ftv_usec = (*(*[4]int64)(unsafe.Pointer(bp + 32)))[int32(1)]
			(*Titimerval)(unsafe.Pointer(old)).Fit_value.Ftv_sec = (*(*[4]int64)(unsafe.Pointer(bp + 32)))[int32(2)]
			(*Titimerval)(unsafe.Pointer(old)).Fit_value.Ftv_usec = (*(*[4]int64)(unsafe.Pointer(bp + 32)))[int32(3)]
		}
		return int32(X__syscall_ret(tls, uint64(r)))
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_setitimer), int64(which), int64(new1), int64(old)))))
}

type Tk_sigaction = struct {
	Fhandler  uintptr
	Fflags    uint64
	Frestorer uintptr
	Fmask     [2]uint32
}

var _unmask_done int32
var _handler_set [1]uint64

func X__get_handler_set(tls *TLS, set uintptr) {
	if __ccgo_strace {
		trc("tls=%v set=%v, (%v:)", tls, set, origin(2))
	}
	Xmemcpy(tls, set, uintptr(unsafe.Pointer(&_handler_set)), uint64(8))
}

func X__libc_sigaction(tls *TLS, sig int32, sa uintptr, old1 uintptr) (r2 int32) {
	if __ccgo_strace {
		trc("tls=%v sig=%v sa=%v old1=%v, (%v:)", tls, sig, sa, old1, origin(2))
		defer func() { trc("-> %v", r2) }()
	}
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var old, r, r1, v, v12, v15, v19, v22, v4, v7 int32
	var v1, v10, v11, v18, v25, v26, v27, v3 uintptr
	var v2 int64
	var _ /* ksa at bp+16 */ Tk_sigaction
	var _ /* ksa_old at bp+48 */ Tk_sigaction
	var _ /* u at bp+8 */ struct {
		Fr [0][2]Tuint32_t
		Fv Tuint64_t
	}
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = old, r, r1, v, v1, v10, v11, v12, v15, v18, v19, v2, v22, v25, v26, v27, v3, v4, v7
	if sa != 0 {
		if uint64(*(*uintptr)(unsafe.Pointer(sa))) > uint64(1) {
			v1 = uintptr(unsafe.Pointer(&_handler_set)) + uintptr(uint64(sig-Int32FromInt32(1))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
			v2 = int64(uint64(1) << (uint64(sig-Int32FromInt32(1)) % (Uint64FromInt32(8) * Uint64FromInt64(8))))
			if Uint64FromInt64(8) == Uint64FromInt64(4) {
				v3 = v1
				for {
					// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
					X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1487)
					v7 = v
					goto _8
				_8:
					old = v7
					goto _6
				_6:
					;
					// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
					X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1487)
					v4 = BoolInt32(!(r != 0))
					goto _5
				_5:
					;
					if !!(v4 != 0) {
						break
					}
				}
				_ = old
				goto _9
			_9:
			} else {
				v10 = v1
				*(*struct {
					Fr [0][2]Tuint32_t
					Fv Tuint64_t
				})(unsafe.Pointer(bp + 8)) = struct {
					Fr [0][2]Tuint32_t
					Fv Tuint64_t
				}{}
				*(*uint64)(unsafe.Pointer(bp + 8)) = uint64(v2)
				if *(*Tuint32_t)(unsafe.Pointer(bp + 8)) != 0 {
					v11 = v10
					for {
						// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
						X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1487)
						v15 = v
						goto _16
					_16:
						old = v15
						goto _14
					_14:
						;
						// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
						X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1487)
						v12 = BoolInt32(!(r != 0))
						goto _13
					_13:
						;
						if !!(v12 != 0) {
							break
						}
					}
					_ = old
					goto _17
				_17:
				}
				if *(*Tuint32_t)(unsafe.Pointer(bp + 8 + 1*4)) != 0 {
					v18 = v10 + uintptr(1)*4
					for {
						// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
						X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1487)
						v22 = v
						goto _23
					_23:
						old = v22
						goto _21
					_21:
						;
						// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
						X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1487)
						v19 = BoolInt32(!(r != 0))
						goto _20
					_20:
						;
						if !!(v19 != 0) {
							break
						}
					}
					_ = old
					goto _24
				_24:
				}
			}
			/* If pthread_create has not yet been called,
			 * implementation-internal signals might not
			 * yet have been unblocked. They must be
			 * unblocked before any signal handler is
			 * installed, so that an application cannot
			 * receive an illegal sigset_t (with them
			 * blocked) as part of the ucontext_t passed
			 * to the signal handler. */
			if !(X__libc.Fthreaded != 0) && !(_unmask_done != 0) {
				*(*[1]uint64)(unsafe.Pointer(bp)) = [1]uint64{
					0: Uint64FromUint64(3) << (Int32FromInt32(32) * BoolInt32(Uint64FromInt64(8) > Uint64FromInt32(4))),
				}
				X__syscall4(tls, int64(SYS_rt_sigprocmask), int64(Int32FromInt32(SIG_UNBLOCK)), int64(bp), int64(Int32FromInt32(0)), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)))
				_unmask_done = int32(1)
			}
			if !((*Tsigaction)(unsafe.Pointer(sa)).Fsa_flags&Int32FromInt32(SA_RESTART) != 0) {
				// __asm__ __volatile__ ("dmb ish" : : : "memory");
				X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1487)
				AtomicStorePInt32(uintptr(unsafe.Pointer(&X__eintr_valid_flag)), int32(1))
				// __asm__ __volatile__ ("dmb ish" : : : "memory");
				X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1487)
			}
		}
		(*(*Tk_sigaction)(unsafe.Pointer(bp + 16))).Fhandler = *(*uintptr)(unsafe.Pointer(sa))
		(*(*Tk_sigaction)(unsafe.Pointer(bp + 16))).Fflags = uint64((*Tsigaction)(unsafe.Pointer(sa)).Fsa_flags)
		(*(*Tk_sigaction)(unsafe.Pointer(bp + 16))).Fflags |= uint64(SA_RESTORER)
		if (*Tsigaction)(unsafe.Pointer(sa)).Fsa_flags&int32(SA_SIGINFO) != 0 {
			v25 = __ccgo_fp(X__restore_rt)
		} else {
			v25 = __ccgo_fp(X__restore)
		}
		(*(*Tk_sigaction)(unsafe.Pointer(bp + 16))).Frestorer = v25
		Xmemcpy(tls, bp+16+24, sa+8, uint64(Int32FromInt32(_NSIG)/Int32FromInt32(8)))
	}
	if sa != 0 {
		v26 = bp + 16
	} else {
		v26 = uintptr(0)
	}
	if old1 != 0 {
		v27 = bp + 48
	} else {
		v27 = uintptr(0)
	}
	r1 = int32(X__syscall4(tls, int64(SYS_rt_sigaction), int64(sig), int64(v26), int64(v27), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8))))
	if old1 != 0 && !(r1 != 0) {
		*(*uintptr)(unsafe.Pointer(old1)) = (*(*Tk_sigaction)(unsafe.Pointer(bp + 48))).Fhandler
		(*Tsigaction)(unsafe.Pointer(old1)).Fsa_flags = int32((*(*Tk_sigaction)(unsafe.Pointer(bp + 48))).Fflags)
		Xmemcpy(tls, old1+8, bp+48+24, uint64(Int32FromInt32(_NSIG)/Int32FromInt32(8)))
	}
	return int32(X__syscall_ret(tls, uint64(r1)))
}

func X__sigaction(tls *TLS, sig int32, sa uintptr, old uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v sig=%v sa=%v old=%v, (%v:)", tls, sig, sa, old, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r int32
	var _ /* set at bp+0 */ [1]uint64
	_ = r
	if uint32(sig)-uint32(32) < uint32(3) || uint32(sig)-uint32(1) >= uint32(Int32FromInt32(_NSIG)-Int32FromInt32(1)) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	/* Doing anything with the disposition of SIGABRT requires a lock,
	 * so that it cannot be changed while abort is terminating the
	 * process and so any change made by abort can't be observed. */
	if sig == int32(SIGABRT) {
		X__block_all_sigs(tls, bp)
		___lock(tls, uintptr(unsafe.Pointer(&X__abort_lock)))
	}
	r = X__libc_sigaction(tls, sig, sa, old)
	if sig == int32(SIGABRT) {
		___unlock(tls, uintptr(unsafe.Pointer(&X__abort_lock)))
		X__restore_sigs(tls, bp)
	}
	return r
}

func Xsigaction(tls *TLS, sig int32, sa uintptr, old uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v sig=%v sa=%v old=%v, (%v:)", tls, sig, sa, old, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__sigaction(tls, sig, sa, old)
}

func Xsigaddset(tls *TLS, set uintptr, sig int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v set=%v sig=%v, (%v:)", tls, set, sig, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var s uint32
	_ = s
	s = uint32(sig - int32(1))
	if s >= uint32(Int32FromInt32(_NSIG)-Int32FromInt32(1)) || uint32(sig)-uint32(32) < uint32(3) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	*(*uint64)(unsafe.Pointer(set + uintptr(uint64(s/uint32(8))/uint64(8))*8)) |= uint64(1) << (uint64(s) & (Uint64FromInt32(8)*Uint64FromInt64(8) - Uint64FromInt32(1)))
	return 0
}

func Xsigaltstack(tls *TLS, ss uintptr, old uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ss=%v old=%v, (%v:)", tls, ss, old, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if ss != 0 {
		if !((*Tstack_t)(unsafe.Pointer(ss)).Fss_flags&Int32FromInt32(SS_DISABLE) != 0) && (*Tstack_t)(unsafe.Pointer(ss)).Fss_size < uint64(MINSIGSTKSZ) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMEM)
			return -int32(1)
		}
		if (*Tstack_t)(unsafe.Pointer(ss)).Fss_flags&int32(SS_ONSTACK) != 0 {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
			return -int32(1)
		}
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_sigaltstack), int64(ss), int64(old)))))
}

const SST_SIZE = 8

type Tucontext_t7 = struct {
	Fuc_flags    uint64
	Fuc_link     uintptr
	Fuc_stack    Tstack_t
	Fuc_sigmask  Tsigset_t
	Fuc_mcontext Tmcontext_t1
}

func Xsigandset(tls *TLS, dest uintptr, left uintptr, right uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v dest=%v left=%v right=%v, (%v:)", tls, dest, left, right, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var d, l, r uintptr
	var i uint64
	_, _, _, _ = d, i, l, r
	i = uint64(0)
	d = dest
	l = left
	r = right
	for {
		if !(i < uint64(Int32FromInt32(_NSIG)/Int32FromInt32(8))/Uint64FromInt64(8)) {
			break
		}
		*(*uint64)(unsafe.Pointer(d + uintptr(i)*8)) = *(*uint64)(unsafe.Pointer(l + uintptr(i)*8)) & *(*uint64)(unsafe.Pointer(r + uintptr(i)*8))
		goto _1
	_1:
		;
		i++
	}
	return 0
}
func Xsigdelset(tls *TLS, set uintptr, sig int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v set=%v sig=%v, (%v:)", tls, set, sig, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var s uint32
	_ = s
	s = uint32(sig - int32(1))
	if s >= uint32(Int32FromInt32(_NSIG)-Int32FromInt32(1)) || uint32(sig)-uint32(32) < uint32(3) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	*(*uint64)(unsafe.Pointer(set + uintptr(uint64(s/uint32(8))/uint64(8))*8)) &= ^(Uint64FromUint64(1) << (uint64(s) & (Uint64FromInt32(8)*Uint64FromInt64(8) - Uint64FromInt32(1))))
	return 0
}

func Xsigemptyset(tls *TLS, set uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v set=%v, (%v:)", tls, set, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	*(*uint64)(unsafe.Pointer(set)) = uint64(0)
	if Bool(uint64(8) == uint64(4)) || Bool(int32(_NSIG) > int32(65)) {
		*(*uint64)(unsafe.Pointer(set + 1*8)) = uint64(0)
	}
	if Bool(uint64(8) == uint64(4)) && Bool(int32(_NSIG) > int32(65)) {
		*(*uint64)(unsafe.Pointer(set + 2*8)) = uint64(0)
		*(*uint64)(unsafe.Pointer(set + 3*8)) = uint64(0)
	}
	return 0
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xsigfillset(tls *TLS, set uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v set=%v, (%v:)", tls, set, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	*(*uint64)(unsafe.Pointer(set)) = uint64(0xfffffffc7fffffff)
	if int32(_NSIG) > int32(65) {
		*(*uint64)(unsafe.Pointer(set + 1*8)) = uint64(0xffffffffffffffff)
	}
	return 0
}

func Xsigisemptyset(tls *TLS, set uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v set=%v, (%v:)", tls, set, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i Tsize_t
	_ = i
	i = uint64(0)
	for {
		if !(i < uint64(Int32FromInt32(_NSIG)/Int32FromInt32(8))/Uint64FromInt64(8)) {
			break
		}
		if *(*uint64)(unsafe.Pointer(set + uintptr(i)*8)) != 0 {
			return 0
		}
		goto _1
	_1:
		;
		i++
	}
	return int32(1)
}
func Xsigismember(tls *TLS, set uintptr, sig int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v set=%v sig=%v, (%v:)", tls, set, sig, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var s uint32
	_ = s
	s = uint32(sig - int32(1))
	if s >= uint32(Int32FromInt32(_NSIG)-Int32FromInt32(1)) {
		return 0
	}
	return BoolInt32(!!(*(*uint64)(unsafe.Pointer(set + uintptr(uint64(s/uint32(8))/uint64(8))*8))&(Uint64FromUint64(1)<<(uint64(s)&(Uint64FromInt32(8)*Uint64FromInt64(8)-Uint64FromInt32(1)))) != 0))
}

func Xsigorset(tls *TLS, dest uintptr, left uintptr, right uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v dest=%v left=%v right=%v, (%v:)", tls, dest, left, right, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var d, l, r uintptr
	var i uint64
	_, _, _, _ = d, i, l, r
	i = uint64(0)
	d = dest
	l = left
	r = right
	for {
		if !(i < uint64(Int32FromInt32(_NSIG)/Int32FromInt32(8))/Uint64FromInt64(8)) {
			break
		}
		*(*uint64)(unsafe.Pointer(d + uintptr(i)*8)) = *(*uint64)(unsafe.Pointer(l + uintptr(i)*8)) | *(*uint64)(unsafe.Pointer(r + uintptr(i)*8))
		goto _1
	_1:
		;
		i++
	}
	return 0
}
func Xsigpending(tls *TLS, set uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v set=%v, (%v:)", tls, set, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_rt_sigpending), int64(set), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8))))))
}

func Xsigprocmask(tls *TLS, how int32, set uintptr, old uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v how=%v set=%v old=%v, (%v:)", tls, how, set, old, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = _pthread_sigmask(tls, how, set, old)
	if !(r != 0) {
		return r
	}
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = r
	return -int32(1)
}

func Xsigqueue(tls *TLS, pid Tpid_t, sig int32, value Tsigval) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v pid=%v sig=%v value=%v, (%v:)", tls, pid, sig, value, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var r int32
	var _ /* set at bp+128 */ Tsigset_t
	var _ /* si at bp+0 */ Tsiginfo_t
	_ = r
	Xmemset(tls, bp, 0, uint64(128))
	(*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_signo = sig
	(*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_code = -int32(1)
	*(*Tsigval)(unsafe.Pointer(bp + 16 + 8)) = value
	*(*Tuid_t)(unsafe.Pointer(bp + 16 + 4)) = Xgetuid(tls)
	X__block_app_sigs(tls, bp+128)
	*(*Tpid_t)(unsafe.Pointer(bp + 16)) = Xgetpid(tls)
	r = int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_rt_sigqueueinfo), int64(pid), int64(sig), int64(bp)))))
	X__restore_sigs(tls, bp+128)
	return r
}

func X__libc_current_sigrtmax(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Int32FromInt32(_NSIG) - Int32FromInt32(1)
}

func X__libc_current_sigrtmin(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(35)
}

type t__jmp_buf = [22]uint64

type Tjmp_buf = [1]t__jmp_buf_tag

type t__jmp_buf_tag = struct {
	F__jb t__jmp_buf
	F__fl uint64
	F__ss [16]uint64
}

type Tsigjmp_buf = [1]t__jmp_buf_tag

func X__sigsetjmp_tail(tls *TLS, jb uintptr, ret int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v jb=%v ret=%v, (%v:)", tls, jb, ret, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p, v1, v2 uintptr
	_, _, _ = p, v1, v2
	p = jb + 184
	if ret != 0 {
		v1 = p
	} else {
		v1 = uintptr(0)
	}
	if ret != 0 {
		v2 = uintptr(0)
	} else {
		v2 = p
	}
	X__syscall4(tls, int64(SYS_rt_sigprocmask), int64(Int32FromInt32(SIG_SETMASK)), int64(v1), int64(v2), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)))
	return ret
}

func Xsigsuspend(tls *TLS, mask uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mask=%v, (%v:)", tls, mask, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_rt_sigsuspend), int64(mask), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)), 0, 0, 0, 0))))
}

func _do_sigtimedwait(tls *TLS, mask uintptr, si uintptr, ts uintptr) (r int32) {
	return int32(___syscall_cp(tls, int64(SYS_rt_sigtimedwait), int64(mask), int64(si), int64(ts), int64(Int32FromInt32(_NSIG)/Int32FromInt32(8)), 0, 0))
}

func Xsigtimedwait(tls *TLS, mask uintptr, si uintptr, timeout uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mask=%v si=%v timeout=%v, (%v:)", tls, mask, si, timeout, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int32
	_ = ret
	for cond := true; cond; cond = ret == -int32(EINTR) {
		ret = _do_sigtimedwait(tls, mask, si, timeout)
	}
	return int32(X__syscall_ret(tls, uint64(ret)))
}

func Xsigwait(tls *TLS, mask uintptr, sig uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mask=%v sig=%v, (%v:)", tls, mask, sig, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var _ /* si at bp+0 */ Tsiginfo_t
	if Xsigtimedwait(tls, mask, bp, uintptr(0)) < 0 {
		return -int32(1)
	}
	*(*int32)(unsafe.Pointer(sig)) = (*(*Tsiginfo_t)(unsafe.Pointer(bp))).Fsi_signo
	return 0
}

func Xsigwaitinfo(tls *TLS, mask uintptr, si uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mask=%v si=%v, (%v:)", tls, mask, si, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsigtimedwait(tls, mask, si, uintptr(0))
}

func X__fxstat(tls *TLS, ver int32, fd int32, buf uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ver=%v fd=%v buf=%v, (%v:)", tls, ver, fd, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfstat(tls, fd, buf)
}

func X__fxstatat(tls *TLS, ver int32, fd int32, path uintptr, buf uintptr, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ver=%v fd=%v path=%v buf=%v flag=%v, (%v:)", tls, ver, fd, path, buf, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfstatat(tls, fd, path, buf, flag)
}

func X__lxstat(tls *TLS, ver int32, path uintptr, buf uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ver=%v path=%v buf=%v, (%v:)", tls, ver, path, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xlstat(tls, path, buf)
}

func X__xstat(tls *TLS, ver int32, path uintptr, buf uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ver=%v path=%v buf=%v, (%v:)", tls, ver, path, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstat(tls, path, buf)
}

func X__xmknod(tls *TLS, ver int32, path uintptr, mode Tmode_t, dev uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ver=%v path=%v mode=%v dev=%v, (%v:)", tls, ver, path, mode, dev, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xmknod(tls, path, mode, *(*Tdev_t)(unsafe.Pointer(dev)))
}

func X__xmknodat(tls *TLS, ver int32, fd int32, path uintptr, mode Tmode_t, dev uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ver=%v fd=%v path=%v mode=%v dev=%v, (%v:)", tls, ver, fd, path, mode, dev, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xmknodat(tls, fd, path, mode, *(*Tdev_t)(unsafe.Pointer(dev)))
}

func Xchmod(tls *TLS, path uintptr, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v mode=%v, (%v:)", tls, path, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_fchmodat), int64(-Int32FromInt32(100)), int64(path), int64(mode)))))
}

func Xfchmod(tls *TLS, fd int32, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v mode=%v, (%v:)", tls, fd, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ret int32
	var _ /* buf at bp+0 */ [27]uint8
	_ = ret
	ret = int32(X__syscall2(tls, int64(SYS_fchmod), int64(fd), int64(mode)))
	if ret != -int32(EBADF) || X__syscall2(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_GETFD))) < 0 {
		return int32(X__syscall_ret(tls, uint64(ret)))
	}
	X__procfdname(tls, bp, uint32(fd))
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_fchmodat), int64(-Int32FromInt32(100)), int64(bp), int64(mode)))))
}

func Xfchmodat(tls *TLS, fd int32, path uintptr, mode Tmode_t, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v mode=%v flag=%v, (%v:)", tls, fd, path, mode, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(160)
	defer tls.Free(160)
	var fd2, ret, v1 int32
	var _ /* proc at bp+128 */ [27]uint8
	var _ /* st at bp+0 */ Tstat
	_, _, _ = fd2, ret, v1
	if !(flag != 0) {
		return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_fchmodat), int64(fd), int64(path), int64(mode)))))
	}
	ret = int32(X__syscall4(tls, int64(SYS_fchmodat2), int64(fd), int64(path), int64(mode), int64(flag)))
	if ret != -int32(ENOSYS) {
		return int32(X__syscall_ret(tls, uint64(ret)))
	}
	if flag != int32(AT_SYMLINK_NOFOLLOW) {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
	}
	if Xfstatat(tls, fd, path, bp, flag) != 0 {
		return -int32(1)
	}
	if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(S_IFMT) == uint32(S_IFLNK) {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EOPNOTSUPP))))
	}
	v1 = int32(X__syscall3(tls, int64(SYS_openat), int64(fd), int64(path), int64(Int32FromInt32(O_RDONLY)|Int32FromInt32(O_PATH)|Int32FromInt32(O_NOFOLLOW)|Int32FromInt32(O_NOCTTY)|Int32FromInt32(O_CLOEXEC))))
	fd2 = v1
	if v1 < 0 {
		if fd2 == -int32(ELOOP) {
			return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EOPNOTSUPP))))
		}
		return int32(X__syscall_ret(tls, uint64(fd2)))
	}
	X__procfdname(tls, bp+128, uint32(fd2))
	ret = Xstat(tls, bp+128, bp)
	if !(ret != 0) {
		if (*(*Tstat)(unsafe.Pointer(bp))).Fst_mode&uint32(S_IFMT) == uint32(S_IFLNK) {
			ret = int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EOPNOTSUPP))))
		} else {
			ret = int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_fchmodat), int64(-Int32FromInt32(100)), int64(bp+128), int64(mode)))))
		}
	}
	X__syscall1(tls, int64(SYS_close), int64(fd2))
	return ret
}

func X__fstat(tls *TLS, fd int32, st uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v st=%v, (%v:)", tls, fd, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if fd < 0 {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EBADF))))
	}
	return X__fstatat(tls, fd, __ccgo_ts, st, int32(AT_EMPTY_PATH))
}

func Xfstat(tls *TLS, fd int32, st uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v st=%v, (%v:)", tls, fd, st, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fstat(tls, fd, st)
}

type Tstatx1 = struct {
	Fstx_mask            Tuint32_t
	Fstx_blksize         Tuint32_t
	Fstx_attributes      Tuint64_t
	Fstx_nlink           Tuint32_t
	Fstx_uid             Tuint32_t
	Fstx_gid             Tuint32_t
	Fstx_mode            Tuint16_t
	Fpad1                Tuint16_t
	Fstx_ino             Tuint64_t
	Fstx_size            Tuint64_t
	Fstx_blocks          Tuint64_t
	Fstx_attributes_mask Tuint64_t
	Fstx_atime           struct {
		Ftv_sec  Tint64_t
		Ftv_nsec Tuint32_t
		Fpad     Tint32_t
	}
	Fstx_btime struct {
		Ftv_sec  Tint64_t
		Ftv_nsec Tuint32_t
		Fpad     Tint32_t
	}
	Fstx_ctime struct {
		Ftv_sec  Tint64_t
		Ftv_nsec Tuint32_t
		Fpad     Tint32_t
	}
	Fstx_mtime struct {
		Ftv_sec  Tint64_t
		Ftv_nsec Tuint32_t
		Fpad     Tint32_t
	}
	Fstx_rdev_major Tuint32_t
	Fstx_rdev_minor Tuint32_t
	Fstx_dev_major  Tuint32_t
	Fstx_dev_minor  Tuint32_t
	Fspare          [14]Tuint64_t
}

func _fstatat_statx(tls *TLS, fd int32, path uintptr, st uintptr, flag int32) (r int32) {
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var ret int32
	var _ /* stx at bp+0 */ Tstatx1
	_ = ret
	flag |= int32(AT_NO_AUTOMOUNT)
	ret = int32(X__syscall5(tls, int64(SYS_statx), int64(fd), int64(path), int64(flag), int64(Int32FromInt32(0x7ff)), int64(bp)))
	if ret != 0 {
		return ret
	}
	*(*Tstat)(unsafe.Pointer(st)) = Tstat{
		Fst_dev:     uint64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_dev_major)&Uint64FromUint64(0xfffff000)<<Int32FromInt32(32) | uint64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_dev_major)&Uint64FromUint64(0x00000fff)<<Int32FromInt32(8) | uint64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_dev_minor)&Uint64FromUint64(0xffffff00)<<Int32FromInt32(12) | uint64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_dev_minor)&Uint64FromUint64(0x000000ff),
		Fst_ino:     (*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_ino,
		Fst_mode:    uint32((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_mode),
		Fst_nlink:   (*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_nlink,
		Fst_uid:     (*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_uid,
		Fst_gid:     (*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_gid,
		Fst_rdev:    uint64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_rdev_major)&Uint64FromUint64(0xfffff000)<<Int32FromInt32(32) | uint64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_rdev_major)&Uint64FromUint64(0x00000fff)<<Int32FromInt32(8) | uint64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_rdev_minor)&Uint64FromUint64(0xffffff00)<<Int32FromInt32(12) | uint64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_rdev_minor)&Uint64FromUint64(0x000000ff),
		Fst_size:    int64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_size),
		Fst_blksize: int32((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_blksize),
		Fst_blocks:  int64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_blocks),
		Fst_atim: Ttimespec{
			Ftv_sec:  (*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_atime.Ftv_sec,
			Ftv_nsec: int64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_atime.Ftv_nsec),
		},
		Fst_mtim: Ttimespec{
			Ftv_sec:  (*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_mtime.Ftv_sec,
			Ftv_nsec: int64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_mtime.Ftv_nsec),
		},
		Fst_ctim: Ttimespec{
			Ftv_sec:  (*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_ctime.Ftv_sec,
			Ftv_nsec: int64((*(*Tstatx1)(unsafe.Pointer(bp))).Fstx_ctime.Ftv_nsec),
		},
	}
	return 0
}

type Tkstat = struct {
	Fst_dev        Tdev_t
	Fst_ino        Tino_t
	Fst_mode       Tmode_t
	Fst_nlink      Tnlink_t
	Fst_uid        Tuid_t
	Fst_gid        Tgid_t
	Fst_rdev       Tdev_t
	F__pad         uint64
	Fst_size       Toff_t
	Fst_blksize    Tblksize_t
	F__pad2        int32
	Fst_blocks     Tblkcnt_t
	Fst_atime_sec  int64
	Fst_atime_nsec int64
	Fst_mtime_sec  int64
	Fst_mtime_nsec int64
	Fst_ctime_sec  int64
	Fst_ctime_nsec int64
	F__unused      [2]uint32
}

func _fstatat_kstat(tls *TLS, fd int32, path uintptr, st uintptr, flag int32) (r int32) {
	bp := tls.Alloc(160)
	defer tls.Free(160)
	var ret int32
	var _ /* buf at bp+128 */ [27]uint8
	var _ /* kst at bp+0 */ Tkstat
	_ = ret
	if flag == int32(AT_EMPTY_PATH) && fd >= 0 && !(*(*uint8)(unsafe.Pointer(path)) != 0) {
		ret = int32(X__syscall2(tls, int64(SYS_fstat), int64(fd), int64(bp)))
		if ret == -int32(EBADF) && X__syscall2(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_GETFD))) >= 0 {
			ret = int32(X__syscall4(tls, int64(SYS_newfstatat), int64(fd), int64(path), int64(bp), int64(flag)))
			if ret == -int32(EINVAL) {
				X__procfdname(tls, bp+128, uint32(fd))
				ret = int32(X__syscall4(tls, int64(SYS_newfstatat), int64(-Int32FromInt32(100)), int64(bp+128), int64(bp), int64(Int32FromInt32(0))))
			}
		}
	} else {
		ret = int32(X__syscall4(tls, int64(SYS_newfstatat), int64(fd), int64(path), int64(bp), int64(flag)))
	}
	if ret != 0 {
		return ret
	}
	*(*Tstat)(unsafe.Pointer(st)) = Tstat{
		Fst_dev:     (*(*Tkstat)(unsafe.Pointer(bp))).Fst_dev,
		Fst_ino:     (*(*Tkstat)(unsafe.Pointer(bp))).Fst_ino,
		Fst_mode:    (*(*Tkstat)(unsafe.Pointer(bp))).Fst_mode,
		Fst_nlink:   (*(*Tkstat)(unsafe.Pointer(bp))).Fst_nlink,
		Fst_uid:     (*(*Tkstat)(unsafe.Pointer(bp))).Fst_uid,
		Fst_gid:     (*(*Tkstat)(unsafe.Pointer(bp))).Fst_gid,
		Fst_rdev:    (*(*Tkstat)(unsafe.Pointer(bp))).Fst_rdev,
		Fst_size:    (*(*Tkstat)(unsafe.Pointer(bp))).Fst_size,
		Fst_blksize: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_blksize,
		Fst_blocks:  (*(*Tkstat)(unsafe.Pointer(bp))).Fst_blocks,
		Fst_atim: Ttimespec{
			Ftv_sec:  (*(*Tkstat)(unsafe.Pointer(bp))).Fst_atime_sec,
			Ftv_nsec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_atime_nsec,
		},
		Fst_mtim: Ttimespec{
			Ftv_sec:  (*(*Tkstat)(unsafe.Pointer(bp))).Fst_mtime_sec,
			Ftv_nsec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_mtime_nsec,
		},
		Fst_ctim: Ttimespec{
			Ftv_sec:  (*(*Tkstat)(unsafe.Pointer(bp))).Fst_ctime_sec,
			Ftv_nsec: (*(*Tkstat)(unsafe.Pointer(bp))).Fst_ctime_nsec,
		},
	}
	return 0
}

func X__fstatat(tls *TLS, fd int32, path uintptr, st uintptr, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v st=%v flag=%v, (%v:)", tls, fd, path, st, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int32
	_ = ret
	if uint64(8) < uint64(8) {
		ret = _fstatat_statx(tls, fd, path, st, flag)
		if ret != -int32(ENOSYS) {
			return int32(X__syscall_ret(tls, uint64(ret)))
		}
	}
	ret = _fstatat_kstat(tls, fd, path, st, flag)
	return int32(X__syscall_ret(tls, uint64(ret)))
}

func Xfstatat(tls *TLS, fd int32, path uintptr, st uintptr, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v st=%v flag=%v, (%v:)", tls, fd, path, st, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fstatat(tls, fd, path, st, flag)
}

func Xfutimens(tls *TLS, fd int32, times uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v times=%v, (%v:)", tls, fd, times, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xutimensat(tls, fd, uintptr(0), times, 0)
}

func X__futimesat(tls *TLS, dirfd int32, pathname uintptr, times uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v dirfd=%v pathname=%v times=%v, (%v:)", tls, dirfd, pathname, times, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i int32
	var v2 uintptr
	var _ /* ts at bp+0 */ [2]Ttimespec
	_, _ = i, v2
	if times != 0 {
		i = 0
		for {
			if !(i < int32(2)) {
				break
			}
			if uint64((*(*Ttimeval)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_usec) >= uint64(1000000) {
				return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
			}
			(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[i].Ftv_sec = (*(*Ttimeval)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_sec
			(*(*[2]Ttimespec)(unsafe.Pointer(bp)))[i].Ftv_nsec = (*(*Ttimeval)(unsafe.Pointer(times + uintptr(i)*16))).Ftv_usec * int64(1000)
			goto _1
		_1:
			;
			i++
		}
	}
	if times != 0 {
		v2 = bp
	} else {
		v2 = uintptr(0)
	}
	return Xutimensat(tls, dirfd, pathname, v2, 0)
}

func Xfutimesat(tls *TLS, dirfd int32, pathname uintptr, times uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v dirfd=%v pathname=%v times=%v, (%v:)", tls, dirfd, pathname, times, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__futimesat(tls, dirfd, pathname, times)
}

func Xlchmod(tls *TLS, path uintptr, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v mode=%v, (%v:)", tls, path, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfchmodat(tls, -int32(100), path, mode, int32(AT_SYMLINK_NOFOLLOW))
}

func Xlstat(tls *TLS, path uintptr, buf uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v buf=%v, (%v:)", tls, path, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfstatat(tls, -int32(100), path, buf, int32(AT_SYMLINK_NOFOLLOW))
}

func Xmkdir(tls *TLS, path uintptr, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v mode=%v, (%v:)", tls, path, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_mkdirat), int64(-Int32FromInt32(100)), int64(path), int64(mode)))))
}

func Xmkdirat(tls *TLS, fd int32, path uintptr, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v mode=%v, (%v:)", tls, fd, path, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_mkdirat), int64(fd), int64(path), int64(mode)))))
}

func Xmkfifo(tls *TLS, path uintptr, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v mode=%v, (%v:)", tls, path, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xmknod(tls, path, mode|uint32(S_IFIFO), uint64(0))
}

func Xmkfifoat(tls *TLS, fd int32, path uintptr, mode Tmode_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v mode=%v, (%v:)", tls, fd, path, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xmknodat(tls, fd, path, mode|uint32(S_IFIFO), uint64(0))
}

func Xmknod(tls *TLS, path uintptr, mode Tmode_t, dev Tdev_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v mode=%v dev=%v, (%v:)", tls, path, mode, dev, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_mknodat), int64(-Int32FromInt32(100)), int64(path), int64(mode), int64(dev)))))
}

func Xmknodat(tls *TLS, fd int32, path uintptr, mode Tmode_t, dev Tdev_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v mode=%v dev=%v, (%v:)", tls, fd, path, mode, dev, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_mknodat), int64(fd), int64(path), int64(mode), int64(dev)))))
}

func Xstat(tls *TLS, path uintptr, buf uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v buf=%v, (%v:)", tls, path, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfstatat(tls, -int32(100), path, buf, 0)
}

func ___statfs(tls *TLS, path uintptr, buf uintptr) (r int32) {
	*(*Tstatfs)(unsafe.Pointer(buf)) = Tstatfs{}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_statfs), int64(path), int64(buf)))))
}

func Xfstatfs(tls *TLS, fd int32, buf uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v, (%v:)", tls, fd, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	*(*Tstatfs)(unsafe.Pointer(buf)) = Tstatfs{}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_fstatfs), int64(fd), int64(buf)))))
}

func _fixup(tls *TLS, out uintptr, in uintptr) {
	var v1 uint64
	_ = v1
	*(*Tstatvfs)(unsafe.Pointer(out)) = Tstatvfs{}
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_bsize = (*Tstatfs)(unsafe.Pointer(in)).Ff_bsize
	if (*Tstatfs)(unsafe.Pointer(in)).Ff_frsize != 0 {
		v1 = (*Tstatfs)(unsafe.Pointer(in)).Ff_frsize
	} else {
		v1 = (*Tstatfs)(unsafe.Pointer(in)).Ff_bsize
	}
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_frsize = v1
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_blocks = (*Tstatfs)(unsafe.Pointer(in)).Ff_blocks
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_bfree = (*Tstatfs)(unsafe.Pointer(in)).Ff_bfree
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_bavail = (*Tstatfs)(unsafe.Pointer(in)).Ff_bavail
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_files = (*Tstatfs)(unsafe.Pointer(in)).Ff_files
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_ffree = (*Tstatfs)(unsafe.Pointer(in)).Ff_ffree
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_favail = (*Tstatfs)(unsafe.Pointer(in)).Ff_ffree
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_fsid = uint64(*(*int32)(unsafe.Pointer(in + 56)))
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_flag = (*Tstatfs)(unsafe.Pointer(in)).Ff_flags
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_namemax = (*Tstatfs)(unsafe.Pointer(in)).Ff_namelen
	(*Tstatvfs)(unsafe.Pointer(out)).Ff_type = uint32((*Tstatfs)(unsafe.Pointer(in)).Ff_type)
}

func Xstatvfs(tls *TLS, path uintptr, buf uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v buf=%v, (%v:)", tls, path, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var _ /* kbuf at bp+0 */ Tstatfs
	if ___statfs(tls, path, bp) < 0 {
		return -int32(1)
	}
	_fixup(tls, buf, bp)
	return 0
}

func Xfstatvfs(tls *TLS, fd int32, buf uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v, (%v:)", tls, fd, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var _ /* kbuf at bp+0 */ Tstatfs
	if Xfstatfs(tls, fd, bp) < 0 {
		return -int32(1)
	}
	_fixup(tls, buf, bp)
	return 0
}

func Xumask(tls *TLS, mode Tmode_t) (r Tmode_t) {
	if __ccgo_strace {
		trc("tls=%v mode=%v, (%v:)", tls, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_umask), int64(mode)))))
}

func Xutimensat(tls *TLS, fd int32, path uintptr, times uintptr, flags int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v times=%v flags=%v, (%v:)", tls, fd, path, times, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	if times != 0 && (*(*Ttimespec)(unsafe.Pointer(times))).Ftv_nsec == int64(UTIME_NOW) && (*(*Ttimespec)(unsafe.Pointer(times + 1*16))).Ftv_nsec == int64(UTIME_NOW) {
		times = uintptr(0)
	}
	r = int32(X__syscall4(tls, int64(SYS_utimensat), int64(fd), int64(path), int64(times), int64(flags)))
	return int32(X__syscall_ret(tls, uint64(r)))
}

func X__fclose_ca(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fclose1})))(tls, f)
}

func X__fdopen(tls *TLS, fd int32, mode uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v fd=%v mode=%v, (%v:)", tls, fd, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var f, v1 uintptr
	var flags, v2 int32
	var _ /* wsz at bp+0 */ Twinsize
	_, _, _, _ = f, flags, v1, v2
	/* Check for valid initial mode character */
	if !(Xstrchr(tls, __ccgo_ts+1504, int32(*(*uint8)(unsafe.Pointer(mode)))) != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	/* Allocate FILE+buffer or fail */
	v1 = Xmalloc(tls, Uint64FromInt64(232)+Uint64FromInt32(UNGET)+Uint64FromInt32(BUFSIZ))
	f = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	/* Zero-fill only the struct, not the buffer */
	Xmemset(tls, f, 0, uint64(232))
	/* Impose mode restrictions */
	if !(Xstrchr(tls, mode, int32('+')) != 0) {
		if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('r') {
			v2 = int32(F_NOWR)
		} else {
			v2 = int32(F_NORD)
		}
		(*TFILE)(unsafe.Pointer(f)).Fflags = uint32(v2)
	}
	/* Apply close-on-exec flag */
	if Xstrchr(tls, mode, int32('e')) != 0 {
		X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
	}
	/* Set append mode on fd if opened for append */
	if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('a') {
		flags = int32(X__syscall2(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_GETFL))))
		if !(flags&Int32FromInt32(O_APPEND) != 0) {
			X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_SETFL)), int64(flags|Int32FromInt32(O_APPEND)))
		}
		*(*uint32)(unsafe.Pointer(f)) |= uint32(F_APP)
	}
	(*TFILE)(unsafe.Pointer(f)).Ffd = fd
	(*TFILE)(unsafe.Pointer(f)).Fbuf = f + uintptr(232) + uintptr(UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fbuf_size = uint64(BUFSIZ)
	/* Activate line buffered mode for terminals */
	(*TFILE)(unsafe.Pointer(f)).Flbf = -int32(1)
	if !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_NOWR) != 0) && !(X__syscall3(tls, int64(SYS_ioctl), int64(fd), int64(Int32FromInt32(TIOCGWINSZ)), int64(bp)) != 0) {
		(*TFILE)(unsafe.Pointer(f)).Flbf = int32('\n')
	}
	/* Initialize op ptrs. No problem if some are unneeded. */
	(*TFILE)(unsafe.Pointer(f)).Fread = __ccgo_fp(X__stdio_read)
	(*TFILE)(unsafe.Pointer(f)).Fwrite = __ccgo_fp(X__stdio_write)
	(*TFILE)(unsafe.Pointer(f)).Fseek = __ccgo_fp(X__stdio_seek)
	(*TFILE)(unsafe.Pointer(f)).Fclose1 = __ccgo_fp(X__stdio_close)
	if !(X__libc.Fthreaded != 0) {
		AtomicStorePInt32(f+140, -int32(1))
	}
	/* Add new FILE to open file list */
	return X__ofl_add(tls, f)
}

func Xfdopen(tls *TLS, fd int32, mode uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v fd=%v mode=%v, (%v:)", tls, fd, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fdopen(tls, fd, mode)
}

func X__fmodeflags(tls *TLS, mode uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v mode=%v, (%v:)", tls, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var flags int32
	_ = flags
	if Xstrchr(tls, mode, int32('+')) != 0 {
		flags = int32(O_RDWR)
	} else {
		if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('r') {
			flags = O_RDONLY
		} else {
			flags = int32(O_WRONLY)
		}
	}
	if Xstrchr(tls, mode, int32('x')) != 0 {
		flags |= int32(O_EXCL)
	}
	if Xstrchr(tls, mode, int32('e')) != 0 {
		flags |= int32(O_CLOEXEC)
	}
	if int32(*(*uint8)(unsafe.Pointer(mode))) != int32('r') {
		flags |= int32(O_CREAT)
	}
	if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('w') {
		flags |= int32(O_TRUNC)
	}
	if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('a') {
		flags |= int32(O_APPEND)
	}
	return flags
}

func X__fopen_rb_ca(tls *TLS, filename uintptr, f uintptr, buf uintptr, len1 Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v filename=%v f=%v buf=%v len1=%v, (%v:)", tls, filename, f, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	Xmemset(tls, f, 0, uint64(232))
	(*TFILE)(unsafe.Pointer(f)).Ffd = int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_openat), int64(-Int32FromInt32(100)), int64(filename), int64(Int32FromInt32(O_RDONLY)|Int32FromInt32(O_CLOEXEC)|Int32FromInt32(O_LARGEFILE))))))
	if (*TFILE)(unsafe.Pointer(f)).Ffd < 0 {
		return uintptr(0)
	}
	X__syscall3(tls, int64(SYS_fcntl), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
	(*TFILE)(unsafe.Pointer(f)).Fflags = uint32(Int32FromInt32(F_NOWR) | Int32FromInt32(F_PERM))
	(*TFILE)(unsafe.Pointer(f)).Fbuf = buf + uintptr(UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fbuf_size = len1 - uint64(UNGET)
	(*TFILE)(unsafe.Pointer(f)).Fread = __ccgo_fp(X__stdio_read)
	(*TFILE)(unsafe.Pointer(f)).Fseek = __ccgo_fp(X__stdio_seek)
	(*TFILE)(unsafe.Pointer(f)).Fclose1 = __ccgo_fp(X__stdio_close)
	AtomicStorePInt32(f+140, -int32(1))
	return f
}

func X__overflow(tls *TLS, f uintptr, _c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v _c=%v, (%v:)", tls, f, _c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 uint8
	var v2, v3 uintptr
	var _ /* c at bp+0 */ uint8
	_, _, _ = v1, v2, v3
	*(*uint8)(unsafe.Pointer(bp)) = uint8(_c)
	if !((*TFILE)(unsafe.Pointer(f)).Fwend != 0) && X__towrite(tls, f) != 0 {
		return -int32(1)
	}
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend && int32(*(*uint8)(unsafe.Pointer(bp))) != (*TFILE)(unsafe.Pointer(f)).Flbf {
		v1 = *(*uint8)(unsafe.Pointer(bp))
		v3 = f + 40
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		*(*uint8)(unsafe.Pointer(v2)) = v1
		return int32(v1)
	}
	if (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, bp, uint64(1)) != uint64(1) {
		return -int32(1)
	}
	return int32(*(*uint8)(unsafe.Pointer(bp)))
}

func _dummy9(tls *TLS, fd int32) (r int32) {
	return fd
}

func X__stdio_close(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_close), int64(_dummy9(tls, (*TFILE)(unsafe.Pointer(f)).Ffd))))))
}

var _dummy_file = uintptr(0)

func _close_file(tls *TLS, f uintptr) {
	if !(f != 0) {
		return
	}
	if AtomicLoadPInt32(f+140) >= 0 {
		___lockfile(tls, f)
	}
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
	}
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		(*(*func(*TLS, uintptr, Toff_t, int32) Toff_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Frend), int32(1))
	}
}

func X__stdio_exit(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	var f uintptr
	_ = f
	f = *(*uintptr)(unsafe.Pointer(X__ofl_lock(tls)))
	for {
		if !(f != 0) {
			break
		}
		_close_file(tls, f)
		goto _1
	_1:
		;
		f = (*TFILE)(unsafe.Pointer(f)).Fnext
	}
	_close_file(tls, AtomicLoadPUintptr(uintptr(unsafe.Pointer(&X__stdin_used))))
	_close_file(tls, AtomicLoadPUintptr(uintptr(unsafe.Pointer(&X__stdout_used))))
	_close_file(tls, AtomicLoadPUintptr(uintptr(unsafe.Pointer(&X__stderr_used))))
}

func X__stdio_exit_needed(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	X__stdio_exit(tls)
}

func X__stdio_read(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v buf=%v len1=%v, (%v:)", tls, f, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var cnt Tssize_t
	var v1 int64
	var v2 int32
	var v3, v4 uintptr
	var _ /* iov at bp+0 */ [2]Tiovec
	_, _, _, _, _ = cnt, v1, v2, v3, v4
	*(*[2]Tiovec)(unsafe.Pointer(bp)) = [2]Tiovec{
		0: {
			Fiov_base: buf,
			Fiov_len:  len1 - BoolUint64(!!((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0)),
		},
		1: {
			Fiov_base: (*TFILE)(unsafe.Pointer(f)).Fbuf,
			Fiov_len:  (*TFILE)(unsafe.Pointer(f)).Fbuf_size,
		},
	}
	if (*(*[2]Tiovec)(unsafe.Pointer(bp)))[0].Fiov_len != 0 {
		v1 = X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_readv), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(bp), int64(Int32FromInt32(2)))))
	} else {
		v1 = X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_read), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64((*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(1)].Fiov_base), int64((*(*[2]Tiovec)(unsafe.Pointer(bp)))[int32(1)].Fiov_len))))
	}
	cnt = v1
	if cnt <= 0 {
		if cnt != 0 {
			v2 = int32(F_ERR)
		} else {
			v2 = int32(F_EOF)
		}
		*(*uint32)(unsafe.Pointer(f)) |= uint32(v2)
		return uint64(0)
	}
	if uint64(cnt) <= (*(*[2]Tiovec)(unsafe.Pointer(bp)))[0].Fiov_len {
		return uint64(cnt)
	}
	cnt = Tssize_t(uint64(cnt) - (*(*[2]Tiovec)(unsafe.Pointer(bp)))[0].Fiov_len)
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(cnt)
	if (*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0 {
		v4 = f + 8
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(buf + uintptr(len1-uint64(1)))) = *(*uint8)(unsafe.Pointer(v3))
	}
	return len1
}

func X__stdio_seek(tls *TLS, f uintptr, off Toff_t, whence int32) (r Toff_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v off=%v whence=%v, (%v:)", tls, f, off, whence, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lseek(tls, (*TFILE)(unsafe.Pointer(f)).Ffd, off, whence)
}

func X__stdio_write(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v buf=%v len1=%v, (%v:)", tls, f, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var cnt Tssize_t
	var iov, v2, v3, v4 uintptr
	var iovcnt int32
	var rem Tsize_t
	var v5 uint64
	var _ /* iovs at bp+0 */ [2]Tiovec
	_, _, _, _, _, _, _, _ = cnt, iov, iovcnt, rem, v2, v3, v4, v5
	*(*[2]Tiovec)(unsafe.Pointer(bp)) = [2]Tiovec{
		0: {
			Fiov_base: (*TFILE)(unsafe.Pointer(f)).Fwbase,
			Fiov_len:  uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase)),
		},
		1: {
			Fiov_base: buf,
			Fiov_len:  len1,
		},
	}
	iov = bp
	rem = (*(*Tiovec)(unsafe.Pointer(iov))).Fiov_len + (*(*Tiovec)(unsafe.Pointer(iov + 1*16))).Fiov_len
	iovcnt = int32(2)
	for {
		cnt = X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_writev), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(iov), int64(iovcnt))))
		if uint64(cnt) == rem {
			(*TFILE)(unsafe.Pointer(f)).Fwend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
			v2 = (*TFILE)(unsafe.Pointer(f)).Fbuf
			(*TFILE)(unsafe.Pointer(f)).Fwbase = v2
			(*TFILE)(unsafe.Pointer(f)).Fwpos = v2
			return len1
		}
		if cnt < 0 {
			v4 = UintptrFromInt32(0)
			(*TFILE)(unsafe.Pointer(f)).Fwend = v4
			v3 = v4
			(*TFILE)(unsafe.Pointer(f)).Fwbase = v3
			(*TFILE)(unsafe.Pointer(f)).Fwpos = v3
			*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
			if iovcnt == int32(2) {
				v5 = uint64(0)
			} else {
				v5 = len1 - (*(*Tiovec)(unsafe.Pointer(iov))).Fiov_len
			}
			return v5
		}
		rem -= uint64(cnt)
		if uint64(cnt) > (*(*Tiovec)(unsafe.Pointer(iov))).Fiov_len {
			cnt = Tssize_t(uint64(cnt) - (*(*Tiovec)(unsafe.Pointer(iov))).Fiov_len)
			iov += 16
			iovcnt--
		}
		(*(*Tiovec)(unsafe.Pointer(iov))).Fiov_base = (*(*Tiovec)(unsafe.Pointer(iov))).Fiov_base + uintptr(cnt)
		(*(*Tiovec)(unsafe.Pointer(iov))).Fiov_len -= uint64(cnt)
		goto _1
	_1:
	}
	return r
}

func X__stdout_write(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v buf=%v len1=%v, (%v:)", tls, f, buf, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* wsz at bp+0 */ Twinsize
	(*TFILE)(unsafe.Pointer(f)).Fwrite = __ccgo_fp(X__stdio_write)
	if !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_SVB) != 0) && X__syscall3(tls, int64(SYS_ioctl), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(TIOCGWINSZ)), int64(bp)) != 0 {
		(*TFILE)(unsafe.Pointer(f)).Flbf = -int32(1)
	}
	return X__stdio_write(tls, f, buf, len1)
}

func X__toread(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2, v3 uintptr
	var v4 int32
	_, _, _, _ = v1, v2, v3, v4
	*(*int32)(unsafe.Pointer(f + 136)) |= (*TFILE)(unsafe.Pointer(f)).Fmode - int32(1)
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
	}
	v2 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v2
	v1 = v2
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v1
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v1
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_NORD) != 0 {
		*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
		return -int32(1)
	}
	v3 = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
	(*TFILE)(unsafe.Pointer(f)).Frend = v3
	(*TFILE)(unsafe.Pointer(f)).Frpos = v3
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_EOF) != 0 {
		v4 = -int32(1)
	} else {
		v4 = 0
	}
	return v4
}

func X__toread_needs_stdio_exit(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	X__stdio_exit_needed(tls)
}

func X__towrite(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2 uintptr
	_, _ = v1, v2
	*(*int32)(unsafe.Pointer(f + 136)) |= (*TFILE)(unsafe.Pointer(f)).Fmode - int32(1)
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_NOWR) != 0 {
		*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
		return -int32(1)
	}
	/* Clear read buffer (easier than summoning nasal demons) */
	v1 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frend = v1
	(*TFILE)(unsafe.Pointer(f)).Frpos = v1
	/* Activate write through the buffer. */
	v2 = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v2
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v2
	(*TFILE)(unsafe.Pointer(f)).Fwend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
	return 0
}

func X__towrite_needs_stdio_exit(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	X__stdio_exit_needed(tls)
}

/* This function assumes it will never be called if there is already
 * data buffered for reading. */

func X__uflow(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* c at bp+0 */ uint8
	if !(X__toread(tls, f) != 0) && (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fread})))(tls, f, bp, uint64(1)) == uint64(1) {
		return int32(*(*uint8)(unsafe.Pointer(bp)))
	}
	return -int32(1)
}

func Xasprintf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v va=%v, (%v:)", tls, s, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvasprintf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func Xclearerr(tls *TLS, f uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	var __need_unlock, v1 int32
	_, _ = __need_unlock, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^(Int32FromInt32(F_EOF) | Int32FromInt32(F_ERR)))
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
}

func Xclearerr_unlocked(tls *TLS, f uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	Xclearerr(tls, f)
}

func Xdprintf(tls *TLS, fd int32, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v fmt=%v va=%v, (%v:)", tls, fd, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvdprintf(tls, fd, fmt, ap)
	_ = ap
	return ret
}

const FSETLOCKING_BYCALLER = 2
const FSETLOCKING_INTERNAL = 1
const FSETLOCKING_QUERY = 0

func X_flushlbf(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	Xfflush(tls, uintptr(0))
}

func X__fsetlocking(tls *TLS, f uintptr, type1 int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v type1=%v, (%v:)", tls, f, type1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return 0
}

func X__fwriting(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32((*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_NORD) != 0 || (*TFILE)(unsafe.Pointer(f)).Fwend != 0)
}

func X__freading(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32((*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_NOWR) != 0 || (*TFILE)(unsafe.Pointer(f)).Frend != 0)
}

func X__freadable(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_NORD) != 0))
}

func X__fwritable(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32(!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_NOWR) != 0))
}

func X__flbf(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return BoolInt32((*TFILE)(unsafe.Pointer(f)).Flbf >= 0)
}

func X__fbufsize(tls *TLS, f uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return (*TFILE)(unsafe.Pointer(f)).Fbuf_size
}

func X__fpending(tls *TLS, f uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int64
	_ = v1
	if (*TFILE)(unsafe.Pointer(f)).Fwend != 0 {
		v1 = int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase)
	} else {
		v1 = 0
	}
	return uint64(v1)
}

func X__fpurge(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2, v3 uintptr
	_, _, _ = v1, v2, v3
	if !(f != 0) { // libbsd fpurge test fails w/o this.
		return int32(1)
	}
	v2 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v2
	v1 = v2
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v1
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v1
	v3 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frend = v3
	(*TFILE)(unsafe.Pointer(f)).Frpos = v3
	return 0
}

func Xfpurge(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fpurge(tls, f)
}

func X__freadahead(tls *TLS, f uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int64
	_ = v1
	if (*TFILE)(unsafe.Pointer(f)).Frend != 0 {
		v1 = int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
	} else {
		v1 = 0
	}
	return uint64(v1)
}

func X__freadptr(tls *TLS, f uintptr, sizep uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v sizep=%v, (%v:)", tls, f, sizep, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if (*TFILE)(unsafe.Pointer(f)).Frpos == (*TFILE)(unsafe.Pointer(f)).Frend {
		return uintptr(0)
	}
	*(*Tsize_t)(unsafe.Pointer(sizep)) = uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos))
	return (*TFILE)(unsafe.Pointer(f)).Frpos
}

func X__freadptrinc(tls *TLS, f uintptr, inc Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v inc=%v, (%v:)", tls, f, inc, origin(2))
	}
	*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(inc)
}

func X__fseterr(tls *TLS, f uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
}

func _dummy10(tls *TLS, f uintptr) {
}

func Xfclose(tls *TLS, f uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var __need_unlock, r, v1 int32
	var head uintptr
	_, _, _, _ = __need_unlock, head, r, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	r = Xfflush(tls, f)
	r |= (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fclose1})))(tls, f)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	/* Past this point, f is closed and any further explict access
	 * to it is undefined. However, it still exists as an entry in
	 * the open file list and possibly in the thread's locked files
	 * list, if it was closed while explicitly locked. Functions
	 * which process these lists must tolerate dead FILE objects
	 * (which necessarily have inactive buffer pointers) without
	 * producing any side effects. */
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_PERM) != 0 {
		return r
	}
	X__unlist_locked_file(tls, f)
	head = X__ofl_lock(tls)
	if (*TFILE)(unsafe.Pointer(f)).Fprev != 0 {
		(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fprev)).Fnext = (*TFILE)(unsafe.Pointer(f)).Fnext
	}
	if (*TFILE)(unsafe.Pointer(f)).Fnext != 0 {
		(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fnext)).Fprev = (*TFILE)(unsafe.Pointer(f)).Fprev
	}
	if *(*uintptr)(unsafe.Pointer(head)) == f {
		*(*uintptr)(unsafe.Pointer(head)) = (*TFILE)(unsafe.Pointer(f)).Fnext
	}
	X__ofl_unlock(tls)
	Xfree(tls, (*TFILE)(unsafe.Pointer(f)).Fgetln_buf)
	Xfree(tls, f)
	return r
}

func Xfeof(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, ret, v1 int32
	_, _, _ = __need_unlock, ret, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	ret = BoolInt32(!!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_EOF) != 0))
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return ret
}

func X_IO_feof_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfeof(tls, f)
}

func Xfeof_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfeof(tls, f)
}

func Xferror(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, ret, v1 int32
	_, _, _ = __need_unlock, ret, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	ret = BoolInt32(!!((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_ERR) != 0))
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return ret
}

func X_IO_ferror_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xferror(tls, f)
}

func Xferror_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xferror(tls, f)
}

// C documentation
//
//	/* stdout.c will override this if linked */
var _dummy11 = uintptr(0)

func Xfflush(tls *TLS, f uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var __need_unlock, __need_unlock1, r, v2, v3 int32
	var v4, v5, v6 uintptr
	_, _, _, _, _, _, _, _ = __need_unlock, __need_unlock1, r, v2, v3, v4, v5, v6
	if !(f != 0) {
		r = 0
		if AtomicLoadPUintptr(uintptr(unsafe.Pointer(&X__stdout_used))) != 0 {
			r |= Xfflush(tls, AtomicLoadPUintptr(uintptr(unsafe.Pointer(&X__stdout_used))))
		}
		if AtomicLoadPUintptr(uintptr(unsafe.Pointer(&X__stderr_used))) != 0 {
			r |= Xfflush(tls, AtomicLoadPUintptr(uintptr(unsafe.Pointer(&X__stderr_used))))
		}
		f = *(*uintptr)(unsafe.Pointer(X__ofl_lock(tls)))
		for {
			if !(f != 0) {
				break
			}
			if AtomicLoadPInt32(f+140) >= 0 {
				v2 = ___lockfile(tls, f)
			} else {
				v2 = 0
			}
			__need_unlock = v2
			if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
				r |= Xfflush(tls, f)
			}
			if __need_unlock != 0 {
				___unlockfile(tls, f)
			}
			goto _1
		_1:
			;
			f = (*TFILE)(unsafe.Pointer(f)).Fnext
		}
		X__ofl_unlock(tls)
		return r
	}
	if AtomicLoadPInt32(f+140) >= 0 {
		v3 = ___lockfile(tls, f)
	} else {
		v3 = 0
	}
	__need_unlock1 = v3
	/* If writing, flush output */
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
		if !((*TFILE)(unsafe.Pointer(f)).Fwpos != 0) {
			if __need_unlock1 != 0 {
				___unlockfile(tls, f)
			}
			return -int32(1)
		}
	}
	/* If reading, sync position, per POSIX */
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		(*(*func(*TLS, uintptr, Toff_t, int32) Toff_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Frend), int32(1))
	}
	/* Clear read and write modes */
	v5 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v5
	v4 = v5
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v4
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v4
	v6 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frend = v6
	(*TFILE)(unsafe.Pointer(f)).Frpos = v6
	if __need_unlock1 != 0 {
		___unlockfile(tls, f)
	}
	return 0
}

func Xfflush_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfflush(tls, f)
}

func _locking_getc(tls *TLS, f uintptr) (r1 int32) {
	var c, old, old1, r, v, v13, v16, v18, v2, v21, v22, v5, v7, v9 int32
	var v1, v10, v11, v12, v20 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, old, old1, r, v, v1, v10, v11, v12, v13, v16, v18, v2, v20, v21, v22, v5, v7, v9
	v1 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1508)
		v5 = v
		goto _6
	_6:
		old = v5
		if old != 0 {
			// __asm__ __volatile__ ("dmb ish" : : : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1508)
			break
		}
		goto _4
	_4:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1508)
		v2 = BoolInt32(!(r != 0))
		goto _3
	_3:
		;
		if !!(v2 != 0) {
			break
		}
	}
	v7 = old
	goto _8
_8:
	if v7 != 0 {
		___lockfile(tls, f)
	}
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		v11 = f + 8
		v10 = *(*uintptr)(unsafe.Pointer(v11))
		*(*uintptr)(unsafe.Pointer(v11))++
		v9 = int32(*(*uint8)(unsafe.Pointer(v10)))
	} else {
		v9 = X__uflow(tls, f)
	}
	c = v9
	v12 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1508)
		v16 = v
		goto _17
	_17:
		old1 = v16
		goto _15
	_15:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1508)
		v13 = BoolInt32(!(r != 0))
		goto _14
	_14:
		;
		if !!(v13 != 0) {
			break
		}
	}
	v18 = old1
	goto _19
_19:
	if v18&int32(MAYBE_WAITERS) != 0 {
		v20 = f + 140
		v21 = int32(1)
		v22 = int32(1)
		if v22 != 0 {
			v22 = int32(FUTEX_PRIVATE)
		}
		if v21 < Int32FromInt32(0) {
			v21 = int32(INT_MAX)
		}
		_ = X__syscall3(tls, int64(SYS_futex), int64(v20), int64(Int32FromInt32(FUTEX_WAKE)|v22), int64(v21)) != int64(-int32(ENOSYS)) || X__syscall3(tls, int64(SYS_futex), int64(v20), int64(Int32FromInt32(FUTEX_WAKE)), int64(v21)) != 0
	}
	return c
}

func Xfgetc(tls *TLS, f1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f1=%v, (%v:)", tls, f1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l, v2, v4 int32
	var v1, v5, v6 uintptr
	_, _, _, _, _, _ = l, v1, v2, v4, v5, v6
	v1 = f1
	l = AtomicLoadPInt32(v1 + 140)
	if l < 0 || l != 0 && l & ^Int32FromInt32(MAYBE_WAITERS) == (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
		if (*TFILE)(unsafe.Pointer(v1)).Frpos != (*TFILE)(unsafe.Pointer(v1)).Frend {
			v6 = v1 + 8
			v5 = *(*uintptr)(unsafe.Pointer(v6))
			*(*uintptr)(unsafe.Pointer(v6))++
			v4 = int32(*(*uint8)(unsafe.Pointer(v5)))
		} else {
			v4 = X__uflow(tls, v1)
		}
		v2 = v4
		goto _3
	}
	v2 = _locking_getc(tls, v1)
	goto _3
_3:
	return v2
}

func Xfgetln(tls *TLS, f uintptr, plen uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v plen=%v, (%v:)", tls, f, plen, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var __need_unlock, v1, v2 int32
	var l, v8 Tssize_t
	var ret, z, v3, v4, v5, v7 uintptr
	var v6 bool
	_, _, _, _, _, _, _, _, _, _, _, _ = __need_unlock, l, ret, z, v1, v2, v3, v4, v5, v6, v7, v8
	ret = uintptr(0)
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		v4 = f + 8
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
	} else {
		v2 = X__uflow(tls, f)
	}
	Xungetc(tls, v2, f)
	if v6 = (*TFILE)(unsafe.Pointer(f)).Frend != 0; v6 {
		v5 = Xmemchr(tls, (*TFILE)(unsafe.Pointer(f)).Frpos, int32('\n'), uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)))
		z = v5
	}
	if v6 && v5 != 0 {
		ret = (*TFILE)(unsafe.Pointer(f)).Frpos
		z++
		v7 = z
		*(*Tsize_t)(unsafe.Pointer(plen)) = uint64(int64(v7) - int64(ret))
		(*TFILE)(unsafe.Pointer(f)).Frpos = z
	} else {
		*(*[1]Tsize_t)(unsafe.Pointer(bp)) = [1]Tsize_t{}
		v8 = Xgetline(tls, f+168, bp, f)
		l = v8
		if v8 > 0 {
			*(*Tsize_t)(unsafe.Pointer(plen)) = uint64(l)
			ret = (*TFILE)(unsafe.Pointer(f)).Fgetln_buf
		}
	}
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return ret
}

func Xfgetpos(tls *TLS, f uintptr, pos uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v pos=%v, (%v:)", tls, f, pos, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var off Toff_t
	_ = off
	off = X__ftello(tls, f)
	if off < 0 {
		return -int32(1)
	}
	*(*int64)(unsafe.Pointer(pos)) = off
	return 0
}

func Xfgets(tls *TLS, s uintptr, n int32, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v, (%v:)", tls, s, n, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, c, v1, v4, v5 int32
	var k Tsize_t
	var p, z, v6, v7, v9 uintptr
	var v2 int64
	var v3 uint64
	var v8 uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = __need_unlock, c, k, p, z, v1, v2, v3, v4, v5, v6, v7, v8, v9
	p = s
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	if n <= int32(1) {
		*(*int32)(unsafe.Pointer(f + 136)) |= (*TFILE)(unsafe.Pointer(f)).Fmode - int32(1)
		if __need_unlock != 0 {
			___unlockfile(tls, f)
		}
		if n < int32(1) {
			return uintptr(0)
		}
		*(*uint8)(unsafe.Pointer(s)) = uint8(0)
		return s
	}
	n--
	for n != 0 {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			z = Xmemchr(tls, (*TFILE)(unsafe.Pointer(f)).Frpos, int32('\n'), uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)))
			if z != 0 {
				v2 = int64(z) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + int64(1)
			} else {
				v2 = int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
			}
			k = uint64(v2)
			if k < uint64(n) {
				v3 = k
			} else {
				v3 = uint64(n)
			}
			k = v3
			Xmemcpy(tls, p, (*TFILE)(unsafe.Pointer(f)).Frpos, k)
			*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(k)
			p += uintptr(k)
			n = int32(uint64(n) - k)
			if z != 0 || !(n != 0) {
				break
			}
		}
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			v7 = f + 8
			v6 = *(*uintptr)(unsafe.Pointer(v7))
			*(*uintptr)(unsafe.Pointer(v7))++
			v5 = int32(*(*uint8)(unsafe.Pointer(v6)))
		} else {
			v5 = X__uflow(tls, f)
		}
		v4 = v5
		c = v4
		if v4 < 0 {
			if p == s || !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_EOF) != 0) {
				s = uintptr(0)
			}
			break
		}
		n--
		v8 = uint8(c)
		v9 = p
		p++
		*(*uint8)(unsafe.Pointer(v9)) = v8
		if int32(v8) == int32('\n') {
			break
		}
	}
	if s != 0 {
		*(*uint8)(unsafe.Pointer(p)) = uint8(0)
	}
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return s
}

func Xfgets_unlocked(tls *TLS, s uintptr, n int32, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v, (%v:)", tls, s, n, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfgets(tls, s, n, f)
}

func ___fgetwc_unlocked_internal(tls *TLS, f uintptr) (r Twint_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var c, first, v1, v2 int32
	var l Tsize_t
	var v3, v4 uintptr
	var _ /* b at bp+16 */ uint8
	var _ /* st at bp+8 */ Tmbstate_t
	var _ /* wc at bp+0 */ Twchar_t
	_, _, _, _, _, _, _ = c, first, l, v1, v2, v3, v4
	/* Convert character from buffer if possible */
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		l = uint64(Xmbtowc(tls, bp, (*TFILE)(unsafe.Pointer(f)).Frpos, uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos))))
		if l+uint64(1) >= uint64(1) {
			*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(l + BoolUint64(!(l != 0))) /* l==0 means 1 byte, null */
			return *(*Twchar_t)(unsafe.Pointer(bp))
		}
	}
	/* Convert character byte-by-byte */
	*(*Tmbstate_t)(unsafe.Pointer(bp + 8)) = Tmbstate_t{}
	first = int32(1)
	for cond := true; cond; cond = l == uint64(-Int32FromInt32(2)) {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			v4 = f + 8
			v3 = *(*uintptr)(unsafe.Pointer(v4))
			*(*uintptr)(unsafe.Pointer(v4))++
			v2 = int32(*(*uint8)(unsafe.Pointer(v3)))
		} else {
			v2 = X__uflow(tls, f)
		}
		v1 = v2
		c = v1
		*(*uint8)(unsafe.Pointer(bp + 16)) = uint8(v1)
		if c < 0 {
			if !(first != 0) {
				*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
				*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EILSEQ)
			}
			return uint32(0xffffffff)
		}
		l = Xmbrtowc(tls, bp, bp+16, uint64(1), bp+8)
		if l == uint64(-Int32FromInt32(1)) {
			if !(first != 0) {
				*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
				Xungetc(tls, int32(*(*uint8)(unsafe.Pointer(bp + 16))), f)
			}
			return uint32(0xffffffff)
		}
		first = 0
	}
	return *(*Twchar_t)(unsafe.Pointer(bp))
}

func X__fgetwc_unlocked(tls *TLS, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var loc Tlocale_t
	var ploc uintptr
	var wc Twchar_t
	_, _, _ = loc, ploc, wc
	ploc = ___get_tp(tls) + 152
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if (*TFILE)(unsafe.Pointer(f)).Fmode <= 0 {
		Xfwide(tls, f, int32(1))
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = (*TFILE)(unsafe.Pointer(f)).Flocale
	wc = ___fgetwc_unlocked_internal(tls, f)
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return wc
}

func Xfgetwc(tls *TLS, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, v1 int32
	var c Twint_t
	_, _, _ = __need_unlock, c, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	c = X__fgetwc_unlocked(tls, f)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return c
}

func Xfgetwc_unlocked(tls *TLS, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fgetwc_unlocked(tls, f)
}

func Xgetwc_unlocked(tls *TLS, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fgetwc_unlocked(tls, f)
}

func Xfgetws(tls *TLS, s uintptr, n int32, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v, (%v:)", tls, s, n, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, v1, v2 int32
	var c Twint_t
	var p, v4, v5 uintptr
	_, _, _, _, _, _, _ = __need_unlock, c, p, v1, v2, v4, v5
	p = s
	v1 = n
	n--
	if !(v1 != 0) {
		return s
	}
	if AtomicLoadPInt32(f+140) >= 0 {
		v2 = ___lockfile(tls, f)
	} else {
		v2 = 0
	}
	__need_unlock = v2
	for {
		if !(n != 0) {
			break
		}
		c = X__fgetwc_unlocked(tls, f)
		if c == uint32(0xffffffff) {
			break
		}
		v4 = p
		p += 4
		*(*Twchar_t)(unsafe.Pointer(v4)) = c
		if c == uint32('\n') {
			break
		}
		goto _3
	_3:
		;
		n--
	}
	*(*Twchar_t)(unsafe.Pointer(p)) = uint32(0)
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_ERR) != 0 {
		p = s
	}
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	if p == s {
		v5 = UintptrFromInt32(0)
	} else {
		v5 = s
	}
	return v5
}

func Xfgetws_unlocked(tls *TLS, s uintptr, n int32, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v, (%v:)", tls, s, n, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfgetws(tls, s, n, f)
}

func Xfileno(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, fd, v1 int32
	_, _, _ = __need_unlock, fd, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	fd = (*TFILE)(unsafe.Pointer(f)).Ffd
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	if fd < 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EBADF)
		return -int32(1)
	}
	return fd
}

func Xfileno_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfileno(tls, f)
}

func Xflockfile(tls *TLS, f uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	if !(Xftrylockfile(tls, f) != 0) {
		return
	}
	___lockfile(tls, f)
	X__register_locked_file(tls, f, ___get_tp(tls))
}

type Tcookie = struct {
	Fpos  Tsize_t
	Flen1 Tsize_t
	Fsize Tsize_t
	Fbuf  uintptr
	Fmode int32
}

type Tmem_FILE = struct {
	Ff   TFILE
	Fc   Tcookie
	Fbuf [1032]uint8
}

func _mseek(tls *TLS, f uintptr, off Toff_t, whence int32) (r Toff_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var base Tssize_t
	var c uintptr
	var v2 Tsize_t
	_, _, _ = base, c, v2
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(uint32(whence) > uint32(2)) {
		goto _1
	}
	goto fail
fail:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
	return int64(-int32(1))
_1:
	;
	*(*[3]Tsize_t)(unsafe.Pointer(bp)) = [3]Tsize_t{
		1: (*Tcookie)(unsafe.Pointer(c)).Fpos,
		2: (*Tcookie)(unsafe.Pointer(c)).Flen1,
	}
	base = int64(*(*Tsize_t)(unsafe.Pointer(bp + uintptr(whence)*8)))
	if off < -base || off > int64((*Tcookie)(unsafe.Pointer(c)).Fsize)-base {
		goto fail
	}
	v2 = uint64(base + off)
	(*Tcookie)(unsafe.Pointer(c)).Fpos = v2
	return int64(v2)
}

func _mread(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var c uintptr
	var rem Tsize_t
	_, _ = c, rem
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	rem = (*Tcookie)(unsafe.Pointer(c)).Flen1 - (*Tcookie)(unsafe.Pointer(c)).Fpos
	if (*Tcookie)(unsafe.Pointer(c)).Fpos > (*Tcookie)(unsafe.Pointer(c)).Flen1 {
		rem = uint64(0)
	}
	if len1 > rem {
		len1 = rem
		*(*uint32)(unsafe.Pointer(f)) |= uint32(F_EOF)
	}
	Xmemcpy(tls, buf, (*Tcookie)(unsafe.Pointer(c)).Fbuf+uintptr((*Tcookie)(unsafe.Pointer(c)).Fpos), len1)
	*(*Tsize_t)(unsafe.Pointer(c)) += len1
	rem -= len1
	if rem > (*TFILE)(unsafe.Pointer(f)).Fbuf_size {
		rem = (*TFILE)(unsafe.Pointer(f)).Fbuf_size
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(rem)
	Xmemcpy(tls, (*TFILE)(unsafe.Pointer(f)).Frpos, (*Tcookie)(unsafe.Pointer(c)).Fbuf+uintptr((*Tcookie)(unsafe.Pointer(c)).Fpos), rem)
	*(*Tsize_t)(unsafe.Pointer(c)) += rem
	return len1
}

func _mwrite(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var c uintptr
	var len2, rem Tsize_t
	_, _, _ = c, len2, rem
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	len2 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
	if len2 != 0 {
		(*TFILE)(unsafe.Pointer(f)).Fwpos = (*TFILE)(unsafe.Pointer(f)).Fwbase
		if _mwrite(tls, f, (*TFILE)(unsafe.Pointer(f)).Fwpos, len2) < len2 {
			return uint64(0)
		}
	}
	if (*Tcookie)(unsafe.Pointer(c)).Fmode == int32('a') {
		(*Tcookie)(unsafe.Pointer(c)).Fpos = (*Tcookie)(unsafe.Pointer(c)).Flen1
	}
	rem = (*Tcookie)(unsafe.Pointer(c)).Fsize - (*Tcookie)(unsafe.Pointer(c)).Fpos
	if len1 > rem {
		len1 = rem
	}
	Xmemcpy(tls, (*Tcookie)(unsafe.Pointer(c)).Fbuf+uintptr((*Tcookie)(unsafe.Pointer(c)).Fpos), buf, len1)
	*(*Tsize_t)(unsafe.Pointer(c)) += len1
	if (*Tcookie)(unsafe.Pointer(c)).Fpos > (*Tcookie)(unsafe.Pointer(c)).Flen1 {
		(*Tcookie)(unsafe.Pointer(c)).Flen1 = (*Tcookie)(unsafe.Pointer(c)).Fpos
		if (*Tcookie)(unsafe.Pointer(c)).Flen1 < (*Tcookie)(unsafe.Pointer(c)).Fsize {
			*(*uint8)(unsafe.Pointer((*Tcookie)(unsafe.Pointer(c)).Fbuf + uintptr((*Tcookie)(unsafe.Pointer(c)).Flen1))) = uint8(0)
		} else {
			if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_NORD) != 0 && (*Tcookie)(unsafe.Pointer(c)).Fsize != 0 {
				*(*uint8)(unsafe.Pointer((*Tcookie)(unsafe.Pointer(c)).Fbuf + uintptr((*Tcookie)(unsafe.Pointer(c)).Fsize-uint64(1)))) = uint8(0)
			}
		}
	}
	return len1
}

func _mclose(tls *TLS, m uintptr) (r int32) {
	return 0
}

func Xfmemopen(tls *TLS, buf uintptr, size Tsize_t, mode uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v buf=%v size=%v mode=%v, (%v:)", tls, buf, size, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var f uintptr
	var plus, v2 int32
	var v1 uint64
	var v3 Tsize_t
	_, _, _, _, _ = f, plus, v1, v2, v3
	plus = BoolInt32(!!(Xstrchr(tls, mode, int32('+')) != 0))
	if !(Xstrchr(tls, __ccgo_ts+1504, int32(*(*uint8)(unsafe.Pointer(mode)))) != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	if !(buf != 0) && size > uint64(Int64FromInt64(INT64_MAX)) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMEM)
		return uintptr(0)
	}
	if buf != 0 {
		v1 = uint64(0)
	} else {
		v1 = size
	}
	f = Xmalloc(tls, uint64(1304)+v1)
	if !(f != 0) {
		return uintptr(0)
	}
	Xmemset(tls, f, 0, uint64(UintptrFromInt32(0)+272))
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Fcookie = f + 232
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Ffd = -int32(1)
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Flbf = -int32(1)
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Fbuf = f + 272 + uintptr(UNGET)
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Fbuf_size = Uint64FromInt64(1032) - Uint64FromInt32(UNGET)
	if !(buf != 0) {
		buf = f + 1304
		Xmemset(tls, buf, 0, size)
	}
	(*Tmem_FILE)(unsafe.Pointer(f)).Fc.Fbuf = buf
	(*Tmem_FILE)(unsafe.Pointer(f)).Fc.Fsize = size
	(*Tmem_FILE)(unsafe.Pointer(f)).Fc.Fmode = int32(*(*uint8)(unsafe.Pointer(mode)))
	if !(plus != 0) {
		if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('r') {
			v2 = int32(F_NOWR)
		} else {
			v2 = int32(F_NORD)
		}
		(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Fflags = uint32(v2)
	}
	if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('r') {
		(*Tmem_FILE)(unsafe.Pointer(f)).Fc.Flen1 = size
	} else {
		if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('a') {
			v3 = Xstrnlen(tls, buf, size)
			(*Tmem_FILE)(unsafe.Pointer(f)).Fc.Fpos = v3
			(*Tmem_FILE)(unsafe.Pointer(f)).Fc.Flen1 = v3
		} else {
			if plus != 0 {
				*(*uint8)(unsafe.Pointer((*Tmem_FILE)(unsafe.Pointer(f)).Fc.Fbuf)) = uint8(0)
			}
		}
	}
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Fread = __ccgo_fp(_mread)
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Fwrite = __ccgo_fp(_mwrite)
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Fseek = __ccgo_fp(_mseek)
	(*Tmem_FILE)(unsafe.Pointer(f)).Ff.Fclose1 = __ccgo_fp(_mclose)
	if !(X__libc.Fthreaded != 0) {
		AtomicStorePInt32(f+140, -int32(1))
	}
	return X__ofl_add(tls, f)
}

func Xfopen(tls *TLS, filename uintptr, mode uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v filename=%v mode=%v, (%v:)", tls, filename, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var f uintptr
	var fd, flags int32
	_, _, _ = f, fd, flags
	/* Check for valid initial mode character */
	if !(Xstrchr(tls, __ccgo_ts+1504, int32(*(*uint8)(unsafe.Pointer(mode)))) != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	/* Compute the flags to pass to open() */
	flags = X__fmodeflags(tls, mode)
	fd = int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_openat), int64(-Int32FromInt32(100)), int64(filename), int64(flags|Int32FromInt32(O_LARGEFILE)), int64(Int32FromInt32(0666))))))
	if fd < 0 {
		return uintptr(0)
	}
	if flags&int32(O_CLOEXEC) != 0 {
		X__syscall3(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
	}
	f = X__fdopen(tls, fd, mode)
	if f != 0 {
		return f
	}
	X__syscall1(tls, int64(SYS_close), int64(fd))
	return uintptr(0)
}

type Tfcookie = struct {
	Fcookie  uintptr
	Fiofuncs Tcookie_io_functions_t
}

type Tcookie_FILE = struct {
	Ff   TFILE
	Ffc  Tfcookie
	Fbuf [1032]uint8
}

func _cookieread(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var fc, v2, v3, v5 uintptr
	var len2, readlen, remain, v1 Tsize_t
	var ret Tssize_t
	var v4 int32
	_, _, _, _, _, _, _, _, _, _ = fc, len2, readlen, remain, ret, v1, v2, v3, v4, v5
	fc = (*TFILE)(unsafe.Pointer(f)).Fcookie
	ret = int64(-int32(1))
	remain = len1
	readlen = uint64(0)
	len2 = len1 - BoolUint64(!!((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0))
	if !((*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fread != 0) {
		goto bail
	}
	if len2 != 0 {
		ret = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tssize_t)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fread})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie, buf, len2)
		if ret <= 0 {
			goto bail
		}
		readlen += uint64(ret)
		remain -= uint64(ret)
	}
	if !((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0) || remain > BoolUint64(!!((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0)) {
		return readlen
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	ret = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tssize_t)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fread})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie, (*TFILE)(unsafe.Pointer(f)).Frpos, (*TFILE)(unsafe.Pointer(f)).Fbuf_size)
	if ret <= 0 {
		goto bail
	}
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Frpos + uintptr(ret)
	v1 = readlen
	readlen++
	v3 = f + 8
	v2 = *(*uintptr)(unsafe.Pointer(v3))
	*(*uintptr)(unsafe.Pointer(v3))++
	*(*uint8)(unsafe.Pointer(buf + uintptr(v1))) = *(*uint8)(unsafe.Pointer(v2))
	return readlen
	goto bail
bail:
	;
	if ret == 0 {
		v4 = int32(F_EOF)
	} else {
		v4 = int32(F_ERR)
	}
	*(*uint32)(unsafe.Pointer(f)) |= uint32(v4)
	v5 = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = v5
	(*TFILE)(unsafe.Pointer(f)).Frpos = v5
	return readlen
}

func _cookiewrite(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var fc, v1, v2 uintptr
	var len2 Tsize_t
	var ret Tssize_t
	_, _, _, _, _ = fc, len2, ret, v1, v2
	fc = (*TFILE)(unsafe.Pointer(f)).Fcookie
	len2 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
	if !((*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fwrite != 0) {
		return len1
	}
	if len2 != 0 {
		(*TFILE)(unsafe.Pointer(f)).Fwpos = (*TFILE)(unsafe.Pointer(f)).Fwbase
		if _cookiewrite(tls, f, (*TFILE)(unsafe.Pointer(f)).Fwpos, len2) < len2 {
			return uint64(0)
		}
	}
	ret = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tssize_t)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fwrite})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie, buf, len1)
	if ret < 0 {
		v2 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Fwend = v2
		v1 = v2
		(*TFILE)(unsafe.Pointer(f)).Fwbase = v1
		(*TFILE)(unsafe.Pointer(f)).Fwpos = v1
		*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
		return uint64(0)
	}
	return uint64(ret)
}

func _cookieseek(tls *TLS, f uintptr, _off Toff_t, whence int32) (r Toff_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*Toff_t)(unsafe.Pointer(bp)) = _off
	var fc uintptr
	var res int32
	_, _ = fc, res
	fc = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if uint32(whence) > uint32(2) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return int64(-int32(1))
	}
	if !((*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fseek != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOPNOTSUPP)
		return int64(-int32(1))
	}
	res = (*(*func(*TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fseek})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie, bp, whence)
	if res < 0 {
		return int64(res)
	}
	return *(*Toff_t)(unsafe.Pointer(bp))
}

func _cookieclose(tls *TLS, f uintptr) (r int32) {
	var fc uintptr
	_ = fc
	fc = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if (*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fclose1 != 0 {
		return (*(*func(*TLS, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{(*Tfcookie)(unsafe.Pointer(fc)).Fiofuncs.Fclose1})))(tls, (*Tfcookie)(unsafe.Pointer(fc)).Fcookie)
	}
	return 0
}

func Xfopencookie(tls *TLS, cookie uintptr, mode uintptr, iofuncs Tcookie_io_functions_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v cookie=%v mode=%v iofuncs=%v, (%v:)", tls, cookie, mode, iofuncs, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var f, v1 uintptr
	var v2 int32
	_, _, _ = f, v1, v2
	/* Check for valid initial mode character */
	if !(Xstrchr(tls, __ccgo_ts+1504, int32(*(*uint8)(unsafe.Pointer(mode)))) != 0) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	/* Allocate FILE+fcookie+buffer or fail */
	v1 = Xmalloc(tls, uint64(1304))
	f = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	/* Zero-fill only the struct, not the buffer */
	Xmemset(tls, f, 0, uint64(232))
	/* Impose mode restrictions */
	if !(Xstrchr(tls, mode, int32('+')) != 0) {
		if int32(*(*uint8)(unsafe.Pointer(mode))) == int32('r') {
			v2 = int32(F_NOWR)
		} else {
			v2 = int32(F_NORD)
		}
		(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fflags = uint32(v2)
	}
	/* Set up our fcookie */
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ffc.Fcookie = cookie
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ffc.Fiofuncs = iofuncs
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Ffd = -int32(1)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fcookie = f + 232
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fbuf = f + 272 + uintptr(UNGET)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fbuf_size = Uint64FromInt64(1032) - Uint64FromInt32(UNGET)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Flbf = -int32(1)
	/* Initialize op ptrs. No problem if some are unneeded. */
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fread = __ccgo_fp(_cookieread)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fwrite = __ccgo_fp(_cookiewrite)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fseek = __ccgo_fp(_cookieseek)
	(*Tcookie_FILE)(unsafe.Pointer(f)).Ff.Fclose1 = __ccgo_fp(_cookieclose)
	/* Add new FILE to open file list */
	return X__ofl_add(tls, f)
}

func Xfprintf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v va=%v, (%v:)", tls, f, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvfprintf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func _locking_putc(tls *TLS, c int32, f uintptr) (r1 int32) {
	var old, old1, r, v, v14, v17, v19, v2, v22, v23, v5, v7, v9 int32
	var v1, v11, v12, v13, v21 uintptr
	var v10 uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = old, old1, r, v, v1, v10, v11, v12, v13, v14, v17, v19, v2, v21, v22, v23, v5, v7, v9
	v1 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1521)
		v5 = v
		goto _6
	_6:
		old = v5
		if old != 0 {
			// __asm__ __volatile__ ("dmb ish" : : : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1521)
			break
		}
		goto _4
	_4:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1521)
		v2 = BoolInt32(!(r != 0))
		goto _3
	_3:
		;
		if !!(v2 != 0) {
			break
		}
	}
	v7 = old
	goto _8
_8:
	if v7 != 0 {
		___lockfile(tls, f)
	}
	if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(f)).Flbf && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend {
		v10 = uint8(c)
		v12 = f + 40
		v11 = *(*uintptr)(unsafe.Pointer(v12))
		*(*uintptr)(unsafe.Pointer(v12))++
		*(*uint8)(unsafe.Pointer(v11)) = v10
		v9 = int32(v10)
	} else {
		v9 = X__overflow(tls, f, int32(uint8(c)))
	}
	c = v9
	v13 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1521)
		v17 = v
		goto _18
	_18:
		old1 = v17
		goto _16
	_16:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1521)
		v14 = BoolInt32(!(r != 0))
		goto _15
	_15:
		;
		if !!(v14 != 0) {
			break
		}
	}
	v19 = old1
	goto _20
_20:
	if v19&int32(MAYBE_WAITERS) != 0 {
		v21 = f + 140
		v22 = int32(1)
		v23 = int32(1)
		if v23 != 0 {
			v23 = int32(FUTEX_PRIVATE)
		}
		if v22 < Int32FromInt32(0) {
			v22 = int32(INT_MAX)
		}
		_ = X__syscall3(tls, int64(SYS_futex), int64(v21), int64(Int32FromInt32(FUTEX_WAKE)|v23), int64(v22)) != int64(-int32(ENOSYS)) || X__syscall3(tls, int64(SYS_futex), int64(v21), int64(Int32FromInt32(FUTEX_WAKE)), int64(v22)) != 0
	}
	return c
}

func Xfputc(tls *TLS, c1 int32, f1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c1=%v f1=%v, (%v:)", tls, c1, f1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l, v1, v3, v5 int32
	var v2, v7, v8 uintptr
	var v6 uint8
	_, _, _, _, _, _, _, _ = l, v1, v2, v3, v5, v6, v7, v8
	v1 = c1
	v2 = f1
	l = AtomicLoadPInt32(v2 + 140)
	if l < 0 || l != 0 && l & ^Int32FromInt32(MAYBE_WAITERS) == (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
		if int32(uint8(v1)) != (*TFILE)(unsafe.Pointer(v2)).Flbf && (*TFILE)(unsafe.Pointer(v2)).Fwpos != (*TFILE)(unsafe.Pointer(v2)).Fwend {
			v6 = uint8(v1)
			v8 = v2 + 40
			v7 = *(*uintptr)(unsafe.Pointer(v8))
			*(*uintptr)(unsafe.Pointer(v8))++
			*(*uint8)(unsafe.Pointer(v7)) = v6
			v5 = int32(v6)
		} else {
			v5 = X__overflow(tls, v2, int32(uint8(v1)))
		}
		v3 = v5
		goto _4
	}
	v3 = _locking_putc(tls, v1, v2)
	goto _4
_4:
	return v3
}

func Xfputs(tls *TLS, s uintptr, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v f=%v, (%v:)", tls, s, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tsize_t
	_ = l
	l = Xstrlen(tls, s)
	return BoolInt32(Xfwrite(tls, s, uint64(1), l, f) == l) - int32(1)
}

func Xfputs_unlocked(tls *TLS, s uintptr, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v f=%v, (%v:)", tls, s, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfputs(tls, s, f)
}

func X__fputwc_unlocked(tls *TLS, c Twchar_t, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var l, v1 int32
	var loc Tlocale_t
	var ploc, v3, v4 uintptr
	var v2 uint8
	var _ /* mbc at bp+0 */ [4]uint8
	_, _, _, _, _, _, _ = l, loc, ploc, v1, v2, v3, v4
	ploc = ___get_tp(tls) + 152
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if (*TFILE)(unsafe.Pointer(f)).Fmode <= 0 {
		Xfwide(tls, f, int32(1))
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = (*TFILE)(unsafe.Pointer(f)).Flocale
	if BoolInt32(c < uint32(128)) != 0 {
		if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(f)).Flbf && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend {
			v2 = uint8(c)
			v4 = f + 40
			v3 = *(*uintptr)(unsafe.Pointer(v4))
			*(*uintptr)(unsafe.Pointer(v4))++
			*(*uint8)(unsafe.Pointer(v3)) = v2
			v1 = int32(v2)
		} else {
			v1 = X__overflow(tls, f, int32(uint8(c)))
		}
		c = uint32(v1)
	} else {
		if (*TFILE)(unsafe.Pointer(f)).Fwpos+uintptr(MB_LEN_MAX) < (*TFILE)(unsafe.Pointer(f)).Fwend {
			l = Xwctomb(tls, (*TFILE)(unsafe.Pointer(f)).Fwpos, c)
			if l < 0 {
				c = uint32(0xffffffff)
			} else {
				*(*uintptr)(unsafe.Pointer(f + 40)) += uintptr(l)
			}
		} else {
			l = Xwctomb(tls, bp, c)
			if l < 0 || X__fwritex(tls, bp, uint64(l), f) < uint64(l) {
				c = uint32(0xffffffff)
			}
		}
	}
	if c == uint32(0xffffffff) {
		*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return c
}

func Xfputwc(tls *TLS, c Twchar_t, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, v1 int32
	_, _ = __need_unlock, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	c = X__fputwc_unlocked(tls, c, f)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return c
}

func Xfputwc_unlocked(tls *TLS, c Twchar_t, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fputwc_unlocked(tls, c, f)
}

func Xputwc_unlocked(tls *TLS, c Twchar_t, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fputwc_unlocked(tls, c, f)
}

func Xfputws(tls *TLS, _ws uintptr, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v _ws=%v f=%v, (%v:)", tls, _ws, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(1040)
	defer tls.Free(1040)
	*(*uintptr)(unsafe.Pointer(bp)) = _ws
	var __need_unlock, v1 int32
	var l, v2 Tsize_t
	var loc Tlocale_t
	var ploc uintptr
	var v3 bool
	var _ /* buf at bp+8 */ [1024]uint8
	_, _, _, _, _, _, _ = __need_unlock, l, loc, ploc, v1, v2, v3
	l = uint64(0)
	ploc = ___get_tp(tls) + 152
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	Xfwide(tls, f, int32(1))
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = (*TFILE)(unsafe.Pointer(f)).Flocale
	for {
		if v3 = *(*uintptr)(unsafe.Pointer(bp)) != 0; v3 {
			v2 = Xwcsrtombs(tls, bp+8, bp, uint64(1024), uintptr(0))
			l = v2
		}
		if !(v3 && v2+uint64(1) > uint64(1)) {
			break
		}
		if X__fwritex(tls, bp+8, l, f) < l {
			if __need_unlock != 0 {
				___unlockfile(tls, f)
			}
			*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
			return -int32(1)
		}
	}
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return int32(l) /* 0 or -1 */
}

func Xfputws_unlocked(tls *TLS, _ws uintptr, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v _ws=%v f=%v, (%v:)", tls, _ws, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfputws(tls, _ws, f)
}

func Xfread(tls *TLS, destv uintptr, size Tsize_t, nmemb Tsize_t, f uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v destv=%v size=%v nmemb=%v f=%v, (%v:)", tls, destv, size, nmemb, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, v1 int32
	var dest uintptr
	var k, l, len1 Tsize_t
	var v2, v4 uint64
	_, _, _, _, _, _, _, _ = __need_unlock, dest, k, l, len1, v1, v2, v4
	dest = destv
	len1 = size * nmemb
	l = len1
	if !(size != 0) {
		nmemb = uint64(0)
	}
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	*(*int32)(unsafe.Pointer(f + 136)) |= (*TFILE)(unsafe.Pointer(f)).Fmode - int32(1)
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		/* First exhaust the buffer. */
		if uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)) < l {
			v2 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos))
		} else {
			v2 = l
		}
		k = v2
		Xmemcpy(tls, dest, (*TFILE)(unsafe.Pointer(f)).Frpos, k)
		*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(k)
		dest += uintptr(k)
		l -= k
	}
	/* Read the remainder directly */
	for {
		if !(l != 0) {
			break
		}
		if X__toread(tls, f) != 0 {
			v4 = uint64(0)
		} else {
			v4 = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fread})))(tls, f, dest, l)
		}
		k = v4
		if !(k != 0) {
			if __need_unlock != 0 {
				___unlockfile(tls, f)
			}
			return (len1 - l) / size
		}
		goto _3
	_3:
		;
		l -= k
		dest += uintptr(k)
	}
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return nmemb
}

func Xfread_unlocked(tls *TLS, destv uintptr, size Tsize_t, nmemb Tsize_t, f uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v destv=%v size=%v nmemb=%v f=%v, (%v:)", tls, destv, size, nmemb, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfread(tls, destv, size, nmemb, f)
}

/* The basic idea of this implementation is to open a new FILE,
 * hack the necessary parts of the new FILE into the old one, then
 * close the new FILE. */

/* Locking IS necessary because another thread may provably hold the
 * lock, via flockfile or otherwise, when freopen is called, and in that
 * case, freopen cannot act until the lock is released. */

func Xfreopen(tls *TLS, filename uintptr, mode uintptr, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v filename=%v mode=%v f=%v, (%v:)", tls, filename, mode, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, fl, v1 int32
	var f2 uintptr
	_, _, _, _ = __need_unlock, f2, fl, v1
	fl = X__fmodeflags(tls, mode)
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	Xfflush(tls, f)
	if !(filename != 0) {
		if fl&int32(O_CLOEXEC) != 0 {
			X__syscall3(tls, int64(SYS_fcntl), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
		}
		fl &= ^(Int32FromInt32(O_CREAT) | Int32FromInt32(O_EXCL) | Int32FromInt32(O_CLOEXEC))
		if X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_fcntl), int64((*TFILE)(unsafe.Pointer(f)).Ffd), int64(Int32FromInt32(F_SETFL)), int64(fl)))) < 0 {
			goto fail
		}
	} else {
		f2 = Xfopen(tls, filename, mode)
		if !(f2 != 0) {
			goto fail
		}
		if (*TFILE)(unsafe.Pointer(f2)).Ffd == (*TFILE)(unsafe.Pointer(f)).Ffd {
			(*TFILE)(unsafe.Pointer(f2)).Ffd = -int32(1)
		} else {
			if X__dup3(tls, (*TFILE)(unsafe.Pointer(f2)).Ffd, (*TFILE)(unsafe.Pointer(f)).Ffd, fl&int32(O_CLOEXEC)) < 0 {
				goto fail2
			}
		}
		(*TFILE)(unsafe.Pointer(f)).Fflags = (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_PERM) | (*TFILE)(unsafe.Pointer(f2)).Fflags
		(*TFILE)(unsafe.Pointer(f)).Fread = (*TFILE)(unsafe.Pointer(f2)).Fread
		(*TFILE)(unsafe.Pointer(f)).Fwrite = (*TFILE)(unsafe.Pointer(f2)).Fwrite
		(*TFILE)(unsafe.Pointer(f)).Fseek = (*TFILE)(unsafe.Pointer(f2)).Fseek
		(*TFILE)(unsafe.Pointer(f)).Fclose1 = (*TFILE)(unsafe.Pointer(f2)).Fclose1
		Xfclose(tls, f2)
	}
	(*TFILE)(unsafe.Pointer(f)).Fmode = 0
	(*TFILE)(unsafe.Pointer(f)).Flocale = uintptr(0)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return f
	goto fail2
fail2:
	;
	Xfclose(tls, f2)
	goto fail
fail:
	;
	Xfclose(tls, f)
	return UintptrFromInt32(0)
}

func Xfscanf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v va=%v, (%v:)", tls, f, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvfscanf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func X__isoc99_fscanf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v va=%v, (%v:)", tls, f, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfscanf(tls, f, fmt, va)
}

func X__fseeko_unlocked(tls *TLS, f uintptr, off Toff_t, whence int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v off=%v whence=%v, (%v:)", tls, f, off, whence, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v2, v3 uintptr
	_, _, _ = v1, v2, v3
	/* Fail immediately for invalid whence argument. */
	if whence != int32(1) && whence != 0 && whence != int32(2) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	/* Adjust relative offset for unread data in buffer, if any. */
	if whence == int32(1) && (*TFILE)(unsafe.Pointer(f)).Frend != 0 {
		off -= int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
	}
	/* Flush write buffer, and report error on failure. */
	if (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
		if !((*TFILE)(unsafe.Pointer(f)).Fwpos != 0) {
			return -int32(1)
		}
	}
	/* Leave writing mode */
	v2 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Fwend = v2
	v1 = v2
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v1
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v1
	/* Perform the underlying seek. */
	if (*(*func(*TLS, uintptr, Toff_t, int32) Toff_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, off, whence) < 0 {
		return -int32(1)
	}
	/* If seek succeeded, file is seekable and we discard read buffer. */
	v3 = UintptrFromInt32(0)
	(*TFILE)(unsafe.Pointer(f)).Frend = v3
	(*TFILE)(unsafe.Pointer(f)).Frpos = v3
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(F_EOF))
	return 0
}

func X__fseeko(tls *TLS, f uintptr, off Toff_t, whence int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v off=%v whence=%v, (%v:)", tls, f, off, whence, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, result, v1 int32
	_, _, _ = __need_unlock, result, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	result = X__fseeko_unlocked(tls, f, off, whence)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return result
}

func Xfseek(tls *TLS, f uintptr, off int64, whence int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v off=%v whence=%v, (%v:)", tls, f, off, whence, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fseeko(tls, f, off, whence)
}

func Xfseeko(tls *TLS, f uintptr, off Toff_t, whence int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v off=%v whence=%v, (%v:)", tls, f, off, whence, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fseeko(tls, f, off, whence)
}

func Xfsetpos(tls *TLS, f uintptr, pos uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v pos=%v, (%v:)", tls, f, pos, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__fseeko(tls, f, *(*int64)(unsafe.Pointer(pos)), 0)
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func X__ftello_unlocked(tls *TLS, f uintptr) (r Toff_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var pos Toff_t
	var v1 int32
	_, _ = pos, v1
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_APP) != 0 && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwbase {
		v1 = int32(2)
	} else {
		v1 = int32(1)
	}
	pos = (*(*func(*TLS, uintptr, Toff_t, int32) Toff_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fseek})))(tls, f, 0, v1)
	if pos < 0 {
		return pos
	}
	/* Adjust for data in buffer. */
	if (*TFILE)(unsafe.Pointer(f)).Frend != 0 {
		pos += int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Frend)
	} else {
		if (*TFILE)(unsafe.Pointer(f)).Fwbase != 0 {
			pos += int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase)
		}
	}
	return pos
}

func X__ftello(tls *TLS, f uintptr) (r Toff_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, v1 int32
	var pos Toff_t
	_, _, _ = __need_unlock, pos, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	pos = X__ftello_unlocked(tls, f)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return pos
}

func Xftell(tls *TLS, f uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var pos Toff_t
	_ = pos
	pos = X__ftello(tls, f)
	if pos > int64(0x7fffffffffffffff) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOVERFLOW)
		return int64(-int32(1))
	}
	return pos
}

func Xftello(tls *TLS, f uintptr) (r Toff_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__ftello(tls, f)
}

func X__do_orphaned_stdio_locks(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	var f uintptr
	_ = f
	f = (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Fstdio_locks
	for {
		if !(f != 0) {
			break
		}
		// __asm__ __volatile__ ("dmb ish" : : : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1534)
		AtomicStorePInt32(f+140, int32(0x40000000))
		// __asm__ __volatile__ ("dmb ish" : : : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1534)
		goto _1
	_1:
		;
		f = (*TFILE)(unsafe.Pointer(f)).Fnext_locked
	}
}

func X__unlist_locked_file(tls *TLS, f uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	if (*TFILE)(unsafe.Pointer(f)).Flockcount != 0 {
		if (*TFILE)(unsafe.Pointer(f)).Fnext_locked != 0 {
			(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fnext_locked)).Fprev_locked = (*TFILE)(unsafe.Pointer(f)).Fprev_locked
		}
		if (*TFILE)(unsafe.Pointer(f)).Fprev_locked != 0 {
			(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fprev_locked)).Fnext_locked = (*TFILE)(unsafe.Pointer(f)).Fnext_locked
		} else {
			(*t__pthread)(unsafe.Pointer(___get_tp(tls))).Fstdio_locks = (*TFILE)(unsafe.Pointer(f)).Fnext_locked
		}
	}
}

func X__register_locked_file(tls *TLS, f uintptr, self Tpthread_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v self=%v, (%v:)", tls, f, self, origin(2))
	}
	(*TFILE)(unsafe.Pointer(f)).Flockcount = int64(1)
	(*TFILE)(unsafe.Pointer(f)).Fprev_locked = uintptr(0)
	(*TFILE)(unsafe.Pointer(f)).Fnext_locked = (*t__pthread)(unsafe.Pointer(self)).Fstdio_locks
	if (*TFILE)(unsafe.Pointer(f)).Fnext_locked != 0 {
		(*TFILE)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fnext_locked)).Fprev_locked = f
	}
	(*t__pthread)(unsafe.Pointer(self)).Fstdio_locks = f
}

func Xftrylockfile(tls *TLS, f uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var old, owner, r, tid, v, v1, v3, v6, v8 int32
	var self Tpthread_t
	var v10 bool
	var v2 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _ = old, owner, r, self, tid, v, v1, v10, v2, v3, v6, v8
	self = ___get_tp(tls)
	tid = (*t__pthread)(unsafe.Pointer(self)).Ftid
	owner = AtomicLoadPInt32(f + 140)
	if owner & ^Int32FromInt32(MAYBE_WAITERS) == tid {
		if (*TFILE)(unsafe.Pointer(f)).Flockcount == int64(0x7fffffffffffffff) {
			return -int32(1)
		}
		(*TFILE)(unsafe.Pointer(f)).Flockcount++
		return 0
	}
	if owner < 0 {
		v1 = Int32FromInt32(0)
		owner = v1
		AtomicStorePInt32(f+140, v1)
	}
	if v10 = owner != 0; !v10 {
		v2 = f + 140
		for {
			// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1560)
			v6 = v
			goto _7
		_7:
			old = v6
			if old != 0 {
				// __asm__ __volatile__ ("dmb ish" : : : "memory");
				X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1560)
				break
			}
			goto _5
		_5:
			;
			// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1560)
			v3 = BoolInt32(!(r != 0))
			goto _4
		_4:
			;
			if !!(v3 != 0) {
				break
			}
		}
		v8 = old
		goto _9
	_9:
	}
	if v10 || v8 != 0 {
		return -int32(1)
	}
	X__register_locked_file(tls, f, self)
	return 0
}

func Xfunlockfile(tls *TLS, f uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	if (*TFILE)(unsafe.Pointer(f)).Flockcount == int64(1) {
		X__unlist_locked_file(tls, f)
		(*TFILE)(unsafe.Pointer(f)).Flockcount = 0
		___unlockfile(tls, f)
	} else {
		(*TFILE)(unsafe.Pointer(f)).Flockcount--
	}
}

func Xfwide(tls *TLS, f uintptr, mode int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v mode=%v, (%v:)", tls, f, mode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, v1, v3, v4 int32
	var v2 Tlocale_t
	_, _, _, _, _ = __need_unlock, v1, v2, v3, v4
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	if mode != 0 {
		if !((*TFILE)(unsafe.Pointer(f)).Flocale != 0) {
			if !!(*(*uintptr)(unsafe.Pointer((*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)) != 0) {
				v3 = int32(4)
			} else {
				v3 = int32(1)
			}
			if v3 == int32(1) {
				v2 = uintptr(unsafe.Pointer(&X__c_locale))
			} else {
				v2 = uintptr(unsafe.Pointer(&X__c_dot_utf8_locale))
			}
			(*TFILE)(unsafe.Pointer(f)).Flocale = v2
		}
		if !((*TFILE)(unsafe.Pointer(f)).Fmode != 0) {
			if mode > 0 {
				v4 = int32(1)
			} else {
				v4 = -int32(1)
			}
			(*TFILE)(unsafe.Pointer(f)).Fmode = v4
		}
	}
	mode = (*TFILE)(unsafe.Pointer(f)).Fmode
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return mode
}

func Xfwprintf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v va=%v, (%v:)", tls, f, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvfwprintf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func X__fwritex(tls *TLS, s uintptr, l Tsize_t, f uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v l=%v f=%v, (%v:)", tls, s, l, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var i, n Tsize_t
	_, _ = i, n
	i = uint64(0)
	if !((*TFILE)(unsafe.Pointer(f)).Fwend != 0) && X__towrite(tls, f) != 0 {
		return uint64(0)
	}
	if l > uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwend)-int64((*TFILE)(unsafe.Pointer(f)).Fwpos)) {
		return (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, s, l)
	}
	if (*TFILE)(unsafe.Pointer(f)).Flbf >= 0 {
		/* Match /^(.*\n|)/ */
		i = l
		for {
			if !(i != 0 && int32(*(*uint8)(unsafe.Pointer(s + uintptr(i-uint64(1))))) != int32('\n')) {
				break
			}
			goto _1
		_1:
			;
			i--
		}
		if i != 0 {
			n = (*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, s, i)
			if n < i {
				return n
			}
			s += uintptr(i)
			l -= i
		}
	}
	Xmemcpy(tls, (*TFILE)(unsafe.Pointer(f)).Fwpos, s, l)
	*(*uintptr)(unsafe.Pointer(f + 40)) += uintptr(l)
	return l + i
}

func Xfwrite(tls *TLS, src uintptr, size Tsize_t, nmemb Tsize_t, f uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v src=%v size=%v nmemb=%v f=%v, (%v:)", tls, src, size, nmemb, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, v1 int32
	var k, l Tsize_t
	var v2 uint64
	_, _, _, _, _ = __need_unlock, k, l, v1, v2
	l = size * nmemb
	if !(size != 0) {
		nmemb = uint64(0)
	}
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	k = X__fwritex(tls, src, l, f)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	if k == l {
		v2 = nmemb
	} else {
		v2 = k / size
	}
	return v2
}

func Xfwrite_unlocked(tls *TLS, src uintptr, size Tsize_t, nmemb Tsize_t, f uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v src=%v size=%v nmemb=%v f=%v, (%v:)", tls, src, size, nmemb, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfwrite(tls, src, size, nmemb, f)
}

func Xfwscanf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v va=%v, (%v:)", tls, f, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvfwscanf(tls, f, fmt, ap)
	_ = ap
	return ret
}

func X__isoc99_fwscanf(tls *TLS, f uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v va=%v, (%v:)", tls, f, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfwscanf(tls, f, fmt, va)
}

func _locking_getc1(tls *TLS, f uintptr) (r1 int32) {
	var c, old, old1, r, v, v13, v16, v18, v2, v21, v22, v5, v7, v9 int32
	var v1, v10, v11, v12, v20 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, old, old1, r, v, v1, v10, v11, v12, v13, v16, v18, v2, v20, v21, v22, v5, v7, v9
	v1 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1508)
		v5 = v
		goto _6
	_6:
		old = v5
		if old != 0 {
			// __asm__ __volatile__ ("dmb ish" : : : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1508)
			break
		}
		goto _4
	_4:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1508)
		v2 = BoolInt32(!(r != 0))
		goto _3
	_3:
		;
		if !!(v2 != 0) {
			break
		}
	}
	v7 = old
	goto _8
_8:
	if v7 != 0 {
		___lockfile(tls, f)
	}
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		v11 = f + 8
		v10 = *(*uintptr)(unsafe.Pointer(v11))
		*(*uintptr)(unsafe.Pointer(v11))++
		v9 = int32(*(*uint8)(unsafe.Pointer(v10)))
	} else {
		v9 = X__uflow(tls, f)
	}
	c = v9
	v12 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1508)
		v16 = v
		goto _17
	_17:
		old1 = v16
		goto _15
	_15:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1508)
		v13 = BoolInt32(!(r != 0))
		goto _14
	_14:
		;
		if !!(v13 != 0) {
			break
		}
	}
	v18 = old1
	goto _19
_19:
	if v18&int32(MAYBE_WAITERS) != 0 {
		v20 = f + 140
		v21 = int32(1)
		v22 = int32(1)
		if v22 != 0 {
			v22 = int32(FUTEX_PRIVATE)
		}
		if v21 < Int32FromInt32(0) {
			v21 = int32(INT_MAX)
		}
		_ = X__syscall3(tls, int64(SYS_futex), int64(v20), int64(Int32FromInt32(FUTEX_WAKE)|v22), int64(v21)) != int64(-int32(ENOSYS)) || X__syscall3(tls, int64(SYS_futex), int64(v20), int64(Int32FromInt32(FUTEX_WAKE)), int64(v21)) != 0
	}
	return c
}

func Xgetc(tls *TLS, f1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f1=%v, (%v:)", tls, f1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l, v2, v4 int32
	var v1, v5, v6 uintptr
	_, _, _, _, _, _ = l, v1, v2, v4, v5, v6
	v1 = f1
	l = AtomicLoadPInt32(v1 + 140)
	if l < 0 || l != 0 && l & ^Int32FromInt32(MAYBE_WAITERS) == (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
		if (*TFILE)(unsafe.Pointer(v1)).Frpos != (*TFILE)(unsafe.Pointer(v1)).Frend {
			v6 = v1 + 8
			v5 = *(*uintptr)(unsafe.Pointer(v6))
			*(*uintptr)(unsafe.Pointer(v6))++
			v4 = int32(*(*uint8)(unsafe.Pointer(v5)))
		} else {
			v4 = X__uflow(tls, v1)
		}
		v2 = v4
		goto _3
	}
	v2 = _locking_getc1(tls, v1)
	goto _3
_3:
	return v2
}

func X_IO_getc(tls *TLS, f1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f1=%v, (%v:)", tls, f1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetc(tls, f1)
}

func Xgetc_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	var v2, v3 uintptr
	_, _, _ = v1, v2, v3
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		v3 = f + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = X__uflow(tls, f)
	}
	return v1
}

func X_IO_getc_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetc_unlocked(tls, f)
}

func Xfgetc_unlocked(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetc_unlocked(tls, f)
}

func _locking_getc2(tls *TLS, f uintptr) (r1 int32) {
	var c, old, old1, r, v, v13, v16, v18, v2, v21, v22, v5, v7, v9 int32
	var v1, v10, v11, v12, v20 uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = c, old, old1, r, v, v1, v10, v11, v12, v13, v16, v18, v2, v20, v21, v22, v5, v7, v9
	v1 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1508)
		v5 = v
		goto _6
	_6:
		old = v5
		if old != 0 {
			// __asm__ __volatile__ ("dmb ish" : : : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1508)
			break
		}
		goto _4
	_4:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1508)
		v2 = BoolInt32(!(r != 0))
		goto _3
	_3:
		;
		if !!(v2 != 0) {
			break
		}
	}
	v7 = old
	goto _8
_8:
	if v7 != 0 {
		___lockfile(tls, f)
	}
	if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
		v11 = f + 8
		v10 = *(*uintptr)(unsafe.Pointer(v11))
		*(*uintptr)(unsafe.Pointer(v11))++
		v9 = int32(*(*uint8)(unsafe.Pointer(v10)))
	} else {
		v9 = X__uflow(tls, f)
	}
	c = v9
	v12 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1508)
		v16 = v
		goto _17
	_17:
		old1 = v16
		goto _15
	_15:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1508)
		v13 = BoolInt32(!(r != 0))
		goto _14
	_14:
		;
		if !!(v13 != 0) {
			break
		}
	}
	v18 = old1
	goto _19
_19:
	if v18&int32(MAYBE_WAITERS) != 0 {
		v20 = f + 140
		v21 = int32(1)
		v22 = int32(1)
		if v22 != 0 {
			v22 = int32(FUTEX_PRIVATE)
		}
		if v21 < Int32FromInt32(0) {
			v21 = int32(INT_MAX)
		}
		_ = X__syscall3(tls, int64(SYS_futex), int64(v20), int64(Int32FromInt32(FUTEX_WAKE)|v22), int64(v21)) != int64(-int32(ENOSYS)) || X__syscall3(tls, int64(SYS_futex), int64(v20), int64(Int32FromInt32(FUTEX_WAKE)), int64(v21)) != 0
	}
	return c
}

func Xgetchar(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l, v2, v4 int32
	var v1, v5, v6 uintptr
	_, _, _, _, _, _ = l, v1, v2, v4, v5, v6
	v1 = uintptr(unsafe.Pointer(&X__stdin_FILE))
	l = AtomicLoadPInt32(v1 + 140)
	if l < 0 || l != 0 && l & ^Int32FromInt32(MAYBE_WAITERS) == (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
		if (*TFILE)(unsafe.Pointer(v1)).Frpos != (*TFILE)(unsafe.Pointer(v1)).Frend {
			v6 = v1 + 8
			v5 = *(*uintptr)(unsafe.Pointer(v6))
			*(*uintptr)(unsafe.Pointer(v6))++
			v4 = int32(*(*uint8)(unsafe.Pointer(v5)))
		} else {
			v4 = X__uflow(tls, v1)
		}
		v2 = v4
		goto _3
	}
	v2 = _locking_getc2(tls, v1)
	goto _3
_3:
	return v2
}

func Xgetchar_unlocked(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	var v2, v3 uintptr
	_, _, _ = v1, v2, v3
	if (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdin_FILE)))).Frpos != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdin_FILE)))).Frend {
		v3 = uintptr(unsafe.Pointer(&X__stdin_FILE)) + 8
		v2 = *(*uintptr)(unsafe.Pointer(v3))
		*(*uintptr)(unsafe.Pointer(v3))++
		v1 = int32(*(*uint8)(unsafe.Pointer(v2)))
	} else {
		v1 = X__uflow(tls, uintptr(unsafe.Pointer(&X__stdin_FILE)))
	}
	return v1
}

func Xgetdelim(tls *TLS, s uintptr, n uintptr, delim int32, f uintptr) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v delim=%v f=%v, (%v:)", tls, s, n, delim, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, c, v1, v4, v5 int32
	var i, k, m, v11 Tsize_t
	var tmp, z, v6, v7, v8, v9 uintptr
	var v10 uint8
	var v3 int64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __need_unlock, c, i, k, m, tmp, z, v1, v10, v11, v3, v4, v5, v6, v7, v8, v9
	i = uint64(0)
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	if !(n != 0) || !(s != 0) {
		*(*int32)(unsafe.Pointer(f + 136)) |= (*TFILE)(unsafe.Pointer(f)).Fmode - int32(1)
		*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
		if __need_unlock != 0 {
			___unlockfile(tls, f)
		}
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return int64(-int32(1))
	}
	if !(*(*uintptr)(unsafe.Pointer(s)) != 0) {
		*(*Tsize_t)(unsafe.Pointer(n)) = uint64(0)
	}
	for {
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			z = Xmemchr(tls, (*TFILE)(unsafe.Pointer(f)).Frpos, delim, uint64(int64((*TFILE)(unsafe.Pointer(f)).Frend)-int64((*TFILE)(unsafe.Pointer(f)).Frpos)))
			if z != 0 {
				v3 = int64(z) - int64((*TFILE)(unsafe.Pointer(f)).Frpos) + int64(1)
			} else {
				v3 = int64((*TFILE)(unsafe.Pointer(f)).Frend) - int64((*TFILE)(unsafe.Pointer(f)).Frpos)
			}
			k = uint64(v3)
		} else {
			z = uintptr(0)
			k = uint64(0)
		}
		if i+k >= *(*Tsize_t)(unsafe.Pointer(n)) {
			m = i + k + uint64(2)
			if !(z != 0) && m < Uint64FromUint64(0xffffffffffffffff)/Uint64FromInt32(4) {
				m += m / uint64(2)
			}
			tmp = Xrealloc(tls, *(*uintptr)(unsafe.Pointer(s)), m)
			if !(tmp != 0) {
				m = i + k + uint64(2)
				tmp = Xrealloc(tls, *(*uintptr)(unsafe.Pointer(s)), m)
				if !(tmp != 0) {
					/* Copy as much as fits and ensure no
					 * pushback remains in the FILE buf. */
					k = *(*Tsize_t)(unsafe.Pointer(n)) - i
					Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(i), (*TFILE)(unsafe.Pointer(f)).Frpos, k)
					*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(k)
					*(*int32)(unsafe.Pointer(f + 136)) |= (*TFILE)(unsafe.Pointer(f)).Fmode - int32(1)
					*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
					if __need_unlock != 0 {
						___unlockfile(tls, f)
					}
					*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOMEM)
					return int64(-int32(1))
				}
			}
			*(*uintptr)(unsafe.Pointer(s)) = tmp
			*(*Tsize_t)(unsafe.Pointer(n)) = m
		}
		if k != 0 {
			Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(s))+uintptr(i), (*TFILE)(unsafe.Pointer(f)).Frpos, k)
			*(*uintptr)(unsafe.Pointer(f + 8)) += uintptr(k)
			i += k
		}
		if z != 0 {
			break
		}
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend {
			v7 = f + 8
			v6 = *(*uintptr)(unsafe.Pointer(v7))
			*(*uintptr)(unsafe.Pointer(v7))++
			v5 = int32(*(*uint8)(unsafe.Pointer(v6)))
		} else {
			v5 = X__uflow(tls, f)
		}
		v4 = v5
		c = v4
		if v4 == -int32(1) {
			if !(i != 0) || !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_EOF) != 0) {
				if __need_unlock != 0 {
					___unlockfile(tls, f)
				}
				return int64(-int32(1))
			}
			break
		}
		/* If the byte read by getc won't fit without growing the
		 * output buffer, push it back for next iteration. */
		if i+uint64(1) >= *(*Tsize_t)(unsafe.Pointer(n)) {
			v9 = f + 8
			*(*uintptr)(unsafe.Pointer(v9))--
			v8 = *(*uintptr)(unsafe.Pointer(v9))
			*(*uint8)(unsafe.Pointer(v8)) = uint8(c)
		} else {
			v10 = uint8(c)
			v11 = i
			i++
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)) + uintptr(v11))) = v10
			if int32(v10) == delim {
				break
			}
		}
		goto _2
	_2:
	}
	*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)) + uintptr(i))) = uint8(0)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return int64(i)
}

func X__getdelim(tls *TLS, s uintptr, n uintptr, delim int32, f uintptr) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v delim=%v f=%v, (%v:)", tls, s, n, delim, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetdelim(tls, s, n, delim, f)
}

func Xgetline(tls *TLS, s uintptr, n uintptr, f uintptr) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v, (%v:)", tls, s, n, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetdelim(tls, s, n, int32('\n'), f)
}

func Xgets(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, c, v1, v2, v3 int32
	var i, v6 Tsize_t
	var v4, v5 uintptr
	_, _, _, _, _, _, _, _, _ = __need_unlock, c, i, v1, v2, v3, v4, v5, v6
	i = uint64(0)
	if AtomicLoadPInt32(uintptr(unsafe.Pointer(&X__stdin_FILE))+140) >= 0 {
		v1 = ___lockfile(tls, uintptr(unsafe.Pointer(&X__stdin_FILE)))
	} else {
		v1 = 0
	}
	__need_unlock = v1
	for {
		if (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdin_FILE)))).Frpos != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdin_FILE)))).Frend {
			v5 = uintptr(unsafe.Pointer(&X__stdin_FILE)) + 8
			v4 = *(*uintptr)(unsafe.Pointer(v5))
			*(*uintptr)(unsafe.Pointer(v5))++
			v3 = int32(*(*uint8)(unsafe.Pointer(v4)))
		} else {
			v3 = X__uflow(tls, uintptr(unsafe.Pointer(&X__stdin_FILE)))
		}
		v2 = v3
		c = v2
		if !(v2 != -int32(1) && c != int32('\n')) {
			break
		}
		v6 = i
		i++
		*(*uint8)(unsafe.Pointer(s + uintptr(v6))) = uint8(c)
	}
	*(*uint8)(unsafe.Pointer(s + uintptr(i))) = uint8(0)
	if c != int32('\n') && (!((*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdin_FILE)))).Fflags&Uint32FromInt32(F_EOF) != 0) || !(i != 0)) {
		s = uintptr(0)
	}
	if __need_unlock != 0 {
		___unlockfile(tls, uintptr(unsafe.Pointer(&X__stdin_FILE)))
	}
	return s
}

func Xgetw(tls *TLS, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 int32
	var _ /* x at bp+0 */ int32
	_ = v1
	if Xfread(tls, bp, uint64(4), uint64(1), f) != 0 {
		v1 = *(*int32)(unsafe.Pointer(bp))
	} else {
		v1 = -int32(1)
	}
	return v1
}

func Xgetwc(tls *TLS, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfgetwc(tls, f)
}

func Xgetwchar(tls *TLS) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfgetwc(tls, uintptr(unsafe.Pointer(&X__stdin_FILE)))
}

func Xgetwchar_unlocked(tls *TLS) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetwchar(tls)
}

var _ofl_head uintptr
var _ofl_lock [1]int32

func X__ofl_lock(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	___lock(tls, uintptr(unsafe.Pointer(&_ofl_lock)))
	return uintptr(unsafe.Pointer(&_ofl_head))
}

func X__ofl_unlock(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	___unlock(tls, uintptr(unsafe.Pointer(&_ofl_lock)))
}

func X__ofl_add(tls *TLS, f uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var head uintptr
	_ = head
	head = X__ofl_lock(tls)
	(*TFILE)(unsafe.Pointer(f)).Fnext = *(*uintptr)(unsafe.Pointer(head))
	if *(*uintptr)(unsafe.Pointer(head)) != 0 {
		(*TFILE)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(head)))).Fprev = f
	}
	*(*uintptr)(unsafe.Pointer(head)) = f
	X__ofl_unlock(tls)
	return f
}

type Tcookie1 = struct {
	Fbufp  uintptr
	Fsizep uintptr
	Fpos   Tsize_t
	Fbuf   uintptr
	Flen1  Tsize_t
	Fspace Tsize_t
}

type Tms_FILE = struct {
	Ff   TFILE
	Fc   Tcookie1
	Fbuf [1024]uint8
}

func _ms_seek(tls *TLS, f uintptr, off Toff_t, whence int32) (r Toff_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var base Tssize_t
	var c uintptr
	var v2 Tsize_t
	_, _, _ = base, c, v2
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(uint32(whence) > uint32(2)) {
		goto _1
	}
	goto fail
fail:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
	return int64(-int32(1))
_1:
	;
	*(*[3]Tsize_t)(unsafe.Pointer(bp)) = [3]Tsize_t{
		1: (*Tcookie1)(unsafe.Pointer(c)).Fpos,
		2: (*Tcookie1)(unsafe.Pointer(c)).Flen1,
	}
	base = int64(*(*Tsize_t)(unsafe.Pointer(bp + uintptr(whence)*8)))
	if off < -base || off > int64(0x7fffffffffffffff)-base {
		goto fail
	}
	v2 = uint64(base + off)
	(*Tcookie1)(unsafe.Pointer(c)).Fpos = v2
	return int64(v2)
}

func _ms_write(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var c, newbuf, v1 uintptr
	var len2 Tsize_t
	_, _, _, _ = c, len2, newbuf, v1
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	len2 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
	if len2 != 0 {
		(*TFILE)(unsafe.Pointer(f)).Fwpos = (*TFILE)(unsafe.Pointer(f)).Fwbase
		if _ms_write(tls, f, (*TFILE)(unsafe.Pointer(f)).Fwbase, len2) < len2 {
			return uint64(0)
		}
	}
	if len1+(*Tcookie1)(unsafe.Pointer(c)).Fpos >= (*Tcookie1)(unsafe.Pointer(c)).Fspace {
		len2 = uint64(2)*(*Tcookie1)(unsafe.Pointer(c)).Fspace + uint64(1) | ((*Tcookie1)(unsafe.Pointer(c)).Fpos + len1 + uint64(1))
		newbuf = Xrealloc(tls, (*Tcookie1)(unsafe.Pointer(c)).Fbuf, len2)
		if !(newbuf != 0) {
			return uint64(0)
		}
		v1 = newbuf
		(*Tcookie1)(unsafe.Pointer(c)).Fbuf = v1
		*(*uintptr)(unsafe.Pointer((*Tcookie1)(unsafe.Pointer(c)).Fbufp)) = v1
		Xmemset(tls, (*Tcookie1)(unsafe.Pointer(c)).Fbuf+uintptr((*Tcookie1)(unsafe.Pointer(c)).Fspace), 0, len2-(*Tcookie1)(unsafe.Pointer(c)).Fspace)
		(*Tcookie1)(unsafe.Pointer(c)).Fspace = len2
	}
	Xmemcpy(tls, (*Tcookie1)(unsafe.Pointer(c)).Fbuf+uintptr((*Tcookie1)(unsafe.Pointer(c)).Fpos), buf, len1)
	*(*Tsize_t)(unsafe.Pointer(c + 16)) += len1
	if (*Tcookie1)(unsafe.Pointer(c)).Fpos >= (*Tcookie1)(unsafe.Pointer(c)).Flen1 {
		(*Tcookie1)(unsafe.Pointer(c)).Flen1 = (*Tcookie1)(unsafe.Pointer(c)).Fpos
	}
	*(*Tsize_t)(unsafe.Pointer((*Tcookie1)(unsafe.Pointer(c)).Fsizep)) = (*Tcookie1)(unsafe.Pointer(c)).Fpos
	return len1
}

func _ms_close(tls *TLS, f uintptr) (r int32) {
	return 0
}

func Xopen_memstream(tls *TLS, bufp uintptr, sizep uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v bufp=%v sizep=%v, (%v:)", tls, bufp, sizep, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var buf, f, v1, v2, v6 uintptr
	var v3, v4, v5 Tsize_t
	_, _, _, _, _, _, _, _ = buf, f, v1, v2, v3, v4, v5, v6
	v1 = Xmalloc(tls, uint64(1304))
	f = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	v2 = Xmalloc(tls, uint64(1))
	buf = v2
	if !(v2 != 0) {
		Xfree(tls, f)
		return uintptr(0)
	}
	Xmemset(tls, f, 0, uint64(232))
	Xmemset(tls, f+232, 0, uint64(48))
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Fcookie = f + 232
	(*Tms_FILE)(unsafe.Pointer(f)).Fc.Fbufp = bufp
	(*Tms_FILE)(unsafe.Pointer(f)).Fc.Fsizep = sizep
	v5 = Uint64FromInt32(0)
	*(*Tsize_t)(unsafe.Pointer(sizep)) = v5
	v4 = v5
	(*Tms_FILE)(unsafe.Pointer(f)).Fc.Fspace = v4
	v3 = v4
	(*Tms_FILE)(unsafe.Pointer(f)).Fc.Flen1 = v3
	(*Tms_FILE)(unsafe.Pointer(f)).Fc.Fpos = v3
	v6 = buf
	*(*uintptr)(unsafe.Pointer(bufp)) = v6
	(*Tms_FILE)(unsafe.Pointer(f)).Fc.Fbuf = v6
	*(*uint8)(unsafe.Pointer(buf)) = uint8(0)
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Fflags = uint32(F_NORD)
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Ffd = -int32(1)
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Fbuf = f + 280
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Fbuf_size = uint64(1024)
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Flbf = -int32(1)
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Fwrite = __ccgo_fp(_ms_write)
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Fseek = __ccgo_fp(_ms_seek)
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Fclose1 = __ccgo_fp(_ms_close)
	(*Tms_FILE)(unsafe.Pointer(f)).Ff.Fmode = -int32(1)
	if !(X__libc.Fthreaded != 0) {
		AtomicStorePInt32(f+140, -int32(1))
	}
	return X__ofl_add(tls, f)
}

type Tcookie2 = struct {
	Fbufp  uintptr
	Fsizep uintptr
	Fpos   Tsize_t
	Fbuf   uintptr
	Flen1  Tsize_t
	Fspace Tsize_t
	Fmbs   Tmbstate_t
}

type Twms_FILE = struct {
	Ff   TFILE
	Fc   Tcookie2
	Fbuf [1]uint8
}

func _wms_seek(tls *TLS, f uintptr, off Toff_t, whence int32) (r Toff_t) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var base Tssize_t
	var c uintptr
	var v2 Tsize_t
	_, _, _ = base, c, v2
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(uint32(whence) > uint32(2)) {
		goto _1
	}
	goto fail
fail:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
	return int64(-int32(1))
_1:
	;
	*(*[3]Tsize_t)(unsafe.Pointer(bp)) = [3]Tsize_t{
		1: (*Tcookie2)(unsafe.Pointer(c)).Fpos,
		2: (*Tcookie2)(unsafe.Pointer(c)).Flen1,
	}
	base = int64(*(*Tsize_t)(unsafe.Pointer(bp + uintptr(whence)*8)))
	if off < -base || off > Int64FromInt64(0x7fffffffffffffff)/Int64FromInt32(4)-base {
		goto fail
	}
	Xmemset(tls, c+48, 0, uint64(8))
	v2 = uint64(base + off)
	(*Tcookie2)(unsafe.Pointer(c)).Fpos = v2
	return int64(v2)
}

func _wms_write(tls *TLS, f uintptr, _buf uintptr, len1 Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = _buf
	var c, newbuf, v1 uintptr
	var len2 Tsize_t
	_, _, _, _ = c, len2, newbuf, v1
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	len2 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
	if len2 != 0 {
		(*TFILE)(unsafe.Pointer(f)).Fwpos = (*TFILE)(unsafe.Pointer(f)).Fwbase
		if _wms_write(tls, f, (*TFILE)(unsafe.Pointer(f)).Fwbase, len2) < len2 {
			return uint64(0)
		}
	}
	if len1+(*Tcookie2)(unsafe.Pointer(c)).Fpos >= (*Tcookie2)(unsafe.Pointer(c)).Fspace {
		len2 = uint64(2)*(*Tcookie2)(unsafe.Pointer(c)).Fspace + uint64(1) | ((*Tcookie2)(unsafe.Pointer(c)).Fpos + len1 + uint64(1))
		if len2 > uint64(Int64FromInt64(0x7fffffffffffffff)/Int64FromInt32(4)) {
			return uint64(0)
		}
		newbuf = Xrealloc(tls, (*Tcookie2)(unsafe.Pointer(c)).Fbuf, len2*uint64(4))
		if !(newbuf != 0) {
			return uint64(0)
		}
		v1 = newbuf
		(*Tcookie2)(unsafe.Pointer(c)).Fbuf = v1
		*(*uintptr)(unsafe.Pointer((*Tcookie2)(unsafe.Pointer(c)).Fbufp)) = v1
		Xmemset(tls, (*Tcookie2)(unsafe.Pointer(c)).Fbuf+uintptr((*Tcookie2)(unsafe.Pointer(c)).Fspace)*4, 0, uint64(4)*(len2-(*Tcookie2)(unsafe.Pointer(c)).Fspace))
		(*Tcookie2)(unsafe.Pointer(c)).Fspace = len2
	}
	len2 = Xmbsnrtowcs(tls, (*Tcookie2)(unsafe.Pointer(c)).Fbuf+uintptr((*Tcookie2)(unsafe.Pointer(c)).Fpos)*4, bp, len1, (*Tcookie2)(unsafe.Pointer(c)).Fspace-(*Tcookie2)(unsafe.Pointer(c)).Fpos, c+48)
	if len2 == uint64(-Int32FromInt32(1)) {
		return uint64(0)
	}
	*(*Tsize_t)(unsafe.Pointer(c + 16)) += len2
	if (*Tcookie2)(unsafe.Pointer(c)).Fpos >= (*Tcookie2)(unsafe.Pointer(c)).Flen1 {
		(*Tcookie2)(unsafe.Pointer(c)).Flen1 = (*Tcookie2)(unsafe.Pointer(c)).Fpos
	}
	*(*Tsize_t)(unsafe.Pointer((*Tcookie2)(unsafe.Pointer(c)).Fsizep)) = (*Tcookie2)(unsafe.Pointer(c)).Fpos
	return len1
}

func _wms_close(tls *TLS, f uintptr) (r int32) {
	return 0
}

func Xopen_wmemstream(tls *TLS, bufp uintptr, sizep uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v bufp=%v sizep=%v, (%v:)", tls, bufp, sizep, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var buf, f, v1, v2, v6 uintptr
	var v3, v4, v5 Tsize_t
	_, _, _, _, _, _, _, _ = buf, f, v1, v2, v3, v4, v5, v6
	v1 = Xmalloc(tls, uint64(296))
	f = v1
	if !(v1 != 0) {
		return uintptr(0)
	}
	v2 = Xmalloc(tls, uint64(4))
	buf = v2
	if !(v2 != 0) {
		Xfree(tls, f)
		return uintptr(0)
	}
	Xmemset(tls, f, 0, uint64(232))
	Xmemset(tls, f+232, 0, uint64(56))
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Fcookie = f + 232
	(*Twms_FILE)(unsafe.Pointer(f)).Fc.Fbufp = bufp
	(*Twms_FILE)(unsafe.Pointer(f)).Fc.Fsizep = sizep
	v5 = Uint64FromInt32(0)
	*(*Tsize_t)(unsafe.Pointer(sizep)) = v5
	v4 = v5
	(*Twms_FILE)(unsafe.Pointer(f)).Fc.Fspace = v4
	v3 = v4
	(*Twms_FILE)(unsafe.Pointer(f)).Fc.Flen1 = v3
	(*Twms_FILE)(unsafe.Pointer(f)).Fc.Fpos = v3
	v6 = buf
	*(*uintptr)(unsafe.Pointer(bufp)) = v6
	(*Twms_FILE)(unsafe.Pointer(f)).Fc.Fbuf = v6
	*(*Twchar_t)(unsafe.Pointer(buf)) = uint32(0)
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Fflags = uint32(F_NORD)
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Ffd = -int32(1)
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Fbuf = f + 288
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Fbuf_size = uint64(0)
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Flbf = -int32(1)
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Fwrite = __ccgo_fp(_wms_write)
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Fseek = __ccgo_fp(_wms_seek)
	(*Twms_FILE)(unsafe.Pointer(f)).Ff.Fclose1 = __ccgo_fp(_wms_close)
	if !(X__libc.Fthreaded != 0) {
		AtomicStorePInt32(f+140, -int32(1))
	}
	Xfwide(tls, f, int32(1))
	return X__ofl_add(tls, f)
}

func Xpclose(tls *TLS, f uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var pid Tpid_t
	var r, v1 int32
	var _ /* status at bp+0 */ int32
	_, _, _ = pid, r, v1
	pid = (*TFILE)(unsafe.Pointer(f)).Fpipe_pid
	Xfclose(tls, f)
	for {
		v1 = int32(X__syscall4(tls, int64(SYS_wait4), int64(pid), int64(bp), int64(Int32FromInt32(0)), int64(Int32FromInt32(0))))
		r = v1
		if !(v1 == -int32(EINTR)) {
			break
		}
	}
	if r < 0 {
		return int32(X__syscall_ret(tls, uint64(r)))
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func Xperror(tls *TLS, msg uintptr) {
	if __ccgo_strace {
		trc("tls=%v msg=%v, (%v:)", tls, msg, origin(2))
	}
	var __need_unlock, old_mode, v1 int32
	var errstr, f, old_locale uintptr
	_, _, _, _, _, _ = __need_unlock, errstr, f, old_locale, old_mode, v1
	f = uintptr(unsafe.Pointer(&X__stderr_FILE))
	errstr = Xstrerror(tls, *(*int32)(unsafe.Pointer(X__errno_location(tls))))
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	/* Save stderr's orientation and encoding rule, since perror is not
	 * permitted to change them. */
	old_locale = (*TFILE)(unsafe.Pointer(f)).Flocale
	old_mode = (*TFILE)(unsafe.Pointer(f)).Fmode
	if msg != 0 && *(*uint8)(unsafe.Pointer(msg)) != 0 {
		Xfwrite(tls, msg, Xstrlen(tls, msg), uint64(1), f)
		Xfputc(tls, int32(':'), f)
		Xfputc(tls, int32(' '), f)
	}
	Xfwrite(tls, errstr, Xstrlen(tls, errstr), uint64(1), f)
	Xfputc(tls, int32('\n'), f)
	(*TFILE)(unsafe.Pointer(f)).Fmode = old_mode
	(*TFILE)(unsafe.Pointer(f)).Flocale = old_locale
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
}

func Xprintf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v va=%v, (%v:)", tls, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvfprintf(tls, uintptr(unsafe.Pointer(&X__stdout_FILE)), fmt, ap)
	_ = ap
	return ret
}

func _locking_putc1(tls *TLS, c int32, f uintptr) (r1 int32) {
	var old, old1, r, v, v14, v17, v19, v2, v22, v23, v5, v7, v9 int32
	var v1, v11, v12, v13, v21 uintptr
	var v10 uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = old, old1, r, v, v1, v10, v11, v12, v13, v14, v17, v19, v2, v21, v22, v23, v5, v7, v9
	v1 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1521)
		v5 = v
		goto _6
	_6:
		old = v5
		if old != 0 {
			// __asm__ __volatile__ ("dmb ish" : : : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1521)
			break
		}
		goto _4
	_4:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1521)
		v2 = BoolInt32(!(r != 0))
		goto _3
	_3:
		;
		if !!(v2 != 0) {
			break
		}
	}
	v7 = old
	goto _8
_8:
	if v7 != 0 {
		___lockfile(tls, f)
	}
	if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(f)).Flbf && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend {
		v10 = uint8(c)
		v12 = f + 40
		v11 = *(*uintptr)(unsafe.Pointer(v12))
		*(*uintptr)(unsafe.Pointer(v12))++
		*(*uint8)(unsafe.Pointer(v11)) = v10
		v9 = int32(v10)
	} else {
		v9 = X__overflow(tls, f, int32(uint8(c)))
	}
	c = v9
	v13 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1521)
		v17 = v
		goto _18
	_18:
		old1 = v17
		goto _16
	_16:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1521)
		v14 = BoolInt32(!(r != 0))
		goto _15
	_15:
		;
		if !!(v14 != 0) {
			break
		}
	}
	v19 = old1
	goto _20
_20:
	if v19&int32(MAYBE_WAITERS) != 0 {
		v21 = f + 140
		v22 = int32(1)
		v23 = int32(1)
		if v23 != 0 {
			v23 = int32(FUTEX_PRIVATE)
		}
		if v22 < Int32FromInt32(0) {
			v22 = int32(INT_MAX)
		}
		_ = X__syscall3(tls, int64(SYS_futex), int64(v21), int64(Int32FromInt32(FUTEX_WAKE)|v23), int64(v22)) != int64(-int32(ENOSYS)) || X__syscall3(tls, int64(SYS_futex), int64(v21), int64(Int32FromInt32(FUTEX_WAKE)), int64(v22)) != 0
	}
	return c
}

func Xputc(tls *TLS, c1 int32, f1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c1=%v f1=%v, (%v:)", tls, c1, f1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l, v1, v3, v5 int32
	var v2, v7, v8 uintptr
	var v6 uint8
	_, _, _, _, _, _, _, _ = l, v1, v2, v3, v5, v6, v7, v8
	v1 = c1
	v2 = f1
	l = AtomicLoadPInt32(v2 + 140)
	if l < 0 || l != 0 && l & ^Int32FromInt32(MAYBE_WAITERS) == (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
		if int32(uint8(v1)) != (*TFILE)(unsafe.Pointer(v2)).Flbf && (*TFILE)(unsafe.Pointer(v2)).Fwpos != (*TFILE)(unsafe.Pointer(v2)).Fwend {
			v6 = uint8(v1)
			v8 = v2 + 40
			v7 = *(*uintptr)(unsafe.Pointer(v8))
			*(*uintptr)(unsafe.Pointer(v8))++
			*(*uint8)(unsafe.Pointer(v7)) = v6
			v5 = int32(v6)
		} else {
			v5 = X__overflow(tls, v2, int32(uint8(v1)))
		}
		v3 = v5
		goto _4
	}
	v3 = _locking_putc1(tls, v1, v2)
	goto _4
_4:
	return v3
}

func X_IO_putc(tls *TLS, c1 int32, f1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c1=%v f1=%v, (%v:)", tls, c1, f1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xputc(tls, c1, f1)
}

func Xputc_unlocked(tls *TLS, c int32, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	var v2 uint8
	var v3, v4 uintptr
	_, _, _, _ = v1, v2, v3, v4
	if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(f)).Flbf && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend {
		v2 = uint8(c)
		v4 = f + 40
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(v3)) = v2
		v1 = int32(v2)
	} else {
		v1 = X__overflow(tls, f, int32(uint8(c)))
	}
	return v1
}

func X_IO_putc_unlocked(tls *TLS, c int32, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xputc_unlocked(tls, c, f)
}

func Xfputc_unlocked(tls *TLS, c int32, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xputc_unlocked(tls, c, f)
}

func _locking_putc2(tls *TLS, c int32, f uintptr) (r1 int32) {
	var old, old1, r, v, v14, v17, v19, v2, v22, v23, v5, v7, v9 int32
	var v1, v11, v12, v13, v21 uintptr
	var v10 uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = old, old1, r, v, v1, v10, v11, v12, v13, v14, v17, v19, v2, v21, v22, v23, v5, v7, v9
	v1 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1521)
		v5 = v
		goto _6
	_6:
		old = v5
		if old != 0 {
			// __asm__ __volatile__ ("dmb ish" : : : "memory");
			X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1521)
			break
		}
		goto _4
	_4:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1521)
		v2 = BoolInt32(!(r != 0))
		goto _3
	_3:
		;
		if !!(v2 != 0) {
			break
		}
	}
	v7 = old
	goto _8
_8:
	if v7 != 0 {
		___lockfile(tls, f)
	}
	if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(f)).Flbf && (*TFILE)(unsafe.Pointer(f)).Fwpos != (*TFILE)(unsafe.Pointer(f)).Fwend {
		v10 = uint8(c)
		v12 = f + 40
		v11 = *(*uintptr)(unsafe.Pointer(v12))
		*(*uintptr)(unsafe.Pointer(v12))++
		*(*uint8)(unsafe.Pointer(v11)) = v10
		v9 = int32(v10)
	} else {
		v9 = X__overflow(tls, f, int32(uint8(c)))
	}
	c = v9
	v13 = f + 140
	for {
		// __asm__ __volatile__ ("ldaxr %w0,%1" : "=r"(v) : "Q"(*p));
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 5, __ccgo_ts+1521)
		v17 = v
		goto _18
	_18:
		old1 = v17
		goto _16
	_16:
		;
		// __asm__ __volatile__ ("stlxr %w0,%w2,%1" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 13, __ccgo_ts+1521)
		v14 = BoolInt32(!(r != 0))
		goto _15
	_15:
		;
		if !!(v14 != 0) {
			break
		}
	}
	v19 = old1
	goto _20
_20:
	if v19&int32(MAYBE_WAITERS) != 0 {
		v21 = f + 140
		v22 = int32(1)
		v23 = int32(1)
		if v23 != 0 {
			v23 = int32(FUTEX_PRIVATE)
		}
		if v22 < Int32FromInt32(0) {
			v22 = int32(INT_MAX)
		}
		_ = X__syscall3(tls, int64(SYS_futex), int64(v21), int64(Int32FromInt32(FUTEX_WAKE)|v23), int64(v22)) != int64(-int32(ENOSYS)) || X__syscall3(tls, int64(SYS_futex), int64(v21), int64(Int32FromInt32(FUTEX_WAKE)), int64(v22)) != 0
	}
	return c
}

func Xputchar(tls *TLS, c1 int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c1=%v, (%v:)", tls, c1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l, v1, v3, v5 int32
	var v2, v7, v8 uintptr
	var v6 uint8
	_, _, _, _, _, _, _, _ = l, v1, v2, v3, v5, v6, v7, v8
	v1 = c1
	v2 = uintptr(unsafe.Pointer(&X__stdout_FILE))
	l = AtomicLoadPInt32(v2 + 140)
	if l < 0 || l != 0 && l & ^Int32FromInt32(MAYBE_WAITERS) == (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Ftid {
		if int32(uint8(v1)) != (*TFILE)(unsafe.Pointer(v2)).Flbf && (*TFILE)(unsafe.Pointer(v2)).Fwpos != (*TFILE)(unsafe.Pointer(v2)).Fwend {
			v6 = uint8(v1)
			v8 = v2 + 40
			v7 = *(*uintptr)(unsafe.Pointer(v8))
			*(*uintptr)(unsafe.Pointer(v8))++
			*(*uint8)(unsafe.Pointer(v7)) = v6
			v5 = int32(v6)
		} else {
			v5 = X__overflow(tls, v2, int32(uint8(v1)))
		}
		v3 = v5
		goto _4
	}
	v3 = _locking_putc2(tls, v1, v2)
	goto _4
_4:
	return v3
}

func Xputchar_unlocked(tls *TLS, c int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	var v2 uint8
	var v3, v4 uintptr
	_, _, _, _ = v1, v2, v3, v4
	if int32(uint8(c)) != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdout_FILE)))).Flbf && (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdout_FILE)))).Fwpos != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdout_FILE)))).Fwend {
		v2 = uint8(c)
		v4 = uintptr(unsafe.Pointer(&X__stdout_FILE)) + 40
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(v3)) = v2
		v1 = int32(v2)
	} else {
		v1 = X__overflow(tls, uintptr(unsafe.Pointer(&X__stdout_FILE)), int32(uint8(c)))
	}
	return v1
}

func Xputs(tls *TLS, s uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var __need_unlock, r, v1, v2 int32
	var v3 uint8
	var v4, v5 uintptr
	var v6 bool
	_, _, _, _, _, _, _, _ = __need_unlock, r, v1, v2, v3, v4, v5, v6
	if AtomicLoadPInt32(uintptr(unsafe.Pointer(&X__stdout_FILE))+140) >= 0 {
		v1 = ___lockfile(tls, uintptr(unsafe.Pointer(&X__stdout_FILE)))
	} else {
		v1 = 0
	}
	__need_unlock = v1
	if v6 = Xfputs(tls, s, uintptr(unsafe.Pointer(&X__stdout_FILE))) < 0; !v6 {
		if int32(uint8(Int32FromUint8('\n'))) != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdout_FILE)))).Flbf && (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdout_FILE)))).Fwpos != (*TFILE)(unsafe.Pointer(uintptr(unsafe.Pointer(&X__stdout_FILE)))).Fwend {
			v3 = uint8(Int32FromUint8('\n'))
			v5 = uintptr(unsafe.Pointer(&X__stdout_FILE)) + 40
			v4 = *(*uintptr)(unsafe.Pointer(v5))
			*(*uintptr)(unsafe.Pointer(v5))++
			*(*uint8)(unsafe.Pointer(v4)) = v3
			v2 = int32(v3)
		} else {
			v2 = X__overflow(tls, uintptr(unsafe.Pointer(&X__stdout_FILE)), int32(uint8(Int32FromUint8('\n'))))
		}
	}
	r = -BoolInt32(v6 || v2 < 0)
	if __need_unlock != 0 {
		___unlockfile(tls, uintptr(unsafe.Pointer(&X__stdout_FILE)))
	}
	return r
}

func Xputw(tls *TLS, _x int32, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v _x=%v f=%v, (%v:)", tls, _x, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*int32)(unsafe.Pointer(bp)) = _x
	return int32(Xfwrite(tls, bp, uint64(4), uint64(1), f)) - int32(1)
}

func Xputwc(tls *TLS, c Twchar_t, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfputwc(tls, c, f)
}

func Xputwchar(tls *TLS, c Twchar_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xfputwc(tls, c, uintptr(unsafe.Pointer(&X__stdout_FILE)))
}

func Xputwchar_unlocked(tls *TLS, c Twchar_t) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v, (%v:)", tls, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xputwchar(tls, c)
}

func Xremove(tls *TLS, path uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v, (%v:)", tls, path, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = int32(X__syscall3(tls, int64(SYS_unlinkat), int64(-Int32FromInt32(100)), int64(path), int64(Int32FromInt32(0))))
	if r == -int32(EISDIR) {
		r = int32(X__syscall3(tls, int64(SYS_unlinkat), int64(-Int32FromInt32(100)), int64(path), int64(Int32FromInt32(AT_REMOVEDIR))))
	}
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xrename(tls *TLS, old uintptr, new1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v old=%v new1=%v, (%v:)", tls, old, new1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_renameat), int64(-Int32FromInt32(100)), int64(old), int64(-Int32FromInt32(100)), int64(new1)))))
}

func Xrewind(tls *TLS, f uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	var __need_unlock, v1 int32
	_, _ = __need_unlock, v1
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	X__fseeko_unlocked(tls, f, 0, 0)
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(F_ERR))
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
}

func Xscanf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v va=%v, (%v:)", tls, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvscanf(tls, fmt, ap)
	_ = ap
	return ret
}

func X__isoc99_scanf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v va=%v, (%v:)", tls, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xscanf(tls, fmt, va)
}

func Xsetbuf(tls *TLS, f uintptr, buf uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v buf=%v, (%v:)", tls, f, buf, origin(2))
	}
	var v1 int32
	_ = v1
	if buf != 0 {
		v1 = _IOFBF
	} else {
		v1 = int32(_IONBF)
	}
	Xsetvbuf(tls, f, buf, v1, uint64(BUFSIZ))
}

func Xsetbuffer(tls *TLS, f uintptr, buf uintptr, size Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v f=%v buf=%v size=%v, (%v:)", tls, f, buf, size, origin(2))
	}
	var v1 int32
	_ = v1
	if buf != 0 {
		v1 = _IOFBF
	} else {
		v1 = int32(_IONBF)
	}
	Xsetvbuf(tls, f, buf, v1, size)
}

func Xsetlinebuf(tls *TLS, f uintptr) {
	if __ccgo_strace {
		trc("tls=%v f=%v, (%v:)", tls, f, origin(2))
	}
	Xsetvbuf(tls, f, uintptr(0), int32(_IOLBF), uint64(0))
}

/* The behavior of this function is undefined except when it is the first
 * operation on the stream, so the presence or absence of locking is not
 * observable in a program whose behavior is defined. Thus no locking is
 * performed here. No allocation of buffers is performed, but a buffer
 * provided by the caller is used as long as it is suitably sized. */

func Xsetvbuf(tls *TLS, f uintptr, buf uintptr, type1 int32, size Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v buf=%v type1=%v size=%v, (%v:)", tls, f, buf, type1, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	(*TFILE)(unsafe.Pointer(f)).Flbf = -int32(1)
	if type1 == int32(_IONBF) {
		(*TFILE)(unsafe.Pointer(f)).Fbuf_size = uint64(0)
	} else {
		if type1 == int32(_IOLBF) || type1 == _IOFBF {
			if buf != 0 && size >= uint64(UNGET) {
				(*TFILE)(unsafe.Pointer(f)).Fbuf = buf + UintptrFromInt32(UNGET)
				(*TFILE)(unsafe.Pointer(f)).Fbuf_size = size - uint64(UNGET)
			}
			if type1 == int32(_IOLBF) && (*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0 {
				(*TFILE)(unsafe.Pointer(f)).Flbf = int32('\n')
			}
		} else {
			return -int32(1)
		}
	}
	*(*uint32)(unsafe.Pointer(f)) |= uint32(F_SVB)
	return 0
}

func Xsnprintf(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v fmt=%v va=%v, (%v:)", tls, s, n, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvsnprintf(tls, s, n, fmt, ap)
	_ = ap
	return ret
}

func Xsprintf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v va=%v, (%v:)", tls, s, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvsprintf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func Xsscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v va=%v, (%v:)", tls, s, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvsscanf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func X__isoc99_sscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v va=%v, (%v:)", tls, s, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsscanf(tls, s, fmt, va)
}

var _buf5 [8]uint8

func init() {
	p := unsafe.Pointer(&X__stderr_FILE)
	*(*uintptr)(unsafe.Add(p, 24)) = __ccgo_fp(X__stdio_close)
	*(*uintptr)(unsafe.Add(p, 72)) = __ccgo_fp(X__stdio_write)
	*(*uintptr)(unsafe.Add(p, 80)) = __ccgo_fp(X__stdio_seek)
}

var _buf6 [1032]uint8

func init() {
	p := unsafe.Pointer(&X__stdin_FILE)
	*(*uintptr)(unsafe.Add(p, 24)) = __ccgo_fp(X__stdio_close)
	*(*uintptr)(unsafe.Add(p, 64)) = __ccgo_fp(X__stdio_read)
	*(*uintptr)(unsafe.Add(p, 80)) = __ccgo_fp(X__stdio_seek)
}

var _buf7 [1032]uint8

func init() {
	p := unsafe.Pointer(&X__stdout_FILE)
	*(*uintptr)(unsafe.Add(p, 24)) = __ccgo_fp(X__stdio_close)
	*(*uintptr)(unsafe.Add(p, 72)) = __ccgo_fp(X__stdout_write)
	*(*uintptr)(unsafe.Add(p, 80)) = __ccgo_fp(X__stdio_seek)
}

func Xswprintf(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v fmt=%v va=%v, (%v:)", tls, s, n, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvswprintf(tls, s, n, fmt, ap)
	_ = ap
	return ret
}

func Xswscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v va=%v, (%v:)", tls, s, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvswscanf(tls, s, fmt, ap)
	_ = ap
	return ret
}

func X__isoc99_swscanf(tls *TLS, s uintptr, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v va=%v, (%v:)", tls, s, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xswscanf(tls, s, fmt, va)
}

const MAXTRIES = 100

func Xtempnam(tls *TLS, dir uintptr, pfx uintptr) (r1 uintptr) {
	if __ccgo_strace {
		trc("tls=%v dir=%v pfx=%v, (%v:)", tls, dir, pfx, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(4112)
	defer tls.Free(4112)
	var dl, l, pl Tsize_t
	var r, try int32
	var _ /* s at bp+1 */ [4096]uint8
	_, _, _, _, _ = dl, l, pl, r, try
	if !(dir != 0) {
		dir = __ccgo_ts + 1573
	}
	if !(pfx != 0) {
		pfx = __ccgo_ts + 1578
	}
	dl = Xstrlen(tls, dir)
	pl = Xstrlen(tls, pfx)
	l = dl + uint64(1) + pl + uint64(1) + uint64(6)
	if l >= uint64(PATH_MAX) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENAMETOOLONG)
		return uintptr(0)
	}
	Xmemcpy(tls, bp+1, dir, dl)
	(*(*[4096]uint8)(unsafe.Pointer(bp + 1)))[dl] = uint8('/')
	Xmemcpy(tls, bp+1+uintptr(dl)+uintptr(1), pfx, pl)
	(*(*[4096]uint8)(unsafe.Pointer(bp + 1)))[dl+uint64(1)+pl] = uint8('_')
	(*(*[4096]uint8)(unsafe.Pointer(bp + 1)))[l] = uint8(0)
	try = 0
	for {
		if !(try < int32(MAXTRIES)) {
			break
		}
		___randname(tls, bp+1+uintptr(l)-uintptr(6))
		*(*[1]uint8)(unsafe.Pointer(bp)) = [1]uint8{}
		r = int32(X__syscall4(tls, int64(SYS_readlinkat), int64(-Int32FromInt32(100)), int64(bp+1), int64(bp), int64(Int32FromInt32(1))))
		if r == -int32(ENOENT) {
			return Xstrdup(tls, bp+1)
		}
		goto _1
	_1:
		;
		try++
	}
	return uintptr(0)
}

func Xtmpfile(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var f uintptr
	var fd, try int32
	var _ /* s at bp+0 */ [20]uint8
	_, _, _ = f, fd, try
	*(*[20]uint8)(unsafe.Pointer(bp)) = [20]uint8{'/', 't', 'm', 'p', '/', 't', 'm', 'p', 'f', 'i', 'l', 'e', '_', 'X', 'X', 'X', 'X', 'X', 'X'}
	try = 0
	for {
		if !(try < int32(MAXTRIES)) {
			break
		}
		___randname(tls, bp+uintptr(13))
		fd = int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_openat), int64(-Int32FromInt32(100)), int64(bp), int64(Int32FromInt32(O_RDWR)|Int32FromInt32(O_CREAT)|Int32FromInt32(O_EXCL)|Int32FromInt32(O_LARGEFILE)), int64(Int32FromInt32(0600))))))
		if fd >= 0 {
			X__syscall3(tls, int64(SYS_unlinkat), int64(-Int32FromInt32(100)), int64(bp), int64(Int32FromInt32(0)))
			f = X__fdopen(tls, fd, __ccgo_ts+1583)
			if !(f != 0) {
				X__syscall1(tls, int64(SYS_close), int64(fd))
			}
			return f
		}
		goto _1
	_1:
		;
		try++
	}
	return uintptr(0)
}

func Xtmpnam(tls *TLS, buf uintptr) (r1 uintptr) {
	if __ccgo_strace {
		trc("tls=%v buf=%v, (%v:)", tls, buf, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var r, try int32
	var v2 uintptr
	var _ /* s at bp+1 */ [19]uint8
	_, _, _ = r, try, v2
	*(*[19]uint8)(unsafe.Pointer(bp + 1)) = [19]uint8{'/', 't', 'm', 'p', '/', 't', 'm', 'p', 'n', 'a', 'm', '_', 'X', 'X', 'X', 'X', 'X', 'X'}
	try = 0
	for {
		if !(try < int32(MAXTRIES)) {
			break
		}
		___randname(tls, bp+1+uintptr(12))
		*(*[1]uint8)(unsafe.Pointer(bp)) = [1]uint8{}
		r = int32(X__syscall4(tls, int64(SYS_readlinkat), int64(-Int32FromInt32(100)), int64(bp+1), int64(bp), int64(Int32FromInt32(1))))
		if r == -int32(ENOENT) {
			if buf != 0 {
				v2 = buf
			} else {
				v2 = uintptr(unsafe.Pointer(&_internal1))
			}
			return Xstrcpy(tls, v2, bp+1)
		}
		goto _1
	_1:
		;
		try++
	}
	return uintptr(0)
}

var _internal1 [20]uint8

func Xungetc(tls *TLS, c int32, f uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var __need_unlock, v1 int32
	var v2, v3 uintptr
	_, _, _, _ = __need_unlock, v1, v2, v3
	if c == -int32(1) {
		return c
	}
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		X__toread(tls, f)
	}
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) || (*TFILE)(unsafe.Pointer(f)).Frpos <= (*TFILE)(unsafe.Pointer(f)).Fbuf-uintptr(UNGET) {
		if __need_unlock != 0 {
			___unlockfile(tls, f)
		}
		return -int32(1)
	}
	v3 = f + 8
	*(*uintptr)(unsafe.Pointer(v3))--
	v2 = *(*uintptr)(unsafe.Pointer(v3))
	*(*uint8)(unsafe.Pointer(v2)) = uint8(c)
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(F_EOF))
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return int32(uint8(c))
}

func Xungetwc(tls *TLS, c Twint_t, f uintptr) (r Twint_t) {
	if __ccgo_strace {
		trc("tls=%v c=%v f=%v, (%v:)", tls, c, f, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var __need_unlock, l, v1, v2 int32
	var loc Tlocale_t
	var ploc, v4, v5, p6 uintptr
	var v3 bool
	var _ /* mbc at bp+0 */ [4]uint8
	_, _, _, _, _, _, _, _, _, _ = __need_unlock, l, loc, ploc, v1, v2, v3, v4, v5, p6
	ploc = ___get_tp(tls) + 152
	loc = *(*Tlocale_t)(unsafe.Pointer(ploc))
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	if (*TFILE)(unsafe.Pointer(f)).Fmode <= 0 {
		Xfwide(tls, f, int32(1))
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = (*TFILE)(unsafe.Pointer(f)).Flocale
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		X__toread(tls, f)
	}
	if v3 = !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) || c == uint32(0xffffffff); !v3 {
		v2 = int32(Xwcrtomb(tls, bp, c, uintptr(0)))
		l = v2
	}
	if v3 || v2 < 0 || (*TFILE)(unsafe.Pointer(f)).Frpos < (*TFILE)(unsafe.Pointer(f)).Fbuf-uintptr(UNGET)+uintptr(l) {
		if __need_unlock != 0 {
			___unlockfile(tls, f)
		}
		*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
		return uint32(0xffffffff)
	}
	if BoolInt32(c < uint32(128)) != 0 {
		v5 = f + 8
		*(*uintptr)(unsafe.Pointer(v5))--
		v4 = *(*uintptr)(unsafe.Pointer(v5))
		*(*uint8)(unsafe.Pointer(v4)) = uint8(c)
	} else {
		p6 = f + 8
		*(*uintptr)(unsafe.Pointer(p6)) -= uintptr(l)
		Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(p6)), bp, uint64(l))
	}
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(F_EOF))
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	*(*Tlocale_t)(unsafe.Pointer(ploc)) = loc
	return c
}

func Xvasprintf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v ap=%v, (%v:)", tls, s, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap2 Tva_list
	var l int32
	var v1 uintptr
	var v2 bool
	_, _, _, _ = ap2, l, v1, v2
	ap2 = ap
	l = Xvsnprintf(tls, uintptr(0), uint64(0), fmt, ap2)
	_ = ap2
	if v2 = l < 0; !v2 {
		v1 = Xmalloc(tls, uint64(uint32(l)+uint32(1)))
		*(*uintptr)(unsafe.Pointer(s)) = v1
	}
	if v2 || !(v1 != 0) {
		return -int32(1)
	}
	return Xvsnprintf(tls, *(*uintptr)(unsafe.Pointer(s)), uint64(uint32(l)+uint32(1)), fmt, ap)
}

func Xvdprintf(tls *TLS, fd int32, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v fmt=%v ap=%v, (%v:)", tls, fd, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(240)
	defer tls.Free(240)
	var _ /* f at bp+0 */ TFILE
	*(*TFILE)(unsafe.Pointer(bp)) = TFILE{
		Fwrite: __ccgo_fp(X__stdio_write),
		Fbuf:   fmt,
		Ffd:    fd,
		Flock:  -int32(1),
		Flbf:   -int32(1),
	}
	return Xvfprintf(tls, bp, fmt, ap)
}

const ALT_FORM = 8
const FLAGMASK = 75913
const GROUPED = 128
const LDBL_EPSILON3 = 2.22044604925031308085e-16
const LEFT_ADJ = 8192
const MARK_POS = 2048
const PAD_POS = 1
const ZERO_PAD = 65536

const _BARE = 0
const _LPRE = 1
const _LLPRE = 2
const _HPRE = 3
const _HHPRE = 4
const _BIGLPRE = 5
const _ZTPRE = 6
const _JPRE = 7
const _STOP = 8
const _PTR = 9
const _INT = 10
const _UINT = 11
const _ULLONG = 12
const _LONG = 13
const _ULONG = 14
const _SHORT = 15
const _USHORT = 16
const _CHAR = 17
const _UCHAR = 18
const _LLONG = 19
const _SIZET = 20
const _IMAX = 21
const _UMAX = 22
const _PDIFF = 23
const _UIPTR = 24
const _DBL = 25
const _LDBL = 26
const _NOARG = 27
const _MAXSTATE = 28

var _states = [8][58]uint8{
	0: {
		0:  uint8(_DBL),
		2:  uint8(_UINT),
		4:  uint8(_DBL),
		5:  uint8(_DBL),
		6:  uint8(_DBL),
		11: uint8(_BIGLPRE),
		18: uint8(_PTR),
		23: uint8(_UINT),
		32: uint8(_DBL),
		34: uint8(_INT),
		35: uint8(_INT),
		36: uint8(_DBL),
		37: uint8(_DBL),
		38: uint8(_DBL),
		39: uint8(_HPRE),
		40: uint8(_INT),
		41: uint8(_JPRE),
		43: uint8(_LPRE),
		44: uint8(_NOARG),
		45: uint8(_PTR),
		46: uint8(_UINT),
		47: uint8(_UIPTR),
		50: uint8(_PTR),
		51: uint8(_ZTPRE),
		52: uint8(_UINT),
		55: uint8(_UINT),
		57: uint8(_ZTPRE),
	},
	1: {
		0:  uint8(_DBL),
		4:  uint8(_DBL),
		5:  uint8(_DBL),
		6:  uint8(_DBL),
		23: uint8(_ULONG),
		32: uint8(_DBL),
		34: uint8(_UINT),
		35: uint8(_LONG),
		36: uint8(_DBL),
		37: uint8(_DBL),
		38: uint8(_DBL),
		40: uint8(_LONG),
		43: uint8(_LLPRE),
		45: uint8(_PTR),
		46: uint8(_ULONG),
		50: uint8(_PTR),
		52: uint8(_ULONG),
		55: uint8(_ULONG),
	},
	2: {
		23: uint8(_ULLONG),
		35: uint8(_LLONG),
		40: uint8(_LLONG),
		45: uint8(_PTR),
		46: uint8(_ULLONG),
		52: uint8(_ULLONG),
		55: uint8(_ULLONG),
	},
	3: {
		23: uint8(_USHORT),
		35: uint8(_SHORT),
		39: uint8(_HHPRE),
		40: uint8(_SHORT),
		45: uint8(_PTR),
		46: uint8(_USHORT),
		52: uint8(_USHORT),
		55: uint8(_USHORT),
	},
	4: {
		23: uint8(_UCHAR),
		35: uint8(_CHAR),
		40: uint8(_CHAR),
		45: uint8(_PTR),
		46: uint8(_UCHAR),
		52: uint8(_UCHAR),
		55: uint8(_UCHAR),
	},
	5: {
		0:  uint8(_LDBL),
		4:  uint8(_LDBL),
		5:  uint8(_LDBL),
		6:  uint8(_LDBL),
		32: uint8(_LDBL),
		36: uint8(_LDBL),
		37: uint8(_LDBL),
		38: uint8(_LDBL),
		45: uint8(_PTR),
	},
	6: {
		23: uint8(_SIZET),
		35: uint8(_PDIFF),
		40: uint8(_PDIFF),
		45: uint8(_PTR),
		46: uint8(_SIZET),
		52: uint8(_SIZET),
		55: uint8(_SIZET),
	},
	7: {
		23: uint8(_UMAX),
		35: uint8(_IMAX),
		40: uint8(_IMAX),
		45: uint8(_PTR),
		46: uint8(_UMAX),
		52: uint8(_UMAX),
		55: uint8(_UMAX),
	},
}

type Targ = struct {
	Ff [0]float64
	Fp [0]uintptr
	Fi Tuintmax_t
}

func _pop_arg(tls *TLS, arg uintptr, type1 int32, ap uintptr) {
	switch type1 {
	case int32(_PTR):
		*(*uintptr)(unsafe.Pointer(arg)) = VaUintptr(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_INT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UINT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaUint32(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_LONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_ULONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_ULLONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_SHORT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(int16(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_USHORT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(uint16(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_CHAR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(int8(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_UCHAR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(uint8(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_LLONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_SIZET):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_IMAX):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UMAX):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_PDIFF):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UIPTR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaUintptr(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_DBL):
		*(*float64)(unsafe.Pointer(arg)) = VaFloat64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_LDBL):
		*(*float64)(unsafe.Pointer(arg)) = VaFloat64(&*(*Tva_list)(unsafe.Pointer(ap)))
	}
}

func _out(tls *TLS, f uintptr, s uintptr, l Tsize_t) {
	if !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_ERR) != 0) {
		X__fwritex(tls, s, l, f)
	}
}

func _pad3(tls *TLS, f uintptr, c uint8, w int32, l int32, fl int32) {
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var v1 uint64
	var _ /* pad at bp+0 */ [256]uint8
	_ = v1
	if uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))) != 0 || l >= w {
		return
	}
	l = w - l
	if uint64(l) > uint64(256) {
		v1 = uint64(256)
	} else {
		v1 = uint64(l)
	}
	Xmemset(tls, bp, int32(c), v1)
	for {
		if !(uint64(l) >= uint64(256)) {
			break
		}
		_out(tls, f, bp, uint64(256))
		goto _2
	_2:
		;
		l = int32(uint64(l) - Uint64FromInt64(256))
	}
	_out(tls, f, bp, uint64(l))
}

var _xdigits1 = [16]uint8{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}

func _fmt_x(tls *TLS, x Tuintmax_t, s uintptr, lower int32) (r uintptr) {
	var v2 uintptr
	_ = v2
	for {
		if !(x != 0) {
			break
		}
		s--
		v2 = s
		*(*uint8)(unsafe.Pointer(v2)) = uint8(int32(_xdigits1[x&uint64(15)]) | lower)
		goto _1
	_1:
		;
		x >>= uint64(4)
	}
	return s
}

func _fmt_o(tls *TLS, x Tuintmax_t, s uintptr) (r uintptr) {
	var v2 uintptr
	_ = v2
	for {
		if !(x != 0) {
			break
		}
		s--
		v2 = s
		*(*uint8)(unsafe.Pointer(v2)) = uint8(uint64('0') + x&uint64(7))
		goto _1
	_1:
		;
		x >>= uint64(3)
	}
	return s
}

func _fmt_u(tls *TLS, x Tuintmax_t, s uintptr) (r uintptr) {
	var y uint64
	var v2, v4 uintptr
	_, _, _ = y, v2, v4
	for {
		if !(x > Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1)) {
			break
		}
		s--
		v2 = s
		*(*uint8)(unsafe.Pointer(v2)) = uint8(uint64('0') + x%uint64(10))
		goto _1
	_1:
		;
		x /= uint64(10)
	}
	y = x
	for {
		if !(y != 0) {
			break
		}
		s--
		v4 = s
		*(*uint8)(unsafe.Pointer(v4)) = uint8(uint64('0') + y%uint64(10))
		goto _3
	_3:
		;
		y /= uint64(10)
	}
	return s
}

// C documentation
//
//	/* Do not override this check. The floating point printing code below
//	 * depends on the float.h constants being right. If they are wrong, it
//	 * may overflow the stack. */
type Tcompiler_defines_long_double_incorrectly = [1]uint8

func _fmt_fp(tls *TLS, f uintptr, y float64, w int32, p int32, fl int32, t int32) (r1 int32) {
	bp := tls.Alloc(560)
	defer tls.Free(560)
	var a, b, d, ebuf, estr, prefix, r, s, s1, s2, s3, s4, z, v10, v11, v13, v14, v15, v17, v18, v19, v20, v21, v24, v27, v28, v31, v32, v43, v44, v46, v48, v49, v5, v51, v54, v55, v56, v6 uintptr
	var carry, carry1, rm, x2 Tuint32_t
	var e, i, j, l, need, pl, re, sh, sh1, x, v12, v16, v22, v25, v42, v45, v52, v58, v7, v8, v9 int32
	var round, round1, small float64
	var x1 Tuint64_t
	var v1, v3 uint64
	var v36, v37, v38, v39, v40, v41, v57 int64
	var _ /* __u at bp+0 */ struct {
		F__i [0]uint64
		F__f float64
	}
	var _ /* big at bp+8 */ [126]Tuint32_t
	var _ /* buf at bp+516 */ [22]uint8
	var _ /* e2 at bp+512 */ int32
	var _ /* ebuf0 at bp+538 */ [12]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, b, carry, carry1, d, e, ebuf, estr, i, j, l, need, pl, prefix, r, re, rm, round, round1, s, s1, s2, s3, s4, sh, sh1, small, x, x1, x2, z, v1, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v24, v25, v27, v28, v3, v31, v32, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v48, v49, v5, v51, v52, v54, v55, v56, v57, v58, v6, v7, v8, v9
	*(*int32)(unsafe.Pointer(bp + 512)) = 0
	prefix = __ccgo_ts + 1586
	ebuf = bp + 538 + uintptr(Uint64FromInt32(3)*Uint64FromInt64(4))
	pl = int32(1)
	*(*float64)(unsafe.Pointer(bp)) = y
	v1 = *(*uint64)(unsafe.Pointer(bp))
	goto _2
_2:
	if int32(v1>>Int32FromInt32(63)) != 0 {
		y = -y
	} else {
		if uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))) != 0 {
			prefix += uintptr(3)
		} else {
			if uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))) != 0 {
				prefix += uintptr(6)
			} else {
				prefix++
				pl = Int32FromInt32(0)
			}
		}
	}
	*(*float64)(unsafe.Pointer(bp)) = y
	v3 = *(*uint64)(unsafe.Pointer(bp))
	goto _4
_4:
	if !(BoolInt32(v3&(-Uint64FromUint64(1)>>Int32FromInt32(1)) < Uint64FromUint64(0x7ff)<<Int32FromInt32(52)) != 0) {
		if t&int32(32) != 0 {
			v5 = __ccgo_ts + 1605
		} else {
			v5 = __ccgo_ts + 1609
		}
		s1 = v5
		if y != y {
			if t&int32(32) != 0 {
				v6 = __ccgo_ts + 256
			} else {
				v6 = __ccgo_ts + 1613
			}
			s1 = v6
		}
		_pad3(tls, f, uint8(' '), w, int32(3)+pl, int32(uint32(fl) & ^(Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' ')))))
		_out(tls, f, prefix, uint64(pl))
		_out(tls, f, s1, uint64(3))
		_pad3(tls, f, uint8(' '), w, int32(3)+pl, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
		if w > int32(3)+pl {
			v7 = w
		} else {
			v7 = int32(3) + pl
		}
		return v7
	}
	y = Xfrexpl(tls, y, bp+512) * Float64FromInt32(2)
	if y != 0 {
		*(*int32)(unsafe.Pointer(bp + 512))--
	}
	if t|int32(32) == int32('a') {
		round = Float64FromFloat64(8)
		if t&int32(32) != 0 {
			prefix += uintptr(9)
		}
		pl += int32(2)
		if p < 0 || p >= Int32FromInt32(LDBL_MANT_DIG)/Int32FromInt32(4)-Int32FromInt32(1) {
			re = 0
		} else {
			re = Int32FromInt32(LDBL_MANT_DIG)/Int32FromInt32(4) - Int32FromInt32(1) - p
		}
		if re != 0 {
			round *= float64(Int32FromInt32(1) << (Int32FromInt32(LDBL_MANT_DIG) % Int32FromInt32(4)))
			for {
				v8 = re
				re--
				if !(v8 != 0) {
					break
				}
				round *= Float64FromInt32(16)
			}
			if int32(*(*uint8)(unsafe.Pointer(prefix))) == int32('-') {
				y = -y
				y -= round
				y += round
				y = -y
			} else {
				y += round
				y -= round
			}
		}
		if *(*int32)(unsafe.Pointer(bp + 512)) < 0 {
			v9 = -*(*int32)(unsafe.Pointer(bp + 512))
		} else {
			v9 = *(*int32)(unsafe.Pointer(bp + 512))
		}
		estr = _fmt_u(tls, uint64(v9), ebuf)
		if estr == ebuf {
			estr--
			v10 = estr
			*(*uint8)(unsafe.Pointer(v10)) = uint8('0')
		}
		estr--
		v11 = estr
		if *(*int32)(unsafe.Pointer(bp + 512)) < 0 {
			v12 = int32('-')
		} else {
			v12 = int32('+')
		}
		*(*uint8)(unsafe.Pointer(v11)) = uint8(v12)
		estr--
		v13 = estr
		*(*uint8)(unsafe.Pointer(v13)) = uint8(t + (Int32FromUint8('p') - Int32FromUint8('a')))
		s = bp + 516
		for cond := true; cond; cond = y != 0 {
			x = int32(y)
			v14 = s
			s++
			*(*uint8)(unsafe.Pointer(v14)) = uint8(int32(_xdigits1[x]) | t&int32(32))
			y = Float64FromInt32(16) * (y - float64(x))
			if int64(s)-t__predefined_ptrdiff_t(bp+516) == int64(1) && (y != 0 || p > 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0) {
				v15 = s
				s++
				*(*uint8)(unsafe.Pointer(v15)) = uint8('.')
			}
		}
		if int64(p) > int64(Int32FromInt32(INT_MAX)-Int32FromInt32(2))-(int64(ebuf)-int64(estr))-int64(pl) {
			return -int32(1)
		}
		if p != 0 && int64(s)-t__predefined_ptrdiff_t(bp+516)-int64(2) < int64(p) {
			l = int32(int64(p+Int32FromInt32(2)) + (int64(ebuf) - int64(estr)))
		} else {
			l = int32(int64(s) - t__predefined_ptrdiff_t(bp+516) + (int64(ebuf) - int64(estr)))
		}
		_pad3(tls, f, uint8(' '), w, pl+l, fl)
		_out(tls, f, prefix, uint64(pl))
		_pad3(tls, f, uint8('0'), w, pl+l, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))))
		_out(tls, f, bp+516, uint64(int64(s)-t__predefined_ptrdiff_t(bp+516)))
		_pad3(tls, f, uint8('0'), int32(int64(l)-(int64(ebuf)-int64(estr))-(int64(s)-t__predefined_ptrdiff_t(bp+516))), 0, 0)
		_out(tls, f, estr, uint64(int64(ebuf)-int64(estr)))
		_pad3(tls, f, uint8(' '), w, pl+l, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
		if w > pl+l {
			v16 = w
		} else {
			v16 = pl + l
		}
		return v16
	}
	if p < 0 {
		p = int32(6)
	}
	if y != 0 {
		y *= Float64FromFloat64(2.68435456e+08)
		*(*int32)(unsafe.Pointer(bp + 512)) -= int32(28)
	}
	if *(*int32)(unsafe.Pointer(bp + 512)) < 0 {
		v18 = bp + 8
		z = v18
		v17 = v18
		r = v17
		a = v17
	} else {
		v20 = bp + 8 + uintptr(Uint64FromInt64(504)/Uint64FromInt64(4))*4 - UintptrFromInt32(LDBL_MANT_DIG)*4 - UintptrFromInt32(1)*4
		z = v20
		v19 = v20
		r = v19
		a = v19
	}
	for cond := true; cond; cond = y != 0 {
		*(*Tuint32_t)(unsafe.Pointer(z)) = uint32(y)
		v21 = z
		z += 4
		y = Float64FromInt32(1000000000) * (y - float64(*(*Tuint32_t)(unsafe.Pointer(v21))))
	}
	for *(*int32)(unsafe.Pointer(bp + 512)) > 0 {
		carry = uint32(0)
		if int32(29) < *(*int32)(unsafe.Pointer(bp + 512)) {
			v22 = int32(29)
		} else {
			v22 = *(*int32)(unsafe.Pointer(bp + 512))
		}
		sh = v22
		d = z - uintptr(1)*4
		for {
			if !(d >= a) {
				break
			}
			x1 = uint64(*(*Tuint32_t)(unsafe.Pointer(d)))<<sh + uint64(carry)
			*(*Tuint32_t)(unsafe.Pointer(d)) = uint32(x1 % uint64(1000000000))
			carry = uint32(x1 / uint64(1000000000))
			goto _23
		_23:
			;
			d -= 4
		}
		if carry != 0 {
			a -= 4
			v24 = a
			*(*Tuint32_t)(unsafe.Pointer(v24)) = carry
		}
		for z > a && !(*(*Tuint32_t)(unsafe.Pointer(z + uintptr(-Int32FromInt32(1))*4)) != 0) {
			z -= 4
		}
		*(*int32)(unsafe.Pointer(bp + 512)) -= sh
	}
	for *(*int32)(unsafe.Pointer(bp + 512)) < 0 {
		carry1 = uint32(0)
		if int32(9) < -*(*int32)(unsafe.Pointer(bp + 512)) {
			v25 = int32(9)
		} else {
			v25 = -*(*int32)(unsafe.Pointer(bp + 512))
		}
		sh1 = v25
		need = int32(uint32(1) + (uint32(p)+Uint32FromInt32(LDBL_MANT_DIG)/Uint32FromUint32(3)+uint32(8))/uint32(9))
		d = a
		for {
			if !(d < z) {
				break
			}
			rm = *(*Tuint32_t)(unsafe.Pointer(d)) & uint32(int32(1)<<sh1-int32(1))
			*(*Tuint32_t)(unsafe.Pointer(d)) = *(*Tuint32_t)(unsafe.Pointer(d))>>sh1 + carry1
			carry1 = uint32(Int32FromInt32(1000000000)>>sh1) * rm
			goto _26
		_26:
			;
			d += 4
		}
		if !(*(*Tuint32_t)(unsafe.Pointer(a)) != 0) {
			a += 4
		}
		if carry1 != 0 {
			v27 = z
			z += 4
			*(*Tuint32_t)(unsafe.Pointer(v27)) = carry1
		}
		/* Avoid (slow!) computation past requested precision */
		if t|int32(32) == int32('f') {
			v28 = r
		} else {
			v28 = a
		}
		b = v28
		if (int64(z)-int64(b))/4 > int64(need) {
			z = b + uintptr(need)*4
		}
		*(*int32)(unsafe.Pointer(bp + 512)) += sh1
	}
	if a < z {
		i = int32(10)
		e = int32(Int64FromInt32(9) * ((int64(r) - int64(a)) / 4))
		for {
			if !(*(*Tuint32_t)(unsafe.Pointer(a)) >= uint32(i)) {
				break
			}
			goto _29
		_29:
			;
			i *= int32(10)
			e++
		}
	} else {
		e = 0
	}
	/* Perform rounding: j is precision after the radix (possibly neg) */
	j = p - BoolInt32(t|int32(32) != int32('f'))*e - BoolInt32(t|int32(32) == int32('g') && p != 0)
	if int64(j) < int64(9)*((int64(z)-int64(r))/4-int64(1)) {
		/* We avoid C's broken division of negative numbers */
		d = r + uintptr(1)*4 + uintptr((j+Int32FromInt32(9)*Int32FromInt32(LDBL_MAX_EXP))/Int32FromInt32(9)-Int32FromInt32(LDBL_MAX_EXP))*4
		j += Int32FromInt32(9) * Int32FromInt32(LDBL_MAX_EXP)
		j %= int32(9)
		i = int32(10)
		j++
		for {
			if !(j < int32(9)) {
				break
			}
			goto _30
		_30:
			;
			i *= int32(10)
			j++
		}
		x2 = *(*Tuint32_t)(unsafe.Pointer(d)) % uint32(i)
		/* Are there any significant digits past j? */
		if x2 != 0 || d+uintptr(1)*4 != z {
			round1 = Float64FromInt32(2) / Float64FromFloat64(2.22044604925031308085e-16)
			if *(*Tuint32_t)(unsafe.Pointer(d))/uint32(i)&uint32(1) != 0 || i == int32(1000000000) && d > a && *(*Tuint32_t)(unsafe.Pointer(d + uintptr(-Int32FromInt32(1))*4))&uint32(1) != 0 {
				round1 += Float64FromInt32(2)
			}
			if x2 < uint32(i/int32(2)) {
				small = Float64FromFloat64(0.5)
			} else {
				if x2 == uint32(i/int32(2)) && d+uintptr(1)*4 == z {
					small = Float64FromFloat64(1)
				} else {
					small = Float64FromFloat64(1.5)
				}
			}
			if pl != 0 && int32(*(*uint8)(unsafe.Pointer(prefix))) == int32('-') {
				round1 *= float64(-Int32FromInt32(1))
				small *= float64(-Int32FromInt32(1))
			}
			*(*Tuint32_t)(unsafe.Pointer(d)) -= x2
			/* Decide whether to round by probing round+small */
			if round1+small != round1 {
				*(*Tuint32_t)(unsafe.Pointer(d)) = *(*Tuint32_t)(unsafe.Pointer(d)) + uint32(i)
				for *(*Tuint32_t)(unsafe.Pointer(d)) > uint32(999999999) {
					v31 = d
					d -= 4
					*(*Tuint32_t)(unsafe.Pointer(v31)) = uint32(0)
					if d < a {
						a -= 4
						v32 = a
						*(*Tuint32_t)(unsafe.Pointer(v32)) = uint32(0)
					}
					*(*Tuint32_t)(unsafe.Pointer(d))++
				}
				i = int32(10)
				e = int32(Int64FromInt32(9) * ((int64(r) - int64(a)) / 4))
				for {
					if !(*(*Tuint32_t)(unsafe.Pointer(a)) >= uint32(i)) {
						break
					}
					goto _33
				_33:
					;
					i *= int32(10)
					e++
				}
			}
		}
		if z > d+uintptr(1)*4 {
			z = d + uintptr(1)*4
		}
	}
	for {
		if !(z > a && !(*(*Tuint32_t)(unsafe.Pointer(z + uintptr(-Int32FromInt32(1))*4)) != 0)) {
			break
		}
		goto _34
	_34:
		;
		z -= 4
	}
	if t|int32(32) == int32('g') {
		if !(p != 0) {
			p++
		}
		if p > e && e >= -int32(4) {
			t--
			p -= e + int32(1)
		} else {
			t -= int32(2)
			p--
		}
		if !(uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0) {
			/* Count trailing zeros in last place */
			if z > a && *(*Tuint32_t)(unsafe.Pointer(z + uintptr(-Int32FromInt32(1))*4)) != 0 {
				i = int32(10)
				j = Int32FromInt32(0)
				for {
					if !(*(*Tuint32_t)(unsafe.Pointer(z + uintptr(-Int32FromInt32(1))*4))%uint32(i) == uint32(0)) {
						break
					}
					goto _35
				_35:
					;
					i *= int32(10)
					j++
				}
			} else {
				j = int32(9)
			}
			if t|int32(32) == int32('f') {
				if int64(Int32FromInt32(0)) > int64(9)*((int64(z)-int64(r))/4-int64(1))-int64(j) {
					v37 = int64(Int32FromInt32(0))
				} else {
					v37 = int64(9)*((int64(z)-int64(r))/4-int64(1)) - int64(j)
				}
				if int64(p) < v37 {
					v36 = int64(p)
				} else {
					if int64(Int32FromInt32(0)) > int64(9)*((int64(z)-int64(r))/4-int64(1))-int64(j) {
						v38 = int64(Int32FromInt32(0))
					} else {
						v38 = int64(9)*((int64(z)-int64(r))/4-int64(1)) - int64(j)
					}
					v36 = v38
				}
				p = int32(v36)
			} else {
				if int64(Int32FromInt32(0)) > int64(9)*((int64(z)-int64(r))/4-int64(1))+int64(e)-int64(j) {
					v40 = int64(Int32FromInt32(0))
				} else {
					v40 = int64(9)*((int64(z)-int64(r))/4-int64(1)) + int64(e) - int64(j)
				}
				if int64(p) < v40 {
					v39 = int64(p)
				} else {
					if int64(Int32FromInt32(0)) > int64(9)*((int64(z)-int64(r))/4-int64(1))+int64(e)-int64(j) {
						v41 = int64(Int32FromInt32(0))
					} else {
						v41 = int64(9)*((int64(z)-int64(r))/4-int64(1)) + int64(e) - int64(j)
					}
					v39 = v41
				}
				p = int32(v39)
			}
		}
	}
	if p > Int32FromInt32(INT_MAX)-Int32FromInt32(1)-BoolInt32(p != 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0) {
		return -int32(1)
	}
	l = int32(1) + p + BoolInt32(p != 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0)
	if t|int32(32) == int32('f') {
		if e > int32(INT_MAX)-l {
			return -int32(1)
		}
		if e > 0 {
			l += e
		}
	} else {
		if e < 0 {
			v42 = -e
		} else {
			v42 = e
		}
		estr = _fmt_u(tls, uint64(v42), ebuf)
		for int64(ebuf)-int64(estr) < int64(2) {
			estr--
			v43 = estr
			*(*uint8)(unsafe.Pointer(v43)) = uint8('0')
		}
		estr--
		v44 = estr
		if e < 0 {
			v45 = int32('-')
		} else {
			v45 = int32('+')
		}
		*(*uint8)(unsafe.Pointer(v44)) = uint8(v45)
		estr--
		v46 = estr
		*(*uint8)(unsafe.Pointer(v46)) = uint8(t)
		if int64(ebuf)-int64(estr) > int64(int32(INT_MAX)-l) {
			return -int32(1)
		}
		l = int32(int64(l) + (int64(ebuf) - int64(estr)))
	}
	if l > int32(INT_MAX)-pl {
		return -int32(1)
	}
	_pad3(tls, f, uint8(' '), w, pl+l, fl)
	_out(tls, f, prefix, uint64(pl))
	_pad3(tls, f, uint8('0'), w, pl+l, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))))
	if t|int32(32) == int32('f') {
		if a > r {
			a = r
		}
		d = a
		for {
			if !(d <= r) {
				break
			}
			s2 = _fmt_u(tls, uint64(*(*Tuint32_t)(unsafe.Pointer(d))), bp+516+uintptr(9))
			if d != a {
				for s2 > bp+516 {
					s2--
					v48 = s2
					*(*uint8)(unsafe.Pointer(v48)) = uint8('0')
				}
			} else {
				if s2 == bp+516+uintptr(9) {
					s2--
					v49 = s2
					*(*uint8)(unsafe.Pointer(v49)) = uint8('0')
				}
			}
			_out(tls, f, s2, uint64(int64(bp+516+uintptr(9))-int64(s2)))
			goto _47
		_47:
			;
			d += 4
		}
		if p != 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0 {
			_out(tls, f, __ccgo_ts+558, uint64(1))
		}
		for {
			if !(d < z && p > 0) {
				break
			}
			s3 = _fmt_u(tls, uint64(*(*Tuint32_t)(unsafe.Pointer(d))), bp+516+uintptr(9))
			for s3 > bp+516 {
				s3--
				v51 = s3
				*(*uint8)(unsafe.Pointer(v51)) = uint8('0')
			}
			if int32(9) < p {
				v52 = int32(9)
			} else {
				v52 = p
			}
			_out(tls, f, s3, uint64(v52))
			goto _50
		_50:
			;
			d += 4
			p -= int32(9)
		}
		_pad3(tls, f, uint8('0'), p+int32(9), int32(9), 0)
	} else {
		if z <= a {
			z = a + uintptr(1)*4
		}
		d = a
		for {
			if !(d < z && p >= 0) {
				break
			}
			s4 = _fmt_u(tls, uint64(*(*Tuint32_t)(unsafe.Pointer(d))), bp+516+uintptr(9))
			if s4 == bp+516+uintptr(9) {
				s4--
				v54 = s4
				*(*uint8)(unsafe.Pointer(v54)) = uint8('0')
			}
			if d != a {
				for s4 > bp+516 {
					s4--
					v55 = s4
					*(*uint8)(unsafe.Pointer(v55)) = uint8('0')
				}
			} else {
				v56 = s4
				s4++
				_out(tls, f, v56, uint64(1))
				if p > 0 || uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0 {
					_out(tls, f, __ccgo_ts+558, uint64(1))
				}
			}
			if int64(bp+516+UintptrFromInt32(9))-int64(s4) < int64(p) {
				v57 = int64(bp+516+UintptrFromInt32(9)) - int64(s4)
			} else {
				v57 = int64(p)
			}
			_out(tls, f, s4, uint64(v57))
			p = int32(int64(p) - (int64(bp+516+UintptrFromInt32(9)) - int64(s4)))
			goto _53
		_53:
			;
			d += 4
		}
		_pad3(tls, f, uint8('0'), p+int32(18), int32(18), 0)
		_out(tls, f, estr, uint64(int64(ebuf)-int64(estr)))
	}
	_pad3(tls, f, uint8(' '), w, pl+l, int32(uint32(fl)^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
	if w > pl+l {
		v58 = w
	} else {
		v58 = pl + l
	}
	return v58
}

func _getint(tls *TLS, s uintptr) (r int32) {
	var i int32
	_ = i
	i = 0
	for {
		if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-uint32('0') < uint32(10)) != 0) {
			break
		}
		if uint32(i) > Uint32FromInt32(INT_MAX)/Uint32FromUint32(10) || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))))-int32('0') > int32(INT_MAX)-int32(10)*i {
			i = -int32(1)
		} else {
			i = int32(10)*i + (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))) - int32('0'))
		}
		goto _1
	_1:
		;
		*(*uintptr)(unsafe.Pointer(s))++
	}
	return i
}

func _printf_core(tls *TLS, f uintptr, fmt uintptr, ap uintptr, nl_arg uintptr, nl_type uintptr) (r int32) {
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var a, prefix, ws, z, v35, v39, v44, v48, v8 uintptr
	var argpos, cnt, l, p, pl, t, w, xp, v36, v40, v42, v43, v47, v5, v50, v6, v7 int32
	var fl, l10n, ps, st uint32
	var i Tsize_t
	var v31 uint64
	var v34 int64
	var v45, v49 bool
	var _ /* arg at bp+8 */ Targ
	var _ /* buf at bp+16 */ [24]uint8
	var _ /* mb at bp+48 */ [4]uint8
	var _ /* s at bp+0 */ uintptr
	var _ /* wc at bp+40 */ [2]Twchar_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, argpos, cnt, fl, i, l, l10n, p, pl, prefix, ps, st, t, w, ws, xp, z, v31, v34, v35, v36, v39, v40, v42, v43, v44, v45, v47, v48, v49, v5, v50, v6, v7, v8
	*(*uintptr)(unsafe.Pointer(bp)) = fmt
	l10n = uint32(0)
	cnt = 0
	l = 0
	for {
		/* This error is only specified for snprintf, but since it's
		 * unspecified for other forms, do the same. Stop immediately
		 * on overflow; otherwise %n could produce wrong results. */
		if l > int32(INT_MAX)-cnt {
			goto overflow
		}
		/* Update output count, end loop when fmt is exhausted */
		cnt += l
		if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0) {
			break
		}
		/* Handle literal text and %% format specifiers */
		a = *(*uintptr)(unsafe.Pointer(bp))
		for {
			if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != int32('%')) {
				break
			}
			goto _2
		_2:
			;
			*(*uintptr)(unsafe.Pointer(bp))++
		}
		z = *(*uintptr)(unsafe.Pointer(bp))
		for {
			if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('%') && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1))) == int32('%')) {
				break
			}
			goto _3
		_3:
			;
			z++
			*(*uintptr)(unsafe.Pointer(bp)) += uintptr(2)
		}
		if int64(z)-int64(a) > int64(int32(INT_MAX)-cnt) {
			goto overflow
		}
		l = int32(int64(z) - int64(a))
		if f != 0 {
			_out(tls, f, a, uint64(l))
		}
		if l != 0 {
			goto _1
		}
		if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1)))-uint32('0') < uint32(10)) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2))) == int32('$') {
			l10n = uint32(1)
			argpos = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1))) - int32('0')
			*(*uintptr)(unsafe.Pointer(bp)) += uintptr(3)
		} else {
			argpos = -int32(1)
			*(*uintptr)(unsafe.Pointer(bp))++
		}
		/* Read modifier flags */
		fl = uint32(0)
		for {
			if !(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))-uint32(' ') < uint32(32) && (Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('\'')-Int32FromUint8(' ')))&(uint32(1)<<(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))-int32(' '))) != 0) {
				break
			}
			fl |= uint32(1) << (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) - int32(' '))
			goto _4
		_4:
			;
			*(*uintptr)(unsafe.Pointer(bp))++
		}
		/* Read field width */
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('*') {
			if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1)))-uint32('0') < uint32(10)) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2))) == int32('$') {
				l10n = uint32(1)
				if !(f != 0) {
					*(*int32)(unsafe.Pointer(nl_type + uintptr(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1)))-int32('0'))*4)) = int32(_INT)
					w = Int32FromInt32(0)
				} else {
					w = int32(*(*Tuintmax_t)(unsafe.Pointer(nl_arg + uintptr(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1)))-int32('0'))*8)))
				}
				*(*uintptr)(unsafe.Pointer(bp)) += uintptr(3)
			} else {
				if !(l10n != 0) {
					if f != 0 {
						v5 = VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))
					} else {
						v5 = 0
					}
					w = v5
					*(*uintptr)(unsafe.Pointer(bp))++
				} else {
					goto inval
				}
			}
			if w < 0 {
				fl |= Uint32FromUint32(1) << (Int32FromUint8('-') - Int32FromUint8(' '))
				w = -w
			}
		} else {
			v6 = _getint(tls, bp)
			w = v6
			if v6 < 0 {
				goto overflow
			}
		}
		/* Read precision */
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('.') && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 1))) == int32('*') {
			if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2)))-uint32('0') < uint32(10)) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 3))) == int32('$') {
				if !(f != 0) {
					*(*int32)(unsafe.Pointer(nl_type + uintptr(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2)))-int32('0'))*4)) = int32(_INT)
					p = Int32FromInt32(0)
				} else {
					p = int32(*(*Tuintmax_t)(unsafe.Pointer(nl_arg + uintptr(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 2)))-int32('0'))*8)))
				}
				*(*uintptr)(unsafe.Pointer(bp)) += uintptr(4)
			} else {
				if !(l10n != 0) {
					if f != 0 {
						v7 = VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))
					} else {
						v7 = 0
					}
					p = v7
					*(*uintptr)(unsafe.Pointer(bp)) += uintptr(2)
				} else {
					goto inval
				}
			}
			xp = BoolInt32(p >= 0)
		} else {
			if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == int32('.') {
				*(*uintptr)(unsafe.Pointer(bp))++
				p = _getint(tls, bp)
				xp = int32(1)
			} else {
				p = -int32(1)
				xp = 0
			}
		}
		/* Format specifier state machine */
		st = uint32(0)
		for cond := true; cond; cond = st-uint32(1) < uint32(_STOP) {
			if uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))))-uint32('A') > uint32(Int32FromUint8('z')-Int32FromUint8('A')) {
				goto inval
			}
			ps = st
			v8 = *(*uintptr)(unsafe.Pointer(bp))
			*(*uintptr)(unsafe.Pointer(bp))++
			st = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_states)) + uintptr(st)*58 + uintptr(int32(*(*uint8)(unsafe.Pointer(v8)))-int32('A')))))
		}
		if !(st != 0) {
			goto inval
		}
		/* Check validity of argument type (nl/normal) */
		if st == uint32(_NOARG) {
			if argpos >= 0 {
				goto inval
			}
		} else {
			if argpos >= 0 {
				if !(f != 0) {
					*(*int32)(unsafe.Pointer(nl_type + uintptr(argpos)*4)) = int32(st)
				} else {
					*(*Targ)(unsafe.Pointer(bp + 8)) = *(*Targ)(unsafe.Pointer(nl_arg + uintptr(argpos)*8))
				}
			} else {
				if f != 0 {
					_pop_arg(tls, bp+8, int32(st), ap)
				} else {
					return 0
				}
			}
		}
		if !(f != 0) {
			goto _1
		}
		/* Do not process any new directives once in error state. */
		if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_ERR) != 0 {
			return -int32(1)
		}
		z = bp + 16 + uintptr(24)
		prefix = __ccgo_ts + 1617
		pl = 0
		t = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + uintptr(-Int32FromInt32(1)))))
		/* Transform ls,lc -> S,C */
		if ps != 0 && t&int32(15) == int32(3) {
			t &= ^Int32FromInt32(32)
		}
		/* - and 0 flags are mutually exclusive */
		if fl&(Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))) != 0 {
			fl &= ^(Uint32FromUint32(1) << (Int32FromUint8('0') - Int32FromUint8(' ')))
		}
		switch t {
		case int32('n'):
			goto _9
		case int32('p'):
			goto _10
		case int32('X'):
			goto _11
		case int32('x'):
			goto _12
		case int32('o'):
			goto _13
		case int32('i'):
			goto _14
		case int32('d'):
			goto _15
		case int32('u'):
			goto _16
		case int32('c'):
			goto _17
		case int32('s'):
			goto _18
		case int32('m'):
			goto _19
		case int32('C'):
			goto _20
		case int32('S'):
			goto _21
		case int32('A'):
			goto _22
		case int32('G'):
			goto _23
		case int32('F'):
			goto _24
		case int32('E'):
			goto _25
		case int32('a'):
			goto _26
		case int32('g'):
			goto _27
		case int32('f'):
			goto _28
		case int32('e'):
			goto _29
		}
		goto _30
	_9:
		;
		switch ps {
		case uint32(_BARE):
			*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = cnt
		case uint32(_LPRE):
			*(*int64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = int64(cnt)
		case uint32(_LLPRE):
			*(*int64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = int64(cnt)
		case uint32(_HPRE):
			*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = uint16(cnt)
		case uint32(_HHPRE):
			*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = uint8(cnt)
		case uint32(_ZTPRE):
			*(*Tsize_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = uint64(cnt)
		case uint32(_JPRE):
			*(*Tuintmax_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) = uint64(cnt)
			break
		}
		goto _1
	_10:
		;
		if uint64(p) > Uint64FromInt32(2)*Uint64FromInt64(8) {
			v31 = uint64(p)
		} else {
			v31 = Uint64FromInt32(2) * Uint64FromInt64(8)
		}
		p = int32(v31)
		t = int32('x')
		fl |= Uint32FromUint32(1) << (Int32FromUint8('#') - Int32FromUint8(' '))
	_12:
		;
	_11:
		;
		a = _fmt_x(tls, *(*Tuintmax_t)(unsafe.Pointer(bp + 8)), z, t&int32(32))
		if *(*Tuintmax_t)(unsafe.Pointer(bp + 8)) != 0 && fl&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0 {
			prefix += uintptr(t >> Int32FromInt32(4))
			pl = Int32FromInt32(2)
		}
		if !(0 != 0) {
			goto _32
		}
	_13:
		;
		a = _fmt_o(tls, *(*Tuintmax_t)(unsafe.Pointer(bp + 8)), z)
		if fl&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0 && int64(p) < int64(z)-int64(a)+int64(1) {
			p = int32(int64(z) - int64(a) + int64(1))
		}
	_32:
		;
		if !(0 != 0) {
			goto _33
		}
	_15:
		;
	_14:
		;
		pl = int32(1)
		if *(*Tuintmax_t)(unsafe.Pointer(bp + 8)) > uint64(Int64FromInt64(INT64_MAX)) {
			*(*Tuintmax_t)(unsafe.Pointer(bp + 8)) = -*(*Tuintmax_t)(unsafe.Pointer(bp + 8))
		} else {
			if fl&(Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))) != 0 {
				prefix++
			} else {
				if fl&(Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))) != 0 {
					prefix += uintptr(2)
				} else {
					pl = 0
				}
			}
		}
	_16:
		;
		a = _fmt_u(tls, *(*Tuintmax_t)(unsafe.Pointer(bp + 8)), z)
	_33:
		;
		if xp != 0 && p < 0 {
			goto overflow
		}
		if xp != 0 {
			fl &= ^(Uint32FromUint32(1) << (Int32FromUint8('0') - Int32FromUint8(' ')))
		}
		if !(*(*Tuintmax_t)(unsafe.Pointer(bp + 8)) != 0) && !(p != 0) {
			a = z
			goto _30
		}
		if int64(p) > int64(z)-int64(a)+BoolInt64(!(*(*Tuintmax_t)(unsafe.Pointer(bp + 8)) != 0)) {
			v34 = int64(p)
		} else {
			v34 = int64(z) - int64(a) + BoolInt64(!(*(*Tuintmax_t)(unsafe.Pointer(bp + 8)) != 0))
		}
		p = int32(v34)
		goto _30
		goto narrow_c
	narrow_c:
		;
	_17:
		;
		v36 = Int32FromInt32(1)
		p = v36
		v35 = z - uintptr(v36)
		a = v35
		*(*uint8)(unsafe.Pointer(v35)) = uint8(*(*Tuintmax_t)(unsafe.Pointer(bp + 8)))
		fl &= ^(Uint32FromUint32(1) << (Int32FromUint8('0') - Int32FromUint8(' ')))
		goto _30
	_19:
		;
		if !(int32(1) != 0) {
			goto _37
		}
		a = Xstrerror(tls, *(*int32)(unsafe.Pointer(X__errno_location(tls))))
		goto _38
	_37:
		;
	_18:
		;
		if *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 {
			v39 = *(*uintptr)(unsafe.Pointer(bp + 8))
		} else {
			v39 = __ccgo_ts + 1627
		}
		a = v39
	_38:
		;
		if p < 0 {
			v40 = int32(INT_MAX)
		} else {
			v40 = p
		}
		z = a + uintptr(Xstrnlen(tls, a, uint64(v40)))
		if p < 0 && *(*uint8)(unsafe.Pointer(z)) != 0 {
			goto overflow
		}
		p = int32(int64(z) - int64(a))
		fl &= ^(Uint32FromUint32(1) << (Int32FromUint8('0') - Int32FromUint8(' ')))
		goto _30
	_20:
		;
		if !(*(*Tuintmax_t)(unsafe.Pointer(bp + 8)) != 0) {
			goto narrow_c
		}
		(*(*[2]Twchar_t)(unsafe.Pointer(bp + 40)))[0] = uint32(*(*Tuintmax_t)(unsafe.Pointer(bp + 8)))
		(*(*[2]Twchar_t)(unsafe.Pointer(bp + 40)))[int32(1)] = uint32(0)
		*(*uintptr)(unsafe.Pointer(bp + 8)) = bp + 40
		p = -int32(1)
	_21:
		;
		ws = *(*uintptr)(unsafe.Pointer(bp + 8))
		v42 = Int32FromInt32(0)
		l = v42
		i = uint64(v42)
		for {
			if v45 = i < uint64(p) && *(*Twchar_t)(unsafe.Pointer(ws)) != 0; v45 {
				v44 = ws
				ws += 4
				v43 = Xwctomb(tls, bp+48, *(*Twchar_t)(unsafe.Pointer(v44)))
				l = v43
			}
			if !(v45 && v43 >= 0 && uint64(l) <= uint64(p)-i) {
				break
			}
			goto _41
		_41:
			;
			i += uint64(l)
		}
		if l < 0 {
			return -int32(1)
		}
		if i > uint64(INT_MAX) {
			goto overflow
		}
		p = int32(i)
		_pad3(tls, f, uint8(' '), w, p, int32(fl))
		ws = *(*uintptr)(unsafe.Pointer(bp + 8))
		i = uint64(0)
		for {
			if v49 = i < uint64(0+uint32(p)) && *(*Twchar_t)(unsafe.Pointer(ws)) != 0; v49 {
				v48 = ws
				ws += 4
				v47 = Xwctomb(tls, bp+48, *(*Twchar_t)(unsafe.Pointer(v48)))
				l = v47
			}
			if !(v49 && i+uint64(v47) <= uint64(p)) {
				break
			}
			_out(tls, f, bp+48, uint64(l))
			goto _46
		_46:
			;
			i += uint64(l)
		}
		_pad3(tls, f, uint8(' '), w, p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
		if w > p {
			v50 = w
		} else {
			v50 = p
		}
		l = v50
		goto _1
	_29:
		;
	_28:
		;
	_27:
		;
	_26:
		;
	_25:
		;
	_24:
		;
	_23:
		;
	_22:
		;
		if xp != 0 && p < 0 {
			goto overflow
		}
		l = _fmt_fp(tls, f, *(*float64)(unsafe.Pointer(bp + 8)), w, p, int32(fl), t)
		if l < 0 {
			goto overflow
		}
		goto _1
	_30:
		;
		if int64(p) < int64(z)-int64(a) {
			p = int32(int64(z) - int64(a))
		}
		if p > int32(INT_MAX)-pl {
			goto overflow
		}
		if w < pl+p {
			w = pl + p
		}
		if w > int32(INT_MAX)-cnt {
			goto overflow
		}
		_pad3(tls, f, uint8(' '), w, pl+p, int32(fl))
		_out(tls, f, prefix, uint64(pl))
		_pad3(tls, f, uint8('0'), w, pl+p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))))
		_pad3(tls, f, uint8('0'), p, int32(int64(z)-int64(a)), 0)
		_out(tls, f, a, uint64(int64(z)-int64(a)))
		_pad3(tls, f, uint8(' '), w, pl+p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
		l = w
		goto _1
	_1:
	}
	if f != 0 {
		return cnt
	}
	if !(l10n != 0) {
		return 0
	}
	i = uint64(1)
	for {
		if !(i <= uint64(NL_ARGMAX) && *(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)) != 0) {
			break
		}
		_pop_arg(tls, nl_arg+uintptr(i)*8, *(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)), ap)
		goto _51
	_51:
		;
		i++
	}
	for {
		if !(i <= uint64(NL_ARGMAX) && !(*(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)) != 0)) {
			break
		}
		goto _52
	_52:
		;
		i++
	}
	if i <= uint64(NL_ARGMAX) {
		goto inval
	}
	return int32(1)
	goto inval
inval:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
	return -int32(1)
	goto overflow
overflow:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOVERFLOW)
	return -int32(1)
}

func Xvfprintf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v ap=%v, (%v:)", tls, f, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(208)
	defer tls.Free(208)
	var __need_unlock, olderr, ret, v1 int32
	var saved_buf, v2, v3, v4, v5 uintptr
	var _ /* ap2 at bp+0 */ Tva_list
	var _ /* internal_buf at bp+128 */ [80]uint8
	var _ /* nl_arg at bp+48 */ [10]Targ
	var _ /* nl_type at bp+8 */ [10]int32
	_, _, _, _, _, _, _, _, _ = __need_unlock, olderr, ret, saved_buf, v1, v2, v3, v4, v5
	*(*[10]int32)(unsafe.Pointer(bp + 8)) = [10]int32{}
	saved_buf = uintptr(0)
	/* the copy allows passing va_list* even if va_list is an array */
	*(*Tva_list)(unsafe.Pointer(bp)) = ap
	if _printf_core(tls, uintptr(0), fmt, bp, bp+48, bp+8) < 0 {
		_ = *(*Tva_list)(unsafe.Pointer(bp))
		return -int32(1)
	}
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	olderr = int32((*TFILE)(unsafe.Pointer(f)).Fflags & uint32(F_ERR))
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(F_ERR))
	if !((*TFILE)(unsafe.Pointer(f)).Fbuf_size != 0) {
		saved_buf = (*TFILE)(unsafe.Pointer(f)).Fbuf
		(*TFILE)(unsafe.Pointer(f)).Fbuf = bp + 128
		(*TFILE)(unsafe.Pointer(f)).Fbuf_size = uint64(80)
		v3 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Fwend = v3
		v2 = v3
		(*TFILE)(unsafe.Pointer(f)).Fwbase = v2
		(*TFILE)(unsafe.Pointer(f)).Fwpos = v2
	}
	if !((*TFILE)(unsafe.Pointer(f)).Fwend != 0) && X__towrite(tls, f) != 0 {
		ret = -int32(1)
	} else {
		ret = _printf_core(tls, f, fmt, bp, bp+48, bp+8)
	}
	if saved_buf != 0 {
		(*(*func(*TLS, uintptr, uintptr, Tsize_t) Tsize_t)(unsafe.Pointer(&struct{ uintptr }{(*TFILE)(unsafe.Pointer(f)).Fwrite})))(tls, f, uintptr(0), uint64(0))
		if !((*TFILE)(unsafe.Pointer(f)).Fwpos != 0) {
			ret = -int32(1)
		}
		(*TFILE)(unsafe.Pointer(f)).Fbuf = saved_buf
		(*TFILE)(unsafe.Pointer(f)).Fbuf_size = uint64(0)
		v5 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Fwend = v5
		v4 = v5
		(*TFILE)(unsafe.Pointer(f)).Fwbase = v4
		(*TFILE)(unsafe.Pointer(f)).Fwpos = v4
	}
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_ERR) != 0 {
		ret = -int32(1)
	}
	*(*uint32)(unsafe.Pointer(f)) |= uint32(olderr)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	_ = *(*Tva_list)(unsafe.Pointer(bp))
	return ret
}

const SIZE_L = 2
const SIZE_def = 0
const SIZE_h = -1
const SIZE_hh = -2
const SIZE_l = 1
const SIZE_ll = 3

func _store_int(tls *TLS, dest uintptr, size int32, i uint64) {
	if !(dest != 0) {
		return
	}
	switch size {
	case -int32(2):
		*(*uint8)(unsafe.Pointer(dest)) = uint8(i)
	case -int32(1):
		*(*int16)(unsafe.Pointer(dest)) = int16(i)
	case SIZE_def:
		*(*int32)(unsafe.Pointer(dest)) = int32(i)
	case int32(SIZE_l):
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
	case int32(SIZE_ll):
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
		break
	}
}

func _arg_n(tls *TLS, ap Tva_list, n uint32) (r uintptr) {
	var ap2 Tva_list
	var i uint32
	var p uintptr
	_, _, _ = ap2, i, p
	ap2 = ap
	i = n
	for {
		if !(i > uint32(1)) {
			break
		}
		_ = VaUintptr(&ap2)
		goto _1
	_1:
		;
		i--
	}
	p = VaUintptr(&ap2)
	_ = ap2
	return p
}

func Xvfscanf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v ap=%v, (%v:)", tls, f, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(288)
	defer tls.Free(288)
	var __need_unlock, alloc, base, c, invert, matches, size, t, width, v1, v12, v13, v16, v17, v20, v21, v23, v29, v3, v32, v33, v36, v4, v6, v64, v65, v69, v7, v70, v75, v76, v80, v81, v9 int32
	var dest, p, s, tmp, tmp1, wcs, v10, v11, v18, v19, v24, v25, v28, v30, v31, v37, v38, v59, v62, v66, v67, v71, v72, v74, v77, v78, v82, v83 uintptr
	var i, k, v68, v73, v79 Tsize_t
	var pos Toff_t
	var x uint64
	var y float64
	var v63 uint32
	var _ /* scanset at bp+16 */ [257]uint8
	var _ /* st at bp+8 */ Tmbstate_t
	var _ /* wc at bp+276 */ Twchar_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __need_unlock, alloc, base, c, dest, i, invert, k, matches, p, pos, s, size, t, tmp, tmp1, wcs, width, x, y, v1, v10, v11, v12, v13, v16, v17, v18, v19, v20, v21, v23, v24, v25, v28, v29, v3, v30, v31, v32, v33, v36, v37, v38, v4, v59, v6, v62, v63, v64, v65, v66, v67, v68, v69, v7, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v9
	alloc = 0
	dest = UintptrFromInt32(0)
	matches = 0
	pos = 0
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		X__toread(tls, f)
	}
	if !((*TFILE)(unsafe.Pointer(f)).Frpos != 0) {
		goto input_fail
	}
	p = fmt
	for {
		if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			break
		}
		alloc = 0
		v3 = int32(*(*uint8)(unsafe.Pointer(p)))
		v4 = BoolInt32(v3 == int32(' ') || uint32(v3)-uint32('\t') < uint32(5))
		goto _5
	_5:
		if v4 != 0 {
			for {
				v6 = int32(*(*uint8)(unsafe.Pointer(p + 1)))
				v7 = BoolInt32(v6 == int32(' ') || uint32(v6)-uint32('\t') < uint32(5))
				goto _8
			_8:
				if !(v7 != 0) {
					break
				}
				p++
			}
			X__shlim(tls, f, int64(Int32FromInt32(0)))
			for {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v11 = f + 8
					v10 = *(*uintptr)(unsafe.Pointer(v11))
					*(*uintptr)(unsafe.Pointer(v11))++
					v9 = int32(*(*uint8)(unsafe.Pointer(v10)))
				} else {
					v9 = X__shgetc(tls, f)
				}
				v12 = v9
				v13 = BoolInt32(v12 == int32(' ') || uint32(v12)-uint32('\t') < uint32(5))
				goto _14
			_14:
				if !(v13 != 0) {
					break
				}
			}
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
			pos += (*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf))
			goto _2
		}
		if int32(*(*uint8)(unsafe.Pointer(p))) != int32('%') || int32(*(*uint8)(unsafe.Pointer(p + 1))) == int32('%') {
			X__shlim(tls, f, int64(Int32FromInt32(0)))
			if int32(*(*uint8)(unsafe.Pointer(p))) == int32('%') {
				p++
				for {
					if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
						v19 = f + 8
						v18 = *(*uintptr)(unsafe.Pointer(v19))
						*(*uintptr)(unsafe.Pointer(v19))++
						v17 = int32(*(*uint8)(unsafe.Pointer(v18)))
					} else {
						v17 = X__shgetc(tls, f)
					}
					v16 = v17
					c = v16
					v20 = v16
					v21 = BoolInt32(v20 == int32(' ') || uint32(v20)-uint32('\t') < uint32(5))
					goto _22
				_22:
					if !(v21 != 0) {
						break
					}
				}
			} else {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v25 = f + 8
					v24 = *(*uintptr)(unsafe.Pointer(v25))
					*(*uintptr)(unsafe.Pointer(v25))++
					v23 = int32(*(*uint8)(unsafe.Pointer(v24)))
				} else {
					v23 = X__shgetc(tls, f)
				}
				c = v23
			}
			if c != int32(*(*uint8)(unsafe.Pointer(p))) {
				if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
					(*TFILE)(unsafe.Pointer(f)).Frpos--
				}
				if c < 0 {
					goto input_fail
				}
				goto match_fail
			}
			pos += (*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf))
			goto _2
		}
		p++
		if int32(*(*uint8)(unsafe.Pointer(p))) == int32('*') {
			dest = uintptr(0)
			p++
		} else {
			if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(p)))-uint32('0') < uint32(10)) != 0 && int32(*(*uint8)(unsafe.Pointer(p + 1))) == int32('$') {
				dest = _arg_n(tls, ap, uint32(int32(*(*uint8)(unsafe.Pointer(p)))-int32('0')))
				p += uintptr(2)
			} else {
				dest = VaUintptr(&ap)
			}
		}
		width = 0
		for {
			if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(p)))-uint32('0') < uint32(10)) != 0) {
				break
			}
			width = int32(10)*width + int32(*(*uint8)(unsafe.Pointer(p))) - int32('0')
			goto _27
		_27:
			;
			p++
		}
		if int32(*(*uint8)(unsafe.Pointer(p))) == int32('m') {
			wcs = uintptr(0)
			s = uintptr(0)
			alloc = BoolInt32(!!(dest != 0))
			p++
		} else {
			alloc = 0
		}
		size = SIZE_def
		v28 = p
		p++
		switch int32(*(*uint8)(unsafe.Pointer(v28))) {
		case int32('h'):
			if int32(*(*uint8)(unsafe.Pointer(p))) == int32('h') {
				p++
				size = -Int32FromInt32(2)
			} else {
				size = -int32(1)
			}
		case int32('l'):
			if int32(*(*uint8)(unsafe.Pointer(p))) == int32('l') {
				p++
				size = Int32FromInt32(SIZE_ll)
			} else {
				size = int32(SIZE_l)
			}
		case int32('j'):
			size = int32(SIZE_ll)
		case int32('z'):
			fallthrough
		case int32('t'):
			size = int32(SIZE_l)
		case int32('L'):
			size = int32(SIZE_L)
		case int32('d'):
			fallthrough
		case int32('i'):
			fallthrough
		case int32('o'):
			fallthrough
		case int32('u'):
			fallthrough
		case int32('x'):
			fallthrough
		case int32('a'):
			fallthrough
		case int32('e'):
			fallthrough
		case int32('f'):
			fallthrough
		case int32('g'):
			fallthrough
		case int32('A'):
			fallthrough
		case int32('E'):
			fallthrough
		case int32('F'):
			fallthrough
		case int32('G'):
			fallthrough
		case int32('X'):
			fallthrough
		case int32('s'):
			fallthrough
		case int32('c'):
			fallthrough
		case int32('['):
			fallthrough
		case int32('S'):
			fallthrough
		case int32('C'):
			fallthrough
		case int32('p'):
			fallthrough
		case int32('n'):
			p--
		default:
			goto fmt_fail
		}
		t = int32(*(*uint8)(unsafe.Pointer(p)))
		/* C or S */
		if t&int32(0x2f) == int32(3) {
			t |= int32(32)
			size = int32(SIZE_l)
		}
		switch t {
		case int32('c'):
			if width < int32(1) {
				width = int32(1)
			}
			fallthrough
		case int32('['):
		case int32('n'):
			_store_int(tls, dest, size, uint64(pos))
			/* do not increment match count, etc! */
			goto _2
		default:
			X__shlim(tls, f, int64(Int32FromInt32(0)))
			for {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v31 = f + 8
					v30 = *(*uintptr)(unsafe.Pointer(v31))
					*(*uintptr)(unsafe.Pointer(v31))++
					v29 = int32(*(*uint8)(unsafe.Pointer(v30)))
				} else {
					v29 = X__shgetc(tls, f)
				}
				v32 = v29
				v33 = BoolInt32(v32 == int32(' ') || uint32(v32)-uint32('\t') < uint32(5))
				goto _34
			_34:
				if !(v33 != 0) {
					break
				}
			}
			if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
				(*TFILE)(unsafe.Pointer(f)).Frpos--
			}
			pos += (*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf))
		}
		X__shlim(tls, f, int64(width))
		if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
			v38 = f + 8
			v37 = *(*uintptr)(unsafe.Pointer(v38))
			*(*uintptr)(unsafe.Pointer(v38))++
			v36 = int32(*(*uint8)(unsafe.Pointer(v37)))
		} else {
			v36 = X__shgetc(tls, f)
		}
		if v36 < 0 {
			goto input_fail
		}
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		}
		switch t {
		case int32('['):
			goto _40
		case int32('c'):
			goto _41
		case int32('s'):
			goto _42
		case int32('x'):
			goto _43
		case int32('X'):
			goto _44
		case int32('p'):
			goto _45
		case int32('o'):
			goto _46
		case int32('u'):
			goto _47
		case int32('d'):
			goto _48
		case int32('i'):
			goto _49
		case int32('G'):
			goto _50
		case int32('g'):
			goto _51
		case int32('F'):
			goto _52
		case int32('f'):
			goto _53
		case int32('E'):
			goto _54
		case int32('e'):
			goto _55
		case int32('A'):
			goto _56
		case int32('a'):
			goto _57
		}
		goto _58
	_42:
		;
	_41:
		;
	_40:
		;
		if t == int32('c') || t == int32('s') {
			Xmemset(tls, bp+16, -int32(1), uint64(257))
			(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[0] = uint8(0)
			if t == int32('s') {
				(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[Int32FromInt32(1)+Int32FromUint8('\t')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[Int32FromInt32(1)+Int32FromUint8('\n')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[Int32FromInt32(1)+Int32FromUint8('\v')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[Int32FromInt32(1)+Int32FromUint8('\f')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[Int32FromInt32(1)+Int32FromUint8('\r')] = uint8(0)
				(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[Int32FromInt32(1)+Int32FromUint8(' ')] = uint8(0)
			}
		} else {
			p++
			v59 = p
			if int32(*(*uint8)(unsafe.Pointer(v59))) == int32('^') {
				p++
				invert = Int32FromInt32(1)
			} else {
				invert = 0
			}
			Xmemset(tls, bp+16, invert, uint64(257))
			(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[0] = uint8(0)
			if int32(*(*uint8)(unsafe.Pointer(p))) == int32('-') {
				p++
				(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[Int32FromInt32(1)+Int32FromUint8('-')] = uint8(Int32FromInt32(1) - invert)
			} else {
				if int32(*(*uint8)(unsafe.Pointer(p))) == int32(']') {
					p++
					(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[Int32FromInt32(1)+Int32FromUint8(']')] = uint8(Int32FromInt32(1) - invert)
				}
			}
			for {
				if !(int32(*(*uint8)(unsafe.Pointer(p))) != int32(']')) {
					break
				}
				if !(*(*uint8)(unsafe.Pointer(p)) != 0) {
					goto fmt_fail
				}
				if int32(*(*uint8)(unsafe.Pointer(p))) == int32('-') && *(*uint8)(unsafe.Pointer(p + 1)) != 0 && int32(*(*uint8)(unsafe.Pointer(p + 1))) != int32(']') {
					v62 = p
					p++
					c = int32(*(*uint8)(unsafe.Pointer(v62 + uintptr(-Int32FromInt32(1)))))
					for {
						if !(c < int32(*(*uint8)(unsafe.Pointer(p)))) {
							break
						}
						(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[int32(1)+c] = uint8(int32(1) - invert)
						goto _61
					_61:
						;
						c++
					}
				}
				(*(*[257]uint8)(unsafe.Pointer(bp + 16)))[int32(1)+int32(*(*uint8)(unsafe.Pointer(p)))] = uint8(int32(1) - invert)
				goto _60
			_60:
				;
				p++
			}
		}
		wcs = uintptr(0)
		s = uintptr(0)
		i = uint64(0)
		if t == int32('c') {
			v63 = uint32(width) + uint32(1)
		} else {
			v63 = uint32(31)
		}
		k = uint64(v63)
		if size == int32(SIZE_l) {
			if alloc != 0 {
				wcs = Xmalloc(tls, k*uint64(4))
				if !(wcs != 0) {
					goto alloc_fail
				}
			} else {
				wcs = dest
			}
			*(*Tmbstate_t)(unsafe.Pointer(bp + 8)) = Tmbstate_t{}
			for {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
					v67 = f + 8
					v66 = *(*uintptr)(unsafe.Pointer(v67))
					*(*uintptr)(unsafe.Pointer(v67))++
					v65 = int32(*(*uint8)(unsafe.Pointer(v66)))
				} else {
					v65 = X__shgetc(tls, f)
				}
				v64 = v65
				c = v64
				if !((*(*[257]uint8)(unsafe.Pointer(bp + 16)))[v64+int32(1)] != 0) {
					break
				}
				*(*uint8)(unsafe.Pointer(bp)) = uint8(c)
				switch Xmbrtowc(tls, bp+276, bp, uint64(1), bp+8) {
				case uint64(-Int32FromInt32(1)):
					goto input_fail
				case uint64(-Int32FromInt32(2)):
					continue
				}
				if wcs != 0 {
					v68 = i
					i++
					*(*Twchar_t)(unsafe.Pointer(wcs + uintptr(v68)*4)) = *(*Twchar_t)(unsafe.Pointer(bp + 276))
				}
				if alloc != 0 && i == k {
					k += k + uint64(1)
					tmp = Xrealloc(tls, wcs, k*uint64(4))
					if !(tmp != 0) {
						goto alloc_fail
					}
					wcs = tmp
				}
			}
			if !(Xmbsinit(tls, bp+8) != 0) {
				goto input_fail
			}
		} else {
			if alloc != 0 {
				s = Xmalloc(tls, k)
				if !(s != 0) {
					goto alloc_fail
				}
				for {
					if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
						v72 = f + 8
						v71 = *(*uintptr)(unsafe.Pointer(v72))
						*(*uintptr)(unsafe.Pointer(v72))++
						v70 = int32(*(*uint8)(unsafe.Pointer(v71)))
					} else {
						v70 = X__shgetc(tls, f)
					}
					v69 = v70
					c = v69
					if !((*(*[257]uint8)(unsafe.Pointer(bp + 16)))[v69+int32(1)] != 0) {
						break
					}
					v73 = i
					i++
					*(*uint8)(unsafe.Pointer(s + uintptr(v73))) = uint8(c)
					if i == k {
						k += k + uint64(1)
						tmp1 = Xrealloc(tls, s, k)
						if !(tmp1 != 0) {
							goto alloc_fail
						}
						s = tmp1
					}
				}
			} else {
				v74 = dest
				s = v74
				if v74 != 0 {
					for {
						if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
							v78 = f + 8
							v77 = *(*uintptr)(unsafe.Pointer(v78))
							*(*uintptr)(unsafe.Pointer(v78))++
							v76 = int32(*(*uint8)(unsafe.Pointer(v77)))
						} else {
							v76 = X__shgetc(tls, f)
						}
						v75 = v76
						c = v75
						if !((*(*[257]uint8)(unsafe.Pointer(bp + 16)))[v75+int32(1)] != 0) {
							break
						}
						v79 = i
						i++
						*(*uint8)(unsafe.Pointer(s + uintptr(v79))) = uint8(c)
					}
				} else {
					for {
						if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Fshend {
							v83 = f + 8
							v82 = *(*uintptr)(unsafe.Pointer(v83))
							*(*uintptr)(unsafe.Pointer(v83))++
							v81 = int32(*(*uint8)(unsafe.Pointer(v82)))
						} else {
							v81 = X__shgetc(tls, f)
						}
						v80 = v81
						c = v80
						if !((*(*[257]uint8)(unsafe.Pointer(bp + 16)))[v80+int32(1)] != 0) {
							break
						}
					}
				}
			}
		}
		if (*TFILE)(unsafe.Pointer(f)).Fshlim >= 0 {
			(*TFILE)(unsafe.Pointer(f)).Frpos--
		}
		if !((*TFILE)(unsafe.Pointer(f)).Fshcnt+(int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Fbuf)) != 0) {
			goto match_fail
		}
		if t == int32('c') && (*TFILE)(unsafe.Pointer(f)).Fshcnt+(int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Fbuf)) != int64(width) {
			goto match_fail
		}
		if alloc != 0 {
			if size == int32(SIZE_l) {
				*(*uintptr)(unsafe.Pointer(dest)) = wcs
			} else {
				*(*uintptr)(unsafe.Pointer(dest)) = s
			}
		}
		if t != int32('c') {
			if wcs != 0 {
				*(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) = uint32(0)
			}
			if s != 0 {
				*(*uint8)(unsafe.Pointer(s + uintptr(i))) = uint8(0)
			}
		}
		goto _58
	_45:
		;
	_44:
		;
	_43:
		;
		base = int32(16)
		goto int_common
	_46:
		;
		base = int32(8)
		goto int_common
	_48:
		;
	_47:
		;
		base = int32(10)
		goto int_common
	_49:
		;
		base = 0
		goto int_common
	int_common:
		;
		x = X__intscan(tls, f, uint32(base), 0, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
		if !((*TFILE)(unsafe.Pointer(f)).Fshcnt+(int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Fbuf)) != 0) {
			goto match_fail
		}
		if t == int32('p') && dest != 0 {
			*(*uintptr)(unsafe.Pointer(dest)) = uintptr(x)
		} else {
			_store_int(tls, dest, size, x)
		}
		goto _58
	_57:
		;
	_56:
		;
	_55:
		;
	_54:
		;
	_53:
		;
	_52:
		;
	_51:
		;
	_50:
		;
		y = X__floatscan(tls, f, size, 0)
		if !((*TFILE)(unsafe.Pointer(f)).Fshcnt+(int64((*TFILE)(unsafe.Pointer(f)).Frpos)-int64((*TFILE)(unsafe.Pointer(f)).Fbuf)) != 0) {
			goto match_fail
		}
		if dest != 0 {
			switch size {
			case SIZE_def:
				*(*float32)(unsafe.Pointer(dest)) = float32(y)
			case int32(SIZE_l):
				*(*float64)(unsafe.Pointer(dest)) = y
			case int32(SIZE_L):
				*(*float64)(unsafe.Pointer(dest)) = y
				break
			}
		}
		goto _58
	_58:
		;
		pos += (*TFILE)(unsafe.Pointer(f)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(f)).Frpos) - int64((*TFILE)(unsafe.Pointer(f)).Fbuf))
		if dest != 0 {
			matches++
		}
		goto _2
	_2:
		;
		p++
	}
	if !(0 != 0) {
		goto _85
	}
	goto fmt_fail
fmt_fail:
	;
	goto alloc_fail
alloc_fail:
	;
	goto input_fail
input_fail:
	;
	if !(matches != 0) {
		matches--
	}
	goto match_fail
match_fail:
	;
	if alloc != 0 {
		Xfree(tls, s)
		Xfree(tls, wcs)
	}
_85:
	;
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return matches
}

func X__isoc99_vfscanf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v ap=%v, (%v:)", tls, f, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvfscanf(tls, f, fmt, ap)
}

var _states1 = [8][58]uint8{
	0: {
		0:  uint8(_DBL),
		2:  uint8(_UINT),
		4:  uint8(_DBL),
		5:  uint8(_DBL),
		6:  uint8(_DBL),
		11: uint8(_BIGLPRE),
		18: uint8(_PTR),
		23: uint8(_UINT),
		32: uint8(_DBL),
		34: uint8(_INT),
		35: uint8(_INT),
		36: uint8(_DBL),
		37: uint8(_DBL),
		38: uint8(_DBL),
		39: uint8(_HPRE),
		40: uint8(_INT),
		41: uint8(_JPRE),
		43: uint8(_LPRE),
		44: uint8(_NOARG),
		45: uint8(_PTR),
		46: uint8(_UINT),
		47: uint8(_UIPTR),
		50: uint8(_PTR),
		51: uint8(_ZTPRE),
		52: uint8(_UINT),
		55: uint8(_UINT),
		57: uint8(_ZTPRE),
	},
	1: {
		0:  uint8(_DBL),
		4:  uint8(_DBL),
		5:  uint8(_DBL),
		6:  uint8(_DBL),
		23: uint8(_ULONG),
		32: uint8(_DBL),
		34: uint8(_UINT),
		35: uint8(_LONG),
		36: uint8(_DBL),
		37: uint8(_DBL),
		38: uint8(_DBL),
		40: uint8(_LONG),
		43: uint8(_LLPRE),
		45: uint8(_PTR),
		46: uint8(_ULONG),
		50: uint8(_PTR),
		52: uint8(_ULONG),
		55: uint8(_ULONG),
	},
	2: {
		23: uint8(_ULLONG),
		35: uint8(_LLONG),
		40: uint8(_LLONG),
		45: uint8(_PTR),
		46: uint8(_ULLONG),
		52: uint8(_ULLONG),
		55: uint8(_ULLONG),
	},
	3: {
		23: uint8(_USHORT),
		35: uint8(_SHORT),
		39: uint8(_HHPRE),
		40: uint8(_SHORT),
		45: uint8(_PTR),
		46: uint8(_USHORT),
		52: uint8(_USHORT),
		55: uint8(_USHORT),
	},
	4: {
		23: uint8(_UCHAR),
		35: uint8(_CHAR),
		40: uint8(_CHAR),
		45: uint8(_PTR),
		46: uint8(_UCHAR),
		52: uint8(_UCHAR),
		55: uint8(_UCHAR),
	},
	5: {
		0:  uint8(_LDBL),
		4:  uint8(_LDBL),
		5:  uint8(_LDBL),
		6:  uint8(_LDBL),
		32: uint8(_LDBL),
		36: uint8(_LDBL),
		37: uint8(_LDBL),
		38: uint8(_LDBL),
		45: uint8(_PTR),
	},
	6: {
		23: uint8(_SIZET),
		35: uint8(_PDIFF),
		40: uint8(_PDIFF),
		45: uint8(_PTR),
		46: uint8(_SIZET),
		52: uint8(_SIZET),
		55: uint8(_SIZET),
	},
	7: {
		23: uint8(_UMAX),
		35: uint8(_IMAX),
		40: uint8(_IMAX),
		45: uint8(_PTR),
		46: uint8(_UMAX),
		52: uint8(_UMAX),
		55: uint8(_UMAX),
	},
}

func _pop_arg1(tls *TLS, arg uintptr, type1 int32, ap uintptr) {
	switch type1 {
	case int32(_PTR):
		*(*uintptr)(unsafe.Pointer(arg)) = VaUintptr(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_INT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UINT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaUint32(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_LONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_ULONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_ULLONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_SHORT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(int16(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_USHORT):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(uint16(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_CHAR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(int8(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_UCHAR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(uint8(VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))))
	case int32(_LLONG):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_SIZET):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_IMAX):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UMAX):
		(*Targ)(unsafe.Pointer(arg)).Fi = VaUint64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_PDIFF):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaInt64(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_UIPTR):
		(*Targ)(unsafe.Pointer(arg)).Fi = uint64(VaUintptr(&*(*Tva_list)(unsafe.Pointer(ap))))
	case int32(_DBL):
		*(*float64)(unsafe.Pointer(arg)) = VaFloat64(&*(*Tva_list)(unsafe.Pointer(ap)))
	case int32(_LDBL):
		*(*float64)(unsafe.Pointer(arg)) = VaFloat64(&*(*Tva_list)(unsafe.Pointer(ap)))
	}
}

func _out1(tls *TLS, f uintptr, s uintptr, l Tsize_t) {
	var v1 Tsize_t
	var v2 uintptr
	_, _ = v1, v2
	for {
		v1 = l
		l--
		if !(v1 != 0 && !((*TFILE)(unsafe.Pointer(f)).Fflags&Uint32FromInt32(F_ERR) != 0)) {
			break
		}
		v2 = s
		s += 4
		Xfputwc(tls, *(*Twchar_t)(unsafe.Pointer(v2)), f)
	}
}

func _pad4(tls *TLS, f uintptr, n int32, fl int32) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	if uint32(fl)&(Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))) != 0 || !(n != 0) || (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_ERR) != 0 {
		return
	}
	Xfprintf(tls, f, __ccgo_ts+1634, VaList(bp+8, n, __ccgo_ts))
}

func _getint1(tls *TLS, s uintptr) (r int32) {
	var i int32
	_ = i
	i = 0
	for {
		if !(BoolInt32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))-uint32('0') < uint32(10)) != 0) {
			break
		}
		if uint32(i) > Uint32FromInt32(INT_MAX)/Uint32FromUint32(10) || *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s))))-uint32('0') > uint32(int32(INT_MAX)-int32(10)*i) {
			i = -int32(1)
		} else {
			i = int32(uint32(int32(10)*i) + (*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(s)))) - uint32('0')))
		}
		goto _1
	_1:
		;
		*(*uintptr)(unsafe.Pointer(s)) += 4
	}
	return i
}

var _sizeprefix = [24]uint8{
	0:  uint8('L'),
	3:  uint8('j'),
	4:  uint8('L'),
	5:  uint8('L'),
	6:  uint8('L'),
	8:  uint8('j'),
	14: uint8('j'),
	15: uint8('j'),
	20: uint8('j'),
	23: uint8('j'),
}

func _wprintf_core(tls *TLS, f uintptr, fmt uintptr, ap uintptr, nl_arg uintptr, nl_type uintptr) (r int32) {
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var a, bs, z, v8 uintptr
	var argpos, cnt, i, l, p, t, w, xp, v10, v12, v13, v14, v16, v5, v6, v7 int32
	var fl, l10n, ps, st uint32
	var v15 bool
	var v9 uint64
	var _ /* arg at bp+16 */ Targ
	var _ /* charfmt at bp+24 */ [16]uint8
	var _ /* s at bp+8 */ uintptr
	var _ /* wc at bp+40 */ Twchar_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = a, argpos, bs, cnt, fl, i, l, l10n, p, ps, st, t, w, xp, z, v10, v12, v13, v14, v15, v16, v5, v6, v7, v8, v9
	*(*uintptr)(unsafe.Pointer(bp + 8)) = fmt
	l10n = uint32(0)
	cnt = 0
	l = 0
	for {
		/* This error is only specified for snprintf, but since it's
		 * unspecified for other forms, do the same. Stop immediately
		 * on overflow; otherwise %n could produce wrong results. */
		if l > int32(INT_MAX)-cnt {
			goto overflow
		}
		/* Update output count, end loop when fmt is exhausted */
		cnt += l
		if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0) {
			break
		}
		/* Handle literal text and %% format specifiers */
		a = *(*uintptr)(unsafe.Pointer(bp + 8))
		for {
			if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0 && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != uint32('%')) {
				break
			}
			goto _2
		_2:
			;
			*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
		}
		z = *(*uintptr)(unsafe.Pointer(bp + 8))
		for {
			if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == uint32('%') && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1*4)) == uint32('%')) {
				break
			}
			goto _3
		_3:
			;
			z += 4
			*(*uintptr)(unsafe.Pointer(bp + 8)) += uintptr(2) * 4
		}
		if (int64(z)-int64(a))/4 > int64(int32(INT_MAX)-cnt) {
			goto overflow
		}
		l = int32((int64(z) - int64(a)) / 4)
		if f != 0 {
			_out1(tls, f, a, uint64(l))
		}
		if l != 0 {
			goto _1
		}
		if BoolInt32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1*4))-uint32('0') < uint32(10)) != 0 && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2*4)) == uint32('$') {
			l10n = uint32(1)
			argpos = int32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1*4)) - uint32('0'))
			*(*uintptr)(unsafe.Pointer(bp + 8)) += uintptr(3) * 4
		} else {
			argpos = -int32(1)
			*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
		}
		/* Read modifier flags */
		fl = uint32(0)
		for {
			if !(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))-uint32(' ') < uint32(32) && (Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))|Uint32FromUint32(1)<<(Int32FromUint8('\'')-Int32FromUint8(' ')))&(uint32(1)<<(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))-uint32(' '))) != 0) {
				break
			}
			fl |= uint32(1) << (*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) - uint32(' '))
			goto _4
		_4:
			;
			*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
		}
		/* Read field width */
		if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == uint32('*') {
			if BoolInt32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1*4))-uint32('0') < uint32(10)) != 0 && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2*4)) == uint32('$') {
				l10n = uint32(1)
				*(*int32)(unsafe.Pointer(nl_type + uintptr(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1*4))-uint32('0'))*4)) = int32(_INT)
				w = int32(*(*Tuintmax_t)(unsafe.Pointer(nl_arg + uintptr(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1*4))-uint32('0'))*8)))
				*(*uintptr)(unsafe.Pointer(bp + 8)) += uintptr(3) * 4
			} else {
				if !(l10n != 0) {
					if f != 0 {
						v5 = VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))
					} else {
						v5 = 0
					}
					w = v5
					*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
				} else {
					goto inval
				}
			}
			if w < 0 {
				fl |= Uint32FromUint32(1) << (Int32FromUint8('-') - Int32FromUint8(' '))
				w = -w
			}
		} else {
			v6 = _getint1(tls, bp+8)
			w = v6
			if v6 < 0 {
				goto overflow
			}
		}
		/* Read precision */
		if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == uint32('.') && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 1*4)) == uint32('*') {
			if BoolInt32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2*4))-uint32('0') < uint32(10)) != 0 && *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 3*4)) == uint32('$') {
				*(*int32)(unsafe.Pointer(nl_type + uintptr(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2*4))-uint32('0'))*4)) = int32(_INT)
				p = int32(*(*Tuintmax_t)(unsafe.Pointer(nl_arg + uintptr(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + 2*4))-uint32('0'))*8)))
				*(*uintptr)(unsafe.Pointer(bp + 8)) += uintptr(4) * 4
			} else {
				if !(l10n != 0) {
					if f != 0 {
						v7 = VaInt32(&*(*Tva_list)(unsafe.Pointer(ap)))
					} else {
						v7 = 0
					}
					p = v7
					*(*uintptr)(unsafe.Pointer(bp + 8)) += uintptr(2) * 4
				} else {
					goto inval
				}
			}
			xp = BoolInt32(p >= 0)
		} else {
			if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) == uint32('.') {
				*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
				p = _getint1(tls, bp+8)
				xp = int32(1)
			} else {
				p = -int32(1)
				xp = 0
			}
		}
		/* Format specifier state machine */
		st = uint32(0)
		for cond := true; cond; cond = st-uint32(1) < uint32(_STOP) {
			if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8))))-uint32('A') > uint32(Int32FromUint8('z')-Int32FromUint8('A')) {
				goto inval
			}
			ps = st
			v8 = *(*uintptr)(unsafe.Pointer(bp + 8))
			*(*uintptr)(unsafe.Pointer(bp + 8)) += 4
			st = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&_states1)) + uintptr(st)*58 + uintptr(*(*Twchar_t)(unsafe.Pointer(v8))-uint32('A')))))
		}
		if !(st != 0) {
			goto inval
		}
		/* Check validity of argument type (nl/normal) */
		if st == uint32(_NOARG) {
			if argpos >= 0 {
				goto inval
			}
		} else {
			if argpos >= 0 {
				*(*int32)(unsafe.Pointer(nl_type + uintptr(argpos)*4)) = int32(st)
				*(*Targ)(unsafe.Pointer(bp + 16)) = *(*Targ)(unsafe.Pointer(nl_arg + uintptr(argpos)*8))
			} else {
				if f != 0 {
					_pop_arg1(tls, bp+16, int32(st), ap)
				} else {
					return 0
				}
			}
		}
		if !(f != 0) {
			goto _1
		}
		/* Do not process any new directives once in error state. */
		if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_ERR) != 0 {
			return -int32(1)
		}
		t = int32(*(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(-Int32FromInt32(1))*4)))
		if ps != 0 && t&int32(15) == int32(3) {
			t &= ^Int32FromInt32(32)
		}
		switch t {
		case int32('n'):
			switch ps {
			case uint32(_BARE):
				*(*int32)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = cnt
			case uint32(_LPRE):
				*(*int64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = int64(cnt)
			case uint32(_LLPRE):
				*(*int64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = int64(cnt)
			case uint32(_HPRE):
				*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = uint16(cnt)
			case uint32(_HHPRE):
				*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = uint8(cnt)
			case uint32(_ZTPRE):
				*(*Tsize_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = uint64(cnt)
			case uint32(_JPRE):
				*(*Tuintmax_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))) = uint64(cnt)
				break
			}
			goto _1
		case int32('c'):
			fallthrough
		case int32('C'):
			if w < int32(1) {
				w = int32(1)
			}
			_pad4(tls, f, w-int32(1), int32(fl))
			if t == int32('C') {
				v9 = *(*Tuintmax_t)(unsafe.Pointer(bp + 16))
			} else {
				v9 = uint64(Xbtowc(tls, int32(*(*Tuintmax_t)(unsafe.Pointer(bp + 16)))))
			}
			*(*Twchar_t)(unsafe.Pointer(bp)) = uint32(v9)
			_out1(tls, f, bp, uint64(1))
			_pad4(tls, f, w-int32(1), int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
			l = w
			goto _1
		case int32('S'):
			a = *(*uintptr)(unsafe.Pointer(bp + 16))
			if p < 0 {
				v10 = int32(INT_MAX)
			} else {
				v10 = p
			}
			z = a + uintptr(Xwcsnlen(tls, a, uint64(v10)))*4
			if p < 0 && *(*Twchar_t)(unsafe.Pointer(z)) != 0 {
				goto overflow
			}
			p = int32((int64(z) - int64(a)) / 4)
			if w < p {
				w = p
			}
			_pad4(tls, f, w-p, int32(fl))
			_out1(tls, f, a, uint64(p))
			_pad4(tls, f, w-p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
			l = w
			goto _1
		case int32('m'):
			*(*uintptr)(unsafe.Pointer(bp + 16)) = Xstrerror(tls, *(*int32)(unsafe.Pointer(X__errno_location(tls))))
			fallthrough
		case int32('s'):
			if !(*(*uintptr)(unsafe.Pointer(bp + 16)) != 0) {
				*(*uintptr)(unsafe.Pointer(bp + 16)) = __ccgo_ts + 1627
			}
			bs = *(*uintptr)(unsafe.Pointer(bp + 16))
			v12 = Int32FromInt32(0)
			l = v12
			i = v12
			for {
				if p < 0 {
					v13 = int32(INT_MAX)
				} else {
					v13 = p
				}
				if v15 = l < v13; v15 {
					v14 = Xmbtowc(tls, bp+40, bs, uint64(MB_LEN_MAX))
					i = v14
				}
				if !(v15 && v14 > 0) {
					break
				}
				goto _11
			_11:
				;
				bs += uintptr(i)
				l++
			}
			if i < 0 {
				return -int32(1)
			}
			if p < 0 && *(*uint8)(unsafe.Pointer(bs)) != 0 {
				goto overflow
			}
			p = l
			if w < p {
				w = p
			}
			_pad4(tls, f, w-p, int32(fl))
			bs = *(*uintptr)(unsafe.Pointer(bp + 16))
			for {
				v16 = l
				l--
				if !(v16 != 0) {
					break
				}
				i = Xmbtowc(tls, bp+40, bs, uint64(MB_LEN_MAX))
				bs += uintptr(i)
				_out1(tls, f, bp+40, uint64(1))
			}
			_pad4(tls, f, w-p, int32(fl^Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))))
			l = w
			goto _1
		}
		if xp != 0 && p < 0 {
			goto overflow
		}
		Xsnprintf(tls, bp+24, uint64(16), __ccgo_ts+1638, VaList(bp+56, __ccgo_ts+1658+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8('#')-Int32FromUint8(' '))) != 0)), __ccgo_ts+1660+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8('+')-Int32FromUint8(' '))) != 0)), __ccgo_ts+1662+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8('-')-Int32FromUint8(' '))) != 0)), __ccgo_ts+672+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8(' ')-Int32FromUint8(' '))) != 0)), __ccgo_ts+1664+BoolUintptr(!(fl&(Uint32FromUint32(1)<<(Int32FromUint8('0')-Int32FromUint8(' '))) != 0)), int32(_sizeprefix[t|int32(32)-int32('a')]), t))
		switch t | Int32FromInt32(32) {
		case int32('a'):
			fallthrough
		case int32('e'):
			fallthrough
		case int32('f'):
			fallthrough
		case int32('g'):
			l = Xfprintf(tls, f, bp+24, VaList(bp+56, w, p, *(*float64)(unsafe.Pointer(bp + 16))))
		case int32('d'):
			fallthrough
		case int32('i'):
			fallthrough
		case int32('o'):
			fallthrough
		case int32('u'):
			fallthrough
		case int32('x'):
			fallthrough
		case int32('p'):
			l = Xfprintf(tls, f, bp+24, VaList(bp+56, w, p, *(*Tuintmax_t)(unsafe.Pointer(bp + 16))))
			break
		}
		goto _1
	_1:
	}
	if f != 0 {
		return cnt
	}
	if !(l10n != 0) {
		return 0
	}
	i = int32(1)
	for {
		if !(i <= int32(NL_ARGMAX) && *(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)) != 0) {
			break
		}
		_pop_arg1(tls, nl_arg+uintptr(i)*8, *(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)), ap)
		goto _17
	_17:
		;
		i++
	}
	for {
		if !(i <= int32(NL_ARGMAX) && !(*(*int32)(unsafe.Pointer(nl_type + uintptr(i)*4)) != 0)) {
			break
		}
		goto _18
	_18:
		;
		i++
	}
	if i <= int32(NL_ARGMAX) {
		return -int32(1)
	}
	return int32(1)
	goto inval
inval:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
	return -int32(1)
	goto overflow
overflow:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOVERFLOW)
	return -int32(1)
}

func Xvfwprintf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v ap=%v, (%v:)", tls, f, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var __need_unlock, olderr, ret, v1 int32
	var _ /* ap2 at bp+0 */ Tva_list
	var _ /* nl_arg at bp+48 */ [10]Targ
	var _ /* nl_type at bp+8 */ [10]int32
	_, _, _, _ = __need_unlock, olderr, ret, v1
	*(*[10]int32)(unsafe.Pointer(bp + 8)) = [10]int32{}
	/* the copy allows passing va_list* even if va_list is an array */
	*(*Tva_list)(unsafe.Pointer(bp)) = ap
	if _wprintf_core(tls, uintptr(0), fmt, bp, bp+48, bp+8) < 0 {
		_ = *(*Tva_list)(unsafe.Pointer(bp))
		return -int32(1)
	}
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	Xfwide(tls, f, int32(1))
	olderr = int32((*TFILE)(unsafe.Pointer(f)).Fflags & uint32(F_ERR))
	*(*uint32)(unsafe.Pointer(f)) &= uint32(^Int32FromInt32(F_ERR))
	ret = _wprintf_core(tls, f, fmt, bp, bp+48, bp+8)
	if (*TFILE)(unsafe.Pointer(f)).Fflags&uint32(F_ERR) != 0 {
		ret = -int32(1)
	}
	*(*uint32)(unsafe.Pointer(f)) |= uint32(olderr)
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	_ = *(*Tva_list)(unsafe.Pointer(bp))
	return ret
}

func _store_int1(tls *TLS, dest uintptr, size int32, i uint64) {
	if !(dest != 0) {
		return
	}
	switch size {
	case -int32(2):
		*(*uint8)(unsafe.Pointer(dest)) = uint8(i)
	case -int32(1):
		*(*int16)(unsafe.Pointer(dest)) = int16(i)
	case SIZE_def:
		*(*int32)(unsafe.Pointer(dest)) = int32(i)
	case int32(SIZE_l):
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
	case int32(SIZE_ll):
		*(*int64)(unsafe.Pointer(dest)) = int64(i)
		break
	}
}

func _arg_n1(tls *TLS, ap Tva_list, n uint32) (r uintptr) {
	var ap2 Tva_list
	var i uint32
	var p uintptr
	_, _, _ = ap2, i, p
	ap2 = ap
	i = n
	for {
		if !(i > uint32(1)) {
			break
		}
		_ = VaUintptr(&ap2)
		goto _1
	_1:
		;
		i--
	}
	p = VaUintptr(&ap2)
	_ = ap2
	return p
}

func _in_set(tls *TLS, set uintptr, c int32) (r int32) {
	var j int32
	var p, v3 uintptr
	_, _, _ = j, p, v3
	p = set
	if *(*Twchar_t)(unsafe.Pointer(p)) == uint32('-') {
		if c == int32('-') {
			return int32(1)
		}
		p += 4
	} else {
		if *(*Twchar_t)(unsafe.Pointer(p)) == uint32(']') {
			if c == int32(']') {
				return int32(1)
			}
			p += 4
		}
	}
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(p)) != 0 && *(*Twchar_t)(unsafe.Pointer(p)) != uint32(']')) {
			break
		}
		if *(*Twchar_t)(unsafe.Pointer(p)) == uint32('-') && *(*Twchar_t)(unsafe.Pointer(p + 1*4)) != 0 && *(*Twchar_t)(unsafe.Pointer(p + 1*4)) != uint32(']') {
			v3 = p
			p += 4
			j = int32(*(*Twchar_t)(unsafe.Pointer(v3 + uintptr(-Int32FromInt32(1))*4)))
			for {
				if !(uint32(j) < *(*Twchar_t)(unsafe.Pointer(p))) {
					break
				}
				if c == j {
					return int32(1)
				}
				goto _2
			_2:
				;
				j++
			}
		}
		if uint32(c) == *(*Twchar_t)(unsafe.Pointer(p)) {
			return int32(1)
		}
		goto _1
	_1:
		;
		p += 4
	}
	return 0
}

func Xvfwscanf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v ap=%v, (%v:)", tls, f, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(80)
	defer tls.Free(80)
	var __need_unlock, alloc, c, gotmatch, invert, l, matches, size, t, width, v1, v10, v22, v3, v36 int32
	var dest, p, s, set, tmp1, tmp2, wcs, v12, v13, v15, v16, v18, v19, v21, v24, v25, v27, v28, v30, v31, v32, v33, v34, v38, v39, v41, v43, v44, v45, v5, v6, v8, v9 uintptr
	var i, k, v40 Tsize_t
	var pos Toff_t
	var v11, v14, v23, v26, v35, v37, v4 uint32
	var _ /* cnt at bp+0 */ Toff_t
	var _ /* tmp at bp+8 */ [22]uint8
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = __need_unlock, alloc, c, dest, gotmatch, i, invert, k, l, matches, p, pos, s, set, size, t, tmp1, tmp2, wcs, width, v1, v10, v11, v12, v13, v14, v15, v16, v18, v19, v21, v22, v23, v24, v25, v26, v27, v28, v3, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v4, v40, v41, v43, v44, v45, v5, v6, v8, v9
	dest = UintptrFromInt32(0)
	matches = 0
	pos = 0
	if AtomicLoadPInt32(f+140) >= 0 {
		v1 = ___lockfile(tls, f)
	} else {
		v1 = 0
	}
	__need_unlock = v1
	Xfwide(tls, f, int32(1))
	p = fmt
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(p)) != 0) {
			break
		}
		alloc = 0
		if Xiswspace(tls, *(*Twchar_t)(unsafe.Pointer(p))) != 0 {
			for Xiswspace(tls, *(*Twchar_t)(unsafe.Pointer(p + 1*4))) != 0 {
				p += 4
			}
			for {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend && int32(*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos))) < int32(128) {
					v6 = f + 8
					v5 = *(*uintptr)(unsafe.Pointer(v6))
					*(*uintptr)(unsafe.Pointer(v6))++
					v4 = uint32(*(*uint8)(unsafe.Pointer(v5)))
				} else {
					v4 = Xgetwc(tls, f)
				}
				v3 = int32(v4)
				c = v3
				if !(Xiswspace(tls, uint32(v3)) != 0) {
					break
				}
				pos++
			}
			if (*TFILE)(unsafe.Pointer(f)).Frend != 0 && uint32(c) < uint32(128) {
				v9 = f + 8
				*(*uintptr)(unsafe.Pointer(v9))--
				v8 = *(*uintptr)(unsafe.Pointer(v9))
				_ = *(*uint8)(unsafe.Pointer(v8))
			} else {
				Xungetwc(tls, uint32(c), f)
			}
			goto _2
		}
		if *(*Twchar_t)(unsafe.Pointer(p)) != uint32('%') || *(*Twchar_t)(unsafe.Pointer(p + 1*4)) == uint32('%') {
			if *(*Twchar_t)(unsafe.Pointer(p)) == uint32('%') {
				p += 4
				for {
					if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend && int32(*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos))) < int32(128) {
						v13 = f + 8
						v12 = *(*uintptr)(unsafe.Pointer(v13))
						*(*uintptr)(unsafe.Pointer(v13))++
						v11 = uint32(*(*uint8)(unsafe.Pointer(v12)))
					} else {
						v11 = Xgetwc(tls, f)
					}
					v10 = int32(v11)
					c = v10
					if !(Xiswspace(tls, uint32(v10)) != 0) {
						break
					}
					pos++
				}
			} else {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend && int32(*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos))) < int32(128) {
					v16 = f + 8
					v15 = *(*uintptr)(unsafe.Pointer(v16))
					*(*uintptr)(unsafe.Pointer(v16))++
					v14 = uint32(*(*uint8)(unsafe.Pointer(v15)))
				} else {
					v14 = Xgetwc(tls, f)
				}
				c = int32(v14)
			}
			if uint32(c) != *(*Twchar_t)(unsafe.Pointer(p)) {
				if (*TFILE)(unsafe.Pointer(f)).Frend != 0 && uint32(c) < uint32(128) {
					v19 = f + 8
					*(*uintptr)(unsafe.Pointer(v19))--
					v18 = *(*uintptr)(unsafe.Pointer(v19))
					_ = *(*uint8)(unsafe.Pointer(v18))
				} else {
					Xungetwc(tls, uint32(c), f)
				}
				if c < 0 {
					goto input_fail
				}
				goto match_fail
			}
			pos++
			goto _2
		}
		p += 4
		if *(*Twchar_t)(unsafe.Pointer(p)) == uint32('*') {
			dest = uintptr(0)
			p += 4
		} else {
			if BoolInt32(*(*Twchar_t)(unsafe.Pointer(p))-uint32('0') < uint32(10)) != 0 && *(*Twchar_t)(unsafe.Pointer(p + 1*4)) == uint32('$') {
				dest = _arg_n1(tls, ap, *(*Twchar_t)(unsafe.Pointer(p))-uint32('0'))
				p += uintptr(2) * 4
			} else {
				dest = VaUintptr(&ap)
			}
		}
		width = 0
		for {
			if !(BoolInt32(*(*Twchar_t)(unsafe.Pointer(p))-uint32('0') < uint32(10)) != 0) {
				break
			}
			width = int32(uint32(int32(10)*width) + *(*Twchar_t)(unsafe.Pointer(p)) - uint32('0'))
			goto _20
		_20:
			;
			p += 4
		}
		if *(*Twchar_t)(unsafe.Pointer(p)) == uint32('m') {
			wcs = uintptr(0)
			s = uintptr(0)
			alloc = BoolInt32(!!(dest != 0))
			p += 4
		} else {
			alloc = 0
		}
		size = SIZE_def
		v21 = p
		p += 4
		switch *(*Twchar_t)(unsafe.Pointer(v21)) {
		case uint32('h'):
			if *(*Twchar_t)(unsafe.Pointer(p)) == uint32('h') {
				p += 4
				size = -Int32FromInt32(2)
			} else {
				size = -int32(1)
			}
		case uint32('l'):
			if *(*Twchar_t)(unsafe.Pointer(p)) == uint32('l') {
				p += 4
				size = Int32FromInt32(SIZE_ll)
			} else {
				size = int32(SIZE_l)
			}
		case uint32('j'):
			size = int32(SIZE_ll)
		case uint32('z'):
			fallthrough
		case uint32('t'):
			size = int32(SIZE_l)
		case uint32('L'):
			size = int32(SIZE_L)
		case uint32('d'):
			fallthrough
		case uint32('i'):
			fallthrough
		case uint32('o'):
			fallthrough
		case uint32('u'):
			fallthrough
		case uint32('x'):
			fallthrough
		case uint32('a'):
			fallthrough
		case uint32('e'):
			fallthrough
		case uint32('f'):
			fallthrough
		case uint32('g'):
			fallthrough
		case uint32('A'):
			fallthrough
		case uint32('E'):
			fallthrough
		case uint32('F'):
			fallthrough
		case uint32('G'):
			fallthrough
		case uint32('X'):
			fallthrough
		case uint32('s'):
			fallthrough
		case uint32('c'):
			fallthrough
		case uint32('['):
			fallthrough
		case uint32('S'):
			fallthrough
		case uint32('C'):
			fallthrough
		case uint32('p'):
			fallthrough
		case uint32('n'):
			p -= 4
		default:
			goto fmt_fail
		}
		t = int32(*(*Twchar_t)(unsafe.Pointer(p)))
		/* Transform S,C -> ls,lc */
		if t&int32(0x2f) == int32(3) {
			size = int32(SIZE_l)
			t |= int32(32)
		}
		if t != int32('n') {
			if t != int32('[') && t|int32(32) != int32('c') {
				for {
					if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend && int32(*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos))) < int32(128) {
						v25 = f + 8
						v24 = *(*uintptr)(unsafe.Pointer(v25))
						*(*uintptr)(unsafe.Pointer(v25))++
						v23 = uint32(*(*uint8)(unsafe.Pointer(v24)))
					} else {
						v23 = Xgetwc(tls, f)
					}
					v22 = int32(v23)
					c = v22
					if !(Xiswspace(tls, uint32(v22)) != 0) {
						break
					}
					pos++
				}
			} else {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend && int32(*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos))) < int32(128) {
					v28 = f + 8
					v27 = *(*uintptr)(unsafe.Pointer(v28))
					*(*uintptr)(unsafe.Pointer(v28))++
					v26 = uint32(*(*uint8)(unsafe.Pointer(v27)))
				} else {
					v26 = Xgetwc(tls, f)
				}
				c = int32(v26)
			}
			if c < 0 {
				goto input_fail
			}
			if (*TFILE)(unsafe.Pointer(f)).Frend != 0 && uint32(c) < uint32(128) {
				v31 = f + 8
				*(*uintptr)(unsafe.Pointer(v31))--
				v30 = *(*uintptr)(unsafe.Pointer(v31))
				_ = *(*uint8)(unsafe.Pointer(v30))
			} else {
				Xungetwc(tls, uint32(c), f)
			}
		}
		switch t {
		case int32('n'):
			_store_int1(tls, dest, size, uint64(pos))
			/* do not increment match count, etc! */
			goto _2
		case int32('s'):
			fallthrough
		case int32('c'):
			fallthrough
		case int32('['):
			if t == int32('c') {
				if width < int32(1) {
					width = int32(1)
				}
				invert = int32(1)
				set = __ccgo_ts + 1666
			} else {
				if t == int32('s') {
					invert = int32(1)
					set = uintptr(unsafe.Pointer(&_spaces1))
				} else {
					p += 4
					v32 = p
					if *(*Twchar_t)(unsafe.Pointer(v32)) == uint32('^') {
						p += 4
						invert = Int32FromInt32(1)
					} else {
						invert = 0
					}
					set = p
					if *(*Twchar_t)(unsafe.Pointer(p)) == uint32(']') {
						p += 4
					}
					for *(*Twchar_t)(unsafe.Pointer(p)) != uint32(']') {
						if !(*(*Twchar_t)(unsafe.Pointer(p)) != 0) {
							goto fmt_fail
						}
						p += 4
					}
				}
			}
			if size == SIZE_def {
				v33 = dest
			} else {
				v33 = uintptr(0)
			}
			s = v33
			if size == int32(SIZE_l) {
				v34 = dest
			} else {
				v34 = uintptr(0)
			}
			wcs = v34
			gotmatch = 0
			if width < int32(1) {
				width = -int32(1)
			}
			i = uint64(0)
			if alloc != 0 {
				if t == int32('c') {
					v35 = uint32(width) + uint32(1)
				} else {
					v35 = uint32(31)
				}
				k = uint64(v35)
				if size == int32(SIZE_l) {
					wcs = Xmalloc(tls, k*uint64(4))
					if !(wcs != 0) {
						goto alloc_fail
					}
				} else {
					s = Xmalloc(tls, k)
					if !(s != 0) {
						goto alloc_fail
					}
				}
			}
			for width != 0 {
				if (*TFILE)(unsafe.Pointer(f)).Frpos != (*TFILE)(unsafe.Pointer(f)).Frend && int32(*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Frpos))) < int32(128) {
					v39 = f + 8
					v38 = *(*uintptr)(unsafe.Pointer(v39))
					*(*uintptr)(unsafe.Pointer(v39))++
					v37 = uint32(*(*uint8)(unsafe.Pointer(v38)))
				} else {
					v37 = Xgetwc(tls, f)
				}
				v36 = int32(v37)
				c = v36
				if v36 < 0 {
					break
				}
				if _in_set(tls, set, c) == invert {
					break
				}
				if wcs != 0 {
					v40 = i
					i++
					*(*Twchar_t)(unsafe.Pointer(wcs + uintptr(v40)*4)) = uint32(c)
					if alloc != 0 && i == k {
						k += k + uint64(1)
						tmp1 = Xrealloc(tls, wcs, k*uint64(4))
						if !(tmp1 != 0) {
							goto alloc_fail
						}
						wcs = tmp1
					}
				} else {
					if size != int32(SIZE_l) {
						if s != 0 {
							v41 = s + uintptr(i)
						} else {
							v41 = bp + 8
						}
						l = Xwctomb(tls, v41, uint32(c))
						if l < 0 {
							goto input_fail
						}
						i += uint64(l)
						if alloc != 0 && i > k-uint64(4) {
							k += k + uint64(1)
							tmp2 = Xrealloc(tls, s, k)
							if !(tmp2 != 0) {
								goto alloc_fail
							}
							s = tmp2
						}
					}
				}
				pos++
				width -= BoolInt32(width > 0)
				gotmatch = int32(1)
			}
			if width != 0 {
				if (*TFILE)(unsafe.Pointer(f)).Frend != 0 && uint32(c) < uint32(128) {
					v44 = f + 8
					*(*uintptr)(unsafe.Pointer(v44))--
					v43 = *(*uintptr)(unsafe.Pointer(v44))
					_ = *(*uint8)(unsafe.Pointer(v43))
				} else {
					Xungetwc(tls, uint32(c), f)
				}
				if t == int32('c') || !(gotmatch != 0) {
					goto match_fail
				}
			}
			if alloc != 0 {
				if size == int32(SIZE_l) {
					*(*uintptr)(unsafe.Pointer(dest)) = wcs
				} else {
					*(*uintptr)(unsafe.Pointer(dest)) = s
				}
			}
			if t != int32('c') {
				if wcs != 0 {
					*(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) = uint32(0)
				}
				if s != 0 {
					*(*uint8)(unsafe.Pointer(s + uintptr(i))) = uint8(0)
				}
			}
		case int32('d'):
			fallthrough
		case int32('i'):
			fallthrough
		case int32('o'):
			fallthrough
		case int32('u'):
			fallthrough
		case int32('x'):
			fallthrough
		case int32('a'):
			fallthrough
		case int32('e'):
			fallthrough
		case int32('f'):
			fallthrough
		case int32('g'):
			fallthrough
		case int32('A'):
			fallthrough
		case int32('E'):
			fallthrough
		case int32('F'):
			fallthrough
		case int32('G'):
			fallthrough
		case int32('X'):
			fallthrough
		case int32('p'):
			if width < int32(1) {
				width = 0
			}
			Xsnprintf(tls, bp+8, uint64(22), __ccgo_ts+1670, VaList(bp+40, int32(1)+BoolInt32(!(dest != 0)), __ccgo_ts+1688, width, uintptr(unsafe.Pointer(&_size_pfx))+uintptr(size+int32(2))*3, t))
			*(*Toff_t)(unsafe.Pointer(bp)) = 0
			if dest != 0 {
				v45 = dest
			} else {
				v45 = bp
			}
			if Xfscanf(tls, f, bp+8, VaList(bp+40, v45, bp)) == -int32(1) {
				goto input_fail
			} else {
				if !(*(*Toff_t)(unsafe.Pointer(bp)) != 0) {
					goto match_fail
				}
			}
			pos += *(*Toff_t)(unsafe.Pointer(bp))
		default:
			goto fmt_fail
		}
		if dest != 0 {
			matches++
		}
		goto _2
	_2:
		;
		p += 4
	}
	if !(0 != 0) {
		goto _46
	}
	goto fmt_fail
fmt_fail:
	;
	goto alloc_fail
alloc_fail:
	;
	goto input_fail
input_fail:
	;
	if !(matches != 0) {
		matches--
	}
	goto match_fail
match_fail:
	;
	if alloc != 0 {
		Xfree(tls, s)
		Xfree(tls, wcs)
	}
_46:
	;
	if __need_unlock != 0 {
		___unlockfile(tls, f)
	}
	return matches
}

var _size_pfx = [6][3]uint8{
	0: {'h', 'h'},
	1: {'h'},
	2: {},
	3: {'l'},
	4: {'L'},
	5: {'l', 'l'},
}

var _spaces1 = [22]Twchar_t{
	0:  uint32(' '),
	1:  uint32('\t'),
	2:  uint32('\n'),
	3:  uint32('\r'),
	4:  uint32(11),
	5:  uint32(12),
	6:  uint32(0x0085),
	7:  uint32(0x2000),
	8:  uint32(0x2001),
	9:  uint32(0x2002),
	10: uint32(0x2003),
	11: uint32(0x2004),
	12: uint32(0x2005),
	13: uint32(0x2006),
	14: uint32(0x2008),
	15: uint32(0x2009),
	16: uint32(0x200a),
	17: uint32(0x2028),
	18: uint32(0x2029),
	19: uint32(0x205f),
	20: uint32(0x3000),
}

func X__isoc99_vfwscanf(tls *TLS, f uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v f=%v fmt=%v ap=%v, (%v:)", tls, f, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvfwscanf(tls, f, fmt, ap)
}

func Xvprintf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v ap=%v, (%v:)", tls, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvfprintf(tls, uintptr(unsafe.Pointer(&X__stdout_FILE)), fmt, ap)
}

func Xvscanf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v ap=%v, (%v:)", tls, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvfscanf(tls, uintptr(unsafe.Pointer(&X__stdin_FILE)), fmt, ap)
}

func X__isoc99_vscanf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v ap=%v, (%v:)", tls, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvscanf(tls, fmt, ap)
}

type Tcookie3 = struct {
	Fs uintptr
	Fn Tsize_t
}

func _sn_write(tls *TLS, f uintptr, s uintptr, l Tsize_t) (r Tsize_t) {
	var c, v3 uintptr
	var k Tsize_t
	var v1, v2 uint64
	_, _, _, _, _ = c, k, v1, v2, v3
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if (*Tcookie3)(unsafe.Pointer(c)).Fn < uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos)-int64((*TFILE)(unsafe.Pointer(f)).Fwbase)) {
		v1 = (*Tcookie3)(unsafe.Pointer(c)).Fn
	} else {
		v1 = uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos) - int64((*TFILE)(unsafe.Pointer(f)).Fwbase))
	}
	k = v1
	if k != 0 {
		Xmemcpy(tls, (*Tcookie3)(unsafe.Pointer(c)).Fs, (*TFILE)(unsafe.Pointer(f)).Fwbase, k)
		*(*uintptr)(unsafe.Pointer(c)) += uintptr(k)
		*(*Tsize_t)(unsafe.Pointer(c + 8)) -= k
	}
	if (*Tcookie3)(unsafe.Pointer(c)).Fn < l {
		v2 = (*Tcookie3)(unsafe.Pointer(c)).Fn
	} else {
		v2 = l
	}
	k = v2
	if k != 0 {
		Xmemcpy(tls, (*Tcookie3)(unsafe.Pointer(c)).Fs, s, k)
		*(*uintptr)(unsafe.Pointer(c)) += uintptr(k)
		*(*Tsize_t)(unsafe.Pointer(c + 8)) -= k
	}
	*(*uint8)(unsafe.Pointer((*Tcookie3)(unsafe.Pointer(c)).Fs)) = uint8(0)
	v3 = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v3
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v3
	/* pretend to succeed, even if we discarded extra data */
	return l
}

func Xvsnprintf(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v fmt=%v ap=%v, (%v:)", tls, s, n, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var v1 uintptr
	var v2 uint64
	var _ /* buf at bp+0 */ [1]uint8
	var _ /* c at bp+8 */ Tcookie3
	var _ /* dummy at bp+1 */ [1]uint8
	var _ /* f at bp+24 */ TFILE
	_, _ = v1, v2
	if n != 0 {
		v1 = s
	} else {
		v1 = bp + 1
	}
	if n != 0 {
		v2 = n - uint64(1)
	} else {
		v2 = uint64(0)
	}
	*(*Tcookie3)(unsafe.Pointer(bp + 8)) = Tcookie3{
		Fs: v1,
		Fn: v2,
	}
	*(*TFILE)(unsafe.Pointer(bp + 24)) = TFILE{
		Fwrite:  __ccgo_fp(_sn_write),
		Fbuf:    bp,
		Flock:   -int32(1),
		Flbf:    -int32(1),
		Fcookie: bp + 8,
	}
	*(*uint8)(unsafe.Pointer((*(*Tcookie3)(unsafe.Pointer(bp + 8))).Fs)) = uint8(0)
	return Xvfprintf(tls, bp+24, fmt, ap)
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xvsprintf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v ap=%v, (%v:)", tls, s, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvsnprintf(tls, s, uint64(INT_MAX), fmt, ap)
}

func _string_read(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var end, src uintptr
	var k Tsize_t
	_, _, _ = end, k, src
	src = (*TFILE)(unsafe.Pointer(f)).Fcookie
	k = len1 + uint64(256)
	end = Xmemchr(tls, src, 0, k)
	if end != 0 {
		k = uint64(int64(end) - int64(src))
	}
	if k < len1 {
		len1 = k
	}
	Xmemcpy(tls, buf, src, len1)
	(*TFILE)(unsafe.Pointer(f)).Frpos = src + uintptr(len1)
	(*TFILE)(unsafe.Pointer(f)).Frend = src + uintptr(k)
	(*TFILE)(unsafe.Pointer(f)).Fcookie = src + uintptr(k)
	return len1
}

func Xvsscanf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v ap=%v, (%v:)", tls, s, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(240)
	defer tls.Free(240)
	var _ /* f at bp+0 */ TFILE
	*(*TFILE)(unsafe.Pointer(bp)) = TFILE{
		Fread:   __ccgo_fp(_string_read),
		Fbuf:    s,
		Flock:   -int32(1),
		Fcookie: s,
	}
	return Xvfscanf(tls, bp, fmt, ap)
}

func X__isoc99_vsscanf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v ap=%v, (%v:)", tls, s, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvsscanf(tls, s, fmt, ap)
}

type Tcookie4 = struct {
	Fws uintptr
	Fl  Tsize_t
}

func _sw_write(tls *TLS, f uintptr, s uintptr, l Tsize_t) (r Tsize_t) {
	var c, v3, v4, v5 uintptr
	var i, v1 int32
	var l0 Tsize_t
	var v2 bool
	_, _, _, _, _, _, _, _ = c, i, l0, v1, v2, v3, v4, v5
	l0 = l
	i = 0
	c = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if s != (*TFILE)(unsafe.Pointer(f)).Fwbase && _sw_write(tls, f, (*TFILE)(unsafe.Pointer(f)).Fwbase, uint64(int64((*TFILE)(unsafe.Pointer(f)).Fwpos)-int64((*TFILE)(unsafe.Pointer(f)).Fwbase))) == uint64(-Int32FromInt32(1)) {
		return uint64(-Int32FromInt32(1))
	}
	for {
		if v2 = (*Tcookie4)(unsafe.Pointer(c)).Fl != 0 && l != 0; v2 {
			v1 = Xmbtowc(tls, (*Tcookie4)(unsafe.Pointer(c)).Fws, s, l)
			i = v1
		}
		if !(v2 && v1 >= 0) {
			break
		}
		if !(i != 0) {
			i = int32(1)
		}
		s += uintptr(i)
		l -= uint64(i)
		(*Tcookie4)(unsafe.Pointer(c)).Fl--
		(*Tcookie4)(unsafe.Pointer(c)).Fws += 4
	}
	*(*Twchar_t)(unsafe.Pointer((*Tcookie4)(unsafe.Pointer(c)).Fws)) = uint32(0)
	if i < 0 {
		v4 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Fwend = v4
		v3 = v4
		(*TFILE)(unsafe.Pointer(f)).Fwbase = v3
		(*TFILE)(unsafe.Pointer(f)).Fwpos = v3
		*(*uint32)(unsafe.Pointer(f)) |= uint32(F_ERR)
		return uint64(i)
	}
	(*TFILE)(unsafe.Pointer(f)).Fwend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr((*TFILE)(unsafe.Pointer(f)).Fbuf_size)
	v5 = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Fwbase = v5
	(*TFILE)(unsafe.Pointer(f)).Fwpos = v5
	return l0
}

func Xvswprintf(tls *TLS, s uintptr, n Tsize_t, fmt uintptr, ap Tva_list) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v fmt=%v ap=%v, (%v:)", tls, s, n, fmt, ap, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(512)
	defer tls.Free(512)
	var r, v1 int32
	var _ /* buf at bp+0 */ [256]uint8
	var _ /* c at bp+256 */ Tcookie4
	var _ /* f at bp+272 */ TFILE
	_, _ = r, v1
	*(*Tcookie4)(unsafe.Pointer(bp + 256)) = Tcookie4{
		Fws: s,
		Fl:  n - uint64(1),
	}
	*(*TFILE)(unsafe.Pointer(bp + 272)) = TFILE{
		Fwrite:    __ccgo_fp(_sw_write),
		Fbuf:      bp,
		Fbuf_size: uint64(256),
		Flock:     -int32(1),
		Flbf:      -int32(1),
		Fcookie:   bp + 256,
	}
	if !(n != 0) {
		return -int32(1)
	}
	r = Xvfwprintf(tls, bp+272, fmt, ap)
	_sw_write(tls, bp+272, uintptr(0), uint64(0))
	if uint64(r) >= n {
		v1 = -int32(1)
	} else {
		v1 = r
	}
	return v1
}

func _wstring_read(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var k Tsize_t
	var v1, v2, v3 uintptr
	var _ /* src at bp+0 */ uintptr
	_, _, _, _ = k, v1, v2, v3
	*(*uintptr)(unsafe.Pointer(bp)) = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(*(*uintptr)(unsafe.Pointer(bp)) != 0) {
		return uint64(0)
	}
	k = Xwcsrtombs(tls, (*TFILE)(unsafe.Pointer(f)).Fbuf, bp, (*TFILE)(unsafe.Pointer(f)).Fbuf_size, uintptr(0))
	if k == uint64(-Int32FromInt32(1)) {
		v1 = UintptrFromInt32(0)
		(*TFILE)(unsafe.Pointer(f)).Frend = v1
		(*TFILE)(unsafe.Pointer(f)).Frpos = v1
		return uint64(0)
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(k)
	(*TFILE)(unsafe.Pointer(f)).Fcookie = *(*uintptr)(unsafe.Pointer(bp))
	if !(len1 != 0) || !(k != 0) {
		return uint64(0)
	}
	v3 = f + 8
	v2 = *(*uintptr)(unsafe.Pointer(v3))
	*(*uintptr)(unsafe.Pointer(v3))++
	*(*uint8)(unsafe.Pointer(buf)) = *(*uint8)(unsafe.Pointer(v2))
	return uint64(1)
}

func Xvswscanf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v ap=%v, (%v:)", tls, s, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(496)
	defer tls.Free(496)
	var _ /* buf at bp+0 */ [256]uint8
	var _ /* f at bp+256 */ TFILE
	*(*TFILE)(unsafe.Pointer(bp + 256)) = TFILE{
		Fread:     __ccgo_fp(_wstring_read),
		Fbuf:      bp,
		Fbuf_size: uint64(256),
		Flock:     -int32(1),
		Fcookie:   s,
	}
	return Xvfwscanf(tls, bp+256, fmt, ap)
}

func X__isoc99_vswscanf(tls *TLS, s uintptr, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v fmt=%v ap=%v, (%v:)", tls, s, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvswscanf(tls, s, fmt, ap)
}

func Xvwprintf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v ap=%v, (%v:)", tls, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvfwprintf(tls, uintptr(unsafe.Pointer(&X__stdout_FILE)), fmt, ap)
}

func Xvwscanf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v ap=%v, (%v:)", tls, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvfwscanf(tls, uintptr(unsafe.Pointer(&X__stdin_FILE)), fmt, ap)
}

func X__isoc99_vwscanf(tls *TLS, fmt uintptr, ap Tva_list) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v ap=%v, (%v:)", tls, fmt, ap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xvwscanf(tls, fmt, ap)
}

func Xwprintf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v va=%v, (%v:)", tls, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvwprintf(tls, fmt, ap)
	_ = ap
	return ret
}

func Xwscanf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v va=%v, (%v:)", tls, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ap Tva_list
	var ret int32
	_, _ = ap, ret
	ap = va
	ret = Xvwscanf(tls, fmt, ap)
	_ = ap
	return ret
}

func X__isoc99_wscanf(tls *TLS, fmt uintptr, va uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fmt=%v va=%v, (%v:)", tls, fmt, va, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwscanf(tls, fmt, va)
}

func Xabs(tls *TLS, a int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v a=%v, (%v:)", tls, a, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	_ = v1
	if a > 0 {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func Xatof(tls *TLS, s uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtod(tls, s, uintptr(0))
}

func Xatoi(tls *TLS, s uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var n, neg, v1, v2, v5 int32
	var v4 uintptr
	_, _, _, _, _, _ = n, neg, v1, v2, v4, v5
	n = 0
	neg = 0
	for {
		v1 = int32(*(*uint8)(unsafe.Pointer(s)))
		v2 = BoolInt32(v1 == int32(' ') || uint32(v1)-uint32('\t') < uint32(5))
		goto _3
	_3:
		if !(v2 != 0) {
			break
		}
		s++
	}
	switch int32(*(*uint8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	for BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0 {
		v4 = s
		s++
		n = int32(10)*n - (int32(*(*uint8)(unsafe.Pointer(v4))) - int32('0'))
	}
	if neg != 0 {
		v5 = n
	} else {
		v5 = -n
	}
	return v5
}

func Xatol(tls *TLS, s uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var n, v5 int64
	var neg, v1, v2 int32
	var v4 uintptr
	_, _, _, _, _, _ = n, neg, v1, v2, v4, v5
	n = 0
	neg = 0
	for {
		v1 = int32(*(*uint8)(unsafe.Pointer(s)))
		v2 = BoolInt32(v1 == int32(' ') || uint32(v1)-uint32('\t') < uint32(5))
		goto _3
	_3:
		if !(v2 != 0) {
			break
		}
		s++
	}
	switch int32(*(*uint8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	/* Compute n as a negative number to avoid overflow on LONG_MIN */
	for BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0 {
		v4 = s
		s++
		n = int64(10)*n - int64(int32(*(*uint8)(unsafe.Pointer(v4)))-Int32FromUint8('0'))
	}
	if neg != 0 {
		v5 = n
	} else {
		v5 = -n
	}
	return v5
}

func Xatoll(tls *TLS, s uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var n, v5 int64
	var neg, v1, v2 int32
	var v4 uintptr
	_, _, _, _, _, _ = n, neg, v1, v2, v4, v5
	n = 0
	neg = 0
	for {
		v1 = int32(*(*uint8)(unsafe.Pointer(s)))
		v2 = BoolInt32(v1 == int32(' ') || uint32(v1)-uint32('\t') < uint32(5))
		goto _3
	_3:
		if !(v2 != 0) {
			break
		}
		s++
	}
	switch int32(*(*uint8)(unsafe.Pointer(s))) {
	case int32('-'):
		neg = int32(1)
		fallthrough
	case int32('+'):
		s++
	}
	/* Compute n as a negative number to avoid overflow on LLONG_MIN */
	for BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0 {
		v4 = s
		s++
		n = int64(10)*n - int64(int32(*(*uint8)(unsafe.Pointer(v4)))-Int32FromUint8('0'))
	}
	if neg != 0 {
		v5 = n
	} else {
		v5 = -n
	}
	return v5
}

func Xbsearch(tls *TLS, key uintptr, base uintptr, nel Tsize_t, width Tsize_t, cmp uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v key=%v base=%v nel=%v width=%v cmp=%v, (%v:)", tls, key, base, nel, width, cmp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var sign int32
	var try uintptr
	_, _ = sign, try
	for nel > uint64(0) {
		try = base + uintptr(width*(nel/uint64(2)))
		sign = (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, key, try)
		if sign < 0 {
			nel /= uint64(2)
		} else {
			if sign > 0 {
				base = try + uintptr(width)
				nel -= nel/uint64(2) + uint64(1)
			} else {
				return try
			}
		}
	}
	return UintptrFromInt32(0)
}

func Xdiv(tls *TLS, num int32, den int32) (r Tdiv_t) {
	if __ccgo_strace {
		trc("tls=%v num=%v den=%v, (%v:)", tls, num, den, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Tdiv_t{
		Fquot: num / den,
		Frem:  num % den,
	}
}

func Xecvt(tls *TLS, x float64, n int32, dp uintptr, sign uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v dp=%v sign=%v, (%v:)", tls, x, n, dp, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var i, j, v1, v3 int32
	var _ /* tmp at bp+0 */ [32]uint8
	_, _, _, _ = i, j, v1, v3
	if uint32(n)-uint32(1) > uint32(15) {
		n = int32(15)
	}
	Xsprintf(tls, bp, __ccgo_ts+1691, VaList(bp+40, n-int32(1), x))
	v1 = BoolInt32(int32((*(*[32]uint8)(unsafe.Pointer(bp)))[0]) == Int32FromUint8('-'))
	*(*int32)(unsafe.Pointer(sign)) = v1
	i = v1
	j = 0
	for {
		if !(int32((*(*[32]uint8)(unsafe.Pointer(bp)))[i]) != int32('e')) {
			break
		}
		_buf8[j] = (*(*[32]uint8)(unsafe.Pointer(bp)))[i]
		goto _2
	_2:
		;
		v3 = i
		i++
		j += BoolInt32(int32((*(*[32]uint8)(unsafe.Pointer(bp)))[v3]) != int32('.'))
	}
	_buf8[j] = uint8(0)
	*(*int32)(unsafe.Pointer(dp)) = Xatoi(tls, bp+uintptr(i)+uintptr(1)) + int32(1)
	return uintptr(unsafe.Pointer(&_buf8))
}

var _buf8 [16]uint8

func Xfcvt(tls *TLS, x float64, n int32, dp uintptr, sign uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v dp=%v sign=%v, (%v:)", tls, x, n, dp, sign, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(1536)
	defer tls.Free(1536)
	var i, lz int32
	var _ /* tmp at bp+0 */ [1500]uint8
	_, _ = i, lz
	if uint32(n) > uint32(1400) {
		n = int32(1400)
	}
	Xsprintf(tls, bp, __ccgo_ts+1696, VaList(bp+1512, n, x))
	i = BoolInt32(int32((*(*[1500]uint8)(unsafe.Pointer(bp)))[0]) == int32('-'))
	if int32((*(*[1500]uint8)(unsafe.Pointer(bp)))[i]) == int32('0') {
		lz = int32(Xstrspn(tls, bp+uintptr(i)+uintptr(2), __ccgo_ts+1664))
	} else {
		lz = -int32(Xstrcspn(tls, bp+uintptr(i), __ccgo_ts+558))
	}
	if n <= lz {
		*(*int32)(unsafe.Pointer(sign)) = i
		*(*int32)(unsafe.Pointer(dp)) = int32(1)
		if uint32(n) > uint32(14) {
			n = int32(14)
		}
		return __ccgo_ts + 1701 + UintptrFromInt32(14) - uintptr(n)
	}
	return Xecvt(tls, x, n-lz, dp, sign)
}

func Xgcvt(tls *TLS, x float64, n int32, b uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v x=%v n=%v b=%v, (%v:)", tls, x, n, b, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	Xsprintf(tls, b, __ccgo_ts+1717, VaList(bp+8, n, x))
	return b
}

func Ximaxabs(tls *TLS, a Tintmax_t) (r Tintmax_t) {
	if __ccgo_strace {
		trc("tls=%v a=%v, (%v:)", tls, a, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int64
	_ = v1
	if a > 0 {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func Ximaxdiv(tls *TLS, num Tintmax_t, den Tintmax_t) (r Timaxdiv_t) {
	if __ccgo_strace {
		trc("tls=%v num=%v den=%v, (%v:)", tls, num, den, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Timaxdiv_t{
		Fquot: num / den,
		Frem:  num % den,
	}
}

func Xlabs(tls *TLS, a int64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v a=%v, (%v:)", tls, a, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int64
	_ = v1
	if a > 0 {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func Xldiv(tls *TLS, num int64, den int64) (r Tldiv_t) {
	if __ccgo_strace {
		trc("tls=%v num=%v den=%v, (%v:)", tls, num, den, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Tldiv_t{
		Fquot: num / den,
		Frem:  num % den,
	}
}

func Xllabs(tls *TLS, a int64) (r int64) {
	if __ccgo_strace {
		trc("tls=%v a=%v, (%v:)", tls, a, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int64
	_ = v1
	if a > 0 {
		v1 = a
	} else {
		v1 = -a
	}
	return v1
}

func Xlldiv(tls *TLS, num int64, den int64) (r Tlldiv_t) {
	if __ccgo_strace {
		trc("tls=%v num=%v den=%v, (%v:)", tls, num, den, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Tlldiv_t{
		Fquot: num / den,
		Frem:  num % den,
	}
}

type Tcmpfun = uintptr

func _pntz(tls *TLS, p uintptr) (r1 int32) {
	var r, v1 int32
	var v2 bool
	_, _, _ = r, v1, v2
	r = _a_ctz_l(tls, *(*Tsize_t)(unsafe.Pointer(p))-uint64(1))
	if v2 = r != 0; !v2 {
		v1 = int32(Uint64FromInt32(8)*Uint64FromInt64(8) + uint64(_a_ctz_l(tls, *(*Tsize_t)(unsafe.Pointer(p + 1*8)))))
		r = v1
	}
	if v2 || uint64(v1) != Uint64FromInt32(8)*Uint64FromInt64(8) {
		return r
	}
	return 0
}

func _cycle(tls *TLS, width Tsize_t, ar uintptr, n int32) {
	bp := tls.Alloc(256)
	defer tls.Free(256)
	var i int32
	var l Tsize_t
	var v1 uint64
	var _ /* tmp at bp+0 */ [256]uint8
	_, _, _ = i, l, v1
	if n < int32(2) {
		return
	}
	*(*uintptr)(unsafe.Pointer(ar + uintptr(n)*8)) = bp
	for width != 0 {
		if uint64(256) < width {
			v1 = uint64(256)
		} else {
			v1 = width
		}
		l = v1
		Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(ar + uintptr(n)*8)), *(*uintptr)(unsafe.Pointer(ar)), l)
		i = 0
		for {
			if !(i < n) {
				break
			}
			Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(ar + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(ar + uintptr(i+int32(1))*8)), l)
			*(*uintptr)(unsafe.Pointer(ar + uintptr(i)*8)) += uintptr(l)
			goto _2
		_2:
			;
			i++
		}
		width -= l
	}
}

// C documentation
//
//	/* shl() and shr() need n > 0 */
func _shl(tls *TLS, p uintptr, n int32) {
	if uint64(n) >= Uint64FromInt32(8)*Uint64FromInt64(8) {
		n = int32(uint64(n) - Uint64FromInt32(8)*Uint64FromInt64(8))
		*(*Tsize_t)(unsafe.Pointer(p + 1*8)) = *(*Tsize_t)(unsafe.Pointer(p))
		*(*Tsize_t)(unsafe.Pointer(p)) = uint64(0)
	}
	*(*Tsize_t)(unsafe.Pointer(p + 1*8)) <<= uint64(n)
	*(*Tsize_t)(unsafe.Pointer(p + 1*8)) |= *(*Tsize_t)(unsafe.Pointer(p)) >> (Uint64FromInt64(8)*Uint64FromInt32(8) - uint64(n))
	*(*Tsize_t)(unsafe.Pointer(p)) <<= uint64(n)
}

func _shr(tls *TLS, p uintptr, n int32) {
	if uint64(n) >= Uint64FromInt32(8)*Uint64FromInt64(8) {
		n = int32(uint64(n) - Uint64FromInt32(8)*Uint64FromInt64(8))
		*(*Tsize_t)(unsafe.Pointer(p)) = *(*Tsize_t)(unsafe.Pointer(p + 1*8))
		*(*Tsize_t)(unsafe.Pointer(p + 1*8)) = uint64(0)
	}
	*(*Tsize_t)(unsafe.Pointer(p)) >>= uint64(n)
	*(*Tsize_t)(unsafe.Pointer(p)) |= *(*Tsize_t)(unsafe.Pointer(p + 1*8)) << (Uint64FromInt64(8)*Uint64FromInt32(8) - uint64(n))
	*(*Tsize_t)(unsafe.Pointer(p + 1*8)) >>= uint64(n)
}

func _sift(tls *TLS, head uintptr, width Tsize_t, cmp Tcmpfun, arg uintptr, pshift int32, lp uintptr) {
	bp := tls.Alloc(912)
	defer tls.Free(912)
	var i, v1, v2 int32
	var lf, rt uintptr
	var _ /* ar at bp+0 */ [113]uintptr
	_, _, _, _, _ = i, lf, rt, v1, v2
	i = int32(1)
	(*(*[113]uintptr)(unsafe.Pointer(bp)))[0] = head
	for pshift > int32(1) {
		rt = head - uintptr(width)
		lf = head - uintptr(width) - uintptr(*(*Tsize_t)(unsafe.Pointer(lp + uintptr(pshift-int32(2))*8)))
		if (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, (*(*[113]uintptr)(unsafe.Pointer(bp)))[0], lf, arg) >= 0 && (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, (*(*[113]uintptr)(unsafe.Pointer(bp)))[0], rt, arg) >= 0 {
			break
		}
		if (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, lf, rt, arg) >= 0 {
			v1 = i
			i++
			(*(*[113]uintptr)(unsafe.Pointer(bp)))[v1] = lf
			head = lf
			pshift -= int32(1)
		} else {
			v2 = i
			i++
			(*(*[113]uintptr)(unsafe.Pointer(bp)))[v2] = rt
			head = rt
			pshift -= int32(2)
		}
	}
	_cycle(tls, width, bp, i)
}

func _trinkle(tls *TLS, head uintptr, width Tsize_t, cmp Tcmpfun, arg uintptr, pp uintptr, pshift int32, trusty int32, lp uintptr) {
	bp := tls.Alloc(928)
	defer tls.Free(928)
	var i, trail, v1 int32
	var lf, rt, stepson uintptr
	var _ /* ar at bp+16 */ [113]uintptr
	var _ /* p at bp+0 */ [2]Tsize_t
	_, _, _, _, _, _ = i, lf, rt, stepson, trail, v1
	i = int32(1)
	(*(*[2]Tsize_t)(unsafe.Pointer(bp)))[0] = *(*Tsize_t)(unsafe.Pointer(pp))
	(*(*[2]Tsize_t)(unsafe.Pointer(bp)))[int32(1)] = *(*Tsize_t)(unsafe.Pointer(pp + 1*8))
	(*(*[113]uintptr)(unsafe.Pointer(bp + 16)))[0] = head
	for (*(*[2]Tsize_t)(unsafe.Pointer(bp)))[0] != uint64(1) || (*(*[2]Tsize_t)(unsafe.Pointer(bp)))[int32(1)] != uint64(0) {
		stepson = head - uintptr(*(*Tsize_t)(unsafe.Pointer(lp + uintptr(pshift)*8)))
		if (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, stepson, (*(*[113]uintptr)(unsafe.Pointer(bp + 16)))[0], arg) <= 0 {
			break
		}
		if !(trusty != 0) && pshift > int32(1) {
			rt = head - uintptr(width)
			lf = head - uintptr(width) - uintptr(*(*Tsize_t)(unsafe.Pointer(lp + uintptr(pshift-int32(2))*8)))
			if (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, rt, stepson, arg) >= 0 || (*(*func(*TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, lf, stepson, arg) >= 0 {
				break
			}
		}
		v1 = i
		i++
		(*(*[113]uintptr)(unsafe.Pointer(bp + 16)))[v1] = stepson
		head = stepson
		trail = _pntz(tls, bp)
		_shr(tls, bp, trail)
		pshift += trail
		trusty = 0
	}
	if !(trusty != 0) {
		_cycle(tls, width, bp+16, i)
		_sift(tls, head, width, cmp, arg, pshift, lp)
	}
}

func X__qsort_r(tls *TLS, base uintptr, nel Tsize_t, width Tsize_t, cmp Tcmpfun, arg uintptr) {
	if __ccgo_strace {
		trc("tls=%v base=%v nel=%v width=%v cmp=%v arg=%v, (%v:)", tls, base, nel, width, cmp, arg, origin(2))
	}
	bp := tls.Alloc(784)
	defer tls.Free(784)
	var head, high uintptr
	var i, size, v2, v3 Tsize_t
	var pshift, trail int32
	var _ /* lp at bp+0 */ [96]Tsize_t
	var _ /* p at bp+768 */ [2]Tsize_t
	_, _, _, _, _, _, _, _ = head, high, i, pshift, size, trail, v2, v3
	size = width * nel
	*(*[2]Tsize_t)(unsafe.Pointer(bp + 768)) = [2]Tsize_t{
		0: uint64(1),
	}
	pshift = int32(1)
	if !(size != 0) {
		return
	}
	head = base
	high = head + uintptr(size) - uintptr(width)
	/* Precompute Leonardo numbers, scaled by element width */
	v2 = width
	(*(*[96]Tsize_t)(unsafe.Pointer(bp)))[int32(1)] = v2
	(*(*[96]Tsize_t)(unsafe.Pointer(bp)))[0] = v2
	i = Uint64FromInt32(2)
	for {
		v3 = (*(*[96]Tsize_t)(unsafe.Pointer(bp)))[i-uint64(2)] + (*(*[96]Tsize_t)(unsafe.Pointer(bp)))[i-uint64(1)] + width
		(*(*[96]Tsize_t)(unsafe.Pointer(bp)))[i] = v3
		if !(v3 < size) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	for head < high {
		if (*(*[2]Tsize_t)(unsafe.Pointer(bp + 768)))[0]&uint64(3) == uint64(3) {
			_sift(tls, head, width, cmp, arg, pshift, bp)
			_shr(tls, bp+768, int32(2))
			pshift += int32(2)
		} else {
			if (*(*[96]Tsize_t)(unsafe.Pointer(bp)))[pshift-int32(1)] >= uint64(int64(high)-int64(head)) {
				_trinkle(tls, head, width, cmp, arg, bp+768, pshift, 0, bp)
			} else {
				_sift(tls, head, width, cmp, arg, pshift, bp)
			}
			if pshift == int32(1) {
				_shl(tls, bp+768, int32(1))
				pshift = 0
			} else {
				_shl(tls, bp+768, pshift-int32(1))
				pshift = int32(1)
			}
		}
		*(*Tsize_t)(unsafe.Pointer(bp + 768)) |= uint64(1)
		head += uintptr(width)
	}
	_trinkle(tls, head, width, cmp, arg, bp+768, pshift, 0, bp)
	for pshift != int32(1) || (*(*[2]Tsize_t)(unsafe.Pointer(bp + 768)))[0] != uint64(1) || (*(*[2]Tsize_t)(unsafe.Pointer(bp + 768)))[int32(1)] != uint64(0) {
		if pshift <= int32(1) {
			trail = _pntz(tls, bp+768)
			_shr(tls, bp+768, trail)
			pshift += trail
		} else {
			_shl(tls, bp+768, int32(2))
			pshift -= int32(2)
			*(*Tsize_t)(unsafe.Pointer(bp + 768)) ^= uint64(7)
			_shr(tls, bp+768, int32(1))
			_trinkle(tls, head-uintptr((*(*[96]Tsize_t)(unsafe.Pointer(bp)))[pshift])-uintptr(width), width, cmp, arg, bp+768, pshift+int32(1), int32(1), bp)
			_shl(tls, bp+768, int32(1))
			*(*Tsize_t)(unsafe.Pointer(bp + 768)) |= uint64(1)
			_trinkle(tls, head-uintptr(width), width, cmp, arg, bp+768, pshift, int32(1), bp)
		}
		head -= uintptr(width)
	}
}

func Xqsort_r(tls *TLS, base uintptr, nel Tsize_t, width Tsize_t, cmp Tcmpfun, arg uintptr) {
	if __ccgo_strace {
		trc("tls=%v base=%v nel=%v width=%v cmp=%v arg=%v, (%v:)", tls, base, nel, width, cmp, arg, origin(2))
	}
	X__qsort_r(tls, base, nel, width, cmp, arg)
}

func _wrapper_cmp(tls *TLS, v1 uintptr, v2 uintptr, cmp uintptr) (r int32) {
	return (*(*func(*TLS, uintptr, uintptr) int32)(unsafe.Pointer(&struct{ uintptr }{cmp})))(tls, v1, v2)
}

func Xqsort(tls *TLS, base uintptr, nel Tsize_t, width Tsize_t, cmp Tcmpfun) {
	if __ccgo_strace {
		trc("tls=%v base=%v nel=%v width=%v cmp=%v, (%v:)", tls, base, nel, width, cmp, origin(2))
	}
	X__qsort_r(tls, base, nel, width, __ccgo_fp(_wrapper_cmp), cmp)
}

func _strtox(tls *TLS, s uintptr, p uintptr, prec int32) (r float64) {
	bp := tls.Alloc(240)
	defer tls.Free(240)
	var cnt Toff_t
	var y float64
	var v1, v2 uintptr
	var _ /* f at bp+0 */ TFILE
	_, _, _, _ = cnt, y, v1, v2
	v1 = s
	(*TFILE)(unsafe.Pointer(bp)).Frpos = v1
	(*TFILE)(unsafe.Pointer(bp)).Fbuf = v1
	(*TFILE)(unsafe.Pointer(bp)).Frend = uintptr(-Int32FromInt32(1))
	X__shlim(tls, bp, int64(Int32FromInt32(0)))
	y = X__floatscan(tls, bp, prec, int32(1))
	cnt = (*TFILE)(unsafe.Pointer(bp)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(bp)).Frpos) - int64((*TFILE)(unsafe.Pointer(bp)).Fbuf))
	if p != 0 {
		if cnt != 0 {
			v2 = s + uintptr(cnt)
		} else {
			v2 = s
		}
		*(*uintptr)(unsafe.Pointer(p)) = v2
	}
	return y
}

func Xstrtof(tls *TLS, s uintptr, p uintptr) (r float32) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return float32(_strtox(tls, s, p, 0))
}

func Xstrtod(tls *TLS, s uintptr, p uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _strtox(tls, s, p, int32(1))
}

func Xstrtold(tls *TLS, s uintptr, p uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _strtox(tls, s, p, int32(2))
}

func _strtox1(tls *TLS, s uintptr, p uintptr, base int32, lim uint64) (r uint64) {
	bp := tls.Alloc(240)
	defer tls.Free(240)
	var cnt Tsize_t
	var y uint64
	var v1 uintptr
	var _ /* f at bp+0 */ TFILE
	_, _, _ = cnt, y, v1
	v1 = s
	(*TFILE)(unsafe.Pointer(bp)).Frpos = v1
	(*TFILE)(unsafe.Pointer(bp)).Fbuf = v1
	(*TFILE)(unsafe.Pointer(bp)).Frend = uintptr(-Int32FromInt32(1))
	X__shlim(tls, bp, int64(Int32FromInt32(0)))
	y = X__intscan(tls, bp, uint32(base), int32(1), lim)
	if p != 0 {
		cnt = uint64((*TFILE)(unsafe.Pointer(bp)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(bp)).Frpos) - int64((*TFILE)(unsafe.Pointer(bp)).Fbuf)))
		*(*uintptr)(unsafe.Pointer(p)) = s + uintptr(cnt)
	}
	return y
}

func Xstrtoull(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _strtox1(tls, s, p, base, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
}

func Xstrtoll(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(_strtox1(tls, s, p, base, uint64(-Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1))))
}

func Xstrtoul(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _strtox1(tls, s, p, base, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
}

func Xstrtol(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(_strtox1(tls, s, p, base, Uint64FromUint64(0)+uint64(-Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1))))
}

func Xstrtoimax(tls *TLS, s uintptr, p uintptr, base int32) (r Tintmax_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtoll(tls, s, p, base)
}

func Xstrtoumax(tls *TLS, s uintptr, p uintptr, base int32) (r Tuintmax_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtoull(tls, s, p, base)
}

func X__strtoimax_internal(tls *TLS, s uintptr, p uintptr, base int32) (r Tintmax_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtoimax(tls, s, p, base)
}

func X__strtol_internal(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtol(tls, s, p, base)
}

func X__strtoll_internal(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtoll(tls, s, p, base)
}

func X__strtoul_internal(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtoul(tls, s, p, base)
}

func X__strtoull_internal(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtoull(tls, s, p, base)
}

func X__strtoumax_internal(tls *TLS, s uintptr, p uintptr, base int32) (r Tuintmax_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrtoumax(tls, s, p, base)
}

/* This read function heavily cheats. It knows:
 *  (1) len will always be 1
 *  (2) non-ascii characters don't matter */

func _do_read(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var i Tsize_t
	var wcs, v3, v4 uintptr
	var v2 uint32
	_, _, _, _, _ = i, wcs, v2, v3, v4
	wcs = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(*(*Twchar_t)(unsafe.Pointer(wcs)) != 0) {
		wcs = __ccgo_ts + 1722
	}
	i = uint64(0)
	for {
		if !(i < (*TFILE)(unsafe.Pointer(f)).Fbuf_size && *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) != 0) {
			break
		}
		if *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) < uint32(128) {
			v2 = *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4))
		} else {
			v2 = uint32('@')
		}
		*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(i))) = uint8(v2)
		goto _1
	_1:
		;
		i++
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(i)
	(*TFILE)(unsafe.Pointer(f)).Fcookie = wcs + uintptr(i)*4
	if i != 0 && len1 != 0 {
		v4 = f + 8
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(buf)) = *(*uint8)(unsafe.Pointer(v3))
		return uint64(1)
	}
	return uint64(0)
}

func _wcstox(tls *TLS, s uintptr, p uintptr, prec int32) (r float64) {
	bp := tls.Alloc(304)
	defer tls.Free(304)
	var cnt Tsize_t
	var t, v1, v2, v3 uintptr
	var y float64
	var _ /* buf at bp+0 */ [64]uint8
	var _ /* f at bp+64 */ TFILE
	_, _, _, _, _, _ = cnt, t, y, v1, v2, v3
	t = s
	*(*TFILE)(unsafe.Pointer(bp + 64)) = TFILE{}
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fflags = uint32(0)
	v2 = bp + UintptrFromInt32(4)
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fbuf = v2
	v1 = v2
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Frend = v1
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Frpos = v1
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fbuf_size = Uint64FromInt64(64) - Uint64FromInt32(4)
	AtomicStorePInt32(bp+64+140, -int32(1))
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fread = __ccgo_fp(_do_read)
	for Xiswspace(tls, *(*Twchar_t)(unsafe.Pointer(t))) != 0 {
		t += 4
	}
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fcookie = t
	X__shlim(tls, bp+64, int64(Int32FromInt32(0)))
	y = X__floatscan(tls, bp+64, prec, int32(1))
	if p != 0 {
		cnt = uint64((*TFILE)(unsafe.Pointer(bp+64)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(bp+64)).Frpos) - int64((*TFILE)(unsafe.Pointer(bp+64)).Fbuf)))
		if cnt != 0 {
			v3 = t + uintptr(cnt)*4
		} else {
			v3 = s
		}
		*(*uintptr)(unsafe.Pointer(p)) = v3
	}
	return y
}

func Xwcstof(tls *TLS, s uintptr, p uintptr) (r float32) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return float32(_wcstox(tls, s, p, 0))
}

func Xwcstod(tls *TLS, s uintptr, p uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _wcstox(tls, s, p, int32(1))
}

func Xwcstold(tls *TLS, s uintptr, p uintptr) (r float64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v, (%v:)", tls, s, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _wcstox(tls, s, p, int32(2))
}

/* This read function heavily cheats. It knows:
 *  (1) len will always be 1
 *  (2) non-ascii characters don't matter */

func _do_read1(tls *TLS, f uintptr, buf uintptr, len1 Tsize_t) (r Tsize_t) {
	var i Tsize_t
	var wcs, v3, v4 uintptr
	var v2 uint32
	_, _, _, _, _ = i, wcs, v2, v3, v4
	wcs = (*TFILE)(unsafe.Pointer(f)).Fcookie
	if !(*(*Twchar_t)(unsafe.Pointer(wcs)) != 0) {
		wcs = __ccgo_ts + 1722
	}
	i = uint64(0)
	for {
		if !(i < (*TFILE)(unsafe.Pointer(f)).Fbuf_size && *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) != 0) {
			break
		}
		if *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4)) < uint32(128) {
			v2 = *(*Twchar_t)(unsafe.Pointer(wcs + uintptr(i)*4))
		} else {
			v2 = uint32('@')
		}
		*(*uint8)(unsafe.Pointer((*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(i))) = uint8(v2)
		goto _1
	_1:
		;
		i++
	}
	(*TFILE)(unsafe.Pointer(f)).Frpos = (*TFILE)(unsafe.Pointer(f)).Fbuf
	(*TFILE)(unsafe.Pointer(f)).Frend = (*TFILE)(unsafe.Pointer(f)).Fbuf + uintptr(i)
	(*TFILE)(unsafe.Pointer(f)).Fcookie = wcs + uintptr(i)*4
	if i != 0 && len1 != 0 {
		v4 = f + 8
		v3 = *(*uintptr)(unsafe.Pointer(v4))
		*(*uintptr)(unsafe.Pointer(v4))++
		*(*uint8)(unsafe.Pointer(buf)) = *(*uint8)(unsafe.Pointer(v3))
		return uint64(1)
	}
	return uint64(0)
}

func _wcstox1(tls *TLS, s uintptr, p uintptr, base int32, lim uint64) (r uint64) {
	bp := tls.Alloc(304)
	defer tls.Free(304)
	var cnt Tsize_t
	var t, v1, v2, v3 uintptr
	var y uint64
	var _ /* buf at bp+0 */ [64]uint8
	var _ /* f at bp+64 */ TFILE
	_, _, _, _, _, _ = cnt, t, y, v1, v2, v3
	t = s
	*(*TFILE)(unsafe.Pointer(bp + 64)) = TFILE{}
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fflags = uint32(0)
	v2 = bp + UintptrFromInt32(4)
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fbuf = v2
	v1 = v2
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Frend = v1
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Frpos = v1
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fbuf_size = Uint64FromInt64(64) - Uint64FromInt32(4)
	AtomicStorePInt32(bp+64+140, -int32(1))
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fread = __ccgo_fp(_do_read1)
	for Xiswspace(tls, *(*Twchar_t)(unsafe.Pointer(t))) != 0 {
		t += 4
	}
	(*(*TFILE)(unsafe.Pointer(bp + 64))).Fcookie = t
	X__shlim(tls, bp+64, int64(Int32FromInt32(0)))
	y = X__intscan(tls, bp+64, uint32(base), int32(1), lim)
	if p != 0 {
		cnt = uint64((*TFILE)(unsafe.Pointer(bp+64)).Fshcnt + (int64((*TFILE)(unsafe.Pointer(bp+64)).Frpos) - int64((*TFILE)(unsafe.Pointer(bp+64)).Fbuf)))
		if cnt != 0 {
			v3 = t + uintptr(cnt)*4
		} else {
			v3 = s
		}
		*(*uintptr)(unsafe.Pointer(p)) = v3
	}
	return y
}

func Xwcstoull(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _wcstox1(tls, s, p, base, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
}

func Xwcstoll(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(_wcstox1(tls, s, p, base, uint64(-Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1))))
}

func Xwcstoul(tls *TLS, s uintptr, p uintptr, base int32) (r uint64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return _wcstox1(tls, s, p, base, Uint64FromUint64(2)*Uint64FromInt64(0x7fffffffffffffff)+Uint64FromInt32(1))
}

func Xwcstol(tls *TLS, s uintptr, p uintptr, base int32) (r int64) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int64(_wcstox1(tls, s, p, base, Uint64FromUint64(0)+uint64(-Int64FromInt64(0x7fffffffffffffff)-Int64FromInt32(1))))
}

func Xwcstoimax(tls *TLS, s uintptr, p uintptr, base int32) (r Tintmax_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwcstoll(tls, s, p, base)
}

func Xwcstoumax(tls *TLS, s uintptr, p uintptr, base int32) (r Tuintmax_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v p=%v base=%v, (%v:)", tls, s, p, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwcstoull(tls, s, p, base)
}

func Xbcmp(tls *TLS, s1 uintptr, s2 uintptr, n Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v s1=%v s2=%v n=%v, (%v:)", tls, s1, s2, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xmemcmp(tls, s1, s2, n)
}

func Xbcopy(tls *TLS, s1 uintptr, s2 uintptr, n Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s1=%v s2=%v n=%v, (%v:)", tls, s1, s2, n, origin(2))
	}
	Xmemmove(tls, s2, s1, n)
}

func Xbzero(tls *TLS, s uintptr, n Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v, (%v:)", tls, s, n, origin(2))
	}
	Xmemset(tls, s, 0, n)
}

func Xexplicit_bzero(tls *TLS, d uintptr, n Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v d=%v n=%v, (%v:)", tls, d, n, origin(2))
	}
	d = Xmemset(tls, d, 0, n)
}

func Xindex(tls *TLS, s uintptr, c int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrchr(tls, s, c)
}

const ALIGN1 = -1
const HIGHS = 0
const ONES = 0

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xmemccpy(tls *TLS, dest uintptr, src uintptr, c int32, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v c=%v n=%v, (%v:)", tls, dest, src, c, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d, s, wd, ws uintptr
	var k Tsize_t
	var v2, v6 uint8
	var v3, v7 bool
	_, _, _, _, _, _, _, _, _ = d, k, s, wd, ws, v2, v3, v6, v7
	d = dest
	s = src
	c = int32(uint8(c))
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) == uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			if v3 = uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; v3 {
				v2 = *(*uint8)(unsafe.Pointer(s))
				*(*uint8)(unsafe.Pointer(d)) = v2
			}
			if !(v3 && int32(v2) != c) {
				break
			}
			goto _1
		_1:
			;
			n--
			s++
			d++
		}
		if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 {
			goto tail
		}
		k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(UCHAR_MAX) * uint64(c)
		wd = d
		ws = s
		for {
			if !(n >= uint64(8) && !((*(*uint64)(unsafe.Pointer(ws))^k-uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)) & ^(*(*uint64)(unsafe.Pointer(ws))^k) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)*uint64(Int32FromInt32(UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0)) {
				break
			}
			*(*uint64)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
			goto _4
		_4:
			;
			n -= uint64(8)
			ws += 8
			wd += 8
		}
		d = wd
		s = ws
	}
	for {
		if v7 = n != 0; v7 {
			v6 = *(*uint8)(unsafe.Pointer(s))
			*(*uint8)(unsafe.Pointer(d)) = v6
		}
		if !(v7 && int32(v6) != c) {
			break
		}
		goto _5
	_5:
		;
		n--
		s++
		d++
	}
	goto tail
tail:
	;
	if n != 0 {
		return d + uintptr(1)
	}
	return uintptr(0)
}

const SS = 0

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xmemchr(tls *TLS, src uintptr, c int32, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v src=%v c=%v n=%v, (%v:)", tls, src, c, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var k Tsize_t
	var s, w, v4 uintptr
	_, _, _, _ = k, s, w, v4
	s = src
	c = int32(uint8(c))
	for {
		if !(uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c) {
			break
		}
		goto _1
	_1:
		;
		s++
		n--
	}
	if n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c {
		k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(UCHAR_MAX) * uint64(c)
		w = s
		for {
			if !(n >= Uint64FromInt64(8) && !((*(*uint64)(unsafe.Pointer(w))^k-uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)) & ^(*(*uint64)(unsafe.Pointer(w))^k) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)*uint64(Int32FromInt32(UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0)) {
				break
			}
			goto _2
		_2:
			;
			w += 8
			n -= Uint64FromInt64(8)
		}
		s = w
	}
	for {
		if !(n != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c) {
			break
		}
		goto _3
	_3:
		;
		s++
		n--
	}
	if n != 0 {
		v4 = s
	} else {
		v4 = uintptr(0)
	}
	return v4
}

func Xmemcmp(tls *TLS, vl uintptr, vr uintptr, n Tsize_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v vl=%v vr=%v n=%v, (%v:)", tls, vl, vr, n, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var l, r uintptr
	var v2 int32
	_, _, _ = l, r, v2
	l = vl
	r = vr
	for {
		if !(n != 0 && int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r)))) {
			break
		}
		goto _1
	_1:
		;
		n--
		l++
		r++
	}
	if n != 0 {
		v2 = int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
	} else {
		v2 = 0
	}
	return v2
}

const LS = 0
const RS = 0

func Xmemcpy(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v, (%v:)", tls, dest, src, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d, s, v10, v11, v12, v13, v14, v16, v17, v18, v19, v2, v21, v22, v24, v25, v26, v27, v28, v29, v3, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v5, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v6, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v7, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v8, v80, v81, v82, v83, v85, v86, v9 uintptr
	var w, x Tuint32_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = d, s, w, x, v10, v11, v12, v13, v14, v16, v17, v18, v19, v2, v21, v22, v24, v25, v26, v27, v28, v29, v3, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v5, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v6, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v7, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v8, v80, v81, v82, v83, v85, v86, v9
	d = dest
	s = src
	for {
		if !(uint64(s)%uint64(4) != 0 && n != 0) {
			break
		}
		v2 = d
		d++
		v3 = s
		s++
		*(*uint8)(unsafe.Pointer(v2)) = *(*uint8)(unsafe.Pointer(v3))
		goto _1
	_1:
		;
		n--
	}
	if uint64(d)%uint64(4) == uint64(0) {
		for {
			if !(n >= uint64(16)) {
				break
			}
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(0)))
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(4)))
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(8))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(8)))
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(12))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(12)))
			goto _4
		_4:
			;
			s += uintptr(16)
			d += uintptr(16)
			n -= uint64(16)
		}
		if n&uint64(8) != 0 {
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(0)))
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(4)))
			d += uintptr(8)
			s += uintptr(8)
		}
		if n&uint64(4) != 0 {
			*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(0)))
			d += uintptr(4)
			s += uintptr(4)
		}
		if n&uint64(2) != 0 {
			v5 = d
			d++
			v6 = s
			s++
			*(*uint8)(unsafe.Pointer(v5)) = *(*uint8)(unsafe.Pointer(v6))
			v7 = d
			d++
			v8 = s
			s++
			*(*uint8)(unsafe.Pointer(v7)) = *(*uint8)(unsafe.Pointer(v8))
		}
		if n&uint64(1) != 0 {
			*(*uint8)(unsafe.Pointer(d)) = *(*uint8)(unsafe.Pointer(s))
		}
		return dest
	}
	if n >= uint64(32) {
		switch uint64(d) % Uint64FromInt32(4) {
		case uint64(1):
			w = *(*uint32)(unsafe.Pointer(s))
			v9 = d
			d++
			v10 = s
			s++
			*(*uint8)(unsafe.Pointer(v9)) = *(*uint8)(unsafe.Pointer(v10))
			v11 = d
			d++
			v12 = s
			s++
			*(*uint8)(unsafe.Pointer(v11)) = *(*uint8)(unsafe.Pointer(v12))
			v13 = d
			d++
			v14 = s
			s++
			*(*uint8)(unsafe.Pointer(v13)) = *(*uint8)(unsafe.Pointer(v14))
			n -= uint64(3)
			for {
				if !(n >= uint64(17)) {
					break
				}
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(1)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = w>>Int32FromInt32(24) | x<<Int32FromInt32(8)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(5)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = x>>Int32FromInt32(24) | w<<Int32FromInt32(8)
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(9)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(8))) = w>>Int32FromInt32(24) | x<<Int32FromInt32(8)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(13)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(12))) = x>>Int32FromInt32(24) | w<<Int32FromInt32(8)
				goto _15
			_15:
				;
				s += uintptr(16)
				d += uintptr(16)
				n -= uint64(16)
			}
		case uint64(2):
			w = *(*uint32)(unsafe.Pointer(s))
			v16 = d
			d++
			v17 = s
			s++
			*(*uint8)(unsafe.Pointer(v16)) = *(*uint8)(unsafe.Pointer(v17))
			v18 = d
			d++
			v19 = s
			s++
			*(*uint8)(unsafe.Pointer(v18)) = *(*uint8)(unsafe.Pointer(v19))
			n -= uint64(2)
			for {
				if !(n >= uint64(18)) {
					break
				}
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(2)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = w>>Int32FromInt32(16) | x<<Int32FromInt32(16)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(6)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = x>>Int32FromInt32(16) | w<<Int32FromInt32(16)
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(10)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(8))) = w>>Int32FromInt32(16) | x<<Int32FromInt32(16)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(14)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(12))) = x>>Int32FromInt32(16) | w<<Int32FromInt32(16)
				goto _20
			_20:
				;
				s += uintptr(16)
				d += uintptr(16)
				n -= uint64(16)
			}
		case uint64(3):
			w = *(*uint32)(unsafe.Pointer(s))
			v21 = d
			d++
			v22 = s
			s++
			*(*uint8)(unsafe.Pointer(v21)) = *(*uint8)(unsafe.Pointer(v22))
			n -= uint64(1)
			for {
				if !(n >= uint64(19)) {
					break
				}
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(3)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(0))) = w>>Int32FromInt32(8) | x<<Int32FromInt32(24)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(7)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(4))) = x>>Int32FromInt32(8) | w<<Int32FromInt32(24)
				x = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(11)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(8))) = w>>Int32FromInt32(8) | x<<Int32FromInt32(24)
				w = *(*uint32)(unsafe.Pointer(s + UintptrFromInt32(15)))
				*(*uint32)(unsafe.Pointer(d + UintptrFromInt32(12))) = x>>Int32FromInt32(8) | w<<Int32FromInt32(24)
				goto _23
			_23:
				;
				s += uintptr(16)
				d += uintptr(16)
				n -= uint64(16)
			}
			break
		}
	}
	if n&uint64(16) != 0 {
		v24 = d
		d++
		v25 = s
		s++
		*(*uint8)(unsafe.Pointer(v24)) = *(*uint8)(unsafe.Pointer(v25))
		v26 = d
		d++
		v27 = s
		s++
		*(*uint8)(unsafe.Pointer(v26)) = *(*uint8)(unsafe.Pointer(v27))
		v28 = d
		d++
		v29 = s
		s++
		*(*uint8)(unsafe.Pointer(v28)) = *(*uint8)(unsafe.Pointer(v29))
		v30 = d
		d++
		v31 = s
		s++
		*(*uint8)(unsafe.Pointer(v30)) = *(*uint8)(unsafe.Pointer(v31))
		v32 = d
		d++
		v33 = s
		s++
		*(*uint8)(unsafe.Pointer(v32)) = *(*uint8)(unsafe.Pointer(v33))
		v34 = d
		d++
		v35 = s
		s++
		*(*uint8)(unsafe.Pointer(v34)) = *(*uint8)(unsafe.Pointer(v35))
		v36 = d
		d++
		v37 = s
		s++
		*(*uint8)(unsafe.Pointer(v36)) = *(*uint8)(unsafe.Pointer(v37))
		v38 = d
		d++
		v39 = s
		s++
		*(*uint8)(unsafe.Pointer(v38)) = *(*uint8)(unsafe.Pointer(v39))
		v40 = d
		d++
		v41 = s
		s++
		*(*uint8)(unsafe.Pointer(v40)) = *(*uint8)(unsafe.Pointer(v41))
		v42 = d
		d++
		v43 = s
		s++
		*(*uint8)(unsafe.Pointer(v42)) = *(*uint8)(unsafe.Pointer(v43))
		v44 = d
		d++
		v45 = s
		s++
		*(*uint8)(unsafe.Pointer(v44)) = *(*uint8)(unsafe.Pointer(v45))
		v46 = d
		d++
		v47 = s
		s++
		*(*uint8)(unsafe.Pointer(v46)) = *(*uint8)(unsafe.Pointer(v47))
		v48 = d
		d++
		v49 = s
		s++
		*(*uint8)(unsafe.Pointer(v48)) = *(*uint8)(unsafe.Pointer(v49))
		v50 = d
		d++
		v51 = s
		s++
		*(*uint8)(unsafe.Pointer(v50)) = *(*uint8)(unsafe.Pointer(v51))
		v52 = d
		d++
		v53 = s
		s++
		*(*uint8)(unsafe.Pointer(v52)) = *(*uint8)(unsafe.Pointer(v53))
		v54 = d
		d++
		v55 = s
		s++
		*(*uint8)(unsafe.Pointer(v54)) = *(*uint8)(unsafe.Pointer(v55))
	}
	if n&uint64(8) != 0 {
		v56 = d
		d++
		v57 = s
		s++
		*(*uint8)(unsafe.Pointer(v56)) = *(*uint8)(unsafe.Pointer(v57))
		v58 = d
		d++
		v59 = s
		s++
		*(*uint8)(unsafe.Pointer(v58)) = *(*uint8)(unsafe.Pointer(v59))
		v60 = d
		d++
		v61 = s
		s++
		*(*uint8)(unsafe.Pointer(v60)) = *(*uint8)(unsafe.Pointer(v61))
		v62 = d
		d++
		v63 = s
		s++
		*(*uint8)(unsafe.Pointer(v62)) = *(*uint8)(unsafe.Pointer(v63))
		v64 = d
		d++
		v65 = s
		s++
		*(*uint8)(unsafe.Pointer(v64)) = *(*uint8)(unsafe.Pointer(v65))
		v66 = d
		d++
		v67 = s
		s++
		*(*uint8)(unsafe.Pointer(v66)) = *(*uint8)(unsafe.Pointer(v67))
		v68 = d
		d++
		v69 = s
		s++
		*(*uint8)(unsafe.Pointer(v68)) = *(*uint8)(unsafe.Pointer(v69))
		v70 = d
		d++
		v71 = s
		s++
		*(*uint8)(unsafe.Pointer(v70)) = *(*uint8)(unsafe.Pointer(v71))
	}
	if n&uint64(4) != 0 {
		v72 = d
		d++
		v73 = s
		s++
		*(*uint8)(unsafe.Pointer(v72)) = *(*uint8)(unsafe.Pointer(v73))
		v74 = d
		d++
		v75 = s
		s++
		*(*uint8)(unsafe.Pointer(v74)) = *(*uint8)(unsafe.Pointer(v75))
		v76 = d
		d++
		v77 = s
		s++
		*(*uint8)(unsafe.Pointer(v76)) = *(*uint8)(unsafe.Pointer(v77))
		v78 = d
		d++
		v79 = s
		s++
		*(*uint8)(unsafe.Pointer(v78)) = *(*uint8)(unsafe.Pointer(v79))
	}
	if n&uint64(2) != 0 {
		v80 = d
		d++
		v81 = s
		s++
		*(*uint8)(unsafe.Pointer(v80)) = *(*uint8)(unsafe.Pointer(v81))
		v82 = d
		d++
		v83 = s
		s++
		*(*uint8)(unsafe.Pointer(v82)) = *(*uint8)(unsafe.Pointer(v83))
	}
	if n&uint64(1) != 0 {
		*(*uint8)(unsafe.Pointer(d)) = *(*uint8)(unsafe.Pointer(s))
	}
	return dest
	for {
		if !(n != 0) {
			break
		}
		v85 = d
		d++
		v86 = s
		s++
		*(*uint8)(unsafe.Pointer(v85)) = *(*uint8)(unsafe.Pointer(v86))
		goto _84
	_84:
		;
		n--
	}
	return dest
}

func _twobyte_memmem(tls *TLS, h uintptr, k Tsize_t, n uintptr) (r uintptr) {
	var hw, nw Tuint16_t
	var v2, v3 uintptr
	_, _, _, _ = hw, nw, v2, v3
	nw = uint16(int32(*(*uint8)(unsafe.Pointer(n)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(n + 1))))
	hw = uint16(int32(*(*uint8)(unsafe.Pointer(h)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(h + 1))))
	h += uintptr(2)
	k -= uint64(2)
	for {
		if !(k != 0) {
			break
		}
		if int32(hw) == int32(nw) {
			return h - uintptr(2)
		}
		goto _1
	_1:
		;
		k--
		v2 = h
		h++
		hw = uint16(int32(hw)<<Int32FromInt32(8) | int32(*(*uint8)(unsafe.Pointer(v2))))
	}
	if int32(hw) == int32(nw) {
		v3 = h - uintptr(2)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _threebyte_memmem(tls *TLS, h uintptr, k Tsize_t, n uintptr) (r uintptr) {
	var hw, nw Tuint32_t
	var v2, v3 uintptr
	_, _, _, _ = hw, nw, v2, v3
	nw = uint32(*(*uint8)(unsafe.Pointer(n)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(n + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(n + 2)))<<int32(8))
	hw = uint32(*(*uint8)(unsafe.Pointer(h)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(h + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(h + 2)))<<int32(8))
	h += uintptr(3)
	k -= uint64(3)
	for {
		if !(k != 0) {
			break
		}
		if hw == nw {
			return h - uintptr(3)
		}
		goto _1
	_1:
		;
		k--
		v2 = h
		h++
		hw = (hw | uint32(*(*uint8)(unsafe.Pointer(v2)))) << Int32FromInt32(8)
	}
	if hw == nw {
		v3 = h - uintptr(3)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _fourbyte_memmem(tls *TLS, h uintptr, k Tsize_t, n uintptr) (r uintptr) {
	var hw, nw Tuint32_t
	var v2, v3 uintptr
	_, _, _, _ = hw, nw, v2, v3
	nw = uint32(*(*uint8)(unsafe.Pointer(n)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(n + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(n + 2)))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(n + 3)))
	hw = uint32(*(*uint8)(unsafe.Pointer(h)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(h + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(h + 2)))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(h + 3)))
	h += uintptr(4)
	k -= uint64(4)
	for {
		if !(k != 0) {
			break
		}
		if hw == nw {
			return h - uintptr(4)
		}
		goto _1
	_1:
		;
		k--
		v2 = h
		h++
		hw = hw<<Int32FromInt32(8) | uint32(*(*uint8)(unsafe.Pointer(v2)))
	}
	if hw == nw {
		v3 = h - uintptr(4)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _twoway_memmem(tls *TLS, h uintptr, z uintptr, n uintptr, l Tsize_t) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var i, ip, jp, k, mem, mem0, ms, p, p0, v2, v3, v4, v5, v6, v7 Tsize_t
	var shift [256]Tsize_t
	var v11, v8 uint64
	var _ /* byteset at bp+0 */ [4]Tsize_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = i, ip, jp, k, mem, mem0, ms, p, p0, shift, v11, v2, v3, v4, v5, v6, v7, v8
	*(*[4]Tsize_t)(unsafe.Pointer(bp)) = [4]Tsize_t{}
	/* Computing length of needle and fill shift table */
	i = uint64(0)
	for {
		if !(i < l) {
			break
		}
		*(*Tsize_t)(unsafe.Pointer(bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(n + uintptr(i))))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8)) |= Uint64FromInt32(1) << (uint64(*(*uint8)(unsafe.Pointer(n + uintptr(i)))) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
		shift[*(*uint8)(unsafe.Pointer(n + uintptr(i)))] = i + Uint64FromInt32(1)
		goto _1
	_1:
		;
		i++
	}
	/* Compute maximal suffix */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v2 = Uint64FromInt32(1)
	p = v2
	k = v2
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) > int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v3 = jp
				jp++
				ip = v3
				v4 = Uint64FromInt32(1)
				p = v4
				k = v4
			}
		}
	}
	ms = ip
	p0 = p
	/* And with the opposite comparison */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v5 = Uint64FromInt32(1)
	p = v5
	k = v5
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) < int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v6 = jp
				jp++
				ip = v6
				v7 = Uint64FromInt32(1)
				p = v7
				k = v7
			}
		}
	}
	if ip+uint64(1) > ms+uint64(1) {
		ms = ip
	} else {
		p = p0
	}
	/* Periodic needle? */
	if Xmemcmp(tls, n, n+uintptr(p), ms+uint64(1)) != 0 {
		mem0 = uint64(0)
		if ms > l-ms-uint64(1) {
			v8 = ms
		} else {
			v8 = l - ms - uint64(1)
		}
		p = v8 + uint64(1)
	} else {
		mem0 = l - p
	}
	mem = uint64(0)
	/* Search loop */
	for {
		/* If remainder of haystack is shorter than needle, done */
		if uint64(int64(z)-int64(h)) < l {
			return uintptr(0)
		}
		/* Check last byte first; advance by shift on mismatch */
		if (*(*[4]Tsize_t)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1)))))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1)))))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0 {
			k = l - shift[*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1))))]
			if k != 0 {
				if k < mem {
					k = mem
				}
				h += uintptr(k)
				mem = uint64(0)
				goto _9
			}
		} else {
			h += uintptr(l)
			mem = uint64(0)
			goto _9
		}
		/* Compare right half */
		if ms+uint64(1) > mem {
			v11 = ms + uint64(1)
		} else {
			v11 = mem
		}
		k = v11
		for {
			if !(k < l && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k)))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k))))) {
				break
			}
			goto _10
		_10:
			;
			k++
		}
		if k < l {
			h += uintptr(k - ms)
			mem = uint64(0)
			goto _9
		}
		/* Compare left half */
		k = ms + uint64(1)
		for {
			if !(k > mem && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k-uint64(1))))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k-uint64(1)))))) {
				break
			}
			goto _12
		_12:
			;
			k--
		}
		if k <= mem {
			return h
		}
		h += uintptr(p)
		mem = mem0
		goto _9
	_9:
	}
	return r
}

func Xmemmem(tls *TLS, h0 uintptr, k Tsize_t, n0 uintptr, l Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v h0=%v k=%v n0=%v l=%v, (%v:)", tls, h0, k, n0, l, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var h, n uintptr
	_, _ = h, n
	h = h0
	n = n0
	/* Return immediately on empty needle */
	if !(l != 0) {
		return h
	}
	/* Return immediately when needle is longer than haystack */
	if k < l {
		return uintptr(0)
	}
	/* Use faster algorithms for short needles */
	h = Xmemchr(tls, h0, int32(*(*uint8)(unsafe.Pointer(n))), k)
	if !(h != 0) || l == uint64(1) {
		return h
	}
	k -= uint64(int64(h) - int64(h0))
	if k < l {
		return uintptr(0)
	}
	if l == uint64(2) {
		return _twobyte_memmem(tls, h, k, n)
	}
	if l == uint64(3) {
		return _threebyte_memmem(tls, h, k, n)
	}
	if l == uint64(4) {
		return _fourbyte_memmem(tls, h, k, n)
	}
	return _twoway_memmem(tls, h, h+uintptr(k), n, l)
}

const WS = 0

type TWT = uint64

func Xmemmove(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v, (%v:)", tls, dest, src, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d, s, v2, v3, v6, v7 uintptr
	var v1, v8 Tsize_t
	_, _, _, _, _, _, _, _ = d, s, v1, v2, v3, v6, v7, v8
	d = dest
	s = src
	if d == s {
		return d
	}
	if uint64(s)-uint64(d)-n <= uint64(-Int32FromInt32(2))*n {
		return Xmemcpy(tls, d, s, n)
	}
	if d < s {
		if uint64(s)%Uint64FromInt64(8) == uint64(d)%Uint64FromInt64(8) {
			for uint64(d)%Uint64FromInt64(8) != 0 {
				v1 = n
				n--
				if !(v1 != 0) {
					return dest
				}
				v2 = d
				d++
				v3 = s
				s++
				*(*uint8)(unsafe.Pointer(v2)) = *(*uint8)(unsafe.Pointer(v3))
			}
			for {
				if !(n >= Uint64FromInt64(8)) {
					break
				}
				*(*TWT)(unsafe.Pointer(d)) = *(*TWT)(unsafe.Pointer(s))
				goto _4
			_4:
				;
				n -= Uint64FromInt64(8)
				d += uintptr(Uint64FromInt64(8))
				s += uintptr(Uint64FromInt64(8))
			}
		}
		for {
			if !(n != 0) {
				break
			}
			v6 = d
			d++
			v7 = s
			s++
			*(*uint8)(unsafe.Pointer(v6)) = *(*uint8)(unsafe.Pointer(v7))
			goto _5
		_5:
			;
			n--
		}
	} else {
		if uint64(s)%Uint64FromInt64(8) == uint64(d)%Uint64FromInt64(8) {
			for uint64(d+uintptr(n))%Uint64FromInt64(8) != 0 {
				v8 = n
				n--
				if !(v8 != 0) {
					return dest
				}
				*(*uint8)(unsafe.Pointer(d + uintptr(n))) = *(*uint8)(unsafe.Pointer(s + uintptr(n)))
			}
			for n >= Uint64FromInt64(8) {
				n -= Uint64FromInt64(8)
				*(*TWT)(unsafe.Pointer(d + uintptr(n))) = *(*TWT)(unsafe.Pointer(s + uintptr(n)))
			}
		}
		for n != 0 {
			n--
			*(*uint8)(unsafe.Pointer(d + uintptr(n))) = *(*uint8)(unsafe.Pointer(s + uintptr(n)))
		}
	}
	return dest
}

func Xmempcpy(tls *TLS, dest uintptr, src uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v n=%v, (%v:)", tls, dest, src, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xmemcpy(tls, dest, src, n) + uintptr(n)
}

func X__memrchr(tls *TLS, m uintptr, c int32, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v m=%v c=%v n=%v, (%v:)", tls, m, c, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var s uintptr
	var v1 Tsize_t
	_, _ = s, v1
	s = m
	c = int32(uint8(c))
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(s + uintptr(n)))) == c {
			return s + uintptr(n)
		}
	}
	return uintptr(0)
}

func Xmemrchr(tls *TLS, m uintptr, c int32, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v m=%v c=%v n=%v, (%v:)", tls, m, c, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__memrchr(tls, m, c, n)
}

func Xmemset(tls *TLS, dest uintptr, c int32, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dest=%v c=%v n=%v, (%v:)", tls, dest, c, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var c32 uint32
	var c64 uint64
	var k Tsize_t
	var s uintptr
	_, _, _, _ = c32, c64, k, s
	s = dest
	/* Fill head and tail with minimal branching. Each
	 * conditional ensures that all the subsequently used
	 * offsets are well-defined and in the dest region. */
	if !(n != 0) {
		return dest
	}
	*(*uint8)(unsafe.Pointer(s)) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + uintptr(n-uint64(1)))) = uint8(c)
	if n <= uint64(2) {
		return dest
	}
	*(*uint8)(unsafe.Pointer(s + 1)) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + 2)) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + uintptr(n-uint64(2)))) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + uintptr(n-uint64(3)))) = uint8(c)
	if n <= uint64(6) {
		return dest
	}
	*(*uint8)(unsafe.Pointer(s + 3)) = uint8(c)
	*(*uint8)(unsafe.Pointer(s + uintptr(n-uint64(4)))) = uint8(c)
	if n <= uint64(8) {
		return dest
	}
	/* Advance pointer to align it at a 4-byte boundary,
	 * and truncate n to a multiple of 4. The previous code
	 * already took care of any head/tail that get cut off
	 * by the alignment. */
	k = -uint64(s) & uint64(3)
	s += uintptr(k)
	n -= k
	n &= uint64(-Int32FromInt32(4))
	c32 = uint32(-Int32FromInt32(1)) / Uint32FromInt32(255) * uint32(uint8(c))
	/* In preparation to copy 32 bytes at a time, aligned on
	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
	 * As in the initial byte-based head/tail fill, each
	 * conditional below ensures that the subsequent offsets
	 * are valid (e.g. !(n<=24) implies n>=28). */
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(0))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(4))) = c32
	if n <= uint64(8) {
		return dest
	}
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(4))) = c32
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(8))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(12))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(8))) = c32
	if n <= uint64(24) {
		return dest
	}
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(12))) = c32
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(16))) = c32
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(20))) = c32
	*(*uint32)(unsafe.Pointer(s + UintptrFromInt32(24))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(28))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(24))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(20))) = c32
	*(*uint32)(unsafe.Pointer(s + uintptr(n) - UintptrFromInt32(16))) = c32
	/* Align to a multiple of 8 so we can fill 64 bits at a time,
	 * and avoid writing the same bytes twice as much as is
	 * practical without introducing additional branching. */
	k = uint64(24) + uint64(s)&uint64(4)
	s += uintptr(k)
	n -= k
	/* If this loop is reached, 28 tail bytes have already been
	 * filled, so any remainder when n drops below 32 can be
	 * safely ignored. */
	c64 = uint64(c32) | uint64(c32)<<Int32FromInt32(32)
	for {
		if !(n >= uint64(32)) {
			break
		}
		*(*uint64)(unsafe.Pointer(s + UintptrFromInt32(0))) = c64
		*(*uint64)(unsafe.Pointer(s + UintptrFromInt32(8))) = c64
		*(*uint64)(unsafe.Pointer(s + UintptrFromInt32(16))) = c64
		*(*uint64)(unsafe.Pointer(s + UintptrFromInt32(24))) = c64
		goto _1
	_1:
		;
		n -= uint64(32)
		s += uintptr(32)
	}
	return dest
}

func Xrindex(tls *TLS, s uintptr, c int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrrchr(tls, s, c)
}

const ALIGN2 = 0

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func X__stpcpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v, (%v:)", tls, d, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var wd, ws, v4, v5 uintptr
	var v2, v7 uint8
	_, _, _, _, _, _ = wd, ws, v2, v4, v5, v7
	if uint64(s)%Uint64FromInt64(8) == uint64(d)%Uint64FromInt64(8) {
		for {
			if !(uint64(s)%Uint64FromInt64(8) != 0) {
				break
			}
			v2 = *(*uint8)(unsafe.Pointer(s))
			*(*uint8)(unsafe.Pointer(d)) = v2
			if !(v2 != 0) {
				return d
			}
			goto _1
		_1:
			;
			s++
			d++
		}
		wd = d
		ws = s
		for {
			if !!((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)*uint64(Int32FromInt32(UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
				break
			}
			goto _3
		_3:
			;
			v4 = wd
			wd += 8
			v5 = ws
			ws += 8
			*(*uint64)(unsafe.Pointer(v4)) = *(*uint64)(unsafe.Pointer(v5))
		}
		d = wd
		s = ws
	}
	for {
		v7 = *(*uint8)(unsafe.Pointer(s))
		*(*uint8)(unsafe.Pointer(d)) = v7
		if !(v7 != 0) {
			break
		}
		goto _6
	_6:
		;
		s++
		d++
	}
	return d
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xstpcpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v, (%v:)", tls, d, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__stpcpy(tls, d, s)
}

const ALIGN3 = -1

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func X__stpncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var wd, ws uintptr
	var v2, v6 uint8
	var v3, v7 bool
	_, _, _, _, _, _ = wd, ws, v2, v3, v6, v7
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) == uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			if v3 = uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; v3 {
				v2 = *(*uint8)(unsafe.Pointer(s))
				*(*uint8)(unsafe.Pointer(d)) = v2
			}
			if !(v3 && v2 != 0) {
				break
			}
			goto _1
		_1:
			;
			n--
			s++
			d++
		}
		if !(n != 0) || !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			goto tail
		}
		wd = d
		ws = s
		for {
			if !(n >= uint64(8) && !((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)*uint64(Int32FromInt32(UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0)) {
				break
			}
			*(*uint64)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
			goto _4
		_4:
			;
			n -= uint64(8)
			ws += 8
			wd += 8
		}
		d = wd
		s = ws
	}
	for {
		if v7 = n != 0; v7 {
			v6 = *(*uint8)(unsafe.Pointer(s))
			*(*uint8)(unsafe.Pointer(d)) = v6
		}
		if !(v7 && v6 != 0) {
			break
		}
		goto _5
	_5:
		;
		n--
		s++
		d++
	}
	goto tail
tail:
	;
	Xmemset(tls, d, 0, n)
	return d
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xstpncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__stpncpy(tls, d, s, n)
}

func Xstrcasecmp(tls *TLS, _l uintptr, _r uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v _l=%v _r=%v, (%v:)", tls, _l, _r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var l, r uintptr
	_, _ = l, r
	l = _l
	r = _r
	for {
		if !(*(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && (int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) || Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) == Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(r)))))) {
			break
		}
		goto _1
	_1:
		;
		l++
		r++
	}
	return Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) - Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))
}

func X__strcasecmp_l(tls *TLS, l uintptr, r uintptr, loc Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v loc=%v, (%v:)", tls, l, r, loc, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return Xstrcasecmp(tls, l, r)
}

func Xstrcasecmp_l(tls *TLS, l uintptr, r uintptr, loc Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v loc=%v, (%v:)", tls, l, r, loc, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return X__strcasecmp_l(tls, l, r, loc)
}

func Xstrcasestr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v h=%v n=%v, (%v:)", tls, h, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tsize_t
	_ = l
	l = Xstrlen(tls, n)
	for {
		if !(*(*uint8)(unsafe.Pointer(h)) != 0) {
			break
		}
		if !(Xstrncasecmp(tls, h, n, l) != 0) {
			return h
		}
		goto _1
	_1:
		;
		h++
	}
	return uintptr(0)
}

func Xstrcat(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v, (%v:)", tls, dest, src, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	Xstrcpy(tls, dest+uintptr(Xstrlen(tls, dest)), src)
	return dest
}

func Xstrchr(tls *TLS, s uintptr, c int32) (r1 uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v1 uintptr
	_, _ = r, v1
	r = X__strchrnul(tls, s, c)
	if int32(*(*uint8)(unsafe.Pointer(r))) == int32(uint8(c)) {
		v1 = r
	} else {
		v1 = uintptr(0)
	}
	return v1
}

const ALIGN4 = 0

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func X__strchrnul(tls *TLS, s uintptr, c int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var k Tsize_t
	var w uintptr
	_, _ = k, w
	c = int32(uint8(c))
	if !(c != 0) {
		return s + uintptr(Xstrlen(tls, s))
	}
	for {
		if !(uint64(s)%Uint64FromInt64(8) != 0) {
			break
		}
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) || int32(*(*uint8)(unsafe.Pointer(s))) == c {
			return s
		}
		goto _1
	_1:
		;
		s++
	}
	k = uint64(-Int32FromInt32(1)) / Uint64FromInt32(UCHAR_MAX) * uint64(c)
	w = s
	for {
		if !(!((*(*uint64)(unsafe.Pointer(w))-uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(w)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)*uint64(Int32FromInt32(UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) && !((*(*uint64)(unsafe.Pointer(w))^k-uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)) & ^(*(*uint64)(unsafe.Pointer(w))^k) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)*uint64(Int32FromInt32(UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0)) {
			break
		}
		goto _2
	_2:
		;
		w += 8
	}
	s = w
	for {
		if !(*(*uint8)(unsafe.Pointer(s)) != 0 && int32(*(*uint8)(unsafe.Pointer(s))) != c) {
			break
		}
		goto _3
	_3:
		;
		s++
	}
	return s
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xstrchrnul(tls *TLS, s uintptr, c int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__strchrnul(tls, s, c)
}

func Xstrcmp(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v, (%v:)", tls, l, r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	for {
		if !(int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) && *(*uint8)(unsafe.Pointer(l)) != 0) {
			break
		}
		goto _1
	_1:
		;
		l++
		r++
	}
	return int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
}

func Xstrcpy(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v, (%v:)", tls, dest, src, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	X__stpcpy(tls, dest, src)
	return dest
}

func Xstrcspn(tls *TLS, s uintptr, c uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var a, p2 uintptr
	var v3 bool
	var _ /* byteset at bp+0 */ [4]Tsize_t
	_, _, _ = a, v3, p2
	a = s
	if !(*(*uint8)(unsafe.Pointer(c)) != 0) || !(*(*uint8)(unsafe.Pointer(c + 1)) != 0) {
		return uint64(int64(X__strchrnul(tls, s, int32(*(*uint8)(unsafe.Pointer(c))))) - int64(a))
	}
	Xmemset(tls, bp, 0, uint64(32))
	for {
		if v3 = *(*uint8)(unsafe.Pointer(c)) != 0; v3 {
			p2 = bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(c)))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
			*(*Tsize_t)(unsafe.Pointer(p2)) |= Uint64FromInt32(1) << (uint64(*(*uint8)(unsafe.Pointer(c))) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
		}
		if !(v3 && *(*Tsize_t)(unsafe.Pointer(p2)) != 0) {
			break
		}
		goto _1
	_1:
		;
		c++
	}
	for {
		if !(*(*uint8)(unsafe.Pointer(s)) != 0 && !((*(*[4]Tsize_t)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(s)))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(s)))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0)) {
			break
		}
		goto _4
	_4:
		;
		s++
	}
	return uint64(int64(s) - int64(a))
}

func Xstrdup(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d uintptr
	var l Tsize_t
	_, _ = d, l
	l = Xstrlen(tls, s)
	d = Xmalloc(tls, l+uint64(1))
	if !(d != 0) {
		return UintptrFromInt32(0)
	}
	return Xmemcpy(tls, d, s, l+uint64(1))
}

func Xstrerror_r(tls *TLS, err int32, buf uintptr, buflen Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v err=%v buf=%v buflen=%v, (%v:)", tls, err, buf, buflen, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tsize_t
	var msg uintptr
	_, _ = l, msg
	msg = Xstrerror(tls, err)
	l = Xstrlen(tls, msg)
	if l >= buflen {
		if buflen != 0 {
			Xmemcpy(tls, buf, msg, buflen-uint64(1))
			*(*uint8)(unsafe.Pointer(buf + uintptr(buflen-uint64(1)))) = uint8(0)
		}
		return int32(ERANGE)
	}
	Xmemcpy(tls, buf, msg, l+uint64(1))
	return 0
}

func X__xpg_strerror_r(tls *TLS, err int32, buf uintptr, buflen Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v err=%v buf=%v buflen=%v, (%v:)", tls, err, buf, buflen, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xstrerror_r(tls, err, buf, buflen)
}

func Xstrlcat(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tsize_t
	_ = l
	l = Xstrnlen(tls, d, n)
	if l == n {
		return l + Xstrlen(tls, s)
	}
	return l + Xstrlcpy(tls, d+uintptr(l), s, n-l)
}

const ALIGN5 = -1

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xstrlcpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d0, wd, ws uintptr
	var v1 Tsize_t
	var v3, v7 uint8
	var v4, v8 bool
	_, _, _, _, _, _, _, _ = d0, wd, ws, v1, v3, v4, v7, v8
	d0 = d
	v1 = n
	n--
	if !(v1 != 0) {
		goto finish
	}
	if uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) == uint64(d)&(Uint64FromInt64(8)-Uint64FromInt32(1)) {
		for {
			if v4 = uint64(s)&(Uint64FromInt64(8)-Uint64FromInt32(1)) != 0 && n != 0; v4 {
				v3 = *(*uint8)(unsafe.Pointer(s))
				*(*uint8)(unsafe.Pointer(d)) = v3
			}
			if !(v4 && v3 != 0) {
				break
			}
			goto _2
		_2:
			;
			n--
			s++
			d++
		}
		if n != 0 && *(*uint8)(unsafe.Pointer(s)) != 0 {
			wd = d
			ws = s
			for {
				if !(n >= uint64(8) && !((*(*uint64)(unsafe.Pointer(ws))-uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(ws)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)*uint64(Int32FromInt32(UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0)) {
					break
				}
				*(*Tsize_t)(unsafe.Pointer(wd)) = *(*uint64)(unsafe.Pointer(ws))
				goto _5
			_5:
				;
				n -= uint64(8)
				ws += 8
				wd += 8
			}
			d = wd
			s = ws
		}
	}
	for {
		if v8 = n != 0; v8 {
			v7 = *(*uint8)(unsafe.Pointer(s))
			*(*uint8)(unsafe.Pointer(d)) = v7
		}
		if !(v8 && v7 != 0) {
			break
		}
		goto _6
	_6:
		;
		n--
		s++
		d++
	}
	*(*uint8)(unsafe.Pointer(d)) = uint8(0)
	goto finish
finish:
	;
	return uint64(int64(d)-int64(d0)) + Xstrlen(tls, s)
	return r
}

const ALIGN6 = 0

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xstrlen(tls *TLS, s uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, w uintptr
	_, _ = a, w
	a = s
	for {
		if !(uint64(s)%Uint64FromInt64(8) != 0) {
			break
		}
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			return uint64(int64(s) - int64(a))
		}
		goto _1
	_1:
		;
		s++
	}
	w = s
	for {
		if !!((*(*uint64)(unsafe.Pointer(w))-uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)) & ^*(*uint64)(unsafe.Pointer(w)) & (uint64(-Int32FromInt32(1))/Uint64FromInt32(UCHAR_MAX)*uint64(Int32FromInt32(UCHAR_MAX)/Int32FromInt32(2)+Int32FromInt32(1))) != 0) {
			break
		}
		goto _2
	_2:
		;
		w += 8
	}
	s = w
	for {
		if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
			break
		}
		goto _3
	_3:
		;
		s++
	}
	return uint64(int64(s) - int64(a))
}

func Xstrncasecmp(tls *TLS, _l uintptr, _r uintptr, n Tsize_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v _l=%v _r=%v n=%v, (%v:)", tls, _l, _r, n, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var l, r uintptr
	var v1 Tsize_t
	_, _, _ = l, r, v1
	l = _l
	r = _r
	v1 = n
	n--
	if !(v1 != 0) {
		return 0
	}
	for {
		if !(*(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && n != 0 && (int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r))) || Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) == Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(r)))))) {
			break
		}
		goto _2
	_2:
		;
		l++
		r++
		n--
	}
	return Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(l)))) - Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(r))))
}

func X__strncasecmp_l(tls *TLS, l uintptr, r uintptr, n Tsize_t, loc Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v n=%v loc=%v, (%v:)", tls, l, r, n, loc, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return Xstrncasecmp(tls, l, r, n)
}

func Xstrncasecmp_l(tls *TLS, l uintptr, r uintptr, n Tsize_t, loc Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v n=%v loc=%v, (%v:)", tls, l, r, n, loc, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return X__strncasecmp_l(tls, l, r, n, loc)
}

func Xstrncat(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, v1, v2, v3 uintptr
	_, _, _, _ = a, v1, v2, v3
	a = d
	d += uintptr(Xstrlen(tls, d))
	for n != 0 && *(*uint8)(unsafe.Pointer(s)) != 0 {
		n--
		v1 = d
		d++
		v2 = s
		s++
		*(*uint8)(unsafe.Pointer(v1)) = *(*uint8)(unsafe.Pointer(v2))
	}
	v3 = d
	d++
	*(*uint8)(unsafe.Pointer(v3)) = uint8(0)
	return a
}

func Xstrncmp(tls *TLS, _l uintptr, _r uintptr, n Tsize_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v _l=%v _r=%v n=%v, (%v:)", tls, _l, _r, n, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var l, r uintptr
	var v1 Tsize_t
	_, _, _ = l, r, v1
	l = _l
	r = _r
	v1 = n
	n--
	if !(v1 != 0) {
		return 0
	}
	for {
		if !(*(*uint8)(unsafe.Pointer(l)) != 0 && *(*uint8)(unsafe.Pointer(r)) != 0 && n != 0 && int32(*(*uint8)(unsafe.Pointer(l))) == int32(*(*uint8)(unsafe.Pointer(r)))) {
			break
		}
		goto _2
	_2:
		;
		l++
		r++
		n--
	}
	return int32(*(*uint8)(unsafe.Pointer(l))) - int32(*(*uint8)(unsafe.Pointer(r)))
}

func Xstrncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	X__stpncpy(tls, d, s, n)
	return d
}

func Xstrndup(tls *TLS, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v, (%v:)", tls, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d uintptr
	var l Tsize_t
	_, _ = d, l
	l = Xstrnlen(tls, s, n)
	d = Xmalloc(tls, l+uint64(1))
	if !(d != 0) {
		return UintptrFromInt32(0)
	}
	Xmemcpy(tls, d, s, l)
	*(*uint8)(unsafe.Pointer(d + uintptr(l))) = uint8(0)
	return d
}

func Xstrnlen(tls *TLS, s uintptr, n Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v, (%v:)", tls, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p uintptr
	var v1 uint64
	_, _ = p, v1
	p = Xmemchr(tls, s, 0, n)
	if p != 0 {
		v1 = uint64(int64(p) - int64(s))
	} else {
		v1 = n
	}
	return v1
}

func Xstrpbrk(tls *TLS, s uintptr, b uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v b=%v, (%v:)", tls, s, b, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 uintptr
	_ = v1
	s += uintptr(Xstrcspn(tls, s, b))
	if *(*uint8)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func Xstrrchr(tls *TLS, s uintptr, c int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__memrchr(tls, s, c, Xstrlen(tls, s)+uint64(1))
}

func Xstrsep(tls *TLS, str uintptr, sep uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v str=%v sep=%v, (%v:)", tls, str, sep, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var end, s, v1 uintptr
	_, _, _ = end, s, v1
	s = *(*uintptr)(unsafe.Pointer(str))
	if !(s != 0) {
		return UintptrFromInt32(0)
	}
	end = s + uintptr(Xstrcspn(tls, s, sep))
	if *(*uint8)(unsafe.Pointer(end)) != 0 {
		v1 = end
		end++
		*(*uint8)(unsafe.Pointer(v1)) = uint8(0)
	} else {
		end = uintptr(0)
	}
	*(*uintptr)(unsafe.Pointer(str)) = end
	return s
}

var _strings = [671]uint8{'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 's', 'i', 'g', 'n', 'a', 'l', 0, 'H', 'a', 'n', 'g', 'u', 'p', 0, 'I', 'n', 't', 'e', 'r', 'r', 'u', 'p', 't', 0, 'Q', 'u', 'i', 't', 0, 'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'i', 'n', 's', 't', 'r', 'u', 'c', 't', 'i', 'o', 'n', 0, 'T', 'r', 'a', 'c', 'e', '/', 'b', 'r', 'e', 'a', 'k', 'p', 'o', 'i', 'n', 't', ' ', 't', 'r', 'a', 'p', 0, 'A', 'b', 'o', 'r', 't', 'e', 'd', 0, 'B', 'u', 's', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'A', 'r', 'i', 't', 'h', 'm', 'e', 't', 'i', 'c', ' ', 'e', 'x', 'c', 'e', 'p', 't', 'i', 'o', 'n', 0, 'K', 'i', 'l', 'l', 'e', 'd', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'i', 'g', 'n', 'a', 'l', ' ', '1', 0, 'S', 'e', 'g', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', ' ', 'f', 'a', 'u', 'l', 't', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'i', 'g', 'n', 'a', 'l', ' ', '2', 0, 'B', 'r', 'o', 'k', 'e', 'n', ' ', 'p', 'i', 'p', 'e', 0, 'A', 'l', 'a', 'r', 'm', ' ', 'c', 'l', 'o', 'c', 'k', 0, 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'e', 'd', 0, 'S', 't', 'a', 'c', 'k', ' ', 'f', 'a', 'u', 'l', 't', 0, 'C', 'h', 'i', 'l', 'd', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', ' ', 's', 't', 'a', 't', 'u', 's', 0, 'C', 'o', 'n', 't', 'i', 'n', 'u', 'e', 'd', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 's', 'i', 'g', 'n', 'a', 'l', ')', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 't', 't', 'y', ' ', 'i', 'n', 'p', 'u', 't', ')', 0, 'S', 't', 'o', 'p', 'p', 'e', 'd', ' ', '(', 't', 't', 'y', ' ', 'o', 'u', 't', 'p', 'u', 't', ')', 0, 'U', 'r', 'g', 'e', 'n', 't', ' ', 'I', '/', 'O', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 0, 'C', 'P', 'U', ' ', 't', 'i', 'm', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'F', 'i', 'l', 'e', ' ', 's', 'i', 'z', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'V', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'i', 'm', 'e', 'r', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'P', 'r', 'o', 'f', 'i', 'l', 'i', 'n', 'g', ' ', 't', 'i', 'm', 'e', 'r', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'W', 'i', 'n', 'd', 'o', 'w', ' ', 'c', 'h', 'a', 'n', 'g', 'e', 'd', 0, 'I', '/', 'O', ' ', 'p', 'o', 's', 's', 'i', 'b', 'l', 'e', 0, 'P', 'o', 'w', 'e', 'r', ' ', 'f', 'a', 'i', 'l', 'u', 'r', 'e', 0, 'B', 'a', 'd', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'c', 'a', 'l', 'l', 0, 'R', 'T', '3', '2', 0, 'R', 'T', '3', '3', 0, 'R', 'T', '3', '4', 0, 'R', 'T', '3', '5', 0, 'R', 'T', '3', '6', 0, 'R', 'T', '3', '7', 0, 'R', 'T', '3', '8', 0, 'R', 'T', '3', '9', 0, 'R', 'T', '4', '0', 0, 'R', 'T', '4', '1', 0, 'R', 'T', '4', '2', 0, 'R', 'T', '4', '3', 0, 'R', 'T', '4', '4', 0, 'R', 'T', '4', '5', 0, 'R', 'T', '4', '6', 0, 'R', 'T', '4', '7', 0, 'R', 'T', '4', '8', 0, 'R', 'T', '4', '9', 0, 'R', 'T', '5', '0', 0, 'R', 'T', '5', '1', 0, 'R', 'T', '5', '2', 0, 'R', 'T', '5', '3', 0, 'R', 'T', '5', '4', 0, 'R', 'T', '5', '5', 0, 'R', 'T', '5', '6', 0, 'R', 'T', '5', '7', 0, 'R', 'T', '5', '8', 0, 'R', 'T', '5', '9', 0, 'R', 'T', '6', '0', 0, 'R', 'T', '6', '1', 0, 'R', 'T', '6', '2', 0, 'R', 'T', '6', '3', 0, 'R', 'T', '6', '4'}

func Xstrsignal(tls *TLS, signum int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v signum=%v, (%v:)", tls, signum, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var s uintptr
	var v2 int32
	_, _ = s, v2
	s = uintptr(unsafe.Pointer(&_strings))
	signum = signum
	if uint32(signum)-uint32(1) >= uint32(Int32FromInt32(_NSIG)-Int32FromInt32(1)) {
		signum = 0
	}
	for {
		v2 = signum
		signum--
		if !(v2 != 0) {
			break
		}
		for {
			if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
				break
			}
			goto _3
		_3:
			;
			s++
		}
		goto _1
	_1:
		;
		s++
	}
	return X__lctrans_cur(tls, s)
}

func Xstrspn(tls *TLS, s uintptr, c uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var a, p3 uintptr
	var v4 bool
	var _ /* byteset at bp+0 */ [4]Tsize_t
	_, _, _ = a, v4, p3
	a = s
	*(*[4]Tsize_t)(unsafe.Pointer(bp)) = [4]Tsize_t{}
	if !(*(*uint8)(unsafe.Pointer(c)) != 0) {
		return uint64(0)
	}
	if !(*(*uint8)(unsafe.Pointer(c + 1)) != 0) {
		for {
			if !(int32(*(*uint8)(unsafe.Pointer(s))) == int32(*(*uint8)(unsafe.Pointer(c)))) {
				break
			}
			goto _1
		_1:
			;
			s++
		}
		return uint64(int64(s) - int64(a))
	}
	for {
		if v4 = *(*uint8)(unsafe.Pointer(c)) != 0; v4 {
			p3 = bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(c)))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8
			*(*Tsize_t)(unsafe.Pointer(p3)) |= Uint64FromInt32(1) << (uint64(*(*uint8)(unsafe.Pointer(c))) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
		}
		if !(v4 && *(*Tsize_t)(unsafe.Pointer(p3)) != 0) {
			break
		}
		goto _2
	_2:
		;
		c++
	}
	for {
		if !(*(*uint8)(unsafe.Pointer(s)) != 0 && (*(*[4]Tsize_t)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(s)))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(s)))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0) {
			break
		}
		goto _5
	_5:
		;
		s++
	}
	return uint64(int64(s) - int64(a))
}

func _twobyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw, nw Tuint16_t
	var v2, v3 uintptr
	_, _, _, _ = hw, nw, v2, v3
	nw = uint16(int32(*(*uint8)(unsafe.Pointer(n)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(n + 1))))
	hw = uint16(int32(*(*uint8)(unsafe.Pointer(h)))<<int32(8) | int32(*(*uint8)(unsafe.Pointer(h + 1))))
	h++
	for {
		if !(*(*uint8)(unsafe.Pointer(h)) != 0 && int32(hw) != int32(nw)) {
			break
		}
		goto _1
	_1:
		;
		h++
		v2 = h
		hw = uint16(int32(hw)<<int32(8) | int32(*(*uint8)(unsafe.Pointer(v2))))
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(1)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _threebyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw, nw Tuint32_t
	var v2, v3 uintptr
	_, _, _, _ = hw, nw, v2, v3
	nw = uint32(*(*uint8)(unsafe.Pointer(n)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(n + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(n + 2)))<<int32(8))
	hw = uint32(*(*uint8)(unsafe.Pointer(h)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(h + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(h + 2)))<<int32(8))
	h += uintptr(2)
	for {
		if !(*(*uint8)(unsafe.Pointer(h)) != 0 && hw != nw) {
			break
		}
		goto _1
	_1:
		;
		h++
		v2 = h
		hw = (hw | uint32(*(*uint8)(unsafe.Pointer(v2)))) << int32(8)
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(2)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _fourbyte_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var hw, nw Tuint32_t
	var v2, v3 uintptr
	_, _, _, _ = hw, nw, v2, v3
	nw = uint32(*(*uint8)(unsafe.Pointer(n)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(n + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(n + 2)))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(n + 3)))
	hw = uint32(*(*uint8)(unsafe.Pointer(h)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(h + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(h + 2)))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(h + 3)))
	h += uintptr(3)
	for {
		if !(*(*uint8)(unsafe.Pointer(h)) != 0 && hw != nw) {
			break
		}
		goto _1
	_1:
		;
		h++
		v2 = h
		hw = hw<<int32(8) | uint32(*(*uint8)(unsafe.Pointer(v2)))
	}
	if *(*uint8)(unsafe.Pointer(h)) != 0 {
		v3 = h - uintptr(3)
	} else {
		v3 = uintptr(0)
	}
	return v3
}

func _twoway_strstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var grow, ip, jp, k, l, mem, mem0, ms, p, p0, v2, v3, v4, v5, v6, v7 Tsize_t
	var shift [256]Tsize_t
	var z, z2 uintptr
	var v11, v8 uint64
	var _ /* byteset at bp+0 */ [4]Tsize_t
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = grow, ip, jp, k, l, mem, mem0, ms, p, p0, shift, z, z2, v11, v2, v3, v4, v5, v6, v7, v8
	*(*[4]Tsize_t)(unsafe.Pointer(bp)) = [4]Tsize_t{}
	/* Computing length of needle and fill shift table */
	l = uint64(0)
	for {
		if !(*(*uint8)(unsafe.Pointer(n + uintptr(l))) != 0 && *(*uint8)(unsafe.Pointer(h + uintptr(l))) != 0) {
			break
		}
		*(*Tsize_t)(unsafe.Pointer(bp + uintptr(uint64(*(*uint8)(unsafe.Pointer(n + uintptr(l))))/(Uint64FromInt32(8)*Uint64FromInt64(8)))*8)) |= Uint64FromInt32(1) << (uint64(*(*uint8)(unsafe.Pointer(n + uintptr(l)))) % (Uint64FromInt32(8) * Uint64FromInt64(8)))
		shift[*(*uint8)(unsafe.Pointer(n + uintptr(l)))] = l + Uint64FromInt32(1)
		goto _1
	_1:
		;
		l++
	}
	if *(*uint8)(unsafe.Pointer(n + uintptr(l))) != 0 {
		return uintptr(0)
	} /* hit the end of h */
	/* Compute maximal suffix */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v2 = Uint64FromInt32(1)
	p = v2
	k = v2
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) > int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v3 = jp
				jp++
				ip = v3
				v4 = Uint64FromInt32(1)
				p = v4
				k = v4
			}
		}
	}
	ms = ip
	p0 = p
	/* And with the opposite comparison */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v5 = Uint64FromInt32(1)
	p = v5
	k = v5
	for jp+k < l {
		if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) == int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if int32(*(*uint8)(unsafe.Pointer(n + uintptr(ip+k)))) < int32(*(*uint8)(unsafe.Pointer(n + uintptr(jp+k)))) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v6 = jp
				jp++
				ip = v6
				v7 = Uint64FromInt32(1)
				p = v7
				k = v7
			}
		}
	}
	if ip+uint64(1) > ms+uint64(1) {
		ms = ip
	} else {
		p = p0
	}
	/* Periodic needle? */
	if Xmemcmp(tls, n, n+uintptr(p), ms+uint64(1)) != 0 {
		mem0 = uint64(0)
		if ms > l-ms-uint64(1) {
			v8 = ms
		} else {
			v8 = l - ms - uint64(1)
		}
		p = v8 + uint64(1)
	} else {
		mem0 = l - p
	}
	mem = uint64(0)
	/* Initialize incremental end-of-haystack pointer */
	z = h
	/* Search loop */
	for {
		/* Update incremental end-of-haystack pointer */
		if uint64(int64(z)-int64(h)) < l {
			/* Fast estimate for MAX(l,63) */
			grow = l | uint64(63)
			z2 = Xmemchr(tls, z, 0, grow)
			if z2 != 0 {
				z = z2
				if uint64(int64(z)-int64(h)) < l {
					return uintptr(0)
				}
			} else {
				z += uintptr(grow)
			}
		}
		/* Check last byte first; advance by shift on mismatch */
		if (*(*[4]Tsize_t)(unsafe.Pointer(bp)))[uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1)))))/(Uint64FromInt32(8)*Uint64FromInt64(8))]&(Uint64FromInt32(1)<<(uint64(*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1)))))%(Uint64FromInt32(8)*Uint64FromInt64(8)))) != 0 {
			k = l - shift[*(*uint8)(unsafe.Pointer(h + uintptr(l-uint64(1))))]
			if k != 0 {
				if k < mem {
					k = mem
				}
				h += uintptr(k)
				mem = uint64(0)
				goto _9
			}
		} else {
			h += uintptr(l)
			mem = uint64(0)
			goto _9
		}
		/* Compare right half */
		if ms+uint64(1) > mem {
			v11 = ms + uint64(1)
		} else {
			v11 = mem
		}
		k = v11
		for {
			if !(*(*uint8)(unsafe.Pointer(n + uintptr(k))) != 0 && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k)))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k))))) {
				break
			}
			goto _10
		_10:
			;
			k++
		}
		if *(*uint8)(unsafe.Pointer(n + uintptr(k))) != 0 {
			h += uintptr(k - ms)
			mem = uint64(0)
			goto _9
		}
		/* Compare left half */
		k = ms + uint64(1)
		for {
			if !(k > mem && int32(*(*uint8)(unsafe.Pointer(n + uintptr(k-uint64(1))))) == int32(*(*uint8)(unsafe.Pointer(h + uintptr(k-uint64(1)))))) {
				break
			}
			goto _12
		_12:
			;
			k--
		}
		if k <= mem {
			return h
		}
		h += uintptr(p)
		mem = mem0
		goto _9
	_9:
	}
	return r
}

func Xstrstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v h=%v n=%v, (%v:)", tls, h, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* Return immediately on empty needle */
	if !(*(*uint8)(unsafe.Pointer(n)) != 0) {
		return h
	}
	/* Use faster algorithms for short needles */
	h = Xstrchr(tls, h, int32(*(*uint8)(unsafe.Pointer(n))))
	if !(h != 0) || !(*(*uint8)(unsafe.Pointer(n + 1)) != 0) {
		return h
	}
	if !(*(*uint8)(unsafe.Pointer(h + 1)) != 0) {
		return uintptr(0)
	}
	if !(*(*uint8)(unsafe.Pointer(n + 2)) != 0) {
		return _twobyte_strstr(tls, h, n)
	}
	if !(*(*uint8)(unsafe.Pointer(h + 2)) != 0) {
		return uintptr(0)
	}
	if !(*(*uint8)(unsafe.Pointer(n + 3)) != 0) {
		return _threebyte_strstr(tls, h, n)
	}
	if !(*(*uint8)(unsafe.Pointer(h + 3)) != 0) {
		return uintptr(0)
	}
	if !(*(*uint8)(unsafe.Pointer(n + 4)) != 0) {
		return _fourbyte_strstr(tls, h, n)
	}
	return _twoway_strstr(tls, h, n)
}

func Xstrtok(tls *TLS, s uintptr, sep uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v sep=%v, (%v:)", tls, s, sep, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v3, v4 uintptr
	var v2 bool
	_, _, _, _ = v1, v2, v3, v4
	if v2 = !(s != 0); v2 {
		v1 = _p2
		s = v1
	}
	if v2 && !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	s += uintptr(Xstrspn(tls, s, sep))
	if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
		v3 = UintptrFromInt32(0)
		_p2 = v3
		return v3
	}
	_p2 = s + uintptr(Xstrcspn(tls, s, sep))
	if *(*uint8)(unsafe.Pointer(_p2)) != 0 {
		v4 = _p2
		_p2++
		*(*uint8)(unsafe.Pointer(v4)) = uint8(0)
	} else {
		_p2 = uintptr(0)
	}
	return s
}

var _p2 uintptr

func Xstrtok_r(tls *TLS, s uintptr, sep uintptr, p uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v sep=%v p=%v, (%v:)", tls, s, sep, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v3, v4, v5 uintptr
	var v2 bool
	_, _, _, _, _ = v1, v2, v3, v4, v5
	if v2 = !(s != 0); v2 {
		v1 = *(*uintptr)(unsafe.Pointer(p))
		s = v1
	}
	if v2 && !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	s += uintptr(Xstrspn(tls, s, sep))
	if !(*(*uint8)(unsafe.Pointer(s)) != 0) {
		v3 = UintptrFromInt32(0)
		*(*uintptr)(unsafe.Pointer(p)) = v3
		return v3
	}
	*(*uintptr)(unsafe.Pointer(p)) = s + uintptr(Xstrcspn(tls, s, sep))
	if *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)))) != 0 {
		v5 = p
		v4 = *(*uintptr)(unsafe.Pointer(v5))
		*(*uintptr)(unsafe.Pointer(v5))++
		*(*uint8)(unsafe.Pointer(v4)) = uint8(0)
	} else {
		*(*uintptr)(unsafe.Pointer(p)) = uintptr(0)
	}
	return s
}

func Xstrverscmp(tls *TLS, l0 uintptr, r0 uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l0=%v r0=%v, (%v:)", tls, l0, r0, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var c, z int32
	var dp, i, j, v2 Tsize_t
	var l, r uintptr
	_, _, _, _, _, _, _, _ = c, dp, i, j, l, r, z, v2
	l = l0
	r = r0
	z = int32(1)
	/* Find maximal matching prefix and track its maximal digit
	 * suffix and whether those digits are all zeros. */
	v2 = Uint64FromInt32(0)
	i = v2
	dp = v2
	for {
		if !(int32(*(*uint8)(unsafe.Pointer(l + uintptr(i)))) == int32(*(*uint8)(unsafe.Pointer(r + uintptr(i))))) {
			break
		}
		c = int32(*(*uint8)(unsafe.Pointer(l + uintptr(i))))
		if !(c != 0) {
			return 0
		}
		if !(BoolInt32(uint32(c)-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			dp = i + uint64(1)
			z = Int32FromInt32(1)
		} else {
			if c != int32('0') {
				z = 0
			}
		}
		goto _1
	_1:
		;
		i++
	}
	if uint32(int32(*(*uint8)(unsafe.Pointer(l + uintptr(dp))))-int32('1')) < uint32(9) && uint32(int32(*(*uint8)(unsafe.Pointer(r + uintptr(dp))))-int32('1')) < uint32(9) {
		/* If we're looking at non-degenerate digit sequences starting
		 * with nonzero digits, longest digit string is greater. */
		j = i
		for {
			if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(l + uintptr(j))))-uint32('0') < uint32(10)) != 0) {
				break
			}
			if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(r + uintptr(j))))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
				return int32(1)
			}
			goto _3
		_3:
			;
			j++
		}
		if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(r + uintptr(j))))-uint32('0') < uint32(10)) != 0 {
			return -int32(1)
		}
	} else {
		if z != 0 && dp < i && (BoolInt32(uint32(*(*uint8)(unsafe.Pointer(l + uintptr(i))))-uint32('0') < uint32(10)) != 0 || BoolInt32(uint32(*(*uint8)(unsafe.Pointer(r + uintptr(i))))-uint32('0') < uint32(10)) != 0) {
			/* Otherwise, if common prefix of digit sequence is
			 * all zeros, digits order less than non-digits. */
			return int32(uint8(int32(*(*uint8)(unsafe.Pointer(l + uintptr(i))))-Int32FromUint8('0'))) - int32(uint8(int32(*(*uint8)(unsafe.Pointer(r + uintptr(i))))-Int32FromUint8('0')))
		}
	}
	return int32(*(*uint8)(unsafe.Pointer(l + uintptr(i)))) - int32(*(*uint8)(unsafe.Pointer(r + uintptr(i))))
}

func Xswab(tls *TLS, _src uintptr, _dest uintptr, n Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v _src=%v _dest=%v n=%v, (%v:)", tls, _src, _dest, n, origin(2))
	}
	var dest, src uintptr
	_, _ = dest, src
	src = _src
	dest = _dest
	for {
		if !(n > int64(1)) {
			break
		}
		*(*uint8)(unsafe.Pointer(dest)) = *(*uint8)(unsafe.Pointer(src + 1))
		*(*uint8)(unsafe.Pointer(dest + 1)) = *(*uint8)(unsafe.Pointer(src))
		dest += uintptr(2)
		src += uintptr(2)
		goto _1
	_1:
		;
		n -= int64(2)
	}
}

func Xwcpcpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v, (%v:)", tls, d, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwcscpy(tls, d, s) + uintptr(Xwcslen(tls, s))*4
}

func Xwcpncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwcsncpy(tls, d, s, n) + uintptr(Xwcsnlen(tls, s, n))*4
}

func Xwcscasecmp(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v, (%v:)", tls, l, r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return Xwcsncasecmp(tls, l, r, uint64(-Int32FromInt32(1)))
}

func Xwcscasecmp_l(tls *TLS, l uintptr, r uintptr, locale Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v locale=%v, (%v:)", tls, l, r, locale, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return Xwcscasecmp(tls, l, r)
}

func Xwcscat(tls *TLS, dest uintptr, src uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v dest=%v src=%v, (%v:)", tls, dest, src, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	Xwcscpy(tls, dest+uintptr(Xwcslen(tls, dest))*4, src)
	return dest
}

func Xwcschr(tls *TLS, s uintptr, c Twchar_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v2 uintptr
	_ = v2
	if !(c != 0) {
		return s + uintptr(Xwcslen(tls, s))*4
	}
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(s)) != 0 && *(*Twchar_t)(unsafe.Pointer(s)) != c) {
			break
		}
		goto _1
	_1:
		;
		s += 4
	}
	if *(*Twchar_t)(unsafe.Pointer(s)) != 0 {
		v2 = s
	} else {
		v2 = uintptr(0)
	}
	return v2
}

func Xwcscmp(tls *TLS, l uintptr, r uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v, (%v:)", tls, l, r, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var v2 int32
	_ = v2
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(l)) == *(*Twchar_t)(unsafe.Pointer(r)) && *(*Twchar_t)(unsafe.Pointer(l)) != 0 && *(*Twchar_t)(unsafe.Pointer(r)) != 0) {
			break
		}
		goto _1
	_1:
		;
		l += 4
		r += 4
	}
	if *(*Twchar_t)(unsafe.Pointer(l)) < *(*Twchar_t)(unsafe.Pointer(r)) {
		v2 = -int32(1)
	} else {
		v2 = BoolInt32(*(*Twchar_t)(unsafe.Pointer(l)) > *(*Twchar_t)(unsafe.Pointer(r)))
	}
	return v2
}

func Xwcscpy(tls *TLS, d uintptr, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v, (%v:)", tls, d, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, v2, v3 uintptr
	var v1 Twchar_t
	_, _, _, _ = a, v1, v2, v3
	a = d
	for {
		v2 = s
		s += 4
		v1 = *(*Twchar_t)(unsafe.Pointer(v2))
		v3 = d
		d += 4
		*(*Twchar_t)(unsafe.Pointer(v3)) = v1
		if !(v1 != 0) {
			break
		}
	}
	return a
}

func Xwcscspn(tls *TLS, s uintptr, c uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, v2, v3 uintptr
	var v1 uint64
	_, _, _, _ = a, v1, v2, v3
	if !(*(*Twchar_t)(unsafe.Pointer(c)) != 0) {
		return Xwcslen(tls, s)
	}
	if !(*(*Twchar_t)(unsafe.Pointer(c + 1*4)) != 0) {
		v3 = s
		a = v3
		v2 = Xwcschr(tls, v3, *(*Twchar_t)(unsafe.Pointer(c)))
		s = v2
		if v2 != 0 {
			v1 = uint64((int64(s) - int64(a)) / 4)
		} else {
			v1 = Xwcslen(tls, a)
		}
		return v1
	}
	a = s
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(s)) != 0 && !(Xwcschr(tls, c, *(*Twchar_t)(unsafe.Pointer(s))) != 0)) {
			break
		}
		goto _4
	_4:
		;
		s += 4
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func Xwcsdup(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d uintptr
	var l Tsize_t
	_, _ = d, l
	l = Xwcslen(tls, s)
	d = Xmalloc(tls, (l+uint64(1))*uint64(4))
	if !(d != 0) {
		return UintptrFromInt32(0)
	}
	return Xwmemcpy(tls, d, s, l+uint64(1))
}

func Xwcslen(tls *TLS, s uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a uintptr
	_ = a
	a = s
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(s)) != 0) {
			break
		}
		goto _1
	_1:
		;
		s += 4
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func Xwcsncasecmp(tls *TLS, l uintptr, r uintptr, n Tsize_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v n=%v, (%v:)", tls, l, r, n, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var v1 Tsize_t
	_ = v1
	v1 = n
	n--
	if !(v1 != 0) {
		return 0
	}
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(l)) != 0 && *(*Twchar_t)(unsafe.Pointer(r)) != 0 && n != 0 && (*(*Twchar_t)(unsafe.Pointer(l)) == *(*Twchar_t)(unsafe.Pointer(r)) || Xtowlower(tls, *(*Twchar_t)(unsafe.Pointer(l))) == Xtowlower(tls, *(*Twchar_t)(unsafe.Pointer(r))))) {
			break
		}
		goto _2
	_2:
		;
		l += 4
		r += 4
		n--
	}
	return int32(Xtowlower(tls, *(*Twchar_t)(unsafe.Pointer(l))) - Xtowlower(tls, *(*Twchar_t)(unsafe.Pointer(r))))
}

func Xwcsncasecmp_l(tls *TLS, l uintptr, r uintptr, n Tsize_t, locale Tlocale_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v n=%v locale=%v, (%v:)", tls, l, r, n, locale, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	return Xwcsncasecmp(tls, l, r, n)
}

func Xwcsncat(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, v1, v2, v3 uintptr
	_, _, _, _ = a, v1, v2, v3
	a = d
	d += uintptr(Xwcslen(tls, d)) * 4
	for n != 0 && *(*Twchar_t)(unsafe.Pointer(s)) != 0 {
		n--
		v1 = d
		d += 4
		v2 = s
		s += 4
		*(*Twchar_t)(unsafe.Pointer(v1)) = *(*Twchar_t)(unsafe.Pointer(v2))
	}
	v3 = d
	d += 4
	*(*Twchar_t)(unsafe.Pointer(v3)) = uint32(0)
	return a
}

func Xwcsncmp(tls *TLS, l uintptr, r uintptr, n Tsize_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v n=%v, (%v:)", tls, l, r, n, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var v2, v3 int32
	_, _ = v2, v3
	for {
		if !(n != 0 && *(*Twchar_t)(unsafe.Pointer(l)) == *(*Twchar_t)(unsafe.Pointer(r)) && *(*Twchar_t)(unsafe.Pointer(l)) != 0 && *(*Twchar_t)(unsafe.Pointer(r)) != 0) {
			break
		}
		goto _1
	_1:
		;
		n--
		l += 4
		r += 4
	}
	if n != 0 {
		if *(*Twchar_t)(unsafe.Pointer(l)) < *(*Twchar_t)(unsafe.Pointer(r)) {
			v3 = -int32(1)
		} else {
			v3 = BoolInt32(*(*Twchar_t)(unsafe.Pointer(l)) > *(*Twchar_t)(unsafe.Pointer(r)))
		}
		v2 = v3
	} else {
		v2 = 0
	}
	return v2
}

func Xwcsncpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, v1, v2 uintptr
	_, _, _ = a, v1, v2
	a = d
	for n != 0 && *(*Twchar_t)(unsafe.Pointer(s)) != 0 {
		n--
		v1 = d
		d += 4
		v2 = s
		s += 4
		*(*Twchar_t)(unsafe.Pointer(v1)) = *(*Twchar_t)(unsafe.Pointer(v2))
	}
	Xwmemset(tls, d, uint32(0), n)
	return a
}

func Xwcsnlen(tls *TLS, s uintptr, n Tsize_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v, (%v:)", tls, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var z uintptr
	_ = z
	z = Xwmemchr(tls, s, uint32(0), n)
	if z != 0 {
		n = uint64((int64(z) - int64(s)) / 4)
	}
	return n
}

func Xwcspbrk(tls *TLS, s uintptr, b uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v b=%v, (%v:)", tls, s, b, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 uintptr
	_ = v1
	s += uintptr(Xwcscspn(tls, s, b)) * 4
	if *(*Twchar_t)(unsafe.Pointer(s)) != 0 {
		v1 = s
	} else {
		v1 = UintptrFromInt32(0)
	}
	return v1
}

func Xwcsrchr(tls *TLS, s uintptr, c Twchar_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p, v2 uintptr
	_, _ = p, v2
	p = s + uintptr(Xwcslen(tls, s))*4
	for {
		if !(p >= s && *(*Twchar_t)(unsafe.Pointer(p)) != c) {
			break
		}
		goto _1
	_1:
		;
		p -= 4
	}
	if p >= s {
		v2 = p
	} else {
		v2 = uintptr(0)
	}
	return v2
}

func Xwcsspn(tls *TLS, s uintptr, c uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v, (%v:)", tls, s, c, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a uintptr
	_ = a
	a = s
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(s)) != 0 && Xwcschr(tls, c, *(*Twchar_t)(unsafe.Pointer(s))) != 0) {
			break
		}
		goto _1
	_1:
		;
		s += 4
	}
	return uint64((int64(s) - int64(a)) / 4)
}

func _twoway_wcsstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	var grow, ip, jp, k, l, mem, mem0, ms, p, p0, v2, v3, v4, v5, v6, v7 Tsize_t
	var z, z2 uintptr
	var v11, v8 uint64
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = grow, ip, jp, k, l, mem, mem0, ms, p, p0, z, z2, v11, v2, v3, v4, v5, v6, v7, v8
	/* Computing length of needle */
	l = uint64(0)
	for {
		if !(*(*Twchar_t)(unsafe.Pointer(n + uintptr(l)*4)) != 0 && *(*Twchar_t)(unsafe.Pointer(h + uintptr(l)*4)) != 0) {
			break
		}
		goto _1
	_1:
		;
		l++
	}
	if *(*Twchar_t)(unsafe.Pointer(n + uintptr(l)*4)) != 0 {
		return uintptr(0)
	} /* hit the end of h */
	/* Compute maximal suffix */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v2 = Uint64FromInt32(1)
	p = v2
	k = v2
	for jp+k < l {
		if *(*Twchar_t)(unsafe.Pointer(n + uintptr(ip+k)*4)) == *(*Twchar_t)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if *(*Twchar_t)(unsafe.Pointer(n + uintptr(ip+k)*4)) > *(*Twchar_t)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v3 = jp
				jp++
				ip = v3
				v4 = Uint64FromInt32(1)
				p = v4
				k = v4
			}
		}
	}
	ms = ip
	p0 = p
	/* And with the opposite comparison */
	ip = uint64(-Int32FromInt32(1))
	jp = uint64(0)
	v5 = Uint64FromInt32(1)
	p = v5
	k = v5
	for jp+k < l {
		if *(*Twchar_t)(unsafe.Pointer(n + uintptr(ip+k)*4)) == *(*Twchar_t)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
			if k == p {
				jp += p
				k = uint64(1)
			} else {
				k++
			}
		} else {
			if *(*Twchar_t)(unsafe.Pointer(n + uintptr(ip+k)*4)) < *(*Twchar_t)(unsafe.Pointer(n + uintptr(jp+k)*4)) {
				jp += k
				k = uint64(1)
				p = jp - ip
			} else {
				v6 = jp
				jp++
				ip = v6
				v7 = Uint64FromInt32(1)
				p = v7
				k = v7
			}
		}
	}
	if ip+uint64(1) > ms+uint64(1) {
		ms = ip
	} else {
		p = p0
	}
	/* Periodic needle? */
	if Xwmemcmp(tls, n, n+uintptr(p)*4, ms+uint64(1)) != 0 {
		mem0 = uint64(0)
		if ms > l-ms-uint64(1) {
			v8 = ms
		} else {
			v8 = l - ms - uint64(1)
		}
		p = v8 + uint64(1)
	} else {
		mem0 = l - p
	}
	mem = uint64(0)
	/* Initialize incremental end-of-haystack pointer */
	z = h
	/* Search loop */
	for {
		/* Update incremental end-of-haystack pointer */
		if uint64((int64(z)-int64(h))/4) < l {
			/* Fast estimate for MIN(l,63) */
			grow = l | uint64(63)
			z2 = Xwmemchr(tls, z, uint32(0), grow)
			if z2 != 0 {
				z = z2
				if uint64((int64(z)-int64(h))/4) < l {
					return uintptr(0)
				}
			} else {
				z += uintptr(grow) * 4
			}
		}
		/* Compare right half */
		if ms+uint64(1) > mem {
			v11 = ms + uint64(1)
		} else {
			v11 = mem
		}
		k = v11
		for {
			if !(*(*Twchar_t)(unsafe.Pointer(n + uintptr(k)*4)) != 0 && *(*Twchar_t)(unsafe.Pointer(n + uintptr(k)*4)) == *(*Twchar_t)(unsafe.Pointer(h + uintptr(k)*4))) {
				break
			}
			goto _10
		_10:
			;
			k++
		}
		if *(*Twchar_t)(unsafe.Pointer(n + uintptr(k)*4)) != 0 {
			h += uintptr(k-ms) * 4
			mem = uint64(0)
			goto _9
		}
		/* Compare left half */
		k = ms + uint64(1)
		for {
			if !(k > mem && *(*Twchar_t)(unsafe.Pointer(n + uintptr(k-uint64(1))*4)) == *(*Twchar_t)(unsafe.Pointer(h + uintptr(k-uint64(1))*4))) {
				break
			}
			goto _12
		_12:
			;
			k--
		}
		if k <= mem {
			return h
		}
		h += uintptr(p) * 4
		mem = mem0
		goto _9
	_9:
	}
	return r
}

func Xwcsstr(tls *TLS, h uintptr, n uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v h=%v n=%v, (%v:)", tls, h, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* Return immediately on empty needle or haystack */
	if !(*(*Twchar_t)(unsafe.Pointer(n)) != 0) {
		return h
	}
	if !(*(*Twchar_t)(unsafe.Pointer(h)) != 0) {
		return uintptr(0)
	}
	/* Use faster algorithms for short needles */
	h = Xwcschr(tls, h, *(*Twchar_t)(unsafe.Pointer(n)))
	if !(h != 0) || !(*(*Twchar_t)(unsafe.Pointer(n + 1*4)) != 0) {
		return h
	}
	if !(*(*Twchar_t)(unsafe.Pointer(h + 1*4)) != 0) {
		return uintptr(0)
	}
	return _twoway_wcsstr(tls, h, n)
}

func Xwcstok(tls *TLS, s uintptr, sep uintptr, p uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v sep=%v p=%v, (%v:)", tls, s, sep, p, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1, v3, v4, v5 uintptr
	var v2 bool
	_, _, _, _, _ = v1, v2, v3, v4, v5
	if v2 = !(s != 0); v2 {
		v1 = *(*uintptr)(unsafe.Pointer(p))
		s = v1
	}
	if v2 && !(v1 != 0) {
		return UintptrFromInt32(0)
	}
	s += uintptr(Xwcsspn(tls, s, sep)) * 4
	if !(*(*Twchar_t)(unsafe.Pointer(s)) != 0) {
		v3 = UintptrFromInt32(0)
		*(*uintptr)(unsafe.Pointer(p)) = v3
		return v3
	}
	*(*uintptr)(unsafe.Pointer(p)) = s + uintptr(Xwcscspn(tls, s, sep))*4
	if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)))) != 0 {
		v5 = p
		v4 = *(*uintptr)(unsafe.Pointer(v5))
		*(*uintptr)(unsafe.Pointer(v5)) += 4
		*(*Twchar_t)(unsafe.Pointer(v4)) = uint32(0)
	} else {
		*(*uintptr)(unsafe.Pointer(p)) = uintptr(0)
	}
	return s
}

func Xwcswcs(tls *TLS, haystack uintptr, needle uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v haystack=%v needle=%v, (%v:)", tls, haystack, needle, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xwcsstr(tls, haystack, needle)
}

func Xwmemchr(tls *TLS, s uintptr, c Twchar_t, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v c=%v n=%v, (%v:)", tls, s, c, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v2 uintptr
	_ = v2
	for {
		if !(n != 0 && *(*Twchar_t)(unsafe.Pointer(s)) != c) {
			break
		}
		goto _1
	_1:
		;
		n--
		s += 4
	}
	if n != 0 {
		v2 = s
	} else {
		v2 = uintptr(0)
	}
	return v2
}

func Xwmemcmp(tls *TLS, l uintptr, r uintptr, n Tsize_t) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v l=%v r=%v n=%v, (%v:)", tls, l, r, n, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var v2, v3 int32
	_, _ = v2, v3
	for {
		if !(n != 0 && *(*Twchar_t)(unsafe.Pointer(l)) == *(*Twchar_t)(unsafe.Pointer(r))) {
			break
		}
		goto _1
	_1:
		;
		n--
		l += 4
		r += 4
	}
	if n != 0 {
		if *(*Twchar_t)(unsafe.Pointer(l)) < *(*Twchar_t)(unsafe.Pointer(r)) {
			v3 = -int32(1)
		} else {
			v3 = BoolInt32(*(*Twchar_t)(unsafe.Pointer(l)) > *(*Twchar_t)(unsafe.Pointer(r)))
		}
		v2 = v3
	} else {
		v2 = 0
	}
	return v2
}

func Xwmemcpy(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var a, v2, v3 uintptr
	var v1 Tsize_t
	_, _, _, _ = a, v1, v2, v3
	a = d
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		v2 = d
		d += 4
		v3 = s
		s += 4
		*(*Twchar_t)(unsafe.Pointer(v2)) = *(*Twchar_t)(unsafe.Pointer(v3))
	}
	return a
}

func Xwmemmove(tls *TLS, d uintptr, s uintptr, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v s=%v n=%v, (%v:)", tls, d, s, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var d0, v3, v4 uintptr
	var v1, v2 Tsize_t
	_, _, _, _, _ = d0, v1, v2, v3, v4
	d0 = d
	if d == s {
		return d
	}
	if uint64(d)-uint64(s) < n*uint64(4) {
		for {
			v1 = n
			n--
			if !(v1 != 0) {
				break
			}
			*(*Twchar_t)(unsafe.Pointer(d + uintptr(n)*4)) = *(*Twchar_t)(unsafe.Pointer(s + uintptr(n)*4))
		}
	} else {
		for {
			v2 = n
			n--
			if !(v2 != 0) {
				break
			}
			v3 = d
			d += 4
			v4 = s
			s += 4
			*(*Twchar_t)(unsafe.Pointer(v3)) = *(*Twchar_t)(unsafe.Pointer(v4))
		}
	}
	return d0
}

func Xwmemset(tls *TLS, d uintptr, c Twchar_t, n Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v d=%v c=%v n=%v, (%v:)", tls, d, c, n, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret, v2 uintptr
	var v1 Tsize_t
	_, _, _ = ret, v1, v2
	ret = d
	for {
		v1 = n
		n--
		if !(v1 != 0) {
			break
		}
		v2 = d
		d += 4
		*(*Twchar_t)(unsafe.Pointer(v2)) = c
	}
	return ret
}

func Xmkdtemp(tls *TLS, template uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v template=%v, (%v:)", tls, template, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var l Tsize_t
	var retries, v1 int32
	_, _, _ = l, retries, v1
	l = Xstrlen(tls, template)
	retries = int32(100)
	if l < uint64(6) || Xmemcmp(tls, template+uintptr(l)-uintptr(6), __ccgo_ts+1730, uint64(6)) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return uintptr(0)
	}
	for {
		___randname(tls, template+uintptr(l)-uintptr(6))
		if !(Xmkdir(tls, template, uint32(0700)) != 0) {
			return template
		}
		goto _2
	_2:
		;
		retries--
		v1 = retries
		if !(v1 != 0 && *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EEXIST)) {
			break
		}
	}
	Xmemcpy(tls, template+uintptr(l)-uintptr(6), __ccgo_ts+1730, uint64(6))
	return uintptr(0)
}

func Xmkostemp(tls *TLS, template uintptr, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v template=%v flags=%v, (%v:)", tls, template, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__mkostemps(tls, template, 0, flags)
}

func X__mkostemps(tls *TLS, template uintptr, len1 int32, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v template=%v len1=%v flags=%v, (%v:)", tls, template, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var fd, retries, v1, v3 int32
	var l Tsize_t
	_, _, _, _, _ = fd, l, retries, v1, v3
	l = Xstrlen(tls, template)
	if l < uint64(6) || uint64(len1) > l-uint64(6) || Xmemcmp(tls, template+uintptr(l)-uintptr(len1)-uintptr(6), __ccgo_ts+1730, uint64(6)) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	flags -= flags & (Int32FromInt32(03) | Int32FromInt32(O_PATH))
	retries = int32(100)
	for {
		___randname(tls, template+uintptr(l)-uintptr(len1)-uintptr(6))
		v3 = Xopen(tls, template, flags|int32(O_RDWR)|int32(O_CREAT)|int32(O_EXCL), VaList(bp+8, int32(0600)))
		fd = v3
		if v3 >= 0 {
			return fd
		}
		goto _2
	_2:
		;
		retries--
		v1 = retries
		if !(v1 != 0 && *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EEXIST)) {
			break
		}
	}
	Xmemcpy(tls, template+uintptr(l)-uintptr(len1)-uintptr(6), __ccgo_ts+1730, uint64(6))
	return -int32(1)
}

func Xmkostemps(tls *TLS, template uintptr, len1 int32, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v template=%v len1=%v flags=%v, (%v:)", tls, template, len1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__mkostemps(tls, template, len1, flags)
}

func Xmkstemp(tls *TLS, template uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v template=%v, (%v:)", tls, template, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__mkostemps(tls, template, 0, 0)
}

func Xmkstemps(tls *TLS, template uintptr, len1 int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v template=%v len1=%v, (%v:)", tls, template, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__mkostemps(tls, template, len1, 0)
}

func Xmktemp(tls *TLS, template uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v template=%v, (%v:)", tls, template, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var l Tsize_t
	var retries, v1 int32
	var _ /* st at bp+0 */ Tstat
	_, _, _ = l, retries, v1
	l = Xstrlen(tls, template)
	retries = int32(100)
	if l < uint64(6) || Xmemcmp(tls, template+uintptr(l)-uintptr(6), __ccgo_ts+1730, uint64(6)) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		*(*uint8)(unsafe.Pointer(template)) = uint8(0)
		return template
	}
	for {
		___randname(tls, template+uintptr(l)-uintptr(6))
		if Xstat(tls, template, bp) != 0 {
			if *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(ENOENT) {
				*(*uint8)(unsafe.Pointer(template)) = uint8(0)
			}
			return template
		}
		goto _2
	_2:
		;
		retries--
		v1 = retries
		if !(v1 != 0) {
			break
		}
	}
	*(*uint8)(unsafe.Pointer(template)) = uint8(0)
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EEXIST)
	return template
}

func Xcfgetospeed(tls *TLS, tio uintptr) (r Tspeed_t) {
	if __ccgo_strace {
		trc("tls=%v tio=%v, (%v:)", tls, tio, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return (*Ttermios)(unsafe.Pointer(tio)).Fc_cflag & uint32(CBAUD)
}

func Xcfgetispeed(tls *TLS, tio uintptr) (r Tspeed_t) {
	if __ccgo_strace {
		trc("tls=%v tio=%v, (%v:)", tls, tio, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcfgetospeed(tls, tio)
}

func Xcfmakeraw(tls *TLS, t uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v, (%v:)", tls, t, origin(2))
	}
	*(*Ttcflag_t)(unsafe.Pointer(t)) &= uint32(^(Int32FromInt32(IGNBRK) | Int32FromInt32(BRKINT) | Int32FromInt32(PARMRK) | Int32FromInt32(ISTRIP) | Int32FromInt32(INLCR) | Int32FromInt32(IGNCR) | Int32FromInt32(ICRNL) | Int32FromInt32(IXON)))
	*(*Ttcflag_t)(unsafe.Pointer(t + 4)) &= uint32(^Int32FromInt32(OPOST))
	*(*Ttcflag_t)(unsafe.Pointer(t + 12)) &= uint32(^(Int32FromInt32(ECHO) | Int32FromInt32(ECHONL) | Int32FromInt32(ICANON) | Int32FromInt32(ISIG) | Int32FromInt32(IEXTEN)))
	*(*Ttcflag_t)(unsafe.Pointer(t + 8)) &= uint32(^(Int32FromInt32(CSIZE) | Int32FromInt32(PARENB)))
	*(*Ttcflag_t)(unsafe.Pointer(t + 8)) |= uint32(CS8)
	*(*Tcc_t)(unsafe.Pointer(t + 17 + 6)) = uint8(1)
	*(*Tcc_t)(unsafe.Pointer(t + 17 + 5)) = uint8(0)
}

func Xcfsetospeed(tls *TLS, tio uintptr, speed Tspeed_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v tio=%v speed=%v, (%v:)", tls, tio, speed, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if speed&uint32(^Int32FromInt32(CBAUD)) != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	*(*Ttcflag_t)(unsafe.Pointer(tio + 8)) &= uint32(^Int32FromInt32(CBAUD))
	*(*Ttcflag_t)(unsafe.Pointer(tio + 8)) |= speed
	return 0
}

func Xcfsetispeed(tls *TLS, tio uintptr, speed Tspeed_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v tio=%v speed=%v, (%v:)", tls, tio, speed, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 int32
	_ = v1
	if speed != 0 {
		v1 = Xcfsetospeed(tls, tio, speed)
	} else {
		v1 = 0
	}
	return v1
}

func Xcfsetspeed(tls *TLS, tio uintptr, speed Tspeed_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v tio=%v speed=%v, (%v:)", tls, tio, speed, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xcfsetospeed(tls, tio, speed)
}

func Xtcdrain(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_ioctl), int64(fd), int64(Int32FromInt32(TCSBRK)), int64(Int32FromInt32(1)), 0, 0, 0))))
}

func Xtcflow(tls *TLS, fd int32, action int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v action=%v, (%v:)", tls, fd, action, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	return Xioctl(tls, fd, int32(TCXONC), VaList(bp+8, action))
}

func Xtcflush(tls *TLS, fd int32, queue int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v queue=%v, (%v:)", tls, fd, queue, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	return Xioctl(tls, fd, int32(TCFLSH), VaList(bp+8, queue))
}

func Xtcgetattr(tls *TLS, fd int32, tio uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v tio=%v, (%v:)", tls, fd, tio, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	if Xioctl(tls, fd, int32(TCGETS), VaList(bp+8, tio)) != 0 {
		return -int32(1)
	}
	return 0
}

func Xtcgetsid(tls *TLS, fd int32) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* sid at bp+0 */ int32
	if Xioctl(tls, fd, int32(TIOCGSID), VaList(bp+16, bp)) < 0 {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func Xtcgetwinsize(tls *TLS, fd int32, wsz uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v wsz=%v, (%v:)", tls, fd, wsz, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_ioctl), int64(fd), int64(Int32FromInt32(TIOCGWINSZ)), int64(wsz)))))
}

func Xtcsendbreak(tls *TLS, fd int32, dur int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v dur=%v, (%v:)", tls, fd, dur, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	/* nonzero duration is implementation-defined, so ignore it */
	return Xioctl(tls, fd, int32(TCSBRK), VaList(bp+8, 0))
}

func Xtcsetattr(tls *TLS, fd int32, act int32, tio uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v act=%v tio=%v, (%v:)", tls, fd, act, tio, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	if act < 0 || act > int32(2) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
		return -int32(1)
	}
	return Xioctl(tls, fd, int32(TCSETS)+act, VaList(bp+8, tio))
}

func Xtcsetwinsize(tls *TLS, fd int32, wsz uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v wsz=%v, (%v:)", tls, fd, wsz, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_ioctl), int64(fd), int64(Int32FromInt32(TIOCSWINSZ)), int64(wsz)))))
}

func X__map_file(tls *TLS, pathname uintptr, size uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v pathname=%v size=%v, (%v:)", tls, pathname, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var fd int32
	var map1, v1 uintptr
	var _ /* st at bp+0 */ Tstat
	_, _, _ = fd, map1, v1
	map1 = uintptr(-Int32FromInt32(1))
	fd = int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_openat), int64(-Int32FromInt32(100)), int64(pathname), int64(Int32FromInt32(O_RDONLY)|Int32FromInt32(O_CLOEXEC)|Int32FromInt32(O_NONBLOCK)|Int32FromInt32(O_LARGEFILE))))))
	if fd < 0 {
		return uintptr(0)
	}
	if !(X__fstat(tls, fd, bp) != 0) {
		map1 = X__mmap(tls, uintptr(0), uint64((*(*Tstat)(unsafe.Pointer(bp))).Fst_size), int32(PROT_READ), int32(MAP_SHARED), fd, 0)
		*(*Tsize_t)(unsafe.Pointer(size)) = uint64((*(*Tstat)(unsafe.Pointer(bp))).Fst_size)
	}
	X__syscall1(tls, int64(SYS_close), int64(fd))
	if map1 == uintptr(-Int32FromInt32(1)) {
		v1 = uintptr(0)
	} else {
		v1 = map1
	}
	return v1
}

func X__month_to_secs(tls *TLS, month int32, is_leap int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v month=%v is_leap=%v, (%v:)", tls, month, is_leap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var t int32
	_ = t
	t = _secs_through_month[month]
	if is_leap != 0 && month >= int32(2) {
		t += int32(86400)
	}
	return t
}

var _secs_through_month = [12]int32{
	1:  Int32FromInt32(31) * Int32FromInt32(86400),
	2:  Int32FromInt32(59) * Int32FromInt32(86400),
	3:  Int32FromInt32(90) * Int32FromInt32(86400),
	4:  Int32FromInt32(120) * Int32FromInt32(86400),
	5:  Int32FromInt32(151) * Int32FromInt32(86400),
	6:  Int32FromInt32(181) * Int32FromInt32(86400),
	7:  Int32FromInt32(212) * Int32FromInt32(86400),
	8:  Int32FromInt32(243) * Int32FromInt32(86400),
	9:  Int32FromInt32(273) * Int32FromInt32(86400),
	10: Int32FromInt32(304) * Int32FromInt32(86400),
	11: Int32FromInt32(334) * Int32FromInt32(86400),
}

const DAYS_PER_100Y = 36524
const DAYS_PER_400Y = 146097
const DAYS_PER_4Y = 1461
const LEAPOCH = 951868800

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

/* 2000-03-01 (mod 400 year, immediately after feb29 */

func X__secs_to_tm(tls *TLS, t int64, tm uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v t=%v tm=%v, (%v:)", tls, t, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var c_cycles, leap, months, q_cycles, qc_cycles, remdays, remsecs, remyears, wday, yday int32
	var days, secs, years int64
	_, _, _, _, _, _, _, _, _, _, _, _, _ = c_cycles, days, leap, months, q_cycles, qc_cycles, remdays, remsecs, remyears, secs, wday, yday, years
	/* Reject time_t values whose year would overflow int */
	if t < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff))*Int64FromInt64(31622400) || t > Int64FromInt32(INT_MAX)*Int64FromInt64(31622400) {
		return -int32(1)
	}
	secs = t - (Int64FromInt64(946684800) + int64(Int32FromInt32(86400)*(Int32FromInt32(31)+Int32FromInt32(29))))
	days = secs / int64(86400)
	remsecs = int32(secs % int64(86400))
	if remsecs < 0 {
		remsecs += int32(86400)
		days--
	}
	wday = int32((int64(3) + days) % int64(7))
	if wday < 0 {
		wday += int32(7)
	}
	qc_cycles = int32(days / int64(Int32FromInt32(365)*Int32FromInt32(400)+Int32FromInt32(97)))
	remdays = int32(days % int64(Int32FromInt32(365)*Int32FromInt32(400)+Int32FromInt32(97)))
	if remdays < 0 {
		remdays += Int32FromInt32(365)*Int32FromInt32(400) + Int32FromInt32(97)
		qc_cycles--
	}
	c_cycles = remdays / (Int32FromInt32(365)*Int32FromInt32(100) + Int32FromInt32(24))
	if c_cycles == int32(4) {
		c_cycles--
	}
	remdays -= c_cycles * (Int32FromInt32(365)*Int32FromInt32(100) + Int32FromInt32(24))
	q_cycles = remdays / (Int32FromInt32(365)*Int32FromInt32(4) + Int32FromInt32(1))
	if q_cycles == int32(25) {
		q_cycles--
	}
	remdays -= q_cycles * (Int32FromInt32(365)*Int32FromInt32(4) + Int32FromInt32(1))
	remyears = remdays / int32(365)
	if remyears == int32(4) {
		remyears--
	}
	remdays -= remyears * int32(365)
	leap = BoolInt32(!(remyears != 0) && (q_cycles != 0 || !(c_cycles != 0)))
	yday = remdays + int32(31) + int32(28) + leap
	if yday >= int32(365)+leap {
		yday -= int32(365) + leap
	}
	years = int64(remyears+int32(4)*q_cycles+int32(100)*c_cycles) + int64(400)*int64(qc_cycles)
	months = 0
	for {
		if !(int32(_days_in_month[months]) <= remdays) {
			break
		}
		remdays -= int32(_days_in_month[months])
		goto _1
	_1:
		;
		months++
	}
	if months >= int32(10) {
		months -= int32(12)
		years++
	}
	if years+int64(100) > int64(INT_MAX) || years+int64(100) < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)) {
		return -int32(1)
	}
	(*Ttm)(unsafe.Pointer(tm)).Ftm_year = int32(years + int64(100))
	(*Ttm)(unsafe.Pointer(tm)).Ftm_mon = months + int32(2)
	(*Ttm)(unsafe.Pointer(tm)).Ftm_mday = remdays + int32(1)
	(*Ttm)(unsafe.Pointer(tm)).Ftm_wday = wday
	(*Ttm)(unsafe.Pointer(tm)).Ftm_yday = yday
	(*Ttm)(unsafe.Pointer(tm)).Ftm_hour = remsecs / int32(3600)
	(*Ttm)(unsafe.Pointer(tm)).Ftm_min = remsecs / int32(60) % int32(60)
	(*Ttm)(unsafe.Pointer(tm)).Ftm_sec = remsecs % int32(60)
	return 0
}

var _days_in_month = [12]uint8{
	0:  uint8(31),
	1:  uint8(30),
	2:  uint8(31),
	3:  uint8(30),
	4:  uint8(31),
	5:  uint8(31),
	6:  uint8(30),
	7:  uint8(31),
	8:  uint8(30),
	9:  uint8(31),
	10: uint8(31),
	11: uint8(29),
}

func X__tm_to_secs(tls *TLS, tm uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v tm=%v, (%v:)", tls, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var adj, month int32
	var t, year int64
	var _ /* is_leap at bp+0 */ int32
	_, _, _, _ = adj, month, t, year
	year = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year)
	month = (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
	if month >= int32(12) || month < 0 {
		adj = month / int32(12)
		month %= int32(12)
		if month < 0 {
			adj--
			month += int32(12)
		}
		year += int64(adj)
	}
	t = X__year_to_secs(tls, year, bp)
	t += int64(X__month_to_secs(tls, month, *(*int32)(unsafe.Pointer(bp))))
	t += int64(86400) * int64((*Ttm)(unsafe.Pointer(tm)).Ftm_mday-Int32FromInt32(1))
	t += int64(3600) * int64((*Ttm)(unsafe.Pointer(tm)).Ftm_hour)
	t += int64(60) * int64((*Ttm)(unsafe.Pointer(tm)).Ftm_min)
	t += int64((*Ttm)(unsafe.Pointer(tm)).Ftm_sec)
	return t
}

var _std_name [7]uint8
var _dst_name [7]uint8

var _dst_off int32
var _r0 [5]int32
var _r12 [5]int32

var _zi uintptr
var _trans uintptr
var _index uintptr
var _types uintptr
var _abbrevs uintptr
var _abbrevs_end uintptr
var _map_size Tsize_t

var _old_tz_buf [32]uint8
var _old_tz = uintptr(unsafe.Pointer(&_old_tz_buf))
var _old_tz_size = uint64(32)

var _lock4 [1]int32

func _getint2(tls *TLS, p uintptr) (r int32) {
	var x uint32
	_ = x
	x = uint32(0)
	for {
		if !(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)))))-int32('0')) < uint32(10)) {
			break
		}
		x = uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)))))-int32('0')) + uint32(10)*x
		goto _1
	_1:
		;
		*(*uintptr)(unsafe.Pointer(p))++
	}
	return int32(x)
}

func _getoff(tls *TLS, p uintptr) (r int32) {
	var neg, off, v1 int32
	_, _, _ = neg, off, v1
	neg = 0
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p))))) == int32('-') {
		*(*uintptr)(unsafe.Pointer(p))++
		neg = int32(1)
	} else {
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p))))) == int32('+') {
			*(*uintptr)(unsafe.Pointer(p))++
		}
	}
	off = int32(3600) * _getint2(tls, p)
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p))))) == int32(':') {
		*(*uintptr)(unsafe.Pointer(p))++
		off += int32(60) * _getint2(tls, p)
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p))))) == int32(':') {
			*(*uintptr)(unsafe.Pointer(p))++
			off += _getint2(tls, p)
		}
	}
	if neg != 0 {
		v1 = -off
	} else {
		v1 = off
	}
	return v1
}

func _getrule(tls *TLS, p uintptr, rule uintptr) {
	var r, v1 int32
	_, _ = r, v1
	v1 = int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)))))
	*(*int32)(unsafe.Pointer(rule)) = v1
	r = v1
	if r != int32('M') {
		if r == int32('J') {
			*(*uintptr)(unsafe.Pointer(p))++
		} else {
			*(*int32)(unsafe.Pointer(rule)) = 0
		}
		*(*int32)(unsafe.Pointer(rule + 1*4)) = _getint2(tls, p)
	} else {
		*(*uintptr)(unsafe.Pointer(p))++
		*(*int32)(unsafe.Pointer(rule + 1*4)) = _getint2(tls, p)
		*(*uintptr)(unsafe.Pointer(p))++
		*(*int32)(unsafe.Pointer(rule + 2*4)) = _getint2(tls, p)
		*(*uintptr)(unsafe.Pointer(p))++
		*(*int32)(unsafe.Pointer(rule + 3*4)) = _getint2(tls, p)
	}
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p))))) == int32('/') {
		*(*uintptr)(unsafe.Pointer(p))++
		*(*int32)(unsafe.Pointer(rule + 4*4)) = _getoff(tls, p)
	} else {
		*(*int32)(unsafe.Pointer(rule + 4*4)) = int32(7200)
	}
}

func _getname(tls *TLS, d uintptr, p uintptr) {
	var i, v3 int32
	_, _ = i, v3
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p))))) == int32('<') {
		*(*uintptr)(unsafe.Pointer(p))++
		i = 0
		for {
			if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)) + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)) + uintptr(i)))) != int32('>')) {
				break
			}
			if i < int32(TZNAME_MAX) {
				*(*uint8)(unsafe.Pointer(d + uintptr(i))) = *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)) + uintptr(i)))
			}
			goto _1
		_1:
			;
			i++
		}
		if *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)) + uintptr(i))) != 0 {
			*(*uintptr)(unsafe.Pointer(p))++
		}
	} else {
		i = 0
		for {
			if !(uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)) + uintptr(i))))|int32(32)-int32('a')) < uint32(26)) {
				break
			}
			if i < int32(TZNAME_MAX) {
				*(*uint8)(unsafe.Pointer(d + uintptr(i))) = *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(p)) + uintptr(i)))
			}
			goto _2
		_2:
			;
			i++
		}
	}
	*(*uintptr)(unsafe.Pointer(p)) += uintptr(i)
	if i < int32(TZNAME_MAX) {
		v3 = i
	} else {
		v3 = int32(TZNAME_MAX)
	}
	*(*uint8)(unsafe.Pointer(d + uintptr(v3))) = uint8(0)
}

func _zi_read32(tls *TLS, z uintptr) (r Tuint32_t) {
	return uint32(*(*uint8)(unsafe.Pointer(z)))<<int32(24) | uint32(int32(*(*uint8)(unsafe.Pointer(z + 1)))<<int32(16)) | uint32(int32(*(*uint8)(unsafe.Pointer(z + 2)))<<int32(8)) | uint32(*(*uint8)(unsafe.Pointer(z + 3)))
}

func _zi_dotprod(tls *TLS, z uintptr, v uintptr, n Tsize_t) (r Tsize_t) {
	var x Tuint32_t
	var y Tsize_t
	_, _ = x, y
	y = uint64(0)
	for {
		if !(n != 0) {
			break
		}
		x = _zi_read32(tls, z)
		y += uint64(x * uint32(*(*uint8)(unsafe.Pointer(v))))
		goto _1
	_1:
		;
		n--
		z += uintptr(4)
		v++
	}
	return y
}

func _do_tzset(tls *TLS) {
	bp := tls.Alloc(320)
	defer tls.Free(320)
	var i, l, skip Tsize_t
	var map1, p1, pathname, try, v5 uintptr
	var posix_form, scale, v2, v7 int32
	var v6 int64
	var _ /* buf at bp+6 */ [280]uint8
	var _ /* dummy_name at bp+308 */ [7]uint8
	var _ /* p at bp+296 */ uintptr
	var _ /* s at bp+288 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _ = i, l, map1, p1, pathname, posix_form, scale, skip, try, v2, v5, v6, v7
	pathname = bp + 6 + uintptr(24)
	map1 = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 288)) = Xgetenv(tls, __ccgo_ts+1737)
	if !(*(*uintptr)(unsafe.Pointer(bp + 288)) != 0) {
		*(*uintptr)(unsafe.Pointer(bp + 288)) = __ccgo_ts + 1740
	}
	if !(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288)))) != 0) {
		*(*uintptr)(unsafe.Pointer(bp + 288)) = uintptr(unsafe.Pointer(&X__utc))
	}
	if _old_tz != 0 && !(Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(bp + 288)), _old_tz) != 0) {
		return
	}
	i = uint64(0)
	for {
		if !(i < uint64(5)) {
			break
		}
		v2 = Int32FromInt32(0)
		_r12[i] = v2
		_r0[i] = v2
		goto _1
	_1:
		;
		i++
	}
	if _zi != 0 {
		X__munmap(tls, _zi, _map_size)
	}
	/* Cache the old value of TZ to check if it has changed. Avoid
	 * free so as not to pull it into static programs. Growth
	 * strategy makes it so free would have minimal benefit anyway. */
	i = Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 288)))
	if i > uint64(Int32FromInt32(PATH_MAX)+Int32FromInt32(1)) {
		*(*uintptr)(unsafe.Pointer(bp + 288)) = uintptr(unsafe.Pointer(&X__utc))
		i = Uint64FromInt32(3)
	}
	if i >= _old_tz_size {
		_old_tz_size *= uint64(2)
		if i >= _old_tz_size {
			_old_tz_size = i + uint64(1)
		}
		if _old_tz_size > uint64(Int32FromInt32(PATH_MAX)+Int32FromInt32(2)) {
			_old_tz_size = uint64(Int32FromInt32(PATH_MAX) + Int32FromInt32(2))
		}
		_old_tz = Xmalloc(tls, _old_tz_size)
	}
	if _old_tz != 0 {
		Xmemcpy(tls, _old_tz, *(*uintptr)(unsafe.Pointer(bp + 288)), i+uint64(1))
	}
	posix_form = 0
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) != int32(':') {
		*(*uintptr)(unsafe.Pointer(bp + 296)) = *(*uintptr)(unsafe.Pointer(bp + 288))
		_getname(tls, bp+308, bp+296)
		if *(*uintptr)(unsafe.Pointer(bp + 296)) != *(*uintptr)(unsafe.Pointer(bp + 288)) && (int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296))))) == int32('+') || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296))))) == int32('-') || BoolInt32(uint32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296)))))-uint32('0') < uint32(10)) != 0 || !(Xstrcmp(tls, bp+308, __ccgo_ts+1755) != 0) || !(Xstrcmp(tls, bp+308, __ccgo_ts+1759) != 0)) {
			posix_form = int32(1)
		}
	}
	/* Non-suid can use an absolute tzfile pathname or a relative
	 * pathame beginning with "."; in secure mode, only the
	 * standard path will be searched. */
	if !(posix_form != 0) {
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) == int32(':') {
			*(*uintptr)(unsafe.Pointer(bp + 288))++
		}
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) == int32('/') || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) == int32('.') {
			if !(X__libc.Fsecure != 0) || !(Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(bp + 288)), __ccgo_ts+1740) != 0) {
				map1 = X__map_file(tls, *(*uintptr)(unsafe.Pointer(bp + 288)), uintptr(unsafe.Pointer(&_map_size)))
			}
		} else {
			l = Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 288)))
			if l <= uint64(NAME_MAX) && !(Xstrchr(tls, *(*uintptr)(unsafe.Pointer(bp + 288)), int32('.')) != 0) {
				Xmemcpy(tls, pathname, *(*uintptr)(unsafe.Pointer(bp + 288)), l+uint64(1))
				*(*uint8)(unsafe.Pointer(pathname + uintptr(l))) = uint8(0)
				try = uintptr(unsafe.Pointer(&_search))
				for {
					if !(!(map1 != 0) && *(*uint8)(unsafe.Pointer(try)) != 0) {
						break
					}
					l = Xstrlen(tls, try)
					Xmemcpy(tls, pathname-uintptr(l), try, l)
					map1 = X__map_file(tls, pathname-uintptr(l), uintptr(unsafe.Pointer(&_map_size)))
					goto _3
				_3:
					;
					try += uintptr(l + uint64(1))
				}
			}
		}
		if !(map1 != 0) {
			*(*uintptr)(unsafe.Pointer(bp + 288)) = uintptr(unsafe.Pointer(&X__utc))
		}
	}
	if map1 != 0 && (_map_size < uint64(44) || Xmemcmp(tls, map1, __ccgo_ts+1763, uint64(4)) != 0) {
		X__munmap(tls, map1, _map_size)
		map1 = uintptr(0)
		*(*uintptr)(unsafe.Pointer(bp + 288)) = uintptr(unsafe.Pointer(&X__utc))
	}
	_zi = map1
	if map1 != 0 {
		scale = int32(2)
		if int32(*(*uint8)(unsafe.Pointer(map1 + 4))) != int32('1') {
			*(*[6]uint8)(unsafe.Pointer(bp)) = [6]uint8{
				0: uint8(1),
				1: uint8(1),
				2: uint8(8),
				3: uint8(5),
				4: uint8(6),
				5: uint8(1),
			}
			skip = _zi_dotprod(tls, _zi+uintptr(20), bp, uint64(6))
			_trans = _zi + uintptr(skip) + uintptr(44) + uintptr(44)
			scale++
		} else {
			_trans = _zi + uintptr(44)
		}
		_index = _trans + uintptr(_zi_read32(tls, _trans-uintptr(12))<<scale)
		_types = _index + uintptr(_zi_read32(tls, _trans-uintptr(12)))
		_abbrevs = _types + uintptr(uint32(6)*_zi_read32(tls, _trans-uintptr(8)))
		_abbrevs_end = _abbrevs + uintptr(_zi_read32(tls, _trans-uintptr(4)))
		if int32(*(*uint8)(unsafe.Pointer(_zi + uintptr(_map_size-uint64(1))))) == int32('\n') {
			*(*uintptr)(unsafe.Pointer(bp + 288)) = _zi + uintptr(_map_size) - uintptr(2)
			for {
				if !(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) != int32('\n')) {
					break
				}
				goto _4
			_4:
				;
				*(*uintptr)(unsafe.Pointer(bp + 288))--
			}
			*(*uintptr)(unsafe.Pointer(bp + 288))++
		} else {
			v5 = UintptrFromInt32(0)
			Xtzname[int32(1)] = v5
			Xtzname[0] = v5
			v7 = Int32FromInt32(0)
			_dst_off = v7
			v6 = int64(v7)
			Xtimezone = v6
			Xdaylight = int32(v6)
			p1 = _types
			for {
				if !(p1 < _abbrevs) {
					break
				}
				if !(*(*uint8)(unsafe.Pointer(p1 + 4)) != 0) && !(Xtzname[0] != 0) {
					Xtzname[0] = _abbrevs + uintptr(*(*uint8)(unsafe.Pointer(p1 + 5)))
					Xtimezone = int64(-_zi_read32(tls, p1))
				}
				if *(*uint8)(unsafe.Pointer(p1 + 4)) != 0 && !(Xtzname[int32(1)] != 0) {
					Xtzname[int32(1)] = _abbrevs + uintptr(*(*uint8)(unsafe.Pointer(p1 + 5)))
					_dst_off = int32(-_zi_read32(tls, p1))
					Xdaylight = int32(1)
				}
				goto _8
			_8:
				;
				p1 += uintptr(6)
			}
			if !(Xtzname[0] != 0) {
				Xtzname[0] = Xtzname[int32(1)]
			}
			if !(Xtzname[0] != 0) {
				Xtzname[0] = uintptr(unsafe.Pointer(&X__utc))
			}
			if !(Xdaylight != 0) {
				Xtzname[int32(1)] = Xtzname[0]
				_dst_off = int32(Xtimezone)
			}
			return
		}
	}
	if !(*(*uintptr)(unsafe.Pointer(bp + 288)) != 0) {
		*(*uintptr)(unsafe.Pointer(bp + 288)) = uintptr(unsafe.Pointer(&X__utc))
	}
	_getname(tls, uintptr(unsafe.Pointer(&_std_name)), bp+288)
	Xtzname[0] = uintptr(unsafe.Pointer(&_std_name))
	Xtimezone = int64(_getoff(tls, bp+288))
	_getname(tls, uintptr(unsafe.Pointer(&_dst_name)), bp+288)
	Xtzname[int32(1)] = uintptr(unsafe.Pointer(&_dst_name))
	if _dst_name[0] != 0 {
		Xdaylight = int32(1)
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) == int32('+') || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) == int32('-') || uint32(int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288)))))-int32('0')) < uint32(10) {
			_dst_off = _getoff(tls, bp+288)
		} else {
			_dst_off = int32(Xtimezone - int64(3600))
		}
	} else {
		Xdaylight = 0
		_dst_off = int32(Xtimezone)
	}
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) == int32(',') {
		*(*uintptr)(unsafe.Pointer(bp + 288))++
		_getrule(tls, bp+288, uintptr(unsafe.Pointer(&_r0)))
	}
	if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 288))))) == int32(',') {
		*(*uintptr)(unsafe.Pointer(bp + 288))++
		_getrule(tls, bp+288, uintptr(unsafe.Pointer(&_r12)))
	}
}

var _search = [54]uint8{'/', 'u', 's', 'r', '/', 's', 'h', 'a', 'r', 'e', '/', 'z', 'o', 'n', 'e', 'i', 'n', 'f', 'o', '/', 0, '/', 's', 'h', 'a', 'r', 'e', '/', 'z', 'o', 'n', 'e', 'i', 'n', 'f', 'o', '/', 0, '/', 'e', 't', 'c', '/', 'z', 'o', 'n', 'e', 'i', 'n', 'f', 'o', '/'}

/* Search zoneinfo rules to find the one that applies to the given time,
 * and determine alternate opposite-DST-status rule that may be needed. */

func _scan_trans(tls *TLS, t int64, local int32, alt uintptr) (r Tsize_t) {
	var a, i, j, m, n Tsize_t
	var off, scale int32
	var x Tuint64_t
	_, _, _, _, _, _, _, _ = a, i, j, m, n, off, scale, x
	scale = int32(3) - BoolInt32(_trans == _zi+uintptr(44))
	off = 0
	a = uint64(0)
	n = uint64((int64(_index) - int64(_trans)) >> scale)
	if !(n != 0) {
		if alt != 0 {
			*(*Tsize_t)(unsafe.Pointer(alt)) = uint64(0)
		}
		return uint64(0)
	}
	/* Binary search for 'most-recent rule before t'. */
	for n > uint64(1) {
		m = a + n/uint64(2)
		x = uint64(_zi_read32(tls, _trans+uintptr(m<<scale)))
		if scale == int32(3) {
			x = x<<int32(32) | uint64(_zi_read32(tls, _trans+uintptr(m<<scale)+uintptr(4)))
		} else {
			x = uint64(int32(x))
		}
		if local != 0 {
			off = int32(_zi_read32(tls, _types+uintptr(int32(6)*int32(*(*uint8)(unsafe.Pointer(_index + uintptr(m-uint64(1))))))))
		}
		if t-int64(off) < int64(x) {
			n /= uint64(2)
		} else {
			a = m
			n -= n / uint64(2)
		}
	}
	/* First and last entry are special. First means to use lowest-index
	 * non-DST type. Last means to apply POSIX-style rule if available. */
	n = uint64((int64(_index) - int64(_trans)) >> scale)
	if a == n-uint64(1) {
		return uint64(-Int32FromInt32(1))
	}
	if a == uint64(0) {
		x = uint64(_zi_read32(tls, _trans))
		if scale == int32(3) {
			x = x<<int32(32) | uint64(_zi_read32(tls, _trans+uintptr(4)))
		} else {
			x = uint64(int32(x))
		}
		/* Find the lowest non-DST type, or 0 if none. */
		j = uint64(0)
		i = uint64(int64(_abbrevs) - int64(_types))
		for {
			if !(i != 0) {
				break
			}
			if !(*(*uint8)(unsafe.Pointer(_types + uintptr(i-uint64(6)+uint64(4)))) != 0) {
				j = i - uint64(6)
			}
			goto _1
		_1:
			;
			i -= uint64(6)
		}
		if local != 0 {
			off = int32(_zi_read32(tls, _types+uintptr(j)))
		}
		/* If t is before first transition, use the above-found type
		 * and the index-zero (after transition) type as the alt. */
		if t-int64(off) < int64(x) {
			if alt != 0 {
				*(*Tsize_t)(unsafe.Pointer(alt)) = uint64(*(*uint8)(unsafe.Pointer(_index)))
			}
			return j / uint64(6)
		}
	}
	/* Try to find a neighboring opposite-DST-status rule. */
	if alt != 0 {
		if a != 0 && int32(*(*uint8)(unsafe.Pointer(_types + uintptr(int32(6)*int32(*(*uint8)(unsafe.Pointer(_index + uintptr(a-uint64(1)))))+int32(4))))) != int32(*(*uint8)(unsafe.Pointer(_types + uintptr(int32(6)*int32(*(*uint8)(unsafe.Pointer(_index + uintptr(a))))+int32(4))))) {
			*(*Tsize_t)(unsafe.Pointer(alt)) = uint64(*(*uint8)(unsafe.Pointer(_index + uintptr(a-uint64(1)))))
		} else {
			if a+uint64(1) < n && int32(*(*uint8)(unsafe.Pointer(_types + uintptr(int32(6)*int32(*(*uint8)(unsafe.Pointer(_index + uintptr(a+uint64(1)))))+int32(4))))) != int32(*(*uint8)(unsafe.Pointer(_types + uintptr(int32(6)*int32(*(*uint8)(unsafe.Pointer(_index + uintptr(a))))+int32(4))))) {
				*(*Tsize_t)(unsafe.Pointer(alt)) = uint64(*(*uint8)(unsafe.Pointer(_index + uintptr(a+uint64(1)))))
			} else {
				*(*Tsize_t)(unsafe.Pointer(alt)) = uint64(*(*uint8)(unsafe.Pointer(_index + uintptr(a))))
			}
		}
	}
	return uint64(*(*uint8)(unsafe.Pointer(_index + uintptr(a))))
}

func _days_in_month1(tls *TLS, m int32, is_leap int32) (r int32) {
	if m == int32(2) {
		return int32(28) + is_leap
	} else {
		return int32(30) + int32(0xad5)>>(m-int32(1))&int32(1)
	}
	return r
}

/* Convert a POSIX DST rule plus year to seconds since epoch. */

func _rule_to_secs(tls *TLS, rule uintptr, year int32) (r int64) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var d, days, m, n, wday, x int32
	var t int64
	var _ /* is_leap at bp+0 */ int32
	_, _, _, _, _, _, _ = d, days, m, n, t, wday, x
	t = X__year_to_secs(tls, int64(year), bp)
	if *(*int32)(unsafe.Pointer(rule)) != int32('M') {
		x = *(*int32)(unsafe.Pointer(rule + 1*4))
		if *(*int32)(unsafe.Pointer(rule)) == int32('J') && (x < int32(60) || !(*(*int32)(unsafe.Pointer(bp)) != 0)) {
			x--
		}
		t += int64(int32(86400) * x)
	} else {
		m = *(*int32)(unsafe.Pointer(rule + 1*4))
		n = *(*int32)(unsafe.Pointer(rule + 2*4))
		d = *(*int32)(unsafe.Pointer(rule + 3*4))
		t += int64(X__month_to_secs(tls, m-int32(1), *(*int32)(unsafe.Pointer(bp))))
		wday = int32((t+int64(Int32FromInt32(4)*Int32FromInt32(86400)))%int64(Int32FromInt32(7)*Int32FromInt32(86400))) / int32(86400)
		days = d - wday
		if days < 0 {
			days += int32(7)
		}
		if n == int32(5) && days+int32(28) >= _days_in_month1(tls, m, *(*int32)(unsafe.Pointer(bp))) {
			n = int32(4)
		}
		t += int64(int32(86400) * (days + int32(7)*(n-int32(1))))
	}
	t += int64(*(*int32)(unsafe.Pointer(rule + 4*4)))
	return t
}

/* Determine the time zone in effect for a given time in seconds since the
 * epoch. It can be given in local or universal time. The results will
 * indicate whether DST is in effect at the queried time, and will give both
 * the GMT offset for the active zone/DST rule and the opposite DST. This
 * enables a caller to efficiently adjust for the case where an explicit
 * DST specification mismatches what would be in effect at the time. */

func X__secs_to_zone(tls *TLS, t int64, local int32, isdst uintptr, offset uintptr, oppoff uintptr, zonename uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v local=%v isdst=%v offset=%v oppoff=%v zonename=%v, (%v:)", tls, t, local, isdst, offset, oppoff, zonename, origin(2))
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var i Tsize_t
	var t0, t1, y int64
	var _ /* alt at bp+0 */ Tsize_t
	_, _, _, _ = i, t0, t1, y
	___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
	_do_tzset(tls)
	if _zi != 0 {
		i = _scan_trans(tls, t, local, bp)
		if i != uint64(-Int32FromInt32(1)) {
			*(*int32)(unsafe.Pointer(isdst)) = int32(*(*uint8)(unsafe.Pointer(_types + uintptr(uint64(6)*i+uint64(4)))))
			*(*int64)(unsafe.Pointer(offset)) = int64(int32(_zi_read32(tls, _types+uintptr(uint64(6)*i))))
			*(*uintptr)(unsafe.Pointer(zonename)) = _abbrevs + uintptr(*(*uint8)(unsafe.Pointer(_types + uintptr(uint64(6)*i+uint64(5)))))
			if oppoff != 0 {
				*(*int64)(unsafe.Pointer(oppoff)) = int64(int32(_zi_read32(tls, _types+uintptr(uint64(6)**(*Tsize_t)(unsafe.Pointer(bp))))))
			}
			___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
			return
		}
	}
	if !(Xdaylight != 0) {
		goto std
	}
	/* FIXME: may be broken if DST changes right at year boundary?
	 * Also, this could be more efficient.*/
	y = t/int64(31556952) + int64(70)
	for X__year_to_secs(tls, y, uintptr(0)) > t {
		y--
	}
	for X__year_to_secs(tls, y+int64(1), uintptr(0)) < t {
		y++
	}
	t0 = _rule_to_secs(tls, uintptr(unsafe.Pointer(&_r0)), int32(y))
	t1 = _rule_to_secs(tls, uintptr(unsafe.Pointer(&_r12)), int32(y))
	if !(local != 0) {
		t0 += Xtimezone
		t1 += int64(_dst_off)
	}
	if t0 < t1 {
		if t >= t0 && t < t1 {
			goto dst
		}
		goto std
	} else {
		if t >= t1 && t < t0 {
			goto std
		}
		goto dst
	}
	goto std
std:
	;
	*(*int32)(unsafe.Pointer(isdst)) = 0
	*(*int64)(unsafe.Pointer(offset)) = -Xtimezone
	if oppoff != 0 {
		*(*int64)(unsafe.Pointer(oppoff)) = int64(-_dst_off)
	}
	*(*uintptr)(unsafe.Pointer(zonename)) = Xtzname[0]
	___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
	return
	goto dst
dst:
	;
	*(*int32)(unsafe.Pointer(isdst)) = int32(1)
	*(*int64)(unsafe.Pointer(offset)) = int64(-_dst_off)
	if oppoff != 0 {
		*(*int64)(unsafe.Pointer(oppoff)) = -Xtimezone
	}
	*(*uintptr)(unsafe.Pointer(zonename)) = Xtzname[int32(1)]
	___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
}

func ___tzset(tls *TLS) {
	___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
	_do_tzset(tls)
	___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
}

func X__tm_to_tzname(tls *TLS, tm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v tm=%v, (%v:)", tls, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var p uintptr
	_ = p
	p = (*Ttm)(unsafe.Pointer(tm)).F__tm_zone
	___lock(tls, uintptr(unsafe.Pointer(&_lock4)))
	_do_tzset(tls)
	if p != uintptr(unsafe.Pointer(&X__utc)) && p != Xtzname[0] && p != Xtzname[int32(1)] && (!(_zi != 0) || uint64(p)-uint64(_abbrevs) >= uint64(int64(_abbrevs_end)-int64(_abbrevs))) {
		p = __ccgo_ts
	}
	___unlock(tls, uintptr(unsafe.Pointer(&_lock4)))
	return p
}

func X__year_to_secs(tls *TLS, year int64, is_leap uintptr) (r int64) {
	if __ccgo_strace {
		trc("tls=%v year=%v is_leap=%v, (%v:)", tls, year, is_leap, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var centuries, cycles, leaps, leaps1, rem, y int32
	var _ /* dummy at bp+0 */ int32
	_, _, _, _, _, _ = centuries, cycles, leaps, leaps1, rem, y
	if uint64(year)-uint64(2) <= uint64(136) {
		y = int32(year)
		leaps = (y - int32(68)) >> int32(2)
		if !((y-Int32FromInt32(68))&Int32FromInt32(3) != 0) {
			leaps--
			if is_leap != 0 {
				*(*int32)(unsafe.Pointer(is_leap)) = int32(1)
			}
		} else {
			if is_leap != 0 {
				*(*int32)(unsafe.Pointer(is_leap)) = 0
			}
		}
		return int64(int32(31536000)*(y-int32(70)) + int32(86400)*leaps)
	}
	if !(is_leap != 0) {
		is_leap = bp
	}
	cycles = int32((year - int64(100)) / int64(400))
	rem = int32((year - int64(100)) % int64(400))
	if rem < 0 {
		cycles--
		rem += int32(400)
	}
	if !(rem != 0) {
		*(*int32)(unsafe.Pointer(is_leap)) = int32(1)
		centuries = 0
		leaps1 = 0
	} else {
		if rem >= int32(200) {
			if rem >= int32(300) {
				centuries = int32(3)
				rem -= int32(300)
			} else {
				centuries = int32(2)
				rem -= int32(200)
			}
		} else {
			if rem >= int32(100) {
				centuries = int32(1)
				rem -= int32(100)
			} else {
				centuries = 0
			}
		}
		if !(rem != 0) {
			*(*int32)(unsafe.Pointer(is_leap)) = 0
			leaps1 = 0
		} else {
			leaps1 = int32(uint32(rem) / uint32(4))
			rem = int32(uint32(rem) % Uint32FromUint32(4))
			*(*int32)(unsafe.Pointer(is_leap)) = BoolInt32(!(rem != 0))
		}
	}
	leaps1 += int32(97)*cycles + int32(24)*centuries - *(*int32)(unsafe.Pointer(is_leap))
	return (year-int64(100))*int64(31536000) + int64(leaps1)*int64(86400) + int64(946684800) + int64(86400)
}

func Xasctime(tls *TLS, tm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v tm=%v, (%v:)", tls, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__asctime_r(tls, tm, uintptr(unsafe.Pointer(&_buf9)))
}

var _buf9 [26]uint8

func X__asctime_r(tls *TLS, tm uintptr, buf uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v tm=%v buf=%v, (%v:)", tls, tm, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	if Xsnprintf(tls, buf, uint64(26), __ccgo_ts+1768, VaList(bp+8, X__nl_langinfo_l(tls, int32(ABDAY_1)+(*Ttm)(unsafe.Pointer(tm)).Ftm_wday, uintptr(unsafe.Pointer(&X__c_locale))), X__nl_langinfo_l(tls, int32(ABMON_1)+(*Ttm)(unsafe.Pointer(tm)).Ftm_mon, uintptr(unsafe.Pointer(&X__c_locale))), (*Ttm)(unsafe.Pointer(tm)).Ftm_mday, (*Ttm)(unsafe.Pointer(tm)).Ftm_hour, (*Ttm)(unsafe.Pointer(tm)).Ftm_min, (*Ttm)(unsafe.Pointer(tm)).Ftm_sec, int32(1900)+(*Ttm)(unsafe.Pointer(tm)).Ftm_year)) >= int32(26) {
		/* ISO C requires us to use the above format string,
		 * even if it will not fit in the buffer. Thus asctime_r
		 * is _supposed_ to crash if the fields in tm are too large.
		 * We follow this behavior and crash "gracefully" to warn
		 * application developers that they may not be so lucky
		 * on other implementations (e.g. stack smashing..).
		 */
		*(*uint8)(unsafe.Pointer(UintptrFromInt32(0))) = uint8(0)
	}
	return buf
}

func Xasctime_r(tls *TLS, tm uintptr, buf uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v tm=%v buf=%v, (%v:)", tls, tm, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__asctime_r(tls, tm, buf)
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xclock(tls *TLS) (r Tclock_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* ts at bp+0 */ Ttimespec
	if X__clock_gettime(tls, int32(CLOCK_PROCESS_CPUTIME_ID), bp) != 0 {
		return int64(-int32(1))
	}
	if (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec > Int64FromInt64(0x7fffffffffffffff)/Int64FromInt32(1000000) || (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec/int64(1000) > int64(0x7fffffffffffffff)-int64(1000000)*(*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec {
		return int64(-int32(1))
	}
	return (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec*int64(1000000) + (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec/int64(1000)
}

func Xclock_getcpuclockid(tls *TLS, pid Tpid_t, clk uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v pid=%v clk=%v, (%v:)", tls, pid, clk, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var id Tclockid_t
	var ret int32
	var _ /* ts at bp+0 */ Ttimespec
	_, _ = id, ret
	id = int32(uint32(-pid-Int32FromInt32(1))*uint32(8) + uint32(2))
	ret = int32(X__syscall2(tls, int64(SYS_clock_getres), int64(id), int64(bp)))
	if ret == -int32(EINVAL) {
		ret = -int32(ESRCH)
	}
	if ret != 0 {
		return -ret
	}
	*(*Tclockid_t)(unsafe.Pointer(clk)) = id
	return 0
}

func Xclock_getres(tls *TLS, clk Tclockid_t, ts uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v clk=%v ts=%v, (%v:)", tls, clk, ts, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* If reaching this point, it's a 64-bit arch or time64-only
	 * 32-bit arch and we can get result directly into timespec. */
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_clock_getres), int64(clk), int64(ts)))))
}

func X__clock_gettime(tls *TLS, clk Tclockid_t, ts uintptr) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v clk=%v ts=%v, (%v:)", tls, clk, ts, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	r = int32(X__syscall2(tls, int64(SYS_clock_gettime), int64(clk), int64(ts)))
	if r == -int32(ENOSYS) {
		if clk == CLOCK_REALTIME {
			X__syscall2(tls, int64(SYS_gettimeofday), int64(ts), int64(Int32FromInt32(0)))
			(*Ttimespec)(unsafe.Pointer(ts)).Ftv_nsec = int64(int32((*Ttimespec)(unsafe.Pointer(ts)).Ftv_nsec) * int32(1000))
			return 0
		}
		r = -int32(EINVAL)
	}
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xclock_gettime(tls *TLS, clk Tclockid_t, ts uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v clk=%v ts=%v, (%v:)", tls, clk, ts, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__clock_gettime(tls, clk, ts)
}

func X__clock_nanosleep(tls *TLS, clk Tclockid_t, flags int32, req uintptr, rem uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v clk=%v flags=%v req=%v rem=%v, (%v:)", tls, clk, flags, req, rem, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if clk == int32(CLOCK_THREAD_CPUTIME_ID) {
		return int32(EINVAL)
	}
	if clk == CLOCK_REALTIME && !(flags != 0) {
		return int32(-___syscall_cp(tls, int64(SYS_nanosleep), int64(req), int64(rem), 0, 0, 0, 0))
	}
	return int32(-___syscall_cp(tls, int64(SYS_clock_nanosleep), int64(clk), int64(flags), int64(req), int64(rem), 0, 0))
}

func Xclock_nanosleep(tls *TLS, clk Tclockid_t, flags int32, req uintptr, rem uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v clk=%v flags=%v req=%v rem=%v, (%v:)", tls, clk, flags, req, rem, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__clock_nanosleep(tls, clk, flags, req, rem)
}

func Xclock_settime(tls *TLS, clk Tclockid_t, ts uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v clk=%v ts=%v, (%v:)", tls, clk, ts, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_clock_settime), int64(clk), int64(ts)))))
}

func Xctime(tls *TLS, t uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v, (%v:)", tls, t, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var tm uintptr
	_ = tm
	tm = Xlocaltime(tls, t)
	if !(tm != 0) {
		return uintptr(0)
	}
	return Xasctime(tls, tm)
}

func Xctime_r(tls *TLS, t uintptr, buf uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v buf=%v, (%v:)", tls, t, buf, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var tm_p, v1 uintptr
	var _ /* tm at bp+0 */ Ttm
	_, _ = tm_p, v1
	tm_p = Xlocaltime_r(tls, t, bp)
	if tm_p != 0 {
		v1 = Xasctime_r(tls, tm_p, buf)
	} else {
		v1 = uintptr(0)
	}
	return v1
}

func Xdifftime(tls *TLS, t1 Ttime_t, t0 Ttime_t) (r float64) {
	if __ccgo_strace {
		trc("tls=%v t1=%v t0=%v, (%v:)", tls, t1, t0, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return float64(t1 - t0)
}

type Ttimeb = struct {
	Ftime     Ttime_t
	Fmillitm  uint16
	Ftimezone int16
	Fdstflag  int16
}

func Xftime(tls *TLS, tp uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v tp=%v, (%v:)", tls, tp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var v1 int16
	var _ /* ts at bp+0 */ Ttimespec
	_ = v1
	Xclock_gettime(tls, CLOCK_REALTIME, bp)
	(*Ttimeb)(unsafe.Pointer(tp)).Ftime = (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
	(*Ttimeb)(unsafe.Pointer(tp)).Fmillitm = uint16((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec / int64(1000000))
	v1 = Int16FromInt32(0)
	(*Ttimeb)(unsafe.Pointer(tp)).Fdstflag = v1
	(*Ttimeb)(unsafe.Pointer(tp)).Ftimezone = v1
	return 0
}

func Xgetdate(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(112)
	defer tls.Free(112)
	var datemsk, f, p, ret uintptr
	var _ /* cs at bp+100 */ int32
	var _ /* fmt at bp+0 */ [100]uint8
	_, _, _, _ = datemsk, f, p, ret
	ret = uintptr(0)
	datemsk = Xgetenv(tls, __ccgo_ts+1800)
	f = uintptr(0)
	_pthread_setcancelstate(tls, PTHREAD_CANCEL_DEFERRED, bp+100)
	if !(datemsk != 0) {
		Xgetdate_err = int32(1)
		goto out
	}
	f = Xfopen(tls, datemsk, __ccgo_ts+315)
	if !(f != 0) {
		if *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(ENOMEM) {
			Xgetdate_err = int32(6)
		} else {
			Xgetdate_err = int32(2)
		}
		goto out
	}
	for Xfgets(tls, bp, int32(100), f) != 0 {
		p = Xstrptime(tls, s, bp, uintptr(unsafe.Pointer(&_tmbuf)))
		if p != 0 && !(*(*uint8)(unsafe.Pointer(p)) != 0) {
			ret = uintptr(unsafe.Pointer(&_tmbuf))
			goto out
		}
	}
	if Xferror(tls, f) != 0 {
		Xgetdate_err = int32(5)
	} else {
		Xgetdate_err = int32(7)
	}
	goto out
out:
	;
	if f != 0 {
		Xfclose(tls, f)
	}
	_pthread_setcancelstate(tls, *(*int32)(unsafe.Pointer(bp + 100)), uintptr(0))
	return ret
}

var _tmbuf Ttm

func Xgettimeofday(tls *TLS, tv uintptr, tz uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v tv=%v tz=%v, (%v:)", tls, tv, tz, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* ts at bp+0 */ Ttimespec
	if !(tv != 0) {
		return 0
	}
	Xclock_gettime(tls, CLOCK_REALTIME, bp)
	(*Ttimeval)(unsafe.Pointer(tv)).Ftv_sec = (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
	(*Ttimeval)(unsafe.Pointer(tv)).Ftv_usec = int64(int32((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_nsec) / int32(1000))
	return 0
}

func Xgmtime(tls *TLS, t uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v, (%v:)", tls, t, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__gmtime_r(tls, t, uintptr(unsafe.Pointer(&_tm)))
}

var _tm Ttm

func X__gmtime_r(tls *TLS, t uintptr, tm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v tm=%v, (%v:)", tls, t, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	if X__secs_to_tm(tls, *(*Ttime_t)(unsafe.Pointer(t)), tm) < 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOVERFLOW)
		return uintptr(0)
	}
	(*Ttm)(unsafe.Pointer(tm)).Ftm_isdst = 0
	(*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff = 0
	(*Ttm)(unsafe.Pointer(tm)).F__tm_zone = uintptr(unsafe.Pointer(&X__utc))
	return tm
}

func Xgmtime_r(tls *TLS, t uintptr, tm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v tm=%v, (%v:)", tls, t, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__gmtime_r(tls, t, tm)
}

func Xlocaltime(tls *TLS, t uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v, (%v:)", tls, t, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__localtime_r(tls, t, uintptr(unsafe.Pointer(&_tm1)))
}

var _tm1 Ttm

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func X__localtime_r(tls *TLS, t uintptr, tm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v tm=%v, (%v:)", tls, t, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	/* Reject time_t values whose year would overflow int because
	 * __secs_to_zone cannot safely handle them. */
	if *(*Ttime_t)(unsafe.Pointer(t)) < int64(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff))*Int64FromInt64(31622400) || *(*Ttime_t)(unsafe.Pointer(t)) > Int64FromInt32(INT_MAX)*Int64FromInt64(31622400) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOVERFLOW)
		return uintptr(0)
	}
	X__secs_to_zone(tls, *(*Ttime_t)(unsafe.Pointer(t)), 0, tm+32, tm+40, uintptr(0), tm+48)
	if X__secs_to_tm(tls, *(*Ttime_t)(unsafe.Pointer(t))+(*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff, tm) < 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOVERFLOW)
		return uintptr(0)
	}
	return tm
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xlocaltime_r(tls *TLS, t uintptr, tm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v t=%v tm=%v, (%v:)", tls, t, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__localtime_r(tls, t, tm)
}

func Xmktime(tls *TLS, tm uintptr) (r Ttime_t) {
	if __ccgo_strace {
		trc("tls=%v tm=%v, (%v:)", tls, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var t int64
	var _ /* new at bp+0 */ Ttm
	var _ /* opp at bp+56 */ int64
	_ = t
	t = X__tm_to_secs(tls, tm)
	X__secs_to_zone(tls, t, int32(1), bp+32, bp+40, bp+56, bp+48)
	if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst >= 0 && (*(*Ttm)(unsafe.Pointer(bp))).Ftm_isdst != (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst {
		t -= *(*int64)(unsafe.Pointer(bp + 56)) - (*(*Ttm)(unsafe.Pointer(bp))).F__tm_gmtoff
	}
	t -= (*(*Ttm)(unsafe.Pointer(bp))).F__tm_gmtoff
	if t != t {
		goto error
	}
	X__secs_to_zone(tls, t, 0, bp+32, bp+40, bp+56, bp+48)
	if X__secs_to_tm(tls, t+(*(*Ttm)(unsafe.Pointer(bp))).F__tm_gmtoff, bp) < 0 {
		goto error
	}
	*(*Ttm)(unsafe.Pointer(tm)) = *(*Ttm)(unsafe.Pointer(bp))
	return t
	goto error
error:
	;
	*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOVERFLOW)
	return int64(-int32(1))
}

func Xnanosleep(tls *TLS, req uintptr, rem uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v req=%v rem=%v, (%v:)", tls, req, rem, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(-X__clock_nanosleep(tls, CLOCK_REALTIME, 0, req, rem))))
}

func _is_leap(tls *TLS, y int32) (r int32) {
	/* Avoid overflow */
	if y > Int32FromInt32(INT_MAX)-Int32FromInt32(1900) {
		y -= int32(2000)
	}
	y += int32(1900)
	return BoolInt32(!(y%Int32FromInt32(4) != 0) && (y%int32(100) != 0 || !(y%Int32FromInt32(400) != 0)))
}

func _week_num(tls *TLS, tm uintptr) (r int32) {
	var dec31, jan1, val int32
	_, _, _ = dec31, jan1, val
	val = int32((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday) + uint32(7) - (uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)+uint32(6))%uint32(7)) / uint32(7))
	/* If 1 Jan is just 1-3 days past Monday,
	 * the previous week is also in this year. */
	if (uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)+uint32(371)-uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday)-uint32(2))%uint32(7) <= uint32(2) {
		val++
	}
	if !(val != 0) {
		val = int32(52)
		/* If 31 December of prev year a Thursday,
		 * or Friday of a leap year, then the
		 * prev year has 53 weeks. */
		dec31 = int32((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday) + uint32(7) - uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday) - uint32(1)) % uint32(7))
		if dec31 == int32(4) || dec31 == int32(5) && _is_leap(tls, (*Ttm)(unsafe.Pointer(tm)).Ftm_year%int32(400)-int32(1)) != 0 {
			val++
		}
	} else {
		if val == int32(53) {
			/* If 1 January is not a Thursday, and not
			 * a Wednesday of a leap year, then this
			 * year has only 52 weeks. */
			jan1 = int32((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday) + uint32(371) - uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday)) % uint32(7))
			if jan1 != int32(4) && (jan1 != int32(3) || !(_is_leap(tls, (*Ttm)(unsafe.Pointer(tm)).Ftm_year) != 0)) {
				val = int32(1)
			}
		}
	}
	return val
}

func X__strftime_fmt_1(tls *TLS, s uintptr, l uintptr, f int32, tm uintptr, loc Tlocale_t, pad int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v l=%v f=%v tm=%v loc=%v pad=%v, (%v:)", tls, s, l, f, tm, loc, pad, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var d, fmt, v4, v5 uintptr
	var def_pad, width, v1, v2, v6, v7 int32
	var item Tnl_item
	var val int64
	_, _, _, _, _, _, _, _, _, _, _, _ = d, def_pad, fmt, item, val, width, v1, v2, v4, v5, v6, v7
	fmt = __ccgo_ts + 1662
	width = int32(2)
	def_pad = int32('0')
	switch f {
	case int32('a'):
		if uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday) > uint32(6) {
			goto string
		}
		item = int32(ABDAY_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
		goto nl_strcat
	case int32('A'):
		if uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday) > uint32(6) {
			goto string
		}
		item = int32(DAY_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
		goto nl_strcat
	case int32('h'):
		fallthrough
	case int32('b'):
		if uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_mon) > uint32(11) {
			goto string
		}
		item = int32(ABMON_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
		goto nl_strcat
	case int32('B'):
		if uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_mon) > uint32(11) {
			goto string
		}
		item = int32(MON_1) + (*Ttm)(unsafe.Pointer(tm)).Ftm_mon
		goto nl_strcat
	case int32('c'):
		item = int32(D_T_FMT)
		goto nl_strftime
	case int32('C'):
		val = (int64(1900) + int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year)) / int64(100)
		goto number
	case int32('e'):
		def_pad = int32('_')
		fallthrough
	case int32('d'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_mday)
		goto number
	case int32('D'):
		fmt = __ccgo_ts + 1808
		goto recu_strftime
	case int32('F'):
		fmt = __ccgo_ts + 1817
		goto recu_strftime
	case int32('g'):
		fallthrough
	case int32('G'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year) + int64(1900)
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_yday < int32(3) && _week_num(tls, tm) != int32(1) {
			val--
		} else {
			if (*Ttm)(unsafe.Pointer(tm)).Ftm_yday > int32(360) && _week_num(tls, tm) == int32(1) {
				val++
			}
		}
		if f == int32('g') {
			val %= int64(100)
		} else {
			width = int32(4)
		}
		goto number
	case int32('H'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_hour)
		goto number
	case int32('l'):
		def_pad = int32('_')
		fallthrough
	case int32('I'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_hour)
		if !(val != 0) {
			val = int64(12)
		} else {
			if val > int64(12) {
				val -= int64(12)
			}
		}
		goto number
	case int32('j'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_yday + int32(1))
		width = int32(3)
		goto number
	case int32('k'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_hour)
		def_pad = int32('_')
		goto number
	case int32('m'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_mon + int32(1))
		goto number
	case int32('M'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_min)
		goto number
	case int32('n'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(1)
		return __ccgo_ts + 301
	case int32('p'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_hour >= int32(12) {
			v1 = int32(PM_STR)
		} else {
			v1 = int32(AM_STR)
		}
		item = v1
		goto nl_strcat
	case int32('P'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_hour >= int32(12) {
			v2 = int32(PM_STR)
		} else {
			v2 = int32(AM_STR)
		}
		item = v2
		fmt = X__nl_langinfo_l(tls, item, loc)
		d = s
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(0)
		for {
			if !(*(*uint8)(unsafe.Pointer(fmt)) != 0) {
				break
			}
			v4 = d
			d++
			v5 = fmt
			fmt++
			*(*uint8)(unsafe.Pointer(v4)) = uint8(Xtolower(tls, int32(*(*uint8)(unsafe.Pointer(v5)))))
			goto _3
		_3:
			;
			*(*Tsize_t)(unsafe.Pointer(l))++
		}
		return s
	case int32('r'):
		item = int32(T_FMT_AMPM)
		goto nl_strftime
	case int32('R'):
		fmt = __ccgo_ts + 1826
		goto recu_strftime
	case int32('s'):
		val = X__tm_to_secs(tls, tm) - (*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff
		width = int32(1)
		goto number
	case int32('S'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_sec)
		goto number
	case int32('t'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(1)
		return __ccgo_ts + 1400
	case int32('T'):
		fmt = __ccgo_ts + 1832
		goto recu_strftime
	case int32('u'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_wday != 0 {
			v6 = (*Ttm)(unsafe.Pointer(tm)).Ftm_wday
		} else {
			v6 = int32(7)
		}
		val = int64(v6)
		width = int32(1)
		goto number
	case int32('U'):
		val = int64((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday) + uint32(7) - uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)) / uint32(7))
		goto number
	case int32('W'):
		val = int64((uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_yday) + uint32(7) - (uint32((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)+uint32(6))%uint32(7)) / uint32(7))
		goto number
	case int32('V'):
		val = int64(_week_num(tls, tm))
		goto number
	case int32('w'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_wday)
		width = int32(1)
		goto number
	case int32('x'):
		item = int32(D_FMT)
		goto nl_strftime
	case int32('X'):
		item = int32(T_FMT)
		goto nl_strftime
	case int32('y'):
		val = (int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year) + int64(1900)) % int64(100)
		if val < 0 {
			val = -val
		}
		goto number
	case int32('Y'):
		val = int64((*Ttm)(unsafe.Pointer(tm)).Ftm_year) + int64(1900)
		if val >= int64(10000) {
			*(*Tsize_t)(unsafe.Pointer(l)) = uint64(Xsnprintf(tls, s, uint64(100), __ccgo_ts+1841, VaList(bp+8, val)))
			return s
		}
		width = int32(4)
		goto number
	case int32('z'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst < 0 {
			*(*Tsize_t)(unsafe.Pointer(l)) = uint64(0)
			return __ccgo_ts
		}
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(Xsnprintf(tls, s, uint64(100), __ccgo_ts+1847, VaList(bp+8, (*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff/int64(3600)*int64(100)+(*Ttm)(unsafe.Pointer(tm)).F__tm_gmtoff%int64(3600)/int64(60))))
		return s
	case int32('Z'):
		if (*Ttm)(unsafe.Pointer(tm)).Ftm_isdst < 0 {
			*(*Tsize_t)(unsafe.Pointer(l)) = uint64(0)
			return __ccgo_ts
		}
		fmt = X__tm_to_tzname(tls, tm)
		goto string
	case int32('%'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(1)
		return __ccgo_ts + 348
	default:
		return uintptr(0)
	}
	goto number
number:
	;
	if pad != 0 {
		v7 = pad
	} else {
		v7 = def_pad
	}
	switch v7 {
	case int32('-'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(Xsnprintf(tls, s, uint64(100), __ccgo_ts+1854, VaList(bp+8, val)))
	case int32('_'):
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(Xsnprintf(tls, s, uint64(100), __ccgo_ts+1859, VaList(bp+8, width, val)))
	case int32('0'):
		fallthrough
	default:
		*(*Tsize_t)(unsafe.Pointer(l)) = uint64(Xsnprintf(tls, s, uint64(100), __ccgo_ts+1865, VaList(bp+8, width, val)))
		break
	}
	return s
	goto nl_strcat
nl_strcat:
	;
	fmt = X__nl_langinfo_l(tls, item, loc)
	goto string
string:
	;
	*(*Tsize_t)(unsafe.Pointer(l)) = Xstrlen(tls, fmt)
	return fmt
	goto nl_strftime
nl_strftime:
	;
	fmt = X__nl_langinfo_l(tls, item, loc)
	goto recu_strftime
recu_strftime:
	;
	*(*Tsize_t)(unsafe.Pointer(l)) = X__strftime_l(tls, s, uint64(100), fmt, tm, loc)
	if !(*(*Tsize_t)(unsafe.Pointer(l)) != 0) {
		return uintptr(0)
	}
	return s
}

func X__strftime_l(tls *TLS, s uintptr, n Tsize_t, f uintptr, tm uintptr, loc Tlocale_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v tm=%v loc=%v, (%v:)", tls, s, n, f, tm, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(128)
	defer tls.Free(128)
	var d, l, v10, v12, v2, v7 Tsize_t
	var pad, plus, v4, v8 int32
	var t, v3 uintptr
	var width uint64
	var v9 bool
	var _ /* buf at bp+8 */ [100]uint8
	var _ /* k at bp+0 */ Tsize_t
	var _ /* p at bp+112 */ uintptr
	_, _, _, _, _, _, _, _, _, _, _, _, _, _ = d, l, pad, plus, t, width, v10, v12, v2, v3, v4, v7, v8, v9
	l = uint64(0)
	for {
		if !(l < n) {
			break
		}
		if !(*(*uint8)(unsafe.Pointer(f)) != 0) {
			*(*uint8)(unsafe.Pointer(s + uintptr(l))) = uint8(0)
			return l
		}
		if int32(*(*uint8)(unsafe.Pointer(f))) != int32('%') {
			v2 = l
			l++
			*(*uint8)(unsafe.Pointer(s + uintptr(v2))) = *(*uint8)(unsafe.Pointer(f))
			goto _1
		}
		f++
		pad = 0
		if int32(*(*uint8)(unsafe.Pointer(f))) == int32('-') || int32(*(*uint8)(unsafe.Pointer(f))) == int32('_') || int32(*(*uint8)(unsafe.Pointer(f))) == int32('0') {
			v3 = f
			f++
			pad = int32(*(*uint8)(unsafe.Pointer(v3)))
		}
		v4 = BoolInt32(int32(*(*uint8)(unsafe.Pointer(f))) == Int32FromUint8('+'))
		plus = v4
		if v4 != 0 {
			f++
		}
		if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(f)))-uint32('0') < uint32(10)) != 0 {
			width = Xstrtoul(tls, f, bp+112, int32(10))
		} else {
			width = uint64(0)
			*(*uintptr)(unsafe.Pointer(bp + 112)) = f
		}
		if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('C') || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('F') || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('G') || int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('Y') {
			if !(width != 0) && *(*uintptr)(unsafe.Pointer(bp + 112)) != f {
				width = uint64(1)
			}
		} else {
			width = uint64(0)
		}
		f = *(*uintptr)(unsafe.Pointer(bp + 112))
		if int32(*(*uint8)(unsafe.Pointer(f))) == int32('E') || int32(*(*uint8)(unsafe.Pointer(f))) == int32('O') {
			f++
		}
		t = X__strftime_fmt_1(tls, bp+8, bp, int32(*(*uint8)(unsafe.Pointer(f))), tm, loc, pad)
		if !(t != 0) {
			break
		}
		if width != 0 {
			/* Trim off any sign and leading zeros, then
			 * count remaining digits to determine behavior
			 * for the + flag. */
			if int32(*(*uint8)(unsafe.Pointer(t))) == int32('+') || int32(*(*uint8)(unsafe.Pointer(t))) == int32('-') {
				t++
				*(*Tsize_t)(unsafe.Pointer(bp))--
			}
			for {
				if !(int32(*(*uint8)(unsafe.Pointer(t))) == int32('0') && uint32(int32(*(*uint8)(unsafe.Pointer(t + 1)))-int32('0')) < uint32(10)) {
					break
				}
				goto _5
			_5:
				;
				t++
				*(*Tsize_t)(unsafe.Pointer(bp))--
			}
			if width < *(*Tsize_t)(unsafe.Pointer(bp)) {
				width = *(*Tsize_t)(unsafe.Pointer(bp))
			}
			d = uint64(0)
			for {
				if !(uint32(int32(*(*uint8)(unsafe.Pointer(t + uintptr(d))))-int32('0')) < uint32(10)) {
					break
				}
				goto _6
			_6:
				;
				d++
			}
			if (*Ttm)(unsafe.Pointer(tm)).Ftm_year < -int32(1900) {
				v7 = l
				l++
				*(*uint8)(unsafe.Pointer(s + uintptr(v7))) = uint8('-')
				width--
			} else {
				if v9 = plus != 0; v9 {
					if int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 112))))) == int32('C') {
						v8 = int32(3)
					} else {
						v8 = int32(5)
					}
				}
				if v9 && d+(width-*(*Tsize_t)(unsafe.Pointer(bp))) >= uint64(v8) {
					v10 = l
					l++
					*(*uint8)(unsafe.Pointer(s + uintptr(v10))) = uint8('+')
					width--
				}
			}
			for {
				if !(width > *(*Tsize_t)(unsafe.Pointer(bp)) && l < n) {
					break
				}
				v12 = l
				l++
				*(*uint8)(unsafe.Pointer(s + uintptr(v12))) = uint8('0')
				goto _11
			_11:
				;
				width--
			}
		}
		if *(*Tsize_t)(unsafe.Pointer(bp)) > n-l {
			*(*Tsize_t)(unsafe.Pointer(bp)) = n - l
		}
		Xmemcpy(tls, s+uintptr(l), t, *(*Tsize_t)(unsafe.Pointer(bp)))
		l += *(*Tsize_t)(unsafe.Pointer(bp))
		goto _1
	_1:
		;
		f++
	}
	if n != 0 {
		if l == n {
			l = n - uint64(1)
		}
		*(*uint8)(unsafe.Pointer(s + uintptr(l))) = uint8(0)
	}
	return uint64(0)
}

func Xstrftime(tls *TLS, s uintptr, n Tsize_t, f uintptr, tm uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v tm=%v, (%v:)", tls, s, n, f, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__strftime_l(tls, s, n, f, tm, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func Xstrftime_l(tls *TLS, s uintptr, n Tsize_t, f uintptr, tm uintptr, loc Tlocale_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v tm=%v loc=%v, (%v:)", tls, s, n, f, tm, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__strftime_l(tls, s, n, f, tm, loc)
}

func Xstrptime(tls *TLS, s uintptr, f uintptr, tm uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v f=%v tm=%v, (%v:)", tls, s, f, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var adj, i, min, neg, range1, w, want_century, v1, v2, v45, v46, v5, v53, v6 int32
	var dest, ex, v49, v51, v54, v9 uintptr
	var len1 Tsize_t
	var v48, v8 bool
	var _ /* century at bp+4 */ int32
	var _ /* dummy at bp+0 */ int32
	var _ /* new_f at bp+16 */ uintptr
	var _ /* relyear at bp+8 */ int32
	_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ = adj, dest, ex, i, len1, min, neg, range1, w, want_century, v1, v2, v45, v46, v48, v49, v5, v51, v53, v54, v6, v8, v9
	want_century = 0
	*(*int32)(unsafe.Pointer(bp + 4)) = 0
	*(*int32)(unsafe.Pointer(bp + 8)) = 0
	for *(*uint8)(unsafe.Pointer(f)) != 0 {
		if int32(*(*uint8)(unsafe.Pointer(f))) != int32('%') {
			v1 = int32(*(*uint8)(unsafe.Pointer(f)))
			v2 = BoolInt32(v1 == int32(' ') || uint32(v1)-uint32('\t') < uint32(5))
			goto _3
		_3:
			if v2 != 0 {
				for {
					if v8 = *(*uint8)(unsafe.Pointer(s)) != 0; v8 {
						v5 = int32(*(*uint8)(unsafe.Pointer(s)))
						v6 = BoolInt32(v5 == int32(' ') || uint32(v5)-uint32('\t') < uint32(5))
						goto _7
					_7:
					}
					if !(v8 && v6 != 0) {
						break
					}
					goto _4
				_4:
					;
					s++
				}
			} else {
				if int32(*(*uint8)(unsafe.Pointer(s))) != int32(*(*uint8)(unsafe.Pointer(f))) {
					return uintptr(0)
				} else {
					s++
				}
			}
			f++
			continue
		}
		f++
		if int32(*(*uint8)(unsafe.Pointer(f))) == int32('+') {
			f++
		}
		if BoolInt32(uint32(*(*uint8)(unsafe.Pointer(f)))-uint32('0') < uint32(10)) != 0 {
			w = int32(Xstrtoul(tls, f, bp+16, int32(10)))
			f = *(*uintptr)(unsafe.Pointer(bp + 16))
		} else {
			w = -int32(1)
		}
		adj = 0
		v9 = f
		f++
		switch int32(*(*uint8)(unsafe.Pointer(v9))) {
		case int32('A'):
			goto _10
		case int32('a'):
			goto _11
		case int32('h'):
			goto _12
		case int32('B'):
			goto _13
		case int32('b'):
			goto _14
		case int32('c'):
			goto _15
		case int32('C'):
			goto _16
		case int32('e'):
			goto _17
		case int32('d'):
			goto _18
		case int32('D'):
			goto _19
		case int32('H'):
			goto _20
		case int32('I'):
			goto _21
		case int32('j'):
			goto _22
		case int32('m'):
			goto _23
		case int32('M'):
			goto _24
		case int32('t'):
			goto _25
		case int32('n'):
			goto _26
		case int32('p'):
			goto _27
		case int32('r'):
			goto _28
		case int32('R'):
			goto _29
		case int32('S'):
			goto _30
		case int32('T'):
			goto _31
		case int32('W'):
			goto _32
		case int32('U'):
			goto _33
		case int32('w'):
			goto _34
		case int32('x'):
			goto _35
		case int32('X'):
			goto _36
		case int32('y'):
			goto _37
		case int32('Y'):
			goto _38
		case int32('%'):
			goto _39
		default:
			goto _40
		}
		goto _41
	_11:
		;
	_10:
		;
		dest = tm + 24
		min = int32(ABDAY_1)
		range1 = int32(7)
		goto symbolic_range
	_14:
		;
	_13:
		;
	_12:
		;
		dest = tm + 16
		min = int32(ABMON_1)
		range1 = int32(12)
		goto symbolic_range
	_15:
		;
		s = Xstrptime(tls, s, Xnl_langinfo(tls, int32(D_T_FMT)), tm)
		if !(s != 0) {
			return uintptr(0)
		}
		goto _41
	_16:
		;
		dest = bp + 4
		if w < 0 {
			w = int32(2)
		}
		want_century |= int32(2)
		goto numeric_digits
	_18:
		;
	_17:
		;
		dest = tm + 12
		min = int32(1)
		range1 = int32(31)
		goto numeric_range
	_19:
		;
		s = Xstrptime(tls, s, __ccgo_ts+1808, tm)
		if !(s != 0) {
			return uintptr(0)
		}
		goto _41
	_20:
		;
		dest = tm + 8
		min = 0
		range1 = int32(24)
		goto numeric_range
	_21:
		;
		dest = tm + 8
		min = int32(1)
		range1 = int32(12)
		goto numeric_range
	_22:
		;
		dest = tm + 28
		min = int32(1)
		range1 = int32(366)
		adj = int32(1)
		goto numeric_range
	_23:
		;
		dest = tm + 16
		min = int32(1)
		range1 = int32(12)
		adj = int32(1)
		goto numeric_range
	_24:
		;
		dest = tm + 4
		min = 0
		range1 = int32(60)
		goto numeric_range
	_26:
		;
	_25:
		;
	_44:
		;
		if v48 = *(*uint8)(unsafe.Pointer(s)) != 0; v48 {
			v45 = int32(*(*uint8)(unsafe.Pointer(s)))
			v46 = BoolInt32(v45 == int32(' ') || uint32(v45)-uint32('\t') < uint32(5))
			goto _47
		_47:
		}
		if !(v48 && v46 != 0) {
			goto _42
		}
		goto _43
	_43:
		;
		s++
		goto _44
		goto _42
	_42:
		;
		goto _41
	_27:
		;
		ex = Xnl_langinfo(tls, int32(AM_STR))
		len1 = Xstrlen(tls, ex)
		if !(Xstrncasecmp(tls, s, ex, len1) != 0) {
			*(*int32)(unsafe.Pointer(tm + 8)) %= int32(12)
			s += uintptr(len1)
			goto _41
		}
		ex = Xnl_langinfo(tls, int32(PM_STR))
		len1 = Xstrlen(tls, ex)
		if !(Xstrncasecmp(tls, s, ex, len1) != 0) {
			*(*int32)(unsafe.Pointer(tm + 8)) %= int32(12)
			*(*int32)(unsafe.Pointer(tm + 8)) += int32(12)
			s += uintptr(len1)
			goto _41
		}
		return uintptr(0)
	_28:
		;
		s = Xstrptime(tls, s, Xnl_langinfo(tls, int32(T_FMT_AMPM)), tm)
		if !(s != 0) {
			return uintptr(0)
		}
		goto _41
	_29:
		;
		s = Xstrptime(tls, s, __ccgo_ts+1826, tm)
		if !(s != 0) {
			return uintptr(0)
		}
		goto _41
	_30:
		;
		dest = tm
		min = 0
		range1 = int32(61)
		goto numeric_range
	_31:
		;
		s = Xstrptime(tls, s, __ccgo_ts+1832, tm)
		if !(s != 0) {
			return uintptr(0)
		}
		goto _41
	_33:
		;
	_32:
		;
		/* Throw away result, for now. (FIXME?) */
		dest = bp
		min = 0
		range1 = int32(54)
		goto numeric_range
	_34:
		;
		dest = tm + 24
		min = 0
		range1 = int32(7)
		goto numeric_range
	_35:
		;
		s = Xstrptime(tls, s, Xnl_langinfo(tls, int32(D_FMT)), tm)
		if !(s != 0) {
			return uintptr(0)
		}
		goto _41
	_36:
		;
		s = Xstrptime(tls, s, Xnl_langinfo(tls, int32(T_FMT)), tm)
		if !(s != 0) {
			return uintptr(0)
		}
		goto _41
	_37:
		;
		dest = bp + 8
		w = int32(2)
		want_century |= int32(1)
		goto numeric_digits
	_38:
		;
		dest = tm + 20
		if w < 0 {
			w = int32(4)
		}
		adj = int32(1900)
		want_century = 0
		goto numeric_digits
	_39:
		;
		v49 = s
		s++
		if int32(*(*uint8)(unsafe.Pointer(v49))) != int32('%') {
			return uintptr(0)
		}
		goto _41
	_40:
		;
		return uintptr(0)
		goto numeric_range
	numeric_range:
		;
		if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			return uintptr(0)
		}
		*(*int32)(unsafe.Pointer(dest)) = 0
		i = int32(1)
		for {
			if !(i <= min+range1 && BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0) {
				break
			}
			v51 = s
			s++
			*(*int32)(unsafe.Pointer(dest)) = *(*int32)(unsafe.Pointer(dest))*int32(10) + int32(*(*uint8)(unsafe.Pointer(v51))) - int32('0')
			goto _50
		_50:
			;
			i *= int32(10)
		}
		if uint32(*(*int32)(unsafe.Pointer(dest))-min) >= uint32(range1) {
			return uintptr(0)
		}
		*(*int32)(unsafe.Pointer(dest)) -= adj
		switch int64(dest) - int64(tm) {
		case int64(uint64(UintptrFromInt32(0) + 28)):
		}
		goto update
		goto numeric_digits
	numeric_digits:
		;
		neg = 0
		if int32(*(*uint8)(unsafe.Pointer(s))) == int32('+') {
			s++
		} else {
			if int32(*(*uint8)(unsafe.Pointer(s))) == int32('-') {
				neg = int32(1)
				s++
			}
		}
		if !(BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-Uint32FromUint8('0') < Uint32FromInt32(10)) != 0) {
			return uintptr(0)
		}
		v53 = Int32FromInt32(0)
		i = v53
		*(*int32)(unsafe.Pointer(dest)) = v53
		for {
			if !(i < w && BoolInt32(uint32(*(*uint8)(unsafe.Pointer(s)))-uint32('0') < uint32(10)) != 0) {
				break
			}
			v54 = s
			s++
			*(*int32)(unsafe.Pointer(dest)) = *(*int32)(unsafe.Pointer(dest))*int32(10) + int32(*(*uint8)(unsafe.Pointer(v54))) - int32('0')
			goto _52
		_52:
			;
			i++
		}
		if neg != 0 {
			*(*int32)(unsafe.Pointer(dest)) = -*(*int32)(unsafe.Pointer(dest))
		}
		*(*int32)(unsafe.Pointer(dest)) -= adj
		goto update
		goto symbolic_range
	symbolic_range:
		;
		i = int32(2)*range1 - int32(1)
		for {
			if !(i >= 0) {
				break
			}
			ex = Xnl_langinfo(tls, min+i)
			len1 = Xstrlen(tls, ex)
			if Xstrncasecmp(tls, s, ex, len1) != 0 {
				goto _55
			}
			s += uintptr(len1)
			*(*int32)(unsafe.Pointer(dest)) = i % range1
			break
			goto _55
		_55:
			;
			i--
		}
		if i < 0 {
			return uintptr(0)
		}
		goto update
		goto update
	update:
		;
		//FIXME
	_41:
	}
	if want_century != 0 {
		(*Ttm)(unsafe.Pointer(tm)).Ftm_year = *(*int32)(unsafe.Pointer(bp + 8))
		if want_century&int32(2) != 0 {
			*(*int32)(unsafe.Pointer(tm + 20)) += *(*int32)(unsafe.Pointer(bp + 4))*int32(100) - int32(1900)
		} else {
			if (*Ttm)(unsafe.Pointer(tm)).Ftm_year <= int32(68) {
				*(*int32)(unsafe.Pointer(tm + 20)) += int32(100)
			}
		}
	}
	return s
}

func Xtime(tls *TLS, t uintptr) (r Ttime_t) {
	if __ccgo_strace {
		trc("tls=%v t=%v, (%v:)", tls, t, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* ts at bp+0 */ Ttimespec
	X__clock_gettime(tls, CLOCK_REALTIME, bp)
	if t != 0 {
		*(*Ttime_t)(unsafe.Pointer(t)) = (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
	}
	return (*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec
}

func Xtimegm(tls *TLS, tm uintptr) (r Ttime_t) {
	if __ccgo_strace {
		trc("tls=%v tm=%v, (%v:)", tls, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var t int64
	var _ /* new at bp+0 */ Ttm1
	_ = t
	t = X__tm_to_secs(tls, tm)
	if X__secs_to_tm(tls, t, bp) < 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EOVERFLOW)
		return int64(-int32(1))
	}
	*(*Ttm1)(unsafe.Pointer(tm)) = *(*Ttm1)(unsafe.Pointer(bp))
	(*Ttm1)(unsafe.Pointer(tm)).Ftm_isdst = 0
	(*Ttm1)(unsafe.Pointer(tm)).Ftm_gmtoff = 0
	(*Ttm1)(unsafe.Pointer(tm)).Ftm_zone = uintptr(unsafe.Pointer(&X__utc))
	return t
}

func Xtimer_delete(tls *TLS, t Ttimer_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v t=%v, (%v:)", tls, t, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var td Tpthread_t
	_ = td
	if int64(t) < 0 {
		td = uintptr(uint64(t) << Int32FromInt32(1))
		// __asm__ __volatile__ ("dmb ish" : : : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1872)
		AtomicStorePInt32(td+148, AtomicLoadPInt32(td+148)|(-Int32FromInt32(1)-Int32FromInt32(0x7fffffff)))
		// __asm__ __volatile__ ("dmb ish" : : : "memory");
		X__assert_fail(tls, __ccgo_ts+350, __ccgo_ts+385, 20, __ccgo_ts+1872)
		X__syscall2(tls, int64(SYS_tkill), int64((*t__pthread)(unsafe.Pointer(td)).Ftid), int64(Int32FromInt32(SIGTIMER)))
		return 0
	}
	return int32(X__syscall1(tls, int64(SYS_timer_delete), int64(t)))
}

func Xtimer_getoverrun(tls *TLS, t Ttimer_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v t=%v, (%v:)", tls, t, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var td Tpthread_t
	_ = td
	if int64(t) < 0 {
		td = uintptr(uint64(t) << Int32FromInt32(1))
		t = uintptr(uint64(AtomicLoadPInt32(td+148) & Int32FromInt32(INT_MAX)))
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_timer_getoverrun), int64(t)))))
}

func Xtimer_gettime(tls *TLS, t Ttimer_t, val uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v t=%v val=%v, (%v:)", tls, t, val, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var td Tpthread_t
	_ = td
	if int64(t) < 0 {
		td = uintptr(uint64(t) << Int32FromInt32(1))
		t = uintptr(uint64(AtomicLoadPInt32(td+148) & Int32FromInt32(INT_MAX)))
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_timer_gettime), int64(t), int64(val)))))
}

func Xtimer_settime(tls *TLS, t Ttimer_t, flags int32, val uintptr, old uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v t=%v flags=%v val=%v old=%v, (%v:)", tls, t, flags, val, old, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var td Tpthread_t
	_ = td
	if int64(t) < 0 {
		td = uintptr(uint64(t) << Int32FromInt32(1))
		t = uintptr(uint64(AtomicLoadPInt32(td+148) & Int32FromInt32(INT_MAX)))
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_timer_settime), int64(t), int64(flags), int64(val), int64(old)))))
}

type Ttms = struct {
	Ftms_utime  Tclock_t
	Ftms_stime  Tclock_t
	Ftms_cutime Tclock_t
	Ftms_cstime Tclock_t
}

func Xtimes(tls *TLS, tms uintptr) (r Tclock_t) {
	if __ccgo_strace {
		trc("tls=%v tms=%v, (%v:)", tls, tms, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall1(tls, int64(SYS_times), int64(tms))
}

// C documentation
//
//	/* There is no other implemented value than TIME_UTC; all other values
//	 * are considered erroneous. */
func Xtimespec_get(tls *TLS, ts uintptr, base int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v ts=%v base=%v, (%v:)", tls, ts, base, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret, v1 int32
	_, _ = ret, v1
	if base != int32(TIME_UTC) {
		return 0
	}
	ret = X__clock_gettime(tls, CLOCK_REALTIME, ts)
	if ret < 0 {
		v1 = 0
	} else {
		v1 = base
	}
	return v1
}

type Tutimbuf = struct {
	Factime  Ttime_t
	Fmodtime Ttime_t
}

func Xutime(tls *TLS, path uintptr, times uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v times=%v, (%v:)", tls, path, times, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var v1 uintptr
	_ = v1
	if times != 0 {
		*(*[2]Ttimespec)(unsafe.Pointer(bp)) = [2]Ttimespec{
			0: {
				Ftv_sec: (*Tutimbuf)(unsafe.Pointer(times)).Factime,
			},
			1: {
				Ftv_sec: (*Tutimbuf)(unsafe.Pointer(times)).Fmodtime,
			},
		}
		v1 = bp
	} else {
		v1 = uintptr(0)
	}
	return Xutimensat(tls, -int32(100), path, v1, 0)
}

func X__wcsftime_l(tls *TLS, s uintptr, n Tsize_t, f uintptr, tm uintptr, loc Tlocale_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v tm=%v loc=%v, (%v:)", tls, s, n, f, tm, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(528)
	defer tls.Free(528)
	var l, v2, v6, v7, v9 Tsize_t
	var pad, plus, v4 int32
	var t, t_mb, v3 uintptr
	var width uint64
	var _ /* buf at bp+8 */ [100]uint8
	var _ /* k at bp+0 */ Tsize_t
	var _ /* p at bp+512 */ uintptr
	var _ /* wbuf at bp+108 */ [100]Twchar_t
	_, _, _, _, _, _, _, _, _, _, _, _ = l, pad, plus, t, t_mb, width, v2, v3, v4, v6, v7, v9
	l = uint64(0)
	for {
		if !(l < n) {
			break
		}
		if !(*(*Twchar_t)(unsafe.Pointer(f)) != 0) {
			*(*Twchar_t)(unsafe.Pointer(s + uintptr(l)*4)) = uint32(0)
			return l
		}
		if *(*Twchar_t)(unsafe.Pointer(f)) != uint32('%') {
			v2 = l
			l++
			*(*Twchar_t)(unsafe.Pointer(s + uintptr(v2)*4)) = *(*Twchar_t)(unsafe.Pointer(f))
			goto _1
		}
		f += 4
		pad = 0
		if *(*Twchar_t)(unsafe.Pointer(f)) == uint32('-') || *(*Twchar_t)(unsafe.Pointer(f)) == uint32('_') || *(*Twchar_t)(unsafe.Pointer(f)) == uint32('0') {
			v3 = f
			f += 4
			pad = int32(*(*Twchar_t)(unsafe.Pointer(v3)))
		}
		v4 = BoolInt32(*(*Twchar_t)(unsafe.Pointer(f)) == Uint32FromUint8('+'))
		plus = v4
		if v4 != 0 {
			f += 4
		}
		width = Xwcstoul(tls, f, bp+512, int32(10))
		if *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512)))) == uint32('C') || *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512)))) == uint32('F') || *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512)))) == uint32('G') || *(*Twchar_t)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512)))) == uint32('Y') {
			if !(width != 0) && *(*uintptr)(unsafe.Pointer(bp + 512)) != f {
				width = uint64(1)
			}
		} else {
			width = uint64(0)
		}
		f = *(*uintptr)(unsafe.Pointer(bp + 512))
		if *(*Twchar_t)(unsafe.Pointer(f)) == uint32('E') || *(*Twchar_t)(unsafe.Pointer(f)) == uint32('O') {
			f += 4
		}
		t_mb = X__strftime_fmt_1(tls, bp+8, bp, int32(*(*Twchar_t)(unsafe.Pointer(f))), tm, loc, pad)
		if !(t_mb != 0) {
			break
		}
		*(*Tsize_t)(unsafe.Pointer(bp)) = Xmbstowcs(tls, bp+108, t_mb, Uint64FromInt64(400)/Uint64FromInt64(4))
		if *(*Tsize_t)(unsafe.Pointer(bp)) == uint64(-Int32FromInt32(1)) {
			return uint64(0)
		}
		t = bp + 108
		if width != 0 {
			for {
				if !(*(*Twchar_t)(unsafe.Pointer(t)) == uint32('+') || *(*Twchar_t)(unsafe.Pointer(t)) == uint32('-') || *(*Twchar_t)(unsafe.Pointer(t)) == uint32('0') && *(*Twchar_t)(unsafe.Pointer(t + 1*4)) != 0) {
					break
				}
				goto _5
			_5:
				;
				t += 4
				*(*Tsize_t)(unsafe.Pointer(bp))--
			}
			width--
			if plus != 0 && (*Ttm)(unsafe.Pointer(tm)).Ftm_year >= Int32FromInt32(10000)-Int32FromInt32(1900) {
				v6 = l
				l++
				*(*Twchar_t)(unsafe.Pointer(s + uintptr(v6)*4)) = uint32('+')
			} else {
				if (*Ttm)(unsafe.Pointer(tm)).Ftm_year < -int32(1900) {
					v7 = l
					l++
					*(*Twchar_t)(unsafe.Pointer(s + uintptr(v7)*4)) = uint32('-')
				} else {
					width++
				}
			}
			for {
				if !(width > *(*Tsize_t)(unsafe.Pointer(bp)) && l < n) {
					break
				}
				v9 = l
				l++
				*(*Twchar_t)(unsafe.Pointer(s + uintptr(v9)*4)) = uint32('0')
				goto _8
			_8:
				;
				width--
			}
		}
		if *(*Tsize_t)(unsafe.Pointer(bp)) >= n-l {
			*(*Tsize_t)(unsafe.Pointer(bp)) = n - l
		}
		Xwmemcpy(tls, s+uintptr(l)*4, t, *(*Tsize_t)(unsafe.Pointer(bp)))
		l += *(*Tsize_t)(unsafe.Pointer(bp))
		goto _1
	_1:
		;
		f += 4
	}
	if n != 0 {
		if l == n {
			l = n - uint64(1)
		}
		*(*Twchar_t)(unsafe.Pointer(s + uintptr(l)*4)) = uint32(0)
	}
	return uint64(0)
}

func Xwcsftime(tls *TLS, wcs uintptr, n Tsize_t, f uintptr, tm uintptr) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v wcs=%v n=%v f=%v tm=%v, (%v:)", tls, wcs, n, f, tm, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__wcsftime_l(tls, wcs, n, f, tm, (*t__pthread)(unsafe.Pointer(___get_tp(tls))).Flocale)
}

func Xwcsftime_l(tls *TLS, s uintptr, n Tsize_t, f uintptr, tm uintptr, loc Tlocale_t) (r Tsize_t) {
	if __ccgo_strace {
		trc("tls=%v s=%v n=%v f=%v tm=%v loc=%v, (%v:)", tls, s, n, f, tm, loc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__wcsftime_l(tls, s, n, f, tm, loc)
}

func X_exit(tls *TLS, status int32) {
	if __ccgo_strace {
		trc("tls=%v status=%v, (%v:)", tls, status, origin(2))
	}
	X_Exit(tls, status)
}

func Xaccess(tls *TLS, filename uintptr, amode int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v filename=%v amode=%v, (%v:)", tls, filename, amode, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_faccessat), int64(-Int32FromInt32(100)), int64(filename), int64(amode), int64(Int32FromInt32(0))))))
}

func Xacct(tls *TLS, filename uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v filename=%v, (%v:)", tls, filename, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_acct), int64(filename)))))
}

func Xalarm(tls *TLS, seconds uint32) (r uint32) {
	if __ccgo_strace {
		trc("tls=%v seconds=%v, (%v:)", tls, seconds, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var _ /* it at bp+0 */ Titimerval
	var _ /* old at bp+32 */ Titimerval
	*(*Titimerval)(unsafe.Pointer(bp)) = Titimerval{
		Fit_value: Ttimeval{
			Ftv_sec: int64(seconds),
		},
	}
	*(*Titimerval)(unsafe.Pointer(bp + 32)) = Titimerval{}
	Xsetitimer(tls, ITIMER_REAL, bp, bp+32)
	return uint32((*(*Titimerval)(unsafe.Pointer(bp + 32))).Fit_value.Ftv_sec + BoolInt64(!!((*(*Titimerval)(unsafe.Pointer(bp + 32))).Fit_value.Ftv_usec != 0)))
}

func Xchdir(tls *TLS, path uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v, (%v:)", tls, path, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_chdir), int64(path)))))
}

func Xchown(tls *TLS, path uintptr, uid Tuid_t, gid Tgid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v uid=%v gid=%v, (%v:)", tls, path, uid, gid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_fchownat), int64(-Int32FromInt32(100)), int64(path), int64(uid), int64(gid), int64(Int32FromInt32(0))))))
}

func _dummy12(tls *TLS, fd int32) (r int32) {
	return fd
}

func Xclose(tls *TLS, fd int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r int32
	_ = r
	fd = _dummy12(tls, fd)
	r = int32(___syscall_cp(tls, int64(SYS_close), int64(fd), 0, 0, 0, 0, 0))
	if r == -int32(EINTR) {
		r = 0
	}
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xctermid(tls *TLS, s uintptr) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v s=%v, (%v:)", tls, s, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var v1 uintptr
	_ = v1
	if s != 0 {
		v1 = Xstrcpy(tls, s, __ccgo_ts+292)
	} else {
		v1 = __ccgo_ts + 292
	}
	return v1
}

func Xdup(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_dup), int64(fd)))))
}

func Xdup2(tls *TLS, old int32, new1 int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v old=%v new1=%v, (%v:)", tls, old, new1, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v1 int32
	_, _ = r, v1
	if old == new1 {
		r = int32(X__syscall2(tls, int64(SYS_fcntl), int64(old), int64(Int32FromInt32(F_GETFD))))
		if r >= 0 {
			return old
		}
	} else {
		for {
			v1 = int32(X__syscall3(tls, int64(SYS_dup3), int64(old), int64(new1), int64(Int32FromInt32(0))))
			r = v1
			if !(v1 == -int32(EBUSY)) {
				break
			}
		}
	}
	return int32(X__syscall_ret(tls, uint64(r)))
}

func X__dup3(tls *TLS, old int32, new1 int32, flags int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v old=%v new1=%v flags=%v, (%v:)", tls, old, new1, flags, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	var r, v1 int32
	_, _ = r, v1
	for {
		v1 = int32(X__syscall3(tls, int64(SYS_dup3), int64(old), int64(new1), int64(flags)))
		r = v1
		if !(v1 == -int32(EBUSY)) {
			break
		}
	}
	return int32(X__syscall_ret(tls, uint64(r)))
}

func Xdup3(tls *TLS, old int32, new1 int32, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v old=%v new1=%v flags=%v, (%v:)", tls, old, new1, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__dup3(tls, old, new1, flags)
}

type Tctx1 = struct {
	Ffd       int32
	Ffilename uintptr
	Famode    int32
	Fp        int32
}

func _checker(tls *TLS, p uintptr) (r int32) {
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var c uintptr
	var _ /* ret at bp+0 */ int32
	_ = c
	c = p
	if X__syscall2(tls, int64(SYS_setregid), X__syscall0(tls, int64(SYS_getegid)), int64(-Int32FromInt32(1))) != 0 || X__syscall2(tls, int64(SYS_setreuid), X__syscall0(tls, int64(SYS_geteuid)), int64(-Int32FromInt32(1))) != 0 {
		X__syscall1(tls, int64(SYS_exit), int64(Int32FromInt32(1)))
	}
	*(*int32)(unsafe.Pointer(bp)) = int32(X__syscall4(tls, int64(SYS_faccessat), int64((*Tctx1)(unsafe.Pointer(c)).Ffd), int64((*Tctx1)(unsafe.Pointer(c)).Ffilename), int64((*Tctx1)(unsafe.Pointer(c)).Famode), int64(Int32FromInt32(0))))
	X__syscall3(tls, int64(SYS_write), int64((*Tctx1)(unsafe.Pointer(c)).Fp), int64(bp), int64(Uint64FromInt64(4)))
	return 0
}

func Xfaccessat(tls *TLS, fd int32, filename uintptr, amode int32, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v filename=%v amode=%v flag=%v, (%v:)", tls, fd, filename, amode, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int32
	_ = ret
	if flag != 0 {
		ret = int32(X__syscall4(tls, int64(SYS_faccessat2), int64(fd), int64(filename), int64(amode), int64(flag)))
		if ret != -int32(ENOSYS) {
			return int32(X__syscall_ret(tls, uint64(ret)))
		}
	}
	if flag & ^Int32FromInt32(AT_EACCESS) != 0 {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_faccessat), int64(fd), int64(filename), int64(amode)))))
}

func Xfchdir(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ret int32
	var _ /* buf at bp+0 */ [27]uint8
	_ = ret
	ret = int32(X__syscall1(tls, int64(SYS_fchdir), int64(fd)))
	if ret != -int32(EBADF) || X__syscall2(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_GETFD))) < 0 {
		return int32(X__syscall_ret(tls, uint64(ret)))
	}
	X__procfdname(tls, bp, uint32(fd))
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_chdir), int64(bp)))))
}

func Xfchown(tls *TLS, fd int32, uid Tuid_t, gid Tgid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v uid=%v gid=%v, (%v:)", tls, fd, uid, gid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var ret int32
	var _ /* buf at bp+0 */ [27]uint8
	_ = ret
	ret = int32(X__syscall3(tls, int64(SYS_fchown), int64(fd), int64(uid), int64(gid)))
	if ret != -int32(EBADF) || X__syscall2(tls, int64(SYS_fcntl), int64(fd), int64(Int32FromInt32(F_GETFD))) < 0 {
		return int32(X__syscall_ret(tls, uint64(ret)))
	}
	X__procfdname(tls, bp, uint32(fd))
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_fchownat), int64(-Int32FromInt32(100)), int64(bp), int64(uid), int64(gid), int64(Int32FromInt32(0))))))
}

func Xfchownat(tls *TLS, fd int32, path uintptr, uid Tuid_t, gid Tgid_t, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v uid=%v gid=%v flag=%v, (%v:)", tls, fd, path, uid, gid, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_fchownat), int64(fd), int64(path), int64(uid), int64(gid), int64(flag)))))
}

func Xfdatasync(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_fdatasync), int64(fd), 0, 0, 0, 0, 0))))
}

func Xfsync(tls *TLS, fd int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_fsync), int64(fd), 0, 0, 0, 0, 0))))
}

func Xftruncate(tls *TLS, fd int32, length Toff_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v length=%v, (%v:)", tls, fd, length, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_ftruncate), int64(fd), length))))
}

func Xgetcwd(tls *TLS, buf uintptr, size Tsize_t) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v buf=%v size=%v, (%v:)", tls, buf, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int64
	var tmp, v3 uintptr
	var v1 t__predefined_size_t
	var v2 int32
	_, _, _, _, _ = ret, tmp, v1, v2, v3
	defer func() { Xrealloc(tls, tmp, 0) }()
	if buf != 0 {
		v2 = int32(1)
	} else {
		v2 = int32(PATH_MAX)
	}
	v1 = uint64(v2)
	tmp = Xrealloc(tls, tmp, v1)
	if !(buf != 0) {
		buf = tmp
		size = v1
	} else {
		if !(size != 0) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EINVAL)
			return uintptr(0)
		}
	}
	ret = X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_getcwd), int64(buf), int64(size))))
	if ret < 0 {
		return uintptr(0)
	}
	if ret == 0 || int32(*(*uint8)(unsafe.Pointer(buf))) != int32('/') {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOENT)
		return uintptr(0)
	}
	if buf == tmp {
		v3 = Xstrdup(tls, buf)
	} else {
		v3 = buf
	}
	return v3
}

func Xgetegid(tls *TLS) (r Tgid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint32(X__syscall0(tls, int64(SYS_getegid)))
}

func Xgeteuid(tls *TLS) (r Tuid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint32(X__syscall0(tls, int64(SYS_geteuid)))
}

func Xgetgid(tls *TLS) (r Tgid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint32(X__syscall0(tls, int64(SYS_getgid)))
}

func Xgetgroups(tls *TLS, count int32, list uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v count=%v list=%v, (%v:)", tls, count, list, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_getgroups), int64(count), int64(list)))))
}

func Xgethostname(tls *TLS, name uintptr, len1 Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v len1=%v, (%v:)", tls, name, len1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(400)
	defer tls.Free(400)
	var i Tsize_t
	var v2 uint8
	var v3 bool
	var _ /* uts at bp+0 */ Tutsname1
	_, _, _ = i, v2, v3
	if Xuname(tls, bp) != 0 {
		return -int32(1)
	}
	if len1 > uint64(65) {
		len1 = uint64(65)
	}
	i = uint64(0)
	for {
		if v3 = i < len1; v3 {
			v2 = *(*uint8)(unsafe.Pointer(bp + 65 + uintptr(i)))
			*(*uint8)(unsafe.Pointer(name + uintptr(i))) = v2
		}
		if !(v3 && v2 != 0) {
			break
		}
		goto _1
	_1:
		;
		i++
	}
	if i != 0 && i == len1 {
		*(*uint8)(unsafe.Pointer(name + uintptr(i-uint64(1)))) = uint8(0)
	}
	return 0
}

func Xgetlogin(tls *TLS) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xgetenv(tls, __ccgo_ts+1885)
}

func Xgetlogin_r(tls *TLS, name uintptr, size Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v name=%v size=%v, (%v:)", tls, name, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var logname uintptr
	_ = logname
	logname = Xgetlogin(tls)
	if !(logname != 0) {
		return int32(ENXIO)
	} /* or...? */
	if Xstrlen(tls, logname) >= size {
		return int32(ERANGE)
	}
	Xstrcpy(tls, name, logname)
	return 0
}

func Xgetpgid(tls *TLS, pid Tpid_t) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v pid=%v, (%v:)", tls, pid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_getpgid), int64(pid)))))
}

func Xgetpgrp(tls *TLS) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall1(tls, int64(SYS_getpgid), int64(Int32FromInt32(0))))
}

func Xgetpid(tls *TLS) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall0(tls, int64(SYS_getpid)))
}

func Xgetppid(tls *TLS) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall0(tls, int64(SYS_getppid)))
}

func Xgetsid(tls *TLS, pid Tpid_t) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v pid=%v, (%v:)", tls, pid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall1(tls, int64(SYS_getsid), int64(pid)))))
}

func Xgetuid(tls *TLS) (r Tuid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return uint32(X__syscall0(tls, int64(SYS_getuid)))
}

func Xisatty(tls *TLS, fd int32) (r1 int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r uint64
	var _ /* wsz at bp+0 */ Twinsize
	_ = r
	r = uint64(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_ioctl), int64(fd), int64(Int32FromInt32(TIOCGWINSZ)), int64(bp)))))
	if r == uint64(0) {
		return int32(1)
	}
	if *(*int32)(unsafe.Pointer(X__errno_location(tls))) != int32(EBADF) {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(ENOTTY)
	}
	return 0
}

func Xlchown(tls *TLS, path uintptr, uid Tuid_t, gid Tgid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v uid=%v gid=%v, (%v:)", tls, path, uid, gid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_fchownat), int64(-Int32FromInt32(100)), int64(path), int64(uid), int64(gid), int64(Int32FromInt32(AT_SYMLINK_NOFOLLOW))))))
}

func Xlink(tls *TLS, existing uintptr, new1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v existing=%v new1=%v, (%v:)", tls, existing, new1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_linkat), int64(-Int32FromInt32(100)), int64(existing), int64(-Int32FromInt32(100)), int64(new1), int64(Int32FromInt32(0))))))
}

func Xlinkat(tls *TLS, fd1 int32, existing uintptr, fd2 int32, new1 uintptr, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd1=%v existing=%v fd2=%v new1=%v flag=%v, (%v:)", tls, fd1, existing, fd2, new1, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall5(tls, int64(SYS_linkat), int64(fd1), int64(existing), int64(fd2), int64(new1), int64(flag)))))
}

func X__lseek(tls *TLS, fd int32, offset Toff_t, whence int32) (r Toff_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v offset=%v whence=%v, (%v:)", tls, fd, offset, whence, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_lseek), int64(fd), offset, int64(whence))))
}

func Xlseek(tls *TLS, fd int32, offset Toff_t, whence int32) (r Toff_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v offset=%v whence=%v, (%v:)", tls, fd, offset, whence, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__lseek(tls, fd, offset, whence)
}

func Xnice(tls *TLS, inc int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v inc=%v, (%v:)", tls, inc, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var prio int32
	_ = prio
	prio = inc
	// Only query old priority if it can affect the result.
	// This also avoids issues with integer overflow.
	if inc > -Int32FromInt32(2)*Int32FromInt32(NZERO) && inc < Int32FromInt32(2)*Int32FromInt32(NZERO) {
		prio += Xgetpriority(tls, PRIO_PROCESS, uint32(0))
	}
	if prio > Int32FromInt32(NZERO)-Int32FromInt32(1) {
		prio = Int32FromInt32(NZERO) - Int32FromInt32(1)
	}
	if prio < -int32(NZERO) {
		prio = -int32(NZERO)
	}
	if Xsetpriority(tls, PRIO_PROCESS, uint32(0), prio) != 0 {
		if *(*int32)(unsafe.Pointer(X__errno_location(tls))) == int32(EACCES) {
			*(*int32)(unsafe.Pointer(X__errno_location(tls))) = int32(EPERM)
		}
		return -int32(1)
	} else {
		return prio
	}
	return r
}

func Xpause(tls *TLS) (r int32) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_ppoll), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), int64(Int32FromInt32(0)), 0, 0))))
}

func Xpipe(tls *TLS, fd uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_pipe2), int64(fd), int64(Int32FromInt32(0))))))
}

func Xpipe2(tls *TLS, fd uintptr, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v flag=%v, (%v:)", tls, fd, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var ret int32
	_ = ret
	if !(flag != 0) {
		return Xpipe(tls, fd)
	}
	ret = int32(X__syscall2(tls, int64(SYS_pipe2), int64(fd), int64(flag)))
	if ret != -int32(ENOSYS) {
		return int32(X__syscall_ret(tls, uint64(ret)))
	}
	if flag & ^(Int32FromInt32(O_CLOEXEC)|Int32FromInt32(O_NONBLOCK)) != 0 {
		return int32(X__syscall_ret(tls, uint64(-Int32FromInt32(EINVAL))))
	}
	ret = Xpipe(tls, fd)
	if ret != 0 {
		return ret
	}
	if flag&int32(O_CLOEXEC) != 0 {
		X__syscall3(tls, int64(SYS_fcntl), int64(*(*int32)(unsafe.Pointer(fd))), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
		X__syscall3(tls, int64(SYS_fcntl), int64(*(*int32)(unsafe.Pointer(fd + 1*4))), int64(Int32FromInt32(F_SETFD)), int64(Int32FromInt32(FD_CLOEXEC)))
	}
	if flag&int32(O_NONBLOCK) != 0 {
		X__syscall3(tls, int64(SYS_fcntl), int64(*(*int32)(unsafe.Pointer(fd))), int64(Int32FromInt32(F_SETFL)), int64(Int32FromInt32(O_NONBLOCK)))
		X__syscall3(tls, int64(SYS_fcntl), int64(*(*int32)(unsafe.Pointer(fd + 1*4))), int64(Int32FromInt32(F_SETFL)), int64(Int32FromInt32(O_NONBLOCK)))
	}
	return 0
}

func Xposix_close(tls *TLS, fd int32, flags int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v flags=%v, (%v:)", tls, fd, flags, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xclose(tls, fd)
}

func Xpread(tls *TLS, fd int32, buf uintptr, size Tsize_t, ofs Toff_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v size=%v ofs=%v, (%v:)", tls, fd, buf, size, ofs, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_pread64), int64(fd), int64(buf), int64(size), ofs, 0, 0)))
}

func Xpreadv(tls *TLS, fd int32, iov uintptr, count int32, ofs Toff_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v iov=%v count=%v ofs=%v, (%v:)", tls, fd, iov, count, ofs, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_preadv), int64(fd), int64(iov), int64(count), ofs, ofs>>Int32FromInt32(32), 0)))
}

func Xpwrite(tls *TLS, fd int32, buf uintptr, size Tsize_t, ofs Toff_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v size=%v ofs=%v, (%v:)", tls, fd, buf, size, ofs, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_pwrite64), int64(fd), int64(buf), int64(size), ofs, 0, 0)))
}

func Xpwritev(tls *TLS, fd int32, iov uintptr, count int32, ofs Toff_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v iov=%v count=%v ofs=%v, (%v:)", tls, fd, iov, count, ofs, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_pwritev), int64(fd), int64(iov), int64(count), ofs, ofs>>Int32FromInt32(32), 0)))
}

func Xread(tls *TLS, fd int32, buf uintptr, count Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v count=%v, (%v:)", tls, fd, buf, count, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_read), int64(fd), int64(buf), int64(count), 0, 0, 0)))
}

func Xreadlink(tls *TLS, path uintptr, buf uintptr, bufsize Tsize_t) (r1 Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v path=%v buf=%v bufsize=%v, (%v:)", tls, path, buf, bufsize, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r int32
	var _ /* dummy at bp+0 */ [1]uint8
	_ = r
	if !(bufsize != 0) {
		buf = bp
		bufsize = uint64(1)
	}
	r = int32(X__syscall4(tls, int64(SYS_readlinkat), int64(-Int32FromInt32(100)), int64(path), int64(buf), int64(bufsize)))
	if buf == bp && r > 0 {
		r = 0
	}
	return X__syscall_ret(tls, uint64(r))
}

func Xreadlinkat(tls *TLS, fd int32, path uintptr, buf uintptr, bufsize Tsize_t) (r1 Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v buf=%v bufsize=%v, (%v:)", tls, fd, path, buf, bufsize, origin(2))
		defer func() { trc("-> %v", r1) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var r int32
	var _ /* dummy at bp+0 */ [1]uint8
	_ = r
	if !(bufsize != 0) {
		buf = bp
		bufsize = uint64(1)
	}
	r = int32(X__syscall4(tls, int64(SYS_readlinkat), int64(fd), int64(path), int64(buf), int64(bufsize)))
	if buf == bp && r > 0 {
		r = 0
	}
	return X__syscall_ret(tls, uint64(r))
}

func Xreadv(tls *TLS, fd int32, iov uintptr, count int32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v iov=%v count=%v, (%v:)", tls, fd, iov, count, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_readv), int64(fd), int64(iov), int64(count), 0, 0, 0)))
}

func Xrenameat(tls *TLS, oldfd int32, old uintptr, newfd int32, new1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v oldfd=%v old=%v newfd=%v new1=%v, (%v:)", tls, oldfd, old, newfd, new1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall4(tls, int64(SYS_renameat), int64(oldfd), int64(old), int64(newfd), int64(new1)))))
}

func Xrmdir(tls *TLS, path uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v, (%v:)", tls, path, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_unlinkat), int64(-Int32FromInt32(100)), int64(path), int64(Int32FromInt32(AT_REMOVEDIR))))))
}

func Xsetgid(tls *TLS, gid Tgid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v gid=%v, (%v:)", tls, gid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__setxid(tls, int32(SYS_setgid), int32(gid), 0, 0)
}

func Xsetpgid(tls *TLS, pid Tpid_t, pgid Tpid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v pid=%v pgid=%v, (%v:)", tls, pid, pgid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_setpgid), int64(pid), int64(pgid)))))
}

func Xsetpgrp(tls *TLS) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return Xsetpgid(tls, 0, 0)
}

func Xsetsid(tls *TLS) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall0(tls, int64(SYS_setsid)))))
}

func Xsetuid(tls *TLS, uid Tuid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v uid=%v, (%v:)", tls, uid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__setxid(tls, int32(SYS_setuid), int32(uid), 0, 0)
}

type Tctx2 = struct {
	Fid  int32
	Feid int32
	Fsid int32
	Fnr  int32
	Fret int32
}

func _do_setxid(tls *TLS, p uintptr) {
	var c uintptr
	var ret int32
	_, _ = c, ret
	c = p
	if (*Tctx2)(unsafe.Pointer(c)).Fret < 0 {
		return
	}
	ret = int32(X__syscall3(tls, int64((*Tctx2)(unsafe.Pointer(c)).Fnr), int64((*Tctx2)(unsafe.Pointer(c)).Fid), int64((*Tctx2)(unsafe.Pointer(c)).Feid), int64((*Tctx2)(unsafe.Pointer(c)).Fsid)))
	if ret != 0 && !((*Tctx2)(unsafe.Pointer(c)).Fret != 0) {
		/* If one thread fails to set ids after another has already
		 * succeeded, forcibly killing the process is the only safe
		 * thing to do. State is inconsistent and dangerous. Use
		 * SIGKILL because it is uncatchable. */
		X__block_all_sigs(tls, uintptr(0))
		X__syscall2(tls, int64(SYS_kill), X__syscall0(tls, int64(SYS_getpid)), int64(Int32FromInt32(SIGKILL)))
	}
	(*Tctx2)(unsafe.Pointer(c)).Fret = ret
}

func X__setxid(tls *TLS, nr int32, id int32, eid int32, sid int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v nr=%v id=%v eid=%v sid=%v, (%v:)", tls, nr, id, eid, sid, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var v1 int32
	var _ /* c at bp+0 */ Tctx2
	_ = v1
	/* ret is initially nonzero so that failure of the first thread does not
	 * trigger the safety kill above. */
	*(*Tctx2)(unsafe.Pointer(bp)) = Tctx2{
		Fid:  id,
		Feid: eid,
		Fsid: sid,
		Fnr:  nr,
		Fret: int32(1),
	}
	___synccall(tls, __ccgo_fp(_do_setxid), bp)
	if (*(*Tctx2)(unsafe.Pointer(bp))).Fret > 0 {
		v1 = -int32(EAGAIN)
	} else {
		v1 = (*(*Tctx2)(unsafe.Pointer(bp))).Fret
	}
	return int32(X__syscall_ret(tls, uint64(v1)))
}

func Xsleep(tls *TLS, seconds uint32) (r uint32) {
	if __ccgo_strace {
		trc("tls=%v seconds=%v, (%v:)", tls, seconds, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimespec
	*(*Ttimespec)(unsafe.Pointer(bp)) = Ttimespec{
		Ftv_sec: int64(seconds),
	}
	if Xnanosleep(tls, bp, bp) != 0 {
		return uint32((*(*Ttimespec)(unsafe.Pointer(bp))).Ftv_sec)
	}
	return uint32(0)
}

func Xsymlink(tls *TLS, existing uintptr, new1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v existing=%v new1=%v, (%v:)", tls, existing, new1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_symlinkat), int64(existing), int64(-Int32FromInt32(100)), int64(new1)))))
}

func Xsymlinkat(tls *TLS, existing uintptr, fd int32, new1 uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v existing=%v fd=%v new1=%v, (%v:)", tls, existing, fd, new1, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_symlinkat), int64(existing), int64(fd), int64(new1)))))
}

func Xsync(tls *TLS) {
	if __ccgo_strace {
		trc("tls=%v, (%v:)", tls, origin(2))
	}
	X__syscall0(tls, int64(SYS_sync))
}

func Xtcgetpgrp(tls *TLS, fd int32) (r Tpid_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* pgrp at bp+0 */ int32
	if Xioctl(tls, fd, int32(TIOCGPGRP), VaList(bp+16, bp)) < 0 {
		return -int32(1)
	}
	return *(*int32)(unsafe.Pointer(bp))
}

func Xtcsetpgrp(tls *TLS, fd int32, pgrp Tpid_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v pgrp=%v, (%v:)", tls, fd, pgrp, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(32)
	defer tls.Free(32)
	var _ /* pgrp_int at bp+0 */ int32
	*(*int32)(unsafe.Pointer(bp)) = pgrp
	return Xioctl(tls, fd, int32(TIOCSPGRP), VaList(bp+16, bp))
}

func Xtruncate(tls *TLS, path uintptr, length Toff_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v length=%v, (%v:)", tls, path, length, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall2(tls, int64(SYS_truncate), int64(path), length))))
}

/* Support signed or unsigned plain-char */

/* Implementation choices... */

/* Arbitrary numbers... */

/* POSIX/SUS requirements follow. These numbers come directly
 * from SUS and have nothing to do with the host system. */

func Xttyname(tls *TLS, fd int32) (r uintptr) {
	if __ccgo_strace {
		trc("tls=%v fd=%v, (%v:)", tls, fd, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	var result, v1 int32
	_, _ = result, v1
	v1 = Xttyname_r(tls, fd, uintptr(unsafe.Pointer(&_buf10)), uint64(32))
	result = v1
	if v1 != 0 {
		*(*int32)(unsafe.Pointer(X__errno_location(tls))) = result
		return UintptrFromInt32(0)
	}
	return uintptr(unsafe.Pointer(&_buf10))
}

var _buf10 [32]uint8

func Xttyname_r(tls *TLS, fd int32, name uintptr, size Tsize_t) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v name=%v size=%v, (%v:)", tls, fd, name, size, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(288)
	defer tls.Free(288)
	var l Tssize_t
	var _ /* procname at bp+256 */ [29]uint8
	var _ /* st1 at bp+0 */ Tstat
	var _ /* st2 at bp+128 */ Tstat
	_ = l
	if !(Xisatty(tls, fd) != 0) {
		return *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	}
	X__procfdname(tls, bp+256, uint32(fd))
	l = Xreadlink(tls, bp+256, name, size)
	if l < 0 {
		return *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	} else {
		if uint64(l) == size {
			return int32(ERANGE)
		}
	}
	*(*uint8)(unsafe.Pointer(name + uintptr(l))) = uint8(0)
	if Xstat(tls, name, bp) != 0 || Xfstat(tls, fd, bp+128) != 0 {
		return *(*int32)(unsafe.Pointer(X__errno_location(tls)))
	}
	if (*(*Tstat)(unsafe.Pointer(bp))).Fst_dev != (*(*Tstat)(unsafe.Pointer(bp + 128))).Fst_dev || (*(*Tstat)(unsafe.Pointer(bp))).Fst_ino != (*(*Tstat)(unsafe.Pointer(bp + 128))).Fst_ino {
		return int32(ENODEV)
	}
	return 0
}

func Xualarm(tls *TLS, value uint32, interval uint32) (r uint32) {
	if __ccgo_strace {
		trc("tls=%v value=%v interval=%v, (%v:)", tls, value, interval, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(64)
	defer tls.Free(64)
	var _ /* it at bp+0 */ Titimerval
	var _ /* it_old at bp+32 */ Titimerval
	*(*Titimerval)(unsafe.Pointer(bp)) = Titimerval{
		Fit_interval: Ttimeval{
			Ftv_usec: int64(interval),
		},
		Fit_value: Ttimeval{
			Ftv_usec: int64(value),
		},
	}
	Xsetitimer(tls, ITIMER_REAL, bp, bp+32)
	return uint32((*(*Titimerval)(unsafe.Pointer(bp + 32))).Fit_value.Ftv_sec*int64(1000000) + (*(*Titimerval)(unsafe.Pointer(bp + 32))).Fit_value.Ftv_usec)
}

func Xunlink(tls *TLS, path uintptr) (r int32) {
	if __ccgo_strace {
		trc("tls=%v path=%v, (%v:)", tls, path, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_unlinkat), int64(-Int32FromInt32(100)), int64(path), int64(Int32FromInt32(0))))))
}

func Xunlinkat(tls *TLS, fd int32, path uintptr, flag int32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v fd=%v path=%v flag=%v, (%v:)", tls, fd, path, flag, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return int32(X__syscall_ret(tls, uint64(X__syscall3(tls, int64(SYS_unlinkat), int64(fd), int64(path), int64(flag)))))
}

func Xusleep(tls *TLS, useconds uint32) (r int32) {
	if __ccgo_strace {
		trc("tls=%v useconds=%v, (%v:)", tls, useconds, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	bp := tls.Alloc(16)
	defer tls.Free(16)
	var _ /* tv at bp+0 */ Ttimespec
	*(*Ttimespec)(unsafe.Pointer(bp)) = Ttimespec{
		Ftv_sec:  int64(useconds / uint32(1000000)),
		Ftv_nsec: int64(useconds % uint32(1000000) * uint32(1000)),
	}
	return Xnanosleep(tls, bp, bp)
}

func Xwrite(tls *TLS, fd int32, buf uintptr, count Tsize_t) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v buf=%v count=%v, (%v:)", tls, fd, buf, count, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_write), int64(fd), int64(buf), int64(count), 0, 0, 0)))
}

func Xwritev(tls *TLS, fd int32, iov uintptr, count int32) (r Tssize_t) {
	if __ccgo_strace {
		trc("tls=%v fd=%v iov=%v count=%v, (%v:)", tls, fd, iov, count, origin(2))
		defer func() { trc("-> %v", r) }()
	}
	return X__syscall_ret(tls, uint64(___syscall_cp(tls, int64(SYS_writev), int64(fd), int64(iov), int64(count), 0, 0, 0)))
}

func __ccgo_fp(f interface{}) uintptr {
	type iface [2]uintptr
	return (*iface)(unsafe.Pointer(&f))[1]
}

var X__abort_lock [1]int32

var X__at_quick_exit_lockptr = uintptr(unsafe.Pointer(&_lock))

var X__c_dot_utf8 = t__locale_map{
	Fmap1:     uintptr(unsafe.Pointer(&_empty_mo)),
	Fmap_size: uint64(20),
	Fname:     [24]uint8{'C', '.', 'U', 'T', 'F', '-', '8'},
}

var X__c_dot_utf8_locale = t__locale_struct{
	Fcat: [6]uintptr{
		0: uintptr(unsafe.Pointer(&X__c_dot_utf8)),
	},
}

var X__c_locale = t__locale_struct{}

var Xdaylight int32

var X__eintr_valid_flag int32

var Xenviron uintptr

var X__exp2f_data = Texp2f_data{
	Ftab: [32]Tuint64_t{
		0:  uint64(0x3ff0000000000000),
		1:  uint64(0x3fefd9b0d3158574),
		2:  uint64(0x3fefb5586cf9890f),
		3:  uint64(0x3fef9301d0125b51),
		4:  uint64(0x3fef72b83c7d517b),
		5:  uint64(0x3fef54873168b9aa),
		6:  uint64(0x3fef387a6e756238),
		7:  uint64(0x3fef1e9df51fdee1),
		8:  uint64(0x3fef06fe0a31b715),
		9:  uint64(0x3feef1a7373aa9cb),
		10: uint64(0x3feedea64c123422),
		11: uint64(0x3feece086061892d),
		12: uint64(0x3feebfdad5362a27),
		13: uint64(0x3feeb42b569d4f82),
		14: uint64(0x3feeab07dd485429),
		15: uint64(0x3feea47eb03a5585),
		16: uint64(0x3feea09e667f3bcd),
		17: uint64(0x3fee9f75e8ec5f74),
		18: uint64(0x3feea11473eb0187),
		19: uint64(0x3feea589994cce13),
		20: uint64(0x3feeace5422aa0db),
		21: uint64(0x3feeb737b0cdc5e5),
		22: uint64(0x3feec49182a3f090),
		23: uint64(0x3feed503b23e255d),
		24: uint64(0x3feee89f995ad3ad),
		25: uint64(0x3feeff76f2fb5e47),
		26: uint64(0x3fef199bdd85529c),
		27: uint64(0x3fef3720dcef9069),
		28: uint64(0x3fef5818dcfba487),
		29: uint64(0x3fef7c97337b9b5f),
		30: uint64(0x3fefa4afa2a490da),
		31: uint64(0x3fefd0765b6e4540),
	},
	Fshift_scaled: Float64FromFloat64(6.755399441055744e+15) / float64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)),
	Fpoly: [3]float64{
		0: float64(0.05550361559341535),
		1: float64(0.2402284522445722),
		2: float64(0.6931471806916203),
	},
	Fshift:         float64(6.755399441055744e+15),
	Finvln2_scaled: Float64FromFloat64(1.4426950408889634) * float64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)),
	Fpoly_scaled: [3]float64{
		0: Float64FromFloat64(0.05550361559341535) / float64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)) / float64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)) / float64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)),
		1: Float64FromFloat64(0.2402284522445722) / float64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)) / float64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)),
		2: Float64FromFloat64(0.6931471806916203) / float64(Int32FromInt32(1)<<Int32FromInt32(EXP2F_TABLE_BITS)),
	},
}

var X__exp_data = Texp_data{
	Finvln2N:   Float64FromFloat64(1.4426950408889634) * float64(Int32FromInt32(1)<<Int32FromInt32(EXP_TABLE_BITS)),
	Fshift:     float64(6.755399441055744e+15),
	Fnegln2hiN: -Float64FromFloat64(0.005415212348111709),
	Fnegln2loN: -Float64FromFloat64(1.2864023111638346e-14),
	Fpoly: [4]float64{
		0: float64(0.49999999999996786),
		1: float64(0.16666666666665886),
		2: float64(0.0416666808410674),
		3: float64(0.008333335853059549),
	},
	Fexp2_shift: Float64FromFloat64(6.755399441055744e+15) / float64(Int32FromInt32(1)<<Int32FromInt32(EXP_TABLE_BITS)),
	Fexp2_poly: [5]float64{
		0: float64(0.6931471805599453),
		1: float64(0.24022650695909065),
		2: float64(0.0555041086686087),
		3: float64(0.009618131975721055),
		4: float64(0.0013332074570119598),
	},
	Ftab: [256]Tuint64_t{
		1:   uint64(0x3ff0000000000000),
		2:   uint64(0x3c9b3b4f1a88bf6e),
		3:   uint64(0x3feff63da9fb3335),
		4:   uint64(0xbc7160139cd8dc5d),
		5:   uint64(0x3fefec9a3e778061),
		6:   uint64(0xbc905e7a108766d1),
		7:   uint64(0x3fefe315e86e7f85),
		8:   uint64(0x3c8cd2523567f613),
		9:   uint64(0x3fefd9b0d3158574),
		10:  uint64(0xbc8bce8023f98efa),
		11:  uint64(0x3fefd06b29ddf6de),
		12:  uint64(0x3c60f74e61e6c861),
		13:  uint64(0x3fefc74518759bc8),
		14:  uint64(0x3c90a3e45b33d399),
		15:  uint64(0x3fefbe3ecac6f383),
		16:  uint64(0x3c979aa65d837b6d),
		17:  uint64(0x3fefb5586cf9890f),
		18:  uint64(0x3c8eb51a92fdeffc),
		19:  uint64(0x3fefac922b7247f7),
		20:  uint64(0x3c3ebe3d702f9cd1),
		21:  uint64(0x3fefa3ec32d3d1a2),
		22:  uint64(0xbc6a033489906e0b),
		23:  uint64(0x3fef9b66affed31b),
		24:  uint64(0xbc9556522a2fbd0e),
		25:  uint64(0x3fef9301d0125b51),
		26:  uint64(0xbc5080ef8c4eea55),
		27:  uint64(0x3fef8abdc06c31cc),
		28:  uint64(0xbc91c923b9d5f416),
		29:  uint64(0x3fef829aaea92de0),
		30:  uint64(0x3c80d3e3e95c55af),
		31:  uint64(0x3fef7a98c8a58e51),
		32:  uint64(0xbc801b15eaa59348),
		33:  uint64(0x3fef72b83c7d517b),
		34:  uint64(0xbc8f1ff055de323d),
		35:  uint64(0x3fef6af9388c8dea),
		36:  uint64(0x3c8b898c3f1353bf),
		37:  uint64(0x3fef635beb6fcb75),
		38:  uint64(0xbc96d99c7611eb26),
		39:  uint64(0x3fef5be084045cd4),
		40:  uint64(0x3c9aecf73e3a2f60),
		41:  uint64(0x3fef54873168b9aa),
		42:  uint64(0xbc8fe782cb86389d),
		43:  uint64(0x3fef4d5022fcd91d),
		44:  uint64(0x3c8a6f4144a6c38d),
		45:  uint64(0x3fef463b88628cd6),
		46:  uint64(0x3c807a05b0e4047d),
		47:  uint64(0x3fef3f49917ddc96),
		48:  uint64(0x3c968efde3a8a894),
		49:  uint64(0x3fef387a6e756238),
		50:  uint64(0x3c875e18f274487d),
		51:  uint64(0x3fef31ce4fb2a63f),
		52:  uint64(0x3c80472b981fe7f2),
		53:  uint64(0x3fef2b4565e27cdd),
		54:  uint64(0xbc96b87b3f71085e),
		55:  uint64(0x3fef24dfe1f56381),
		56:  uint64(0x3c82f7e16d09ab31),
		57:  uint64(0x3fef1e9df51fdee1),
		58:  uint64(0xbc3d219b1a6fbffa),
		59:  uint64(0x3fef187fd0dad990),
		60:  uint64(0x3c8b3782720c0ab4),
		61:  uint64(0x3fef1285a6e4030b),
		62:  uint64(0x3c6e149289cecb8f),
		63:  uint64(0x3fef0cafa93e2f56),
		64:  uint64(0x3c834d754db0abb6),
		65:  uint64(0x3fef06fe0a31b715),
		66:  uint64(0x3c864201e2ac744c),
		67:  uint64(0x3fef0170fc4cd831),
		68:  uint64(0x3c8fdd395dd3f84a),
		69:  uint64(0x3feefc08b26416ff),
		70:  uint64(0xbc86a3803b8e5b04),
		71:  uint64(0x3feef6c55f929ff1),
		72:  uint64(0xbc924aedcc4b5068),
		73:  uint64(0x3feef1a7373aa9cb),
		74:  uint64(0xbc9907f81b512d8e),
		75:  uint64(0x3feeecae6d05d866),
		76:  uint64(0xbc71d1e83e9436d2),
		77:  uint64(0x3feee7db34e59ff7),
		78:  uint64(0xbc991919b3ce1b15),
		79:  uint64(0x3feee32dc313a8e5),
		80:  uint64(0x3c859f48a72a4c6d),
		81:  uint64(0x3feedea64c123422),
		82:  uint64(0xbc9312607a28698a),
		83:  uint64(0x3feeda4504ac801c),
		84:  uint64(0xbc58a78f4817895b),
		85:  uint64(0x3feed60a21f72e2a),
		86:  uint64(0xbc7c2c9b67499a1b),
		87:  uint64(0x3feed1f5d950a897),
		88:  uint64(0x3c4363ed60c2ac11),
		89:  uint64(0x3feece086061892d),
		90:  uint64(0x3c9666093b0664ef),
		91:  uint64(0x3feeca41ed1d0057),
		92:  uint64(0x3c6ecce1daa10379),
		93:  uint64(0x3feec6a2b5c13cd0),
		94:  uint64(0x3c93ff8e3f0f1230),
		95:  uint64(0x3feec32af0d7d3de),
		96:  uint64(0x3c7690cebb7aafb0),
		97:  uint64(0x3feebfdad5362a27),
		98:  uint64(0x3c931dbdeb54e077),
		99:  uint64(0x3feebcb299fddd0d),
		100: uint64(0xbc8f94340071a38e),
		101: uint64(0x3feeb9b2769d2ca7),
		102: uint64(0xbc87deccdc93a349),
		103: uint64(0x3feeb6daa2cf6642),
		104: uint64(0xbc78dec6bd0f385f),
		105: uint64(0x3feeb42b569d4f82),
		106: uint64(0xbc861246ec7b5cf6),
		107: uint64(0x3feeb1a4ca5d920f),
		108: uint64(0x3c93350518fdd78e),
		109: uint64(0x3feeaf4736b527da),
		110: uint64(0x3c7b98b72f8a9b05),
		111: uint64(0x3feead12d497c7fd),
		112: uint64(0x3c9063e1e21c5409),
		113: uint64(0x3feeab07dd485429),
		114: uint64(0x3c34c7855019c6ea),
		115: uint64(0x3feea9268a5946b7),
		116: uint64(0x3c9432e62b64c035),
		117: uint64(0x3feea76f15ad2148),
		118: uint64(0xbc8ce44a6199769f),
		119: uint64(0x3feea5e1b976dc09),
		120: uint64(0xbc8c33c53bef4da8),
		121: uint64(0x3feea47eb03a5585),
		122: uint64(0xbc845378892be9ae),
		123: uint64(0x3feea34634ccc320),
		124: uint64(0xbc93cedd78565858),
		125: uint64(0x3feea23882552225),
		126: uint64(0x3c5710aa807e1964),
		127: uint64(0x3feea155d44ca973),
		128: uint64(0xbc93b3efbf5e2228),
		129: uint64(0x3feea09e667f3bcd),
		130: uint64(0xbc6a12ad8734b982),
		131: uint64(0x3feea012750bdabf),
		132: uint64(0xbc6367efb86da9ee),
		133: uint64(0x3fee9fb23c651a2f),
		134: uint64(0xbc80dc3d54e08851),
		135: uint64(0x3fee9f7df9519484),
		136: uint64(0xbc781f647e5a3ecf),
		137: uint64(0x3fee9f75e8ec5f74),
		138: uint64(0xbc86ee4ac08b7db0),
		139: uint64(0x3fee9f9a48a58174),
		140: uint64(0xbc8619321e55e68a),
		141: uint64(0x3fee9feb564267c9),
		142: uint64(0x3c909ccb5e09d4d3),
		143: uint64(0x3feea0694fde5d3f),
		144: uint64(0xbc7b32dcb94da51d),
		145: uint64(0x3feea11473eb0187),
		146: uint64(0x3c94ecfd5467c06b),
		147: uint64(0x3feea1ed0130c132),
		148: uint64(0x3c65ebe1abd66c55),
		149: uint64(0x3feea2f336cf4e62),
		150: uint64(0xbc88a1c52fb3cf42),
		151: uint64(0x3feea427543e1a12),
		152: uint64(0xbc9369b6f13b3734),
		153: uint64(0x3feea589994cce13),
		154: uint64(0xbc805e843a19ff1e),
		155: uint64(0x3feea71a4623c7ad),
		156: uint64(0xbc94d450d872576e),
		157: uint64(0x3feea8d99b4492ed),
		158: uint64(0x3c90ad675b0e8a00),
		159: uint64(0x3feeaac7d98a6699),
		160: uint64(0x3c8db72fc1f0eab4),
		161: uint64(0x3feeace5422aa0db),
		162: uint64(0xbc65b6609cc5e7ff),
		163: uint64(0x3feeaf3216b5448c),
		164: uint64(0x3c7bf68359f35f44),
		165: uint64(0x3feeb1ae99157736),
		166: uint64(0xbc93091fa71e3d83),
		167: uint64(0x3feeb45b0b91ffc6),
		168: uint64(0xbc5da9b88b6c1e29),
		169: uint64(0x3feeb737b0cdc5e5),
		170: uint64(0xbc6c23f97c90b959),
		171: uint64(0x3feeba44cbc8520f),
		172: uint64(0xbc92434322f4f9aa),
		173: uint64(0x3feebd829fde4e50),
		174: uint64(0xbc85ca6cd7668e4b),
		175: uint64(0x3feec0f170ca07ba),
		176: uint64(0x3c71affc2b91ce27),
		177: uint64(0x3feec49182a3f090),
		178: uint64(0x3c6dd235e10a73bb),
		179: uint64(0x3feec86319e32323),
		180: uint64(0xbc87c50422622263),
		181: uint64(0x3feecc667b5de565),
		182: uint64(0x3c8b1c86e3e231d5),
		183: uint64(0x3feed09bec4a2d33),
		184: uint64(0xbc91bbd1d3bcbb15),
		185: uint64(0x3feed503b23e255d),
		186: uint64(0x3c90cc319cee31d2),
		187: uint64(0x3feed99e1330b358),
		188: uint64(0x3c8469846e735ab3),
		189: uint64(0x3feede6b5579fdbf),
		190: uint64(0xbc82dfcd978e9db4),
		191: uint64(0x3feee36bbfd3f37a),
		192: uint64(0x3c8c1a7792cb3387),
		193: uint64(0x3feee89f995ad3ad),
		194: uint64(0xbc907b8f4ad1d9fa),
		195: uint64(0x3feeee07298db666),
		196: uint64(0xbc55c3d956dcaeba),
		197: uint64(0x3feef3a2b84f15fb),
		198: uint64(0xbc90a40e3da6f640),
		199: uint64(0x3feef9728de5593a),
		200: uint64(0xbc68d6f438ad9334),
		201: uint64(0x3feeff76f2fb5e47),
		202: uint64(0xbc91eee26b588a35),
		203: uint64(0x3fef05b030a1064a),
		204: uint64(0x3c74ffd70a5fddcd),
		205: uint64(0x3fef0c1e904bc1d2),
		206: uint64(0xbc91bdfbfa9298ac),
		207: uint64(0x3fef12c25bd71e09),
		208: uint64(0x3c736eae30af0cb3),
		209: uint64(0x3fef199bdd85529c),
		210: uint64(0x3c8ee3325c9ffd94),
		211: uint64(0x3fef20ab5fffd07a),
		212: uint64(0x3c84e08fd10959ac),
		213: uint64(0x3fef27f12e57d14b),
		214: uint64(0x3c63cdaf384e1a67),
		215: uint64(0x3fef2f6d9406e7b5),
		216: uint64(0x3c676b2c6c921968),
		217: uint64(0x3fef3720dcef9069),
		218: uint64(0xbc808a1883ccb5d2),
		219: uint64(0x3fef3f0b555dc3fa),
		220: uint64(0xbc8fad5d3ffffa6f),
		221: uint64(0x3fef472d4a07897c),
		222: uint64(0xbc900dae3875a949),
		223: uint64(0x3fef4f87080d89f2),
		224: uint64(0x3c74a385a63d07a7),
		225: uint64(0x3fef5818dcfba487),
		226: uint64(0xbc82919e2040220f),
		227: uint64(0x3fef60e316c98398),
		228: uint64(0x3c8e5a50d5c192ac),
		229: uint64(0x3fef69e603db3285),
		230: uint64(0x3c843a59ac016b4b),
		231: uint64(0x3fef7321f301b460),
		232: uint64(0xbc82d52107b43e1f),
		233: uint64(0x3fef7c97337b9b5f),
		234: uint64(0xbc892ab93b470dc9),
		235: uint64(0x3fef864614f5a129),
		236: uint64(0x3c74b604603a88d3),
		237: uint64(0x3fef902ee78b3ff6),
		238: uint64(0x3c83c5ec519d7271),
		239: uint64(0x3fef9a51fbc74c83),
		240: uint64(0xbc8ff7128fd391f0),
		241: uint64(0x3fefa4afa2a490da),
		242: uint64(0xbc8dae98e223747d),
		243: uint64(0x3fefaf482d8e67f1),
		244: uint64(0x3c8ec3bc41aa2008),
		245: uint64(0x3fefba1bee615a27),
		246: uint64(0x3c842b94c3a9eb32),
		247: uint64(0x3fefc52b376bba97),
		248: uint64(0x3c8a64a931d185ee),
		249: uint64(0x3fefd0765b6e4540),
		250: uint64(0xbc8e37bae43be3ed),
		251: uint64(0x3fefdbfdad9cbe14),
		252: uint64(0x3c77893b4d91cd9d),
		253: uint64(0x3fefe7c1819e90d8),
		254: uint64(0x3c5305c14160cc89),
		255: uint64(0x3feff3c22b8f71f1),
	},
}

var X__fsmu8 = [51]Tuint32_t{
	0:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0x2),
	1:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0x3),
	2:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0x4),
	3:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0x5),
	4:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0x6),
	5:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0x7),
	6:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0x8),
	7:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0x9),
	8:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0xa),
	9:  (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0xb),
	10: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0xc),
	11: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0xd),
	12: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0xe),
	13: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | Uint32FromInt32(0xf),
	14: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x0)+Int32FromInt32(16)),
	15: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x1)+Int32FromInt32(16)),
	16: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x2)+Int32FromInt32(16)),
	17: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x3)+Int32FromInt32(16)),
	18: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x4)+Int32FromInt32(16)),
	19: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x5)+Int32FromInt32(16)),
	20: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x6)+Int32FromInt32(16)),
	21: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x7)+Int32FromInt32(16)),
	22: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x8)+Int32FromInt32(16)),
	23: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0x9)+Int32FromInt32(16)),
	24: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0xa)+Int32FromInt32(16)),
	25: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0xb)+Int32FromInt32(16)),
	26: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0xc)+Int32FromInt32(16)),
	27: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0xd)+Int32FromInt32(16)),
	28: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0xe)+Int32FromInt32(16)),
	29: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | uint32(Int32FromInt32(0xf)+Int32FromInt32(16)),
	30: (Uint32FromUint32(0)-Uint32FromInt32(0xa0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x0),
	31: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x1),
	32: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x2),
	33: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x3),
	34: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x4),
	35: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x5),
	36: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x6),
	37: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x7),
	38: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x8),
	39: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0x9),
	40: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0xa),
	41: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0xb),
	42: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0xc),
	43: (Uint32FromUint32(0x40)-Uint32FromInt32(0xa0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0xd),
	44: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0xe),
	45: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | Uint32FromInt32(0xf),
	46: (Uint32FromUint32(0)-Uint32FromInt32(0x90))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(12) | Uint32FromInt32(0x0),
	47: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(12) | Uint32FromInt32(0x1),
	48: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(12) | Uint32FromInt32(0x2),
	49: (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(12) | Uint32FromInt32(0x3),
	50: (Uint32FromUint32(0x40)-Uint32FromInt32(0x90))<<Int32FromInt32(23) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(6) | (Uint32FromUint32(0x40)-Uint32FromInt32(0xc0))<<Int32FromInt32(23)>>Int32FromInt32(12) | Uint32FromInt32(0x4),
}

var X__gettext_lockptr = uintptr(unsafe.Pointer(&_lock1))

var X__hwcap Tsize_t

var X__libc t__libc

var X__libc_version = [6]uint8{'1', '.', '2', '.', '5'}

var X__locale_lock [1]int32

var X__locale_lockptr = uintptr(unsafe.Pointer(&X__locale_lock))

var X__log2_data = Tlog2_data{
	Finvln2hi: float64(1.4426950407214463),
	Finvln2lo: float64(1.6751713164886512e-10),
	Fpoly: [6]float64{
		0: -Float64FromFloat64(0.7213475204444882),
		1: float64(0.4808983469629985),
		2: -Float64FromFloat64(0.36067375954075914),
		3: float64(0.2885390073180969),
		4: -Float64FromFloat64(0.2404693555628422),
		5: float64(0.2061202382173603),
	},
	Fpoly1: [10]float64{
		0: -Float64FromFloat64(0.7213475204444817),
		1: float64(0.48089834696298744),
		2: -Float64FromFloat64(0.360673760222145),
		3: float64(0.2885390081805197),
		4: -Float64FromFloat64(0.24044917405728863),
		5: float64(0.2060992861022954),
		6: -Float64FromFloat64(0.18033596705327856),
		7: float64(0.1603032746063156),
		8: -Float64FromFloat64(0.14483316576701266),
		9: float64(0.13046826811283835),
	},
	Ftab: [64]struct {
		Finvc float64
		Flogc float64
	}{
		0: {
			Finvc: float64(1.4463276106642393),
			Flogc: -Float64FromFloat64(0.5323943771486483),
		},
		1: {
			Finvc: float64(1.4301675812282968),
			Flogc: -Float64FromFloat64(0.516184206053822),
		},
		2: {
			Finvc: float64(1.4143648676229383),
			Flogc: -Float64FromFloat64(0.5001543441974263),
		},
		3: {
			Finvc: float64(1.3989068970611538),
			Flogc: -Float64FromFloat64(0.4842999484799293),
		},
		4: {
			Finvc: float64(1.3837838957784339),
			Flogc: -Float64FromFloat64(0.46861865624623533),
		},
		5: {
			Finvc: float64(1.368983882697786),
			Flogc: -Float64FromFloat64(0.4531054615783887),
		},
		6: {
			Finvc: float64(1.3544972916324536),
			Flogc: -Float64FromFloat64(0.43775750882059583),
		},
		7: {
			Finvc: float64(1.3403139676437443),
			Flogc: -Float64FromFloat64(0.4225709906127122),
		},
		8: {
			Finvc: float64(1.3264249304188642),
			Flogc: -Float64FromFloat64(0.40754302793970965),
		},
		9: {
			Finvc: float64(1.3128203652112156),
			Flogc: -Float64FromFloat64(0.3926695240384106),
		},
		10: {
			Finvc: float64(1.299492412370217),
			Flogc: -Float64FromFloat64(0.3779482100565019),
		},
		11: {
			Finvc: float64(1.28643198385998),
			Flogc: -Float64FromFloat64(0.36337518101890964),
		},
		12: {
			Finvc: float64(1.2736319291846832),
			Flogc: -Float64FromFloat64(0.3489484089425332),
		},
		13: {
			Finvc: float64(1.2610838968062879),
			Flogc: -Float64FromFloat64(0.33466425780738973),
		},
		14: {
			Finvc: float64(1.248780314313572),
			Flogc: -Float64FromFloat64(0.3205197000629596),
		},
		15: {
			Finvc: float64(1.2367150450059063),
			Flogc: -Float64FromFloat64(0.3065131231801388),
		},
		16: {
			Finvc: float64(1.2248804968401878),
			Flogc: -Float64FromFloat64(0.2926410022678283),
		},
		17: {
			Finvc: float64(1.2132702353497795),
			Flogc: -Float64FromFloat64(0.2789009220805383),
		},
		18: {
			Finvc: float64(1.2018780785715362),
			Flogc: -Float64FromFloat64(0.2652905529862437),
		},
		19: {
			Finvc: float64(1.190697765061355),
			Flogc: -Float64FromFloat64(0.2518072602367738),
		},
		20: {
			Finvc: float64(1.1797235410550593),
			Flogc: -Float64FromFloat64(0.23844881494437686),
		},
		21: {
			Finvc: float64(1.1689498986205256),
			Flogc: -Float64FromFloat64(0.22521309705462045),
		},
		22: {
			Finvc: float64(1.158371137408455),
			Flogc: -Float64FromFloat64(0.21209756102439314),
		},
		23: {
			Finvc: float64(1.1479820146386086),
			Flogc: -Float64FromFloat64(0.1991000395789797),
		},
		24: {
			Finvc: float64(1.1377775576851088),
			Flogc: -Float64FromFloat64(0.18621852970682085),
		},
		25: {
			Finvc: float64(1.127753150630225),
			Flogc: -Float64FromFloat64(0.17345131655361),
		},
		26: {
			Finvc: float64(1.1179037012282074),
			Flogc: -Float64FromFloat64(0.16079591649577196),
		},
		27: {
			Finvc: float64(1.1082251967632821),
			Flogc: -Float64FromFloat64(0.14825107384353942),
		},
		28: {
			Finvc: float64(1.098712461056607),
			Flogc: -Float64FromFloat64(0.13581387465410444),
		},
		29: {
			Finvc: float64(1.0893619091634283),
			Flogc: -Float64FromFloat64(0.12348332762257996),
		},
		30: {
			Finvc: float64(1.0801689912316736),
			Flogc: -Float64FromFloat64(0.11125703807351783),
		},
		31: {
			Finvc: float64(1.071129489697672),
			Flogc: -Float64FromFloat64(0.09913289918449664),
		},
		32: {
			Finvc: float64(1.0622406576750423),
			Flogc: -Float64FromFloat64(0.08711065531497297),
		},
		33: {
			Finvc: float64(1.0534977607927976),
			Flogc: -Float64FromFloat64(0.07518724771330199),
		},
		34: {
			Finvc: float64(1.044897877982342),
			Flogc: -Float64FromFloat64(0.06336194888240243),
		},
		35: {
			Finvc: float64(1.0364370289499079),
			Flogc: -Float64FromFloat64(0.0516324649456692),
		},
		36: {
			Finvc: float64(1.0281122132034575),
			Flogc: -Float64FromFloat64(0.039997735929773626),
		},
		37: {
			Finvc: float64(1.0199202450036955),
			Flogc: -Float64FromFloat64(0.028456341769015125),
		},
		38: {
			Finvc: float64(1.0118577522306755),
			Flogc: -Float64FromFloat64(0.017006489068080555),
		},
		39: {
			Finvc: float64(1.003921649236766),
			Flogc: -Float64FromFloat64(0.005646678981520381),
		},
		40: {
			Finvc: float64(0.9922480467550775),
			Flogc: float64(0.011227277611396858),
		},
		41: {
			Finvc: float64(0.9770993366178549),
			Flogc: float64(0.033422853921138085),
		},
		42: {
			Finvc: float64(0.9624059787315814),
			Flogc: float64(0.05528248992573026),
		},
		43: {
			Finvc: float64(0.9481480598286369),
			Flogc: float64(0.07681573143713649),
		},
		44: {
			Finvc: float64(0.9343065931261065),
			Flogc: float64(0.09803204623631245),
		},
		45: {
			Finvc: float64(0.9208633936884979),
			Flogc: float64(0.11894094059630334),
		},
		46: {
			Finvc: float64(0.9078013641840602),
			Flogc: float64(0.13955143862290242),
		},
		47: {
			Finvc: float64(0.8951048181512927),
			Flogc: float64(0.15987146080919956),
		},
		48: {
			Finvc: float64(0.882758574260473),
			Flogc: float64(0.17990916589428707),
		},
		49: {
			Finvc: float64(0.8707481902241709),
			Flogc: float64(0.19967252559081317),
		},
		50: {
			Finvc: float64(0.8590602881746972),
			Flogc: float64(0.2191687127685782),
		},
		51: {
			Finvc: float64(0.8476822044336688),
			Flogc: float64(0.23840459427242422),
		},
		52: {
			Finvc: float64(0.8366013284053287),
			Flogc: float64(0.25738780610663525),
		},
		53: {
			Finvc: float64(0.8258064913621258),
			Flogc: float64(0.27612433583180973),
		},
		54: {
			Finvc: float64(0.8152865101579193),
			Flogc: float64(0.2946209507022104),
		},
		55: {
			Finvc: float64(0.8050314363208223),
			Flogc: float64(0.31288297359969874),
		},
		56: {
			Finvc: float64(0.7950310492640542),
			Flogc: float64(0.33091689015759584),
		},
		57: {
			Finvc: float64(0.7852760432487271),
			Flogc: float64(0.3487282100279572),
		},
		58: {
			Finvc: float64(0.7757575660314712),
			Flogc: float64(0.36632223233368677),
		},
		59: {
			Finvc: float64(0.7664670566588946),
			Flogc: float64(0.383704309808536),
		},
		60: {
			Finvc: float64(0.7573965608078645),
			Flogc: float64(0.4008792246509074),
		},
		61: {
			Finvc: float64(0.7485380168514022),
			Flogc: float64(0.41785250494945103),
		},
		62: {
			Finvc: float64(0.7398844213755009),
			Flogc: float64(0.4346281724315304),
		},
		63: {
			Finvc: float64(0.7314286113178112),
			Flogc: float64(0.45121103315341315),
		},
	},
}

var X__log2f_data = Tlog2f_data{
	Ftab: [16]struct {
		Finvc float64
		Flogc float64
	}{
		0: {
			Finvc: float64(1.398907162146528),
			Flogc: -Float64FromFloat64(0.48430022186289673),
		},
		1: {
			Finvc: float64(1.3403141896637998),
			Flogc: -Float64FromFloat64(0.42257122959194704),
		},
		2: {
			Finvc: float64(1.286432210124115),
			Flogc: -Float64FromFloat64(0.3633754347673556),
		},
		3: {
			Finvc: float64(1.2367150214269895),
			Flogc: -Float64FromFloat64(0.30651309567405577),
		},
		4: {
			Finvc: float64(1.1906977166711752),
			Flogc: -Float64FromFloat64(0.25180720160537634),
		},
		5: {
			Finvc: float64(1.1479821020556429),
			Flogc: -Float64FromFloat64(0.19910014943794563),
		},
		6: {
			Finvc: float64(1.1082251448272158),
			Flogc: -Float64FromFloat64(0.14825100623281615),
		},
		7: {
			Finvc: float64(1.0711297413057381),
			Flogc: -Float64FromFloat64(0.09913323807318392),
		},
		8: {
			Finvc: float64(1.036437278977283),
			Flogc: -Float64FromFloat64(0.051632812977629436),
		},
		9: {
			Finvc: float64(1),
		},
		10: {
			Finvc: float64(0.9492859795739057),
			Flogc: float64(0.07508531937943004),
		},
		11: {
			Finvc: float64(0.8951049428609004),
			Flogc: float64(0.15987125980713107),
		},
		12: {
			Finvc: float64(0.8476821620351103),
			Flogc: float64(0.2384046664317681),
		},
		13: {
			Finvc: float64(0.8050314851692001),
			Flogc: float64(0.31288288605863257),
		},
		14: {
			Finvc: float64(0.7664671008843108),
			Flogc: float64(0.38370422656453185),
		},
		15: {
			Finvc: float64(0.731428603316328),
			Flogc: float64(0.451211048935815),
		},
	},
	Fpoly: [4]float64{
		0: -Float64FromFloat64(0.36051725506874704),
		1: float64(0.4811247078767291),
		2: -Float64FromFloat64(0.7213476299867769),
		3: float64(1.4426950186867042),
	},
}

var X__log_data = Tlog_data{
	Fln2hi: float64(0.6931471805598903),
	Fln2lo: float64(5.497923018708371e-14),
	Fpoly: [5]float64{
		0: -Float64FromFloat64(0.5000000000000001),
		1: float64(0.33333333331825593),
		2: -Float64FromFloat64(0.2499999999622955),
		3: float64(0.20000304511814496),
		4: -Float64FromFloat64(0.16667054827627667),
	},
	Fpoly1: [11]float64{
		0:  -Float64FromFloat64(0.5),
		1:  float64(0.3333333333333352),
		2:  -Float64FromFloat64(0.24999999999998432),
		3:  float64(0.19999999999320328),
		4:  -Float64FromFloat64(0.16666666669929706),
		5:  float64(0.14285715076560868),
		6:  -Float64FromFloat64(0.12499997863982555),
		7:  float64(0.11110712032936046),
		8:  -Float64FromFloat64(0.10000486757818193),
		9:  float64(0.09181994006195467),
		10: -Float64FromFloat64(0.08328363062289341),
	},
	Ftab: [128]struct {
		Finvc float64
		Flogc float64
	}{
		0: {
			Finvc: float64(1.4504249240398293),
			Flogc: -Float64FromFloat64(0.3718565645633589),
		},
		1: {
			Finvc: float64(1.442253508327276),
			Flogc: -Float64FromFloat64(0.36620682668944937),
		},
		2: {
			Finvc: float64(1.4341736174350004),
			Flogc: -Float64FromFloat64(0.3605888069791945),
		},
		3: {
			Finvc: float64(1.426183816329995),
			Flogc: -Float64FromFloat64(0.3550022171419869),
		},
		4: {
			Finvc: float64(1.4182825527052965),
			Flogc: -Float64FromFloat64(0.34944666968829097),
		},
		5: {
			Finvc: float64(1.4104682921759335),
			Flogc: -Float64FromFloat64(0.3439217713603284),
		},
		6: {
			Finvc: float64(1.4027396147468003),
			Flogc: -Float64FromFloat64(0.3384271921261188),
		},
		7: {
			Finvc: float64(1.3950954438932313),
			Flogc: -Float64FromFloat64(0.332962831494342),
		},
		8: {
			Finvc: float64(1.3875338232485754),
			Flogc: -Float64FromFloat64(0.32752794345742586),
		},
		9: {
			Finvc: float64(1.3800539211058593),
			Flogc: -Float64FromFloat64(0.32212257167088865),
		},
		10: {
			Finvc: float64(1.3726542695419708),
			Flogc: -Float64FromFloat64(0.3167462884799761),
		},
		11: {
			Finvc: float64(1.3653332798446802),
			Flogc: -Float64FromFloat64(0.3113985598928366),
		},
		12: {
			Finvc: float64(1.358090204587874),
			Flogc: -Float64FromFloat64(0.3060794515165526),
		},
		13: {
			Finvc: float64(1.3509234892132138),
			Flogc: -Float64FromFloat64(0.300788424667644),
		},
		14: {
			Finvc: float64(1.3438320840699889),
			Flogc: -Float64FromFloat64(0.2955252968476998),
		},
		15: {
			Finvc: float64(1.3368146974742003),
			Flogc: -Float64FromFloat64(0.29028969275850613),
		},
		16: {
			Finvc: float64(1.329870114677736),
			Flogc: -Float64FromFloat64(0.2850812793277555),
		},
		17: {
			Finvc: float64(1.322997339161106),
			Flogc: -Float64FromFloat64(0.27989987391470095),
		},
		18: {
			Finvc: float64(1.316195352741367),
			Flogc: -Float64FromFloat64(0.27474526621870154),
		},
		19: {
			Finvc: float64(1.3094628125672239),
			Flogc: -Float64FromFloat64(0.2696169863701243),
		},
		20: {
			Finvc: float64(1.3027990455471041),
			Flogc: -Float64FromFloat64(0.26451506180308115),
		},
		21: {
			Finvc: float64(1.2962024229438942),
			Flogc: -Float64FromFloat64(0.2594387762767383),
		},
		22: {
			Finvc: float64(1.2896726275815547),
			Flogc: -Float64FromFloat64(0.2543884090981692),
		},
		23: {
			Finvc: float64(1.2832080305745537),
			Flogc: -Float64FromFloat64(0.24936321635129843),
		},
		24: {
			Finvc: float64(1.276807885983376),
			Flogc: -Float64FromFloat64(0.24436312405975968),
		},
		25: {
			Finvc: float64(1.2704714060687552),
			Flogc: -Float64FromFloat64(0.23938801747897287),
		},
		26: {
			Finvc: float64(1.2641976054949482),
			Flogc: -Float64FromFloat64(0.23443761696705678),
		},
		27: {
			Finvc: float64(1.257985357514882),
			Flogc: -Float64FromFloat64(0.22951151871518505),
		},
		28: {
			Finvc: float64(1.2518337750655457),
			Flogc: -Float64FromFloat64(0.2246094963439873),
		},
		29: {
			Finvc: float64(1.2457421919097305),
			Flogc: -Float64FromFloat64(0.21973149037705753),
		},
		30: {
			Finvc: float64(1.2397094966625508),
			Flogc: -Float64FromFloat64(0.2148770752847895),
		},
		31: {
			Finvc: float64(1.2337348463589233),
			Flogc: -Float64FromFloat64(0.210046029103637),
		},
		32: {
			Finvc: float64(1.2278176973028803),
			Flogc: -Float64FromFloat64(0.20523836373934046),
		},
		33: {
			Finvc: float64(1.2219570190618474),
			Flogc: -Float64FromFloat64(0.20045368751368642),
		},
		34: {
			Finvc: float64(1.2161519732977757),
			Flogc: -Float64FromFloat64(0.1956917537758045),
		},
		35: {
			Finvc: float64(1.2104018095009725),
			Flogc: -Float64FromFloat64(0.19095237845203883),
		},
		36: {
			Finvc: float64(1.204705805718973),
			Flogc: -Float64FromFloat64(0.18623539250290833),
		},
		37: {
			Finvc: float64(1.1990631185441964),
			Flogc: -Float64FromFloat64(0.18154051731551135),
		},
		38: {
			Finvc: float64(1.1934733004462308),
			Flogc: -Float64FromFloat64(0.1768677957431919),
		},
		39: {
			Finvc: float64(1.1879350812847385),
			Flogc: -Float64FromFloat64(0.17221657406412305),
		},
		40: {
			Finvc: float64(1.1824481322833125),
			Flogc: -Float64FromFloat64(0.16758697765942543),
		},
		41: {
			Finvc: float64(1.1770114976921955),
			Flogc: -Float64FromFloat64(0.16297859687290384),
		},
		42: {
			Finvc: float64(1.1716248121809465),
			Flogc: -Float64FromFloat64(0.15839151377804228),
		},
		43: {
			Finvc: float64(1.1662869231674715),
			Flogc: -Float64FromFloat64(0.15382513241456763),
		},
		44: {
			Finvc: float64(1.1609977486762766),
			Flogc: -Float64FromFloat64(0.14927976358922024),
		},
		45: {
			Finvc: float64(1.1557563220795803),
			Flogc: -Float64FromFloat64(0.14475495398119165),
		},
		46: {
			Finvc: float64(1.1505619105480347),
			Flogc: -Float64FromFloat64(0.14025044090817573),
		},
		47: {
			Finvc: float64(1.1454138888505974),
			Flogc: -Float64FromFloat64(0.1357660466685502),
		},
		48: {
			Finvc: float64(1.140311877374656),
			Flogc: -Float64FromFloat64(0.1313018016355727),
		},
		49: {
			Finvc: float64(1.1352550225747513),
			Flogc: -Float64FromFloat64(0.12685731518763532),
		},
		50: {
			Finvc: float64(1.1302429094831266),
			Flogc: -Float64FromFloat64(0.1224325737671279),
		},
		51: {
			Finvc: float64(1.1252747693068048),
			Flogc: -Float64FromFloat64(0.11802724521862729),
		},
		52: {
			Finvc: float64(1.1203501571039876),
			Flogc: -Float64FromFloat64(0.11364127671663482),
		},
		53: {
			Finvc: float64(1.1154683327680124),
			Flogc: -Float64FromFloat64(0.10927434611278386),
		},
		54: {
			Finvc: float64(1.1106291463292157),
			Flogc: -Float64FromFloat64(0.10492665324943573),
		},
		55: {
			Finvc: float64(1.1058315813301596),
			Flogc: -Float64FromFloat64(0.10059761422644442),
		},
		56: {
			Finvc: float64(1.1010752177696026),
			Flogc: -Float64FromFloat64(0.09628717309055901),
		},
		57: {
			Finvc: float64(1.0963597137952512),
			Flogc: -Float64FromFloat64(0.09199534069557558),
		},
		58: {
			Finvc: float64(1.0916844827550398),
			Flogc: -Float64FromFloat64(0.08772190036688698),
		},
		59: {
			Finvc: float64(1.0870487291277784),
			Flogc: -Float64FromFloat64(0.08346643613867855),
		},
		60: {
			Finvc: float64(1.082452357388312),
			Flogc: -Float64FromFloat64(0.07922916827544668),
		},
		61: {
			Finvc: float64(1.0778948225025884),
			Flogc: -Float64FromFloat64(0.0750099004750382),
		},
		62: {
			Finvc: float64(1.0733751731601076),
			Flogc: -Float64FromFloat64(0.07080805133352897),
		},
		63: {
			Finvc: float64(1.068893585073351),
			Flogc: -Float64FromFloat64(0.06662408085151128),
		},
		64: {
			Finvc: float64(1.0644491706655506),
			Flogc: -Float64FromFloat64(0.06245745471915143),
		},
		65: {
			Finvc: float64(1.0600414846328305),
			Flogc: -Float64FromFloat64(0.0583080438042316),
		},
		66: {
			Finvc: float64(1.0556701316181605),
			Flogc: -Float64FromFloat64(0.05417576112313327),
		},
		67: {
			Finvc: float64(1.051334750556926),
			Flogc: -Float64FromFloat64(0.050060547896805474),
		},
		68: {
			Finvc: float64(1.0470347288442157),
			Flogc: -Float64FromFloat64(0.045962101199052086),
		},
		69: {
			Finvc: float64(1.0427699229652954),
			Flogc: -Float64FromFloat64(0.04188056008865715),
		},
		70: {
			Finvc: float64(1.0385395013738175),
			Flogc: -Float64FromFloat64(0.03781540056183985),
		},
		71: {
			Finvc: float64(1.034343418940345),
			Flogc: -Float64FromFloat64(0.03376684757915882),
		},
		72: {
			Finvc: float64(1.0301811073173315),
			Flogc: -Float64FromFloat64(0.029734619131772888),
		},
		73: {
			Finvc: float64(1.026052043621297),
			Flogc: -Float64FromFloat64(0.025718470239212365),
		},
		74: {
			Finvc: float64(1.0219561082336197),
			Flogc: -Float64FromFloat64(0.021718543925430822),
		},
		75: {
			Finvc: float64(1.0178926505784922),
			Flogc: -Float64FromFloat64(0.01773446126981071),
		},
		76: {
			Finvc: float64(1.0138614436244586),
			Flogc: -Float64FromFloat64(0.013766252464051831),
		},
		77: {
			Finvc: float64(1.0098620186501341),
			Flogc: -Float64FromFloat64(0.009813706322574944),
		},
		78: {
			Finvc: float64(1.0058938559734134),
			Flogc: -Float64FromFloat64(0.005876555150052809),
		},
		79: {
			Finvc: float64(1.00195696235014),
			Flogc: -Float64FromFloat64(0.0019550499938532084),
		},
		80: {
			Finvc: float64(0.9961089923088509),
			Flogc: float64(0.0038985973556009412),
		},
		81: {
			Finvc: float64(0.9884170338185201),
			Flogc: float64(0.011650571286395461),
		},
		82: {
			Finvc: float64(0.9808429191005297),
			Flogc: float64(0.019342955478919066),
		},
		83: {
			Finvc: float64(0.9733840169987446),
			Flogc: float64(0.0269766014846482),
		},
		84: {
			Finvc: float64(0.9660377568876556),
			Flogc: float64(0.034552359728422744),
		},
		85: {
			Finvc: float64(0.9588014945307369),
			Flogc: float64(0.04207121767183253),
		},
		86: {
			Finvc: float64(0.9516728569073111),
			Flogc: float64(0.049533940950141186),
		},
		87: {
			Finvc: float64(0.9446494635965822),
			Flogc: float64(0.056941358295944156),
		},
		88: {
			Finvc: float64(0.9377288993026223),
			Flogc: float64(0.06429439168346107),
		},
		89: {
			Finvc: float64(0.9309091073790681),
			Flogc: float64(0.0715936354946507),
		},
		90: {
			Finvc: float64(0.924187681612722),
			Flogc: float64(0.07884010933776153),
		},
		91: {
			Finvc: float64(0.9175626765599192),
			Flogc: float64(0.08603438905970506),
		},
		92: {
			Finvc: float64(0.9110320403624034),
			Flogc: float64(0.09317721180013905),
		},
		93: {
			Finvc: float64(0.9045935839762024),
			Flogc: float64(0.10026951462748457),
		},
		94: {
			Finvc: float64(0.8982456375922825),
			Flogc: float64(0.10731170956330516),
		},
		95: {
			Finvc: float64(0.8919860966782501),
			Flogc: float64(0.11430473320717738),
		},
		96: {
			Finvc: float64(0.8858131121185129),
			Flogc: float64(0.12124928503033061),
		},
		97: {
			Finvc: float64(0.879725075760676),
			Flogc: float64(0.12814583422959913),
		},
		98: {
			Finvc: float64(0.8737201372634685),
			Flogc: float64(0.1349951636851756),
		},
		99: {
			Finvc: float64(0.8677966405782273),
			Flogc: float64(0.1417978768189414),
		},
		100: {
			Finvc: float64(0.8619528050060739),
			Flogc: float64(0.14855476039031146),
		},
		101: {
			Finvc: float64(0.8561872354420692),
			Flogc: float64(0.1552661937658968),
		},
		102: {
			Finvc: float64(0.8504983927816893),
			Flogc: float64(0.16193275688146969),
		},
		103: {
			Finvc: float64(0.8448844572790304),
			Flogc: float64(0.16855539792220497),
		},
		104: {
			Finvc: float64(0.8393442741575965),
			Flogc: float64(0.1751343179947753),
		},
		105: {
			Finvc: float64(0.8338762249349438),
			Flogc: float64(0.1816702989864325),
		},
		106: {
			Finvc: float64(0.8284789320557778),
			Flogc: float64(0.18816387146023317),
		},
		107: {
			Finvc: float64(0.8231510800065832),
			Flogc: float64(0.1946155228479256),
		},
		108: {
			Finvc: float64(0.8178913903778707),
			Flogc: float64(0.20102572579389744),
		},
		109: {
			Finvc: float64(0.8126984007245374),
			Flogc: float64(0.2073952090795501),
		},
		110: {
			Finvc: float64(0.8075710029460227),
			Flogc: float64(0.21372429840596396),
		},
		111: {
			Finvc: float64(0.8025078881160415),
			Flogc: float64(0.2200135945981856),
		},
		112: {
			Finvc: float64(0.7975077379364331),
			Flogc: float64(0.22626374162859975),
		},
		113: {
			Finvc: float64(0.792569604966373),
			Flogc: float64(0.23247494747693054),
		},
		114: {
			Finvc: float64(0.7876923641254114),
			Flogc: float64(0.23864766620658884),
		},
		115: {
			Finvc: float64(0.7828746724940998),
			Flogc: float64(0.24478265647405806),
		},
		116: {
			Finvc: float64(0.7781155388790811),
			Flogc: float64(0.25088025827324145),
		},
		117: {
			Finvc: float64(0.7734139557869777),
			Flogc: float64(0.2569408552510595),
		},
		118: {
			Finvc: float64(0.7687687179914933),
			Flogc: float64(0.26296511155101143),
		},
		119: {
			Finvc: float64(0.7641790698041854),
			Flogc: float64(0.2689531327189343),
		},
		120: {
			Finvc: float64(0.7596438763692399),
			Flogc: float64(0.27490553924610595),
		},
		121: {
			Finvc: float64(0.7551621951078668),
			Flogc: float64(0.2808227248478943),
		},
		122: {
			Finvc: float64(0.7507331780216866),
			Flogc: float64(0.286704979267256),
		},
		123: {
			Finvc: float64(0.7463557196361751),
			Flogc: float64(0.29255295645509705),
		},
		124: {
			Finvc: float64(0.7420289364869653),
			Flogc: float64(0.2983670386142876),
		},
		125: {
			Finvc: float64(0.7377521537065876),
			Flogc: float64(0.30414734587282055),
		},
		126: {
			Finvc: float64(0.7335242966002608),
			Flogc: float64(0.30989455774829366),
		},
		127: {
			Finvc: float64(0.729344777457841),
			Flogc: float64(0.31560871301871884),
		},
	},
}

var X__logf_data = Tlogf_data{
	Ftab: [16]struct {
		Finvc float64
		Flogc float64
	}{
		0: {
			Finvc: float64(1.398907162146528),
			Flogc: -Float64FromFloat64(0.33569133332882284),
		},
		1: {
			Finvc: float64(1.3403141896637998),
			Flogc: -Float64FromFloat64(0.2929040563774074),
		},
		2: {
			Finvc: float64(1.286432210124115),
			Flogc: -Float64FromFloat64(0.2518726580937369),
		},
		3: {
			Finvc: float64(1.2367150214269895),
			Flogc: -Float64FromFloat64(0.21245868807117255),
		},
		4: {
			Finvc: float64(1.1906977166711752),
			Flogc: -Float64FromFloat64(0.17453945183745634),
		},
		5: {
			Finvc: float64(1.1479821020556429),
			Flogc: -Float64FromFloat64(0.1380057072319758),
		},
		6: {
			Finvc: float64(1.1082251448272158),
			Flogc: -Float64FromFloat64(0.10275976698545139),
		},
		7: {
			Finvc: float64(1.0711297413057381),
			Flogc: -Float64FromFloat64(0.06871392447020525),
		},
		8: {
			Finvc: float64(1.036437278977283),
			Flogc: -Float64FromFloat64(0.0357891387398228),
		},
		9: {
			Finvc: float64(1),
		},
		10: {
			Finvc: float64(0.9492859795739057),
			Flogc: float64(0.05204517742929496),
		},
		11: {
			Finvc: float64(0.8951049428609004),
			Flogc: float64(0.11081431298787942),
		},
		12: {
			Finvc: float64(0.8476821620351103),
			Flogc: float64(0.1652495223695143),
		},
		13: {
			Finvc: float64(0.8050314851692001),
			Flogc: float64(0.21687389031699977),
		},
		14: {
			Finvc: float64(0.7664671008843108),
			Flogc: float64(0.2659635028121397),
		},
		15: {
			Finvc: float64(0.731428603316328),
			Flogc: float64(0.3127556664073557),
		},
	},
	Fln2: float64(0.6931471805599453),
	Fpoly: [3]float64{
		0: -Float64FromFloat64(0.25089342214237154),
		1: float64(0.333456765744066),
		2: -Float64FromFloat64(0.4999997485802103),
	},
}

var X__optpos int32

var Xoptreset int32

var X__pow_log_data = Tpow_log_data{
	Fln2hi: float64(0.6931471805598903),
	Fln2lo: float64(5.497923018708371e-14),
	Fpoly: [7]float64{
		0: -Float64FromFloat64(0.5),
		1: Float64FromFloat64(0.3333333333333339) * float64(-Int32FromInt32(2)),
		2: -Float64FromFloat64(0.25000000000000033) * float64(-Int32FromInt32(2)),
		3: Float64FromFloat64(0.1999999998830994) * Float64FromInt32(4),
		4: -Float64FromFloat64(0.16666666658719348) * Float64FromInt32(4),
		5: Float64FromFloat64(0.14286370355743763) * float64(-Int32FromInt32(8)),
		6: -Float64FromFloat64(0.12500519079594427) * float64(-Int32FromInt32(8)),
	},
	Ftab: [128]struct {
		Finvc     float64
		Fpad      float64
		Flogc     float64
		Flogctail float64
	}{
		0: {
			Finvc:     float64(1.4140625),
			Flogc:     -Float64FromFloat64(0.3464667673462145),
			Flogctail: float64(5.929407345889625e-15),
		},
		1: {
			Finvc:     float64(1.40625),
			Flogc:     -Float64FromFloat64(0.34092658697056777),
			Flogctail: -Float64FromFloat64(2.544157440035963e-14),
		},
		2: {
			Finvc:     float64(1.3984375),
			Flogc:     -Float64FromFloat64(0.3353555419211034),
			Flogctail: -Float64FromFloat64(3.443525940775045e-14),
		},
		3: {
			Finvc:     float64(1.390625),
			Flogc:     -Float64FromFloat64(0.3297532863724655),
			Flogctail: -Float64FromFloat64(2.500123826022799e-15),
		},
		4: {
			Finvc:     float64(1.3828125),
			Flogc:     -Float64FromFloat64(0.32411946865420305),
			Flogctail: -Float64FromFloat64(8.929337133850617e-15),
		},
		5: {
			Finvc:     float64(1.375),
			Flogc:     -Float64FromFloat64(0.31845373111855224),
			Flogctail: float64(1.7625431312172662e-14),
		},
		6: {
			Finvc:     float64(1.3671875),
			Flogc:     -Float64FromFloat64(0.31275571000389846),
			Flogctail: float64(1.5688303180062087e-15),
		},
		7: {
			Finvc:     float64(1.359375),
			Flogc:     -Float64FromFloat64(0.3070250352949415),
			Flogctail: float64(2.9655274673691784e-14),
		},
		8: {
			Finvc:     float64(1.3515625),
			Flogc:     -Float64FromFloat64(0.3012613305781997),
			Flogctail: float64(3.7923164802093147e-14),
		},
		9: {
			Finvc:     float64(1.34375),
			Flogc:     -Float64FromFloat64(0.2954642128938758),
			Flogctail: float64(3.993416384387844e-14),
		},
		10: {
			Finvc:     float64(1.3359375),
			Flogc:     -Float64FromFloat64(0.28963329258306203),
			Flogctail: float64(1.9352855826489123e-14),
		},
		11: {
			Finvc:     float64(1.3359375),
			Flogc:     -Float64FromFloat64(0.28963329258306203),
			Flogctail: float64(1.9352855826489123e-14),
		},
		12: {
			Finvc:     float64(1.328125),
			Flogc:     -Float64FromFloat64(0.28376817313062475),
			Flogctail: -Float64FromFloat64(1.9852665484979036e-14),
		},
		13: {
			Finvc:     float64(1.3203125),
			Flogc:     -Float64FromFloat64(0.27786845100342816),
			Flogctail: -Float64FromFloat64(2.814323765595281e-14),
		},
		14: {
			Finvc:     float64(1.3125),
			Flogc:     -Float64FromFloat64(0.2719337154836694),
			Flogctail: float64(2.7643769993528702e-14),
		},
		15: {
			Finvc:     float64(1.3046875),
			Flogc:     -Float64FromFloat64(0.2659635484970977),
			Flogctail: -Float64FromFloat64(4.025092402293806e-14),
		},
		16: {
			Finvc:     float64(1.296875),
			Flogc:     -Float64FromFloat64(0.25995752443691345),
			Flogctail: -Float64FromFloat64(1.2621729398885316e-14),
		},
		17: {
			Finvc:     float64(1.2890625),
			Flogc:     -Float64FromFloat64(0.25391520998095984),
			Flogctail: -Float64FromFloat64(3.600176732637335e-15),
		},
		18: {
			Finvc:     float64(1.2890625),
			Flogc:     -Float64FromFloat64(0.25391520998095984),
			Flogctail: -Float64FromFloat64(3.600176732637335e-15),
		},
		19: {
			Finvc:     float64(1.28125),
			Flogc:     -Float64FromFloat64(0.2478361639045943),
			Flogctail: float64(1.3029797173308663e-14),
		},
		20: {
			Finvc:     float64(1.2734375),
			Flogc:     -Float64FromFloat64(0.2417199368871934),
			Flogctail: float64(4.8230289429940886e-14),
		},
		21: {
			Finvc:     float64(1.265625),
			Flogc:     -Float64FromFloat64(0.23556607131274632),
			Flogctail: -Float64FromFloat64(2.0592242769647135e-14),
		},
		22: {
			Finvc:     float64(1.2578125),
			Flogc:     -Float64FromFloat64(0.22937410106487732),
			Flogctail: float64(3.149265065191484e-14),
		},
		23: {
			Finvc:     float64(1.25),
			Flogc:     -Float64FromFloat64(0.22314355131425145),
			Flogctail: float64(4.169796584527195e-14),
		},
		24: {
			Finvc:     float64(1.25),
			Flogc:     -Float64FromFloat64(0.22314355131425145),
			Flogctail: float64(4.169796584527195e-14),
		},
		25: {
			Finvc:     float64(1.2421875),
			Flogc:     -Float64FromFloat64(0.21687393830063684),
			Flogctail: float64(2.2477465222466186e-14),
		},
		26: {
			Finvc:     float64(1.234375),
			Flogc:     -Float64FromFloat64(0.21056476910735),
			Flogctail: float64(3.6507188831790577e-16),
		},
		27: {
			Finvc:     float64(1.2265625),
			Flogc:     -Float64FromFloat64(0.2042155414286526),
			Flogctail: -Float64FromFloat64(3.827767260205414e-14),
		},
		28: {
			Finvc:     float64(1.2265625),
			Flogc:     -Float64FromFloat64(0.2042155414286526),
			Flogctail: -Float64FromFloat64(3.827767260205414e-14),
		},
		29: {
			Finvc:     float64(1.21875),
			Flogc:     -Float64FromFloat64(0.19782574332987224),
			Flogctail: -Float64FromFloat64(4.7641388950792196e-14),
		},
		30: {
			Finvc:     float64(1.2109375),
			Flogc:     -Float64FromFloat64(0.19139485299967873),
			Flogctail: float64(4.9278276214647115e-14),
		},
		31: {
			Finvc:     float64(1.203125),
			Flogc:     -Float64FromFloat64(0.18492233849406148),
			Flogctail: float64(4.9485167661250996e-14),
		},
		32: {
			Finvc:     float64(1.203125),
			Flogc:     -Float64FromFloat64(0.18492233849406148),
			Flogctail: float64(4.9485167661250996e-14),
		},
		33: {
			Finvc:     float64(1.1953125),
			Flogc:     -Float64FromFloat64(0.1784076574728033),
			Flogctail: -Float64FromFloat64(1.5003333854266542e-14),
		},
		34: {
			Finvc:     float64(1.1875),
			Flogc:     -Float64FromFloat64(0.17185025692663203),
			Flogctail: -Float64FromFloat64(2.7194441649495324e-14),
		},
		35: {
			Finvc:     float64(1.1875),
			Flogc:     -Float64FromFloat64(0.17185025692663203),
			Flogctail: -Float64FromFloat64(2.7194441649495324e-14),
		},
		36: {
			Finvc:     float64(1.1796875),
			Flogc:     -Float64FromFloat64(0.1652495728952772),
			Flogctail: -Float64FromFloat64(2.99659267292569e-14),
		},
		37: {
			Finvc:     float64(1.171875),
			Flogc:     -Float64FromFloat64(0.15860503017665906),
			Flogctail: float64(2.0472357800461955e-14),
		},
		38: {
			Finvc:     float64(1.171875),
			Flogc:     -Float64FromFloat64(0.15860503017665906),
			Flogctail: float64(2.0472357800461955e-14),
		},
		39: {
			Finvc:     float64(1.1640625),
			Flogc:     -Float64FromFloat64(0.15191604202584585),
			Flogctail: float64(3.879296723063646e-15),
		},
		40: {
			Finvc:     float64(1.15625),
			Flogc:     -Float64FromFloat64(0.1451820098444614),
			Flogctail: -Float64FromFloat64(3.6506824353335045e-14),
		},
		41: {
			Finvc:     float64(1.1484375),
			Flogc:     -Float64FromFloat64(0.13840232285906495),
			Flogctail: -Float64FromFloat64(5.4183331379008994e-14),
		},
		42: {
			Finvc:     float64(1.1484375),
			Flogc:     -Float64FromFloat64(0.13840232285906495),
			Flogctail: -Float64FromFloat64(5.4183331379008994e-14),
		},
		43: {
			Finvc:     float64(1.140625),
			Flogc:     -Float64FromFloat64(0.131576357788731),
			Flogctail: float64(1.1729485484531301e-14),
		},
		44: {
			Finvc:     float64(1.140625),
			Flogc:     -Float64FromFloat64(0.131576357788731),
			Flogctail: float64(1.1729485484531301e-14),
		},
		45: {
			Finvc:     float64(1.1328125),
			Flogc:     -Float64FromFloat64(0.12470347850091912),
			Flogctail: -Float64FromFloat64(3.811763084710266e-14),
		},
		46: {
			Finvc:     float64(1.125),
			Flogc:     -Float64FromFloat64(0.11778303565643),
			Flogctail: float64(4.654729747598445e-14),
		},
		47: {
			Finvc:     float64(1.125),
			Flogc:     -Float64FromFloat64(0.11778303565643),
			Flogctail: float64(4.654729747598445e-14),
		},
		48: {
			Finvc:     float64(1.1171875),
			Flogc:     -Float64FromFloat64(0.11081436634026431),
			Flogctail: -Float64FromFloat64(2.5799991283069902e-14),
		},
		49: {
			Finvc:     float64(1.109375),
			Flogc:     -Float64FromFloat64(0.10379679368168127),
			Flogctail: float64(3.7700471749674615e-14),
		},
		50: {
			Finvc:     float64(1.109375),
			Flogc:     -Float64FromFloat64(0.10379679368168127),
			Flogctail: float64(3.7700471749674615e-14),
		},
		51: {
			Finvc:     float64(1.1015625),
			Flogc:     -Float64FromFloat64(0.09672962645856842),
			Flogctail: float64(1.7306161136093256e-14),
		},
		52: {
			Finvc:     float64(1.1015625),
			Flogc:     -Float64FromFloat64(0.09672962645856842),
			Flogctail: float64(1.7306161136093256e-14),
		},
		53: {
			Finvc:     float64(1.09375),
			Flogc:     -Float64FromFloat64(0.089612158689647),
			Flogctail: -Float64FromFloat64(4.012913552726574e-14),
		},
		54: {
			Finvc:     float64(1.0859375),
			Flogc:     -Float64FromFloat64(0.08244366921110213),
			Flogctail: float64(2.7541708360737882e-14),
		},
		55: {
			Finvc:     float64(1.0859375),
			Flogc:     -Float64FromFloat64(0.08244366921110213),
			Flogctail: float64(2.7541708360737882e-14),
		},
		56: {
			Finvc:     float64(1.078125),
			Flogc:     -Float64FromFloat64(0.07522342123763792),
			Flogctail: float64(5.0396178134370583e-14),
		},
		57: {
			Finvc:     float64(1.078125),
			Flogc:     -Float64FromFloat64(0.07522342123763792),
			Flogctail: float64(5.0396178134370583e-14),
		},
		58: {
			Finvc:     float64(1.0703125),
			Flogc:     -Float64FromFloat64(0.06795066190852594),
			Flogctail: float64(1.8195060030168815e-14),
		},
		59: {
			Finvc:     float64(1.0625),
			Flogc:     -Float64FromFloat64(0.06062462181648698),
			Flogctail: float64(5.213620639136504e-14),
		},
		60: {
			Finvc:     float64(1.0625),
			Flogc:     -Float64FromFloat64(0.06062462181648698),
			Flogctail: float64(5.213620639136504e-14),
		},
		61: {
			Finvc:     float64(1.0546875),
			Flogc:     -Float64FromFloat64(0.053244514518837605),
			Flogctail: float64(2.532168943117445e-14),
		},
		62: {
			Finvc:     float64(1.0546875),
			Flogc:     -Float64FromFloat64(0.053244514518837605),
			Flogctail: float64(2.532168943117445e-14),
		},
		63: {
			Finvc:     float64(1.046875),
			Flogc:     -Float64FromFloat64(0.045809536031242715),
			Flogctail: -Float64FromFloat64(5.148849572685811e-14),
		},
		64: {
			Finvc:     float64(1.046875),
			Flogc:     -Float64FromFloat64(0.045809536031242715),
			Flogctail: -Float64FromFloat64(5.148849572685811e-14),
		},
		65: {
			Finvc:     float64(1.0390625),
			Flogc:     -Float64FromFloat64(0.038318864302141264),
			Flogctail: float64(4.6652946995830086e-15),
		},
		66: {
			Finvc:     float64(1.0390625),
			Flogc:     -Float64FromFloat64(0.038318864302141264),
			Flogctail: float64(4.6652946995830086e-15),
		},
		67: {
			Finvc:     float64(1.03125),
			Flogc:     -Float64FromFloat64(0.03077165866670839),
			Flogctail: -Float64FromFloat64(4.529814257790929e-14),
		},
		68: {
			Finvc:     float64(1.03125),
			Flogc:     -Float64FromFloat64(0.03077165866670839),
			Flogctail: -Float64FromFloat64(4.529814257790929e-14),
		},
		69: {
			Finvc:     float64(1.0234375),
			Flogc:     -Float64FromFloat64(0.023167059281490765),
			Flogctail: -Float64FromFloat64(4.361324067851568e-14),
		},
		70: {
			Finvc:     float64(1.015625),
			Flogc:     -Float64FromFloat64(0.015504186535963527),
			Flogctail: -Float64FromFloat64(1.7274567499706107e-15),
		},
		71: {
			Finvc:     float64(1.015625),
			Flogc:     -Float64FromFloat64(0.015504186535963527),
			Flogctail: -Float64FromFloat64(1.7274567499706107e-15),
		},
		72: {
			Finvc:     float64(1.0078125),
			Flogc:     -Float64FromFloat64(0.0077821404420319595),
			Flogctail: -Float64FromFloat64(2.298941004620351e-14),
		},
		73: {
			Finvc:     float64(1.0078125),
			Flogc:     -Float64FromFloat64(0.0077821404420319595),
			Flogctail: -Float64FromFloat64(2.298941004620351e-14),
		},
		74: {
			Finvc: float64(1),
		},
		75: {
			Finvc: float64(1),
		},
		76: {
			Finvc:     float64(0.9921875),
			Flogc:     float64(0.007843177461040796),
			Flogctail: -Float64FromFloat64(1.4902732911301337e-14),
		},
		77: {
			Finvc:     float64(0.984375),
			Flogc:     float64(0.01574835696817445),
			Flogctail: -Float64FromFloat64(3.527980389655325e-14),
		},
		78: {
			Finvc:     float64(0.9765625),
			Flogc:     float64(0.023716526617363343),
			Flogctail: -Float64FromFloat64(4.730054772033249e-14),
		},
		79: {
			Finvc:     float64(0.96875),
			Flogc:     float64(0.03174869831457272),
			Flogctail: float64(7.580310369375161e-15),
		},
		80: {
			Finvc:     float64(0.9609375),
			Flogc:     float64(0.039845908547249564),
			Flogctail: -Float64FromFloat64(4.9893776716773285e-14),
		},
		81: {
			Finvc:     float64(0.953125),
			Flogc:     float64(0.048009219186383234),
			Flogctail: -Float64FromFloat64(2.262629393030674e-14),
		},
		82: {
			Finvc:     float64(0.9453125),
			Flogc:     float64(0.056239718322899535),
			Flogctail: -Float64FromFloat64(2.345674491018699e-14),
		},
		83: {
			Finvc:     float64(0.94140625),
			Flogc:     float64(0.06038051098892083),
			Flogctail: -Float64FromFloat64(1.3352588834854848e-14),
		},
		84: {
			Finvc:     float64(0.93359375),
			Flogc:     float64(0.06871389254808946),
			Flogctail: -Float64FromFloat64(3.765296820388875e-14),
		},
		85: {
			Finvc:     float64(0.92578125),
			Flogc:     float64(0.07711730334438016),
			Flogctail: float64(5.1128335719851986e-14),
		},
		86: {
			Finvc:     float64(0.91796875),
			Flogc:     float64(0.08559193033545398),
			Flogctail: -Float64FromFloat64(5.046674438470119e-14),
		},
		87: {
			Finvc:     float64(0.9140625),
			Flogc:     float64(0.08985632912185793),
			Flogctail: float64(3.1218748807418837e-15),
		},
		88: {
			Finvc:     float64(0.90625),
			Flogc:     float64(0.09844007281321865),
			Flogctail: float64(3.3871241029241416e-14),
		},
		89: {
			Finvc:     float64(0.8984375),
			Flogc:     float64(0.10709813555638448),
			Flogctail: -Float64FromFloat64(1.7376727386423858e-14),
		},
		90: {
			Finvc:     float64(0.89453125),
			Flogc:     float64(0.11145544092528326),
			Flogctail: float64(3.957125899799804e-14),
		},
		91: {
			Finvc:     float64(0.88671875),
			Flogc:     float64(0.12022742699821265),
			Flogctail: -Float64FromFloat64(5.2849453521890294e-14),
		},
		92: {
			Finvc:     float64(0.8828125),
			Flogc:     float64(0.12464244520731427),
			Flogctail: -Float64FromFloat64(3.767012502308738e-14),
		},
		93: {
			Finvc:     float64(0.875),
			Flogc:     float64(0.13353139262449076),
			Flogctail: float64(3.1859736349078334e-14),
		},
		94: {
			Finvc:     float64(0.87109375),
			Flogc:     float64(0.13800567301939282),
			Flogctail: float64(5.0900642926060466e-14),
		},
		95: {
			Finvc:     float64(0.86328125),
			Flogc:     float64(0.14701474296180095),
			Flogctail: float64(8.710783796122478e-15),
		},
		96: {
			Finvc:     float64(0.859375),
			Flogc:     float64(0.15154989812720032),
			Flogctail: float64(6.157896229122976e-16),
		},
		97: {
			Finvc:     float64(0.8515625),
			Flogc:     float64(0.16068238169043525),
			Flogctail: float64(3.821577743916796e-14),
		},
		98: {
			Finvc:     float64(0.84765625),
			Flogc:     float64(0.16528009093906348),
			Flogctail: float64(3.9440046718453496e-14),
		},
		99: {
			Finvc:     float64(0.83984375),
			Flogc:     float64(0.17453941635187675),
			Flogctail: float64(2.2924522154618074e-14),
		},
		100: {
			Finvc:     float64(0.8359375),
			Flogc:     float64(0.17920142945774842),
			Flogctail: -Float64FromFloat64(3.742530094732263e-14),
		},
		101: {
			Finvc:     float64(0.83203125),
			Flogc:     float64(0.18388527877016259),
			Flogctail: -Float64FromFloat64(2.5223102140407338e-14),
		},
		102: {
			Finvc:     float64(0.82421875),
			Flogc:     float64(0.1933193110035063),
			Flogctail: -Float64FromFloat64(1.0320443688698849e-14),
		},
		103: {
			Finvc:     float64(0.8203125),
			Flogc:     float64(0.19806991376208316),
			Flogctail: float64(1.0634128304268335e-14),
		},
		104: {
			Finvc:     float64(0.8125),
			Flogc:     float64(0.20763936477828793),
			Flogctail: -Float64FromFloat64(4.3425422595242564e-14),
		},
		105: {
			Finvc:     float64(0.80859375),
			Flogc:     float64(0.21245865121420593),
			Flogctail: -Float64FromFloat64(1.2527395755711364e-14),
		},
		106: {
			Finvc:     float64(0.8046875),
			Flogc:     float64(0.21730127569003344),
			Flogctail: -Float64FromFloat64(5.204008743405884e-14),
		},
		107: {
			Finvc:     float64(0.80078125),
			Flogc:     float64(0.22216746534115828),
			Flogctail: -Float64FromFloat64(3.979844515951702e-15),
		},
		108: {
			Finvc:     float64(0.79296875),
			Flogc:     float64(0.2319714654378231),
			Flogctail: -Float64FromFloat64(4.7955860343296286e-14),
		},
		109: {
			Finvc:     float64(0.7890625),
			Flogc:     float64(0.2369097470783572),
			Flogctail: float64(5.015686013791602e-16),
		},
		110: {
			Finvc:     float64(0.78515625),
			Flogc:     float64(0.24187253642048745),
			Flogctail: -Float64FromFloat64(7.252318953240293e-16),
		},
		111: {
			Finvc:     float64(0.78125),
			Flogc:     float64(0.2468600779315011),
			Flogctail: float64(2.4688324156011588e-14),
		},
		112: {
			Finvc:     float64(0.7734375),
			Flogc:     float64(0.2569104137850218),
			Flogctail: float64(5.465121253624792e-15),
		},
		113: {
			Finvc:     float64(0.76953125),
			Flogc:     float64(0.26197371574153294),
			Flogctail: float64(4.102651071698446e-14),
		},
		114: {
			Finvc:     float64(0.765625),
			Flogc:     float64(0.2670627852490952),
			Flogctail: -Float64FromFloat64(4.996736502345936e-14),
		},
		115: {
			Finvc:     float64(0.76171875),
			Flogc:     float64(0.27217788591576664),
			Flogctail: float64(4.903580708156347e-14),
		},
		116: {
			Finvc:     float64(0.7578125),
			Flogc:     float64(0.27731928541618345),
			Flogctail: float64(5.089628039500759e-14),
		},
		117: {
			Finvc:     float64(0.75390625),
			Flogc:     float64(0.28248725557466514),
			Flogctail: float64(1.1782016386565151e-14),
		},
		118: {
			Finvc:     float64(0.74609375),
			Flogc:     float64(0.29290401643288533),
			Flogctail: float64(4.727452940514406e-14),
		},
		119: {
			Finvc:     float64(0.7421875),
			Flogc:     float64(0.29815337231912054),
			Flogctail: -Float64FromFloat64(4.4204083338755686e-14),
		},
		120: {
			Finvc:     float64(0.73828125),
			Flogc:     float64(0.3034304294199046),
			Flogctail: float64(1.548345993498083e-14),
		},
		121: {
			Finvc:     float64(0.734375),
			Flogc:     float64(0.30873548164959175),
			Flogctail: float64(2.1522127491642888e-14),
		},
		122: {
			Finvc:     float64(0.73046875),
			Flogc:     float64(0.3140688276249648),
			Flogctail: float64(1.1054030169005386e-14),
		},
		123: {
			Finvc:     float64(0.7265625),
			Flogc:     float64(0.31943077076641657),
			Flogctail: -Float64FromFloat64(5.534326352070679e-14),
		},
		124: {
			Finvc:     float64(0.72265625),
			Flogc:     float64(0.3248216194012912),
			Flogctail: -Float64FromFloat64(5.351646604259541e-14),
		},
		125: {
			Finvc:     float64(0.71875),
			Flogc:     float64(0.33024168687052224),
			Flogctail: float64(5.4612144489920215e-14),
		},
		126: {
			Finvc:     float64(0.71484375),
			Flogc:     float64(0.3356912916381134),
			Flogctail: float64(2.8136969901227338e-14),
		},
		127: {
			Finvc:     float64(0.7109375),
			Flogc:     float64(0.3411707574027787),
			Flogctail: -Float64FromFloat64(1.156568624616423e-14),
		},
	},
}

var X__powf_log2_data = Tpowf_log2_data{
	Ftab: [16]struct {
		Finvc float64
		Flogc float64
	}{
		0: {
			Finvc: float64(1.398907162146528),
			Flogc: -Float64FromFloat64(0.48430022186289673) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		1: {
			Finvc: float64(1.3403141896637998),
			Flogc: -Float64FromFloat64(0.42257122959194704) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		2: {
			Finvc: float64(1.286432210124115),
			Flogc: -Float64FromFloat64(0.3633754347673556) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		3: {
			Finvc: float64(1.2367150214269895),
			Flogc: -Float64FromFloat64(0.30651309567405577) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		4: {
			Finvc: float64(1.1906977166711752),
			Flogc: -Float64FromFloat64(0.25180720160537634) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		5: {
			Finvc: float64(1.1479821020556429),
			Flogc: -Float64FromFloat64(0.19910014943794563) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		6: {
			Finvc: float64(1.1082251448272158),
			Flogc: -Float64FromFloat64(0.14825100623281615) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		7: {
			Finvc: float64(1.0711297413057381),
			Flogc: -Float64FromFloat64(0.09913323807318392) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		8: {
			Finvc: float64(1.036437278977283),
			Flogc: -Float64FromFloat64(0.051632812977629436) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		9: {
			Finvc: float64(1),
			Flogc: float64(0) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		10: {
			Finvc: float64(0.9492859795739057),
			Flogc: float64(0.07508531937943004) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		11: {
			Finvc: float64(0.8951049428609004),
			Flogc: float64(0.15987125980713107) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		12: {
			Finvc: float64(0.8476821620351103),
			Flogc: float64(0.2384046664317681) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		13: {
			Finvc: float64(0.8050314851692001),
			Flogc: float64(0.31288288605863257) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		14: {
			Finvc: float64(0.7664671008843108),
			Flogc: float64(0.38370422656453185) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
		15: {
			Finvc: float64(0.731428603316328),
			Flogc: float64(0.451211048935815) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		},
	},
	Fpoly: [5]float64{
		0: float64(0.288457581109214) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		1: -Float64FromFloat64(0.36092606229713164) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		2: float64(0.480898481472577) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		3: -Float64FromFloat64(0.7213474675006291) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
		4: float64(1.4426950408774342) * float64(Int32FromInt32(1)<<Int32FromInt32(POWF_SCALE_BITS)),
	},
}

var Xprogram_invocation_short_name uintptr

var Xprogram_invocation_name uintptr

var X__random_lockptr = uintptr(unsafe.Pointer(&_lock3))

var X__rsqrt_tab = [128]Tuint16_t{
	0:   uint16(0xb451),
	1:   uint16(0xb2f0),
	2:   uint16(0xb196),
	3:   uint16(0xb044),
	4:   uint16(0xaef9),
	5:   uint16(0xadb6),
	6:   uint16(0xac79),
	7:   uint16(0xab43),
	8:   uint16(0xaa14),
	9:   uint16(0xa8eb),
	10:  uint16(0xa7c8),
	11:  uint16(0xa6aa),
	12:  uint16(0xa592),
	13:  uint16(0xa480),
	14:  uint16(0xa373),
	15:  uint16(0xa26b),
	16:  uint16(0xa168),
	17:  uint16(0xa06a),
	18:  uint16(0x9f70),
	19:  uint16(0x9e7b),
	20:  uint16(0x9d8a),
	21:  uint16(0x9c9d),
	22:  uint16(0x9bb5),
	23:  uint16(0x9ad1),
	24:  uint16(0x99f0),
	25:  uint16(0x9913),
	26:  uint16(0x983a),
	27:  uint16(0x9765),
	28:  uint16(0x9693),
	29:  uint16(0x95c4),
	30:  uint16(0x94f8),
	31:  uint16(0x9430),
	32:  uint16(0x936b),
	33:  uint16(0x92a9),
	34:  uint16(0x91ea),
	35:  uint16(0x912e),
	36:  uint16(0x9075),
	37:  uint16(0x8fbe),
	38:  uint16(0x8f0a),
	39:  uint16(0x8e59),
	40:  uint16(0x8daa),
	41:  uint16(0x8cfe),
	42:  uint16(0x8c54),
	43:  uint16(0x8bac),
	44:  uint16(0x8b07),
	45:  uint16(0x8a64),
	46:  uint16(0x89c4),
	47:  uint16(0x8925),
	48:  uint16(0x8889),
	49:  uint16(0x87ee),
	50:  uint16(0x8756),
	51:  uint16(0x86c0),
	52:  uint16(0x862b),
	53:  uint16(0x8599),
	54:  uint16(0x8508),
	55:  uint16(0x8479),
	56:  uint16(0x83ec),
	57:  uint16(0x8361),
	58:  uint16(0x82d8),
	59:  uint16(0x8250),
	60:  uint16(0x81c9),
	61:  uint16(0x8145),
	62:  uint16(0x80c2),
	63:  uint16(0x8040),
	64:  uint16(0xff02),
	65:  uint16(0xfd0e),
	66:  uint16(0xfb25),
	67:  uint16(0xf947),
	68:  uint16(0xf773),
	69:  uint16(0xf5aa),
	70:  uint16(0xf3ea),
	71:  uint16(0xf234),
	72:  uint16(0xf087),
	73:  uint16(0xeee3),
	74:  uint16(0xed47),
	75:  uint16(0xebb3),
	76:  uint16(0xea27),
	77:  uint16(0xe8a3),
	78:  uint16(0xe727),
	79:  uint16(0xe5b2),
	80:  uint16(0xe443),
	81:  uint16(0xe2dc),
	82:  uint16(0xe17a),
	83:  uint16(0xe020),
	84:  uint16(0xdecb),
	85:  uint16(0xdd7d),
	86:  uint16(0xdc34),
	87:  uint16(0xdaf1),
	88:  uint16(0xd9b3),
	89:  uint16(0xd87b),
	90:  uint16(0xd748),
	91:  uint16(0xd61a),
	92:  uint16(0xd4f1),
	93:  uint16(0xd3cd),
	94:  uint16(0xd2ad),
	95:  uint16(0xd192),
	96:  uint16(0xd07b),
	97:  uint16(0xcf69),
	98:  uint16(0xce5b),
	99:  uint16(0xcd51),
	100: uint16(0xcc4a),
	101: uint16(0xcb48),
	102: uint16(0xca4a),
	103: uint16(0xc94f),
	104: uint16(0xc858),
	105: uint16(0xc764),
	106: uint16(0xc674),
	107: uint16(0xc587),
	108: uint16(0xc49d),
	109: uint16(0xc3b7),
	110: uint16(0xc2d4),
	111: uint16(0xc1f4),
	112: uint16(0xc116),
	113: uint16(0xc03c),
	114: uint16(0xbf65),
	115: uint16(0xbe90),
	116: uint16(0xbdbe),
	117: uint16(0xbcef),
	118: uint16(0xbc23),
	119: uint16(0xbb59),
	120: uint16(0xba91),
	121: uint16(0xb9cc),
	122: uint16(0xb90a),
	123: uint16(0xb84a),
	124: uint16(0xb78c),
	125: uint16(0xb6d0),
	126: uint16(0xb617),
	127: uint16(0xb560),
}

var X__seed48 = [7]uint16{
	3: uint16(0xe66d),
	4: uint16(0xdeec),
	5: uint16(0x5),
	6: uint16(0xb),
}

var Xsigngam int32

var X__stack_chk_guard Tuintptr_t

var X__stderr_FILE = TFILE{
	Fflags: uint32(Int32FromInt32(F_PERM) | Int32FromInt32(F_NORD)),
	Fbuf:   uintptr(unsafe.Pointer(&_buf5)) + uintptr(UNGET),
	Ffd:    int32(2),
	Flock:  -int32(1),
	Flbf:   -int32(1),
}

var X__stderr_used = uintptr(unsafe.Pointer(&X__stderr_FILE))

var X__stdin_FILE = TFILE{
	Fflags:    uint32(Int32FromInt32(F_PERM) | Int32FromInt32(F_NOWR)),
	Fbuf:      uintptr(unsafe.Pointer(&_buf6)) + uintptr(UNGET),
	Fbuf_size: Uint64FromInt64(1032) - Uint64FromInt32(UNGET),
	Flock:     -int32(1),
}

var X__stdin_used = uintptr(unsafe.Pointer(&X__stdin_FILE))

var X__stdio_ofl_lockptr = uintptr(unsafe.Pointer(&_ofl_lock))

var X__stdout_FILE = TFILE{
	Fflags:    uint32(Int32FromInt32(F_PERM) | Int32FromInt32(F_NORD)),
	Fbuf:      uintptr(unsafe.Pointer(&_buf7)) + uintptr(UNGET),
	Fbuf_size: Uint64FromInt64(1032) - Uint64FromInt32(UNGET),
	Ffd:       int32(1),
	Flock:     -int32(1),
	Flbf:      int32('\n'),
}

var X__stdout_used = uintptr(unsafe.Pointer(&X__stdout_FILE))

var X__sysinfo Tsize_t

var X__syslog_lockptr = uintptr(unsafe.Pointer(&_lock2))

var Xtimezone int64

var X__timezone_lockptr = uintptr(unsafe.Pointer(&_lock4))

var Xtzname = [2]uintptr{}

var X__utc = [4]uint8{'U', 'T', 'C'}

var X_ns_flagdata = [16]T_ns_flagdata{
	0: {
		Fmask:  int32(0x8000),
		Fshift: int32(15),
	},
	1: {
		Fmask:  int32(0x7800),
		Fshift: int32(11),
	},
	2: {
		Fmask:  int32(0x0400),
		Fshift: int32(10),
	},
	3: {
		Fmask:  int32(0x0200),
		Fshift: int32(9),
	},
	4: {
		Fmask:  int32(0x0100),
		Fshift: int32(8),
	},
	5: {
		Fmask:  int32(0x0080),
		Fshift: int32(7),
	},
	6: {
		Fmask:  int32(0x0040),
		Fshift: int32(6),
	},
	7: {
		Fmask:  int32(0x0020),
		Fshift: int32(5),
	},
	8: {
		Fmask:  int32(0x0010),
		Fshift: int32(4),
	},
	9: {
		Fmask: int32(0x000f),
	},
	10: {},
	11: {},
	12: {},
	13: {},
	14: {},
	15: {},
}

var Xgetdate_err int32

var Xh_errno int32

var Xin6addr_any = Tin6_addr{}

var Xin6addr_loopback = Tin6_addr{
	F__in6_union: *(*struct {
		F__s6_addr16 [0][8]Tuint16_t
		F__s6_addr32 [0][4]Tuint32_t
		F__s6_addr   [16]Tuint8_t
	})(unsafe.Pointer(&[16]Tuint8_t{
		15: uint8(1),
	})),
}

var Xoptarg uintptr

var Xopterr = int32(1)

var Xoptind = int32(1)

var Xoptopt int32

var Xstderr = uintptr(unsafe.Pointer(&X__stderr_FILE))

var Xstdin = uintptr(unsafe.Pointer(&X__stdin_FILE))

var Xstdout = uintptr(unsafe.Pointer(&X__stdout_FILE))

var __ccgo_ts = (*reflect.StringHeader)(unsafe.Pointer(&__ccgo_ts1)).Data

var __ccgo_ts1 = "\x00/bin:/usr/bin\x00%s\x008b \xd0\xc1\xd2\xcf\xcc\xd8\x00$2a$00$abcdefghijklmnopqrstuu\x00\xff\xa334\xff\xff\xff\xa3345\x00*\x00\x80\xff\x80\x01 \x7f\x81\x80\x80\r\n\xff\x7f \x81 test\x00_0.../9Zz\x00_0.../9ZzX7iSJNd21sU\x00\x80x\x00\x80x22/wK52ZKGA\x00x\x00$1$\x00$5$\x00rounds=\x00rounds=%u$\x00$5$%s%.*s$\x00$6$\x00$6$%s%.*s$\x00toupper\x00tolower\x00Assertion failed: %s (%s: %s: %d)\n\x00infinity\x00nan\x00\x00\x01\x02\x04\a\x03\x06\x05\x00/proc/self/fd/\x00%s: \x00: \x00/dev/tty\x00\n\x00/etc/shells\x00rbe\x00rb\x00UTF-8\x00NLSPATH\x00LANG\x00_.@\x00.@\x00%\x00assembler statements not supported\x00atomic_arch.h\x00bindtextdomain\x00messages\x00%s/%.*s%.*s/%s/%s.mo\x00\x00n!=1;\x00Plural-Forms:\x00nplurals=\x00plural=\x00dcngettext\x00Ê̄Ê̌ê̄ê̌\x00utf8\x00ASCII\x00C\x00LC_ALL\x00C.UTF-8\x00POSIX\x00MUSL_LOCPATH\x00.\x00%*.*f\x00fma\x00/\x00ffsll\x00MSGVERB\x00label\x00severity\x00text\x00action\x00tag\x00HALT: \x00ERROR: \x00WARNING: \x00INFO: \x00/dev/console\x00\nTO FIX: \x00 \x00%s%s%s%s%s%s%s%s\n\x00PWD\x00: unrecognized option: \x00: option requires an argument: \x00: option does not take an argument: \x00: option is ambiguous: \x00%*[^\n]%*[\n]\x00 %n%*[^ \t]%n %n%*[^ \t]%n %n%*[^ \t]%n %n%*[^ \t]%n %d %d\x00%s\t%s\t%s\t%s\t%d\t%d\n\x00/dev/ptmx\x00/dev/pts/%d\x00%b %e %T\x00<%d>%s %n%s%s%.0d%s: \x00[\x00]\x00%.*s\x00/dev/shm/\x00%.2X\x00:%.2X\x00%d.%d.%d.%d.in-addr.arpa\x00ip6.arpa\x00/etc/hosts\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x00/etc/services\x00/udp\x00/tcp\x00tcp\x00udp\x00%s%s%s\n\x00%d.%d.%d.%d\x00%x:%x:%x:%x:%x:%x:%x:%x\x00%x:%x:%x:%x:%x:%x:%d.%d.%d.%d\x00:0\x00/etc/resolv.conf\x00options\x00ndots:\x00attempts:\x00timeout:\x00nameserver\x00domain\x00search\x00127.0.0.1\x00/etc/group\x00/etc/passwd\x00/dev/null\x00re\x00r\x00%s:%s:%u:\x00,\x00%s%s\x00%s:%s:%u:%u:%s:%s:%s\n\x00%s:%s:%.*ld:%.*ld:%.*ld:%.*ld:%.*ld:%.*ld:%.*lu\n\x00PATH\x00/usr/local/bin:/bin:/usr/bin\x00HOME\x00\t\x00\r\x00\f\x00\a\x00\x1b\x00[[:alnum:]_]\x00[^[:alnum:]_]\x00[[:space:]]\x00[^[:space:]]\x00[[:digit:]]\x00[^[:digit:]]\x00__libc_sigaction\x00rwa\x00locking_getc\x00locking_putc\x00__do_orphaned_stdio_locks\x00ftrylockfile\x00/tmp\x00temp\x00w+\x00-0X+0X 0X-0x+0x 0x\x00inf\x00INF\x00NAN\x00-+   0X0x\x00(null)\x00%*s\x00%%%s%s%s%s%s*.*%c%c\x00#\x00+\x00-\x000\x00\x00\x00\x00\x00%.*s%.0d%s%c%%lln\x00%*\x00%.*e\x00%.*f\x00000000000000000\x00%.*g\x00@\x00\x00\x00\x00\x00\x00\x00XXXXXX\x00TZ\x00/etc/localtime\x00UTC\x00GMT\x00TZif\x00%.3s %.3s%3d %.2d:%.2d:%.2d %d\n\x00DATEMSK\x00%m/%d/%y\x00%Y-%m-%d\x00%H:%M\x00%H:%M:%S\x00+%lld\x00%+.4ld\x00%lld\x00%*lld\x00%0*lld\x00timer_delete\x00LOGNAME\x00"
