# Loki Helm Chart - Third-Party Integrations

## Overview

The Loki Helm chart integrates with four third-party components:
1. **MinIO** - Subchart for local S3-compatible storage
2. **Memcached** - Embedded templates for caching
3. **Grafana Agent Operator** - Subchart for self-monitoring
4. **Rollout Operator** - Subchart for zone-aware ingester rollouts

## 1. MinIO Subchart

### Purpose

Provides S3-compatible object storage for development and testing environments. **Not recommended for production.**

### Chart Details

**Source**: https://charts.min.io/  
**Version**: 5.4.0  
**Chart Lock**: `Chart.lock`

### Default Configuration

```yaml
minio:
  enabled: false  # Disabled by default
  replicas: 1
  drivesPerNode: 2  # Minimum for erasure coding
  
  # Root credentials (not used for Loki auth)
  rootUser: root-user
  rootPassword: supersecretpassword
  
  # Loki user (first user used for authentication)
  users:
    - accessKey: logs-user
      secretKey: supersecretpassword
      policy: readwrite
  
  # Auto-created buckets
  buckets:
    - name: chunks
      policy: none
      purge: false
    - name: ruler
      policy: none
      purge: false
    - name: admin
      policy: none
      purge: false
  
  # Persistence
  persistence:
    size: 5Gi
    annotations: {}
  
  # Resources
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
  
  # Service
  service:
    port: 9000
  
  # Override endpoint address
  address: null
```

### Auto-Configuration When Enabled

**Template**: `templates/_helpers.tpl` - `loki.minio` helper

When `minio.enabled: true`:

1. **Storage Config Auto-Generated** (in `loki.commonStorageConfig`):
```yaml
s3:
  endpoint: loki-minio.loki.svc:9000
  bucketnames: chunks
  secret_access_key: supersecretpassword
  access_key_id: logs-user
  s3forcepathstyle: true
  insecure: true
```

2. **Bucket Names**: Auto-set to `chunks`, `ruler`, `admin`

3. **Admin API Config** (if enterprise.adminApi.enabled):
```yaml
# Auto-added to admin-api deployment args
- -admin.client.backend-type=s3
- -admin.client.s3.endpoint={{ template "loki.minio" . }}
- -admin.client.s3.bucket-name={{ .Values.loki.storage.bucketNames.admin }}
- -admin.client.s3.access-key-id={{ (index .Values.minio.users 0).accessKey }}
- -admin.client.s3.secret-access-key={{ (index .Values.minio.users 0).secretKey }}
- -admin.client.s3.insecure={{ .Values.loki.storage.s3.insecure }}
```

4. **Gateway Auto-Config**: Similar args for enterprise gateway

### Address Override

```yaml
minio:
  address: minio.external-namespace.svc:9000
```

**Helper**:
```go
{{- define "loki.minio" -}}
{{- .Values.minio.address | default (printf "%s-%s.%s.svc:%s" .Release.Name "minio" (include "loki.namespace" .) (.Values.minio.service.port | toString)) -}}
{{- end -}}
```

### Production Alternative

For production, disable MinIO and use cloud object storage:

```yaml
minio:
  enabled: false

loki:
  storage:
    type: s3  # or gcs, azure
    bucketNames:
      chunks: production-loki-chunks
      ruler: production-loki-ruler
      admin: production-loki-admin
    s3:
      region: us-east-1
      # Use IRSA/Workload Identity for credentials
```

### Volume Mounts (when enabled)

Components automatically mount MinIO configuration:

```yaml
# templates/admin-api/deployment-admin-api.yaml
{{- if .Values.minio.enabled }}
volumes:
  - name: minio-configuration
    projected:
      sources:
        - configMap:
            name: {{ .Release.Name }}-minio
        - secret:
            name: {{ .Release.Name }}-minio
  {{- if .Values.minio.tls.enabled }}
  - name: cert-secret-volume-mc
    secret:
      secretName: {{ .Values.minio.tls.certSecret }}
{{- end }}
{{- end }}
```

---

## 2. Memcached Embedded Templates

### Purpose

Provides caching layer to reduce object storage reads and improve query performance.

### Implementation

**NOT a subchart** - implemented via reusable templates in `templates/memcached/`

### Template Files

#### templates/memcached/_memcached-statefulset.tpl

**Define**: `loki.memcached.statefulSet`  
**Params**:
- `ctx` - Helm context ($ or .)
- `memcacheConfig` - Configuration (chunksCache or resultsCache values)
- `valuesSection` - Name in values.yaml (chunksCache, resultsCache)
- `component` - K8s component name (chunks-cache, results-cache)

**Features**:
- Creates StatefulSet with memcached + exporter containers
- Auto-calculates memory requests: `ceil(allocatedMemory * 1.2)`
- Persistence support with ext_path
- Auto-calculates persistence size: `ceil(storageSize * 0.9)`
- Extended options support
- Pod management policy configurable
- Update strategy configurable

**Memcached Container**:
```yaml
containers:
  - name: memcached
    image: memcached:1.6.36-alpine
    args:
      - -m {{ .allocatedMemory }}  # Memory limit MB
      - --extended=modern,track_sizes{{ if .persistence.enabled }},ext_path={{ .persistence.mountPath }}/file:{{ $persistenceSize }}G,ext_wbuf_size=16{{ end }}{{ with .extraExtendedOptions }},{{ . }}{{ end }}
      - -I {{ .maxItemMemory }}m  # Max item size MB
      - -c {{ .connectionLimit }}  # Max connections
      - -v  # Verbose logging
      - -u {{ .port }}  # UDP port
    resources:
      limits:
        memory: {{ $requestMemory }}Mi
      requests:
        cpu: 500m
        memory: {{ $requestMemory }}Mi
```

**Exporter Container** (if memcachedExporter.enabled):
```yaml
- name: exporter
  image: prom/memcached-exporter:v0.15.3
  ports:
    - containerPort: 9150
      name: http-metrics
  args:
    - "--memcached.address=localhost:{{ .port }}"
    - "--web.listen-address=0.0.0.0:9150"
  resources:
    {{- toYaml $.ctx.Values.memcachedExporter.resources | nindent 12 }}
```

#### templates/memcached/_memcached-svc.tpl

**Define**: `loki.memcached.service`  
**Type**: Service (ClusterIP: None)  
**Ports**:
- `memcached-client`: Memcached port (11211 default)
- `http-metrics`: Exporter port (9150, if enabled)

#### templates/memcached/_memcached-pdb.tpl

**Define**: `loki.memcached.pdb`  
**Type**: PodDisruptionBudget  
**Active If**: enabled AND replicas > 1

### Usage in Chart

#### Chunks Cache

**Templates**:
- `templates/chunks-cache/statefulset-chunks-cache.yaml`
- `templates/chunks-cache/service-chunks-cache-headless.yaml`
- `templates/chunks-cache/poddisruptionbudget-chunks-cache.yaml`

**Invocation**:
```yaml
# StatefulSet
{{- include "loki.memcached.statefulSet" (dict "ctx" $ "memcacheConfig" .Values.chunksCache "valuesSection" "chunksCache" "component" "chunks-cache") }}

# L2 cache (separate StatefulSet)
{{- if .Values.chunksCache.l2.enabled }}
---
{{ include "loki.memcached.statefulSet" (dict "ctx" $ "memcacheConfig" .Values.chunksCache.l2 "valuesSection" "chunksCache" "component" "chunks-cache") }}
{{- end }}
```

**Resource Names**:
- L1: `loki-chunks-cache` (or with suffix)
- L2: `loki-chunks-cache-l2`

#### Results Cache

**Templates**:
- `templates/results-cache/statefulset-results-cache.yaml`
- `templates/results-cache/service-results-cache-headless.yaml`
- `templates/results-cache/poddisruptionbudget-results-cache.yaml` (direct, not using helper)

**Invocation**:
```yaml
{{- include "loki.memcached.statefulSet" (dict "ctx" $ "memcacheConfig" .Values.resultsCache "valuesSection" "resultsCache" "component" "results-cache") }}
```

**Resource Name**: `loki-results-cache`

### Configuration in Loki Config

**Chunks Cache** (templates/config.yaml):
```yaml
{{- if .Values.chunksCache.enabled }}
chunk_store_config:
  chunk_cache_config:
    default_validity: {{ .defaultValidity }}
    background:
      writeback_goroutines: {{ .writebackParallelism }}
      writeback_buffer: {{ .writebackBuffer }}
      writeback_size_limit: {{ .writebackSizeLimit }}
    memcached:
      batch_size: {{ .batchSize }}
      parallelism: {{ .parallelism }}
    memcached_client:
      addresses: {{ .addresses }}
      consistent_hash: true
      timeout: {{ .timeout }}
      max_idle_conns: 72
{{- end }}
```

**Results Cache**:
```yaml
{{- if .Values.resultsCache.enabled }}
query_range:
  cache_results: true
  results_cache:
    cache:
      default_validity: {{ .defaultValidity }}
      # ... similar to chunks cache
      memcached_client:
        addresses: {{ .addresses }}
{{- end }}
```

### Address Configuration

**DNS Service Discovery Format**:
```yaml
chunksCache:
  addresses: dnssrvnoa+_memcached-client._tcp.loki-chunks-cache.loki.svc

resultsCache:
  addresses: dnssrvnoa+_memcached-client._tcp.loki-results-cache.loki.svc
```

**Template Helper** (used in default addresses):
```go
{{ include "loki.resourceName" (dict "ctx" $ "component" "chunks-cache") }}.{{ include "loki.namespace" $ }}.svc
```

### External Memcached

Disable chart-managed memcached and provide external addresses:

```yaml
memcached:
  enabled: false  # Do not create StatefulSets

chunksCache:
  enabled: true
  addresses: my-memcached.external-ns.svc:11211

resultsCache:
  enabled: true
  addresses: my-results-cache.external-ns.svc:11211
```

### Memcached Global Configuration

```yaml
memcached:
  enabled: true
  image:
    repository: memcached
    tag: 1.6.36-alpine
    pullPolicy: IfNotPresent
  
  podSecurityContext:
    fsGroup: 11211
    runAsGroup: 11211
    runAsNonRoot: true
    runAsUser: 11211
  
  containerSecurityContext:
    readOnlyRootFilesystem: true
    capabilities:
      drop: [ALL]
    allowPrivilegeEscalation: false
  
  # Probes
  readinessProbe:
    tcpSocket:
      port: client
    initialDelaySeconds: 5
    periodSeconds: 10
  
  livenessProbe:
    tcpSocket:
      port: client
    initialDelaySeconds: 10
    periodSeconds: 10
```

### Memcached Exporter Configuration

```yaml
memcachedExporter:
  enabled: true
  image:
    repository: prom/memcached-exporter
    tag: v0.15.3
    pullPolicy: IfNotPresent
  
  resources:
    requests: {}
    limits: {}
  
  containerSecurityContext:
    readOnlyRootFilesystem: true
    capabilities:
      drop: [ALL]
    allowPrivilegeEscalation: false
  
  # Extra args
  extraArgs: {}
    # memcached.tls.enable: true
    # memcached.tls.cert-file: /certs/cert.crt
  
  # Probes
  livenessProbe:
    httpGet:
      path: /metrics
      port: http-metrics
    initialDelaySeconds: 30
  
  readinessProbe:
    httpGet:
      path: /metrics
      port: http-metrics
    initialDelaySeconds: 5
```

### Persistence for Memcached

```yaml
chunksCache:
  persistence:
    enabled: true
    storageSize: 10G  # Must be in G or Gi
    storageClass: fast-ssd
    mountPath: /data
    labels:
      type: cache

resultsCache:
  persistence:
    enabled: true
    storageSize: 5G
```

**Effect**: Enables memcached persistence with `ext_path`:
```
--extended=...,ext_path=/data/file:9G,ext_wbuf_size=16
```

**Size Calculation**: `(storageSize * 0.9)` to leave headroom

### Extended Options

```yaml
chunksCache:
  extraExtendedOptions: "tls,no_hashexpand"
```

**Result**:
```
--extended=modern,track_sizes,ext_path=/data/file:9G,ext_wbuf_size=16,tls,no_hashexpand
```

**Common Options**:
- `tls` - Enable TLS
- `no_hashexpand` - Disable hash table expansion
- `track_sizes` - Track item sizes (default)
- `modern` - Modern mode (default)
- `no_lru_crawler` - Disable LRU crawler
- `no_lru_maintainer` - Disable LRU maintainer

---

## 2. Grafana Agent Operator Subchart

### Purpose

Enables self-monitoring by scraping Loki's own logs and sending them back to Loki for validation.

### Chart Details

**Source**: https://grafana.github.io/helm-charts  
**Version**: 0.5.1  
**Chart Lock**: `Chart.lock`

### Installation

```yaml
monitoring:
  selfMonitoring:
    enabled: true
    grafanaAgent:
      installOperator: true  # Install operator + CRDs
```

**⚠️ Note**: Helm doesn't upgrade CRDs. Manual CRD installation required for upgrades:
```bash
kubectl apply -f https://raw.githubusercontent.com/grafana/agent/main/production/operator/crds/...
```

### Generated Resources

When `monitoring.selfMonitoring.enabled: true`:

#### 1. GrafanaAgent Custom Resource

**Template**: `templates/monitoring/grafana-agent.yaml`  
**Type**: GrafanaAgent (CRD)

```yaml
apiVersion: monitoring.grafana.com/v1alpha1
kind: GrafanaAgent
metadata:
  name: loki
spec:
  serviceAccountName: loki-grafana-agent
  enableConfigReadAPI: false
  logs:
    instanceSelector:
      matchLabels:
        app.kubernetes.io/name: loki
        app.kubernetes.io/instance: {{ .Release.Name }}
  metrics:  # If serviceMonitor.metricsInstance.remoteWrite defined
    instanceSelector:
      matchLabels:
        app.kubernetes.io/name: loki
```

#### 2. LogsInstance Custom Resource

**Template**: `templates/monitoring/logs-instance.yaml`  
**Type**: LogsInstance (CRD)

```yaml
apiVersion: monitoring.grafana.com/v1alpha1
kind: LogsInstance
metadata:
  name: loki
spec:
  clients:
    - url: http://loki-write.loki.svc:3100/loki/api/v1/push  # Auto-configured
      externalLabels:
        cluster: {{ include "loki.clusterLabel" . }}
      basicAuth:  # If enterprise
        username: {secret}
        password: {secret}
      tenantId: self-monitoring  # If auth_enabled
  
  podLogsNamespaceSelector: {}
  podLogsSelector:
    matchLabels:
      app.kubernetes.io/name: loki
```

**Client URL Logic** (`loki.logsInstanceClient` helper):
- SingleBinary: Points to singleBinary service
- SimpleScalable: Points to write service
- With Gateway: Points to gateway
- Adds tenantId if auth_enabled
- Adds basicAuth if enterprise

#### 3. PodLogs Custom Resource

**Template**: `templates/monitoring/pod-logs.yaml`  
**Type**: PodLogs (CRD)

```yaml
apiVersion: monitoring.grafana.com/v1alpha1
kind: PodLogs
metadata:
  name: loki
spec:
  pipelineStages:
    - cri: {}
    {{- with .Values.monitoring.selfMonitoring.podLogs.additionalPipelineStages }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  
  relabelings:
    - action: replace
      sourceLabels: [__meta_kubernetes_pod_node_name]
      targetLabel: __host__
    - action: labelmap
      regex: __meta_kubernetes_pod_label_(.+)
    - action: replace
      replacement: "$1"
      separator: "-"
      sourceLabels:
        - __meta_kubernetes_pod_label_app_kubernetes_io_name
        - __meta_kubernetes_pod_label_app_kubernetes_io_component
      targetLabel: __service__
    - action: replace
      replacement: "$1"
      separator: "/"
      sourceLabels: [__meta_kubernetes_namespace, __service__]
      targetLabel: job
    - action: replace
      sourceLabels: [__meta_kubernetes_pod_container_name]
      targetLabel: container
    - action: replace
      replacement: "{{ include "loki.clusterLabel" $ }}"
      targetLabel: cluster
  
  namespaceSelector:
    matchNames: [{{ include "loki.namespace" $ }}]
  
  selector:
    matchLabels:
      app.kubernetes.io/name: loki
```

**Effect**: Scrapes logs from all Loki pods, relabels for standard format

#### 4. MetricsInstance Custom Resource

**Template**: `templates/monitoring/metrics-instance.yaml`  
**Type**: MetricsInstance (CRD)  
**Active If**: serviceMonitor.enabled AND metricsInstance.enabled

```yaml
apiVersion: monitoring.grafana.com/v1alpha1
kind: MetricsInstance
metadata:
  name: loki
spec:
  remoteWrite:
    - url: http://prometheus:9090/api/v1/write
  
  serviceMonitorNamespaceSelector: {}
  serviceMonitorSelector:
    matchLabels:
      app.kubernetes.io/name: loki
```

**Purpose**: Remote write Loki metrics to Prometheus/Mimir

#### 5. RBAC Resources

**Template**: `templates/monitoring/grafana-agent.yaml` (includes all)

**ServiceAccount**: `loki-grafana-agent`

**ClusterRole**: Permissions for:
- nodes, nodes/proxy, nodes/metrics, services, endpoints, pods, events (get/list/watch)
- ingresses (get/list/watch)
- /metrics, /metrics/cadvisor (get)

**ClusterRoleBinding**: Binds SA → ClusterRole

### Configuration

```yaml
monitoring:
  selfMonitoring:
    enabled: true
    
    tenant:
      name: self-monitoring
      password: secret  # If not enterprise
      secretNamespace: '{{ include "loki.namespace" . }}'
    
    grafanaAgent:
      installOperator: true
      enableConfigReadAPI: false
      priorityClassName: null
      resources:
        limits:
          memory: 200Mi
        requests:
          cpu: 50m
          memory: 100Mi
      tolerations: []
      annotations: {}
      labels: {}
    
    podLogs:
      apiVersion: monitoring.grafana.com/v1alpha1
      annotations: {}
      labels: {}
      relabelings: []
      additionalPipelineStages:
        - regex:
            expression: '.*level=(?P<level>[a-zA-Z]+).*'
        - labels:
            level: ""
    
    logsInstance:
      annotations: {}
      labels: {}
      clients:
        - url: http://external-loki:3100/loki/api/v1/push
          externalLabels:
            source: secondary
```

### Tenant Secret Creation (Enterprise)

**No Longer Auto-Created** (as of 6.36.0):
- Provisioner outputs tokens to logs
- Manual secret creation required:

```bash
kubectl logs -l job-name=loki-provisioner -n loki

# Copy token from logs, then:
kubectl create secret generic loki-provisioned-self-monitoring \
  --from-literal=username=self-monitoring \
  --from-literal=password=<token-from-logs> \
  -n loki
```

---

## 3. Rollout Operator Subchart

### Purpose

Manages controlled rollouts of zone-aware ingester StatefulSets, ensuring data availability during updates.

### Chart Details

**Source**: https://grafana.github.io/helm-charts  
**Version**: 0.32.0  
**Chart Lock**: `Chart.lock`

### Enabling

```yaml
rollout_operator:
  enabled: false  # Enable when using zone-aware ingesters

ingester:
  zoneAwareReplication:
    enabled: true
```

**⚠️ Recommendation**: Enable rollout operator when using zone-aware replication for safer rollouts

### How It Works

1. **Detects StatefulSets** with:
   - `rollout-group` label
   - `rollout-max-unavailable` annotation

2. **Orchestrates Rollouts**:
   - Respects maxUnavailable per group
   - Ensures data availability across zones
   - Prevents simultaneous updates to multiple zones

3. **Zone-Aware Ingester Labels**:
```yaml
# On each zone StatefulSet
metadata:
  labels:
    name: ingester-zone-a
    rollout-group: ingester
  annotations:
    rollout-max-unavailable: "1"  # Calculated per zone
```

4. **PDB Integration**:
```yaml
# templates/ingester/poddisruptionbudget-ingester-rollout.yaml
selector:
  matchLabels:
    rollout-group: ingester  # Matches all zones
maxUnavailable: {{ .Values.ingester.maxUnavailable }}  # Global limit
```

### Configuration

```yaml
rollout_operator:
  enabled: true
  
  # Security contexts (override for OpenShift)
  podSecurityContext:
    fsGroup: 10001
    runAsGroup: 10001
    runAsNonRoot: true
    runAsUser: 10001
    seccompProfile:
      type: RuntimeDefault
  
  securityContext:
    readOnlyRootFilesystem: true
    capabilities:
      drop: [ALL]
    allowPrivilegeEscalation: false
```

### Rollout Behavior

**MaxUnavailable Calculation** (per zone):
```go
{{- define "loki.ingester.maxUnavailable" -}}
{{- ceil (mulf .replicas (divf (int .ctx.Values.ingester.zoneAwareReplication.maxUnavailablePct) 100)) -}}
{{- end -}}
```

**Example**:
- Total replicas: 9
- Per zone: 3
- maxUnavailablePct: 33
- Per zone maxUnavailable: ceil(3 * 0.33) = 1

**Global PDB**: maxUnavailable: 1 (across all zones)

### Rollout Sequence

With rollout operator:
1. Updates zone-a (respects zone maxUnavailable=1)
2. Waits for zone-a ready
3. Updates zone-b (respects zone maxUnavailable=1)
4. Waits for zone-b ready
5. Updates zone-c (respects zone maxUnavailable=1)

Without rollout operator:
- All zones update simultaneously (respects global PDB only)
- Risk of data unavailability if multiple zones updating

---

## Integration Patterns

### MinIO + Loki Integration

**Auto-Detection** in `loki.commonStorageConfig`:
```go
{{- if .Values.minio.enabled -}}
s3:
  endpoint: {{ include "loki.minio" $ }}
  bucketnames: chunks
  secret_access_key: {{ $.Values.minio.rootPassword }}
  access_key_id: {{ $.Values.minio.rootUser }}
  s3forcepathstyle: true
  insecure: true
{{- end }}
```

**Note**: Uses first user's credentials for Loki, not rootUser/rootPassword

### Memcached + Loki Integration

**Chunks Cache**:
- Configured in `chunk_store_config.chunk_cache_config`
- Address injected from chunksCache.addresses
- Write-back caching reduces object storage writes

**Results Cache**:
- Configured in `query_range.results_cache`
- Caches query results for `defaultValidity` period
- Reduces query execution load

**Template Coordination**:
1. Memcached StatefulSet created if memcached.enabled
2. Service created for DNS resolution
3. Loki config includes memcached_client.addresses
4. Loki connects to memcached via service DNS

### Grafana Agent + Loki Integration

**Flow**:
```
Loki Pods (logs) 
  → PodLogs (scrape config)
  → GrafanaAgent (collection)
  → LogsInstance (routing)
  → Loki Write Service (ingestion)
```

**Configuration Coordination**:
1. PodLogs defines what to scrape (all Loki pods)
2. LogsInstance defines where to send (Loki write/gateway)
3. GrafanaAgent discovers PodLogs and LogsInstance via selectors
4. Agent scrapes pods, applies relabelings, sends to Loki

**Authentication**:
- Enterprise: Uses provisioned self-monitoring tenant secret
- OSS with auth: Uses tenantId from selfMonitoring.tenant.name

### Rollout Operator + Ingester Integration

**Coordination**:
1. Ingester StatefulSets labeled with `rollout-group: ingester`
2. Annotated with `rollout-max-unavailable: "X"`
3. Rollout operator watches these StatefulSets
4. Operator controls update rollout based on annotations
5. PDB prevents excessive simultaneous updates

**Without Operator**:
- StatefulSets update per K8s rolling update rules
- PDB provides only safety (maxUnavailable check)
- No cross-zone coordination

---

## Subchart Dependencies

### Chart.yaml Dependencies

```yaml
dependencies:
  - name: minio
    alias: minio
    version: 5.4.0
    repository: https://charts.min.io/
    condition: minio.enabled
  
  - name: grafana-agent-operator
    alias: grafana-agent-operator
    version: 0.5.1
    repository: https://grafana.github.io/helm-charts
    condition: monitoring.selfMonitoring.grafanaAgent.installOperator
  
  - name: rollout-operator
    alias: rollout_operator
    repository: https://grafana.github.io/helm-charts
    version: 0.32.0
    condition: rollout_operator.enabled
```

### Updating Dependencies

```bash
helm dependency update production/helm/loki/
```

**Creates**:
- `Chart.lock` - Locked versions
- `charts/*.tgz` - Downloaded chart archives

### Subchart Values

Passed to subcharts via values.yaml sections:

**MinIO**: `minio.*` → MinIO chart  
**Grafana Agent Operator**: `grafana-agent-operator.*` → Not exposed (uses defaults)  
**Rollout Operator**: `rollout_operator.*` → Rollout operator chart

---

## Configuration Coordination Examples

### Example 1: Full Self-Monitoring Stack

```yaml
# Enable MinIO for local storage
minio:
  enabled: true
  persistence:
    size: 50Gi

# Configure Loki for MinIO
loki:
  auth_enabled: true
  storage:
    type: s3
    bucketNames:
      chunks: chunks
      ruler: ruler
      admin: admin

# Enable self-monitoring
monitoring:
  selfMonitoring:
    enabled: true
    tenant:
      name: self-monitoring
      password: monitoring-secret
    grafanaAgent:
      installOperator: true
  
  # Enable metrics monitoring
  serviceMonitor:
    enabled: true
    labels:
      release: prometheus
    metricsInstance:
      enabled: true
      remoteWrite:
        - url: http://prometheus:9090/api/v1/write

# Enable dashboards
monitoring:
  dashboards:
    enabled: true
    labels:
      grafana_dashboard: "1"

# Enable rules
monitoring:
  rules:
    enabled: true
    alerting: true
```

**Result**:
- Loki uses MinIO for storage
- Grafana Agent scrapes Loki logs
- Logs sent back to Loki (self-monitoring tenant)
- Metrics sent to Prometheus
- Dashboards available in Grafana
- Alert rules in Prometheus

### Example 2: Zone-Aware with Rollout Operator

```yaml
# Enable rollout operator
rollout_operator:
  enabled: true

# Configure zone-aware ingesters
ingester:
  replicas: 9  # 3 per zone
  zoneAwareReplication:
    enabled: true
    maxUnavailablePct: 33
    zoneA:
      nodeSelector:
        topology.kubernetes.io/zone: us-west-2a
    zoneB:
      nodeSelector:
        topology.kubernetes.io/zone: us-west-2b
    zoneC:
      nodeSelector:
        topology.kubernetes.io/zone: us-west-2c
  
  persistence:
    enabled: true
    claims:
      - name: data
        size: 100Gi
        accessModes: [ReadWriteOnce]
  
  resources:
    requests:
      cpu: 4
      memory: 16Gi
```

**Result**:
- 3 StatefulSets created (zone-a, zone-b, zone-c)
- Each with 3 replicas
- Each labeled for rollout-operator control
- Rollout operator manages updates sequentially per zone

### Example 3: External Services

```yaml
# Use external memcached
memcached:
  enabled: false

chunksCache:
  enabled: true
  addresses: external-memcached.cache-ns.svc:11211
  allocatedMemory: 8192  # Match external memcached -m value

resultsCache:
  enabled: true
  addresses: external-results-cache.cache-ns.svc:11211

# Use external object storage (AWS S3)
minio:
  enabled: false

loki:
  storage:
    type: s3
    bucketNames:
      chunks: production-chunks
      ruler: production-ruler
    s3:
      region: us-east-1
      # IRSA authentication via service account

serviceAccount:
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT:role/loki

# No Grafana Agent operator
monitoring:
  selfMonitoring:
    enabled: false
```

---

## Troubleshooting Third-Party Integrations

### MinIO Connection Issues

**Check 1**: Service DNS resolution
```bash
kubectl exec -it loki-write-0 -n loki -- nslookup loki-minio
```

**Check 2**: MinIO health
```bash
kubectl port-forward svc/loki-minio 9000:9000 -n loki
curl http://localhost:9000/minio/health/live
```

**Check 3**: Credentials
```bash
kubectl get secret loki-minio -o yaml
```

### Memcached Connection Issues

**Check 1**: Service exists
```bash
kubectl get svc -l app.kubernetes.io/component=memcached-chunks-cache -n loki
```

**Check 2**: Pods running
```bash
kubectl get pods -l app.kubernetes.io/component=memcached-chunks-cache -n loki
```

**Check 3**: Test connection
```bash
kubectl exec -it loki-write-0 -n loki -- nc -zv loki-chunks-cache 11211
```

**Check 4**: Check Loki logs for memcached errors
```bash
kubectl logs loki-write-0 -n loki | grep -i memcached
```

### Grafana Agent Issues

**Check 1**: Operator installed
```bash
kubectl get deployment grafana-agent-operator -n loki
```

**Check 2**: CRDs exist
```bash
kubectl get crd grafanaagents.monitoring.grafana.com
kubectl get crd podlogs.monitoring.grafana.com
kubectl get crd logsinstances.monitoring.grafana.com
```

**Check 3**: GrafanaAgent status
```bash
kubectl get grafanaagent loki -n loki -o yaml
```

**Check 4**: Check agent pods
```bash
kubectl get pods -l app.kubernetes.io/name=grafana-agent -n loki
kubectl logs <grafana-agent-pod> -n loki
```

### Rollout Operator Issues

**Check 1**: Operator running
```bash
kubectl get deployment loki-rollout-operator -n loki
```

**Check 2**: Check ingester StatefulSets have labels
```bash
kubectl get sts -l rollout-group=ingester -n loki
```

**Check 3**: Check annotations
```bash
kubectl get sts loki-ingester-zone-a -o yaml | grep rollout-max-unavailable
```

**Check 4**: Operator logs
```bash
kubectl logs -l app.kubernetes.io/name=rollout-operator -n loki
```

---

## Next Steps

- For example configurations, see **[Examples & Best Practices](./loki-helm-examples.mdc)**
- For version changes affecting third-party integrations, see **[Changelog Insights](./loki-helm-changelog.mdc)**
- For modification patterns, see **[Modification Guide](./loki-helm-modification-guide.mdc)**
