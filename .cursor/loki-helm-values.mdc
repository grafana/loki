---
alwaysApply: false
---
### 3. Individual Configuration Sections (Recommended)

**Purpose**: Override specific Loki config sections  
**Use When**: Normal operations, specific feature configuration  
**Benefits**: Chart maintains other sections, easier upgrades

Available sections:
- `loki.auth_enabled`
- `loki.server`
- `loki.memberlistConfig` or `loki.extraMemberlistConfig`
- `loki.commonConfig`
- `loki.limits_config`
- `loki.ingester`
- `loki.ingester_client`
- `loki.distributor`
- `loki.querier`
- `loki.query_range`
- `loki.frontend`
- `loki.frontend_worker`
- `loki.query_scheduler`
- `loki.compactor`
- `loki.compactor_grpc_client`
- `loki.index_gateway`
- `loki.pattern_ingester`
- `loki.block_builder`
- `loki.bloom_build`
- `loki.bloom_gateway`
- `loki.storage_config`
- `loki.schemaConfig`
- `loki.rulerConfig`
- `loki.operational_config`
- `loki.analytics`
- `loki.tracing`
- `loki.ui`

**Example**:
```yaml
loki:
  auth_enabled: true
  limits_config:
    max_query_length: 30d
    max_streams_per_user: 0
    retention_period: 744h
  querier:
    max_concurrent: 8
  storage_config:
    boltdb_shipper:
      shared_store: s3
      cache_ttl: 24h
```

**Template Injection**: Each section is injected via `{{- with .Values.loki.[section] }}` blocks in `templates/config.yaml`

---

### 4. External Configuration

**Purpose**: Config provided by external process  
**Use When**: GitOps, external secret management, config pre-processing

```yaml
loki:
  generatedConfigObjectName: ""  # Disable chart config generation
  configObjectName: my-external-config-secret
  configStorageType: Secret
```

**Workflow**:
1. External process creates Secret/ConfigMap named `my-external-config-secret`
2. Chart skips config generation
3. Pods mount external config

---

## Storage Configuration Patterns

### Object Storage Types

Supported: `s3`, `gcs`, `azure`, `swift`, `alibabacloud`, `cos`, `bos`, `filesystem`

**Detection Helper**:
```go
{{- define "loki.isUsingObjectStorage" -}}
{{- has .Values.loki.storage.type (list "s3" "gcs" "azure" "swift" "alibabacloud" "cos" "bos") }}
{{- end -}}
```

### S3 Configuration

```yaml
loki:
  storage:
    type: s3
    bucketNames:
      chunks: my-chunks-bucket
      ruler: my-ruler-bucket
      admin: my-admin-bucket  # GEL only
    s3:
      endpoint: s3.amazonaws.com
      region: us-east-1
      secretAccessKey: null  # Use IRSA/Workload Identity instead
      accessKeyId: null
      s3ForcePathStyle: false
      insecure: false
      signatureVersion: v4
      disable_dualstack: false
      http_config:
        idle_conn_timeout: 90s
        response_header_timeout: 0s
        insecure_skip_verify: false
        tls_config:
          ca_file: ""
          cert_file: ""
          key_file: ""
      backoff_config:
        min_period: 100ms
        max_period: 10s
        max_retries: 10
      sse:
        type: ""  # SSE-S3, SSE-KMS, or SSE-C
        kms_key_id: ""
        kms_encryption_context: ""
```

**AWS IRSA Example**:
```yaml
serviceAccount:
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT:role/loki-role

loki:
  storage:
    type: s3
    bucketNames:
      chunks: loki-chunks
      ruler: loki-ruler
    s3:
      region: us-west-2
      # No credentials needed with IRSA
```

### GCS Configuration

```yaml
loki:
  storage:
    type: gcs
    bucketNames:
      chunks: my-gcs-bucket
      ruler: my-gcs-bucket
    gcs:
      bucket_name: my-gcs-bucket  # Overridden by bucketNames
      chunkBufferSize: 0
      requestTimeout: "0s"
      enableHttp2: true

# Mount service account JSON via extraEnv/extraVolumes
write:
  extraEnv:
    - name: GOOGLE_APPLICATION_CREDENTIALS
      value: /etc/gcs/sa.json
  extraVolumes:
    - name: gcs-sa
      secret:
        secretName: gcs-service-account
  extraVolumeMounts:
    - name: gcs-sa
      mountPath: /etc/gcs
```

### Azure Configuration

```yaml
loki:
  storage:
    type: azure
    bucketNames:
      chunks: loki-chunks
      ruler: loki-ruler
    azure:
      accountName: mystorageaccount
      accountKey: base64key  # Or use connectionString
      connectionString: null
      useManagedIdentity: false
      useFederatedToken: false
      userAssignedId: null
      requestTimeout: 30s
      endpointSuffix: core.windows.net
      chunkDelimiter: null
```

### Filesystem Configuration (SingleBinary Only)

```yaml
loki:
  storage:
    type: filesystem  # Implicit if not s3/gcs/azure/etc
    filesystem:
      chunks_directory: /var/loki/chunks
      rules_directory: /var/loki/rules

singleBinary:
  replicas: 1  # Must be 1 with filesystem
  persistence:
    enabled: true
    size: 50Gi
```

### Thanos Object Store Configuration

**Purpose**: Use Thanos-style object store config (future default)  
**Benefits**: Consistent with Thanos, supports all storage types

```yaml
loki:
  storage:
    use_thanos_objstore: true
    object_store:
      type: s3  # or gcs, azure
      storage_prefix: loki/
      s3:
        bucket_name: my-bucket  # Set by bucketNames helper
        endpoint: s3.amazonaws.com
        region: us-east-1
        access_key_id: ""
        secret_access_key: ""
        insecure: false
        sse:
          type: SSE-KMS
          kms_key_id: alias/my-key
        http:
          tls_config:
            insecure_skip_verify: false
      gcs:
        bucket_name: my-bucket
        service_account: /path/to/sa.json
      azure:
        account_name: myaccount
        account_key: mykey
        container_name: my-container
    bucketNames:
      chunks: my-bucket
      ruler: my-bucket
      admin: my-bucket
```

**Template Helper**: `loki.thanosStorageConfig` in `templates/_helpers.tpl`

**Ruler Storage**: Uses `loki.rulerThanosStorageConfig` if Thanos enabled

---

## Schema Configuration

### Required Configuration

```yaml
loki:
  schemaConfig:
    configs:
      - from: 2024-04-01
        store: tsdb  # or boltdb-shipper (deprecated)
        object_store: s3  # Must match storage.type
        schema: v13  # v12, v13
        index:
          prefix: loki_index_
          period: 24h  # or 168h (weekly)
```

**Validation**: Chart fails if no schema_config provided and useTestSchema=false

### Test Schema (Development Only)

```yaml
loki:
  useTestSchema: true  # Uses built-in test schema
```

**Generated Schema**:
```yaml
schema_config:
  configs:
    - from: 2024-04-01
      store: tsdb
      object_store: '{{ include "loki.testSchemaObjectStore" . }}'  # s3 if minio, else filesystem
      schema: v13
      index:
        prefix: index_
        period: 24h
```

**⚠️ Warning**: Not for production, no data persistence guarantees

### Multiple Schemas (Migration)

```yaml
loki:
  schemaConfig:
    configs:
      - from: 2020-10-24
        store: boltdb-shipper
        object_store: s3
        schema: v11
        index:
          prefix: index_
          period: 24h
      - from: 2024-04-01
        store: tsdb
        object_store: s3
        schema: v13
        index:
          prefix: loki_index_
          period: 24h
```

---

## Common Configuration (common: {})

### Purpose

Shared configuration for all Loki components:
- path_prefix
- replication_factor
- compactor_address or compactor_grpc_address
- storage (auto-generated from loki.storage)

### Default Values

```yaml
loki:
  commonConfig:
    path_prefix: /var/loki
    replication_factor: 3  # 1 for SingleBinary
    compactor_grpc_address: '{{ include "loki.compactorAddress" . }}'
```

### Storage Auto-Injection

Template automatically adds storage section:
```yaml
common:
  {{- toYaml .Values.loki.commonConfig | nindent 2}}
  storage:
    {{- include "loki.commonStorageConfig" . | nindent 4}}
```

**Helper Logic** (`loki.commonStorageConfig`):
1. If use_thanos_objstore: Use `loki.thanosStorageConfig`
2. Else if minio.enabled: Generate minio S3 config
3. Else if objectStorage: Use `loki.lokiStorageConfig`
4. Else: Use filesystem config

---

## Limits Configuration

### Common Limits

```yaml
loki:
  limits_config:
    # Ingestion limits
    ingestion_rate_mb: 10
    ingestion_burst_size_mb: 20
    max_line_size: 256KB
    max_line_size_truncate: false
    
    # Query limits
    max_query_length: 721h  # ~30 days
    max_query_lookback: 0  # No limit
    max_query_parallelism: 32
    max_query_series: 500
    query_timeout: 300s
    
    # Retention
    retention_period: 744h  # 31 days
    
    # Streams
    max_streams_per_user: 0  # No limit
    max_global_streams_per_user: 0
    
    # Chunks
    max_chunks_per_query: 2000000
    max_cache_freshness_per_query: 10m
    
    # Query splitting
    split_queries_by_interval: 15m
    align_queries_with_step: true
    
    # Deletion
    deletion_mode: filter-and-delete
    
    # Volume API
    volume_enabled: true
```

### Runtime Overrides

Per-tenant limits via runtime config:

```yaml
loki:
  runtimeConfig:
    overrides:
      tenant-1:
        ingestion_rate_mb: 50
        max_streams_per_user: 100000
      tenant-2:
        ingestion_rate_mb: 5
```

**Benefits**: Reloadable without pod restart  
**File**: `/etc/loki/runtime-config/runtime-config.yaml`

---

## Storage Configuration Deep Dive

### Bucket Names

```yaml
loki:
  storage:
    bucketNames:
      chunks: loki-chunks     # Required
      ruler: loki-ruler       # Required if ruler enabled (non-local storage)
      admin: loki-admin       # Required if enterprise.adminApi.enabled
```

**Validation**: Chart fails if:
- chunks bucket missing when using object storage
- ruler bucket missing when ruler enabled + object storage
- admin bucket missing when GEL admin API enabled

**Exception**: Not required if minio.enabled (auto-configured)

### S3 Advanced Configuration

```yaml
loki:
  storage:
    type: s3
    s3:
      # Core config
      s3: https  # URL scheme override
      endpoint: custom-s3-endpoint.com
      region: us-west-2
      
      # Authentication (prefer IRSA/Workload Identity)
      accessKeyId: null
      secretAccessKey: null
      
      # Behavior
      s3ForcePathStyle: true  # For MinIO compatibility
      insecure: false
      signatureVersion: v4
      disable_dualstack: true  # Disable IPv6 endpoints
      
      # HTTP client config
      http_config:
        idle_conn_timeout: 90s
        response_header_timeout: 2m
        insecure_skip_verify: false
        tls_config:
          ca_file: /path/to/ca.crt
          cert_file: /path/to/cert.crt
          key_file: /path/to/key.pem
          server_name: s3.example.com
          insecure_skip_verify: false
      
      # Retry configuration
      backoff_config:
        min_period: 100ms
        max_period: 10s
        max_retries: 10
      
      # Server-side encryption
      sse:
        type: SSE-KMS
        kms_key_id: arn:aws:kms:region:account:key/id
        kms_encryption_context: '{"key": "value"}'
```

### GCS with Workload Identity

```yaml
serviceAccount:
  annotations:
    iam.gke.io/gcp-service-account: loki@project.iam.gserviceaccount.com

loki:
  storage:
    type: gcs
    bucketNames:
      chunks: loki-chunks
      ruler: loki-ruler
    gcs:
      chunkBufferSize: 10485760  # 10MB
      requestTimeout: 2m
      enableHttp2: true
```

### Azure with Managed Identity

```yaml
loki:
  storage:
    type: azure
    bucketNames:
      chunks: loki-chunks
    azure:
      accountName: mystorageaccount
      useManagedIdentity: true
      userAssignedId: /subscriptions/ID/resourceGroups/RG/providers/Microsoft.ManagedIdentity/userAssignedIdentities/loki-identity
      endpointSuffix: core.windows.net
      requestTimeout: 30s
      chunkDelimiter: "\n"
```

---

## Memcached Configuration

### Chunks Cache (L1)

```yaml
chunksCache:
  enabled: true
  replicas: 3
  allocatedMemory: 8192  # MB, memcached -m value
  maxItemMemory: 5  # MB, memcached -I value
  connectionLimit: 16384  # memcached -c value
  
  # Cache behavior
  defaultValidity: 0s  # No expiration
  batchSize: 4  # Concurrent requests
  parallelism: 5  # Request threads
  timeout: 2000ms
  
  # Write-back settings
  writebackSizeLimit: 500MB
  writebackBuffer: 500000
  writebackParallelism: 1
  
  # Persistence (ephemeral by default)
  persistence:
    enabled: false
    storageSize: 10G
    storageClass: null
    mountPath: /data
    labels: {}
  
  # External memcached
  addresses: dnssrvnoa+_memcached-client._tcp.loki-chunks-cache.ns.svc
  
  # Customization
  port: 11211
  suffix: ""  # Append to resource names
  extraExtendedOptions: ""  # Additional memcached -o flags
  extraArgs: {}
```

### L2 Chunks Cache

```yaml
chunksCache:
  l2:
    enabled: true
    suffix: "l2"
    l2ChunkCacheHandoff: 345600s  # 4 days
    allocatedMemory: 16384
    # ... same options as L1
```

**Handoff**: Chunks older than `l2ChunkCacheHandoff` move from L1 → L2

### Results Cache

```yaml
resultsCache:
  enabled: true
  replicas: 1
  allocatedMemory: 1024
  defaultValidity: 12h  # Cache query results for 12h
  timeout: 500ms
  # ... similar options to chunks cache
```

### External Memcached Cluster

```yaml
memcached:
  enabled: false  # Disable chart-managed memcached

chunksCache:
  enabled: true
  addresses: my-external-memcached.namespace.svc:11211

resultsCache:
  enabled: true
  addresses: my-external-results-cache.namespace.svc:11211
```

**Note**: Chart will not create memcached StatefulSets if memcached.enabled=false

---

## Component-Specific Values Structure

Each component follows a consistent pattern:

```yaml
[component]:
  # Scaling
  replicas: 3
  autoscaling:
    enabled: false
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 60
    targetMemoryUtilizationPercentage: null
    customMetrics: []
    behavior:
      enabled: false
      scaleUp: {}
      scaleDown: {}
  
  # Image override
  image:
    registry: null
    repository: null
    tag: null
    digest: null
  
  # Command override
  command: null
  
  # Kubernetes config
  priorityClassName: null
  hostUsers: nil
  
  # Labels & annotations
  labels: {}
  podLabels: {}
  podAnnotations: {}
  annotations: {}  # For Deployment/StatefulSet
  selectorLabels: {}  # Additional selector labels
  
  # Service
  service:
    type: ClusterIP
    annotations: {}
    labels: {}
  serviceLabels: {}
  serviceAnnotations: {}
  serviceType: ClusterIP
  
  # Target module
  targetModule: "[component]"
  
  # CLI & env
  extraArgs: []
  extraEnv: []
  extraEnvFrom: []
  
  # Containers
  initContainers: []
  extraContainers: []
  
  # Volumes
  extraVolumes: []
  extraVolumeMounts: []
  
  # Resources
  resources: {}
  
  # Lifecycle
  lifecycle: {}
  terminationGracePeriodSeconds: 30
  
  # Scheduling
  nodeSelector: {}
  affinity: {}
  topologySpreadConstraints: []
  tolerations: []
  dnsConfig: {}
  hostAliases: []
  
  # Probes (if applicable)
  livenessProbe: {}
  readinessProbe: {}
  startupProbe: {}
  
  # Persistence (if StatefulSet)
  persistence:
    enabled: false
    size: 10Gi
    storageClass: null
    accessModes: [ReadWriteOnce]
    selector: null
    annotations: {}
    labels: {}
    
  # PDB
  maxUnavailable: null
  
  # Update strategy (if StatefulSet)
  updateStrategy:
    type: RollingUpdate
  
  # Pod management (if StatefulSet)
  podManagementPolicy: Parallel
```

---

## Global Values

### global.* - Cross-Component Settings

```yaml
global:
  image:
    registry: docker.io  # Override all image registries
  priorityClassName: high-priority  # Apply to all components
  clusterDomain: cluster.local
  dnsService: kube-dns
  dnsNamespace: kube-system
  
  # Applied to all components
  extraArgs: []
  extraEnv: []
  extraEnvFrom: []
  extraVolumes: []
  extraVolumeMounts: []
  
  # Pod-level annotations (memcached only)
  podAnnotations: {}
```

**Merging**: Global values concatenated with component-specific via `concat .Values.global.extraEnv .Values.[component].extraEnv | uniq`

---

## loki.* - Core Loki Configuration

### Server Configuration

```yaml
loki:
  server:
    http_listen_port: 3100
    grpc_listen_port: 9095
    http_server_read_timeout: 600s
    http_server_write_timeout: 600s
    grpc_server_max_recv_msg_size: 104857600  # 100MB
    grpc_server_max_send_msg_size: 104857600
    log_level: info
    log_format: logfmt  # or json
```

**Used By**: All components, injected into config via `{{- with .Values.loki.server }}`

### Memberlist Configuration

**Auto-Generated** (default):
```yaml
loki:
  extraMemberlistConfig: {}
```

Generates:
```yaml
memberlist:
  join_members:
    - loki-memberlist
```

**Custom Memberlist** (full override):
```yaml
loki:
  memberlistConfig:
    node_name: '{{ include "loki.fullname" . }}'
    bind_addr: ['0.0.0.0']
    bind_port: 7946
    join_members: ['loki-memberlist']
    dead_node_reclaim_time: 30s
    gossip_interval: 1s
    gossip_nodes: 3
```

### Ingester Configuration

```yaml
loki:
  ingester:
    chunk_encoding: snappy  # gzip, lz4, snappy, none, zstd
    chunk_idle_period: 30m
    chunk_retain_period: 15m
    chunk_target_size: 1572864  # 1.5MB
    max_chunk_age: 2h
    max_transfer_retries: 0
    wal:
      enabled: true
      dir: /var/loki/wal
      checkpoint_duration: 5m
      flush_on_shutdown: true
      replay_memory_ceiling: 4GB
```

### Query Configuration

```yaml
loki:
  querier:
    max_concurrent: 4
    query_timeout: 5m
    tail_max_duration: 1h
    extra_query_delay: 0s
    query_ingesters_within: 3h
    engine:
      timeout: 5m
      max_look_back_period: 30s
  
  query_range:
    align_queries_with_step: true
    cache_results: true  # If resultsCache.enabled
    max_retries: 5
    parallelise_shardable_queries: true
    cache_index_stats_results: true
  
  frontend:
    log_queries_longer_than: 10s
    compress_responses: true
    max_outstanding_per_tenant: 256
    scheduler_address: '{{ include "loki.querySchedulerAddress" . }}'
    tail_proxy_url: '{{ include "loki.querierAddress" . }}'
  
  frontend_worker:
    frontend_address: ""  # Leave empty to use scheduler
    scheduler_address: '{{ include "loki.querySchedulerAddress" . }}'
    parallelism: 10
    match_max_concurrent: true
```

### Distributor Configuration

```yaml
loki:
  distributor:
    ring:
      kvstore:
        store: memberlist
```

### Compactor Configuration

```yaml
loki:
  compactor:
    working_directory: /var/loki/compactor
    compaction_interval: 10m
    retention_enabled: false
    retention_delete_delay: 2h
    retention_delete_worker_count: 150
    delete_request_store: s3
```

### Storage Config

```yaml
loki:
  storage_config:
    boltdb_shipper:  # Deprecated, use tsdb
      active_index_directory: /var/loki/index
      cache_location: /var/loki/cache
      cache_ttl: 24h
      shared_store: s3
      index_gateway_client:
        server_address: '{{ include "loki.indexGatewayAddress" . }}'
    
    tsdb_shipper:
      active_index_directory: /var/loki/tsdb-index
      cache_location: /var/loki/tsdb-cache
      cache_ttl: 24h
      shared_store: s3
      index_gateway_client:
        server_address: '{{ include "loki.indexGatewayAddress" . }}'
    
    bloom_shipper:
      working_directory: /var/loki/data/bloomshipper
      blocks_downloading_queue:
        workers_count: 4
    
    hedging:
      at: 250ms
      max_per_second: 20
      up_to: 3
    
    # Thanos config
    use_thanos_objstore: false  # Chart sets from loki.storage.use_thanos_objstore
```

### Ruler Configuration

```yaml
loki:
  rulerConfig:
    storage:
      type: local  # or s3, gcs, azure (auto-configured if not specified)
      local:
        directory: /etc/loki/rules
    
    wal:
      dir: /var/loki/ruler-wal
      truncate_frequency: 60m
      min_age: 5m
      max_age: 4h
    
    rule_path: /tmp/rules
    alertmanager_url: http://alertmanager:9093
    enable_api: true
    enable_sharding: true
    ring:
      kvstore:
        store: memberlist
    
    remote_write:
      enabled: true
      clients:
        default:
          url: http://prometheus:9090/api/v1/write
          headers: {}
```

**Note**: `storage` section auto-generated via `loki.rulerConfig` helper which calls `loki.rulerStorageConfig`

### Pattern Ingester Configuration

```yaml
loki:
  pattern_ingester:
    enabled: true
    metric_aggregation:
      enabled: true
      loki_address: '{{ include "loki.address" . }}'
```

**Requires**: patternIngester.replicas > 0 in Distributed mode

### Bloom Filter Configuration

```yaml
loki:
  bloom_build:
    enabled: true
    builder:
      planner_address: '{{ include "loki.bloomPlannerAddress" . }}'
  
  bloom_gateway:
    enabled: true
    client:
      addresses: '{{ include "loki.bloomGatewayAddresses" . }}'
      cache_results: true
```

**Requires**: bloom components with replicas > 0

### Tracing Configuration

```yaml
loki:
  tracing:
    enabled: true
```

Additional tracing config would go in `loki.config` or `loki.structuredConfig`.

### UI Configuration

```yaml
loki:
  ui:
    enabled: true
    gateway:
      enabled: true  # Proxy /ui through gateway
```

**Access**: http://gateway/ui (if gateway enabled)

**Discovery**: Auto-configured to join query-frontend peers

---

## Enterprise Configuration

### Enterprise Enablement

```yaml
enterprise:
  enabled: true
  version: 3.5.2  # GEL version
  
  # License
  license:
    contents: "ACTUAL_LICENSE_JWT_CONTENT"
  # OR
  useExternalLicense: true
  externalLicenseName: my-license-secret
  
  # Cluster name (must match license)
  cluster_name: production-logs
  
  # Admin API
  adminApi:
    enabled: true
  
  # Gateway
  gelGateway: true  # Use GEL gateway instead of nginx
  
  # Image
  image:
    registry: docker.io
    repository: grafana/enterprise-logs
    tag: 3.5.2
```

### Admin Token Configuration

**Required for Provisioner**:

```bash
# 1. Generate token
kubectl create secret generic loki-admin-token \
  --from-literal=token=$(openssl rand -base64 32) \
  -n loki

# 2. Configure chart
```

```yaml
enterprise:
  adminToken:
    secret: loki-admin-token
```

### Provisioner Configuration

```yaml
enterprise:
  provisioner:
    enabled: true
    hookType: post-install  # When to run
    apiUrl: '{{ include "loki.address" . }}'  # Auto-configured
    additionalTenants:
      - name: tenant-1
        secretNamespace: default  # NOT USED (manual creation)
      - name: app-team
        secretNamespace: app-namespace
```

**Important**: As of 6.36.0:
- Tokens output to logs only
- Manual secret creation required
- No automatic secret creation

### Multi-Tenancy with Auth

```yaml
loki:
  auth_enabled: true
  tenants:
    - name: tenant-1
      password: secret1
    - name: tenant-2
      passwordHash: $2y$10$hash...  # bcrypt hash

gateway:
  enabled: true
  basicAuth:
    enabled: true
    # Uses loki.tenants automatically for htpasswd
```

**htpasswd Generation**: Auto-generates from tenants list or basicAuth.username/password

---

## Gateway Configuration

### Nginx Gateway (Default OSS)

```yaml
gateway:
  enabled: true
  replicas: 1
  
  # Container config
  containerPort: 8080
  verboseLogging: true
  
  # Service
  service:
    type: ClusterIP
    port: 80
    # LoadBalancer options
    loadBalancerIP: null
    # NodePort options
    nodePort: null
  
  # Nginx config
  nginxConfig:
    schema: http  # or https
    enableIPv6: true
    clientMaxBodySize: 4M
    
    # Custom backend URLs
    customReadUrl: null
    customWriteUrl: null
    customBackendUrl: null
    
    # Resolver
    resolver: ""  # Auto: kube-dns.kube-system.svc.cluster.local
    
    # SSL
    ssl: false
    
    # Logging
    logFormat: |-
      main '$remote_addr - $remote_user [$time_local]  $status '
              '"$request" $body_bytes_sent "$http_referer" '
              '"$http_user_agent" "$http_x_forwarded_for"';
    
    # Custom snippets
    httpSnippet: ""  # Injected into http {}
    serverSnippet: ""  # Injected into server {}
    locationSnippet: >-  # Injected into every location {}
      {{ if .Values.loki.tenants }}proxy_set_header X-Scope-OrgID $remote_user;{{ end }}
    
    # Complete override
    file: |
      {{- include "loki.nginxFile" . -}}
  
  # Basic auth
  basicAuth:
    enabled: false
    username: admin
    password: secret
    existingSecret: null
    htpasswd: |  # Auto-generated from tenants or username/password
      # ...
  
  # Ingress
  ingress:
    enabled: false
    ingressClassName: nginx
    annotations: {}
    labels: {}
    hosts:
      - host: loki.example.com
        paths:
          - path: /
            pathType: Prefix
    tls:
      - secretName: loki-tls
        hosts: [loki.example.com]
```

### GEL Gateway (Enterprise)

```yaml
enterprise:
  enabled: true
  gelGateway: true  # Use GEL gateway

enterpriseGateway:
  replicas: 1
  useDefaultProxyURLs: true  # Auto-configure proxy URLs
  
  # Manual proxy URLs (if useDefaultProxyURLs: false)
  extraArgs:
    gateway.proxy.default.url: http://custom-backend:3100
    gateway.proxy.distributor.url: dns:///loki-distributor:9095
```

**Auto-Configured Proxy URLs** (Distributed):
- default: admin-api
- admin-api: admin-api
- distributor: distributor-headless (dns:///)
- ingester: ingester
- query-frontend: query-frontend
- ruler: ruler

**Auto-Configured Proxy URLs** (SimpleScalable):
- default: backend
- admin-api: backend
- distributor: write-headless (dns:///)
- ingester: write
- query-frontend: read
- ruler: backend-headless
- query-scheduler: backend-headless
- compactor: backend-headless

---

## Monitoring & Observability Configuration

### ServiceMonitor

```yaml
monitoring:
  serviceMonitor:
    enabled: false
    labels:
      release: prometheus  # Match Prometheus operator release
    namespaceSelector: {}
    annotations: {}
    interval: 15s
    scrapeTimeout: null
    relabelings: []
    metricRelabelings: []
    scheme: http
    tlsConfig: null
```

**Selector**: Automatically finds all Loki services except those with `prometheus.io/service-monitor: "false"` label

### Recording Rules

```yaml
monitoring:
  rules:
    enabled: false
    alerting: true
    namespace: null  # Deploy to different namespace
    labels: {}
    annotations: {}
    additionalRuleLabels: {}  # Labels for all alert rules
    additionalGroups: []  # Custom recording rule groups
    
    # Disable specific alerts
    disabled:
      LokiRequestErrors: false
      LokiRequestPanics: false
      LokiRequestLatency: false
      LokiTooManyCompactorsRunning: false
      LokiCanaryLatency: false
```

### Dashboards

```yaml
monitoring:
  dashboards:
    enabled: false
    namespace: null  # Deploy to Grafana namespace
    labels:
      grafana_dashboard: "1"
    annotations:
      grafana_folder: Loki
```

**Dashboards Included**:
- loki-chunks, loki-deletion, loki-logs, loki-operational, loki-mixin-recording-rules
- loki-reads, loki-reads-resources, loki-retention, loki-writes, loki-writes-resources

### Self-Monitoring (Grafana Agent)

```yaml
monitoring:
  selfMonitoring:
    enabled: false
    tenant:
      name: self-monitoring
      password: secret
      secretNamespace: '{{ include "loki.namespace" . }}'
    
    grafanaAgent:
      installOperator: false  # Install Grafana Agent Operator
      enableConfigReadAPI: false
      priorityClassName: null
      resources: {}
      tolerations: []
    
    podLogs:
      apiVersion: monitoring.grafana.com/v1alpha1
      annotations: {}
      labels: {}
      relabelings: []
      additionalPipelineStages: []
    
    logsInstance:
      annotations: {}
      labels: {}
      clients: null  # Additional remote write targets
  
  serviceMonitor:
    metricsInstance:
      enabled: true
      annotations: {}
      labels: {}
      remoteWrite: null  # Remote write metrics
```

---

## MinIO Subchart Configuration

```yaml
minio:
  enabled: false  # Enable for local testing
  replicas: 1
  drivesPerNode: 2  # Required for erasure coding
  
  # Authentication
  rootUser: root-user
  rootPassword: supersecret
  
  # Loki user (first user is used for Loki)
  users:
    - accessKey: loki
      secretKey: supersecret
      policy: readwrite
  
  # Buckets (auto-created)
  buckets:
    - name: chunks
      policy: none
      purge: false
    - name: ruler
      policy: none
      purge: false
    - name: admin
      policy: none
      purge: false
  
  # Persistence
  persistence:
    size: 5Gi
    annotations: {}
  
  # Resources
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
  
  # Override address
  address: null  # Default: {release}-minio.{namespace}.svc:{port}
  
  service:
    port: 9000
```

**Auto-Configuration**: If minio.enabled=true:
- loki.storage config auto-generated for minio
- Bucket names auto-configured
- Credentials auto-injected

---

## RBAC Configuration

```yaml
rbac:
  # Pod Security Policy (deprecated K8s 1.25+)
  pspEnabled: false
  pspAnnotations: {}
  
  # OpenShift Security Context Constraints
  sccEnabled: false
  sccAllowHostDirVolumePlugin: false
  
  # Scope
  namespaced: false  # false = ClusterRole, true = Role
  
  # Existing role
  useExistingRole: null  # Use existing ClusterRole instead of creating
```

---

## Network Policy Configuration

```yaml
networkPolicy:
  enabled: false
  flavor: kubernetes  # or cilium
  
  # Ingress to Loki (gateway or read/write)
  ingress:
    podSelector: {}
    namespaceSelector: {}
  
  # Metrics scraping
  metrics:
    podSelector: {}
    namespaceSelector: {}
    cidrs: []  # IP CIDR blocks
  
  # Alertmanager egress
  alertmanager:
    port: 9093
    podSelector: {}
    namespaceSelector: {}
  
  # External storage egress
  externalStorage:
    ports: [443]  # HTTPS
    cidrs: []  # e.g., AWS S3 CIDR ranges
  
  # Service discovery egress
  discovery:
    port: null
    podSelector: {}
    namespaceSelector: {}
  
  # Cilium-specific
  egressWorld:
    enabled: false  # Allow write/read/backend → world
  egressKubeApiserver:
    enabled: false  # Allow backend → kube-apiserver
```

---

## Sidecar Configuration (Rules)

```yaml
sidecar:
  image:
    repository: kiwigrid/k8s-sidecar
    tag: 1.30.7
    pullPolicy: IfNotPresent
  
  resources: {}
  securityContext:
    readOnlyRootFilesystem: true
    capabilities:
      drop: [ALL]
    allowPrivilegeEscalation: false
  
  skipTlsVerify: false
  enableUniqueFilenames: false
  
  # Probes (disabled by default)
  readinessProbe: {}
  livenessProbe: {}
  startupProbe: {}
  
  rules:
    enabled: true  # Enable rules sidecar
    label: loki_rule  # ConfigMap/Secret label to watch
    labelValue: ""  # Optional label value filter
    folder: /rules  # Mount path
    folderAnnotation: null  # Override folder per ConfigMap
    searchNamespace: null  # Watch all namespaces or specific list
    watchMethod: WATCH  # or SLEEP
    resource: both  # configmap, secret, or both
    script: null  # Script to run after reload
    watchServerTimeout: 60
    watchClientTimeout: 60
    logLevel: INFO
```

**Active In**:
- backend (SimpleScalable)
- ruler (Distributed)
- single-binary

**ConfigMap Example**:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: loki-rules-tenant1
  labels:
    loki_rule: "1"
data:
  tenant1.yaml: |
    groups:
      - name: tenant1-rules
        interval: 1m
        rules:
          - record: tenant1:log_rate
            expr: sum(rate({tenant="tenant1"}[5m]))
```

---

## Persistence Patterns

### StatefulSet with PVC

```yaml
[component]:
  persistence:
    enabled: true
    size: 10Gi
    storageClass: gp3
    accessModes:
      - ReadWriteOnce
    selector:
      matchLabels:
        type: ssd
    annotations:
      volume.beta.kubernetes.io/storage-class: fast
    labels:
      app: loki
```

### Multiple Volume Claims

```yaml
[component]:
  persistence:
    enabled: true
    claims:
      - name: data
        size: 10Gi
        accessModes: [ReadWriteOnce]
        storageClass: gp3
        annotations: {}
        labels: {}
      - name: wal
        size: 150Gi
        accessModes: [ReadWriteOnce]
        storageClass: gp3
```

**Used By**: ingester, compactor, pattern-ingester, bloom-planner, bloom-gateway

### EmptyDir Alternative

```yaml
[component]:
  persistence:
    volumeClaimsEnabled: false
    dataVolumeParameters:
      emptyDir: {}
```

**Use Case**: Ephemeral storage, cost optimization, data not critical

### In-Memory Storage

```yaml
[component]:
  persistence:
    enabled: true
    inMemory: true
    size: 10Gi
```

Generates:
```yaml
emptyDir:
  medium: Memory
  sizeLimit: 10Gi
```

**Use Case**: Ultra-fast index gateway, performance testing  
**Warning**: Data lost on pod restart

### PVC Auto-Delete

```yaml
[component]:
  persistence:
    enableStatefulSetAutoDeletePVC: true
    whenDeleted: Delete  # or Retain
    whenScaled: Delete   # or Retain
```

**K8s 1.23+**: Automatically delete PVCs when StatefulSet scaled down or deleted

**Enabled by Default**: backend, single-binary, read (legacy)  
**Disabled by Default**: ingester, compactor, ruler, index-gateway (retain data)

---

## Autoscaling Configuration

### HPA Configuration Pattern

```yaml
[component]:
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    
    # Standard metrics
    targetCPUUtilizationPercentage: 60
    targetMemoryUtilizationPercentage: 80
    
    # Custom metrics
    customMetrics:
      - type: Pods
        pods:
          metric:
            name: loki_lines_total
          target:
            type: AverageValue
            averageValue: 10000
      
      - type: External
        external:
          metric:
            name: sqs_queue_depth
          target:
            type: AverageValue
            averageValue: 30
    
    # Scaling behavior
    behavior:
      enabled: true
      scaleUp:
        stabilizationWindowSeconds: 300
        policies:
          - type: Pods
            value: 1
            periodSeconds: 60
          - type: Percent
            value: 10
            periodSeconds: 60
      scaleDown:
        stabilizationWindowSeconds: 600
        policies:
          - type: Pods
            value: 1
            periodSeconds: 180
```

**Components Supporting HPA**:
- gateway, singleBinary (if object storage)
- read, write, backend (SimpleScalable)
- distributor, querier, queryFrontend, bloomBuilder (Distributed)

**Ingester HPA**: Special considerations for WAL drain
```yaml
ingester:
  autoscaling:
    behavior:
      scaleDown:
        policies:
          - type: Pods
            value: 1
            periodSeconds: 1800  # 30 min between scale-downs
        stabilizationWindowSeconds: 3600  # 1 hour stabilization
```

---

## Affinity & Scheduling

### Default Pod Anti-Affinity

All components default to hard anti-affinity on hostname:

```yaml
[component]:
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/component: [component]
              app.kubernetes.io/name: '{{ include "loki.name" . }}'
              app.kubernetes.io/instance: '{{ .Release.Name }}'
          topologyKey: kubernetes.io/hostname
```

**Effect**: No two pods of same component on same node

### Soft Anti-Affinity Example

```yaml
[component]:
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchLabels:
                app.kubernetes.io/component: [component]
            topologyKey: kubernetes.io/hostname
```

### Zone Distribution

```yaml
[component]:
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchLabels:
                app.kubernetes.io/component: [component]
            topologyKey: topology.kubernetes.io/zone
```

### Topology Spread Constraints

```yaml
[component]:
  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
      labelSelector:
        matchLabels:
          app.kubernetes.io/component: [component]
    
    - maxSkew: 1
      topologyKey: topology.kubernetes.io/zone
      whenUnsatisfiable: DoNotSchedule
```

**Benefits**: More flexible than affinity, supports maxSkew

**Template Pattern**: Passed through `tpl` for templating support

---

## Security Context Patterns

### Pod Security Context

```yaml
loki:
  podSecurityContext:
    fsGroup: 10001
    runAsGroup: 10001
    runAsNonRoot: true
    runAsUser: 10001
    seccompProfile:
      type: RuntimeDefault
```

### Container Security Context

```yaml
loki:
  containerSecurityContext:
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
    allowPrivilegeEscalation: false
    runAsNonRoot: true
    runAsUser: 10001
    seccompProfile:
      type: RuntimeDefault
```

### Component-Specific Overrides

Some components have specific security contexts:

**Gateway** (nginx):
```yaml
gateway:
  podSecurityContext:
    fsGroup: 101  # nginx user
    runAsGroup: 101
    runAsUser: 101
```

**Memcached**:
```yaml
memcached:
  podSecurityContext:
    fsGroup: 11211
    runAsGroup: 11211
    runAsNonRoot: true
    runAsUser: 11211
```

---

## Multi-Tenancy Configuration

### Option 1: Basic Auth with Gateway

```yaml
loki:
  auth_enabled: true
  tenants:
    - name: tenant-a
      password: secret-a
    - name: tenant-b
      passwordHash: $2y$10$...  # htpasswd -nbBC10 tenant-b secret-b

gateway:
  enabled: true
  basicAuth:
    enabled: true
    # htpasswd auto-generated from loki.tenants
```

**Effect**:
- Gateway enforces basic auth
- Username becomes X-Scope-OrgID header
- Loki receives pre-authenticated requests

### Option 2: Enterprise with Provisioner

```yaml
enterprise:
  enabled: true
  adminToken:
    secret: loki-admin-token
  provisioner:
    enabled: true
    additionalTenants:
      - name: team-a
      - name: team-b

monitoring:
  selfMonitoring:
    tenant:
      name: self-monitoring
```

**Workflow**:
1. Create admin token secret manually
2. Provisioner job creates tenant tokens (outputs to logs)
3. Manually create secrets from provisioner logs
4. Configure Grafana data sources with tokens

### Option 3: External Auth (Ingress)

```yaml
gateway:
  enabled: false

ingress:
  enabled: true
  annotations:
    nginx.ingress.kubernetes.io/auth-type: basic
    nginx.ingress.kubernetes.io/auth-secret: loki-auth
    nginx.ingress.kubernetes.io/configuration-snippet: |
      proxy_set_header X-Scope-OrgID $remote_user;
```

---

## Resource Sizing Patterns

### Small Deployment (SingleBinary)

```yaml
singleBinary:
  replicas: 1
  resources:
    limits:
      cpu: 2
      memory: 4Gi
    requests:
      cpu: 1
      memory: 2Gi
  extraEnv:
    - name: GOMEMLIMIT
      value: 3750MiB  # 90% of memory limit

chunksCache:
  allocatedMemory: 512
  writebackSizeLimit: 10MB
```

### Medium Deployment (SimpleScalable)

```yaml
write:
  replicas: 3
  resources:
    limits:
      cpu: 4
      memory: 8Gi
    requests:
      cpu: 2
      memory: 4Gi

read:
  replicas: 3
  resources:
    limits:
      cpu: 4
      memory: 8Gi
    requests:
      cpu: 2
      memory: 4Gi

backend:
  replicas: 3
  resources:
    limits:
      cpu: 2
      memory: 4Gi
    requests:
      cpu: 1
      memory: 2Gi

chunksCache:
  allocatedMemory: 4096
  replicas: 3
```

### Large Deployment (Distributed)

```yaml
distributor:
  replicas: 3
  resources:
    limits: {cpu: 2, memory: 2Gi}
    requests: {cpu: 1, memory: 1Gi}

ingester:
  replicas: 9  # 3 per zone
  zoneAwareReplication:
    enabled: true
  resources:
    limits: {cpu: 4, memory: 16Gi}
    requests: {cpu: 2, memory: 8Gi}

querier:
  replicas: 6
  resources:
    limits: {cpu: 4, memory: 8Gi}
    requests: {cpu: 2, memory: 4Gi}

queryFrontend:
  replicas: 2
  resources:
    limits: {cpu: 2, memory: 2Gi}
    requests: {cpu: 1, memory: 1Gi}

chunksCache:
  allocatedMemory: 16384
  replicas: 3
```

---

## DNS Configuration

### Custom DNS Config

```yaml
loki:
  dnsConfig:
    options:
      - name: ndots
        value: "3"
      - name: timeout
        value: "2"
      - name: attempts
        value: "2"
    nameservers:
      - 8.8.8.8
    searches:
      - cluster.local
      - svc.cluster.local
```

**Applied To**: All components (overridable per-component)

### Component-Specific DNS

```yaml
ingester:
  dnsConfig:
    options:
      - name: ndots
        value: "4"  # Override global
```

---

## Init Containers Patterns

### Wait for Service

```yaml
backend:
  initContainers:
    - name: wait-for-minio
      image: busybox:1.36
      command:
        - sh
        - -c
        - |
          until nc -z minio 9000; do
            echo "Waiting for MinIO..."
            sleep 2
          done
```

### Schema Initialization

```yaml
backend:
  initContainers:
    - name: init-schema
      image: grafana/loki:3.5.3
      command:
        - sh
        - -c
        - |
          # Run schema migrations
          /usr/bin/loki -config.file=/etc/loki/config/config.yaml -target=table-manager -table-manager.retention-period=0
```

---

## Extra Containers Patterns

### Log Forwarding Sidecar

```yaml
write:
  extraContainers:
    - name: fluent-bit
      image: fluent/fluent-bit:latest
      volumeMounts:
        - name: data
          mountPath: /var/loki
          readOnly: true
```

### Metrics Exporter

```yaml
compactor:
  extraContainers:
    - name: custom-exporter
      image: my-exporter:latest
      ports:
        - name: metrics
          containerPort: 9090
```

---

## Values.yaml Section Reference

### Global Section (lines 7-37)

```yaml
global:
  image:
    registry: null
  priorityClassName: null
  clusterDomain: "cluster.local"
  dnsService: "kube-dns"
  dnsNamespace: "kube-system"
  extraArgs: []
  extraEnv: []
  extraEnvFrom: []
  extraVolumes: []
  extraVolumeMounts: []
```

**Scope**: admin-api, backend, bloom-builder, bloom-gateway, bloom-planner, compactor, distributor, index-gateway, ingester, overrides-exporter, pattern-ingester, querier, query-frontend, query-scheduler, read, ruler, write

### Loki Section (lines 66-614)

**Sub-sections**:
- Image config (78-88)
- Annotations/labels (89-98)
- Security contexts (101-113)
- Configuration (118-549)
- Server (398-402)
- Limits (404-410)
- Runtime config (411-412)
- Common config (413-419)
- Storage (420-520)
- Schema config (521-534)
- Ruler config (539-547)
- Structured config (548-549)
- Component-specific configs (550-614)

### Enterprise Section (lines 621-735)

- Enable flag (624)
- Version (625-626)
- Cluster name (627-629)
- License (630-641)
- External config (642-643)
- GEL gateway flag (644-645)
- Admin API (646-649)
- Enterprise config string (650-661)
- Image (662-672)
- Admin token (673-676)
- Canary secret (677-678)
- Provisioner (679-735)

### Test Section (lines 742-770)

### Loki Canary Section (lines 773-832)

### Service Account Section (lines 839-852)

### RBAC Section (lines 854-868)

### Network Policy Section (lines 874-922)

### Memberlist Section (lines 930-933)

### Component Sections

- **adminApi** (lines 940-1017)
- **gateway** (lines 1030-1248)
- **enterpriseGateway** (lines 1249-1321)
- **ingress** (lines 1322-1396)
- **migrate** (lines 1404-1412)
- **singleBinary** (lines 1422-1520)
- **write** (lines 1530-1663)
- **read** (lines 1664-1790)
- **backend** (lines 1791-1922)
- **ingester** (lines 1924-2132)
- **distributor** (lines 2134-2240)
- **querier** (lines 2242-2355)
- **queryFrontend** (lines 2357-2458)
- **queryScheduler** (lines 2459-2532)
- **indexGateway** (lines 2533-2639)
- **compactor** (lines 2640-2760)
- **bloomGateway** (lines 2762-2874)
- **bloomPlanner** (lines 2876-2988)
- **bloomBuilder** (lines 2990-3088)
- **patternIngester** (lines 3090-3213)
- **ruler** (lines 3215-3375)
- **overridesExporter** (lines 3378-3442)

### Third-Party Sections

- **memcached** (lines 3450-3496)
- **memcachedExporter** (lines 3498-3540)
- **resultsCache** (lines 3542-3646)
- **chunksCache** (lines 3647-3870)
- **rollout_operator** (lines 3876-3899)
- **minio** (lines 3900-3936)

### Other Sections

- **extraObjects** (lines 3938-3969)
- **sidecar** (lines 3971-4039)
- **monitoring** (DEPRECATED, lines 4048-4189)
- **tableManager** (DEPRECATED, lines 4190-4258)

---

## Configuration vs Values Parameters

### Loki Configuration (loki.config / loki.structuredConfig)

**What**: Loki application configuration  
**File**: `/etc/loki/config/config.yaml` in pods  
**Examples**:
- auth_enabled
- server.http_listen_port
- limits_config.max_query_length
- ingester.chunk_target_size
- storage_config.tsdb_shipper

**When to Use**: Changing Loki runtime behavior

### Values Parameters (values.yaml root level)

**What**: Helm chart/Kubernetes configuration  
**Examples**:
- deploymentMode
- replicas
- resources
- nodeSelector
- persistence
- autoscaling

**When to Use**: Changing deployment characteristics

### Hybrid (Under loki.* but affect K8s)

Some values under `loki.*` affect Kubernetes resources:

- `loki.image.*` - Pod container image
- `loki.annotations` - Deployment/StatefulSet annotations
- `loki.podAnnotations` - Pod annotations
- `loki.podLabels` - Pod labels
- `loki.serviceAnnotations` - Service annotations
- `loki.revisionHistoryLimit` - Deployment history

---

## Common Configuration Scenarios

### Scenario 1: High Cardinality Workload

```yaml
loki:
  limits_config:
    max_streams_per_user: 0  # Remove limit
    max_global_streams_per_user: 0
    max_label_names_per_series: 30
    max_label_value_length: 2048
  
  ingester:
    chunk_target_size: 2097152  # 2MB (larger chunks)
    max_chunk_age: 4h  # Hold chunks longer
  
  querier:
    max_concurrent: 8  # More parallelism
    query_ingesters_within: 6h  # Query ingesters for longer

chunksCache:
  allocatedMemory: 16384  # Larger cache
```

### Scenario 2: Long Retention

```yaml
loki:
  limits_config:
    retention_period: 2160h  # 90 days
    max_query_length: 2160h
  
  compactor:
    retention_enabled: true
    retention_delete_delay: 2h
    retention_delete_worker_count: 150

compactor:
  resources:
    requests:
      cpu: 2
      memory: 4Gi  # Compactor needs memory for retention
```

### Scenario 3: High Query Load

```yaml
querier:
  replicas: 6
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 12
    targetCPUUtilizationPercentage: 70
  resources:
    requests:
      cpu: 2
      memory: 4Gi

queryFrontend:
  replicas: 3

loki:
  query_range:
    parallelise_shardable_queries: true
    cache_results: true
  querier:
    max_concurrent: 8

resultsCache:
  enabled: true
  allocatedMemory: 4096
  replicas: 3
```

### Scenario 4: High Ingestion Rate

```yaml
distributor:
  replicas: 5
  autoscaling:
    enabled: true
    minReplicas: 3
    maxReplicas: 10

ingester:
  replicas: 9  # 3 per zone
  zoneAwareReplication:
    enabled: true
  resources:
    requests:
      cpu: 4
      memory: 16Gi

write:  # If SimpleScalable
  replicas: 6
  autoscaling:
    enabled: true
    behavior:
      scaleUp:
        policies:
          - type: Pods
            value: 2
            periodSeconds: 300

loki:
  limits_config:
    ingestion_rate_mb: 50
    ingestion_burst_size_mb: 100
  ingester:
    chunk_idle_period: 15m  # Flush more frequently
```

---

## Configuration Validation

### Chart Validations (templates/validate.yaml)

Enforced at helm install/upgrade:

1. Object storage required for SimpleScalable/Distributed
2. SingleBinary with filesystem limited to 1 replica
3. Cannot mix deployment modes without transition mode
4. Schema config required (unless useTestSchema)
5. Bucket names required for object storage
6. Admin token secret required if provisioner enabled
7. Cannot have both schemaConfig and useTestSchema

### Runtime Validations

Loki itself validates:
- Schema config compatibility
- Storage accessibility
- Memberlist connectivity

---

## Template Expressions in Values

Many values support Go template expressions via `tpl` function:

```yaml
loki:
  commonConfig:
    compactor_grpc_address: '{{ include "loki.compactorAddress" . }}'

serviceAccount:
  annotations:
    eks.amazonaws.com/role-arn: 'arn:aws:iam::{{ .Values.awsAccountId }}:role/loki'

gateway:
  ingress:
    hosts:
      - host: 'loki.{{ .Values.domainName }}'
```

**Fields Supporting tpl**:
- Affinity
- Topology spread constraints
- DNS config
- Service annotations
- Ingress hosts
- Config object names
- Many string values

---

## Next Steps

- For third-party integrations (MinIO, Memcached), see **[Third-Party Integrations](./loki-helm-third-party.mdc)**
- For production examples, see **[Examples & Best Practices](./loki-helm-examples.mdc)**
- For version-specific changes, see **[Changelog Insights](./loki-helm-changelog.mdc)**
