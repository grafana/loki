// datasetmd.proto holds metadata for columnar-based sections within a data
// object. Columnar-based sections embed dataset for the representation of data
// and metadata.
//
// The metadata of a dataset-based section is encoded into two chunks:
//
// - SectionMetadata, which describes the columns available in the dataset.
// - ColumnMetadata, which describes the pages available for a given column.
//
// The location of SectionMetadata is encoded at the dataobj level using
// SectionInfoExtension, and the location of each ColumnMetadata is referenced
// inside of the SectionMetadata.
syntax = "proto3";

package dataobj.metadata.dataset.v2;

option go_package = "github.com/grafana/loki/v3/pkg/dataobj/internal/metadata/datasetmd";

// SectionInfoExtension holds basic information about how to read this section.
// It is encoded into the extension data field of
// [github.com/grafana/loki/v3/pkg/dataobj/internal/metadata/filemd.FileMetadata].
message SectionInfoExtension {
  // Byte offset relative to the start of the section's metadata region where
  // SectionMetadata for this section is stored.
  uint64 section_metadata_offset = 1;

  // Length of the SectionMetadata for this column in bytes.
  uint64 section_metadata_length = 2;
}

// SectionMetadata holds the entrypoint metadata for the overall section.
// SectionMetadata points to the offset of per-column ColumnMetadata which can
// be retrieved on demand.
message SectionMetadata {
  // The list of columns in the dataset.
  repeated ColumnDesc columns = 1;

  // Dictionary for deduplicating logical types and column tags. The first
  // element (index zero) is reserved for invalid strings ("").
  repeated string dictionary = 2;

  // Sort information about the columns.
  SortInfo sort_info = 3;
}

// ColumnDesc describes an individual column within a data set.
message ColumnDesc {
  // Type holds the type of data in the column.
  ColumnType type = 1;

  // Tag is an optional string that can be used to distinguish between
  // different columns with the same type.
  //
  // For example, there may be two columns with the type (uint64.timestamp)
  // but with different tags ("start_time" and "end_time").
  //
  // Columns are uniquely named based on the combination of their type and
  // optional tag, separated by a "/" when a tag is present:
  //
  //   - uint64.timestamp/start_time
  //   - uint64.timestamp/end_time
  //   - uint64.stream_id (no tag)
  //
  // The tag string can be retrieved from the dictionary field in
  // SectionMetadata, using the tag_ref value as the index.
  uint32 tag_ref = 2;

  // Total number of pages in the column.
  uint64 pages_count = 3;

  // Total number of rows (values + nulls) in the column across all pages.
  uint64 rows_count = 4;

  // Total number of non-NULL values in this column across all pages. The
  // number of NULL values is rows_count - values_count.
  uint64 values_count = 5;

  // Compression type used for all pages.
  CompressionType compression = 6;

  // Total uncompressed size of all pages in the column in bytes.
  uint64 uncompressed_size = 7;

  // Total compressed size of all pages in the column. If no compression is
  // used, compressed_size matches uncompressed_size.
  uint64 compressed_size = 8;

  // Byte offset relative to the start of the section's metadata region where
  // ColumnMetadata for this column is stored.
  uint64 column_metadata_offset = 9;

  // Length of the ColumnMetadata for this column in bytes.
  uint64 column_metadata_length = 10;

  // Statistics for this column.
  Statistics statistics = 11;
}

// ColumnType represents the type of data in a column, combined from its
// physical layout and logical interpretation.
//
// A ColumnType is usually described by concatenating its physical and logical
// type with a ".", such as "uint64.timestamp" or "binary.label".
message ColumnType {
  // Physical is the physical type of the column.
  PhysicalType physical = 1;

  // Logical is a section-specified string indicating how to interpret the
  // physical type. Section implementations are responsible for interpreting
  // this value.
  //
  // The string can be retrieved from the dictionary field in SectionMetadata,
  // using the logical_ref value as the index.
  uint32 logical_ref = 3;
}

// PhysicalType represents the type that the column is encoded as.
enum PhysicalType {
  // Invalid PhysicalType.
  PHYSICAL_TYPE_UNSPECIFIED = 0;

  // PHYSICAL_TYPE_INT64 holds 64-bit integer values.
  PHYSICAL_TYPE_INT64 = 1;

  // PHYSICAL_TYPE_UINT64 holds 64-bit unsigned integer values.
  PHYSICAL_TYPE_UINT64 = 2;

  // PHYSICAL_TYPE_BINARY holds binary data of variable length.
  PHYSICAL_TYPE_BINARY = 3;
}

// CompressionType represents valid compression types that can be used for
// compressing content within pages.
enum CompressionType {
  // Invalid compression type.
  COMPRESSION_TYPE_UNSPECIFIED = 0;

  // No compression.
  COMPRESSION_TYPE_NONE = 1;

  // Snappy compression.
  COMPRESSION_TYPE_SNAPPY = 2;

  // Zstd compression.
  COMPRESSION_TYPE_ZSTD = 3;
}

// ColumnMetadata holds additional metadata for an individual column.
// ColumnMetadata is stored within the metadata region of a section, and its
// offset and size is retrieved from within [ColumnDesc].
message ColumnMetadata {
  // Pages within the column.
  repeated PageDesc pages = 1;
}

// PageDesc describes an individual page within a column.
message PageDesc {
  // Uncompressed size of the page in bytes.
  uint64 uncompressed_size = 1;

  // Compressed size of the page in bytes.
  uint64 compressed_size = 2;

  // CRC32 checksum of the page data.
  uint32 crc32 = 3;

  // Total number of rows (values + nulls) in the page.
  uint64 rows_count = 4;

  // Total number of non-NULL values in the page. The number of NULL values is
  // rows_count - values_count.
  uint64 values_count = 5;

  // Encoding used for values in the page.
  EncodingType encoding = 6;

  // Byte offset relative to the start of the section's data region where the
  // page is stored.
  uint64 data_offset = 7;

  // Size of the page's data in bytes.
  uint64 data_size = 8;

  // Optional statistics for the page.
  Statistics statistics = 9;
}

// EncodingType represents the valid types that a sequence of values which a
// column can be encoded with.
enum EncodingType {
  // Invalid encoding type.
  ENCODING_TYPE_UNSPECIFIED = 0;

  // Plain encoding; data is stored as-is.
  ENCODING_TYPE_PLAIN = 1;

  // Delta encoding. The first value within the page is stored as-is, and
  // subsequent values are stored as the delta from the previous value.
  ENCODING_TYPE_DELTA = 2;

  // Bitmap encoding. Bitmaps efficiently store repeating sequences of unsigned
  // integers using a combination of run-length encoding and bitpacking.
  ENCODING_TYPE_BITMAP = 3;
}

// Statistics about a column or a page. All statistics are optional and are
// conditionally set depending on the column type.
message Statistics {
  // Minimum value. Applications should only set min_value to an encoding of a
  // non-NULL value. If there is no non-NULL value, min_value should be unset.
  //
  // Applications must not assume that an unset min_value means that the column
  // is empty; check for values_count == 0 instead.
  bytes min_value = 1;

  // Maximum value. Applications should only set max_value to an encoding of a
  // non-NULL value. If there is no non-NULL value, max_value should be unset.
  //
  // Applications must not assume that an unset max_value means that the column
  // is empty; check for values_count == 0 instead.
  bytes max_value = 2;

  // Estimated number of distinct values in the column.
  //
  // Applications must not assume that an unset cardinality_count means that
  // the column has no distinct values; check for values_count == 0 instead.
  uint64 cardinality_count = 3;
}

// SortInfo holds sort order information for rows in the section.
message SortInfo {
  message ColumnSort {
    // Index of the column in the columns list.
    uint32 column_index = 1;

    // Sort direction of the column.
    SortDirection direction = 2;
  }

  // The list of column sorts. The length of this depends on how many columns
  // are used for sorting.
  //
  // If the section has no sorting at all, this field will be empty. If the
  // section is sorted based on the value of a single column, this field will
  // contain a single element. Otherwise, this field will contain multiple
  // elements when compound sorting is used.
  repeated ColumnSort column_sorts = 1;
}

// SortDirection represents sort direction of a column.
enum SortDirection {
  // Sort direction is unspecified.
  SORT_DIRECTION_UNSPECIFIED = 0;

  // SORT_DIRECTION_ASCENDING represents ascending sort order (smallest values first).
  SORT_DIRECTION_ASCENDING = 1;

  // SORT_DIRECTION_DESCENDING represents descending sort order (largest values first).
  SORT_DIRECTION_DESCENDING = 2;
}
