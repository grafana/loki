package main

import (
	"errors"
	"fmt"
	"go/types"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

// based on https://evilmartians.com/chronicles/a-taste-of-go-code-generator-magic-a-quick-guide-to-getting-started

var rePkgReferencedType = regexp.MustCompile(`([^*\[\]]+)\.[^.]+`)

type typeAdapter struct {
	wasmType string
	decode   func(statement *jen.Statement) *jen.Statement
	encode   func(statement *jen.Statement) *jen.Statement
}

type generator struct {
	host           *fileGenerator
	guest          *fileGenerator
	hostStatements *jen.Statement
	typeAdapters   map[string]typeAdapter
}

type fileGenerator struct {
	dir       string
	suffix    string
	file      *jen.File
	imports   map[string]struct{}
	statement *jen.Statement
}

const targetParam = "target"
const exchangeParam = "exchange"
const builderParam = "builder"
const stackParam = "stack"

const hostUtilsPackage = "github.com/grafana/loki/v3/pkg/plugins/host"
const guestUtilsPackage = "github.com/grafana/loki/v3/pkg/plugins/guest"
const api = "github.com/tetratelabs/wazero/api"

func main() {
	if len(os.Args) < 3 {
		log.Fatal("Usage: //go:generate go run ../bindgen/bindgen.go <package> <typeName>")
	}

	packageName := os.Args[1]
	typeName := os.Args[2]

	typeObject := loadPackage(packageName).Types.Scope().Lookup(typeName)
	if typeObject == nil {
		log.Fatalf("unable to find type %s", typeName)
	}

	//typeObjectMeta := types.NewPointer(typeObject.Type().Underlying())
	methods := types.NewMethodSet(typeObject.Type().Underlying())

	name := typeObject.Pkg().Name()

	g := &generator{
		host:           newFileGenerator(".", name, "host"),
		guest:          newFileGenerator("guest", name, "guest"),
		hostStatements: jen.Empty(),
		typeAdapters:   newTypeAdapters(),
	}

	hf := g.host.statement
	hf.Line()
	hf.Func().
		Id("AddImport").
		Params(
			jen.Id(builderParam).Qual("github.com/tetratelabs/wazero", "HostModuleBuilder"),
			jen.Id(exchangeParam).Id("*").Qual(hostUtilsPackage, "Exchange"),
			jen.Id(targetParam).Id(typeName),
		).
		Block(g.hostStatements)

	for i := 0; i < methods.Len(); i++ {
		method := methods.At(i).Obj()

		// Skip private methods
		if !method.Exported() {
			continue
		}

		err := g.method(method, packageName)
		if err != nil {
			log.Fatalf("failed to generate method %s.%s: %v", typeName, method.Name(), err)
		}
	}
	g.finish()
}

func (g *generator) finish() {
	g.host.finish()
	g.guest.finish()
}

func (g *fileGenerator) finish() {
	f := g.file
	// TODO consider this when we have extra imports to add it's currently adding
	// superficial guest imports for context and api.Module when host functions use that overload
	//if len(g.imports) > 0 {
	//	importsToAdd := jen.Empty()
	//	for importPackage := range g.imports {
	//		importsToAdd.Add(
	//			jen.Lit(importPackage),
	//			jen.Line(),
	//		)
	//	}
	//
	//	f.Comment("Import missing dependencies")
	//	f.Add(jen.Id("import").Parens(importsToAdd))
	//}

	f.Add(g.statement)

	filename := os.Getenv("GOFILE")
	ext := filepath.Ext(filename)
	filename, _ = strings.CutSuffix(filename, ext)
	filename = path.Join(g.dir, filename+"_"+g.suffix+"_gen.go")

	// Create the output directory if it doesn't exist
	if err := os.MkdirAll(filepath.Dir(filename), 0755); err != nil {
		log.Fatal(fmt.Errorf("failed to create directory: %v", err))
	}

	if err := f.Save(filename); err != nil {
		log.Fatal(fmt.Errorf("failed to save: %v", err))
	}
}

func newTypeAdapters() map[string]typeAdapter {
	return map[string]typeAdapter{
		"int32": {
			wasmType: "ValueTypeI32",
			decode: func(statement *jen.Statement) *jen.Statement {
				return statement.Qual(api, "DecodeI32")
			},
			encode: func(statement *jen.Statement) *jen.Statement {
				return statement.Qual(api, "EncodeI32")
			},
		},
		"float64": {
			wasmType: "ValueTypeF64",
			decode: func(statement *jen.Statement) *jen.Statement {
				return statement.Qual(api, "DecodeF64")
			},
			encode: func(statement *jen.Statement) *jen.Statement {
				return statement.Qual(api, "EncodeF64")
			},
		},
		"uint64": {
			wasmType: "ValueTypeI64",
			decode: func(statement *jen.Statement) *jen.Statement {
				return statement
			},
			encode: func(statement *jen.Statement) *jen.Statement {
				return statement.Qual(api, "EncodeI64")
			},
		},
	}
}

func newFileGenerator(dir, packageName, suffix string) *fileGenerator {
	f := jen.NewFile(packageName)

	f.PackageComment("Code generated by bindgen, DO NOT EDIT.")
	f.PackageComment("")
	f.PackageComment("This file provides the wrappers for wazero.")

	return &fileGenerator{
		dir:       dir,
		suffix:    suffix,
		file:      f,
		imports:   make(map[string]struct{}),
		statement: jen.Empty(),
	}
}

func callImportedFunc(importDeclarationArgs []jen.Code, returnTypes []string, importedFuncName string) (string, jen.Code) {
	var returnType string
	var statement jen.Code = jen.Id(importedFuncName).Call(importDeclarationArgs...)

	if len(returnTypes) > 0 {
		returnType = "(" + strings.Join(returnTypes, ", ") + ")"
		statement = jen.Return(statement)
	}
	return returnType, statement
}

func (g *generator) method(method types.Object, packageName string) error {
	signature := method.Type().(*types.Signature)

	// param: parameter, e.g. "message string"
	// paramType: parameter type, e.g. "string"
	// arg: argument, e.g. "message"

	var guestParams []jen.Code
	var importDeclarationArgs []jen.Code
	var importDeclarationParams []jen.Code
	var hostArgs []jen.Code
	var hostParamTypes []jen.Code
	var hostReturnTypes []jen.Code
	guestStatements := jen.Empty()

	// Get imported packages from params and prepare param names and types
	signatureParams := signature.Params()
	stackIndex := 0
	for i := 0; i < signatureParams.Len(); i++ {
		param := signatureParams.At(i)
		paramType := param.Type().String()

		// Remove current package prefix
		paramType = strings.ReplaceAll(paramType, packageName+".", "")

		// Remove prefixes of imported packages
		paramType = extractImports(paramType, g.guest.imports)

		name := param.Name()
		switch {
		case signature.Variadic() && i == signatureParams.Len()-1:
			paramType = "..." + paramType[2:]
			guestStatements = guestStatements.Qual(guestUtilsPackage, "PushStrings").Call(jen.Id(name)).Line()
			hostArgs = append(hostArgs, jen.Id(exchangeParam).Dot("StringImportArgs").Call().Add(jen.Id("...")))
			guestParams = append(guestParams, jen.Id(name).Id(paramType))
		case paramType == "string":
			guestStatements = guestStatements.Qual(guestUtilsPackage, "PushString").Call(jen.Id(name)).Line()
			hostArgs = append(hostArgs, jen.Id(exchangeParam).Dot("StringImportArg").Call())
			guestParams = append(guestParams, jen.Id(name).Id(paramType))
		case paramType == "context.Context":
			hostArgs = append(hostArgs, jen.Id("ctx"))
		case paramType == "api.Module":
			hostArgs = append(hostArgs, jen.Id("m"))
		default:
			adapter, ok := g.typeAdapters[paramType]
			if !ok {
				return fmt.Errorf("unsupported param type %s", paramType)
			}
			importDeclarationParams = append(importDeclarationParams, jen.Id(name).Id(paramType))
			importDeclarationArgs = append(importDeclarationArgs, jen.Id(name))
			hostParamTypes = append(hostParamTypes, jen.Qual(api, adapter.wasmType))
			hostArgs = append(hostArgs, adapter.decode(&jen.Statement{}).
				Call(jen.Id(stackParam).Index(jen.Id(strconv.Itoa(stackIndex)))))
			guestParams = append(guestParams, jen.Id(name).Id(paramType))
			stackIndex++
		}
	}

	returnTypes := g.returnTypes(signature, packageName)

	for _, returnType := range returnTypes {
		adapter, ok := g.typeAdapters[returnType]
		if !ok {
			return fmt.Errorf("unsupported return type %s", returnType)
		}
		hostReturnTypes = append(hostReturnTypes, jen.Qual(api, adapter.wasmType))
	}

	importedFuncName := method.Name() + "_import"
	// lower case the first letter of the method wasmType
	importedFuncName = strings.ToLower(importedFuncName[:1]) + importedFuncName[1:]
	guestReturnType, lastStatement := callImportedFunc(importDeclarationArgs, returnTypes, importedFuncName)

	target, err := g.callTarget(method, hostArgs, returnTypes)
	if err != nil {
		return err
	}

	g.hostStatements = g.hostStatements.Id(builderParam).
		Dot("NewFunctionBuilder").Call().
		Dot("WithGoModuleFunction").
		Params(jen.Qual(api, "GoModuleFunc").
			Call(
				jen.Func().Call(
					jen.Id("ctx").Qual("context", "Context"),
					jen.Id("m").Qual(api, "Module"),
					jen.Id(stackParam).Index().Uint64()).
					Block(target),
			),
			jen.Index().Qual(api, "ValueType").Values(hostParamTypes...),
			jen.Index().Qual(api, "ValueType").Values(hostReturnTypes...),
		).
		Dot("Export").Params(jen.Lit(importedFuncName)).Line()

	gf := g.guest.statement
	gf.Line()
	gf.Comment("//go:wasmimport env " + importedFuncName)
	gf.Line()
	gf.Func().Id(importedFuncName).Params(
		importDeclarationParams...,
	)

	if len(returnTypes) > 0 {
		gf.Id("(" + strings.Join(returnTypes, ", ") + ")")
	}

	gf.Line()
	gf.Line()
	gf.Func().Id(method.Name()).Params(guestParams...).Id(guestReturnType).Block(
		guestStatements,
		lastStatement,
	)
	gf.Line()
	return nil
}

func (g *generator) callTarget(method types.Object, hostArgs []jen.Code, returnTypes []string) (*jen.Statement, error) {
	statement := jen.Id(targetParam).Dot(method.Name()).Call(hostArgs...)
	if len(returnTypes) > 0 {
		if len(returnTypes) > 1 {
			return nil, errors.New("method has multiple return types, which is not supported")
		}

		r := returnTypes[0]
		adapter, ok := g.typeAdapters[r]
		if !ok {
			return nil, fmt.Errorf("unsupported return type %s", r)
		}

		statement = jen.Id(stackParam).Index(jen.Lit(0)).Op("=").
			Add(adapter.encode(&jen.Statement{}).Call(statement))
	}
	return statement, nil
}

func (g *generator) returnTypes(signature *types.Signature, packageName string) []string {
	results := signature.Results()
	returnTypes := make([]string, 0, results.Len())

	// Get imported packages from returns and parepare return types
	for j := 0; j < results.Len(); j++ {
		resultType := results.At(j).Type().String()

		// Remove current package prefix
		resultType = strings.ReplaceAll(resultType, packageName+".", "")

		// Remove prefixes of imported packages
		resultType = extractImports(resultType, g.guest.imports)

		returnTypes = append(returnTypes, resultType)
	}
	return returnTypes
}

func loadPackage(path string) *packages.Package {
	// load the local "plugins" package

	cfg := &packages.Config{Mode: packages.NeedTypes}

	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		log.Fatalf("failed to load package '%s' for inspection: %v", path, err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		log.Fatalf("package errors: %v", packages.PrintErrors(pkgs))
	}

	return pkgs[0]
}

func extractImports(paramType string, imports map[string]struct{}) string {
	if strings.Index(paramType, ".") < 0 {
		return paramType
	}

	submatches := rePkgReferencedType.FindStringSubmatch(paramType)

	imports[submatches[1]] = struct{}{}

	for packageName := range imports {
		paramType = strings.ReplaceAll(paramType, filepath.Dir(packageName)+"/", "")
	}

	return paramType
}
