// xcap.proto holds types for serializing xcap via protobuf.
syntax = "proto3";

package loki.xcap;

import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";

option go_package = "github.com/grafana/loki/v3/pkg/xcap/internal/proto";

// Capture is protobuf representation of a Capture.
message Capture {
  // A list of Regions recorded in the Capture.
  repeated Region regions = 1;

  // A list of statistic definitions used in the Capture across all
  // Regions. The index into this list is used as the statistic_id field
  // in Observation.
  repeated Statistic statistics = 2;
}

// Region is protobuf representation of a Region.
message Region {
  // Name is the name of the region.
  string name = 1;

  // StartTime is when the region was created.
  google.protobuf.Timestamp start_time = 2 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];

  // EndTime is when the region ended. Zero if not ended.
  google.protobuf.Timestamp end_time = 3 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];

  // Observations are all observations recorded in this region.
  repeated Observation observations = 4;

  // Id is a unique identifier for this region (8 bytes).
  bytes id = 5;

  // ParentId is the ID of the parent region, or empty if this is a root region (8 bytes).
  bytes parent_id = 6;

  // Attributes are the attributes associated with this region.
  repeated Attribute attributes = 7;

  // Events are timestamped events recorded in this region.
  repeated Event events = 8;

  // Status is the status of the region's operation.
  Status status = 9;
}

// Event represents a timestamped event within a region.
message Event {
  // Name is the name of the event.
  string name = 1;

  // Timestamp is when the event occurred.
  google.protobuf.Timestamp timestamp = 2 [
    (gogoproto.nullable) = false,
    (gogoproto.stdtime) = true
  ];

  // Attributes are the attributes associated with this event.
  repeated Attribute attributes = 3;
}

// Status represents the status of a region's operation.
message Status {
  // Code is the status code (0=Unset, 1=Error, 2=Ok).
  uint32 code = 1;

  // Message is an optional status message.
  string message = 2;
}

// Attribute represents a single attribute key-value pair.
message Attribute {
  // Key is the attribute key.
  string key = 1;

  // Value is the attribute value.
  AttributeValue value = 2;
}

// AttributeValue represents an attribute value.
message AttributeValue {
  oneof kind {
    string string_value = 1;
    int64 int_value = 2;
    double float_value = 3;
    bool bool_value = 4;
  }
}

// Statistic represents a statistic definition.
message Statistic {
  // Name is the name of the statistic.
  string name = 1;

  // DataType is the data type of the statistic's values.
  DataType data_type = 2;

  // AggregationType is how multiple observations are aggregated.
  AggregationType aggregation_type = 3;
}

// Observation represents an aggregated observation value for a statistic.
message Observation {
  // StatisticId is the index into the statistics list in Capture.
  uint32 statistic_id = 1;

  // Value is the aggregated observation value.
  ObservationValue value = 2;

  // Count is the number of observations aggregated.
  uint32 count = 3;
}

// ObservationValue represents a single observation value.
message ObservationValue {
  oneof kind {
    int64 int_value = 1;
    double float_value = 2;
    bool bool_value = 3;
  }
}

// DataType specifies the data type of a statistic's values.
enum DataType {
  DATA_TYPE_INVALID = 0; // Invalid/unspecified data type.
  DATA_TYPE_INT64 = 1; // Signed 64-bit integer statistic.
  DATA_TYPE_FLOAT64 = 2; // Double precision floating point statistic.
  DATA_TYPE_BOOL = 3; // Boolean statistic (flag).
}

// AggregationType specifies how to combine multiple observations of the
// same statistic.
enum AggregationType {
  AGGREGATION_TYPE_INVALID = 0; // Invalid/unspecified aggregation type.
  AGGREGATION_TYPE_SUM = 1; // Sum all observations together.
  AGGREGATION_TYPE_MIN = 2; // Use the smallest value.
  AGGREGATION_TYPE_MAX = 3; // Use the largest value.
  AGGREGATION_TYPE_LAST = 4; // Use the last recorded value.
  AGGREGATION_TYPE_FIRST = 5; // Use the first recorded value.
}
