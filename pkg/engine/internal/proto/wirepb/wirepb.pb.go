// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/engine/internal/proto/wirepb/wirepb.proto

package wirepb

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	httpgrpc "github.com/grafana/dskit/httpgrpc"
	physicalpb "github.com/grafana/loki/v3/pkg/engine/internal/proto/physicalpb"
	_ "github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid"
	github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid "github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TaskState represents the execution state of a task.
type TaskState int32

const (
	TASK_STATE_INVALID   TaskState = 0
	TASK_STATE_CREATED   TaskState = 1
	TASK_STATE_PENDING   TaskState = 2
	TASK_STATE_RUNNING   TaskState = 3
	TASK_STATE_COMPLETED TaskState = 4
	TASK_STATE_CANCELLED TaskState = 5
	TASK_STATE_FAILED    TaskState = 6
)

var TaskState_name = map[int32]string{
	0: "TASK_STATE_INVALID",
	1: "TASK_STATE_CREATED",
	2: "TASK_STATE_PENDING",
	3: "TASK_STATE_RUNNING",
	4: "TASK_STATE_COMPLETED",
	5: "TASK_STATE_CANCELLED",
	6: "TASK_STATE_FAILED",
}

var TaskState_value = map[string]int32{
	"TASK_STATE_INVALID":   0,
	"TASK_STATE_CREATED":   1,
	"TASK_STATE_PENDING":   2,
	"TASK_STATE_RUNNING":   3,
	"TASK_STATE_COMPLETED": 4,
	"TASK_STATE_CANCELLED": 5,
	"TASK_STATE_FAILED":    6,
}

func (TaskState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{0}
}

// StreamState represents the state of a stream.
type StreamState int32

const (
	STREAM_STATE_INVALID StreamState = 0
	STREAM_STATE_IDLE    StreamState = 1
	STREAM_STATE_OPEN    StreamState = 2
	STREAM_STATE_BLOCKED StreamState = 3
	STREAM_STATE_CLOSED  StreamState = 4
)

var StreamState_name = map[int32]string{
	0: "STREAM_STATE_INVALID",
	1: "STREAM_STATE_IDLE",
	2: "STREAM_STATE_OPEN",
	3: "STREAM_STATE_BLOCKED",
	4: "STREAM_STATE_CLOSED",
}

var StreamState_value = map[string]int32{
	"STREAM_STATE_INVALID": 0,
	"STREAM_STATE_IDLE":    1,
	"STREAM_STATE_OPEN":    2,
	"STREAM_STATE_BLOCKED": 3,
	"STREAM_STATE_CLOSED":  4,
}

func (StreamState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{1}
}

type Frame struct {
	// Types that are valid to be assigned to Kind:
	//	*Frame_Ack
	//	*Frame_Nack
	//	*Frame_Discard
	//	*Frame_Message
	Kind isFrame_Kind `protobuf_oneof:"kind"`
}

func (m *Frame) Reset()      { *m = Frame{} }
func (*Frame) ProtoMessage() {}
func (*Frame) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{0}
}
func (m *Frame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Frame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Frame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Frame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Frame.Merge(m, src)
}
func (m *Frame) XXX_Size() int {
	return m.Size()
}
func (m *Frame) XXX_DiscardUnknown() {
	xxx_messageInfo_Frame.DiscardUnknown(m)
}

var xxx_messageInfo_Frame proto.InternalMessageInfo

type isFrame_Kind interface {
	isFrame_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Frame_Ack struct {
	Ack *AckFrame `protobuf:"bytes,1,opt,name=ack,proto3,oneof"`
}
type Frame_Nack struct {
	Nack *NackFrame `protobuf:"bytes,2,opt,name=nack,proto3,oneof"`
}
type Frame_Discard struct {
	Discard *DiscardFrame `protobuf:"bytes,3,opt,name=discard,proto3,oneof"`
}
type Frame_Message struct {
	Message *MessageFrame `protobuf:"bytes,4,opt,name=message,proto3,oneof"`
}

func (*Frame_Ack) isFrame_Kind()     {}
func (*Frame_Nack) isFrame_Kind()    {}
func (*Frame_Discard) isFrame_Kind() {}
func (*Frame_Message) isFrame_Kind() {}

func (m *Frame) GetKind() isFrame_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *Frame) GetAck() *AckFrame {
	if x, ok := m.GetKind().(*Frame_Ack); ok {
		return x.Ack
	}
	return nil
}

func (m *Frame) GetNack() *NackFrame {
	if x, ok := m.GetKind().(*Frame_Nack); ok {
		return x.Nack
	}
	return nil
}

func (m *Frame) GetDiscard() *DiscardFrame {
	if x, ok := m.GetKind().(*Frame_Discard); ok {
		return x.Discard
	}
	return nil
}

func (m *Frame) GetMessage() *MessageFrame {
	if x, ok := m.GetKind().(*Frame_Message); ok {
		return x.Message
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Frame) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Frame_Ack)(nil),
		(*Frame_Nack)(nil),
		(*Frame_Discard)(nil),
		(*Frame_Message)(nil),
	}
}

type AckFrame struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AckFrame) Reset()      { *m = AckFrame{} }
func (*AckFrame) ProtoMessage() {}
func (*AckFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{1}
}
func (m *AckFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AckFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AckFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AckFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckFrame.Merge(m, src)
}
func (m *AckFrame) XXX_Size() int {
	return m.Size()
}
func (m *AckFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_AckFrame.DiscardUnknown(m)
}

var xxx_messageInfo_AckFrame proto.InternalMessageInfo

func (m *AckFrame) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type NackFrame struct {
	Id    uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Error *Error `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *NackFrame) Reset()      { *m = NackFrame{} }
func (*NackFrame) ProtoMessage() {}
func (*NackFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{2}
}
func (m *NackFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NackFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NackFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NackFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NackFrame.Merge(m, src)
}
func (m *NackFrame) XXX_Size() int {
	return m.Size()
}
func (m *NackFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_NackFrame.DiscardUnknown(m)
}

var xxx_messageInfo_NackFrame proto.InternalMessageInfo

func (m *NackFrame) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *NackFrame) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type Error struct {
	// The HTTP status code of the error.
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	// A message describing the error.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *Error) Reset()      { *m = Error{} }
func (*Error) ProtoMessage() {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{3}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DiscardFrame struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *DiscardFrame) Reset()      { *m = DiscardFrame{} }
func (*DiscardFrame) ProtoMessage() {}
func (*DiscardFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{4}
}
func (m *DiscardFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscardFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscardFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscardFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscardFrame.Merge(m, src)
}
func (m *DiscardFrame) XXX_Size() int {
	return m.Size()
}
func (m *DiscardFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscardFrame.DiscardUnknown(m)
}

var xxx_messageInfo_DiscardFrame proto.InternalMessageInfo

func (m *DiscardFrame) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MessageFrame struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Types that are valid to be assigned to Kind:
	//	*MessageFrame_WorkerHello
	//	*MessageFrame_WorkerReady
	//	*MessageFrame_TaskAssign
	//	*MessageFrame_TaskCancel
	//	*MessageFrame_TaskFlag
	//	*MessageFrame_TaskStatus
	//	*MessageFrame_StreamBind
	//	*MessageFrame_StreamData
	//	*MessageFrame_StreamStatus
	Kind isMessageFrame_Kind `protobuf_oneof:"kind"`
}

func (m *MessageFrame) Reset()      { *m = MessageFrame{} }
func (*MessageFrame) ProtoMessage() {}
func (*MessageFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{5}
}
func (m *MessageFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageFrame.Merge(m, src)
}
func (m *MessageFrame) XXX_Size() int {
	return m.Size()
}
func (m *MessageFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageFrame.DiscardUnknown(m)
}

var xxx_messageInfo_MessageFrame proto.InternalMessageInfo

type isMessageFrame_Kind interface {
	isMessageFrame_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MessageFrame_WorkerHello struct {
	WorkerHello *WorkerHelloMessage `protobuf:"bytes,10,opt,name=worker_hello,json=workerHello,proto3,oneof"`
}
type MessageFrame_WorkerReady struct {
	WorkerReady *WorkerReadyMessage `protobuf:"bytes,2,opt,name=worker_ready,json=workerReady,proto3,oneof"`
}
type MessageFrame_TaskAssign struct {
	TaskAssign *TaskAssignMessage `protobuf:"bytes,3,opt,name=task_assign,json=taskAssign,proto3,oneof"`
}
type MessageFrame_TaskCancel struct {
	TaskCancel *TaskCancelMessage `protobuf:"bytes,4,opt,name=task_cancel,json=taskCancel,proto3,oneof"`
}
type MessageFrame_TaskFlag struct {
	TaskFlag *TaskFlagMessage `protobuf:"bytes,5,opt,name=task_flag,json=taskFlag,proto3,oneof"`
}
type MessageFrame_TaskStatus struct {
	TaskStatus *TaskStatusMessage `protobuf:"bytes,6,opt,name=task_status,json=taskStatus,proto3,oneof"`
}
type MessageFrame_StreamBind struct {
	StreamBind *StreamBindMessage `protobuf:"bytes,7,opt,name=stream_bind,json=streamBind,proto3,oneof"`
}
type MessageFrame_StreamData struct {
	StreamData *StreamDataMessage `protobuf:"bytes,8,opt,name=stream_data,json=streamData,proto3,oneof"`
}
type MessageFrame_StreamStatus struct {
	StreamStatus *StreamStatusMessage `protobuf:"bytes,9,opt,name=stream_status,json=streamStatus,proto3,oneof"`
}

func (*MessageFrame_WorkerHello) isMessageFrame_Kind()  {}
func (*MessageFrame_WorkerReady) isMessageFrame_Kind()  {}
func (*MessageFrame_TaskAssign) isMessageFrame_Kind()   {}
func (*MessageFrame_TaskCancel) isMessageFrame_Kind()   {}
func (*MessageFrame_TaskFlag) isMessageFrame_Kind()     {}
func (*MessageFrame_TaskStatus) isMessageFrame_Kind()   {}
func (*MessageFrame_StreamBind) isMessageFrame_Kind()   {}
func (*MessageFrame_StreamData) isMessageFrame_Kind()   {}
func (*MessageFrame_StreamStatus) isMessageFrame_Kind() {}

func (m *MessageFrame) GetKind() isMessageFrame_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *MessageFrame) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MessageFrame) GetWorkerHello() *WorkerHelloMessage {
	if x, ok := m.GetKind().(*MessageFrame_WorkerHello); ok {
		return x.WorkerHello
	}
	return nil
}

func (m *MessageFrame) GetWorkerReady() *WorkerReadyMessage {
	if x, ok := m.GetKind().(*MessageFrame_WorkerReady); ok {
		return x.WorkerReady
	}
	return nil
}

func (m *MessageFrame) GetTaskAssign() *TaskAssignMessage {
	if x, ok := m.GetKind().(*MessageFrame_TaskAssign); ok {
		return x.TaskAssign
	}
	return nil
}

func (m *MessageFrame) GetTaskCancel() *TaskCancelMessage {
	if x, ok := m.GetKind().(*MessageFrame_TaskCancel); ok {
		return x.TaskCancel
	}
	return nil
}

func (m *MessageFrame) GetTaskFlag() *TaskFlagMessage {
	if x, ok := m.GetKind().(*MessageFrame_TaskFlag); ok {
		return x.TaskFlag
	}
	return nil
}

func (m *MessageFrame) GetTaskStatus() *TaskStatusMessage {
	if x, ok := m.GetKind().(*MessageFrame_TaskStatus); ok {
		return x.TaskStatus
	}
	return nil
}

func (m *MessageFrame) GetStreamBind() *StreamBindMessage {
	if x, ok := m.GetKind().(*MessageFrame_StreamBind); ok {
		return x.StreamBind
	}
	return nil
}

func (m *MessageFrame) GetStreamData() *StreamDataMessage {
	if x, ok := m.GetKind().(*MessageFrame_StreamData); ok {
		return x.StreamData
	}
	return nil
}

func (m *MessageFrame) GetStreamStatus() *StreamStatusMessage {
	if x, ok := m.GetKind().(*MessageFrame_StreamStatus); ok {
		return x.StreamStatus
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MessageFrame) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MessageFrame_WorkerHello)(nil),
		(*MessageFrame_WorkerReady)(nil),
		(*MessageFrame_TaskAssign)(nil),
		(*MessageFrame_TaskCancel)(nil),
		(*MessageFrame_TaskFlag)(nil),
		(*MessageFrame_TaskStatus)(nil),
		(*MessageFrame_StreamBind)(nil),
		(*MessageFrame_StreamData)(nil),
		(*MessageFrame_StreamStatus)(nil),
	}
}

// WorkerHelloMessage is sent by a peer to the scheduler to establish
// itself as a control plane connection that can run tasks.
//
// WorkerHelloMessage must be sent by workers before any other worker messages.
type WorkerHelloMessage struct {
	// Threads is the maximum number of threads the worker has available.
	//
	// The scheduler uses threads to determine the maximum number of tasks that
	// can be assigned concurrently to a worker.
	Threads uint64 `protobuf:"varint,1,opt,name=threads,proto3" json:"threads,omitempty"`
}

func (m *WorkerHelloMessage) Reset()      { *m = WorkerHelloMessage{} }
func (*WorkerHelloMessage) ProtoMessage() {}
func (*WorkerHelloMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{6}
}
func (m *WorkerHelloMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerHelloMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerHelloMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerHelloMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerHelloMessage.Merge(m, src)
}
func (m *WorkerHelloMessage) XXX_Size() int {
	return m.Size()
}
func (m *WorkerHelloMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerHelloMessage.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerHelloMessage proto.InternalMessageInfo

func (m *WorkerHelloMessage) GetThreads() uint64 {
	if m != nil {
		return m.Threads
	}
	return 0
}

// WorkerReadyMessage is sent by a worker to the scheduler to signal that
// the worker has at least one worker thread available for running tasks.
//
// Workers may send WorkerReadyMessage at any time.
type WorkerReadyMessage struct {
}

func (m *WorkerReadyMessage) Reset()      { *m = WorkerReadyMessage{} }
func (*WorkerReadyMessage) ProtoMessage() {}
func (*WorkerReadyMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{7}
}
func (m *WorkerReadyMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerReadyMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerReadyMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerReadyMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerReadyMessage.Merge(m, src)
}
func (m *WorkerReadyMessage) XXX_Size() int {
	return m.Size()
}
func (m *WorkerReadyMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerReadyMessage.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerReadyMessage proto.InternalMessageInfo

// TaskAssignMessage is sent by the scheduler to a worker when there is a
// task to run.
//
// Workers that have no threads available should reject task assignment with a
// HTTP 429 Too Many Requests. When this happens, the scheduler will remove the
// ready state from the worker until it receives a WorkerReadyMessage.
type TaskAssignMessage struct {
	Task *Task `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	// StreamStates holds the most recent state of each stream that the task
	// reads from. The key is the stream ULID.
	StreamStates map[string]StreamState `protobuf:"bytes,2,rep,name=stream_states,json=streamStates,proto3" json:"stream_states,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=loki.wire.StreamState"`
	// Metadata holds additional metadata to propagate with the task, such as
	// trace context.
	Metadata []*httpgrpc.Header `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *TaskAssignMessage) Reset()      { *m = TaskAssignMessage{} }
func (*TaskAssignMessage) ProtoMessage() {}
func (*TaskAssignMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{8}
}
func (m *TaskAssignMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskAssignMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskAssignMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskAssignMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskAssignMessage.Merge(m, src)
}
func (m *TaskAssignMessage) XXX_Size() int {
	return m.Size()
}
func (m *TaskAssignMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskAssignMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TaskAssignMessage proto.InternalMessageInfo

func (m *TaskAssignMessage) GetTask() *Task {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *TaskAssignMessage) GetStreamStates() map[string]StreamState {
	if m != nil {
		return m.StreamStates
	}
	return nil
}

func (m *TaskAssignMessage) GetMetadata() []*httpgrpc.Header {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// TaskCancelMessage is sent by the scheduler to a worker when a task is no
// longer needed.
type TaskCancelMessage struct {
	Id github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid.ULID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid.ULID" json:"id"`
}

func (m *TaskCancelMessage) Reset()      { *m = TaskCancelMessage{} }
func (*TaskCancelMessage) ProtoMessage() {}
func (*TaskCancelMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{9}
}
func (m *TaskCancelMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskCancelMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskCancelMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskCancelMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskCancelMessage.Merge(m, src)
}
func (m *TaskCancelMessage) XXX_Size() int {
	return m.Size()
}
func (m *TaskCancelMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskCancelMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TaskCancelMessage proto.InternalMessageInfo

// TaskFlagMessage is sent by the scheduler to update the runtime flags of a task.
type TaskFlagMessage struct {
	Id github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid.ULID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid.ULID" json:"id"`
	// Interruptible indicates that tasks blocked on writing or reading to a
	// stream can be paused, and that worker can accept new tasks to run.
	Interruptible bool `protobuf:"varint,2,opt,name=interruptible,proto3" json:"interruptible,omitempty"`
}

func (m *TaskFlagMessage) Reset()      { *m = TaskFlagMessage{} }
func (*TaskFlagMessage) ProtoMessage() {}
func (*TaskFlagMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{10}
}
func (m *TaskFlagMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskFlagMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskFlagMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskFlagMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskFlagMessage.Merge(m, src)
}
func (m *TaskFlagMessage) XXX_Size() int {
	return m.Size()
}
func (m *TaskFlagMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskFlagMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TaskFlagMessage proto.InternalMessageInfo

func (m *TaskFlagMessage) GetInterruptible() bool {
	if m != nil {
		return m.Interruptible
	}
	return false
}

// TaskStatusMessage is sent by the worker to the scheduler to inform the
// scheduler of the current status of a task.
type TaskStatusMessage struct {
	Id     github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid.ULID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid.ULID" json:"id"`
	Status TaskStatus                                                     `protobuf:"bytes,2,opt,name=status,proto3" json:"status"`
}

func (m *TaskStatusMessage) Reset()      { *m = TaskStatusMessage{} }
func (*TaskStatusMessage) ProtoMessage() {}
func (*TaskStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{11}
}
func (m *TaskStatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskStatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskStatusMessage.Merge(m, src)
}
func (m *TaskStatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *TaskStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TaskStatusMessage proto.InternalMessageInfo

func (m *TaskStatusMessage) GetStatus() TaskStatus {
	if m != nil {
		return m.Status
	}
	return TaskStatus{}
}

// StreamBindMessage is sent by the scheduler to a worker to inform the
// worker about the location of a stream receiver.
type StreamBindMessage struct {
	StreamId github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid.ULID `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid.ULID" json:"stream_id"`
	// Receiver is the network address of the stream receiver.
	Receiver string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
}

func (m *StreamBindMessage) Reset()      { *m = StreamBindMessage{} }
func (*StreamBindMessage) ProtoMessage() {}
func (*StreamBindMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{12}
}
func (m *StreamBindMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamBindMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamBindMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamBindMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamBindMessage.Merge(m, src)
}
func (m *StreamBindMessage) XXX_Size() int {
	return m.Size()
}
func (m *StreamBindMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamBindMessage.DiscardUnknown(m)
}

var xxx_messageInfo_StreamBindMessage proto.InternalMessageInfo

func (m *StreamBindMessage) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

// StreamDataMessage is sent by a peer to a stream receiver to provide
// payload data for a stream.
//
// Sending StreamDataMessage establishes the connection as part of the data
// plane. No other messages may be sent along data plane connections.
type StreamDataMessage struct {
	StreamId github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid.ULID `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid.ULID" json:"stream_id"`
	// Data is the serialized Arrow record payload.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *StreamDataMessage) Reset()      { *m = StreamDataMessage{} }
func (*StreamDataMessage) ProtoMessage() {}
func (*StreamDataMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{13}
}
func (m *StreamDataMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamDataMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamDataMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamDataMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamDataMessage.Merge(m, src)
}
func (m *StreamDataMessage) XXX_Size() int {
	return m.Size()
}
func (m *StreamDataMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamDataMessage.DiscardUnknown(m)
}

var xxx_messageInfo_StreamDataMessage proto.InternalMessageInfo

func (m *StreamDataMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// StreamStatusMessage communicates the status of the sending side of a stream.
type StreamStatusMessage struct {
	StreamId github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid.ULID `protobuf:"bytes,1,opt,name=stream_id,json=streamId,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid.ULID" json:"stream_id"`
	State    StreamState                                                    `protobuf:"varint,2,opt,name=state,proto3,enum=loki.wire.StreamState" json:"state,omitempty"`
}

func (m *StreamStatusMessage) Reset()      { *m = StreamStatusMessage{} }
func (*StreamStatusMessage) ProtoMessage() {}
func (*StreamStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{14}
}
func (m *StreamStatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamStatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamStatusMessage.Merge(m, src)
}
func (m *StreamStatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *StreamStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_StreamStatusMessage proto.InternalMessageInfo

func (m *StreamStatusMessage) GetState() StreamState {
	if m != nil {
		return m.State
	}
	return STREAM_STATE_INVALID
}

// Task is a single unit of work within a workflow.
type Task struct {
	Ulid     github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid.ULID `protobuf:"bytes,1,opt,name=ulid,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid.ULID" json:"ulid"`
	TenantId string                                                         `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	// Fragment is the local physical plan that this task represents.
	Fragment *physicalpb.Plan `protobuf:"bytes,3,opt,name=fragment,proto3" json:"fragment,omitempty"`
	// Sources defines which streams physical nodes read from.
	// The key is the node ID string representation.
	Sources map[string]*StreamList `protobuf:"bytes,4,rep,name=sources,proto3" json:"sources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Sinks defines which streams physical nodes write to.
	// The key is the node ID string representation.
	Sinks map[string]*StreamList `protobuf:"bytes,5,rep,name=sinks,proto3" json:"sinks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The maximum boundary of timestamps that the task can possibly emit.
	// Does not account for predicates.
	// MaxTimeRange is not read when executing a task fragment. It can be used
	// as metadata to control execution (such as cancelling ongoing tasks based
	// on their maximum time range).
	MaxTimeRange *physicalpb.TimeRange `protobuf:"bytes,6,opt,name=max_time_range,json=maxTimeRange,proto3" json:"max_time_range,omitempty"`
}

func (m *Task) Reset()      { *m = Task{} }
func (*Task) ProtoMessage() {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{15}
}
func (m *Task) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Task.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return m.Size()
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

func (m *Task) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *Task) GetFragment() *physicalpb.Plan {
	if m != nil {
		return m.Fragment
	}
	return nil
}

func (m *Task) GetSources() map[string]*StreamList {
	if m != nil {
		return m.Sources
	}
	return nil
}

func (m *Task) GetSinks() map[string]*StreamList {
	if m != nil {
		return m.Sinks
	}
	return nil
}

func (m *Task) GetMaxTimeRange() *physicalpb.TimeRange {
	if m != nil {
		return m.MaxTimeRange
	}
	return nil
}

// StreamList is a list of streams, used in Task's sources and sinks maps.
type StreamList struct {
	Streams []*Stream `protobuf:"bytes,1,rep,name=streams,proto3" json:"streams,omitempty"`
}

func (m *StreamList) Reset()      { *m = StreamList{} }
func (*StreamList) ProtoMessage() {}
func (*StreamList) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{16}
}
func (m *StreamList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamList.Merge(m, src)
}
func (m *StreamList) XXX_Size() int {
	return m.Size()
}
func (m *StreamList) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamList.DiscardUnknown(m)
}

var xxx_messageInfo_StreamList proto.InternalMessageInfo

func (m *StreamList) GetStreams() []*Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

// Stream is an abstract representation of how data flows across task boundaries.
type Stream struct {
	Ulid     github_com_grafana_loki_v3_pkg_engine_internal_proto_ulid.ULID `protobuf:"bytes,1,opt,name=ulid,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/proto/ulid.ULID" json:"ulid"`
	TenantId string                                                         `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
}

func (m *Stream) Reset()      { *m = Stream{} }
func (*Stream) ProtoMessage() {}
func (*Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{17}
}
func (m *Stream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream.Merge(m, src)
}
func (m *Stream) XXX_Size() int {
	return m.Size()
}
func (m *Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_Stream proto.InternalMessageInfo

func (m *Stream) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

// TaskStatus represents the current status of a task.
type TaskStatus struct {
	State TaskState `protobuf:"varint,1,opt,name=state,proto3,enum=loki.wire.TaskState" json:"state,omitempty"`
	// Error is set only when state is TASK_STATE_FAILED.
	Error *TaskError `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Capture is the capture data for this task, if available.
	// This is an opaque binary representation of the capture payload.
	Capture               []byte                 `protobuf:"bytes,3,opt,name=capture,proto3" json:"capture,omitempty"`
	ContributingTimeRange *ContributingTimeRange `protobuf:"bytes,4,opt,name=contributing_time_range,json=contributingTimeRange,proto3" json:"contributing_time_range,omitempty"`
}

func (m *TaskStatus) Reset()      { *m = TaskStatus{} }
func (*TaskStatus) ProtoMessage() {}
func (*TaskStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{18}
}
func (m *TaskStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskStatus.Merge(m, src)
}
func (m *TaskStatus) XXX_Size() int {
	return m.Size()
}
func (m *TaskStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TaskStatus proto.InternalMessageInfo

func (m *TaskStatus) GetState() TaskState {
	if m != nil {
		return m.State
	}
	return TASK_STATE_INVALID
}

func (m *TaskStatus) GetError() *TaskError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *TaskStatus) GetCapture() []byte {
	if m != nil {
		return m.Capture
	}
	return nil
}

func (m *TaskStatus) GetContributingTimeRange() *ContributingTimeRange {
	if m != nil {
		return m.ContributingTimeRange
	}
	return nil
}

type ContributingTimeRange struct {
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	LessThan  bool      `protobuf:"varint,2,opt,name=less_than,json=lessThan,proto3" json:"less_than,omitempty"`
}

func (m *ContributingTimeRange) Reset()      { *m = ContributingTimeRange{} }
func (*ContributingTimeRange) ProtoMessage() {}
func (*ContributingTimeRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{19}
}
func (m *ContributingTimeRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContributingTimeRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContributingTimeRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContributingTimeRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContributingTimeRange.Merge(m, src)
}
func (m *ContributingTimeRange) XXX_Size() int {
	return m.Size()
}
func (m *ContributingTimeRange) XXX_DiscardUnknown() {
	xxx_messageInfo_ContributingTimeRange.DiscardUnknown(m)
}

var xxx_messageInfo_ContributingTimeRange proto.InternalMessageInfo

func (m *ContributingTimeRange) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *ContributingTimeRange) GetLessThan() bool {
	if m != nil {
		return m.LessThan
	}
	return false
}

type TaskError struct {
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *TaskError) Reset()      { *m = TaskError{} }
func (*TaskError) ProtoMessage() {}
func (*TaskError) Descriptor() ([]byte, []int) {
	return fileDescriptor_9956cb67d4b0d2a4, []int{20}
}
func (m *TaskError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskError.Merge(m, src)
}
func (m *TaskError) XXX_Size() int {
	return m.Size()
}
func (m *TaskError) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskError.DiscardUnknown(m)
}

var xxx_messageInfo_TaskError proto.InternalMessageInfo

func (m *TaskError) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func init() {
	proto.RegisterEnum("loki.wire.TaskState", TaskState_name, TaskState_value)
	proto.RegisterEnum("loki.wire.StreamState", StreamState_name, StreamState_value)
	proto.RegisterType((*Frame)(nil), "loki.wire.Frame")
	proto.RegisterType((*AckFrame)(nil), "loki.wire.AckFrame")
	proto.RegisterType((*NackFrame)(nil), "loki.wire.NackFrame")
	proto.RegisterType((*Error)(nil), "loki.wire.Error")
	proto.RegisterType((*DiscardFrame)(nil), "loki.wire.DiscardFrame")
	proto.RegisterType((*MessageFrame)(nil), "loki.wire.MessageFrame")
	proto.RegisterType((*WorkerHelloMessage)(nil), "loki.wire.WorkerHelloMessage")
	proto.RegisterType((*WorkerReadyMessage)(nil), "loki.wire.WorkerReadyMessage")
	proto.RegisterType((*TaskAssignMessage)(nil), "loki.wire.TaskAssignMessage")
	proto.RegisterMapType((map[string]StreamState)(nil), "loki.wire.TaskAssignMessage.StreamStatesEntry")
	proto.RegisterType((*TaskCancelMessage)(nil), "loki.wire.TaskCancelMessage")
	proto.RegisterType((*TaskFlagMessage)(nil), "loki.wire.TaskFlagMessage")
	proto.RegisterType((*TaskStatusMessage)(nil), "loki.wire.TaskStatusMessage")
	proto.RegisterType((*StreamBindMessage)(nil), "loki.wire.StreamBindMessage")
	proto.RegisterType((*StreamDataMessage)(nil), "loki.wire.StreamDataMessage")
	proto.RegisterType((*StreamStatusMessage)(nil), "loki.wire.StreamStatusMessage")
	proto.RegisterType((*Task)(nil), "loki.wire.Task")
	proto.RegisterMapType((map[string]*StreamList)(nil), "loki.wire.Task.SinksEntry")
	proto.RegisterMapType((map[string]*StreamList)(nil), "loki.wire.Task.SourcesEntry")
	proto.RegisterType((*StreamList)(nil), "loki.wire.StreamList")
	proto.RegisterType((*Stream)(nil), "loki.wire.Stream")
	proto.RegisterType((*TaskStatus)(nil), "loki.wire.TaskStatus")
	proto.RegisterType((*ContributingTimeRange)(nil), "loki.wire.ContributingTimeRange")
	proto.RegisterType((*TaskError)(nil), "loki.wire.TaskError")
}

func init() {
	proto.RegisterFile("pkg/engine/internal/proto/wirepb/wirepb.proto", fileDescriptor_9956cb67d4b0d2a4)
}

var fileDescriptor_9956cb67d4b0d2a4 = []byte{
	// 1448 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x41, 0x6c, 0x1b, 0x45,
	0x17, 0xf6, 0xda, 0xeb, 0xc4, 0x7e, 0x71, 0x5b, 0x67, 0x9a, 0xb4, 0x96, 0xff, 0xff, 0xdf, 0x44,
	0xfb, 0x23, 0x28, 0x69, 0x6b, 0x97, 0x46, 0x45, 0x14, 0xa4, 0x22, 0x3b, 0x76, 0x88, 0xa9, 0xeb,
	0x84, 0xb5, 0x4b, 0x11, 0x17, 0x6b, 0xbc, 0x3b, 0xd9, 0xac, 0x6c, 0xef, 0x9a, 0xdd, 0x71, 0xda,
	0x48, 0x1c, 0x38, 0x70, 0xe0, 0xd8, 0x03, 0x12, 0x12, 0x77, 0xa4, 0x5e, 0xb8, 0x22, 0x71, 0xe4,
	0xd6, 0x13, 0xea, 0xb1, 0xe2, 0x50, 0x68, 0x7a, 0xe1, 0xd8, 0x0b, 0x77, 0x34, 0xb3, 0xeb, 0xf5,
	0x78, 0xd7, 0x2d, 0x12, 0x42, 0x29, 0x97, 0x64, 0xf7, 0x7b, 0xdf, 0xfb, 0xe6, 0xcd, 0x9b, 0x37,
	0x6f, 0x66, 0x0d, 0x97, 0x47, 0x7d, 0xb3, 0x4c, 0x6c, 0xd3, 0xb2, 0x49, 0xd9, 0xb2, 0x29, 0x71,
	0x6d, 0x3c, 0x28, 0x8f, 0x5c, 0x87, 0x3a, 0xe5, 0xbb, 0x96, 0x4b, 0x46, 0xbd, 0xe0, 0x5f, 0x89,
	0x63, 0x28, 0x3b, 0x70, 0xfa, 0x56, 0x89, 0x41, 0xc5, 0x2b, 0xa6, 0x45, 0x0f, 0xc6, 0xbd, 0x92,
	0xee, 0x0c, 0xcb, 0xa6, 0x8b, 0xf7, 0xb1, 0x8d, 0xcb, 0x86, 0xd7, 0xb7, 0x68, 0xf9, 0x80, 0xd2,
	0x91, 0xe9, 0x8e, 0xf4, 0xf0, 0xc1, 0x77, 0x2e, 0xae, 0x98, 0x8e, 0xe9, 0xf8, 0xda, 0xec, 0x29,
	0x40, 0xd7, 0x4c, 0xc7, 0x31, 0x07, 0xc4, 0x1f, 0xb4, 0x37, 0xde, 0x2f, 0x53, 0x6b, 0x48, 0x3c,
	0x8a, 0x87, 0xa3, 0x80, 0x70, 0xed, 0xc5, 0x21, 0x8e, 0x0e, 0x8e, 0x3c, 0x4b, 0xc7, 0x83, 0x51,
	0x4f, 0x78, 0x0c, 0xdc, 0xde, 0x7c, 0xb1, 0xdb, 0x78, 0x60, 0x19, 0xfc, 0x8f, 0x4f, 0x55, 0x7f,
	0x96, 0x20, 0xbd, 0xed, 0xe2, 0x21, 0x41, 0x6f, 0x40, 0x0a, 0xeb, 0xfd, 0x82, 0xb4, 0x2e, 0x5d,
	0x58, 0xba, 0x7a, 0xb6, 0x14, 0xce, 0xb6, 0x54, 0xd1, 0xfb, 0x9c, 0xb1, 0x93, 0xd0, 0x18, 0x03,
	0x6d, 0x80, 0x6c, 0x33, 0x66, 0x92, 0x33, 0x57, 0x04, 0x66, 0x0b, 0x4f, 0xa9, 0x9c, 0x83, 0x36,
	0x61, 0xd1, 0xb0, 0x3c, 0x1d, 0xbb, 0x46, 0x21, 0xc5, 0xe9, 0xe7, 0x05, 0x7a, 0xcd, 0xb7, 0x4c,
	0x3c, 0x26, 0x4c, 0xe6, 0x34, 0x24, 0x9e, 0x87, 0x4d, 0x52, 0x90, 0x63, 0x4e, 0xb7, 0x7c, 0x4b,
	0xe8, 0x14, 0x30, 0xab, 0x0b, 0x20, 0xf7, 0x2d, 0xdb, 0x50, 0x8b, 0x90, 0x99, 0x04, 0x8c, 0x4e,
	0x43, 0xd2, 0x32, 0xf8, 0x8c, 0x64, 0x2d, 0x69, 0x19, 0x6a, 0x03, 0xb2, 0x61, 0x88, 0x51, 0x23,
	0x7a, 0x1d, 0xd2, 0xc4, 0x75, 0x1d, 0x37, 0x08, 0x34, 0x2f, 0x8c, 0x59, 0x67, 0xb8, 0xe6, 0x9b,
	0x3f, 0x94, 0x33, 0xc9, 0x7c, 0x4a, 0xbd, 0x06, 0x69, 0x8e, 0x22, 0x04, 0xb2, 0xee, 0x18, 0x84,
	0x0b, 0xa5, 0x35, 0xfe, 0x8c, 0x0a, 0xd3, 0x09, 0xb0, 0x24, 0x65, 0xc3, 0x28, 0x55, 0x05, 0x72,
	0xe2, 0xac, 0x63, 0x11, 0xfe, 0x21, 0x43, 0x4e, 0x9c, 0x61, 0x2c, 0xca, 0x2a, 0xe4, 0xee, 0x3a,
	0x6e, 0x9f, 0xb8, 0xdd, 0x03, 0x32, 0x18, 0x38, 0x05, 0xe0, 0xc1, 0xfe, 0x4f, 0x08, 0xf6, 0x0e,
	0x37, 0xef, 0x30, 0x6b, 0xa0, 0xb4, 0x93, 0xd0, 0x96, 0xee, 0x4e, 0x51, 0x41, 0xc3, 0x25, 0xd8,
	0x38, 0x0a, 0x16, 0x32, 0xae, 0xa1, 0x31, 0x6b, 0x4c, 0x83, 0xa3, 0xe8, 0x7d, 0x58, 0xa2, 0xd8,
	0xeb, 0x77, 0xb1, 0xe7, 0x59, 0xa6, 0x1d, 0xe4, 0xec, 0xbf, 0x82, 0x44, 0x07, 0x7b, 0xfd, 0x0a,
	0x37, 0x4e, 0x15, 0x80, 0x86, 0x60, 0x28, 0xa0, 0x63, 0x5b, 0x27, 0x83, 0x60, 0xa1, 0xa3, 0x02,
	0x5b, 0xdc, 0x18, 0x11, 0xf0, 0x41, 0x74, 0x1d, 0xb2, 0x5c, 0x60, 0x7f, 0x80, 0xcd, 0x42, 0x9a,
	0xbb, 0x17, 0x23, 0xee, 0xdb, 0x03, 0x6c, 0x4e, 0x9d, 0x33, 0x34, 0x80, 0xc2, 0xb1, 0x3d, 0x8a,
	0xe9, 0xd8, 0x2b, 0x2c, 0xcc, 0x1d, 0xbb, 0xcd, 0x8d, 0x91, 0xb1, 0x7d, 0x90, 0x09, 0x78, 0xd4,
	0x25, 0x78, 0xd8, 0xed, 0x59, 0xb6, 0x51, 0x58, 0x8c, 0x09, 0xb4, 0xb9, 0xb5, 0x6a, 0xd9, 0x86,
	0x20, 0xe0, 0x85, 0xa0, 0x20, 0x60, 0x60, 0x8a, 0x0b, 0x99, 0x17, 0x08, 0xd4, 0x30, 0xc5, 0x31,
	0x01, 0x06, 0xa2, 0x3a, 0x9c, 0x0a, 0x04, 0x82, 0x49, 0x64, 0xb9, 0x84, 0x12, 0x93, 0x88, 0x4e,
	0x23, 0xe7, 0x09, 0x70, 0xb8, 0x6b, 0x4a, 0x80, 0xe2, 0x75, 0xc3, 0xea, 0x98, 0x1e, 0xb0, 0x1a,
	0xf1, 0x82, 0x0a, 0x9c, 0xbc, 0xaa, 0x2b, 0x13, 0xbe, 0x58, 0x23, 0xea, 0xd7, 0x49, 0x58, 0x8e,
	0xad, 0x3b, 0xfa, 0x3f, 0xc8, 0x2c, 0x75, 0x41, 0x67, 0x39, 0x13, 0x49, 0xb3, 0xc6, 0x8d, 0xa8,
	0x3d, 0x33, 0x1f, 0xe2, 0x15, 0x92, 0xeb, 0xa9, 0x0b, 0x4b, 0x57, 0x4b, 0x2f, 0xab, 0x28, 0x61,
	0x86, 0xc4, 0xab, 0xdb, 0xd4, 0x3d, 0x12, 0x67, 0x47, 0x3c, 0x74, 0x09, 0x32, 0x43, 0x42, 0x31,
	0x4f, 0x71, 0x8a, 0xeb, 0xe5, 0x4b, 0x61, 0x63, 0xde, 0x21, 0xd8, 0x20, 0xae, 0x16, 0x32, 0x8a,
	0x77, 0x60, 0x39, 0x26, 0x88, 0xf2, 0x90, 0xea, 0x93, 0x23, 0x1e, 0x7b, 0x56, 0x63, 0x8f, 0xe8,
	0x12, 0xa4, 0x0f, 0xf1, 0x60, 0xec, 0x6f, 0xed, 0xd3, 0x57, 0xcf, 0xcd, 0xcd, 0x38, 0xd1, 0x7c,
	0xd2, 0xbb, 0xc9, 0x77, 0x24, 0xf5, 0x4b, 0xc9, 0x4f, 0xcb, 0x4c, 0x35, 0x23, 0x27, 0xdc, 0xd9,
	0xac, 0xc1, 0xf1, 0x96, 0xcc, 0x95, 0x0e, 0xdf, 0x2a, 0xed, 0xb1, 0xd6, 0x7c, 0xbb, 0xd9, 0xa8,
	0x55, 0xb7, 0x1f, 0x3e, 0x59, 0x4b, 0xfc, 0xf2, 0x64, 0xed, 0xc6, 0x9c, 0x13, 0x87, 0xb1, 0xcb,
	0x87, 0x9b, 0xe5, 0x97, 0x37, 0xfb, 0x12, 0xd3, 0xe1, 0xbd, 0xe5, 0x81, 0x04, 0x67, 0x22, 0xbb,
	0xe2, 0xc4, 0x83, 0x40, 0xaf, 0xc1, 0x29, 0x6e, 0x77, 0xc7, 0x23, 0x6a, 0xf5, 0x06, 0x7e, 0x16,
	0x33, 0xda, 0x2c, 0xa8, 0xfe, 0x18, 0x64, 0x6c, 0xa6, 0x78, 0x4f, 0x3e, 0xd8, 0x4d, 0x58, 0x08,
	0x76, 0x97, 0xdf, 0x22, 0x57, 0xe7, 0xb6, 0x88, 0xaa, 0xcc, 0x86, 0xd4, 0x02, 0xaa, 0xfa, 0xbd,
	0x34, 0xa9, 0x23, 0x61, 0xfb, 0xa3, 0xcf, 0x21, 0x1b, 0xd4, 0xf7, 0xc9, 0x4d, 0x21, 0xe3, 0x8f,
	0xd8, 0x30, 0x50, 0x11, 0x32, 0x2e, 0xd1, 0x89, 0x75, 0x48, 0xdc, 0xe0, 0x44, 0x0a, 0xdf, 0xd5,
	0xef, 0xc2, 0x78, 0x85, 0x6e, 0xf3, 0x8a, 0xe3, 0x45, 0x20, 0xf3, 0x4d, 0xcb, 0x62, 0xcd, 0x69,
	0xfc, 0x59, 0xfd, 0x49, 0x82, 0xb3, 0x73, 0x5a, 0xda, 0x2b, 0x8e, 0xf4, 0x12, 0xa4, 0x79, 0xc3,
	0xfa, 0xab, 0x6e, 0xc0, 0x49, 0xea, 0x37, 0x32, 0xc8, 0xac, 0x70, 0x90, 0x07, 0x32, 0x53, 0x3b,
	0xa9, 0x78, 0xf9, 0x60, 0xe8, 0x3f, 0x90, 0xa5, 0xc4, 0xc6, 0x36, 0x65, 0x99, 0x0a, 0xca, 0xc0,
	0x07, 0x1a, 0x06, 0x2a, 0x43, 0x66, 0xdf, 0xc5, 0xe6, 0x90, 0xd8, 0x34, 0x38, 0xcd, 0x83, 0x3b,
	0xe0, 0xe4, 0x76, 0x59, 0xda, 0x1b, 0x60, 0x5b, 0x0b, 0x49, 0xe8, 0x6d, 0x58, 0xf4, 0x9c, 0xb1,
	0xab, 0x13, 0xaf, 0x20, 0xf3, 0xde, 0x1a, 0x3d, 0x40, 0x4b, 0x6d, 0xdf, 0xec, 0x77, 0xe6, 0x09,
	0x19, 0x5d, 0x81, 0xb4, 0x67, 0xd9, 0x7d, 0xaf, 0x90, 0xe6, 0x5e, 0xc5, 0x98, 0x17, 0x33, 0xfa,
	0x3e, 0x3e, 0x11, 0xdd, 0x80, 0xd3, 0x43, 0x7c, 0xaf, 0xcb, 0x2e, 0xc7, 0x5d, 0x17, 0xdb, 0x26,
	0x09, 0x4e, 0xec, 0x42, 0x24, 0xc0, 0x8e, 0x35, 0x24, 0x1a, 0xb3, 0x6b, 0xb9, 0x21, 0xbe, 0x17,
	0xbe, 0x15, 0x3f, 0x82, 0x9c, 0x18, 0xca, 0x9c, 0x9e, 0x7e, 0x51, 0xec, 0xe9, 0xb3, 0xfb, 0xdc,
	0x5f, 0xc5, 0xa6, 0xe5, 0x51, 0xa1, 0xa5, 0x17, 0x77, 0x01, 0xa6, 0x71, 0xfe, 0x03, 0x82, 0xea,
	0x75, 0x80, 0xa9, 0x01, 0x5d, 0x84, 0x45, 0xbf, 0xc2, 0xd8, 0xc1, 0xcb, 0xb2, 0xb4, 0x1c, 0x13,
	0xd0, 0x26, 0x0c, 0xf5, 0x5b, 0x09, 0x16, 0x7c, 0xec, 0xdf, 0x57, 0x56, 0xea, 0x63, 0x09, 0x60,
	0xda, 0x2a, 0xd1, 0xc6, 0x64, 0xbb, 0x48, 0x7c, 0xbb, 0xac, 0xcc, 0x69, 0xa8, 0x93, 0xcd, 0xc2,
	0xb8, 0xfe, 0x85, 0x3c, 0xfe, 0xa1, 0xc1, 0xb8, 0xe2, 0xa5, 0x9c, 0xdd, 0x54, 0x74, 0x3c, 0xa2,
	0x63, 0x97, 0xf0, 0xe2, 0xcd, 0x69, 0x93, 0x57, 0xf4, 0x09, 0x9c, 0xd7, 0x1d, 0x9b, 0xba, 0x56,
	0x6f, 0x4c, 0x2d, 0xdb, 0x14, 0xab, 0xc8, 0xbf, 0x73, 0xae, 0x0b, 0xba, 0x5b, 0x02, 0x73, 0x5a,
	0x4d, 0xab, 0xfa, 0x3c, 0x58, 0xbd, 0x07, 0xab, 0x73, 0xf9, 0xa8, 0x0a, 0xd9, 0xf0, 0x43, 0x2e,
	0x58, 0x8a, 0x62, 0xc9, 0xff, 0xd4, 0x2b, 0x4d, 0x3e, 0xf5, 0x78, 0xb1, 0x72, 0x46, 0x35, 0xc3,
	0x56, 0xe3, 0xfe, 0xaf, 0x6b, 0x92, 0x36, 0x75, 0x63, 0x49, 0x1d, 0x10, 0xcf, 0xeb, 0xd2, 0x03,
	0x6c, 0x07, 0x67, 0x64, 0x86, 0x01, 0x9d, 0x03, 0x6c, 0xab, 0x97, 0x21, 0x1b, 0x66, 0x00, 0xad,
	0xc3, 0x92, 0x41, 0x3c, 0xdd, 0xb5, 0x46, 0xd4, 0x72, 0xec, 0xa0, 0x08, 0x45, 0x68, 0xe3, 0x07,
	0xc9, 0xe7, 0xf3, 0xec, 0xa2, 0x73, 0x80, 0x3a, 0x95, 0xf6, 0xcd, 0x6e, 0xbb, 0x53, 0xe9, 0xd4,
	0xbb, 0x8d, 0xd6, 0xc7, 0x95, 0x66, 0xa3, 0x96, 0x4f, 0x44, 0xf0, 0x2d, 0xad, 0x5e, 0xe9, 0xd4,
	0x6b, 0x79, 0x29, 0x82, 0xef, 0xd5, 0x5b, 0xb5, 0x46, 0xeb, 0x83, 0x7c, 0x32, 0x82, 0x6b, 0xb7,
	0x5b, 0x2d, 0x86, 0xa7, 0x50, 0x01, 0x56, 0x44, 0x9d, 0xdd, 0x5b, 0x7b, 0xcd, 0x3a, 0x53, 0x92,
	0xa3, 0x96, 0x4a, 0x6b, 0xab, 0xde, 0x6c, 0xd6, 0x6b, 0xf9, 0x34, 0x5a, 0x85, 0x65, 0xc1, 0xb2,
	0x5d, 0x69, 0x30, 0x78, 0x61, 0xe3, 0x2b, 0x09, 0x96, 0x84, 0x2e, 0xca, 0x04, 0xda, 0x1d, 0xad,
	0x5e, 0xb9, 0x15, 0x0b, 0x7e, 0x15, 0x96, 0x67, 0x2d, 0xb5, 0x66, 0x3d, 0x2f, 0xc5, 0xe0, 0xdd,
	0xbd, 0x7a, 0x2b, 0x9f, 0x8c, 0xe9, 0x54, 0x9b, 0xbb, 0x5b, 0x37, 0xeb, 0xb5, 0x7c, 0x0a, 0x9d,
	0x87, 0xb3, 0x33, 0x96, 0xad, 0xe6, 0x6e, 0x9b, 0xc5, 0x5e, 0xfd, 0xec, 0xd1, 0x53, 0x25, 0xf1,
	0xf8, 0xa9, 0x92, 0x78, 0xfe, 0x54, 0x91, 0xbe, 0x38, 0x56, 0xa4, 0x07, 0xc7, 0x8a, 0xf4, 0xf0,
	0x58, 0x91, 0x1e, 0x1d, 0x2b, 0xd2, 0x6f, 0xc7, 0x8a, 0xf4, 0xfb, 0xb1, 0x92, 0x78, 0x7e, 0xac,
	0x48, 0xf7, 0x9f, 0x29, 0x89, 0x47, 0xcf, 0x94, 0xc4, 0xe3, 0x67, 0x4a, 0xe2, 0xd3, 0xf7, 0xfe,
	0xd6, 0x06, 0xf3, 0x7f, 0x76, 0xe8, 0x2d, 0xf0, 0xb7, 0xcd, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff,
	0x1d, 0xd2, 0xe9, 0xea, 0xa8, 0x10, 0x00, 0x00,
}

func (x TaskState) String() string {
	s, ok := TaskState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StreamState) String() string {
	s, ok := StreamState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Frame) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Frame)
	if !ok {
		that2, ok := that.(Frame)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *Frame_Ack) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Frame_Ack)
	if !ok {
		that2, ok := that.(Frame_Ack)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ack.Equal(that1.Ack) {
		return false
	}
	return true
}
func (this *Frame_Nack) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Frame_Nack)
	if !ok {
		that2, ok := that.(Frame_Nack)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Nack.Equal(that1.Nack) {
		return false
	}
	return true
}
func (this *Frame_Discard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Frame_Discard)
	if !ok {
		that2, ok := that.(Frame_Discard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Discard.Equal(that1.Discard) {
		return false
	}
	return true
}
func (this *Frame_Message) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Frame_Message)
	if !ok {
		that2, ok := that.(Frame_Message)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Message.Equal(that1.Message) {
		return false
	}
	return true
}
func (this *AckFrame) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AckFrame)
	if !ok {
		that2, ok := that.(AckFrame)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *NackFrame) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NackFrame)
	if !ok {
		that2, ok := that.(NackFrame)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (this *Error) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Error)
	if !ok {
		that2, ok := that.(Error)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *DiscardFrame) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscardFrame)
	if !ok {
		that2, ok := that.(DiscardFrame)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *MessageFrame) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame)
	if !ok {
		that2, ok := that.(MessageFrame)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *MessageFrame_WorkerHello) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_WorkerHello)
	if !ok {
		that2, ok := that.(MessageFrame_WorkerHello)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WorkerHello.Equal(that1.WorkerHello) {
		return false
	}
	return true
}
func (this *MessageFrame_WorkerReady) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_WorkerReady)
	if !ok {
		that2, ok := that.(MessageFrame_WorkerReady)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WorkerReady.Equal(that1.WorkerReady) {
		return false
	}
	return true
}
func (this *MessageFrame_TaskAssign) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_TaskAssign)
	if !ok {
		that2, ok := that.(MessageFrame_TaskAssign)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TaskAssign.Equal(that1.TaskAssign) {
		return false
	}
	return true
}
func (this *MessageFrame_TaskCancel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_TaskCancel)
	if !ok {
		that2, ok := that.(MessageFrame_TaskCancel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TaskCancel.Equal(that1.TaskCancel) {
		return false
	}
	return true
}
func (this *MessageFrame_TaskFlag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_TaskFlag)
	if !ok {
		that2, ok := that.(MessageFrame_TaskFlag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TaskFlag.Equal(that1.TaskFlag) {
		return false
	}
	return true
}
func (this *MessageFrame_TaskStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_TaskStatus)
	if !ok {
		that2, ok := that.(MessageFrame_TaskStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TaskStatus.Equal(that1.TaskStatus) {
		return false
	}
	return true
}
func (this *MessageFrame_StreamBind) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_StreamBind)
	if !ok {
		that2, ok := that.(MessageFrame_StreamBind)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StreamBind.Equal(that1.StreamBind) {
		return false
	}
	return true
}
func (this *MessageFrame_StreamData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_StreamData)
	if !ok {
		that2, ok := that.(MessageFrame_StreamData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StreamData.Equal(that1.StreamData) {
		return false
	}
	return true
}
func (this *MessageFrame_StreamStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageFrame_StreamStatus)
	if !ok {
		that2, ok := that.(MessageFrame_StreamStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StreamStatus.Equal(that1.StreamStatus) {
		return false
	}
	return true
}
func (this *WorkerHelloMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WorkerHelloMessage)
	if !ok {
		that2, ok := that.(WorkerHelloMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Threads != that1.Threads {
		return false
	}
	return true
}
func (this *WorkerReadyMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WorkerReadyMessage)
	if !ok {
		that2, ok := that.(WorkerReadyMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *TaskAssignMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskAssignMessage)
	if !ok {
		that2, ok := that.(TaskAssignMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Task.Equal(that1.Task) {
		return false
	}
	if len(this.StreamStates) != len(that1.StreamStates) {
		return false
	}
	for i := range this.StreamStates {
		if this.StreamStates[i] != that1.StreamStates[i] {
			return false
		}
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if !this.Metadata[i].Equal(that1.Metadata[i]) {
			return false
		}
	}
	return true
}
func (this *TaskCancelMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskCancelMessage)
	if !ok {
		that2, ok := that.(TaskCancelMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	return true
}
func (this *TaskFlagMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskFlagMessage)
	if !ok {
		that2, ok := that.(TaskFlagMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if this.Interruptible != that1.Interruptible {
		return false
	}
	return true
}
func (this *TaskStatusMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskStatusMessage)
	if !ok {
		that2, ok := that.(TaskStatusMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	return true
}
func (this *StreamBindMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamBindMessage)
	if !ok {
		that2, ok := that.(StreamBindMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StreamId.Equal(that1.StreamId) {
		return false
	}
	if this.Receiver != that1.Receiver {
		return false
	}
	return true
}
func (this *StreamDataMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamDataMessage)
	if !ok {
		that2, ok := that.(StreamDataMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StreamId.Equal(that1.StreamId) {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *StreamStatusMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamStatusMessage)
	if !ok {
		that2, ok := that.(StreamStatusMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StreamId.Equal(that1.StreamId) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *Task) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Task)
	if !ok {
		that2, ok := that.(Task)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ulid.Equal(that1.Ulid) {
		return false
	}
	if this.TenantId != that1.TenantId {
		return false
	}
	if !this.Fragment.Equal(that1.Fragment) {
		return false
	}
	if len(this.Sources) != len(that1.Sources) {
		return false
	}
	for i := range this.Sources {
		if !this.Sources[i].Equal(that1.Sources[i]) {
			return false
		}
	}
	if len(this.Sinks) != len(that1.Sinks) {
		return false
	}
	for i := range this.Sinks {
		if !this.Sinks[i].Equal(that1.Sinks[i]) {
			return false
		}
	}
	if !this.MaxTimeRange.Equal(that1.MaxTimeRange) {
		return false
	}
	return true
}
func (this *StreamList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamList)
	if !ok {
		that2, ok := that.(StreamList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Streams) != len(that1.Streams) {
		return false
	}
	for i := range this.Streams {
		if !this.Streams[i].Equal(that1.Streams[i]) {
			return false
		}
	}
	return true
}
func (this *Stream) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Stream)
	if !ok {
		that2, ok := that.(Stream)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ulid.Equal(that1.Ulid) {
		return false
	}
	if this.TenantId != that1.TenantId {
		return false
	}
	return true
}
func (this *TaskStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskStatus)
	if !ok {
		that2, ok := that.(TaskStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if !this.Error.Equal(that1.Error) {
		return false
	}
	if !bytes.Equal(this.Capture, that1.Capture) {
		return false
	}
	if !this.ContributingTimeRange.Equal(that1.ContributingTimeRange) {
		return false
	}
	return true
}
func (this *ContributingTimeRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContributingTimeRange)
	if !ok {
		that2, ok := that.(ContributingTimeRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.LessThan != that1.LessThan {
		return false
	}
	return true
}
func (this *TaskError) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskError)
	if !ok {
		that2, ok := that.(TaskError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *Frame) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wirepb.Frame{")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Frame_Ack) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.Frame_Ack{` +
		`Ack:` + fmt.Sprintf("%#v", this.Ack) + `}`}, ", ")
	return s
}
func (this *Frame_Nack) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.Frame_Nack{` +
		`Nack:` + fmt.Sprintf("%#v", this.Nack) + `}`}, ", ")
	return s
}
func (this *Frame_Discard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.Frame_Discard{` +
		`Discard:` + fmt.Sprintf("%#v", this.Discard) + `}`}, ", ")
	return s
}
func (this *Frame_Message) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.Frame_Message{` +
		`Message:` + fmt.Sprintf("%#v", this.Message) + `}`}, ", ")
	return s
}
func (this *AckFrame) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wirepb.AckFrame{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NackFrame) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.NackFrame{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Error) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.Error{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscardFrame) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wirepb.DiscardFrame{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageFrame) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&wirepb.MessageFrame{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageFrame_WorkerHello) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_WorkerHello{` +
		`WorkerHello:` + fmt.Sprintf("%#v", this.WorkerHello) + `}`}, ", ")
	return s
}
func (this *MessageFrame_WorkerReady) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_WorkerReady{` +
		`WorkerReady:` + fmt.Sprintf("%#v", this.WorkerReady) + `}`}, ", ")
	return s
}
func (this *MessageFrame_TaskAssign) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_TaskAssign{` +
		`TaskAssign:` + fmt.Sprintf("%#v", this.TaskAssign) + `}`}, ", ")
	return s
}
func (this *MessageFrame_TaskCancel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_TaskCancel{` +
		`TaskCancel:` + fmt.Sprintf("%#v", this.TaskCancel) + `}`}, ", ")
	return s
}
func (this *MessageFrame_TaskFlag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_TaskFlag{` +
		`TaskFlag:` + fmt.Sprintf("%#v", this.TaskFlag) + `}`}, ", ")
	return s
}
func (this *MessageFrame_TaskStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_TaskStatus{` +
		`TaskStatus:` + fmt.Sprintf("%#v", this.TaskStatus) + `}`}, ", ")
	return s
}
func (this *MessageFrame_StreamBind) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_StreamBind{` +
		`StreamBind:` + fmt.Sprintf("%#v", this.StreamBind) + `}`}, ", ")
	return s
}
func (this *MessageFrame_StreamData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_StreamData{` +
		`StreamData:` + fmt.Sprintf("%#v", this.StreamData) + `}`}, ", ")
	return s
}
func (this *MessageFrame_StreamStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&wirepb.MessageFrame_StreamStatus{` +
		`StreamStatus:` + fmt.Sprintf("%#v", this.StreamStatus) + `}`}, ", ")
	return s
}
func (this *WorkerHelloMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wirepb.WorkerHelloMessage{")
	s = append(s, "Threads: "+fmt.Sprintf("%#v", this.Threads)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WorkerReadyMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&wirepb.WorkerReadyMessage{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskAssignMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&wirepb.TaskAssignMessage{")
	if this.Task != nil {
		s = append(s, "Task: "+fmt.Sprintf("%#v", this.Task)+",\n")
	}
	keysForStreamStates := make([]string, 0, len(this.StreamStates))
	for k, _ := range this.StreamStates {
		keysForStreamStates = append(keysForStreamStates, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStreamStates)
	mapStringForStreamStates := "map[string]StreamState{"
	for _, k := range keysForStreamStates {
		mapStringForStreamStates += fmt.Sprintf("%#v: %#v,", k, this.StreamStates[k])
	}
	mapStringForStreamStates += "}"
	if this.StreamStates != nil {
		s = append(s, "StreamStates: "+mapStringForStreamStates+",\n")
	}
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskCancelMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wirepb.TaskCancelMessage{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskFlagMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.TaskFlagMessage{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Interruptible: "+fmt.Sprintf("%#v", this.Interruptible)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskStatusMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.TaskStatusMessage{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Status: "+strings.Replace(this.Status.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamBindMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.StreamBindMessage{")
	s = append(s, "StreamId: "+fmt.Sprintf("%#v", this.StreamId)+",\n")
	s = append(s, "Receiver: "+fmt.Sprintf("%#v", this.Receiver)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamDataMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.StreamDataMessage{")
	s = append(s, "StreamId: "+fmt.Sprintf("%#v", this.StreamId)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamStatusMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.StreamStatusMessage{")
	s = append(s, "StreamId: "+fmt.Sprintf("%#v", this.StreamId)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Task) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&wirepb.Task{")
	s = append(s, "Ulid: "+fmt.Sprintf("%#v", this.Ulid)+",\n")
	s = append(s, "TenantId: "+fmt.Sprintf("%#v", this.TenantId)+",\n")
	if this.Fragment != nil {
		s = append(s, "Fragment: "+fmt.Sprintf("%#v", this.Fragment)+",\n")
	}
	keysForSources := make([]string, 0, len(this.Sources))
	for k, _ := range this.Sources {
		keysForSources = append(keysForSources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSources)
	mapStringForSources := "map[string]*StreamList{"
	for _, k := range keysForSources {
		mapStringForSources += fmt.Sprintf("%#v: %#v,", k, this.Sources[k])
	}
	mapStringForSources += "}"
	if this.Sources != nil {
		s = append(s, "Sources: "+mapStringForSources+",\n")
	}
	keysForSinks := make([]string, 0, len(this.Sinks))
	for k, _ := range this.Sinks {
		keysForSinks = append(keysForSinks, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSinks)
	mapStringForSinks := "map[string]*StreamList{"
	for _, k := range keysForSinks {
		mapStringForSinks += fmt.Sprintf("%#v: %#v,", k, this.Sinks[k])
	}
	mapStringForSinks += "}"
	if this.Sinks != nil {
		s = append(s, "Sinks: "+mapStringForSinks+",\n")
	}
	if this.MaxTimeRange != nil {
		s = append(s, "MaxTimeRange: "+fmt.Sprintf("%#v", this.MaxTimeRange)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wirepb.StreamList{")
	if this.Streams != nil {
		s = append(s, "Streams: "+fmt.Sprintf("%#v", this.Streams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Stream) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.Stream{")
	s = append(s, "Ulid: "+fmt.Sprintf("%#v", this.Ulid)+",\n")
	s = append(s, "TenantId: "+fmt.Sprintf("%#v", this.TenantId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&wirepb.TaskStatus{")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.Error != nil {
		s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	}
	s = append(s, "Capture: "+fmt.Sprintf("%#v", this.Capture)+",\n")
	if this.ContributingTimeRange != nil {
		s = append(s, "ContributingTimeRange: "+fmt.Sprintf("%#v", this.ContributingTimeRange)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContributingTimeRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&wirepb.ContributingTimeRange{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "LessThan: "+fmt.Sprintf("%#v", this.LessThan)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&wirepb.TaskError{")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringWirepb(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Frame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Frame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Frame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Frame_Ack) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Frame_Ack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ack != nil {
		{
			size, err := m.Ack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Frame_Nack) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Frame_Nack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Nack != nil {
		{
			size, err := m.Nack.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Frame_Discard) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Frame_Discard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Discard != nil {
		{
			size, err := m.Discard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Frame_Message) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Frame_Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AckFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckFrame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AckFrame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintWirepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NackFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NackFrame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NackFrame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintWirepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintWirepb(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintWirepb(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiscardFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscardFrame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscardFrame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintWirepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageFrame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageFrame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Id != 0 {
		i = encodeVarintWirepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageFrame_WorkerReady) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_WorkerReady) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WorkerReady != nil {
		{
			size, err := m.WorkerReady.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MessageFrame_TaskAssign) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_TaskAssign) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TaskAssign != nil {
		{
			size, err := m.TaskAssign.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MessageFrame_TaskCancel) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_TaskCancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TaskCancel != nil {
		{
			size, err := m.TaskCancel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MessageFrame_TaskFlag) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_TaskFlag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TaskFlag != nil {
		{
			size, err := m.TaskFlag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *MessageFrame_TaskStatus) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_TaskStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TaskStatus != nil {
		{
			size, err := m.TaskStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *MessageFrame_StreamBind) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_StreamBind) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StreamBind != nil {
		{
			size, err := m.StreamBind.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *MessageFrame_StreamData) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_StreamData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StreamData != nil {
		{
			size, err := m.StreamData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *MessageFrame_StreamStatus) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_StreamStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StreamStatus != nil {
		{
			size, err := m.StreamStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *MessageFrame_WorkerHello) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *MessageFrame_WorkerHello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WorkerHello != nil {
		{
			size, err := m.WorkerHello.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *WorkerHelloMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerHelloMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerHelloMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threads != 0 {
		i = encodeVarintWirepb(dAtA, i, uint64(m.Threads))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkerReadyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerReadyMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerReadyMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TaskAssignMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskAssignMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskAssignMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for iNdEx := len(m.Metadata) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metadata[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWirepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.StreamStates) > 0 {
		for k := range m.StreamStates {
			v := m.StreamStates[k]
			baseI := i
			i = encodeVarintWirepb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintWirepb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintWirepb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Task != nil {
		{
			size, err := m.Task.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskCancelMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskCancelMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskCancelMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TaskFlagMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskFlagMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskFlagMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Interruptible {
		i--
		if m.Interruptible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TaskStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskStatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Id.Size()
		i -= size
		if _, err := m.Id.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StreamBindMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamBindMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamBindMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintWirepb(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.StreamId.Size()
		i -= size
		if _, err := m.StreamId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StreamDataMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamDataMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamDataMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintWirepb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.StreamId.Size()
		i -= size
		if _, err := m.StreamId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StreamStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamStatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintWirepb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.StreamId.Size()
		i -= size
		if _, err := m.StreamId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Task) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Task) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxTimeRange != nil {
		{
			size, err := m.MaxTimeRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Sinks) > 0 {
		for k := range m.Sinks {
			v := m.Sinks[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintWirepb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintWirepb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintWirepb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Sources) > 0 {
		for k := range m.Sources {
			v := m.Sources[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintWirepb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintWirepb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintWirepb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Fragment != nil {
		{
			size, err := m.Fragment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TenantId) > 0 {
		i -= len(m.TenantId)
		copy(dAtA[i:], m.TenantId)
		i = encodeVarintWirepb(dAtA, i, uint64(len(m.TenantId)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Ulid.Size()
		i -= size
		if _, err := m.Ulid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StreamList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Streams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWirepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Stream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TenantId) > 0 {
		i -= len(m.TenantId)
		copy(dAtA[i:], m.TenantId)
		i = encodeVarintWirepb(dAtA, i, uint64(len(m.TenantId)))
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Ulid.Size()
		i -= size
		if _, err := m.Ulid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintWirepb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TaskStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContributingTimeRange != nil {
		{
			size, err := m.ContributingTimeRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Capture) > 0 {
		i -= len(m.Capture)
		copy(dAtA[i:], m.Capture)
		i = encodeVarintWirepb(dAtA, i, uint64(len(m.Capture)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWirepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintWirepb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContributingTimeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContributingTimeRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContributingTimeRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LessThan {
		i--
		if m.LessThan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	n31, err31 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err31 != nil {
		return 0, err31
	}
	i -= n31
	i = encodeVarintWirepb(dAtA, i, uint64(n31))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TaskError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintWirepb(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintWirepb(dAtA []byte, offset int, v uint64) int {
	offset -= sovWirepb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Frame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *Frame_Ack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ack != nil {
		l = m.Ack.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *Frame_Nack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nack != nil {
		l = m.Nack.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *Frame_Discard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Discard != nil {
		l = m.Discard.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *Frame_Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *AckFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovWirepb(uint64(m.Id))
	}
	return n
}

func (m *NackFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovWirepb(uint64(m.Id))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovWirepb(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}

func (m *DiscardFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovWirepb(uint64(m.Id))
	}
	return n
}

func (m *MessageFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovWirepb(uint64(m.Id))
	}
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *MessageFrame_WorkerReady) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkerReady != nil {
		l = m.WorkerReady.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *MessageFrame_TaskAssign) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskAssign != nil {
		l = m.TaskAssign.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *MessageFrame_TaskCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskCancel != nil {
		l = m.TaskCancel.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *MessageFrame_TaskFlag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskFlag != nil {
		l = m.TaskFlag.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *MessageFrame_TaskStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskStatus != nil {
		l = m.TaskStatus.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *MessageFrame_StreamBind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamBind != nil {
		l = m.StreamBind.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *MessageFrame_StreamData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamData != nil {
		l = m.StreamData.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *MessageFrame_StreamStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StreamStatus != nil {
		l = m.StreamStatus.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *MessageFrame_WorkerHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkerHello != nil {
		l = m.WorkerHello.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}
func (m *WorkerHelloMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Threads != 0 {
		n += 1 + sovWirepb(uint64(m.Threads))
	}
	return n
}

func (m *WorkerReadyMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TaskAssignMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	if len(m.StreamStates) > 0 {
		for k, v := range m.StreamStates {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovWirepb(uint64(len(k))) + 1 + sovWirepb(uint64(v))
			n += mapEntrySize + 1 + sovWirepb(uint64(mapEntrySize))
		}
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovWirepb(uint64(l))
		}
	}
	return n
}

func (m *TaskCancelMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovWirepb(uint64(l))
	return n
}

func (m *TaskFlagMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovWirepb(uint64(l))
	if m.Interruptible {
		n += 2
	}
	return n
}

func (m *TaskStatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovWirepb(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovWirepb(uint64(l))
	return n
}

func (m *StreamBindMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StreamId.Size()
	n += 1 + l + sovWirepb(uint64(l))
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}

func (m *StreamDataMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StreamId.Size()
	n += 1 + l + sovWirepb(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}

func (m *StreamStatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StreamId.Size()
	n += 1 + l + sovWirepb(uint64(l))
	if m.State != 0 {
		n += 1 + sovWirepb(uint64(m.State))
	}
	return n
}

func (m *Task) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Ulid.Size()
	n += 1 + l + sovWirepb(uint64(l))
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovWirepb(uint64(l))
	}
	if m.Fragment != nil {
		l = m.Fragment.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	if len(m.Sources) > 0 {
		for k, v := range m.Sources {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovWirepb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovWirepb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovWirepb(uint64(mapEntrySize))
		}
	}
	if len(m.Sinks) > 0 {
		for k, v := range m.Sinks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovWirepb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovWirepb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovWirepb(uint64(mapEntrySize))
		}
	}
	if m.MaxTimeRange != nil {
		l = m.MaxTimeRange.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}

func (m *StreamList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovWirepb(uint64(l))
		}
	}
	return n
}

func (m *Stream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Ulid.Size()
	n += 1 + l + sovWirepb(uint64(l))
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}

func (m *TaskStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovWirepb(uint64(m.State))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	l = len(m.Capture)
	if l > 0 {
		n += 1 + l + sovWirepb(uint64(l))
	}
	if m.ContributingTimeRange != nil {
		l = m.ContributingTimeRange.Size()
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}

func (m *ContributingTimeRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovWirepb(uint64(l))
	if m.LessThan {
		n += 2
	}
	return n
}

func (m *TaskError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovWirepb(uint64(l))
	}
	return n
}

func sovWirepb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWirepb(x uint64) (n int) {
	return sovWirepb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Frame) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Frame{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Frame_Ack) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Frame_Ack{`,
		`Ack:` + strings.Replace(fmt.Sprintf("%v", this.Ack), "AckFrame", "AckFrame", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Frame_Nack) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Frame_Nack{`,
		`Nack:` + strings.Replace(fmt.Sprintf("%v", this.Nack), "NackFrame", "NackFrame", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Frame_Discard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Frame_Discard{`,
		`Discard:` + strings.Replace(fmt.Sprintf("%v", this.Discard), "DiscardFrame", "DiscardFrame", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Frame_Message) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Frame_Message{`,
		`Message:` + strings.Replace(fmt.Sprintf("%v", this.Message), "MessageFrame", "MessageFrame", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AckFrame) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AckFrame{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NackFrame) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NackFrame{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Error:` + strings.Replace(this.Error.String(), "Error", "Error", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Error) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Error{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscardFrame) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscardFrame{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_WorkerReady) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_WorkerReady{`,
		`WorkerReady:` + strings.Replace(fmt.Sprintf("%v", this.WorkerReady), "WorkerReadyMessage", "WorkerReadyMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_TaskAssign) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_TaskAssign{`,
		`TaskAssign:` + strings.Replace(fmt.Sprintf("%v", this.TaskAssign), "TaskAssignMessage", "TaskAssignMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_TaskCancel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_TaskCancel{`,
		`TaskCancel:` + strings.Replace(fmt.Sprintf("%v", this.TaskCancel), "TaskCancelMessage", "TaskCancelMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_TaskFlag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_TaskFlag{`,
		`TaskFlag:` + strings.Replace(fmt.Sprintf("%v", this.TaskFlag), "TaskFlagMessage", "TaskFlagMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_TaskStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_TaskStatus{`,
		`TaskStatus:` + strings.Replace(fmt.Sprintf("%v", this.TaskStatus), "TaskStatusMessage", "TaskStatusMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_StreamBind) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_StreamBind{`,
		`StreamBind:` + strings.Replace(fmt.Sprintf("%v", this.StreamBind), "StreamBindMessage", "StreamBindMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_StreamData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_StreamData{`,
		`StreamData:` + strings.Replace(fmt.Sprintf("%v", this.StreamData), "StreamDataMessage", "StreamDataMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_StreamStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_StreamStatus{`,
		`StreamStatus:` + strings.Replace(fmt.Sprintf("%v", this.StreamStatus), "StreamStatusMessage", "StreamStatusMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageFrame_WorkerHello) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageFrame_WorkerHello{`,
		`WorkerHello:` + strings.Replace(fmt.Sprintf("%v", this.WorkerHello), "WorkerHelloMessage", "WorkerHelloMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkerHelloMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WorkerHelloMessage{`,
		`Threads:` + fmt.Sprintf("%v", this.Threads) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkerReadyMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WorkerReadyMessage{`,
		`}`,
	}, "")
	return s
}
func (this *TaskAssignMessage) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetadata := "[]*Header{"
	for _, f := range this.Metadata {
		repeatedStringForMetadata += strings.Replace(fmt.Sprintf("%v", f), "Header", "httpgrpc.Header", 1) + ","
	}
	repeatedStringForMetadata += "}"
	keysForStreamStates := make([]string, 0, len(this.StreamStates))
	for k, _ := range this.StreamStates {
		keysForStreamStates = append(keysForStreamStates, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStreamStates)
	mapStringForStreamStates := "map[string]StreamState{"
	for _, k := range keysForStreamStates {
		mapStringForStreamStates += fmt.Sprintf("%v: %v,", k, this.StreamStates[k])
	}
	mapStringForStreamStates += "}"
	s := strings.Join([]string{`&TaskAssignMessage{`,
		`Task:` + strings.Replace(this.Task.String(), "Task", "Task", 1) + `,`,
		`StreamStates:` + mapStringForStreamStates + `,`,
		`Metadata:` + repeatedStringForMetadata + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskCancelMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskCancelMessage{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskFlagMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskFlagMessage{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Interruptible:` + fmt.Sprintf("%v", this.Interruptible) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskStatusMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskStatusMessage{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Status:` + strings.Replace(strings.Replace(this.Status.String(), "TaskStatus", "TaskStatus", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamBindMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamBindMessage{`,
		`StreamId:` + fmt.Sprintf("%v", this.StreamId) + `,`,
		`Receiver:` + fmt.Sprintf("%v", this.Receiver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamDataMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamDataMessage{`,
		`StreamId:` + fmt.Sprintf("%v", this.StreamId) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamStatusMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamStatusMessage{`,
		`StreamId:` + fmt.Sprintf("%v", this.StreamId) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Task) String() string {
	if this == nil {
		return "nil"
	}
	keysForSources := make([]string, 0, len(this.Sources))
	for k, _ := range this.Sources {
		keysForSources = append(keysForSources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSources)
	mapStringForSources := "map[string]*StreamList{"
	for _, k := range keysForSources {
		mapStringForSources += fmt.Sprintf("%v: %v,", k, this.Sources[k])
	}
	mapStringForSources += "}"
	keysForSinks := make([]string, 0, len(this.Sinks))
	for k, _ := range this.Sinks {
		keysForSinks = append(keysForSinks, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSinks)
	mapStringForSinks := "map[string]*StreamList{"
	for _, k := range keysForSinks {
		mapStringForSinks += fmt.Sprintf("%v: %v,", k, this.Sinks[k])
	}
	mapStringForSinks += "}"
	s := strings.Join([]string{`&Task{`,
		`Ulid:` + fmt.Sprintf("%v", this.Ulid) + `,`,
		`TenantId:` + fmt.Sprintf("%v", this.TenantId) + `,`,
		`Fragment:` + strings.Replace(fmt.Sprintf("%v", this.Fragment), "Plan", "physicalpb.Plan", 1) + `,`,
		`Sources:` + mapStringForSources + `,`,
		`Sinks:` + mapStringForSinks + `,`,
		`MaxTimeRange:` + strings.Replace(fmt.Sprintf("%v", this.MaxTimeRange), "TimeRange", "physicalpb.TimeRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStreams := "[]*Stream{"
	for _, f := range this.Streams {
		repeatedStringForStreams += strings.Replace(f.String(), "Stream", "Stream", 1) + ","
	}
	repeatedStringForStreams += "}"
	s := strings.Join([]string{`&StreamList{`,
		`Streams:` + repeatedStringForStreams + `,`,
		`}`,
	}, "")
	return s
}
func (this *Stream) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Stream{`,
		`Ulid:` + fmt.Sprintf("%v", this.Ulid) + `,`,
		`TenantId:` + fmt.Sprintf("%v", this.TenantId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskStatus{`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Error:` + strings.Replace(this.Error.String(), "TaskError", "TaskError", 1) + `,`,
		`Capture:` + fmt.Sprintf("%v", this.Capture) + `,`,
		`ContributingTimeRange:` + strings.Replace(this.ContributingTimeRange.String(), "ContributingTimeRange", "ContributingTimeRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContributingTimeRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContributingTimeRange{`,
		`Timestamp:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Timestamp), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`LessThan:` + fmt.Sprintf("%v", this.LessThan) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskError{`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringWirepb(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Frame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Frame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Frame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AckFrame{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Frame_Ack{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NackFrame{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Frame_Nack{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DiscardFrame{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Frame_Discard{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MessageFrame{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Frame_Message{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NackFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NackFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NackFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscardFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscardFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscardFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerReady", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WorkerReadyMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_WorkerReady{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskAssign", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TaskAssignMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_TaskAssign{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TaskCancelMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_TaskCancel{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskFlag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TaskFlagMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_TaskFlag{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TaskStatusMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_TaskStatus{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamBind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamBindMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_StreamBind{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamDataMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_StreamData{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamStatusMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_StreamStatus{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerHello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WorkerHelloMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &MessageFrame_WorkerHello{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerHelloMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerHelloMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerHelloMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threads |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerReadyMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerReadyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerReadyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskAssignMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskAssignMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskAssignMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &Task{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StreamStates == nil {
				m.StreamStates = make(map[string]StreamState)
			}
			var mapkey string
			var mapvalue StreamState
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWirepb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWirepb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWirepb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthWirepb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWirepb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= StreamState(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWirepb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthWirepb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StreamStates[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, &httpgrpc.Header{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskCancelMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskCancelMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskCancelMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskFlagMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskFlagMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskFlagMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interruptible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Interruptible = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamBindMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamBindMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamBindMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamDataMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamDataMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamDataMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StreamState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ulid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ulid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fragment == nil {
				m.Fragment = &physicalpb.Plan{}
			}
			if err := m.Fragment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sources == nil {
				m.Sources = make(map[string]*StreamList)
			}
			var mapkey string
			var mapvalue *StreamList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWirepb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWirepb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWirepb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthWirepb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWirepb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthWirepb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthWirepb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StreamList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWirepb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthWirepb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sources[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sinks == nil {
				m.Sinks = make(map[string]*StreamList)
			}
			var mapkey string
			var mapvalue *StreamList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWirepb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWirepb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWirepb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthWirepb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWirepb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthWirepb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthWirepb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StreamList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWirepb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthWirepb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sinks[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTimeRange == nil {
				m.MaxTimeRange = &physicalpb.TimeRange{}
			}
			if err := m.MaxTimeRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, &Stream{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ulid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ulid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TaskState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &TaskError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capture", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capture = append(m.Capture[:0], dAtA[iNdEx:postIndex]...)
			if m.Capture == nil {
				m.Capture = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContributingTimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContributingTimeRange == nil {
				m.ContributingTimeRange = &ContributingTimeRange{}
			}
			if err := m.ContributingTimeRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContributingTimeRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContributingTimeRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContributingTimeRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LessThan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LessThan = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWirepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWirepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWirepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWirepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWirepb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWirepb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWirepb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWirepb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthWirepb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWirepb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWirepb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthWirepb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWirepb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWirepb   = fmt.Errorf("proto: integer overflow")
)
