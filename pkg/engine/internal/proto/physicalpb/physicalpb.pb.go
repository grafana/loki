// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/engine/internal/proto/physicalpb/physicalpb.proto

package physicalpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	expressionpb "github.com/grafana/loki/v3/pkg/engine/internal/proto/expressionpb"
	_ "github.com/grafana/loki/v3/pkg/engine/internal/util/ulid"
	github_com_grafana_loki_v3_pkg_engine_internal_util_ulid "github.com/grafana/loki/v3/pkg/engine/internal/util/ulid"
	_ "google.golang.org/protobuf/types/known/durationpb"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AggregateRangeOp represents the operation to perform on the aggregated
// data.
type AggregateRangeOp int32

const (
	AGGREGATE_RANGE_OP_INVALID AggregateRangeOp = 0
	AGGREGATE_RANGE_OP_COUNT   AggregateRangeOp = 1
	AGGREGATE_RANGE_OP_SUM     AggregateRangeOp = 2
	AGGREGATE_RANGE_OP_MAX     AggregateRangeOp = 3
	AGGREGATE_RANGE_OP_MIN     AggregateRangeOp = 4
	AGGREGATE_RANGE_OP_BYTES   AggregateRangeOp = 5
)

var AggregateRangeOp_name = map[int32]string{
	0: "AGGREGATE_RANGE_OP_INVALID",
	1: "AGGREGATE_RANGE_OP_COUNT",
	2: "AGGREGATE_RANGE_OP_SUM",
	3: "AGGREGATE_RANGE_OP_MAX",
	4: "AGGREGATE_RANGE_OP_MIN",
	5: "AGGREGATE_RANGE_OP_BYTES",
}

var AggregateRangeOp_value = map[string]int32{
	"AGGREGATE_RANGE_OP_INVALID": 0,
	"AGGREGATE_RANGE_OP_COUNT":   1,
	"AGGREGATE_RANGE_OP_SUM":     2,
	"AGGREGATE_RANGE_OP_MAX":     3,
	"AGGREGATE_RANGE_OP_MIN":     4,
	"AGGREGATE_RANGE_OP_BYTES":   5,
}

func (AggregateRangeOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{0}
}

// AggregateVectorOp represents the different aggregation operations that can
// be performed on a range vector.
type AggregateVectorOp int32

const (
	AGGREGATE_VECTOR_OP_INVALID   AggregateVectorOp = 0
	AGGREGATE_VECTOR_OP_SUM       AggregateVectorOp = 1
	AGGREGATE_VECTOR_OP_MAX       AggregateVectorOp = 2
	AGGREGATE_VECTOR_OP_MIN       AggregateVectorOp = 3
	AGGREGATE_VECTOR_OP_COUNT     AggregateVectorOp = 4
	AGGREGATE_VECTOR_OP_AVG       AggregateVectorOp = 5
	AGGREGATE_VECTOR_OP_STDDEV    AggregateVectorOp = 6
	AGGREGATE_VECTOR_OP_STDVAR    AggregateVectorOp = 7
	AGGREGATE_VECTOR_OP_BOTTOMK   AggregateVectorOp = 8
	AGGREGATE_VECTOR_OP_TOPK      AggregateVectorOp = 9
	AGGREGATE_VECTOR_OP_SORT      AggregateVectorOp = 10
	AGGREGATE_VECTOR_OP_SORT_DESC AggregateVectorOp = 11
)

var AggregateVectorOp_name = map[int32]string{
	0:  "AGGREGATE_VECTOR_OP_INVALID",
	1:  "AGGREGATE_VECTOR_OP_SUM",
	2:  "AGGREGATE_VECTOR_OP_MAX",
	3:  "AGGREGATE_VECTOR_OP_MIN",
	4:  "AGGREGATE_VECTOR_OP_COUNT",
	5:  "AGGREGATE_VECTOR_OP_AVG",
	6:  "AGGREGATE_VECTOR_OP_STDDEV",
	7:  "AGGREGATE_VECTOR_OP_STDVAR",
	8:  "AGGREGATE_VECTOR_OP_BOTTOMK",
	9:  "AGGREGATE_VECTOR_OP_TOPK",
	10: "AGGREGATE_VECTOR_OP_SORT",
	11: "AGGREGATE_VECTOR_OP_SORT_DESC",
}

var AggregateVectorOp_value = map[string]int32{
	"AGGREGATE_VECTOR_OP_INVALID":   0,
	"AGGREGATE_VECTOR_OP_SUM":       1,
	"AGGREGATE_VECTOR_OP_MAX":       2,
	"AGGREGATE_VECTOR_OP_MIN":       3,
	"AGGREGATE_VECTOR_OP_COUNT":     4,
	"AGGREGATE_VECTOR_OP_AVG":       5,
	"AGGREGATE_VECTOR_OP_STDDEV":    6,
	"AGGREGATE_VECTOR_OP_STDVAR":    7,
	"AGGREGATE_VECTOR_OP_BOTTOMK":   8,
	"AGGREGATE_VECTOR_OP_TOPK":      9,
	"AGGREGATE_VECTOR_OP_SORT":      10,
	"AGGREGATE_VECTOR_OP_SORT_DESC": 11,
}

func (AggregateVectorOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{1}
}

// SortOrder represents the order in which results should be sorted.
type SortOrder int32

const (
	SORT_ORDER_INVALID    SortOrder = 0
	SORT_ORDER_ASCENDING  SortOrder = 1
	SORT_ORDER_DESCENDING SortOrder = 2
)

var SortOrder_name = map[int32]string{
	0: "SORT_ORDER_INVALID",
	1: "SORT_ORDER_ASCENDING",
	2: "SORT_ORDER_DESCENDING",
}

var SortOrder_value = map[string]int32{
	"SORT_ORDER_INVALID":    0,
	"SORT_ORDER_ASCENDING":  1,
	"SORT_ORDER_DESCENDING": 2,
}

func (SortOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{2}
}

// Plan represents the physical plan of a query.
type Plan struct {
	Nodes []*Node     `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Edges []*PlanEdge `protobuf:"bytes,2,rep,name=edges,proto3" json:"edges,omitempty"`
}

func (m *Plan) Reset()      { *m = Plan{} }
func (*Plan) ProtoMessage() {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{0}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.Size()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Plan) GetEdges() []*PlanEdge {
	if m != nil {
		return m.Edges
	}
	return nil
}

// PlanEdge represents a relationship between two nodes in the physical plan.
type PlanEdge struct {
	Parent NodeID `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent"`
	Child  NodeID `protobuf:"bytes,2,opt,name=child,proto3" json:"child"`
}

func (m *PlanEdge) Reset()      { *m = PlanEdge{} }
func (*PlanEdge) ProtoMessage() {}
func (*PlanEdge) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{1}
}
func (m *PlanEdge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanEdge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanEdge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanEdge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanEdge.Merge(m, src)
}
func (m *PlanEdge) XXX_Size() int {
	return m.Size()
}
func (m *PlanEdge) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanEdge.DiscardUnknown(m)
}

var xxx_messageInfo_PlanEdge proto.InternalMessageInfo

func (m *PlanEdge) GetParent() NodeID {
	if m != nil {
		return m.Parent
	}
	return NodeID{}
}

func (m *PlanEdge) GetChild() NodeID {
	if m != nil {
		return m.Child
	}
	return NodeID{}
}

// NodeID represents a unique identifier for a node in the physical plan.
type NodeID struct {
	Value github_com_grafana_loki_v3_pkg_engine_internal_util_ulid.ULID `protobuf:"bytes,1,opt,name=value,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/util/ulid.ULID" json:"value"`
}

func (m *NodeID) Reset()      { *m = NodeID{} }
func (*NodeID) ProtoMessage() {}
func (*NodeID) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{2}
}
func (m *NodeID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeID.Merge(m, src)
}
func (m *NodeID) XXX_Size() int {
	return m.Size()
}
func (m *NodeID) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeID.DiscardUnknown(m)
}

var xxx_messageInfo_NodeID proto.InternalMessageInfo

// Node represents a node in the physical plan.
type Node struct {
	// ID of the node.
	Id NodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Types that are valid to be assigned to Kind:
	//	*Node_AggregateRange
	//	*Node_AggregateVector
	//	*Node_Scan
	//	*Node_Filter
	//	*Node_Limit
	//	*Node_Projection
	//	*Node_ColumnCompat
	//	*Node_ScanSet
	//	*Node_TopK
	//	*Node_Parallelize
	//	*Node_Join
	Kind isNode_Kind `protobuf_oneof:"kind"`
}

func (m *Node) Reset()      { *m = Node{} }
func (*Node) ProtoMessage() {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{3}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

type isNode_Kind interface {
	isNode_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Node_AggregateRange struct {
	AggregateRange *AggregateRange `protobuf:"bytes,2,opt,name=aggregate_range,json=aggregateRange,proto3,oneof"`
}
type Node_AggregateVector struct {
	AggregateVector *AggregateVector `protobuf:"bytes,3,opt,name=aggregate_vector,json=aggregateVector,proto3,oneof"`
}
type Node_Scan struct {
	Scan *DataObjScan `protobuf:"bytes,4,opt,name=scan,proto3,oneof"`
}
type Node_Filter struct {
	Filter *Filter `protobuf:"bytes,5,opt,name=filter,proto3,oneof"`
}
type Node_Limit struct {
	Limit *Limit `protobuf:"bytes,6,opt,name=limit,proto3,oneof"`
}
type Node_Projection struct {
	Projection *Projection `protobuf:"bytes,7,opt,name=projection,proto3,oneof"`
}
type Node_ColumnCompat struct {
	ColumnCompat *ColumnCompat `protobuf:"bytes,8,opt,name=column_compat,json=columnCompat,proto3,oneof"`
}
type Node_ScanSet struct {
	ScanSet *ScanSet `protobuf:"bytes,9,opt,name=scan_set,json=scanSet,proto3,oneof"`
}
type Node_TopK struct {
	TopK *TopK `protobuf:"bytes,10,opt,name=top_k,json=topK,proto3,oneof"`
}
type Node_Parallelize struct {
	Parallelize *Parallelize `protobuf:"bytes,11,opt,name=parallelize,proto3,oneof"`
}
type Node_Join struct {
	Join *Join `protobuf:"bytes,12,opt,name=join,proto3,oneof"`
}

func (*Node_AggregateRange) isNode_Kind()  {}
func (*Node_AggregateVector) isNode_Kind() {}
func (*Node_Scan) isNode_Kind()            {}
func (*Node_Filter) isNode_Kind()          {}
func (*Node_Limit) isNode_Kind()           {}
func (*Node_Projection) isNode_Kind()      {}
func (*Node_ColumnCompat) isNode_Kind()    {}
func (*Node_ScanSet) isNode_Kind()         {}
func (*Node_TopK) isNode_Kind()            {}
func (*Node_Parallelize) isNode_Kind()     {}
func (*Node_Join) isNode_Kind()            {}

func (m *Node) GetKind() isNode_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *Node) GetId() NodeID {
	if m != nil {
		return m.Id
	}
	return NodeID{}
}

func (m *Node) GetAggregateRange() *AggregateRange {
	if x, ok := m.GetKind().(*Node_AggregateRange); ok {
		return x.AggregateRange
	}
	return nil
}

func (m *Node) GetAggregateVector() *AggregateVector {
	if x, ok := m.GetKind().(*Node_AggregateVector); ok {
		return x.AggregateVector
	}
	return nil
}

func (m *Node) GetScan() *DataObjScan {
	if x, ok := m.GetKind().(*Node_Scan); ok {
		return x.Scan
	}
	return nil
}

func (m *Node) GetFilter() *Filter {
	if x, ok := m.GetKind().(*Node_Filter); ok {
		return x.Filter
	}
	return nil
}

func (m *Node) GetLimit() *Limit {
	if x, ok := m.GetKind().(*Node_Limit); ok {
		return x.Limit
	}
	return nil
}

func (m *Node) GetProjection() *Projection {
	if x, ok := m.GetKind().(*Node_Projection); ok {
		return x.Projection
	}
	return nil
}

func (m *Node) GetColumnCompat() *ColumnCompat {
	if x, ok := m.GetKind().(*Node_ColumnCompat); ok {
		return x.ColumnCompat
	}
	return nil
}

func (m *Node) GetScanSet() *ScanSet {
	if x, ok := m.GetKind().(*Node_ScanSet); ok {
		return x.ScanSet
	}
	return nil
}

func (m *Node) GetTopK() *TopK {
	if x, ok := m.GetKind().(*Node_TopK); ok {
		return x.TopK
	}
	return nil
}

func (m *Node) GetParallelize() *Parallelize {
	if x, ok := m.GetKind().(*Node_Parallelize); ok {
		return x.Parallelize
	}
	return nil
}

func (m *Node) GetJoin() *Join {
	if x, ok := m.GetKind().(*Node_Join); ok {
		return x.Join
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Node) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Node_AggregateRange)(nil),
		(*Node_AggregateVector)(nil),
		(*Node_Scan)(nil),
		(*Node_Filter)(nil),
		(*Node_Limit)(nil),
		(*Node_Projection)(nil),
		(*Node_ColumnCompat)(nil),
		(*Node_ScanSet)(nil),
		(*Node_TopK)(nil),
		(*Node_Parallelize)(nil),
		(*Node_Join)(nil),
	}
}

// AggregateRange aggregates samples into windowed ranges.
type AggregateRange struct {
	// Columns to partition the data by.
	PartitionBy []*expressionpb.ColumnExpression `protobuf:"bytes,1,rep,name=partition_by,json=partitionBy,proto3" json:"partition_by,omitempty"`
	Operation   AggregateRangeOp                 `protobuf:"varint,2,opt,name=operation,proto3,enum=loki.physical.AggregateRangeOp" json:"operation,omitempty"`
	Start       time.Time                        `protobuf:"bytes,3,opt,name=start,proto3,stdtime" json:"start"`
	End         time.Time                        `protobuf:"bytes,4,opt,name=end,proto3,stdtime" json:"end"`
	Step        time.Duration                    `protobuf:"bytes,5,opt,name=step,proto3,stdduration" json:"step"`
	Range       time.Duration                    `protobuf:"bytes,6,opt,name=range,proto3,stdduration" json:"range"`
}

func (m *AggregateRange) Reset()      { *m = AggregateRange{} }
func (*AggregateRange) ProtoMessage() {}
func (*AggregateRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{4}
}
func (m *AggregateRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateRange.Merge(m, src)
}
func (m *AggregateRange) XXX_Size() int {
	return m.Size()
}
func (m *AggregateRange) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateRange.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateRange proto.InternalMessageInfo

func (m *AggregateRange) GetPartitionBy() []*expressionpb.ColumnExpression {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *AggregateRange) GetOperation() AggregateRangeOp {
	if m != nil {
		return m.Operation
	}
	return AGGREGATE_RANGE_OP_INVALID
}

func (m *AggregateRange) GetStart() time.Time {
	if m != nil {
		return m.Start
	}
	return time.Time{}
}

func (m *AggregateRange) GetEnd() time.Time {
	if m != nil {
		return m.End
	}
	return time.Time{}
}

func (m *AggregateRange) GetStep() time.Duration {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *AggregateRange) GetRange() time.Duration {
	if m != nil {
		return m.Range
	}
	return 0
}

// AggregateVector represents an operation to aggregate a range vector into an
// instant vector, with optional grouping on specified dimensions.
type AggregateVector struct {
	// Columns to group the data by. If empty, all rows are aggregated into a single result.
	GroupBy []*expressionpb.ColumnExpression `protobuf:"bytes,1,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	// Aggregation operation to perform over the underlying range vector.
	Operation AggregateVectorOp `protobuf:"varint,2,opt,name=operation,proto3,enum=loki.physical.AggregateVectorOp" json:"operation,omitempty"`
}

func (m *AggregateVector) Reset()      { *m = AggregateVector{} }
func (*AggregateVector) ProtoMessage() {}
func (*AggregateVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{5}
}
func (m *AggregateVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateVector.Merge(m, src)
}
func (m *AggregateVector) XXX_Size() int {
	return m.Size()
}
func (m *AggregateVector) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateVector.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateVector proto.InternalMessageInfo

func (m *AggregateVector) GetGroupBy() []*expressionpb.ColumnExpression {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *AggregateVector) GetOperation() AggregateVectorOp {
	if m != nil {
		return m.Operation
	}
	return AGGREGATE_VECTOR_OP_INVALID
}

// DataObjScan represents an operation to read the contents of a data object
// section.
type DataObjScan struct {
	// Stored location of the data object to read.
	Location string `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// Section within the data object to read.
	Section int64 `protobuf:"varint,2,opt,name=section,proto3" json:"section,omitempty"`
	// StreamIDs within the section to read.
	StreamIds []int64 `protobuf:"varint,3,rep,packed,name=stream_ids,json=streamIds,proto3" json:"stream_ids,omitempty"`
	// Projections are used to limit the columns that are read.
	Projections []*expressionpb.ColumnExpression `protobuf:"bytes,4,rep,name=projections,proto3" json:"projections,omitempty"`
	// Predicates are used to filter rows to reduce the amount of rows that are
	// returned.
	Predicates []*expressionpb.Expression `protobuf:"bytes,5,rep,name=predicates,proto3" json:"predicates,omitempty"`
}

func (m *DataObjScan) Reset()      { *m = DataObjScan{} }
func (*DataObjScan) ProtoMessage() {}
func (*DataObjScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{6}
}
func (m *DataObjScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataObjScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataObjScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataObjScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataObjScan.Merge(m, src)
}
func (m *DataObjScan) XXX_Size() int {
	return m.Size()
}
func (m *DataObjScan) XXX_DiscardUnknown() {
	xxx_messageInfo_DataObjScan.DiscardUnknown(m)
}

var xxx_messageInfo_DataObjScan proto.InternalMessageInfo

func (m *DataObjScan) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *DataObjScan) GetSection() int64 {
	if m != nil {
		return m.Section
	}
	return 0
}

func (m *DataObjScan) GetStreamIds() []int64 {
	if m != nil {
		return m.StreamIds
	}
	return nil
}

func (m *DataObjScan) GetProjections() []*expressionpb.ColumnExpression {
	if m != nil {
		return m.Projections
	}
	return nil
}

func (m *DataObjScan) GetPredicates() []*expressionpb.Expression {
	if m != nil {
		return m.Predicates
	}
	return nil
}

// Filter represents an operation to filter rows based on a condition.
type Filter struct {
	// Predicates to apply to filter rows.
	Predicates []*expressionpb.Expression `protobuf:"bytes,1,rep,name=predicates,proto3" json:"predicates,omitempty"`
}

func (m *Filter) Reset()      { *m = Filter{} }
func (*Filter) ProtoMessage() {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{7}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetPredicates() []*expressionpb.Expression {
	if m != nil {
		return m.Predicates
	}
	return nil
}

// Limit represents a limiting operation in the physical plan that applies
// offset and limit to the result set.
type Limit struct {
	// Skip specifies how many initial rows should be skipped.
	Skip uint32 `protobuf:"varint,1,opt,name=skip,proto3" json:"skip,omitempty"`
	// Fetch specifies how many rows should be returned in total.
	Fetch uint32 `protobuf:"varint,2,opt,name=fetch,proto3" json:"fetch,omitempty"`
}

func (m *Limit) Reset()      { *m = Limit{} }
func (*Limit) ProtoMessage() {}
func (*Limit) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{8}
}
func (m *Limit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limit.Merge(m, src)
}
func (m *Limit) XXX_Size() int {
	return m.Size()
}
func (m *Limit) XXX_DiscardUnknown() {
	xxx_messageInfo_Limit.DiscardUnknown(m)
}

var xxx_messageInfo_Limit proto.InternalMessageInfo

func (m *Limit) GetSkip() uint32 {
	if m != nil {
		return m.Skip
	}
	return 0
}

func (m *Limit) GetFetch() uint32 {
	if m != nil {
		return m.Fetch
	}
	return 0
}

// Projection represents an operation to return a subset of columns from the
// input.
type Projection struct {
	// Expressions is a set of column expressions that are used to drop not needed
	// columns that match the column expression, or to expand columns that result
	// from the expressions.
	Expressions []*expressionpb.Expression `protobuf:"bytes,1,rep,name=expressions,proto3" json:"expressions,omitempty"`
	All         bool                       `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
	Expand      bool                       `protobuf:"varint,4,opt,name=expand,proto3" json:"expand,omitempty"`
	Drop        bool                       `protobuf:"varint,5,opt,name=drop,proto3" json:"drop,omitempty"`
}

func (m *Projection) Reset()      { *m = Projection{} }
func (*Projection) ProtoMessage() {}
func (*Projection) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{9}
}
func (m *Projection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Projection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Projection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Projection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Projection.Merge(m, src)
}
func (m *Projection) XXX_Size() int {
	return m.Size()
}
func (m *Projection) XXX_DiscardUnknown() {
	xxx_messageInfo_Projection.DiscardUnknown(m)
}

var xxx_messageInfo_Projection proto.InternalMessageInfo

func (m *Projection) GetExpressions() []*expressionpb.Expression {
	if m != nil {
		return m.Expressions
	}
	return nil
}

func (m *Projection) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *Projection) GetExpand() bool {
	if m != nil {
		return m.Expand
	}
	return false
}

func (m *Projection) GetDrop() bool {
	if m != nil {
		return m.Drop
	}
	return false
}

// ColumnCompat represents a compactibilty operation in the physical plan that
// moves a values from a conflicting metadata column with a label column into a new column suffixed with `_extracted`.
type ColumnCompat struct {
	Source      expressionpb.ColumnType `protobuf:"varint,1,opt,name=source,proto3,enum=loki.expression.ColumnType" json:"source,omitempty"`
	Destination expressionpb.ColumnType `protobuf:"varint,2,opt,name=destination,proto3,enum=loki.expression.ColumnType" json:"destination,omitempty"`
	Collision   expressionpb.ColumnType `protobuf:"varint,3,opt,name=collision,proto3,enum=loki.expression.ColumnType" json:"collision,omitempty"`
}

func (m *ColumnCompat) Reset()      { *m = ColumnCompat{} }
func (*ColumnCompat) ProtoMessage() {}
func (*ColumnCompat) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{10}
}
func (m *ColumnCompat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnCompat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnCompat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnCompat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnCompat.Merge(m, src)
}
func (m *ColumnCompat) XXX_Size() int {
	return m.Size()
}
func (m *ColumnCompat) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnCompat.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnCompat proto.InternalMessageInfo

func (m *ColumnCompat) GetSource() expressionpb.ColumnType {
	if m != nil {
		return m.Source
	}
	return expressionpb.COLUMN_TYPE_INVALID
}

func (m *ColumnCompat) GetDestination() expressionpb.ColumnType {
	if m != nil {
		return m.Destination
	}
	return expressionpb.COLUMN_TYPE_INVALID
}

func (m *ColumnCompat) GetCollision() expressionpb.ColumnType {
	if m != nil {
		return m.Collision
	}
	return expressionpb.COLUMN_TYPE_INVALID
}

// TopK represents a physical plan node that performs topK operation.
// It sorts rows based on sort expressions and limits the result to the top K rows.
// This is equivalent to a SORT followed by a LIMIT operation.
type TopK struct {
	SortBy     *expressionpb.ColumnExpression `protobuf:"bytes,1,opt,name=sort_by,json=sortBy,proto3" json:"sort_by,omitempty"`
	Ascending  bool                           `protobuf:"varint,2,opt,name=ascending,proto3" json:"ascending,omitempty"`
	NullsFirst bool                           `protobuf:"varint,3,opt,name=nulls_first,json=nullsFirst,proto3" json:"nulls_first,omitempty"`
	K          int64                          `protobuf:"varint,4,opt,name=k,proto3" json:"k,omitempty"`
}

func (m *TopK) Reset()      { *m = TopK{} }
func (*TopK) ProtoMessage() {}
func (*TopK) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{11}
}
func (m *TopK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopK.Merge(m, src)
}
func (m *TopK) XXX_Size() int {
	return m.Size()
}
func (m *TopK) XXX_DiscardUnknown() {
	xxx_messageInfo_TopK.DiscardUnknown(m)
}

var xxx_messageInfo_TopK proto.InternalMessageInfo

func (m *TopK) GetSortBy() *expressionpb.ColumnExpression {
	if m != nil {
		return m.SortBy
	}
	return nil
}

func (m *TopK) GetAscending() bool {
	if m != nil {
		return m.Ascending
	}
	return false
}

func (m *TopK) GetNullsFirst() bool {
	if m != nil {
		return m.NullsFirst
	}
	return false
}

func (m *TopK) GetK() int64 {
	if m != nil {
		return m.K
	}
	return 0
}

// ScanSet represents a physical plan operation for reading data from targets.
type ScanSet struct {
	// Targets to scan
	Targets []*ScanTarget `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets,omitempty"`
	// Projections are used to limit the columns that are read to the ones
	// provided in the column expressions to reduce the amount of data that
	// needs to be processed.
	Projections []*expressionpb.ColumnExpression `protobuf:"bytes,2,rep,name=projections,proto3" json:"projections,omitempty"`
	// Predicates are used to filter rows to reduce the amount of rows that are
	// returned. Predicates would almost always contain a time range filter to
	// only read the logs for the requested time range.
	Predicates []*expressionpb.Expression `protobuf:"bytes,3,rep,name=predicates,proto3" json:"predicates,omitempty"`
}

func (m *ScanSet) Reset()      { *m = ScanSet{} }
func (*ScanSet) ProtoMessage() {}
func (*ScanSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{12}
}
func (m *ScanSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanSet.Merge(m, src)
}
func (m *ScanSet) XXX_Size() int {
	return m.Size()
}
func (m *ScanSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanSet.DiscardUnknown(m)
}

var xxx_messageInfo_ScanSet proto.InternalMessageInfo

func (m *ScanSet) GetTargets() []*ScanTarget {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *ScanSet) GetProjections() []*expressionpb.ColumnExpression {
	if m != nil {
		return m.Projections
	}
	return nil
}

func (m *ScanSet) GetPredicates() []*expressionpb.Expression {
	if m != nil {
		return m.Predicates
	}
	return nil
}

// ScanTarget represents a target of a [ScanSet].
type ScanTarget struct {
	// Types that are valid to be assigned to Kind:
	//
	//	*ScanTarget_DataObject
	Kind isScanTarget_Kind `protobuf_oneof:"kind"`
}

func (m *ScanTarget) Reset()      { *m = ScanTarget{} }
func (*ScanTarget) ProtoMessage() {}
func (*ScanTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{13}
}
func (m *ScanTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanTarget.Merge(m, src)
}
func (m *ScanTarget) XXX_Size() int {
	return m.Size()
}
func (m *ScanTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanTarget.DiscardUnknown(m)
}

var xxx_messageInfo_ScanTarget proto.InternalMessageInfo

type isScanTarget_Kind interface {
	isScanTarget_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ScanTarget_DataObject struct {
	DataObject *DataObjScan `protobuf:"bytes,1,opt,name=data_object,json=dataObject,proto3,oneof"`
}

func (*ScanTarget_DataObject) isScanTarget_Kind() {}

func (m *ScanTarget) GetKind() isScanTarget_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *ScanTarget) GetDataObject() *DataObjScan {
	if x, ok := m.GetKind().(*ScanTarget_DataObject); ok {
		return x.DataObject
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ScanTarget) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ScanTarget_DataObject)(nil),
	}
}

// Parallelize represents a hint to the engine to partition and parallelize the
// children branches of the Parallelize and emit results as a single sequence
// with no guaranteed order.
type Parallelize struct {
}

func (m *Parallelize) Reset()      { *m = Parallelize{} }
func (*Parallelize) ProtoMessage() {}
func (*Parallelize) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{14}
}
func (m *Parallelize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Parallelize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Parallelize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Parallelize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Parallelize.Merge(m, src)
}
func (m *Parallelize) XXX_Size() int {
	return m.Size()
}
func (m *Parallelize) XXX_DiscardUnknown() {
	xxx_messageInfo_Parallelize.DiscardUnknown(m)
}

var xxx_messageInfo_Parallelize proto.InternalMessageInfo

// Join represents a join operation in the physical plan.
// For now it is only an inner join on `timestamp`. Will be expanded later.
type Join struct {
}

func (m *Join) Reset()      { *m = Join{} }
func (*Join) ProtoMessage() {}
func (*Join) Descriptor() ([]byte, []int) {
	return fileDescriptor_d1fdbb44b95b211f, []int{15}
}
func (m *Join) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Join) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Join.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Join) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Join.Merge(m, src)
}
func (m *Join) XXX_Size() int {
	return m.Size()
}
func (m *Join) XXX_DiscardUnknown() {
	xxx_messageInfo_Join.DiscardUnknown(m)
}

var xxx_messageInfo_Join proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("loki.physical.AggregateRangeOp", AggregateRangeOp_name, AggregateRangeOp_value)
	proto.RegisterEnum("loki.physical.AggregateVectorOp", AggregateVectorOp_name, AggregateVectorOp_value)
	proto.RegisterEnum("loki.physical.SortOrder", SortOrder_name, SortOrder_value)
	proto.RegisterType((*Plan)(nil), "loki.physical.Plan")
	proto.RegisterType((*PlanEdge)(nil), "loki.physical.PlanEdge")
	proto.RegisterType((*NodeID)(nil), "loki.physical.NodeID")
	proto.RegisterType((*Node)(nil), "loki.physical.Node")
	proto.RegisterType((*AggregateRange)(nil), "loki.physical.AggregateRange")
	proto.RegisterType((*AggregateVector)(nil), "loki.physical.AggregateVector")
	proto.RegisterType((*DataObjScan)(nil), "loki.physical.DataObjScan")
	proto.RegisterType((*Filter)(nil), "loki.physical.Filter")
	proto.RegisterType((*Limit)(nil), "loki.physical.Limit")
	proto.RegisterType((*Projection)(nil), "loki.physical.Projection")
	proto.RegisterType((*ColumnCompat)(nil), "loki.physical.ColumnCompat")
	proto.RegisterType((*TopK)(nil), "loki.physical.TopK")
	proto.RegisterType((*ScanSet)(nil), "loki.physical.ScanSet")
	proto.RegisterType((*ScanTarget)(nil), "loki.physical.ScanTarget")
	proto.RegisterType((*Parallelize)(nil), "loki.physical.Parallelize")
	proto.RegisterType((*Join)(nil), "loki.physical.Join")
}

func init() {
	proto.RegisterFile("pkg/engine/internal/proto/physicalpb/physicalpb.proto", fileDescriptor_d1fdbb44b95b211f)
}

var fileDescriptor_d1fdbb44b95b211f = []byte{
	// 1476 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x27, 0xf5, 0x5f, 0x4f, 0xb6, 0xc3, 0x4e, 0x1d, 0x87, 0xb6, 0x63, 0xda, 0xd1, 0xc9, 0x71,
	0x5b, 0xa9, 0x89, 0xd1, 0x16, 0x49, 0x9b, 0x14, 0xfa, 0x17, 0x4b, 0x75, 0x22, 0x19, 0x23, 0xc5,
	0x48, 0x7b, 0x51, 0x29, 0x72, 0x4c, 0x33, 0xa6, 0x49, 0x82, 0x1c, 0x19, 0x71, 0x0f, 0x45, 0x6f,
	0x45, 0x4f, 0xcd, 0xb1, 0x1f, 0xa1, 0xc7, 0xfd, 0x02, 0x0b, 0x2c, 0xf6, 0x94, 0x63, 0x8e, 0xc1,
	0x1e, 0xb2, 0x1b, 0x67, 0x0f, 0x7b, 0xcc, 0x17, 0x58, 0x60, 0x31, 0x33, 0x94, 0xf5, 0xc7, 0x92,
	0x63, 0x03, 0x7b, 0x31, 0x66, 0xde, 0xfb, 0xfd, 0xde, 0xbc, 0xf9, 0xf1, 0xbd, 0x37, 0x16, 0xfc,
	0xce, 0x3f, 0xb2, 0x8a, 0xc4, 0xb5, 0x6c, 0x97, 0x14, 0x6d, 0x97, 0x92, 0xc0, 0xd5, 0x9d, 0xa2,
	0x1f, 0x78, 0xd4, 0x2b, 0xfa, 0x87, 0xa7, 0xa1, 0x6d, 0xe8, 0x8e, 0xdf, 0x1b, 0x59, 0x16, 0xb8,
	0x0f, 0xcd, 0x3b, 0xde, 0x91, 0x5d, 0x18, 0x98, 0x57, 0x16, 0x2d, 0xcf, 0xf2, 0x04, 0x8b, 0xad,
	0x04, 0x68, 0x45, 0xb3, 0x3c, 0xcf, 0x72, 0x88, 0x08, 0xd7, 0xeb, 0x1f, 0x14, 0xcd, 0x7e, 0xa0,
	0x53, 0xdb, 0x73, 0x23, 0xff, 0xfa, 0xa4, 0x9f, 0xda, 0xc7, 0x24, 0xa4, 0xfa, 0xb1, 0x1f, 0x01,
	0x1e, 0xcc, 0x4e, 0x8e, 0xbc, 0xf2, 0x03, 0x12, 0x86, 0xb6, 0xe7, 0xfa, 0xbd, 0xb1, 0x4d, 0x44,
	0xdd, 0x9c, 0x46, 0xed, 0x53, 0xdb, 0x29, 0xf6, 0x1d, 0xdb, 0xe4, 0x7f, 0x04, 0x32, 0xff, 0x77,
	0x48, 0xec, 0x39, 0xba, 0x8b, 0xee, 0x42, 0xd2, 0xf5, 0x4c, 0x12, 0xaa, 0xf2, 0x46, 0x7c, 0x33,
	0x77, 0xff, 0x97, 0x85, 0xb1, 0x2b, 0x16, 0x9a, 0x9e, 0x49, 0xb0, 0x40, 0xa0, 0xdf, 0x40, 0x92,
	0x98, 0x16, 0x09, 0xd5, 0x18, 0x87, 0xde, 0x9a, 0x80, 0xb2, 0x70, 0x35, 0xd3, 0x22, 0x58, 0xa0,
	0xf2, 0x01, 0x64, 0x06, 0x26, 0xb4, 0x0d, 0x29, 0x5f, 0x0f, 0x88, 0x4b, 0x55, 0x79, 0x43, 0xde,
	0xcc, 0xdd, 0xbf, 0x39, 0xe5, 0x98, 0x46, 0xb5, 0x9c, 0x78, 0xf3, 0x7e, 0x5d, 0xc2, 0x11, 0x14,
	0xdd, 0x83, 0xa4, 0x71, 0x68, 0x3b, 0xa6, 0x1a, 0xfb, 0x3c, 0x47, 0x20, 0xf3, 0xff, 0x84, 0x94,
	0x30, 0x23, 0x0a, 0xc9, 0x13, 0xdd, 0xe9, 0x93, 0xe8, 0xc0, 0x5b, 0x05, 0x7e, 0x77, 0x1e, 0xe1,
	0xe4, 0x5e, 0x61, 0x8f, 0x69, 0xf0, 0xfc, 0x69, 0xa3, 0x5a, 0xae, 0x31, 0xfa, 0x37, 0xef, 0xd7,
	0x1f, 0x59, 0x36, 0x3d, 0xec, 0xf7, 0x0a, 0x86, 0x77, 0x5c, 0xb4, 0x02, 0xfd, 0x40, 0x77, 0xf5,
	0x22, 0x43, 0x17, 0x4f, 0xb6, 0x8b, 0x97, 0x8a, 0x5a, 0x60, 0x61, 0xb0, 0x38, 0x2c, 0xff, 0x45,
	0x12, 0x12, 0x2c, 0x01, 0xf4, 0x2b, 0x88, 0xd9, 0xe6, 0x55, 0x2e, 0x1b, 0xb3, 0x4d, 0x54, 0x87,
	0x1b, 0xba, 0x65, 0x05, 0xc4, 0xd2, 0x29, 0xe9, 0x06, 0xba, 0x6b, 0x91, 0xe8, 0xca, 0x6b, 0x13,
	0xcc, 0xd2, 0x00, 0x85, 0x19, 0xa8, 0x2e, 0xe1, 0x05, 0x7d, 0xcc, 0x82, 0x76, 0x41, 0x19, 0x46,
	0x3a, 0x21, 0x06, 0xf5, 0x02, 0x35, 0xce, 0x43, 0x69, 0xb3, 0x42, 0xed, 0x73, 0x54, 0x5d, 0xc2,
	0xc3, 0x1c, 0x84, 0x09, 0xfd, 0x16, 0x12, 0xa1, 0xa1, 0xbb, 0x6a, 0x82, 0x07, 0x58, 0x99, 0x08,
	0x50, 0xd5, 0xa9, 0xde, 0xea, 0xbd, 0x6c, 0x1b, 0xba, 0x5b, 0x97, 0x30, 0x47, 0xa2, 0x22, 0xa4,
	0x0e, 0x6c, 0x87, 0x92, 0x40, 0x4d, 0x4e, 0xbd, 0xf9, 0x13, 0xee, 0xac, 0x4b, 0x38, 0x82, 0xa1,
	0x5f, 0x43, 0xd2, 0xb1, 0x8f, 0x6d, 0xaa, 0xa6, 0x38, 0x7e, 0x71, 0x02, 0xff, 0x94, 0xf9, 0xea,
	0x12, 0x16, 0x20, 0xf4, 0x47, 0x00, 0x3f, 0xf0, 0x5e, 0x12, 0x83, 0x75, 0x93, 0x9a, 0xe6, 0x94,
	0xe5, 0xc9, 0x2a, 0x3c, 0x07, 0xd4, 0x25, 0x3c, 0x02, 0x47, 0x65, 0x98, 0x37, 0x3c, 0xa7, 0x7f,
	0xec, 0x76, 0x0d, 0xef, 0xd8, 0xd7, 0xa9, 0x9a, 0xe1, 0xfc, 0xd5, 0x09, 0x7e, 0x85, 0x63, 0x2a,
	0x1c, 0x52, 0x97, 0xf0, 0x9c, 0x31, 0xb2, 0x47, 0xdb, 0x90, 0x61, 0xf7, 0xec, 0x86, 0x84, 0xaa,
	0x59, 0x4e, 0x5f, 0x9a, 0xa0, 0x33, 0x39, 0xda, 0x84, 0x31, 0xd3, 0xa1, 0x58, 0xa2, 0x2d, 0x48,
	0x52, 0xcf, 0xef, 0x1e, 0xa9, 0xc0, 0x19, 0x93, 0x1d, 0xd6, 0xf1, 0xfc, 0x5d, 0x26, 0x20, 0xf5,
	0xfc, 0x5d, 0xf4, 0x18, 0x72, 0xbe, 0x1e, 0xe8, 0x8e, 0x43, 0x1c, 0xfb, 0x1f, 0x44, 0xcd, 0x4d,
	0x55, 0x7e, 0x6f, 0x88, 0xa8, 0x4b, 0x78, 0x94, 0x80, 0xee, 0x42, 0xe2, 0xa5, 0x67, 0xbb, 0xea,
	0xdc, 0xd4, 0xa3, 0xfe, 0xe2, 0xd9, 0xfc, 0x5b, 0x31, 0x48, 0x39, 0x05, 0x89, 0x23, 0xdb, 0x35,
	0xf3, 0x3f, 0xc6, 0x60, 0x61, 0xbc, 0xae, 0x50, 0x15, 0xe6, 0x7c, 0x3d, 0xa0, 0x36, 0xd3, 0xad,
	0xdb, 0x3b, 0x8d, 0x46, 0xc3, 0x1d, 0x11, 0x6d, 0x38, 0x75, 0x22, 0xad, 0x6a, 0xe7, 0x06, 0x9e,
	0x8b, 0xa0, 0x95, 0x4f, 0xd1, 0x23, 0xc8, 0x7a, 0x3e, 0x11, 0xa3, 0x8f, 0xd7, 0xf3, 0xc2, 0xfd,
	0xf5, 0x4b, 0xeb, 0xb9, 0xe5, 0xe3, 0x21, 0x03, 0x3d, 0x84, 0x64, 0x48, 0xf5, 0x80, 0x46, 0xf5,
	0xbb, 0x52, 0x10, 0x63, 0xb3, 0x30, 0x18, 0x9b, 0x85, 0xce, 0x60, 0x6c, 0x96, 0x33, 0xac, 0x93,
	0x5e, 0x7f, 0xbb, 0x2e, 0x63, 0x41, 0x41, 0xbf, 0x87, 0x38, 0x71, 0xcd, 0xf3, 0xc2, 0xbd, 0x0a,
	0x93, 0x11, 0xd0, 0x1f, 0x20, 0x11, 0x52, 0xe2, 0x47, 0xd5, 0xbb, 0x7c, 0x81, 0x58, 0x8d, 0x26,
	0xb9, 0xe0, 0xfd, 0x8f, 0xf1, 0x38, 0x01, 0x3d, 0x80, 0xa4, 0xe8, 0xdb, 0xd4, 0xd5, 0x99, 0x82,
	0x91, 0xff, 0xaf, 0x0c, 0x37, 0x26, 0x9a, 0x11, 0xfd, 0x09, 0x32, 0x56, 0xe0, 0xf5, 0xfd, 0x6b,
	0x89, 0x9f, 0xe6, 0x94, 0xf2, 0x29, 0x7a, 0x7c, 0x51, 0xf8, 0x8d, 0xcb, 0xbb, 0x7f, 0x4c, 0xf9,
	0xfc, 0xf7, 0x32, 0xe4, 0x46, 0xba, 0x1b, 0xad, 0x40, 0xc6, 0xf1, 0x0c, 0x11, 0x8e, 0x4d, 0xb4,
	0x2c, 0x3e, 0xdf, 0x23, 0x15, 0xd2, 0x61, 0xd4, 0x8f, 0xec, 0xa4, 0x38, 0x1e, 0x6c, 0xd1, 0x1a,
	0x40, 0x48, 0x03, 0xa2, 0x1f, 0x77, 0x6d, 0x33, 0x54, 0xe3, 0x1b, 0xf1, 0xcd, 0x38, 0xce, 0x0a,
	0x4b, 0xc3, 0x0c, 0x51, 0x05, 0x72, 0xc3, 0xe6, 0x0c, 0xd5, 0xc4, 0xd5, 0x4b, 0x6c, 0xc8, 0x12,
	0x03, 0x81, 0x98, 0xb6, 0xa1, 0x53, 0x12, 0xaa, 0x49, 0x1e, 0x63, 0xf5, 0x42, 0x8c, 0x11, 0xf6,
	0x08, 0x3c, 0x5f, 0x83, 0x94, 0x98, 0x47, 0x13, 0x61, 0xe4, 0xeb, 0x85, 0xb9, 0x07, 0x49, 0x3e,
	0xa6, 0x10, 0x82, 0x44, 0x78, 0x64, 0xfb, 0x5c, 0xa2, 0x79, 0xcc, 0xd7, 0x68, 0x11, 0x92, 0x07,
	0x84, 0x1a, 0x87, 0x5c, 0x9c, 0x79, 0x2c, 0x36, 0xf9, 0xff, 0xc8, 0x00, 0xc3, 0x39, 0x85, 0x1e,
	0x41, 0x6e, 0x78, 0xcc, 0x95, 0xce, 0x1f, 0xc5, 0x23, 0x05, 0xe2, 0xba, 0xe3, 0xf0, 0x36, 0xc9,
	0x60, 0xb6, 0x44, 0x4b, 0x90, 0x22, 0xaf, 0x7c, 0x3d, 0xea, 0x80, 0x0c, 0x8e, 0x76, 0x2c, 0x43,
	0x33, 0xf0, 0x44, 0x79, 0x67, 0x30, 0x5f, 0xe7, 0xbf, 0x94, 0x61, 0xae, 0x32, 0x3e, 0xe3, 0x52,
	0xa1, 0xd7, 0x0f, 0x0c, 0xf1, 0x72, 0x2e, 0x4c, 0x49, 0x44, 0xc0, 0x3b, 0xa7, 0x3e, 0xc1, 0x11,
	0x94, 0x5d, 0xc1, 0x24, 0x21, 0xb5, 0xdd, 0xd1, 0xa2, 0xbb, 0x94, 0x39, 0x8a, 0x47, 0x0f, 0x20,
	0x6b, 0x78, 0x8e, 0x63, 0x33, 0x10, 0xbf, 0xc8, 0x67, 0xc8, 0x43, 0x34, 0x6b, 0x9f, 0x04, 0x1b,
	0xa1, 0xe8, 0x21, 0xa4, 0x43, 0x2f, 0xa0, 0xa2, 0x65, 0xe4, 0xab, 0x15, 0x53, 0x8a, 0x31, 0xca,
	0xa7, 0xe8, 0x36, 0x64, 0xf5, 0xd0, 0x20, 0xae, 0x69, 0xbb, 0x16, 0x4f, 0x3e, 0x83, 0x87, 0x06,
	0xb4, 0x0e, 0x39, 0xb7, 0xef, 0x38, 0x61, 0xf7, 0xc0, 0x0e, 0x42, 0x1a, 0x09, 0x0d, 0xdc, 0xf4,
	0x84, 0x59, 0xd0, 0x1c, 0xc8, 0x47, 0x5c, 0xea, 0x38, 0x96, 0x8f, 0xf2, 0x5f, 0xc9, 0x90, 0x8e,
	0x9e, 0x01, 0xb4, 0x0d, 0x69, 0xaa, 0x07, 0x16, 0xa1, 0x83, 0xcf, 0xba, 0x3c, 0xe5, 0xbd, 0xe8,
	0x70, 0x04, 0x1e, 0x20, 0x27, 0x5b, 0x23, 0xf6, 0x33, 0xb4, 0x46, 0xfc, 0x7a, 0x35, 0xdd, 0x06,
	0x18, 0x26, 0xc6, 0x3f, 0xae, 0x4e, 0xf5, 0xae, 0xd7, 0x63, 0xd1, 0x23, 0x75, 0x2f, 0xff, 0x77,
	0x00, 0x4c, 0xb1, 0x25, 0x06, 0x3d, 0x7f, 0x68, 0xe6, 0x21, 0x37, 0xf2, 0x72, 0xe5, 0x53, 0x90,
	0x60, 0xef, 0xd1, 0xd6, 0xd7, 0x32, 0x28, 0x93, 0xef, 0x00, 0xd2, 0x60, 0xa5, 0xb4, 0xb3, 0x83,
	0x6b, 0x3b, 0xa5, 0x4e, 0xad, 0x8b, 0x4b, 0xcd, 0x9d, 0x5a, 0xb7, 0xb5, 0xd7, 0x6d, 0x34, 0xf7,
	0x4b, 0x4f, 0x1b, 0x55, 0x45, 0x42, 0xb7, 0x41, 0x9d, 0xe2, 0xaf, 0xb4, 0x9e, 0x37, 0x3b, 0x8a,
	0x8c, 0x56, 0x60, 0x69, 0x8a, 0xb7, 0xfd, 0xfc, 0x99, 0x12, 0x9b, 0xe1, 0x7b, 0x56, 0x7a, 0xa1,
	0xc4, 0x67, 0xf9, 0x1a, 0x4d, 0x25, 0x31, 0xe3, 0xc4, 0xf2, 0x5f, 0x3b, 0xb5, 0xb6, 0x92, 0xdc,
	0xfa, 0x77, 0x1c, 0x7e, 0x71, 0x61, 0xa6, 0xa2, 0x75, 0x58, 0x1d, 0x72, 0xf6, 0x6b, 0x95, 0x4e,
	0x0b, 0x8f, 0x5f, 0x63, 0x15, 0x6e, 0x4d, 0x03, 0xb0, 0x4c, 0xe5, 0x59, 0x4e, 0x96, 0x6a, 0x6c,
	0xa6, 0xb3, 0xd1, 0x54, 0xe2, 0x68, 0x0d, 0x96, 0xa7, 0x39, 0x85, 0x3c, 0x89, 0x59, 0xdc, 0xd2,
	0xfe, 0x8e, 0x92, 0x1c, 0x57, 0x7e, 0x24, 0xa5, 0x4e, 0xb5, 0x5a, 0xdb, 0x57, 0x52, 0x97, 0xf8,
	0xf7, 0x4b, 0x58, 0x49, 0xcf, 0xba, 0x73, 0xb9, 0xd5, 0xe9, 0xb4, 0x9e, 0xed, 0x2a, 0x99, 0x71,
	0x21, 0x87, 0x80, 0x4e, 0x6b, 0x6f, 0x57, 0xc9, 0xce, 0xf2, 0xb6, 0x5b, 0xb8, 0xa3, 0x00, 0xba,
	0x03, 0x6b, 0xb3, 0xbc, 0xdd, 0x6a, 0xad, 0x5d, 0x51, 0x72, 0x5b, 0x2f, 0x20, 0xdb, 0xf6, 0x02,
	0xda, 0x0a, 0x4c, 0x12, 0xa0, 0x25, 0x40, 0xdc, 0xd7, 0xc2, 0xd5, 0x1a, 0x1e, 0xd1, 0x5d, 0x85,
	0xc5, 0x11, 0x7b, 0xa9, 0x5d, 0xa9, 0x35, 0xab, 0x8d, 0xe6, 0x8e, 0x22, 0xa3, 0x65, 0xb8, 0x39,
	0xe2, 0x61, 0x31, 0x23, 0x57, 0xac, 0xdc, 0x7f, 0xfb, 0x41, 0x93, 0xde, 0x7d, 0xd0, 0xa4, 0x4f,
	0x1f, 0x34, 0xf9, 0x5f, 0x67, 0x9a, 0xfc, 0xff, 0x33, 0x4d, 0x7e, 0x73, 0xa6, 0xc9, 0x6f, 0xcf,
	0x34, 0xf9, 0xbb, 0x33, 0x4d, 0xfe, 0xe1, 0x4c, 0x93, 0x3e, 0x9d, 0x69, 0xf2, 0xeb, 0x8f, 0x9a,
	0xf4, 0xf6, 0xa3, 0x26, 0xbd, 0xfb, 0xa8, 0x49, 0x7f, 0xfb, 0xf3, 0x35, 0x7f, 0x57, 0x4c, 0xfe,
	0x08, 0xed, 0xa5, 0xb8, 0x65, 0xfb, 0xa7, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7c, 0x29, 0xf4, 0x30,
	0xb3, 0x0e, 0x00, 0x00,
}

func (x AggregateRangeOp) String() string {
	s, ok := AggregateRangeOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AggregateVectorOp) String() string {
	s, ok := AggregateVectorOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SortOrder) String() string {
	s, ok := SortOrder_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Plan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Plan)
	if !ok {
		that2, ok := that.(Plan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	if len(this.Edges) != len(that1.Edges) {
		return false
	}
	for i := range this.Edges {
		if !this.Edges[i].Equal(that1.Edges[i]) {
			return false
		}
	}
	return true
}
func (this *PlanEdge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanEdge)
	if !ok {
		that2, ok := that.(PlanEdge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Parent.Equal(&that1.Parent) {
		return false
	}
	if !this.Child.Equal(&that1.Child) {
		return false
	}
	return true
}
func (this *NodeID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeID)
	if !ok {
		that2, ok := that.(NodeID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node)
	if !ok {
		that2, ok := that.(Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *Node_AggregateRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_AggregateRange)
	if !ok {
		that2, ok := that.(Node_AggregateRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AggregateRange.Equal(that1.AggregateRange) {
		return false
	}
	return true
}
func (this *Node_AggregateVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_AggregateVector)
	if !ok {
		that2, ok := that.(Node_AggregateVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AggregateVector.Equal(that1.AggregateVector) {
		return false
	}
	return true
}
func (this *Node_Scan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Scan)
	if !ok {
		that2, ok := that.(Node_Scan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scan.Equal(that1.Scan) {
		return false
	}
	return true
}
func (this *Node_Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Filter)
	if !ok {
		that2, ok := that.(Node_Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	return true
}
func (this *Node_Limit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Limit)
	if !ok {
		that2, ok := that.(Node_Limit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Limit.Equal(that1.Limit) {
		return false
	}
	return true
}
func (this *Node_Projection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Projection)
	if !ok {
		that2, ok := that.(Node_Projection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Projection.Equal(that1.Projection) {
		return false
	}
	return true
}
func (this *Node_ColumnCompat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_ColumnCompat)
	if !ok {
		that2, ok := that.(Node_ColumnCompat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnCompat.Equal(that1.ColumnCompat) {
		return false
	}
	return true
}
func (this *Node_ScanSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_ScanSet)
	if !ok {
		that2, ok := that.(Node_ScanSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ScanSet.Equal(that1.ScanSet) {
		return false
	}
	return true
}
func (this *Node_TopK) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_TopK)
	if !ok {
		that2, ok := that.(Node_TopK)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TopK.Equal(that1.TopK) {
		return false
	}
	return true
}
func (this *Node_Parallelize) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Parallelize)
	if !ok {
		that2, ok := that.(Node_Parallelize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Parallelize.Equal(that1.Parallelize) {
		return false
	}
	return true
}
func (this *Node_Join) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node_Join)
	if !ok {
		that2, ok := that.(Node_Join)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Join.Equal(that1.Join) {
		return false
	}
	return true
}
func (this *AggregateRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateRange)
	if !ok {
		that2, ok := that.(AggregateRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PartitionBy) != len(that1.PartitionBy) {
		return false
	}
	for i := range this.PartitionBy {
		if !this.PartitionBy[i].Equal(that1.PartitionBy[i]) {
			return false
		}
	}
	if this.Operation != that1.Operation {
		return false
	}
	if !this.Start.Equal(that1.Start) {
		return false
	}
	if !this.End.Equal(that1.End) {
		return false
	}
	if this.Step != that1.Step {
		return false
	}
	if this.Range != that1.Range {
		return false
	}
	return true
}
func (this *AggregateVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateVector)
	if !ok {
		that2, ok := that.(AggregateVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GroupBy) != len(that1.GroupBy) {
		return false
	}
	for i := range this.GroupBy {
		if !this.GroupBy[i].Equal(that1.GroupBy[i]) {
			return false
		}
	}
	if this.Operation != that1.Operation {
		return false
	}
	return true
}
func (this *DataObjScan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataObjScan)
	if !ok {
		that2, ok := that.(DataObjScan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.Section != that1.Section {
		return false
	}
	if len(this.StreamIds) != len(that1.StreamIds) {
		return false
	}
	for i := range this.StreamIds {
		if this.StreamIds[i] != that1.StreamIds[i] {
			return false
		}
	}
	if len(this.Projections) != len(that1.Projections) {
		return false
	}
	for i := range this.Projections {
		if !this.Projections[i].Equal(that1.Projections[i]) {
			return false
		}
	}
	if len(this.Predicates) != len(that1.Predicates) {
		return false
	}
	for i := range this.Predicates {
		if !this.Predicates[i].Equal(that1.Predicates[i]) {
			return false
		}
	}
	return true
}
func (this *Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Filter)
	if !ok {
		that2, ok := that.(Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Predicates) != len(that1.Predicates) {
		return false
	}
	for i := range this.Predicates {
		if !this.Predicates[i].Equal(that1.Predicates[i]) {
			return false
		}
	}
	return true
}
func (this *Limit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Limit)
	if !ok {
		that2, ok := that.(Limit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Skip != that1.Skip {
		return false
	}
	if this.Fetch != that1.Fetch {
		return false
	}
	return true
}
func (this *Projection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Projection)
	if !ok {
		that2, ok := that.(Projection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Expressions) != len(that1.Expressions) {
		return false
	}
	for i := range this.Expressions {
		if !this.Expressions[i].Equal(that1.Expressions[i]) {
			return false
		}
	}
	if this.All != that1.All {
		return false
	}
	if this.Expand != that1.Expand {
		return false
	}
	if this.Drop != that1.Drop {
		return false
	}
	return true
}
func (this *ColumnCompat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnCompat)
	if !ok {
		that2, ok := that.(ColumnCompat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.Destination != that1.Destination {
		return false
	}
	if this.Collision != that1.Collision {
		return false
	}
	return true
}
func (this *TopK) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopK)
	if !ok {
		that2, ok := that.(TopK)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SortBy.Equal(that1.SortBy) {
		return false
	}
	if this.Ascending != that1.Ascending {
		return false
	}
	if this.NullsFirst != that1.NullsFirst {
		return false
	}
	if this.K != that1.K {
		return false
	}
	return true
}
func (this *ScanSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScanSet)
	if !ok {
		that2, ok := that.(ScanSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Targets) != len(that1.Targets) {
		return false
	}
	for i := range this.Targets {
		if !this.Targets[i].Equal(that1.Targets[i]) {
			return false
		}
	}
	if len(this.Projections) != len(that1.Projections) {
		return false
	}
	for i := range this.Projections {
		if !this.Projections[i].Equal(that1.Projections[i]) {
			return false
		}
	}
	if len(this.Predicates) != len(that1.Predicates) {
		return false
	}
	for i := range this.Predicates {
		if !this.Predicates[i].Equal(that1.Predicates[i]) {
			return false
		}
	}
	return true
}
func (this *ScanTarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScanTarget)
	if !ok {
		that2, ok := that.(ScanTarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *ScanTarget_DataObject) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScanTarget_DataObject)
	if !ok {
		that2, ok := that.(ScanTarget_DataObject)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DataObject.Equal(that1.DataObject) {
		return false
	}
	return true
}
func (this *Parallelize) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Parallelize)
	if !ok {
		that2, ok := that.(Parallelize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Join) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Join)
	if !ok {
		that2, ok := that.(Join)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Plan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.Plan{")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	if this.Edges != nil {
		s = append(s, "Edges: "+fmt.Sprintf("%#v", this.Edges)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanEdge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.PlanEdge{")
	s = append(s, "Parent: "+strings.Replace(this.Parent.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Child: "+strings.Replace(this.Child.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.NodeID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&physicalpb.Node{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Node_AggregateRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_AggregateRange{` +
		`AggregateRange:` + fmt.Sprintf("%#v", this.AggregateRange) + `}`}, ", ")
	return s
}
func (this *Node_AggregateVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_AggregateVector{` +
		`AggregateVector:` + fmt.Sprintf("%#v", this.AggregateVector) + `}`}, ", ")
	return s
}
func (this *Node_Scan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_Scan{` +
		`Scan:` + fmt.Sprintf("%#v", this.Scan) + `}`}, ", ")
	return s
}
func (this *Node_Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_Filter{` +
		`Filter:` + fmt.Sprintf("%#v", this.Filter) + `}`}, ", ")
	return s
}
func (this *Node_Limit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_Limit{` +
		`Limit:` + fmt.Sprintf("%#v", this.Limit) + `}`}, ", ")
	return s
}
func (this *Node_Projection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_Projection{` +
		`Projection:` + fmt.Sprintf("%#v", this.Projection) + `}`}, ", ")
	return s
}
func (this *Node_ColumnCompat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_ColumnCompat{` +
		`ColumnCompat:` + fmt.Sprintf("%#v", this.ColumnCompat) + `}`}, ", ")
	return s
}
func (this *Node_ScanSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_ScanSet{` +
		`ScanSet:` + fmt.Sprintf("%#v", this.ScanSet) + `}`}, ", ")
	return s
}
func (this *Node_TopK) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_TopK{` +
		`TopK:` + fmt.Sprintf("%#v", this.TopK) + `}`}, ", ")
	return s
}
func (this *Node_Parallelize) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_Parallelize{` +
		`Parallelize:` + fmt.Sprintf("%#v", this.Parallelize) + `}`}, ", ")
	return s
}
func (this *Node_Join) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Node_Join{` +
		`Join:` + fmt.Sprintf("%#v", this.Join) + `}`}, ", ")
	return s
}
func (this *AggregateRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&physicalpb.AggregateRange{")
	if this.PartitionBy != nil {
		s = append(s, "PartitionBy: "+fmt.Sprintf("%#v", this.PartitionBy)+",\n")
	}
	s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "Range: "+fmt.Sprintf("%#v", this.Range)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AggregateVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.AggregateVector{")
	if this.GroupBy != nil {
		s = append(s, "GroupBy: "+fmt.Sprintf("%#v", this.GroupBy)+",\n")
	}
	s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataObjScan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&physicalpb.DataObjScan{")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "Section: "+fmt.Sprintf("%#v", this.Section)+",\n")
	s = append(s, "StreamIds: "+fmt.Sprintf("%#v", this.StreamIds)+",\n")
	if this.Projections != nil {
		s = append(s, "Projections: "+fmt.Sprintf("%#v", this.Projections)+",\n")
	}
	if this.Predicates != nil {
		s = append(s, "Predicates: "+fmt.Sprintf("%#v", this.Predicates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.Filter{")
	if this.Predicates != nil {
		s = append(s, "Predicates: "+fmt.Sprintf("%#v", this.Predicates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Limit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.Limit{")
	s = append(s, "Skip: "+fmt.Sprintf("%#v", this.Skip)+",\n")
	s = append(s, "Fetch: "+fmt.Sprintf("%#v", this.Fetch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Projection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&physicalpb.Projection{")
	if this.Expressions != nil {
		s = append(s, "Expressions: "+fmt.Sprintf("%#v", this.Expressions)+",\n")
	}
	s = append(s, "All: "+fmt.Sprintf("%#v", this.All)+",\n")
	s = append(s, "Expand: "+fmt.Sprintf("%#v", this.Expand)+",\n")
	s = append(s, "Drop: "+fmt.Sprintf("%#v", this.Drop)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnCompat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&physicalpb.ColumnCompat{")
	s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	s = append(s, "Collision: "+fmt.Sprintf("%#v", this.Collision)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TopK) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&physicalpb.TopK{")
	if this.SortBy != nil {
		s = append(s, "SortBy: "+fmt.Sprintf("%#v", this.SortBy)+",\n")
	}
	s = append(s, "Ascending: "+fmt.Sprintf("%#v", this.Ascending)+",\n")
	s = append(s, "NullsFirst: "+fmt.Sprintf("%#v", this.NullsFirst)+",\n")
	s = append(s, "K: "+fmt.Sprintf("%#v", this.K)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScanSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&physicalpb.ScanSet{")
	if this.Targets != nil {
		s = append(s, "Targets: "+fmt.Sprintf("%#v", this.Targets)+",\n")
	}
	if this.Projections != nil {
		s = append(s, "Projections: "+fmt.Sprintf("%#v", this.Projections)+",\n")
	}
	if this.Predicates != nil {
		s = append(s, "Predicates: "+fmt.Sprintf("%#v", this.Predicates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScanTarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.ScanTarget{")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScanTarget_DataObject) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.ScanTarget_DataObject{` +
		`DataObject:` + fmt.Sprintf("%#v", this.DataObject) + `}`}, ", ")
	return s
}
func (this *Parallelize) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&physicalpb.Parallelize{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Join) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&physicalpb.Join{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPhysicalpb(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Edges) > 0 {
		for iNdEx := len(m.Edges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Edges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlanEdge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanEdge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanEdge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NodeID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Value.Size()
		i -= size
		if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Node_AggregateRange) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_AggregateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AggregateRange != nil {
		{
			size, err := m.AggregateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Node_AggregateVector) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_AggregateVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AggregateVector != nil {
		{
			size, err := m.AggregateVector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Node_Scan) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_Scan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scan != nil {
		{
			size, err := m.Scan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Node_Filter) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Node_Limit) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_Limit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Node_Projection) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Projection != nil {
		{
			size, err := m.Projection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Node_ColumnCompat) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_ColumnCompat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnCompat != nil {
		{
			size, err := m.ColumnCompat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Node_ScanSet) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_ScanSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScanSet != nil {
		{
			size, err := m.ScanSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Node_TopK) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_TopK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TopK != nil {
		{
			size, err := m.TopK.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Node_Parallelize) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_Parallelize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Parallelize != nil {
		{
			size, err := m.Parallelize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Node_Join) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Node_Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *AggregateRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n16, err16 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Range, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Range):])
	if err16 != nil {
		return 0, err16
	}
	i -= n16
	i = encodeVarintPhysicalpb(dAtA, i, uint64(n16))
	i--
	dAtA[i] = 0x32
	n17, err17 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Step, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Step):])
	if err17 != nil {
		return 0, err17
	}
	i -= n17
	i = encodeVarintPhysicalpb(dAtA, i, uint64(n17))
	i--
	dAtA[i] = 0x2a
	n18, err18 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.End, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.End):])
	if err18 != nil {
		return 0, err18
	}
	i -= n18
	i = encodeVarintPhysicalpb(dAtA, i, uint64(n18))
	i--
	dAtA[i] = 0x22
	n19, err19 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Start):])
	if err19 != nil {
		return 0, err19
	}
	i -= n19
	i = encodeVarintPhysicalpb(dAtA, i, uint64(n19))
	i--
	dAtA[i] = 0x1a
	if m.Operation != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AggregateVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataObjScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataObjScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataObjScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Predicates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StreamIds) > 0 {
		dAtA21 := make([]byte, len(m.StreamIds)*10)
		var j20 int
		for _, num1 := range m.StreamIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintPhysicalpb(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x1a
	}
	if m.Section != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Section))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintPhysicalpb(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Predicates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Limit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fetch != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Fetch))
		i--
		dAtA[i] = 0x10
	}
	if m.Skip != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Skip))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Drop {
		i--
		if m.Drop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Expand {
		i--
		if m.Expand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Expressions) > 0 {
		for iNdEx := len(m.Expressions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Expressions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ColumnCompat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnCompat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnCompat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Collision != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Collision))
		i--
		dAtA[i] = 0x18
	}
	if m.Destination != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Destination))
		i--
		dAtA[i] = 0x10
	}
	if m.Source != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.K != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.K))
		i--
		dAtA[i] = 0x20
	}
	if m.NullsFirst {
		i--
		if m.NullsFirst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Ascending {
		i--
		if m.Ascending {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.SortBy != nil {
		{
			size, err := m.SortBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Predicates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScanTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScanTarget_DataObject) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *ScanTarget_DataObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DataObject != nil {
		{
			size, err := m.DataObject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Parallelize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parallelize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Parallelize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Join) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintPhysicalpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPhysicalpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Plan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	return n
}

func (m *PlanEdge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Parent.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	l = m.Child.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	return n
}

func (m *NodeID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *Node_AggregateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregateRange != nil {
		l = m.AggregateRange.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_AggregateVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregateVector != nil {
		l = m.AggregateVector.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_Scan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_Limit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != nil {
		l = m.Limit.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_Projection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Projection != nil {
		l = m.Projection.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_ColumnCompat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnCompat != nil {
		l = m.ColumnCompat.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_ScanSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScanSet != nil {
		l = m.ScanSet.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_TopK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopK != nil {
		l = m.TopK.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_Parallelize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parallelize != nil {
		l = m.Parallelize.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Node_Join) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Join != nil {
		l = m.Join.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *AggregateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if m.Operation != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Operation))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovPhysicalpb(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.End)
	n += 1 + l + sovPhysicalpb(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Step)
	n += 1 + l + sovPhysicalpb(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Range)
	n += 1 + l + sovPhysicalpb(uint64(l))
	return n
}

func (m *AggregateVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if m.Operation != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Operation))
	}
	return n
}

func (m *DataObjScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	if m.Section != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Section))
	}
	if len(m.StreamIds) > 0 {
		l = 0
		for _, e := range m.StreamIds {
			l += sovPhysicalpb(uint64(e))
		}
		n += 1 + sovPhysicalpb(uint64(l)) + l
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if len(m.Predicates) > 0 {
		for _, e := range m.Predicates {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Predicates) > 0 {
		for _, e := range m.Predicates {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	return n
}

func (m *Limit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Skip != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Skip))
	}
	if m.Fetch != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Fetch))
	}
	return n
}

func (m *Projection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, e := range m.Expressions {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if m.All {
		n += 2
	}
	if m.Expand {
		n += 2
	}
	if m.Drop {
		n += 2
	}
	return n
}

func (m *ColumnCompat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Source))
	}
	if m.Destination != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Destination))
	}
	if m.Collision != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Collision))
	}
	return n
}

func (m *TopK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SortBy != nil {
		l = m.SortBy.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	if m.Ascending {
		n += 2
	}
	if m.NullsFirst {
		n += 2
	}
	if m.K != 0 {
		n += 1 + sovPhysicalpb(uint64(m.K))
	}
	return n
}

func (m *ScanSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if len(m.Predicates) > 0 {
		for _, e := range m.Predicates {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	return n
}

func (m *ScanTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *ScanTarget_DataObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataObject != nil {
		l = m.DataObject.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *Parallelize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Join) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPhysicalpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPhysicalpb(x uint64) (n int) {
	return sovPhysicalpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Plan) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*Node{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "Node", "Node", 1) + ","
	}
	repeatedStringForNodes += "}"
	repeatedStringForEdges := "[]*PlanEdge{"
	for _, f := range this.Edges {
		repeatedStringForEdges += strings.Replace(f.String(), "PlanEdge", "PlanEdge", 1) + ","
	}
	repeatedStringForEdges += "}"
	s := strings.Join([]string{`&Plan{`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`Edges:` + repeatedStringForEdges + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanEdge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanEdge{`,
		`Parent:` + strings.Replace(strings.Replace(this.Parent.String(), "NodeID", "NodeID", 1), `&`, ``, 1) + `,`,
		`Child:` + strings.Replace(strings.Replace(this.Child.String(), "NodeID", "NodeID", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "NodeID", "NodeID", 1), `&`, ``, 1) + `,`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_AggregateRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_AggregateRange{`,
		`AggregateRange:` + strings.Replace(fmt.Sprintf("%v", this.AggregateRange), "AggregateRange", "AggregateRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_AggregateVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_AggregateVector{`,
		`AggregateVector:` + strings.Replace(fmt.Sprintf("%v", this.AggregateVector), "AggregateVector", "AggregateVector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Scan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Scan{`,
		`Scan:` + strings.Replace(fmt.Sprintf("%v", this.Scan), "DataObjScan", "DataObjScan", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Filter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Filter{`,
		`Filter:` + strings.Replace(fmt.Sprintf("%v", this.Filter), "Filter", "Filter", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Limit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Limit{`,
		`Limit:` + strings.Replace(fmt.Sprintf("%v", this.Limit), "Limit", "Limit", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Projection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Projection{`,
		`Projection:` + strings.Replace(fmt.Sprintf("%v", this.Projection), "Projection", "Projection", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_ColumnCompat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_ColumnCompat{`,
		`ColumnCompat:` + strings.Replace(fmt.Sprintf("%v", this.ColumnCompat), "ColumnCompat", "ColumnCompat", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_ScanSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_ScanSet{`,
		`ScanSet:` + strings.Replace(fmt.Sprintf("%v", this.ScanSet), "ScanSet", "ScanSet", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_TopK) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_TopK{`,
		`TopK:` + strings.Replace(fmt.Sprintf("%v", this.TopK), "TopK", "TopK", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Parallelize) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Parallelize{`,
		`Parallelize:` + strings.Replace(fmt.Sprintf("%v", this.Parallelize), "Parallelize", "Parallelize", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Node_Join) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Node_Join{`,
		`Join:` + strings.Replace(fmt.Sprintf("%v", this.Join), "Join", "Join", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateRange) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPartitionBy := "[]*ColumnExpression{"
	for _, f := range this.PartitionBy {
		repeatedStringForPartitionBy += strings.Replace(fmt.Sprintf("%v", f), "ColumnExpression", "expressionpb.ColumnExpression", 1) + ","
	}
	repeatedStringForPartitionBy += "}"
	s := strings.Join([]string{`&AggregateRange{`,
		`PartitionBy:` + repeatedStringForPartitionBy + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`Start:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Start), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`End:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.End), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`Step:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Step), "Duration", "durationpb.Duration", 1), `&`, ``, 1) + `,`,
		`Range:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Range), "Duration", "durationpb.Duration", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateVector) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGroupBy := "[]*ColumnExpression{"
	for _, f := range this.GroupBy {
		repeatedStringForGroupBy += strings.Replace(fmt.Sprintf("%v", f), "ColumnExpression", "expressionpb.ColumnExpression", 1) + ","
	}
	repeatedStringForGroupBy += "}"
	s := strings.Join([]string{`&AggregateVector{`,
		`GroupBy:` + repeatedStringForGroupBy + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataObjScan) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProjections := "[]*ColumnExpression{"
	for _, f := range this.Projections {
		repeatedStringForProjections += strings.Replace(fmt.Sprintf("%v", f), "ColumnExpression", "expressionpb.ColumnExpression", 1) + ","
	}
	repeatedStringForProjections += "}"
	repeatedStringForPredicates := "[]*Expression{"
	for _, f := range this.Predicates {
		repeatedStringForPredicates += strings.Replace(fmt.Sprintf("%v", f), "Expression", "expressionpb.Expression", 1) + ","
	}
	repeatedStringForPredicates += "}"
	s := strings.Join([]string{`&DataObjScan{`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Section:` + fmt.Sprintf("%v", this.Section) + `,`,
		`StreamIds:` + fmt.Sprintf("%v", this.StreamIds) + `,`,
		`Projections:` + repeatedStringForProjections + `,`,
		`Predicates:` + repeatedStringForPredicates + `,`,
		`}`,
	}, "")
	return s
}
func (this *Filter) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPredicates := "[]*Expression{"
	for _, f := range this.Predicates {
		repeatedStringForPredicates += strings.Replace(fmt.Sprintf("%v", f), "Expression", "expressionpb.Expression", 1) + ","
	}
	repeatedStringForPredicates += "}"
	s := strings.Join([]string{`&Filter{`,
		`Predicates:` + repeatedStringForPredicates + `,`,
		`}`,
	}, "")
	return s
}
func (this *Limit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Limit{`,
		`Skip:` + fmt.Sprintf("%v", this.Skip) + `,`,
		`Fetch:` + fmt.Sprintf("%v", this.Fetch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Projection) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForExpressions := "[]*Expression{"
	for _, f := range this.Expressions {
		repeatedStringForExpressions += strings.Replace(fmt.Sprintf("%v", f), "Expression", "expressionpb.Expression", 1) + ","
	}
	repeatedStringForExpressions += "}"
	s := strings.Join([]string{`&Projection{`,
		`Expressions:` + repeatedStringForExpressions + `,`,
		`All:` + fmt.Sprintf("%v", this.All) + `,`,
		`Expand:` + fmt.Sprintf("%v", this.Expand) + `,`,
		`Drop:` + fmt.Sprintf("%v", this.Drop) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnCompat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnCompat{`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`Destination:` + fmt.Sprintf("%v", this.Destination) + `,`,
		`Collision:` + fmt.Sprintf("%v", this.Collision) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TopK) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TopK{`,
		`SortBy:` + strings.Replace(fmt.Sprintf("%v", this.SortBy), "ColumnExpression", "expressionpb.ColumnExpression", 1) + `,`,
		`Ascending:` + fmt.Sprintf("%v", this.Ascending) + `,`,
		`NullsFirst:` + fmt.Sprintf("%v", this.NullsFirst) + `,`,
		`K:` + fmt.Sprintf("%v", this.K) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScanSet) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTargets := "[]*ScanTarget{"
	for _, f := range this.Targets {
		repeatedStringForTargets += strings.Replace(f.String(), "ScanTarget", "ScanTarget", 1) + ","
	}
	repeatedStringForTargets += "}"
	repeatedStringForProjections := "[]*ColumnExpression{"
	for _, f := range this.Projections {
		repeatedStringForProjections += strings.Replace(fmt.Sprintf("%v", f), "ColumnExpression", "expressionpb.ColumnExpression", 1) + ","
	}
	repeatedStringForProjections += "}"
	repeatedStringForPredicates := "[]*Expression{"
	for _, f := range this.Predicates {
		repeatedStringForPredicates += strings.Replace(fmt.Sprintf("%v", f), "Expression", "expressionpb.Expression", 1) + ","
	}
	repeatedStringForPredicates += "}"
	s := strings.Join([]string{`&ScanSet{`,
		`Targets:` + repeatedStringForTargets + `,`,
		`Projections:` + repeatedStringForProjections + `,`,
		`Predicates:` + repeatedStringForPredicates + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScanTarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScanTarget{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScanTarget_DataObject) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScanTarget_DataObject{`,
		`DataObject:` + strings.Replace(fmt.Sprintf("%v", this.DataObject), "DataObjScan", "DataObjScan", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Parallelize) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Parallelize{`,
		`}`,
	}, "")
	return s
}
func (this *Join) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Join{`,
		`}`,
	}, "")
	return s
}
func valueToStringPhysicalpb(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &PlanEdge{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanEdge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanEdge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanEdge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AggregateRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_AggregateRange{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateVector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AggregateVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_AggregateVector{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataObjScan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_Scan{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_Filter{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Limit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_Limit{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Projection{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_Projection{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnCompat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnCompat{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_ColumnCompat{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScanSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_ScanSet{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopK", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TopK{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_TopK{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Parallelize{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_Parallelize{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Join{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Node_Join{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &expressionpb.ColumnExpression{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= AggregateRangeOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.End, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Step, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Range, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &expressionpb.ColumnExpression{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= AggregateVectorOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataObjScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataObjScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataObjScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Section", wireType)
			}
			m.Section = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Section |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StreamIds = append(m.StreamIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPhysicalpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPhysicalpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StreamIds) == 0 {
					m.StreamIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StreamIds = append(m.StreamIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIds", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, &expressionpb.ColumnExpression{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, &expressionpb.Expression{})
			if err := m.Predicates[len(m.Predicates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, &expressionpb.Expression{})
			if err := m.Predicates[len(m.Predicates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			m.Skip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Skip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fetch", wireType)
			}
			m.Fetch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fetch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expressions = append(m.Expressions, &expressionpb.Expression{})
			if err := m.Expressions[len(m.Expressions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expand = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnCompat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnCompat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnCompat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= expressionpb.ColumnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			m.Destination = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Destination |= expressionpb.ColumnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collision", wireType)
			}
			m.Collision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Collision |= expressionpb.ColumnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SortBy == nil {
				m.SortBy = &expressionpb.ColumnExpression{}
			}
			if err := m.SortBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ascending", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ascending = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullsFirst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NullsFirst = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &ScanTarget{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, &expressionpb.ColumnExpression{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, &expressionpb.Expression{})
			if err := m.Predicates[len(m.Predicates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataObjScan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &ScanTarget_DataObject{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parallelize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parallelize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parallelize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Join) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Join: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Join: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPhysicalpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPhysicalpb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPhysicalpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPhysicalpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPhysicalpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPhysicalpb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPhysicalpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPhysicalpb   = fmt.Errorf("proto: integer overflow")
)
