// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/engine/internal/planner/physical/physicalpb/expression.proto

package physicalpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UnaryOp denotes the kind of unary operation to perform.
type UnaryOp int32

const (
	UNARY_OP_INVALID       UnaryOp = 0
	UNARY_OP_NOT           UnaryOp = 1
	UNARY_OP_ABS           UnaryOp = 2
	UNARY_OP_CAST_FLOAT    UnaryOp = 3
	UNARY_OP_CAST_BYTES    UnaryOp = 4
	UNARY_OP_CAST_DURATION UnaryOp = 5
)

var UnaryOp_name = map[int32]string{
	0: "UNARY_OP_INVALID",
	1: "UNARY_OP_NOT",
	2: "UNARY_OP_ABS",
	3: "UNARY_OP_CAST_FLOAT",
	4: "UNARY_OP_CAST_BYTES",
	5: "UNARY_OP_CAST_DURATION",
}

var UnaryOp_value = map[string]int32{
	"UNARY_OP_INVALID":       0,
	"UNARY_OP_NOT":           1,
	"UNARY_OP_ABS":           2,
	"UNARY_OP_CAST_FLOAT":    3,
	"UNARY_OP_CAST_BYTES":    4,
	"UNARY_OP_CAST_DURATION": 5,
}

func (UnaryOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{0}
}

// BinaryOp denotes the kind of binary operation to perform.
type BinaryOp int32

const (
	BINARY_OP_INVALID           BinaryOp = 0
	BINARY_OP_EQ                BinaryOp = 1
	BINARY_OP_NEQ               BinaryOp = 2
	BINARY_OP_GT                BinaryOp = 3
	BINARY_OP_GTE               BinaryOp = 4
	BINARY_OP_LT                BinaryOp = 5
	BINARY_OP_LTE               BinaryOp = 6
	BINARY_OP_AND               BinaryOp = 7
	BINARY_OP_OR                BinaryOp = 8
	BINARY_OP_XOR               BinaryOp = 9
	BINARY_OP_NOT               BinaryOp = 10
	BINARY_OP_ADD               BinaryOp = 11
	BINARY_OP_SUB               BinaryOp = 12
	BINARY_OP_MUL               BinaryOp = 13
	BINARY_OP_DIV               BinaryOp = 14
	BINARY_OP_MOD               BinaryOp = 15
	BINARY_OP_POW               BinaryOp = 16
	BINARY_OP_MATCH_SUBSTR      BinaryOp = 17
	BINARY_OP_NOT_MATCH_SUBSTR  BinaryOp = 18
	BINARY_OP_MATCH_RE          BinaryOp = 19
	BINARY_OP_NOT_MATCH_RE      BinaryOp = 20
	BINARY_OP_MATCH_PATTERN     BinaryOp = 21
	BINARY_OP_NOT_MATCH_PATTERN BinaryOp = 22
)

var BinaryOp_name = map[int32]string{
	0:  "BINARY_OP_INVALID",
	1:  "BINARY_OP_EQ",
	2:  "BINARY_OP_NEQ",
	3:  "BINARY_OP_GT",
	4:  "BINARY_OP_GTE",
	5:  "BINARY_OP_LT",
	6:  "BINARY_OP_LTE",
	7:  "BINARY_OP_AND",
	8:  "BINARY_OP_OR",
	9:  "BINARY_OP_XOR",
	10: "BINARY_OP_NOT",
	11: "BINARY_OP_ADD",
	12: "BINARY_OP_SUB",
	13: "BINARY_OP_MUL",
	14: "BINARY_OP_DIV",
	15: "BINARY_OP_MOD",
	16: "BINARY_OP_POW",
	17: "BINARY_OP_MATCH_SUBSTR",
	18: "BINARY_OP_NOT_MATCH_SUBSTR",
	19: "BINARY_OP_MATCH_RE",
	20: "BINARY_OP_NOT_MATCH_RE",
	21: "BINARY_OP_MATCH_PATTERN",
	22: "BINARY_OP_NOT_MATCH_PATTERN",
}

var BinaryOp_value = map[string]int32{
	"BINARY_OP_INVALID":           0,
	"BINARY_OP_EQ":                1,
	"BINARY_OP_NEQ":               2,
	"BINARY_OP_GT":                3,
	"BINARY_OP_GTE":               4,
	"BINARY_OP_LT":                5,
	"BINARY_OP_LTE":               6,
	"BINARY_OP_AND":               7,
	"BINARY_OP_OR":                8,
	"BINARY_OP_XOR":               9,
	"BINARY_OP_NOT":               10,
	"BINARY_OP_ADD":               11,
	"BINARY_OP_SUB":               12,
	"BINARY_OP_MUL":               13,
	"BINARY_OP_DIV":               14,
	"BINARY_OP_MOD":               15,
	"BINARY_OP_POW":               16,
	"BINARY_OP_MATCH_SUBSTR":      17,
	"BINARY_OP_NOT_MATCH_SUBSTR":  18,
	"BINARY_OP_MATCH_RE":          19,
	"BINARY_OP_NOT_MATCH_RE":      20,
	"BINARY_OP_MATCH_PATTERN":     21,
	"BINARY_OP_NOT_MATCH_PATTERN": 22,
}

func (BinaryOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{1}
}

// ColumnType holds valid types of columns that can be referenced.
type ColumnType int32

const (
	COLUMN_TYPE_INVALID   ColumnType = 0
	COLUMN_TYPE_BUILTIN   ColumnType = 1
	COLUMN_TYPE_LABEL     ColumnType = 2
	COLUMN_TYPE_METADATA  ColumnType = 3
	COLUMN_TYPE_PARSED    ColumnType = 4
	COLUMN_TYPE_AMBIGUOUS ColumnType = 5
	COLUMN_TYPE_GENERATED ColumnType = 6
)

var ColumnType_name = map[int32]string{
	0: "COLUMN_TYPE_INVALID",
	1: "COLUMN_TYPE_BUILTIN",
	2: "COLUMN_TYPE_LABEL",
	3: "COLUMN_TYPE_METADATA",
	4: "COLUMN_TYPE_PARSED",
	5: "COLUMN_TYPE_AMBIGUOUS",
	6: "COLUMN_TYPE_GENERATED",
}

var ColumnType_value = map[string]int32{
	"COLUMN_TYPE_INVALID":   0,
	"COLUMN_TYPE_BUILTIN":   1,
	"COLUMN_TYPE_LABEL":     2,
	"COLUMN_TYPE_METADATA":  3,
	"COLUMN_TYPE_PARSED":    4,
	"COLUMN_TYPE_AMBIGUOUS": 5,
	"COLUMN_TYPE_GENERATED": 6,
}

func (ColumnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{2}
}

// Expression represents an expression used to compute values in output arrays.
type Expression struct {
	// Types that are valid to be assigned to Kind:
	//
	//	*Expression_UnaryExpression
	//	*Expression_BinaryExpression
	//	*Expression_LiteralExpression
	//	*Expression_ColumnExpression
	Kind isExpression_Kind `protobuf_oneof:"kind"`
}

func (m *Expression) Reset()      { *m = Expression{} }
func (*Expression) ProtoMessage() {}
func (*Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{0}
}
func (m *Expression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression.Merge(m, src)
}
func (m *Expression) XXX_Size() int {
	return m.Size()
}
func (m *Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_Expression proto.InternalMessageInfo

type isExpression_Kind interface {
	isExpression_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Expression_UnaryExpression struct {
	UnaryExpression *UnaryExpression `protobuf:"bytes,1,opt,name=unary_expression,json=unaryExpression,proto3,oneof"`
}
type Expression_BinaryExpression struct {
	BinaryExpression *BinaryExpression `protobuf:"bytes,2,opt,name=binary_expression,json=binaryExpression,proto3,oneof"`
}
type Expression_LiteralExpression struct {
	LiteralExpression *LiteralExpression `protobuf:"bytes,3,opt,name=literal_expression,json=literalExpression,proto3,oneof"`
}
type Expression_ColumnExpression struct {
	ColumnExpression *ColumnExpression `protobuf:"bytes,4,opt,name=column_expression,json=columnExpression,proto3,oneof"`
}

func (*Expression_UnaryExpression) isExpression_Kind()   {}
func (*Expression_BinaryExpression) isExpression_Kind()  {}
func (*Expression_LiteralExpression) isExpression_Kind() {}
func (*Expression_ColumnExpression) isExpression_Kind()  {}

func (m *Expression) GetKind() isExpression_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *Expression) GetUnaryExpression() *UnaryExpression {
	if x, ok := m.GetKind().(*Expression_UnaryExpression); ok {
		return x.UnaryExpression
	}
	return nil
}

func (m *Expression) GetBinaryExpression() *BinaryExpression {
	if x, ok := m.GetKind().(*Expression_BinaryExpression); ok {
		return x.BinaryExpression
	}
	return nil
}

func (m *Expression) GetLiteralExpression() *LiteralExpression {
	if x, ok := m.GetKind().(*Expression_LiteralExpression); ok {
		return x.LiteralExpression
	}
	return nil
}

func (m *Expression) GetColumnExpression() *ColumnExpression {
	if x, ok := m.GetKind().(*Expression_ColumnExpression); ok {
		return x.ColumnExpression
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Expression) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Expression_UnaryExpression)(nil),
		(*Expression_BinaryExpression)(nil),
		(*Expression_LiteralExpression)(nil),
		(*Expression_ColumnExpression)(nil),
	}
}

// UnaryExpression represents a unary operation applied to an expression.
type UnaryExpression struct {
	Op    UnaryOp     `protobuf:"varint,1,opt,name=op,proto3,enum=physical.engine.loki.v1.UnaryOp" json:"op,omitempty"`
	Value *Expression `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UnaryExpression) Reset()      { *m = UnaryExpression{} }
func (*UnaryExpression) ProtoMessage() {}
func (*UnaryExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{1}
}
func (m *UnaryExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnaryExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnaryExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnaryExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnaryExpression.Merge(m, src)
}
func (m *UnaryExpression) XXX_Size() int {
	return m.Size()
}
func (m *UnaryExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_UnaryExpression.DiscardUnknown(m)
}

var xxx_messageInfo_UnaryExpression proto.InternalMessageInfo

func (m *UnaryExpression) GetOp() UnaryOp {
	if m != nil {
		return m.Op
	}
	return UNARY_OP_INVALID
}

func (m *UnaryExpression) GetValue() *Expression {
	if m != nil {
		return m.Value
	}
	return nil
}

// BinaryExpression represents a binary operation applied to two expressions.
type BinaryExpression struct {
	Op    BinaryOp    `protobuf:"varint,1,opt,name=op,proto3,enum=physical.engine.loki.v1.BinaryOp" json:"op,omitempty"`
	Left  *Expression `protobuf:"bytes,2,opt,name=left,proto3" json:"left,omitempty"`
	Right *Expression `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
}

func (m *BinaryExpression) Reset()      { *m = BinaryExpression{} }
func (*BinaryExpression) ProtoMessage() {}
func (*BinaryExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{2}
}
func (m *BinaryExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryExpression.Merge(m, src)
}
func (m *BinaryExpression) XXX_Size() int {
	return m.Size()
}
func (m *BinaryExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryExpression.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryExpression proto.InternalMessageInfo

func (m *BinaryExpression) GetOp() BinaryOp {
	if m != nil {
		return m.Op
	}
	return BINARY_OP_INVALID
}

func (m *BinaryExpression) GetLeft() *Expression {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *BinaryExpression) GetRight() *Expression {
	if m != nil {
		return m.Right
	}
	return nil
}

// LiteralExpression represents a constant literal value in an expression tree.
type LiteralExpression struct {
	// Types that are valid to be assigned to Kind:
	//
	//	*LiteralExpression_NullLiteral
	//	*LiteralExpression_BoolLiteral
	//	*LiteralExpression_StringLiteral
	//	*LiteralExpression_IntegerLiteral
	//	*LiteralExpression_FloatLiteral
	//	*LiteralExpression_TimestampLiteral
	//	*LiteralExpression_DurationLiteral
	//	*LiteralExpression_BytesLiteral
	Kind isLiteralExpression_Kind `protobuf_oneof:"kind"`
}

func (m *LiteralExpression) Reset()      { *m = LiteralExpression{} }
func (*LiteralExpression) ProtoMessage() {}
func (*LiteralExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{3}
}
func (m *LiteralExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiteralExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiteralExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiteralExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiteralExpression.Merge(m, src)
}
func (m *LiteralExpression) XXX_Size() int {
	return m.Size()
}
func (m *LiteralExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_LiteralExpression.DiscardUnknown(m)
}

var xxx_messageInfo_LiteralExpression proto.InternalMessageInfo

type isLiteralExpression_Kind interface {
	isLiteralExpression_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LiteralExpression_NullLiteral struct {
	NullLiteral *NullLiteral `protobuf:"bytes,1,opt,name=null_literal,json=nullLiteral,proto3,oneof"`
}
type LiteralExpression_BoolLiteral struct {
	BoolLiteral *BoolLiteral `protobuf:"bytes,2,opt,name=bool_literal,json=boolLiteral,proto3,oneof"`
}
type LiteralExpression_StringLiteral struct {
	StringLiteral *StringLiteral `protobuf:"bytes,3,opt,name=string_literal,json=stringLiteral,proto3,oneof"`
}
type LiteralExpression_IntegerLiteral struct {
	IntegerLiteral *IntegerLiteral `protobuf:"bytes,4,opt,name=integer_literal,json=integerLiteral,proto3,oneof"`
}
type LiteralExpression_FloatLiteral struct {
	FloatLiteral *FloatLiteral `protobuf:"bytes,5,opt,name=float_literal,json=floatLiteral,proto3,oneof"`
}
type LiteralExpression_TimestampLiteral struct {
	TimestampLiteral *TimestampLiteral `protobuf:"bytes,6,opt,name=timestamp_literal,json=timestampLiteral,proto3,oneof"`
}
type LiteralExpression_DurationLiteral struct {
	DurationLiteral *DurationLiteral `protobuf:"bytes,7,opt,name=duration_literal,json=durationLiteral,proto3,oneof"`
}
type LiteralExpression_BytesLiteral struct {
	BytesLiteral *BytesLiteral `protobuf:"bytes,8,opt,name=bytes_literal,json=bytesLiteral,proto3,oneof"`
}

func (*LiteralExpression_NullLiteral) isLiteralExpression_Kind()      {}
func (*LiteralExpression_BoolLiteral) isLiteralExpression_Kind()      {}
func (*LiteralExpression_StringLiteral) isLiteralExpression_Kind()    {}
func (*LiteralExpression_IntegerLiteral) isLiteralExpression_Kind()   {}
func (*LiteralExpression_FloatLiteral) isLiteralExpression_Kind()     {}
func (*LiteralExpression_TimestampLiteral) isLiteralExpression_Kind() {}
func (*LiteralExpression_DurationLiteral) isLiteralExpression_Kind()  {}
func (*LiteralExpression_BytesLiteral) isLiteralExpression_Kind()     {}

func (m *LiteralExpression) GetKind() isLiteralExpression_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *LiteralExpression) GetNullLiteral() *NullLiteral {
	if x, ok := m.GetKind().(*LiteralExpression_NullLiteral); ok {
		return x.NullLiteral
	}
	return nil
}

func (m *LiteralExpression) GetBoolLiteral() *BoolLiteral {
	if x, ok := m.GetKind().(*LiteralExpression_BoolLiteral); ok {
		return x.BoolLiteral
	}
	return nil
}

func (m *LiteralExpression) GetStringLiteral() *StringLiteral {
	if x, ok := m.GetKind().(*LiteralExpression_StringLiteral); ok {
		return x.StringLiteral
	}
	return nil
}

func (m *LiteralExpression) GetIntegerLiteral() *IntegerLiteral {
	if x, ok := m.GetKind().(*LiteralExpression_IntegerLiteral); ok {
		return x.IntegerLiteral
	}
	return nil
}

func (m *LiteralExpression) GetFloatLiteral() *FloatLiteral {
	if x, ok := m.GetKind().(*LiteralExpression_FloatLiteral); ok {
		return x.FloatLiteral
	}
	return nil
}

func (m *LiteralExpression) GetTimestampLiteral() *TimestampLiteral {
	if x, ok := m.GetKind().(*LiteralExpression_TimestampLiteral); ok {
		return x.TimestampLiteral
	}
	return nil
}

func (m *LiteralExpression) GetDurationLiteral() *DurationLiteral {
	if x, ok := m.GetKind().(*LiteralExpression_DurationLiteral); ok {
		return x.DurationLiteral
	}
	return nil
}

func (m *LiteralExpression) GetBytesLiteral() *BytesLiteral {
	if x, ok := m.GetKind().(*LiteralExpression_BytesLiteral); ok {
		return x.BytesLiteral
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LiteralExpression) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LiteralExpression_NullLiteral)(nil),
		(*LiteralExpression_BoolLiteral)(nil),
		(*LiteralExpression_StringLiteral)(nil),
		(*LiteralExpression_IntegerLiteral)(nil),
		(*LiteralExpression_FloatLiteral)(nil),
		(*LiteralExpression_TimestampLiteral)(nil),
		(*LiteralExpression_DurationLiteral)(nil),
		(*LiteralExpression_BytesLiteral)(nil),
	}
}

// NullLiteral represents a null literal value.
type NullLiteral struct {
}

func (m *NullLiteral) Reset()      { *m = NullLiteral{} }
func (*NullLiteral) ProtoMessage() {}
func (*NullLiteral) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{4}
}
func (m *NullLiteral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullLiteral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullLiteral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullLiteral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullLiteral.Merge(m, src)
}
func (m *NullLiteral) XXX_Size() int {
	return m.Size()
}
func (m *NullLiteral) XXX_DiscardUnknown() {
	xxx_messageInfo_NullLiteral.DiscardUnknown(m)
}

var xxx_messageInfo_NullLiteral proto.InternalMessageInfo

// BoolLiteral represents a boolean literal value.
type BoolLiteral struct {
	Value bool `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *BoolLiteral) Reset()      { *m = BoolLiteral{} }
func (*BoolLiteral) ProtoMessage() {}
func (*BoolLiteral) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{5}
}
func (m *BoolLiteral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoolLiteral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoolLiteral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoolLiteral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoolLiteral.Merge(m, src)
}
func (m *BoolLiteral) XXX_Size() int {
	return m.Size()
}
func (m *BoolLiteral) XXX_DiscardUnknown() {
	xxx_messageInfo_BoolLiteral.DiscardUnknown(m)
}

var xxx_messageInfo_BoolLiteral proto.InternalMessageInfo

func (m *BoolLiteral) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

// StringLiteral represents a string literal value.
type StringLiteral struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *StringLiteral) Reset()      { *m = StringLiteral{} }
func (*StringLiteral) ProtoMessage() {}
func (*StringLiteral) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{6}
}
func (m *StringLiteral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringLiteral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringLiteral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringLiteral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringLiteral.Merge(m, src)
}
func (m *StringLiteral) XXX_Size() int {
	return m.Size()
}
func (m *StringLiteral) XXX_DiscardUnknown() {
	xxx_messageInfo_StringLiteral.DiscardUnknown(m)
}

var xxx_messageInfo_StringLiteral proto.InternalMessageInfo

func (m *StringLiteral) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// IntegerLiteral represents a signed integer literal value.
type IntegerLiteral struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *IntegerLiteral) Reset()      { *m = IntegerLiteral{} }
func (*IntegerLiteral) ProtoMessage() {}
func (*IntegerLiteral) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{7}
}
func (m *IntegerLiteral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntegerLiteral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntegerLiteral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntegerLiteral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegerLiteral.Merge(m, src)
}
func (m *IntegerLiteral) XXX_Size() int {
	return m.Size()
}
func (m *IntegerLiteral) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegerLiteral.DiscardUnknown(m)
}

var xxx_messageInfo_IntegerLiteral proto.InternalMessageInfo

func (m *IntegerLiteral) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// FloatLiteral represents a floating point literal value.
type FloatLiteral struct {
	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *FloatLiteral) Reset()      { *m = FloatLiteral{} }
func (*FloatLiteral) ProtoMessage() {}
func (*FloatLiteral) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{8}
}
func (m *FloatLiteral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatLiteral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FloatLiteral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FloatLiteral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatLiteral.Merge(m, src)
}
func (m *FloatLiteral) XXX_Size() int {
	return m.Size()
}
func (m *FloatLiteral) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatLiteral.DiscardUnknown(m)
}

var xxx_messageInfo_FloatLiteral proto.InternalMessageInfo

func (m *FloatLiteral) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// TimestampLiteral represents a timestamp literal value in nanoseconds since
// the Unix epoch.
type TimestampLiteral struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *TimestampLiteral) Reset()      { *m = TimestampLiteral{} }
func (*TimestampLiteral) ProtoMessage() {}
func (*TimestampLiteral) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{9}
}
func (m *TimestampLiteral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimestampLiteral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimestampLiteral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimestampLiteral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimestampLiteral.Merge(m, src)
}
func (m *TimestampLiteral) XXX_Size() int {
	return m.Size()
}
func (m *TimestampLiteral) XXX_DiscardUnknown() {
	xxx_messageInfo_TimestampLiteral.DiscardUnknown(m)
}

var xxx_messageInfo_TimestampLiteral proto.InternalMessageInfo

func (m *TimestampLiteral) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// DurationLiteral represents a duration literal value in nanoseconds.
type DurationLiteral struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *DurationLiteral) Reset()      { *m = DurationLiteral{} }
func (*DurationLiteral) ProtoMessage() {}
func (*DurationLiteral) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{10}
}
func (m *DurationLiteral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DurationLiteral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DurationLiteral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DurationLiteral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DurationLiteral.Merge(m, src)
}
func (m *DurationLiteral) XXX_Size() int {
	return m.Size()
}
func (m *DurationLiteral) XXX_DiscardUnknown() {
	xxx_messageInfo_DurationLiteral.DiscardUnknown(m)
}

var xxx_messageInfo_DurationLiteral proto.InternalMessageInfo

func (m *DurationLiteral) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// BytesLiteral represents a bytes count literal value.
type BytesLiteral struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *BytesLiteral) Reset()      { *m = BytesLiteral{} }
func (*BytesLiteral) ProtoMessage() {}
func (*BytesLiteral) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{11}
}
func (m *BytesLiteral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BytesLiteral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BytesLiteral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BytesLiteral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BytesLiteral.Merge(m, src)
}
func (m *BytesLiteral) XXX_Size() int {
	return m.Size()
}
func (m *BytesLiteral) XXX_DiscardUnknown() {
	xxx_messageInfo_BytesLiteral.DiscardUnknown(m)
}

var xxx_messageInfo_BytesLiteral proto.InternalMessageInfo

func (m *BytesLiteral) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// ColumnExpression is an expression used to reference a column.
type ColumnExpression struct {
	Name string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type ColumnType `protobuf:"varint,2,opt,name=type,proto3,enum=physical.engine.loki.v1.ColumnType" json:"type,omitempty"`
}

func (m *ColumnExpression) Reset()      { *m = ColumnExpression{} }
func (*ColumnExpression) ProtoMessage() {}
func (*ColumnExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_14ac7d2685fb6178, []int{12}
}
func (m *ColumnExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnExpression.Merge(m, src)
}
func (m *ColumnExpression) XXX_Size() int {
	return m.Size()
}
func (m *ColumnExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnExpression proto.InternalMessageInfo

func (m *ColumnExpression) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ColumnExpression) GetType() ColumnType {
	if m != nil {
		return m.Type
	}
	return COLUMN_TYPE_INVALID
}

func init() {
	proto.RegisterEnum("physical.engine.loki.v1.UnaryOp", UnaryOp_name, UnaryOp_value)
	proto.RegisterEnum("physical.engine.loki.v1.BinaryOp", BinaryOp_name, BinaryOp_value)
	proto.RegisterEnum("physical.engine.loki.v1.ColumnType", ColumnType_name, ColumnType_value)
	proto.RegisterType((*Expression)(nil), "physical.engine.loki.v1.Expression")
	proto.RegisterType((*UnaryExpression)(nil), "physical.engine.loki.v1.UnaryExpression")
	proto.RegisterType((*BinaryExpression)(nil), "physical.engine.loki.v1.BinaryExpression")
	proto.RegisterType((*LiteralExpression)(nil), "physical.engine.loki.v1.LiteralExpression")
	proto.RegisterType((*NullLiteral)(nil), "physical.engine.loki.v1.NullLiteral")
	proto.RegisterType((*BoolLiteral)(nil), "physical.engine.loki.v1.BoolLiteral")
	proto.RegisterType((*StringLiteral)(nil), "physical.engine.loki.v1.StringLiteral")
	proto.RegisterType((*IntegerLiteral)(nil), "physical.engine.loki.v1.IntegerLiteral")
	proto.RegisterType((*FloatLiteral)(nil), "physical.engine.loki.v1.FloatLiteral")
	proto.RegisterType((*TimestampLiteral)(nil), "physical.engine.loki.v1.TimestampLiteral")
	proto.RegisterType((*DurationLiteral)(nil), "physical.engine.loki.v1.DurationLiteral")
	proto.RegisterType((*BytesLiteral)(nil), "physical.engine.loki.v1.BytesLiteral")
	proto.RegisterType((*ColumnExpression)(nil), "physical.engine.loki.v1.ColumnExpression")
}

func init() {
	proto.RegisterFile("pkg/engine/internal/planner/physical/physicalpb/expression.proto", fileDescriptor_14ac7d2685fb6178)
}

var fileDescriptor_14ac7d2685fb6178 = []byte{
	// 1032 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x96, 0xbd, 0x72, 0xdb, 0x46,
	0x10, 0xc7, 0x09, 0x8a, 0x94, 0xe4, 0x95, 0x48, 0x2e, 0xcf, 0xfa, 0x70, 0xec, 0x19, 0xc4, 0x91,
	0xbf, 0x14, 0x15, 0x64, 0x6c, 0x17, 0x99, 0x74, 0x01, 0x04, 0x58, 0x62, 0x06, 0x02, 0x64, 0x10,
	0x74, 0xac, 0xa4, 0xe0, 0x80, 0x12, 0x44, 0x61, 0x04, 0x01, 0x18, 0x10, 0xd4, 0x44, 0x4d, 0xc6,
	0x8f, 0x90, 0x3c, 0x43, 0x9a, 0xbc, 0x42, 0x8a, 0xf4, 0x29, 0x55, 0xba, 0x8c, 0xa8, 0x26, 0xa5,
	0xfb, 0xa4, 0xc8, 0x1c, 0x48, 0x02, 0x38, 0xc8, 0x30, 0xed, 0x8e, 0xf7, 0xbf, 0xff, 0xfe, 0xb0,
	0xb7, 0xb7, 0xb7, 0x43, 0xf8, 0xd6, 0x3f, 0xed, 0x37, 0x2d, 0xb7, 0x6f, 0xbb, 0x56, 0xd3, 0x76,
	0x43, 0x2b, 0x70, 0x4d, 0xa7, 0xe9, 0x3b, 0xa6, 0xeb, 0x5a, 0x41, 0xd3, 0x3f, 0xb9, 0x18, 0xd8,
	0x87, 0x54, 0x98, 0xfc, 0xf0, 0x7b, 0x4d, 0xeb, 0x27, 0x3f, 0xb0, 0x06, 0x03, 0xdb, 0x73, 0x1b,
	0x7e, 0xe0, 0x85, 0x1e, 0x59, 0x9f, 0x6e, 0x36, 0xc6, 0x98, 0x86, 0xe3, 0x9d, 0xda, 0x8d, 0xf3,
	0xa7, 0x1b, 0xff, 0x15, 0x01, 0xe4, 0xd8, 0x4d, 0x3a, 0x80, 0x43, 0xd7, 0x0c, 0x2e, 0xba, 0x09,
	0xe1, 0x0e, 0x77, 0x9f, 0xdb, 0x5c, 0x7a, 0xb6, 0xd9, 0xc8, 0x41, 0x34, 0x3a, 0x34, 0x20, 0x61,
	0xec, 0x16, 0xf4, 0xda, 0x90, 0x95, 0xc8, 0x6b, 0xa8, 0xf7, 0xec, 0x2c, 0xb7, 0x18, 0x71, 0xbf,
	0xcc, 0xe5, 0x8a, 0xf6, 0x0d, 0x30, 0xf6, 0x32, 0x1a, 0xf9, 0x11, 0x88, 0x63, 0x87, 0x56, 0x60,
	0x3a, 0x69, 0xf4, 0x5c, 0x84, 0xde, 0xca, 0x45, 0x2b, 0xe3, 0x10, 0x86, 0x5d, 0x77, 0xb2, 0x22,
	0x4d, 0xfb, 0xd0, 0x73, 0x86, 0x67, 0x6e, 0x9a, 0x5d, 0x9a, 0x91, 0xf6, 0x76, 0x14, 0xc1, 0xa6,
	0x7d, 0x98, 0xd1, 0xc4, 0x79, 0x28, 0x9d, 0xda, 0xee, 0xd1, 0xc6, 0xcf, 0x50, 0xcb, 0x94, 0x8f,
	0x7c, 0x05, 0x45, 0xcf, 0x8f, 0x8a, 0x5e, 0x7d, 0x76, 0xff, 0xc3, 0x45, 0xd7, 0x7c, 0xbd, 0xe8,
	0xf9, 0xe4, 0x1b, 0x28, 0x9f, 0x9b, 0xce, 0xd0, 0x9a, 0x54, 0xf4, 0x41, 0x6e, 0x50, 0xf2, 0x15,
	0x7d, 0x1c, 0xb1, 0xf1, 0x07, 0x07, 0x98, 0xad, 0x33, 0x79, 0x9a, 0xca, 0xe0, 0x8b, 0x19, 0xd7,
	0x33, 0x49, 0xe1, 0x6b, 0x28, 0x39, 0xd6, 0x71, 0xf8, 0x29, 0x19, 0x44, 0x01, 0x34, 0xf7, 0xc0,
	0xee, 0x9f, 0x84, 0x93, 0x2b, 0xfb, 0xb8, 0xdc, 0xa3, 0x88, 0x8d, 0xdf, 0xca, 0x50, 0xbf, 0x71,
	0x91, 0xa4, 0x05, 0xcb, 0xee, 0xd0, 0x71, 0xba, 0x93, 0xdb, 0x9c, 0x74, 0xef, 0xc3, 0x5c, 0xae,
	0x3a, 0x74, 0x9c, 0x09, 0x65, 0xb7, 0xa0, 0x2f, 0xb9, 0xc9, 0x92, 0xa2, 0x7a, 0x9e, 0x97, 0xa0,
	0x8a, 0x33, 0x50, 0xa2, 0xe7, 0xa5, 0x51, 0xbd, 0x64, 0x49, 0x34, 0xa8, 0x0e, 0xc2, 0xc0, 0x76,
	0xfb, 0x31, 0x6c, 0x7c, 0xde, 0xc7, 0xb9, 0xb0, 0x76, 0x64, 0x4f, 0x70, 0x95, 0x41, 0x5a, 0x20,
	0x3a, 0xd4, 0xe8, 0x24, 0xe8, 0x5b, 0x41, 0x4c, 0x1c, 0x37, 0xe6, 0x93, 0x5c, 0x62, 0x6b, 0xec,
	0x4f, 0x90, 0x55, 0x9b, 0x51, 0x88, 0x02, 0x95, 0x63, 0xc7, 0x33, 0xc3, 0x98, 0x58, 0x8e, 0x88,
	0x8f, 0x72, 0x89, 0x2f, 0xa8, 0x3b, 0xe1, 0x2d, 0x1f, 0xa7, 0xd6, 0xf4, 0xf1, 0x84, 0xf6, 0x99,
	0x35, 0x08, 0xcd, 0x33, 0x3f, 0x26, 0xce, 0xcf, 0x78, 0x3c, 0xc6, 0x34, 0x22, 0xa1, 0x62, 0x98,
	0xd1, 0xe8, 0x90, 0x3a, 0x1a, 0x06, 0x66, 0x68, 0x7b, 0x6e, 0x0c, 0x5e, 0x98, 0x31, 0xa4, 0xa4,
	0x49, 0x40, 0xc2, 0xad, 0x1d, 0xb1, 0x12, 0x3d, 0x7e, 0xef, 0x22, 0xb4, 0x06, 0x31, 0x73, 0x71,
	0xc6, 0xf1, 0x45, 0xea, 0x4e, 0x1d, 0xbf, 0x97, 0x5a, 0xc7, 0x2f, 0xbc, 0x02, 0x4b, 0xa9, 0x16,
	0xdb, 0x78, 0x00, 0x4b, 0xa9, 0x36, 0x21, 0x2b, 0xd3, 0xa7, 0x4b, 0xdb, 0x74, 0x71, 0xfa, 0x2a,
	0x1f, 0x41, 0x85, 0xb9, 0x7e, 0xd6, 0x76, 0x6b, 0x6a, 0x7b, 0x0c, 0x55, 0xf6, 0x4e, 0x59, 0xdf,
	0xdc, 0xd4, 0xf7, 0x10, 0x96, 0xd3, 0x37, 0xc5, 0xba, 0xb8, 0xa9, 0x6b, 0x13, 0x30, 0x5b, 0xfd,
	0x1c, 0xde, 0x13, 0xa8, 0x65, 0xca, 0x99, 0xff, 0xe1, 0x74, 0x8d, 0x72, 0x5c, 0x5d, 0xc0, 0xec,
	0xcc, 0x24, 0x04, 0x4a, 0xae, 0x79, 0x36, 0x3d, 0x6f, 0xf4, 0x9b, 0xce, 0x98, 0xf0, 0xc2, 0x1f,
	0x4f, 0xb9, 0xea, 0x07, 0x26, 0xc5, 0x18, 0x66, 0x5c, 0xf8, 0x96, 0x1e, 0x05, 0x6c, 0xfd, 0xca,
	0xc1, 0xc2, 0x64, 0x5e, 0x92, 0x15, 0xc0, 0x8e, 0x2a, 0xe8, 0x07, 0x5d, 0x6d, 0xbf, 0xdb, 0x52,
	0x5f, 0x09, 0x4a, 0x4b, 0xc2, 0x02, 0x41, 0x58, 0x8e, 0x55, 0x55, 0x33, 0x90, 0x63, 0x14, 0x41,
	0x6c, 0x63, 0x91, 0xac, 0xc3, 0xed, 0x58, 0xd9, 0x16, 0xda, 0x46, 0xf7, 0x85, 0xa2, 0x09, 0x06,
	0xce, 0xdd, 0xdc, 0x10, 0x0f, 0x0c, 0xb9, 0x8d, 0x25, 0x72, 0x17, 0xd6, 0xd8, 0x0d, 0xa9, 0xa3,
	0x0b, 0x46, 0x4b, 0x53, 0xb1, 0xbc, 0xf5, 0xef, 0x1c, 0x2c, 0x4e, 0x27, 0x28, 0x59, 0x85, 0xba,
	0xd8, 0x7a, 0x6f, 0x56, 0x89, 0x2c, 0xbf, 0x44, 0x8e, 0xd4, 0xa1, 0x92, 0x28, 0xaa, 0xfc, 0x12,
	0x8b, 0xac, 0x69, 0x87, 0xe6, 0xc3, 0x98, 0x76, 0x0c, 0x19, 0x4b, 0xac, 0x49, 0x31, 0xb0, 0xcc,
	0x9a, 0x14, 0x43, 0xc6, 0x79, 0x56, 0x12, 0x54, 0x09, 0x17, 0xd8, 0x38, 0x4d, 0xc7, 0x45, 0xd6,
	0xf4, 0x5a, 0xd3, 0xf1, 0x56, 0x26, 0x29, 0xcd, 0x40, 0xc8, 0xa0, 0x24, 0x09, 0x97, 0x58, 0xa9,
	0xdd, 0x11, 0x71, 0x99, 0x95, 0xf6, 0x3a, 0x0a, 0x56, 0x58, 0x49, 0x6a, 0xbd, 0xc2, 0x6a, 0xc6,
	0xa5, 0x49, 0x58, 0x63, 0xa5, 0x7d, 0xed, 0x7b, 0x44, 0x5a, 0xeb, 0x94, 0x4b, 0x30, 0xb6, 0x77,
	0xe9, 0x47, 0xda, 0x86, 0x8e, 0x75, 0xc2, 0xc3, 0x5d, 0x26, 0x41, 0x76, 0x9f, 0x90, 0x35, 0x20,
	0xd9, 0x58, 0x5d, 0xc6, 0xdb, 0x2c, 0x33, 0x89, 0xd3, 0x65, 0x5c, 0x21, 0xf7, 0x60, 0x3d, 0x1b,
	0xb3, 0x2f, 0x18, 0x86, 0xac, 0xab, 0xb8, 0x4a, 0x3e, 0x87, 0x7b, 0xef, 0x0b, 0x9c, 0x1a, 0xd6,
	0xb6, 0xfe, 0xe4, 0x00, 0x92, 0x36, 0xa5, 0x1d, 0xb4, 0xad, 0x29, 0x9d, 0x3d, 0xb5, 0x6b, 0x1c,
	0xec, 0xcb, 0xa9, 0x0e, 0xc8, 0x6c, 0x88, 0x9d, 0x96, 0x62, 0xb4, 0x54, 0xe4, 0x68, 0xc7, 0xa4,
	0x37, 0x14, 0x41, 0x94, 0x15, 0x2c, 0x92, 0x3b, 0xb0, 0x92, 0x96, 0xf7, 0x64, 0x43, 0x90, 0x04,
	0x43, 0xc0, 0x39, 0x7a, 0xc6, 0xf4, 0xce, 0xbe, 0xa0, 0xb7, 0x65, 0x09, 0x4b, 0xe4, 0x33, 0x58,
	0x4d, 0xeb, 0xc2, 0x9e, 0xd8, 0xda, 0xe9, 0x68, 0x9d, 0x36, 0x96, 0xb3, 0x5b, 0x3b, 0xb2, 0x2a,
	0xeb, 0x82, 0x21, 0x4b, 0x38, 0x2f, 0xbe, 0xe1, 0x2e, 0xaf, 0xf8, 0xc2, 0xdb, 0x2b, 0xbe, 0xf0,
	0xee, 0x8a, 0xe7, 0xde, 0x8c, 0x78, 0xee, 0xf7, 0x11, 0xcf, 0xfd, 0x35, 0xe2, 0xb9, 0xcb, 0x11,
	0xcf, 0xfd, 0x3d, 0xe2, 0xb9, 0x7f, 0x46, 0x7c, 0xe1, 0xdd, 0x88, 0xe7, 0x7e, 0xb9, 0xe6, 0x0b,
	0x97, 0xd7, 0x7c, 0xe1, 0xed, 0x35, 0x5f, 0xf8, 0xe1, 0xbb, 0xbe, 0x1d, 0x9e, 0x0c, 0x7b, 0x8d,
	0x43, 0xef, 0xac, 0xd9, 0x0f, 0xcc, 0x63, 0xd3, 0x35, 0x9b, 0xf4, 0xd5, 0x36, 0xcf, 0x9f, 0x37,
	0x3f, 0xf1, 0x2f, 0x6e, 0x6f, 0x3e, 0xfa, 0x63, 0xfb, 0xfc, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x6f, 0xb3, 0x34, 0x12, 0x1c, 0x0b, 0x00, 0x00,
}

func (x UnaryOp) String() string {
	s, ok := UnaryOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BinaryOp) String() string {
	s, ok := BinaryOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ColumnType) String() string {
	s, ok := ColumnType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Expression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Expression)
	if !ok {
		that2, ok := that.(Expression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *Expression_UnaryExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Expression_UnaryExpression)
	if !ok {
		that2, ok := that.(Expression_UnaryExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UnaryExpression.Equal(that1.UnaryExpression) {
		return false
	}
	return true
}
func (this *Expression_BinaryExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Expression_BinaryExpression)
	if !ok {
		that2, ok := that.(Expression_BinaryExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BinaryExpression.Equal(that1.BinaryExpression) {
		return false
	}
	return true
}
func (this *Expression_LiteralExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Expression_LiteralExpression)
	if !ok {
		that2, ok := that.(Expression_LiteralExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LiteralExpression.Equal(that1.LiteralExpression) {
		return false
	}
	return true
}
func (this *Expression_ColumnExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Expression_ColumnExpression)
	if !ok {
		that2, ok := that.(Expression_ColumnExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnExpression.Equal(that1.ColumnExpression) {
		return false
	}
	return true
}
func (this *UnaryExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UnaryExpression)
	if !ok {
		that2, ok := that.(UnaryExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *BinaryExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BinaryExpression)
	if !ok {
		that2, ok := that.(BinaryExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if !this.Left.Equal(that1.Left) {
		return false
	}
	if !this.Right.Equal(that1.Right) {
		return false
	}
	return true
}
func (this *LiteralExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression)
	if !ok {
		that2, ok := that.(LiteralExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *LiteralExpression_NullLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression_NullLiteral)
	if !ok {
		that2, ok := that.(LiteralExpression_NullLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NullLiteral.Equal(that1.NullLiteral) {
		return false
	}
	return true
}
func (this *LiteralExpression_BoolLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression_BoolLiteral)
	if !ok {
		that2, ok := that.(LiteralExpression_BoolLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BoolLiteral.Equal(that1.BoolLiteral) {
		return false
	}
	return true
}
func (this *LiteralExpression_StringLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression_StringLiteral)
	if !ok {
		that2, ok := that.(LiteralExpression_StringLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StringLiteral.Equal(that1.StringLiteral) {
		return false
	}
	return true
}
func (this *LiteralExpression_IntegerLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression_IntegerLiteral)
	if !ok {
		that2, ok := that.(LiteralExpression_IntegerLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IntegerLiteral.Equal(that1.IntegerLiteral) {
		return false
	}
	return true
}
func (this *LiteralExpression_FloatLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression_FloatLiteral)
	if !ok {
		that2, ok := that.(LiteralExpression_FloatLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FloatLiteral.Equal(that1.FloatLiteral) {
		return false
	}
	return true
}
func (this *LiteralExpression_TimestampLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression_TimestampLiteral)
	if !ok {
		that2, ok := that.(LiteralExpression_TimestampLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TimestampLiteral.Equal(that1.TimestampLiteral) {
		return false
	}
	return true
}
func (this *LiteralExpression_DurationLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression_DurationLiteral)
	if !ok {
		that2, ok := that.(LiteralExpression_DurationLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DurationLiteral.Equal(that1.DurationLiteral) {
		return false
	}
	return true
}
func (this *LiteralExpression_BytesLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LiteralExpression_BytesLiteral)
	if !ok {
		that2, ok := that.(LiteralExpression_BytesLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BytesLiteral.Equal(that1.BytesLiteral) {
		return false
	}
	return true
}
func (this *NullLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NullLiteral)
	if !ok {
		that2, ok := that.(NullLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *BoolLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BoolLiteral)
	if !ok {
		that2, ok := that.(BoolLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *StringLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StringLiteral)
	if !ok {
		that2, ok := that.(StringLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *IntegerLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IntegerLiteral)
	if !ok {
		that2, ok := that.(IntegerLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *FloatLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FloatLiteral)
	if !ok {
		that2, ok := that.(FloatLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *TimestampLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TimestampLiteral)
	if !ok {
		that2, ok := that.(TimestampLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *DurationLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DurationLiteral)
	if !ok {
		that2, ok := that.(DurationLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *BytesLiteral) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BytesLiteral)
	if !ok {
		that2, ok := that.(BytesLiteral)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ColumnExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnExpression)
	if !ok {
		that2, ok := that.(ColumnExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *Expression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&physicalpb.Expression{")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Expression_UnaryExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Expression_UnaryExpression{` +
		`UnaryExpression:` + fmt.Sprintf("%#v", this.UnaryExpression) + `}`}, ", ")
	return s
}
func (this *Expression_BinaryExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Expression_BinaryExpression{` +
		`BinaryExpression:` + fmt.Sprintf("%#v", this.BinaryExpression) + `}`}, ", ")
	return s
}
func (this *Expression_LiteralExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Expression_LiteralExpression{` +
		`LiteralExpression:` + fmt.Sprintf("%#v", this.LiteralExpression) + `}`}, ", ")
	return s
}
func (this *Expression_ColumnExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.Expression_ColumnExpression{` +
		`ColumnExpression:` + fmt.Sprintf("%#v", this.ColumnExpression) + `}`}, ", ")
	return s
}
func (this *UnaryExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.UnaryExpression{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BinaryExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&physicalpb.BinaryExpression{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	if this.Left != nil {
		s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	}
	if this.Right != nil {
		s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LiteralExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&physicalpb.LiteralExpression{")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LiteralExpression_NullLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.LiteralExpression_NullLiteral{` +
		`NullLiteral:` + fmt.Sprintf("%#v", this.NullLiteral) + `}`}, ", ")
	return s
}
func (this *LiteralExpression_BoolLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.LiteralExpression_BoolLiteral{` +
		`BoolLiteral:` + fmt.Sprintf("%#v", this.BoolLiteral) + `}`}, ", ")
	return s
}
func (this *LiteralExpression_StringLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.LiteralExpression_StringLiteral{` +
		`StringLiteral:` + fmt.Sprintf("%#v", this.StringLiteral) + `}`}, ", ")
	return s
}
func (this *LiteralExpression_IntegerLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.LiteralExpression_IntegerLiteral{` +
		`IntegerLiteral:` + fmt.Sprintf("%#v", this.IntegerLiteral) + `}`}, ", ")
	return s
}
func (this *LiteralExpression_FloatLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.LiteralExpression_FloatLiteral{` +
		`FloatLiteral:` + fmt.Sprintf("%#v", this.FloatLiteral) + `}`}, ", ")
	return s
}
func (this *LiteralExpression_TimestampLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.LiteralExpression_TimestampLiteral{` +
		`TimestampLiteral:` + fmt.Sprintf("%#v", this.TimestampLiteral) + `}`}, ", ")
	return s
}
func (this *LiteralExpression_DurationLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.LiteralExpression_DurationLiteral{` +
		`DurationLiteral:` + fmt.Sprintf("%#v", this.DurationLiteral) + `}`}, ", ")
	return s
}
func (this *LiteralExpression_BytesLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.LiteralExpression_BytesLiteral{` +
		`BytesLiteral:` + fmt.Sprintf("%#v", this.BytesLiteral) + `}`}, ", ")
	return s
}
func (this *NullLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&physicalpb.NullLiteral{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BoolLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.BoolLiteral{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StringLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.StringLiteral{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IntegerLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.IntegerLiteral{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FloatLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.FloatLiteral{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimestampLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.TimestampLiteral{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DurationLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.DurationLiteral{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BytesLiteral) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.BytesLiteral{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ColumnExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.ColumnExpression{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringExpression(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Expression_UnaryExpression) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_UnaryExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UnaryExpression != nil {
		{
			size, err := m.UnaryExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Expression_BinaryExpression) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_BinaryExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BinaryExpression != nil {
		{
			size, err := m.BinaryExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Expression_LiteralExpression) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_LiteralExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LiteralExpression != nil {
		{
			size, err := m.LiteralExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Expression_ColumnExpression) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Expression_ColumnExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnExpression != nil {
		{
			size, err := m.ColumnExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *UnaryExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnaryExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnaryExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintExpression(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BinaryExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BinaryExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Right != nil {
		{
			size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintExpression(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LiteralExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiteralExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiteralExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LiteralExpression_NullLiteral) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LiteralExpression_NullLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NullLiteral != nil {
		{
			size, err := m.NullLiteral.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LiteralExpression_BoolLiteral) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LiteralExpression_BoolLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BoolLiteral != nil {
		{
			size, err := m.BoolLiteral.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LiteralExpression_StringLiteral) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LiteralExpression_StringLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StringLiteral != nil {
		{
			size, err := m.StringLiteral.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LiteralExpression_IntegerLiteral) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LiteralExpression_IntegerLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IntegerLiteral != nil {
		{
			size, err := m.IntegerLiteral.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *LiteralExpression_FloatLiteral) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LiteralExpression_FloatLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FloatLiteral != nil {
		{
			size, err := m.FloatLiteral.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *LiteralExpression_TimestampLiteral) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LiteralExpression_TimestampLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TimestampLiteral != nil {
		{
			size, err := m.TimestampLiteral.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *LiteralExpression_DurationLiteral) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LiteralExpression_DurationLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DurationLiteral != nil {
		{
			size, err := m.DurationLiteral.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *LiteralExpression_BytesLiteral) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *LiteralExpression_BytesLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BytesLiteral != nil {
		{
			size, err := m.BytesLiteral.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExpression(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *NullLiteral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullLiteral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BoolLiteral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoolLiteral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoolLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value {
		i--
		if m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StringLiteral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringLiteral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IntegerLiteral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntegerLiteral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegerLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintExpression(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FloatLiteral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatLiteral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *TimestampLiteral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimestampLiteral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimestampLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintExpression(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DurationLiteral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DurationLiteral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DurationLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintExpression(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BytesLiteral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BytesLiteral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BytesLiteral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintExpression(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintExpression(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintExpression(dAtA []byte, offset int, v uint64) int {
	offset -= sovExpression(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *Expression_UnaryExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnaryExpression != nil {
		l = m.UnaryExpression.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *Expression_BinaryExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BinaryExpression != nil {
		l = m.BinaryExpression.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *Expression_LiteralExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiteralExpression != nil {
		l = m.LiteralExpression.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *Expression_ColumnExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnExpression != nil {
		l = m.ColumnExpression.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *UnaryExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovExpression(uint64(m.Op))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}

func (m *BinaryExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovExpression(uint64(m.Op))
	}
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}

func (m *LiteralExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *LiteralExpression_NullLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NullLiteral != nil {
		l = m.NullLiteral.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *LiteralExpression_BoolLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoolLiteral != nil {
		l = m.BoolLiteral.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *LiteralExpression_StringLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StringLiteral != nil {
		l = m.StringLiteral.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *LiteralExpression_IntegerLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntegerLiteral != nil {
		l = m.IntegerLiteral.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *LiteralExpression_FloatLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FloatLiteral != nil {
		l = m.FloatLiteral.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *LiteralExpression_TimestampLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimestampLiteral != nil {
		l = m.TimestampLiteral.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *LiteralExpression_DurationLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DurationLiteral != nil {
		l = m.DurationLiteral.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *LiteralExpression_BytesLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesLiteral != nil {
		l = m.BytesLiteral.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}
func (m *NullLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BoolLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value {
		n += 2
	}
	return n
}

func (m *StringLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	return n
}

func (m *IntegerLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovExpression(uint64(m.Value))
	}
	return n
}

func (m *FloatLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *TimestampLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovExpression(uint64(m.Value))
	}
	return n
}

func (m *DurationLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovExpression(uint64(m.Value))
	}
	return n
}

func (m *BytesLiteral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovExpression(uint64(m.Value))
	}
	return n
}

func (m *ColumnExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovExpression(uint64(m.Type))
	}
	return n
}

func sovExpression(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExpression(x uint64) (n int) {
	return sovExpression(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Expression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expression{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Expression_UnaryExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expression_UnaryExpression{`,
		`UnaryExpression:` + strings.Replace(fmt.Sprintf("%v", this.UnaryExpression), "UnaryExpression", "UnaryExpression", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Expression_BinaryExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expression_BinaryExpression{`,
		`BinaryExpression:` + strings.Replace(fmt.Sprintf("%v", this.BinaryExpression), "BinaryExpression", "BinaryExpression", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Expression_LiteralExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expression_LiteralExpression{`,
		`LiteralExpression:` + strings.Replace(fmt.Sprintf("%v", this.LiteralExpression), "LiteralExpression", "LiteralExpression", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Expression_ColumnExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Expression_ColumnExpression{`,
		`ColumnExpression:` + strings.Replace(fmt.Sprintf("%v", this.ColumnExpression), "ColumnExpression", "ColumnExpression", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UnaryExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UnaryExpression{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Value:` + strings.Replace(this.Value.String(), "Expression", "Expression", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BinaryExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BinaryExpression{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Left:` + strings.Replace(this.Left.String(), "Expression", "Expression", 1) + `,`,
		`Right:` + strings.Replace(this.Right.String(), "Expression", "Expression", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression_NullLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression_NullLiteral{`,
		`NullLiteral:` + strings.Replace(fmt.Sprintf("%v", this.NullLiteral), "NullLiteral", "NullLiteral", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression_BoolLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression_BoolLiteral{`,
		`BoolLiteral:` + strings.Replace(fmt.Sprintf("%v", this.BoolLiteral), "BoolLiteral", "BoolLiteral", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression_StringLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression_StringLiteral{`,
		`StringLiteral:` + strings.Replace(fmt.Sprintf("%v", this.StringLiteral), "StringLiteral", "StringLiteral", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression_IntegerLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression_IntegerLiteral{`,
		`IntegerLiteral:` + strings.Replace(fmt.Sprintf("%v", this.IntegerLiteral), "IntegerLiteral", "IntegerLiteral", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression_FloatLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression_FloatLiteral{`,
		`FloatLiteral:` + strings.Replace(fmt.Sprintf("%v", this.FloatLiteral), "FloatLiteral", "FloatLiteral", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression_TimestampLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression_TimestampLiteral{`,
		`TimestampLiteral:` + strings.Replace(fmt.Sprintf("%v", this.TimestampLiteral), "TimestampLiteral", "TimestampLiteral", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression_DurationLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression_DurationLiteral{`,
		`DurationLiteral:` + strings.Replace(fmt.Sprintf("%v", this.DurationLiteral), "DurationLiteral", "DurationLiteral", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LiteralExpression_BytesLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LiteralExpression_BytesLiteral{`,
		`BytesLiteral:` + strings.Replace(fmt.Sprintf("%v", this.BytesLiteral), "BytesLiteral", "BytesLiteral", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NullLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NullLiteral{`,
		`}`,
	}, "")
	return s
}
func (this *BoolLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BoolLiteral{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StringLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StringLiteral{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IntegerLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IntegerLiteral{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FloatLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FloatLiteral{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimestampLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimestampLiteral{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DurationLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DurationLiteral{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BytesLiteral) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BytesLiteral{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ColumnExpression) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ColumnExpression{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringExpression(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnaryExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UnaryExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Expression_UnaryExpression{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BinaryExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Expression_BinaryExpression{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiteralExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LiteralExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Expression_LiteralExpression{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Expression_ColumnExpression{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnaryExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnaryExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnaryExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= UnaryOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Expression{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= BinaryOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &Expression{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &Expression{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiteralExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiteralExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiteralExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullLiteral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NullLiteral{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &LiteralExpression_NullLiteral{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolLiteral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BoolLiteral{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &LiteralExpression_BoolLiteral{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringLiteral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringLiteral{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &LiteralExpression_StringLiteral{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntegerLiteral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IntegerLiteral{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &LiteralExpression_IntegerLiteral{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatLiteral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FloatLiteral{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &LiteralExpression_FloatLiteral{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampLiteral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TimestampLiteral{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &LiteralExpression_TimestampLiteral{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationLiteral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DurationLiteral{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &LiteralExpression_DurationLiteral{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesLiteral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BytesLiteral{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &LiteralExpression_BytesLiteral{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullLiteral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullLiteral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullLiteral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoolLiteral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoolLiteral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoolLiteral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringLiteral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringLiteral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringLiteral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntegerLiteral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntegerLiteral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntegerLiteral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatLiteral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatLiteral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatLiteral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimestampLiteral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimestampLiteral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimestampLiteral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DurationLiteral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DurationLiteral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DurationLiteral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BytesLiteral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BytesLiteral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BytesLiteral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ColumnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExpression(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExpression
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthExpression
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExpression
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExpression(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthExpression
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExpression = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExpression   = fmt.Errorf("proto: integer overflow")
)
