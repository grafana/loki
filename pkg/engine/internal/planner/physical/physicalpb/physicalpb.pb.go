// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/engine/internal/planner/physical/physicalpb/physicalpb.proto

package physicalpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/grafana/loki/v3/pkg/engine/internal/util/ulid"
	github_com_grafana_loki_v3_pkg_engine_internal_util_ulid "github.com/grafana/loki/v3/pkg/engine/internal/util/ulid"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AggregateRangeOp represents the operation to perform on the aggregated
// data.
type AggregateRangeOp int32

const (
	AGGREGATE_RANGE_OP_INVALID AggregateRangeOp = 0
	AGGREGATE_RANGE_OP_COUNT   AggregateRangeOp = 1
	AGGREGATE_RANGE_OP_SUM     AggregateRangeOp = 2
	AGGREGATE_RANGE_OP_MAX     AggregateRangeOp = 3
	AGGREGATE_RANGE_OP_MIN     AggregateRangeOp = 4
)

var AggregateRangeOp_name = map[int32]string{
	0: "AGGREGATE_RANGE_OP_INVALID",
	1: "AGGREGATE_RANGE_OP_COUNT",
	2: "AGGREGATE_RANGE_OP_SUM",
	3: "AGGREGATE_RANGE_OP_MAX",
	4: "AGGREGATE_RANGE_OP_MIN",
}

var AggregateRangeOp_value = map[string]int32{
	"AGGREGATE_RANGE_OP_INVALID": 0,
	"AGGREGATE_RANGE_OP_COUNT":   1,
	"AGGREGATE_RANGE_OP_SUM":     2,
	"AGGREGATE_RANGE_OP_MAX":     3,
	"AGGREGATE_RANGE_OP_MIN":     4,
}

func (AggregateRangeOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{0}
}

// AggregateVectorOp represents the different aggregation operations that can
// be performed on a range vector.
type AggregateVectorOp int32

const (
	AGGREGATE_VECTOR_OP_INVALID   AggregateVectorOp = 0
	AGGREGATE_VECTOR_OP_SUM       AggregateVectorOp = 1
	AGGREGATE_VECTOR_OP_MAX       AggregateVectorOp = 2
	AGGREGATE_VECTOR_OP_MIN       AggregateVectorOp = 3
	AGGREGATE_VECTOR_OP_COUNT     AggregateVectorOp = 4
	AGGREGATE_VECTOR_OP_AVG       AggregateVectorOp = 5
	AGGREGATE_VECTOR_OP_STDDEV    AggregateVectorOp = 6
	AGGREGATE_VECTOR_OP_STDVAR    AggregateVectorOp = 7
	AGGREGATE_VECTOR_OP_BOTTOMK   AggregateVectorOp = 8
	AGGREGATE_VECTOR_OP_TOPK      AggregateVectorOp = 9
	AGGREGATE_VECTOR_OP_SORT      AggregateVectorOp = 10
	AGGREGATE_VECTOR_OP_SORT_DESC AggregateVectorOp = 11
)

var AggregateVectorOp_name = map[int32]string{
	0:  "AGGREGATE_VECTOR_OP_INVALID",
	1:  "AGGREGATE_VECTOR_OP_SUM",
	2:  "AGGREGATE_VECTOR_OP_MAX",
	3:  "AGGREGATE_VECTOR_OP_MIN",
	4:  "AGGREGATE_VECTOR_OP_COUNT",
	5:  "AGGREGATE_VECTOR_OP_AVG",
	6:  "AGGREGATE_VECTOR_OP_STDDEV",
	7:  "AGGREGATE_VECTOR_OP_STDVAR",
	8:  "AGGREGATE_VECTOR_OP_BOTTOMK",
	9:  "AGGREGATE_VECTOR_OP_TOPK",
	10: "AGGREGATE_VECTOR_OP_SORT",
	11: "AGGREGATE_VECTOR_OP_SORT_DESC",
}

var AggregateVectorOp_value = map[string]int32{
	"AGGREGATE_VECTOR_OP_INVALID":   0,
	"AGGREGATE_VECTOR_OP_SUM":       1,
	"AGGREGATE_VECTOR_OP_MAX":       2,
	"AGGREGATE_VECTOR_OP_MIN":       3,
	"AGGREGATE_VECTOR_OP_COUNT":     4,
	"AGGREGATE_VECTOR_OP_AVG":       5,
	"AGGREGATE_VECTOR_OP_STDDEV":    6,
	"AGGREGATE_VECTOR_OP_STDVAR":    7,
	"AGGREGATE_VECTOR_OP_BOTTOMK":   8,
	"AGGREGATE_VECTOR_OP_TOPK":      9,
	"AGGREGATE_VECTOR_OP_SORT":      10,
	"AGGREGATE_VECTOR_OP_SORT_DESC": 11,
}

func (AggregateVectorOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{1}
}

// ParseOp represents the type of parse operation to be performed.
type ParseOp int32

const (
	PARSE_OP_INVALID ParseOp = 0
	PARSE_OP_LOGFMT  ParseOp = 1
	PARSE_OP_JSON    ParseOp = 2
)

var ParseOp_name = map[int32]string{
	0: "PARSE_OP_INVALID",
	1: "PARSE_OP_LOGFMT",
	2: "PARSE_OP_JSON",
}

var ParseOp_value = map[string]int32{
	"PARSE_OP_INVALID": 0,
	"PARSE_OP_LOGFMT":  1,
	"PARSE_OP_JSON":    2,
}

func (ParseOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{2}
}

// SortOrder represents the order in which results should be sorted.
type SortOrder int32

const (
	SORT_ORDER_INVALID    SortOrder = 0
	SORT_ORDER_ASCENDING  SortOrder = 1
	SORT_ORDER_DESCENDING SortOrder = 2
)

var SortOrder_name = map[int32]string{
	0: "SORT_ORDER_INVALID",
	1: "SORT_ORDER_ASCENDING",
	2: "SORT_ORDER_DESCENDING",
}

var SortOrder_value = map[string]int32{
	"SORT_ORDER_INVALID":    0,
	"SORT_ORDER_ASCENDING":  1,
	"SORT_ORDER_DESCENDING": 2,
}

func (SortOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{3}
}

// Plan represents the physical plan of a query.
type Plan struct {
	Nodes []*PlanNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Edges []*PlanEdge `protobuf:"bytes,2,rep,name=edges,proto3" json:"edges,omitempty"`
}

func (m *Plan) Reset()      { *m = Plan{} }
func (*Plan) ProtoMessage() {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{0}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.Size()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetNodes() []*PlanNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Plan) GetEdges() []*PlanEdge {
	if m != nil {
		return m.Edges
	}
	return nil
}

// PlanEdge represents a relationship between two nodes in the physical plan.
type PlanEdge struct {
	Parent PlanNodeID `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent"`
	Child  PlanNodeID `protobuf:"bytes,2,opt,name=child,proto3" json:"child"`
}

func (m *PlanEdge) Reset()      { *m = PlanEdge{} }
func (*PlanEdge) ProtoMessage() {}
func (*PlanEdge) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{1}
}
func (m *PlanEdge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanEdge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanEdge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanEdge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanEdge.Merge(m, src)
}
func (m *PlanEdge) XXX_Size() int {
	return m.Size()
}
func (m *PlanEdge) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanEdge.DiscardUnknown(m)
}

var xxx_messageInfo_PlanEdge proto.InternalMessageInfo

func (m *PlanEdge) GetParent() PlanNodeID {
	if m != nil {
		return m.Parent
	}
	return PlanNodeID{}
}

func (m *PlanEdge) GetChild() PlanNodeID {
	if m != nil {
		return m.Child
	}
	return PlanNodeID{}
}

type PlanNodeID struct {
	Value github_com_grafana_loki_v3_pkg_engine_internal_util_ulid.ULID `protobuf:"bytes,1,opt,name=value,proto3,customtype=github.com/grafana/loki/v3/pkg/engine/internal/util/ulid.ULID" json:"value"`
}

func (m *PlanNodeID) Reset()      { *m = PlanNodeID{} }
func (*PlanNodeID) ProtoMessage() {}
func (*PlanNodeID) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{2}
}
func (m *PlanNodeID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanNodeID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanNodeID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanNodeID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanNodeID.Merge(m, src)
}
func (m *PlanNodeID) XXX_Size() int {
	return m.Size()
}
func (m *PlanNodeID) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanNodeID.DiscardUnknown(m)
}

var xxx_messageInfo_PlanNodeID proto.InternalMessageInfo

// PlanNode represents a node in the physical plan.
type PlanNode struct {
	// Types that are valid to be assigned to Kind:
	//	*PlanNode_AggregateRange
	//	*PlanNode_AggregateVector
	//	*PlanNode_Scan
	//	*PlanNode_Filter
	//	*PlanNode_Limit
	//	*PlanNode_Merge
	//	*PlanNode_Parse
	//	*PlanNode_Projection
	//	*PlanNode_SortMerge
	Kind isPlanNode_Kind `protobuf_oneof:"kind"`
}

func (m *PlanNode) Reset()      { *m = PlanNode{} }
func (*PlanNode) ProtoMessage() {}
func (*PlanNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{3}
}
func (m *PlanNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanNode.Merge(m, src)
}
func (m *PlanNode) XXX_Size() int {
	return m.Size()
}
func (m *PlanNode) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanNode.DiscardUnknown(m)
}

var xxx_messageInfo_PlanNode proto.InternalMessageInfo

type isPlanNode_Kind interface {
	isPlanNode_Kind()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PlanNode_AggregateRange struct {
	AggregateRange *AggregateRange `protobuf:"bytes,1,opt,name=aggregate_range,json=aggregateRange,proto3,oneof"`
}
type PlanNode_AggregateVector struct {
	AggregateVector *AggregateVector `protobuf:"bytes,2,opt,name=aggregate_vector,json=aggregateVector,proto3,oneof"`
}
type PlanNode_Scan struct {
	Scan *DataObjScan `protobuf:"bytes,3,opt,name=scan,proto3,oneof"`
}
type PlanNode_Filter struct {
	Filter *Filter `protobuf:"bytes,4,opt,name=filter,proto3,oneof"`
}
type PlanNode_Limit struct {
	Limit *Limit `protobuf:"bytes,5,opt,name=limit,proto3,oneof"`
}
type PlanNode_Merge struct {
	Merge *Merge `protobuf:"bytes,6,opt,name=merge,proto3,oneof"`
}
type PlanNode_Parse struct {
	Parse *Parse `protobuf:"bytes,7,opt,name=parse,proto3,oneof"`
}
type PlanNode_Projection struct {
	Projection *Projection `protobuf:"bytes,8,opt,name=projection,proto3,oneof"`
}
type PlanNode_SortMerge struct {
	SortMerge *SortMerge `protobuf:"bytes,9,opt,name=sort_merge,json=sortMerge,proto3,oneof"`
}

func (*PlanNode_AggregateRange) isPlanNode_Kind()  {}
func (*PlanNode_AggregateVector) isPlanNode_Kind() {}
func (*PlanNode_Scan) isPlanNode_Kind()            {}
func (*PlanNode_Filter) isPlanNode_Kind()          {}
func (*PlanNode_Limit) isPlanNode_Kind()           {}
func (*PlanNode_Merge) isPlanNode_Kind()           {}
func (*PlanNode_Parse) isPlanNode_Kind()           {}
func (*PlanNode_Projection) isPlanNode_Kind()      {}
func (*PlanNode_SortMerge) isPlanNode_Kind()       {}

func (m *PlanNode) GetKind() isPlanNode_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *PlanNode) GetAggregateRange() *AggregateRange {
	if x, ok := m.GetKind().(*PlanNode_AggregateRange); ok {
		return x.AggregateRange
	}
	return nil
}

func (m *PlanNode) GetAggregateVector() *AggregateVector {
	if x, ok := m.GetKind().(*PlanNode_AggregateVector); ok {
		return x.AggregateVector
	}
	return nil
}

func (m *PlanNode) GetScan() *DataObjScan {
	if x, ok := m.GetKind().(*PlanNode_Scan); ok {
		return x.Scan
	}
	return nil
}

func (m *PlanNode) GetFilter() *Filter {
	if x, ok := m.GetKind().(*PlanNode_Filter); ok {
		return x.Filter
	}
	return nil
}

func (m *PlanNode) GetLimit() *Limit {
	if x, ok := m.GetKind().(*PlanNode_Limit); ok {
		return x.Limit
	}
	return nil
}

func (m *PlanNode) GetMerge() *Merge {
	if x, ok := m.GetKind().(*PlanNode_Merge); ok {
		return x.Merge
	}
	return nil
}

func (m *PlanNode) GetParse() *Parse {
	if x, ok := m.GetKind().(*PlanNode_Parse); ok {
		return x.Parse
	}
	return nil
}

func (m *PlanNode) GetProjection() *Projection {
	if x, ok := m.GetKind().(*PlanNode_Projection); ok {
		return x.Projection
	}
	return nil
}

func (m *PlanNode) GetSortMerge() *SortMerge {
	if x, ok := m.GetKind().(*PlanNode_SortMerge); ok {
		return x.SortMerge
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlanNode) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlanNode_AggregateRange)(nil),
		(*PlanNode_AggregateVector)(nil),
		(*PlanNode_Scan)(nil),
		(*PlanNode_Filter)(nil),
		(*PlanNode_Limit)(nil),
		(*PlanNode_Merge)(nil),
		(*PlanNode_Parse)(nil),
		(*PlanNode_Projection)(nil),
		(*PlanNode_SortMerge)(nil),
	}
}

// AggregateRange aggregates samples into windowed ranges.
type AggregateRange struct {
	// ID for the node.
	Id PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Columns to partition the data by.
	PartitionBy    []*ColumnExpression `protobuf:"bytes,2,rep,name=partition_by,json=partitionBy,proto3" json:"partition_by,omitempty"`
	Operation      AggregateRangeOp    `protobuf:"varint,3,opt,name=operation,proto3,enum=physical.engine.loki.v1.AggregateRangeOp" json:"operation,omitempty"`
	StartUnixNanos int64               `protobuf:"varint,4,opt,name=start_unix_nanos,json=startUnixNanos,proto3" json:"start_unix_nanos,omitempty"`
	EndUnixNanos   int64               `protobuf:"varint,5,opt,name=end_unix_nanos,json=endUnixNanos,proto3" json:"end_unix_nanos,omitempty"`
	StepNs         int64               `protobuf:"varint,6,opt,name=step_ns,json=stepNs,proto3" json:"step_ns,omitempty"`
	RangeNs        int64               `protobuf:"varint,7,opt,name=range_ns,json=rangeNs,proto3" json:"range_ns,omitempty"`
}

func (m *AggregateRange) Reset()      { *m = AggregateRange{} }
func (*AggregateRange) ProtoMessage() {}
func (*AggregateRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{4}
}
func (m *AggregateRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateRange.Merge(m, src)
}
func (m *AggregateRange) XXX_Size() int {
	return m.Size()
}
func (m *AggregateRange) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateRange.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateRange proto.InternalMessageInfo

func (m *AggregateRange) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

func (m *AggregateRange) GetPartitionBy() []*ColumnExpression {
	if m != nil {
		return m.PartitionBy
	}
	return nil
}

func (m *AggregateRange) GetOperation() AggregateRangeOp {
	if m != nil {
		return m.Operation
	}
	return AGGREGATE_RANGE_OP_INVALID
}

func (m *AggregateRange) GetStartUnixNanos() int64 {
	if m != nil {
		return m.StartUnixNanos
	}
	return 0
}

func (m *AggregateRange) GetEndUnixNanos() int64 {
	if m != nil {
		return m.EndUnixNanos
	}
	return 0
}

func (m *AggregateRange) GetStepNs() int64 {
	if m != nil {
		return m.StepNs
	}
	return 0
}

func (m *AggregateRange) GetRangeNs() int64 {
	if m != nil {
		return m.RangeNs
	}
	return 0
}

// AggregateVector represents an operation to aggregate a range vector into an
// instant vector, with optional grouping on specified dimensions.
type AggregateVector struct {
	// ID for the node.
	Id PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Columns to group the data by. If empty, all rows are aggregated into a single result.
	GroupBy []*ColumnExpression `protobuf:"bytes,2,rep,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	// Aggregation operation to perform over the underlying range vector.
	Operation AggregateVectorOp `protobuf:"varint,3,opt,name=operation,proto3,enum=physical.engine.loki.v1.AggregateVectorOp" json:"operation,omitempty"`
}

func (m *AggregateVector) Reset()      { *m = AggregateVector{} }
func (*AggregateVector) ProtoMessage() {}
func (*AggregateVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{5}
}
func (m *AggregateVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateVector.Merge(m, src)
}
func (m *AggregateVector) XXX_Size() int {
	return m.Size()
}
func (m *AggregateVector) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateVector.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateVector proto.InternalMessageInfo

func (m *AggregateVector) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

func (m *AggregateVector) GetGroupBy() []*ColumnExpression {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *AggregateVector) GetOperation() AggregateVectorOp {
	if m != nil {
		return m.Operation
	}
	return AGGREGATE_VECTOR_OP_INVALID
}

// DataObjScan represents an operation to read the contents of a data object
// section.
type DataObjScan struct {
	// ID for the node.
	Id PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Stored location of the data object to read.
	Location string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	// Section within the data object to read.
	Section int64 `protobuf:"varint,3,opt,name=section,proto3" json:"section,omitempty"`
	// StreamIDs within the section to read.
	StreamIds []int64 `protobuf:"varint,4,rep,packed,name=stream_ids,json=streamIds,proto3" json:"stream_ids,omitempty"`
	// Projections are used to limit the columns that are read.
	Projections []*ColumnExpression `protobuf:"bytes,5,rep,name=projections,proto3" json:"projections,omitempty"`
	// Predicates are used to filter rows to reduce the amount of rows that are
	// returned.
	Predicates []*Expression `protobuf:"bytes,6,rep,name=predicates,proto3" json:"predicates,omitempty"`
	// Sort order for the scan.
	SortOrder SortOrder `protobuf:"varint,7,opt,name=sort_order,json=sortOrder,proto3,enum=physical.engine.loki.v1.SortOrder" json:"sort_order,omitempty"`
	// Limit of rows to return.
	Limit uint32 `protobuf:"varint,8,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *DataObjScan) Reset()      { *m = DataObjScan{} }
func (*DataObjScan) ProtoMessage() {}
func (*DataObjScan) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{6}
}
func (m *DataObjScan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataObjScan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataObjScan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataObjScan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataObjScan.Merge(m, src)
}
func (m *DataObjScan) XXX_Size() int {
	return m.Size()
}
func (m *DataObjScan) XXX_DiscardUnknown() {
	xxx_messageInfo_DataObjScan.DiscardUnknown(m)
}

var xxx_messageInfo_DataObjScan proto.InternalMessageInfo

func (m *DataObjScan) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

func (m *DataObjScan) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *DataObjScan) GetSection() int64 {
	if m != nil {
		return m.Section
	}
	return 0
}

func (m *DataObjScan) GetStreamIds() []int64 {
	if m != nil {
		return m.StreamIds
	}
	return nil
}

func (m *DataObjScan) GetProjections() []*ColumnExpression {
	if m != nil {
		return m.Projections
	}
	return nil
}

func (m *DataObjScan) GetPredicates() []*Expression {
	if m != nil {
		return m.Predicates
	}
	return nil
}

func (m *DataObjScan) GetSortOrder() SortOrder {
	if m != nil {
		return m.SortOrder
	}
	return SORT_ORDER_INVALID
}

func (m *DataObjScan) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// Filter represents an operation to filter rows based on a condition.
type Filter struct {
	// ID for the node.
	Id PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Predicates to apply to filter rows.
	Predicates []*Expression `protobuf:"bytes,2,rep,name=predicates,proto3" json:"predicates,omitempty"`
}

func (m *Filter) Reset()      { *m = Filter{} }
func (*Filter) ProtoMessage() {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{7}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

func (m *Filter) GetPredicates() []*Expression {
	if m != nil {
		return m.Predicates
	}
	return nil
}

// Limit represents a limiting operation in the physical plan that applies
// offset and limit to the result set.
type Limit struct {
	// ID for the node.
	Id PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Skip specifies how many initial rows should be skipped.
	Skip uint32 `protobuf:"varint,2,opt,name=skip,proto3" json:"skip,omitempty"`
	// Fetch specifies how many rows should be returned in total.
	Fetch uint32 `protobuf:"varint,3,opt,name=fetch,proto3" json:"fetch,omitempty"`
}

func (m *Limit) Reset()      { *m = Limit{} }
func (*Limit) ProtoMessage() {}
func (*Limit) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{8}
}
func (m *Limit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Limit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Limit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Limit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Limit.Merge(m, src)
}
func (m *Limit) XXX_Size() int {
	return m.Size()
}
func (m *Limit) XXX_DiscardUnknown() {
	xxx_messageInfo_Limit.DiscardUnknown(m)
}

var xxx_messageInfo_Limit proto.InternalMessageInfo

func (m *Limit) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

func (m *Limit) GetSkip() uint32 {
	if m != nil {
		return m.Skip
	}
	return 0
}

func (m *Limit) GetFetch() uint32 {
	if m != nil {
		return m.Fetch
	}
	return 0
}

// Merge represents an operation in the physical plan that merges a sequence of
// inputs into a single output, retaining the order of the inputs.
type Merge struct {
	// ID for the node.
	Id PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
}

func (m *Merge) Reset()      { *m = Merge{} }
func (*Merge) ProtoMessage() {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{9}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.Size()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

// Parse represents an operation to parse a log message into multiple key-value
// pairs.
type Parse struct {
	// ID for the node.
	Id            PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Operation     ParseOp    `protobuf:"varint,2,opt,name=operation,proto3,enum=physical.engine.loki.v1.ParseOp" json:"operation,omitempty"`
	RequestedKeys []string   `protobuf:"bytes,3,rep,name=requested_keys,json=requestedKeys,proto3" json:"requested_keys,omitempty"`
}

func (m *Parse) Reset()      { *m = Parse{} }
func (*Parse) ProtoMessage() {}
func (*Parse) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{10}
}
func (m *Parse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Parse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Parse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Parse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Parse.Merge(m, src)
}
func (m *Parse) XXX_Size() int {
	return m.Size()
}
func (m *Parse) XXX_DiscardUnknown() {
	xxx_messageInfo_Parse.DiscardUnknown(m)
}

var xxx_messageInfo_Parse proto.InternalMessageInfo

func (m *Parse) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

func (m *Parse) GetOperation() ParseOp {
	if m != nil {
		return m.Operation
	}
	return PARSE_OP_INVALID
}

func (m *Parse) GetRequestedKeys() []string {
	if m != nil {
		return m.RequestedKeys
	}
	return nil
}

// Projection represents an operation to return a subset of columns from the
// input.
type Projection struct {
	// ID for the node.
	Id PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Columns that should be kept in the output.
	Columns []*ColumnExpression `protobuf:"bytes,2,rep,name=columns,proto3" json:"columns,omitempty"`
}

func (m *Projection) Reset()      { *m = Projection{} }
func (*Projection) ProtoMessage() {}
func (*Projection) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{11}
}
func (m *Projection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Projection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Projection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Projection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Projection.Merge(m, src)
}
func (m *Projection) XXX_Size() int {
	return m.Size()
}
func (m *Projection) XXX_DiscardUnknown() {
	xxx_messageInfo_Projection.DiscardUnknown(m)
}

var xxx_messageInfo_Projection proto.InternalMessageInfo

func (m *Projection) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

func (m *Projection) GetColumns() []*ColumnExpression {
	if m != nil {
		return m.Columns
	}
	return nil
}

// SortMerge represents an operation in the physical plan. It merges a sequence
// of sorted inputs into a single sorted output.
type SortMerge struct {
	// ID for the node.
	Id PlanNodeID `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	// Column defines the column by which the rows should be sorted. This is almost always
	// the timestamp column, as it is the column by which DataObjScan results
	// are sorted.
	Column *ColumnExpression `protobuf:"bytes,2,opt,name=column,proto3" json:"column,omitempty"`
	// Order defines how rows for the column are sorted. Must match the sort
	// order of the inputs.
	Order SortOrder `protobuf:"varint,3,opt,name=order,proto3,enum=physical.engine.loki.v1.SortOrder" json:"order,omitempty"`
}

func (m *SortMerge) Reset()      { *m = SortMerge{} }
func (*SortMerge) ProtoMessage() {}
func (*SortMerge) Descriptor() ([]byte, []int) {
	return fileDescriptor_24be8eac7b1072f5, []int{12}
}
func (m *SortMerge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortMerge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortMerge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortMerge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortMerge.Merge(m, src)
}
func (m *SortMerge) XXX_Size() int {
	return m.Size()
}
func (m *SortMerge) XXX_DiscardUnknown() {
	xxx_messageInfo_SortMerge.DiscardUnknown(m)
}

var xxx_messageInfo_SortMerge proto.InternalMessageInfo

func (m *SortMerge) GetId() PlanNodeID {
	if m != nil {
		return m.Id
	}
	return PlanNodeID{}
}

func (m *SortMerge) GetColumn() *ColumnExpression {
	if m != nil {
		return m.Column
	}
	return nil
}

func (m *SortMerge) GetOrder() SortOrder {
	if m != nil {
		return m.Order
	}
	return SORT_ORDER_INVALID
}

func init() {
	proto.RegisterEnum("physical.engine.loki.v1.AggregateRangeOp", AggregateRangeOp_name, AggregateRangeOp_value)
	proto.RegisterEnum("physical.engine.loki.v1.AggregateVectorOp", AggregateVectorOp_name, AggregateVectorOp_value)
	proto.RegisterEnum("physical.engine.loki.v1.ParseOp", ParseOp_name, ParseOp_value)
	proto.RegisterEnum("physical.engine.loki.v1.SortOrder", SortOrder_name, SortOrder_value)
	proto.RegisterType((*Plan)(nil), "physical.engine.loki.v1.Plan")
	proto.RegisterType((*PlanEdge)(nil), "physical.engine.loki.v1.PlanEdge")
	proto.RegisterType((*PlanNodeID)(nil), "physical.engine.loki.v1.PlanNodeID")
	proto.RegisterType((*PlanNode)(nil), "physical.engine.loki.v1.PlanNode")
	proto.RegisterType((*AggregateRange)(nil), "physical.engine.loki.v1.AggregateRange")
	proto.RegisterType((*AggregateVector)(nil), "physical.engine.loki.v1.AggregateVector")
	proto.RegisterType((*DataObjScan)(nil), "physical.engine.loki.v1.DataObjScan")
	proto.RegisterType((*Filter)(nil), "physical.engine.loki.v1.Filter")
	proto.RegisterType((*Limit)(nil), "physical.engine.loki.v1.Limit")
	proto.RegisterType((*Merge)(nil), "physical.engine.loki.v1.Merge")
	proto.RegisterType((*Parse)(nil), "physical.engine.loki.v1.Parse")
	proto.RegisterType((*Projection)(nil), "physical.engine.loki.v1.Projection")
	proto.RegisterType((*SortMerge)(nil), "physical.engine.loki.v1.SortMerge")
}

func init() {
	proto.RegisterFile("pkg/engine/internal/planner/physical/physicalpb/physicalpb.proto", fileDescriptor_24be8eac7b1072f5)
}

var fileDescriptor_24be8eac7b1072f5 = []byte{
	// 1318 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x26, 0x45, 0x7d, 0x58, 0xe3, 0x58, 0x61, 0xf6, 0xf5, 0x1b, 0x33, 0xce, 0x1b, 0xda, 0xe1,
	0x9b, 0xa2, 0xaa, 0x0f, 0x12, 0x9a, 0x00, 0x6d, 0x53, 0xa0, 0x1f, 0x94, 0xa5, 0x48, 0x8a, 0x6d,
	0xd1, 0x58, 0xc9, 0x46, 0xd0, 0x8b, 0x40, 0x8b, 0x1b, 0x9a, 0x31, 0x4d, 0xb2, 0x24, 0x65, 0xd8,
	0xb7, 0xa0, 0x97, 0xe6, 0x50, 0x14, 0xfd, 0x11, 0x3d, 0xb4, 0xbf, 0xa3, 0x97, 0x1c, 0x73, 0x0c,
	0x8a, 0x22, 0x68, 0x14, 0xa0, 0xc8, 0x31, 0x3f, 0xa1, 0xd8, 0x25, 0xf5, 0x95, 0x98, 0x76, 0x1c,
	0x5d, 0x04, 0xee, 0xcc, 0xf3, 0xcc, 0x3e, 0x3b, 0x3b, 0x33, 0x14, 0xe1, 0x5b, 0xef, 0xc0, 0x2c,
	0x13, 0xc7, 0xb4, 0x1c, 0x52, 0xb6, 0x9c, 0x90, 0xf8, 0x8e, 0x6e, 0x97, 0x3d, 0x5b, 0x77, 0x1c,
	0xe2, 0x97, 0xbd, 0xfd, 0x93, 0xc0, 0xea, 0x51, 0x43, 0xfc, 0xe0, 0xed, 0x4d, 0x3c, 0x96, 0x3c,
	0xdf, 0x0d, 0x5d, 0xb4, 0x34, 0xb4, 0x94, 0xa2, 0x30, 0x25, 0xdb, 0x3d, 0xb0, 0x4a, 0x47, 0x9f,
	0x2e, 0x2f, 0x9a, 0xae, 0xe9, 0x32, 0x4c, 0x99, 0x3e, 0x45, 0xf0, 0xe5, 0xe2, 0x69, 0x1b, 0xf6,
	0x43, 0xcb, 0x2e, 0xf7, 0x6d, 0xcb, 0x60, 0x3f, 0x31, 0xf2, 0xc2, 0xd2, 0xc8, 0xb1, 0xe7, 0x93,
	0x20, 0xb0, 0x5c, 0x27, 0x8a, 0xa0, 0x1c, 0x43, 0x7a, 0xdb, 0xd6, 0x1d, 0xf4, 0x39, 0x64, 0x1c,
	0xd7, 0x20, 0x81, 0xc4, 0xaf, 0x0a, 0xc5, 0xf9, 0xdb, 0x37, 0x4b, 0x09, 0x92, 0x4b, 0x14, 0xdd,
	0x72, 0x0d, 0x82, 0x23, 0x3c, 0x25, 0x12, 0xc3, 0x24, 0x81, 0x94, 0x7a, 0x0f, 0x62, 0xcd, 0x30,
	0x09, 0x8e, 0xf0, 0xca, 0xcf, 0x3c, 0xcc, 0x0d, 0x6d, 0x48, 0x85, 0xac, 0xa7, 0xfb, 0xc4, 0x09,
	0x25, 0x7e, 0x95, 0x2f, 0xce, 0xdf, 0xfe, 0xff, 0xb9, 0xfb, 0x37, 0xab, 0x95, 0xf4, 0xd3, 0x17,
	0x2b, 0x1c, 0x8e, 0x89, 0xe8, 0x1b, 0xc8, 0xf4, 0xf6, 0x2d, 0xdb, 0x90, 0x52, 0x17, 0x8d, 0x10,
	0xf1, 0x94, 0x1f, 0x78, 0x80, 0xb1, 0x0f, 0x85, 0x90, 0x39, 0xd2, 0xed, 0x3e, 0x89, 0x15, 0x2d,
	0x95, 0x58, 0xde, 0x47, 0x41, 0x68, 0xf6, 0x76, 0x36, 0x9b, 0xd5, 0x4a, 0x8d, 0xc6, 0xf8, 0xf3,
	0xc5, 0xca, 0x57, 0xa6, 0x15, 0xee, 0xf7, 0xf7, 0x4a, 0x3d, 0xf7, 0xb0, 0x6c, 0xfa, 0xfa, 0x43,
	0xdd, 0xd1, 0xcb, 0x14, 0x5d, 0x3e, 0xba, 0x53, 0x3e, 0xf3, 0x42, 0x4b, 0x34, 0x0c, 0x8e, 0x36,
	0x53, 0x5e, 0xa7, 0xa3, 0xac, 0x50, 0x11, 0x08, 0xc3, 0x65, 0xdd, 0x34, 0x7d, 0x62, 0xea, 0x21,
	0xe9, 0xfa, 0xba, 0x63, 0x0e, 0xc5, 0x7c, 0x9c, 0x78, 0x38, 0x75, 0x88, 0xc7, 0x14, 0xde, 0xe0,
	0x70, 0x41, 0x9f, 0xb2, 0xa0, 0x1d, 0x10, 0xc7, 0x31, 0x8f, 0x48, 0x2f, 0x74, 0xfd, 0x38, 0x63,
	0xc5, 0xf3, 0x83, 0xee, 0x32, 0x7c, 0x83, 0xc3, 0x63, 0x5d, 0x91, 0x09, 0x7d, 0x09, 0xe9, 0xa0,
	0xa7, 0x3b, 0x92, 0xc0, 0x42, 0xdd, 0x4a, 0x0c, 0x55, 0xd5, 0x43, 0x5d, 0xdb, 0x7b, 0xd4, 0xee,
	0xe9, 0x4e, 0x83, 0xc3, 0x8c, 0x83, 0xee, 0x42, 0xf6, 0xa1, 0x65, 0x87, 0xc4, 0x97, 0xd2, 0x8c,
	0xbd, 0x92, 0xc8, 0xbe, 0xc7, 0x60, 0x0d, 0x0e, 0xc7, 0x04, 0xf4, 0x19, 0x64, 0x6c, 0xeb, 0xd0,
	0x0a, 0xa5, 0x0c, 0x63, 0xca, 0x89, 0xcc, 0x4d, 0x8a, 0x6a, 0x70, 0x38, 0x82, 0x53, 0xde, 0x21,
	0xf1, 0x4d, 0x22, 0x65, 0xcf, 0xe1, 0x6d, 0x51, 0x14, 0xe5, 0x31, 0x38, 0xe5, 0x79, 0xba, 0x1f,
	0x10, 0x29, 0x77, 0x0e, 0x6f, 0x9b, 0xa2, 0x28, 0x8f, 0xc1, 0x51, 0x0d, 0xc0, 0xf3, 0xdd, 0x47,
	0xa4, 0x17, 0x5a, 0xae, 0x23, 0xcd, 0x9d, 0x57, 0xa1, 0x23, 0x68, 0x83, 0xc3, 0x13, 0x44, 0xb4,
	0x0e, 0x10, 0xb8, 0x7e, 0xd8, 0x8d, 0xb4, 0xe7, 0x59, 0x18, 0x25, 0x31, 0x4c, 0xdb, 0xf5, 0xc3,
	0xa1, 0xfe, 0x7c, 0x30, 0x5c, 0x54, 0xb2, 0x90, 0x3e, 0xb0, 0x1c, 0x43, 0xf9, 0x27, 0x05, 0x85,
	0xe9, 0x72, 0x41, 0x77, 0x21, 0x65, 0x19, 0x17, 0x6f, 0xc1, 0x94, 0x65, 0xa0, 0x4d, 0xb8, 0xe4,
	0xe9, 0x7e, 0x68, 0x51, 0x9d, 0xdd, 0xbd, 0x93, 0x78, 0x1c, 0x7c, 0x92, 0x18, 0x64, 0xdd, 0xb5,
	0xfb, 0x87, 0x4e, 0x6d, 0x34, 0x8f, 0xf0, 0xfc, 0x88, 0x5e, 0x39, 0x41, 0x75, 0xc8, 0xbb, 0x1e,
	0xf1, 0x75, 0x96, 0x2e, 0x5a, 0x53, 0x85, 0x33, 0x42, 0x4d, 0x1f, 0x42, 0xf3, 0xf0, 0x98, 0x8b,
	0x8a, 0x20, 0x06, 0xa1, 0xee, 0x87, 0xdd, 0xbe, 0x63, 0x1d, 0x77, 0x1d, 0xdd, 0x71, 0x03, 0x56,
	0x65, 0x02, 0x2e, 0x30, 0xfb, 0x8e, 0x63, 0x1d, 0xb7, 0xa8, 0x15, 0xdd, 0x82, 0x02, 0x71, 0x8c,
	0x49, 0x5c, 0x86, 0xe1, 0x2e, 0x11, 0xc7, 0x18, 0xa3, 0x96, 0x20, 0x17, 0x84, 0xc4, 0xeb, 0x3a,
	0x01, 0x2b, 0x1d, 0x01, 0x67, 0xe9, 0xb2, 0x15, 0xa0, 0x6b, 0x30, 0xc7, 0x3a, 0x94, 0x7a, 0x72,
	0xcc, 0x93, 0x63, 0xeb, 0x56, 0xa0, 0xfc, 0xc5, 0xc3, 0xe5, 0xb7, 0x5a, 0x68, 0x96, 0x4c, 0x57,
	0x61, 0xce, 0xf4, 0xdd, 0xbe, 0xf7, 0x41, 0x59, 0xce, 0x31, 0x6a, 0xe5, 0x04, 0x35, 0xde, 0xcd,
	0xf0, 0xda, 0xfb, 0x0e, 0x80, 0xa9, 0x14, 0x2b, 0x4f, 0x04, 0x98, 0x9f, 0x68, 0xeb, 0x59, 0x8e,
	0xb6, 0x0c, 0x73, 0xb6, 0xdb, 0x8b, 0x34, 0xd1, 0xa1, 0x94, 0xc7, 0xa3, 0x35, 0x92, 0x20, 0x17,
	0xc4, 0xfd, 0x23, 0x44, 0xf9, 0x8d, 0x97, 0xe8, 0x06, 0x40, 0x10, 0xfa, 0x44, 0x3f, 0xec, 0x5a,
	0x06, 0xbd, 0x5d, 0xa1, 0x28, 0xe0, 0x7c, 0x64, 0x69, 0x1a, 0x01, 0xda, 0x80, 0xf9, 0x71, 0x0b,
	0xd1, 0x5b, 0xbd, 0x70, 0x61, 0x8e, 0xd9, 0xb4, 0x03, 0x3d, 0x9f, 0x18, 0x56, 0x4f, 0x0f, 0x09,
	0x2d, 0x01, 0xe1, 0xcc, 0x43, 0x4e, 0x44, 0x99, 0xa0, 0x21, 0x35, 0x6e, 0x63, 0xd7, 0x37, 0x88,
	0xcf, 0xaa, 0xa5, 0x70, 0x4e, 0x1b, 0x6b, 0x14, 0x19, 0x35, 0x31, 0x7b, 0x44, 0x8b, 0xc3, 0xc1,
	0x47, 0x67, 0xc9, 0x42, 0x3c, 0xd6, 0x94, 0x27, 0x3c, 0x64, 0xa3, 0x19, 0x39, 0xcb, 0x2d, 0x4c,
	0x9f, 0x31, 0xf5, 0x41, 0x67, 0x54, 0x6c, 0xc8, 0xb0, 0x99, 0x3b, 0x8b, 0x10, 0x04, 0xe9, 0xe0,
	0xc0, 0xf2, 0x58, 0x29, 0x2c, 0x60, 0xf6, 0x4c, 0x0f, 0xfe, 0x90, 0x84, 0xbd, 0x7d, 0x56, 0x04,
	0x0b, 0x38, 0x5a, 0x28, 0x15, 0xc8, 0xb0, 0xe1, 0x36, 0xc3, 0x6e, 0xca, 0xef, 0x3c, 0x64, 0xd8,
	0xd8, 0x9e, 0x45, 0xf2, 0xd7, 0x93, 0x6d, 0x95, 0x62, 0x37, 0xbb, 0x7a, 0xf6, 0x4b, 0x62, 0x7a,
	0x5e, 0x7d, 0x04, 0x05, 0x9f, 0x7c, 0xdf, 0x27, 0x41, 0x48, 0x8c, 0xee, 0x01, 0x39, 0x09, 0x24,
	0x61, 0x55, 0x28, 0xe6, 0xf1, 0xc2, 0xc8, 0xba, 0x41, 0x4e, 0x02, 0xe5, 0x27, 0xfa, 0x5f, 0x65,
	0xfc, 0x5e, 0x98, 0xe9, 0xb2, 0x73, 0x3d, 0x56, 0xf1, 0xc1, 0x07, 0x0c, 0x93, 0x98, 0xa9, 0xfc,
	0xc1, 0x43, 0x7e, 0xf4, 0xb6, 0x99, 0x45, 0x8d, 0x0a, 0xd9, 0x28, 0x66, 0xfc, 0x9f, 0xe4, 0x02,
	0x62, 0x62, 0x22, 0xfa, 0x02, 0x32, 0x51, 0x5f, 0x09, 0xef, 0xdd, 0x57, 0x11, 0x61, 0xed, 0x57,
	0x1e, 0xc4, 0xb7, 0xdf, 0x25, 0x48, 0x86, 0x65, 0xb5, 0x5e, 0xc7, 0xb5, 0xba, 0xda, 0xa9, 0x75,
	0xb1, 0xda, 0xaa, 0xd7, 0xba, 0xda, 0x76, 0xb7, 0xd9, 0xda, 0x55, 0x37, 0x9b, 0x55, 0x91, 0x43,
	0xff, 0x03, 0xe9, 0x14, 0xff, 0xba, 0xb6, 0xd3, 0xea, 0x88, 0x3c, 0x5a, 0x86, 0xab, 0xa7, 0x78,
	0xdb, 0x3b, 0x5b, 0x62, 0x2a, 0xc1, 0xb7, 0xa5, 0x3e, 0x10, 0x85, 0x24, 0x5f, 0xb3, 0x25, 0xa6,
	0xd7, 0x7e, 0x14, 0xe0, 0xca, 0x3b, 0x03, 0x19, 0xad, 0xc0, 0xf5, 0x31, 0x63, 0xb7, 0xb6, 0xde,
	0xd1, 0xf0, 0xb4, 0xd0, 0xeb, 0xb0, 0x74, 0x1a, 0x80, 0x6a, 0xe1, 0x93, 0x9c, 0x54, 0x4c, 0x2a,
	0xd1, 0xd9, 0x6c, 0x89, 0x02, 0xba, 0x01, 0xd7, 0x4e, 0x73, 0x46, 0x09, 0x48, 0x27, 0x71, 0xd5,
	0xdd, 0xba, 0x98, 0x99, 0xce, 0xed, 0x84, 0xa4, 0x4e, 0xb5, 0x5a, 0xdb, 0x15, 0xb3, 0x67, 0xf8,
	0x77, 0x55, 0x2c, 0xe6, 0x92, 0xce, 0x5c, 0xd1, 0x3a, 0x1d, 0x6d, 0x6b, 0x43, 0x9c, 0x9b, 0xbe,
	0x9c, 0x31, 0xa0, 0xa3, 0x6d, 0x6f, 0x88, 0xf9, 0x24, 0x6f, 0x5b, 0xc3, 0x1d, 0x11, 0xd0, 0x4d,
	0xb8, 0x91, 0xe4, 0xed, 0x56, 0x6b, 0xed, 0x75, 0x71, 0x7e, 0xad, 0x0e, 0xb9, 0xb8, 0x85, 0xd1,
	0x22, 0x88, 0xdb, 0x2a, 0x6e, 0xbf, 0x55, 0x1c, 0xff, 0x81, 0xcb, 0x23, 0xeb, 0xa6, 0x56, 0xbf,
	0xb7, 0x45, 0x6b, 0xe2, 0x0a, 0x2c, 0x8c, 0x8c, 0xf7, 0xdb, 0x5a, 0x4b, 0x4c, 0xad, 0x3d, 0x88,
	0xda, 0x27, 0x1a, 0xed, 0x57, 0x01, 0xb1, 0x4d, 0x34, 0x5c, 0xad, 0xe1, 0x89, 0x60, 0x12, 0x2c,
	0x4e, 0xd8, 0xd5, 0xf6, 0x7a, 0xad, 0x55, 0x6d, 0xb6, 0xea, 0x22, 0x8f, 0xae, 0xc1, 0x7f, 0x27,
	0x3c, 0x54, 0x5c, 0xec, 0x4a, 0x55, 0x1e, 0xf3, 0xcf, 0x5e, 0xca, 0xdc, 0xf3, 0x97, 0x32, 0xf7,
	0xe6, 0xa5, 0xcc, 0x3f, 0x1e, 0xc8, 0xfc, 0x6f, 0x03, 0x99, 0x7f, 0x3a, 0x90, 0xf9, 0x67, 0x03,
	0x99, 0xff, 0x7b, 0x20, 0xf3, 0xaf, 0x07, 0x32, 0xf7, 0x66, 0x20, 0xf3, 0xbf, 0xbc, 0x92, 0xb9,
	0x67, 0xaf, 0x64, 0xee, 0xf9, 0x2b, 0x99, 0xfb, 0xee, 0xfe, 0x05, 0x3f, 0x66, 0xce, 0xf8, 0xe6,
	0xdc, 0x4e, 0xed, 0x65, 0xd9, 0xb7, 0xe6, 0x9d, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x85, 0x66,
	0x44, 0x23, 0x4a, 0x0f, 0x00, 0x00,
}

func (x AggregateRangeOp) String() string {
	s, ok := AggregateRangeOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AggregateVectorOp) String() string {
	s, ok := AggregateVectorOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ParseOp) String() string {
	s, ok := ParseOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SortOrder) String() string {
	s, ok := SortOrder_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Plan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Plan)
	if !ok {
		that2, ok := that.(Plan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	if len(this.Edges) != len(that1.Edges) {
		return false
	}
	for i := range this.Edges {
		if !this.Edges[i].Equal(that1.Edges[i]) {
			return false
		}
	}
	return true
}
func (this *PlanEdge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanEdge)
	if !ok {
		that2, ok := that.(PlanEdge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Parent.Equal(&that1.Parent) {
		return false
	}
	if !this.Child.Equal(&that1.Child) {
		return false
	}
	return true
}
func (this *PlanNodeID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNodeID)
	if !ok {
		that2, ok := that.(PlanNodeID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *PlanNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode)
	if !ok {
		that2, ok := that.(PlanNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Kind == nil {
		if this.Kind != nil {
			return false
		}
	} else if this.Kind == nil {
		return false
	} else if !this.Kind.Equal(that1.Kind) {
		return false
	}
	return true
}
func (this *PlanNode_AggregateRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_AggregateRange)
	if !ok {
		that2, ok := that.(PlanNode_AggregateRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AggregateRange.Equal(that1.AggregateRange) {
		return false
	}
	return true
}
func (this *PlanNode_AggregateVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_AggregateVector)
	if !ok {
		that2, ok := that.(PlanNode_AggregateVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AggregateVector.Equal(that1.AggregateVector) {
		return false
	}
	return true
}
func (this *PlanNode_Scan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_Scan)
	if !ok {
		that2, ok := that.(PlanNode_Scan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scan.Equal(that1.Scan) {
		return false
	}
	return true
}
func (this *PlanNode_Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_Filter)
	if !ok {
		that2, ok := that.(PlanNode_Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	return true
}
func (this *PlanNode_Limit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_Limit)
	if !ok {
		that2, ok := that.(PlanNode_Limit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Limit.Equal(that1.Limit) {
		return false
	}
	return true
}
func (this *PlanNode_Merge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_Merge)
	if !ok {
		that2, ok := that.(PlanNode_Merge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Merge.Equal(that1.Merge) {
		return false
	}
	return true
}
func (this *PlanNode_Parse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_Parse)
	if !ok {
		that2, ok := that.(PlanNode_Parse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Parse.Equal(that1.Parse) {
		return false
	}
	return true
}
func (this *PlanNode_Projection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_Projection)
	if !ok {
		that2, ok := that.(PlanNode_Projection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Projection.Equal(that1.Projection) {
		return false
	}
	return true
}
func (this *PlanNode_SortMerge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanNode_SortMerge)
	if !ok {
		that2, ok := that.(PlanNode_SortMerge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SortMerge.Equal(that1.SortMerge) {
		return false
	}
	return true
}
func (this *AggregateRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateRange)
	if !ok {
		that2, ok := that.(AggregateRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if len(this.PartitionBy) != len(that1.PartitionBy) {
		return false
	}
	for i := range this.PartitionBy {
		if !this.PartitionBy[i].Equal(that1.PartitionBy[i]) {
			return false
		}
	}
	if this.Operation != that1.Operation {
		return false
	}
	if this.StartUnixNanos != that1.StartUnixNanos {
		return false
	}
	if this.EndUnixNanos != that1.EndUnixNanos {
		return false
	}
	if this.StepNs != that1.StepNs {
		return false
	}
	if this.RangeNs != that1.RangeNs {
		return false
	}
	return true
}
func (this *AggregateVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregateVector)
	if !ok {
		that2, ok := that.(AggregateVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if len(this.GroupBy) != len(that1.GroupBy) {
		return false
	}
	for i := range this.GroupBy {
		if !this.GroupBy[i].Equal(that1.GroupBy[i]) {
			return false
		}
	}
	if this.Operation != that1.Operation {
		return false
	}
	return true
}
func (this *DataObjScan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataObjScan)
	if !ok {
		that2, ok := that.(DataObjScan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.Section != that1.Section {
		return false
	}
	if len(this.StreamIds) != len(that1.StreamIds) {
		return false
	}
	for i := range this.StreamIds {
		if this.StreamIds[i] != that1.StreamIds[i] {
			return false
		}
	}
	if len(this.Projections) != len(that1.Projections) {
		return false
	}
	for i := range this.Projections {
		if !this.Projections[i].Equal(that1.Projections[i]) {
			return false
		}
	}
	if len(this.Predicates) != len(that1.Predicates) {
		return false
	}
	for i := range this.Predicates {
		if !this.Predicates[i].Equal(that1.Predicates[i]) {
			return false
		}
	}
	if this.SortOrder != that1.SortOrder {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Filter)
	if !ok {
		that2, ok := that.(Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if len(this.Predicates) != len(that1.Predicates) {
		return false
	}
	for i := range this.Predicates {
		if !this.Predicates[i].Equal(that1.Predicates[i]) {
			return false
		}
	}
	return true
}
func (this *Limit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Limit)
	if !ok {
		that2, ok := that.(Limit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if this.Skip != that1.Skip {
		return false
	}
	if this.Fetch != that1.Fetch {
		return false
	}
	return true
}
func (this *Merge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Merge)
	if !ok {
		that2, ok := that.(Merge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	return true
}
func (this *Parse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Parse)
	if !ok {
		that2, ok := that.(Parse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if this.Operation != that1.Operation {
		return false
	}
	if len(this.RequestedKeys) != len(that1.RequestedKeys) {
		return false
	}
	for i := range this.RequestedKeys {
		if this.RequestedKeys[i] != that1.RequestedKeys[i] {
			return false
		}
	}
	return true
}
func (this *Projection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Projection)
	if !ok {
		that2, ok := that.(Projection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if len(this.Columns) != len(that1.Columns) {
		return false
	}
	for i := range this.Columns {
		if !this.Columns[i].Equal(that1.Columns[i]) {
			return false
		}
	}
	return true
}
func (this *SortMerge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SortMerge)
	if !ok {
		that2, ok := that.(SortMerge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(&that1.Id) {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	if this.Order != that1.Order {
		return false
	}
	return true
}
func (this *Plan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.Plan{")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	if this.Edges != nil {
		s = append(s, "Edges: "+fmt.Sprintf("%#v", this.Edges)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanEdge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.PlanEdge{")
	s = append(s, "Parent: "+strings.Replace(this.Parent.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Child: "+strings.Replace(this.Child.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanNodeID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.PlanNodeID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&physicalpb.PlanNode{")
	if this.Kind != nil {
		s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanNode_AggregateRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_AggregateRange{` +
		`AggregateRange:` + fmt.Sprintf("%#v", this.AggregateRange) + `}`}, ", ")
	return s
}
func (this *PlanNode_AggregateVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_AggregateVector{` +
		`AggregateVector:` + fmt.Sprintf("%#v", this.AggregateVector) + `}`}, ", ")
	return s
}
func (this *PlanNode_Scan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_Scan{` +
		`Scan:` + fmt.Sprintf("%#v", this.Scan) + `}`}, ", ")
	return s
}
func (this *PlanNode_Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_Filter{` +
		`Filter:` + fmt.Sprintf("%#v", this.Filter) + `}`}, ", ")
	return s
}
func (this *PlanNode_Limit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_Limit{` +
		`Limit:` + fmt.Sprintf("%#v", this.Limit) + `}`}, ", ")
	return s
}
func (this *PlanNode_Merge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_Merge{` +
		`Merge:` + fmt.Sprintf("%#v", this.Merge) + `}`}, ", ")
	return s
}
func (this *PlanNode_Parse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_Parse{` +
		`Parse:` + fmt.Sprintf("%#v", this.Parse) + `}`}, ", ")
	return s
}
func (this *PlanNode_Projection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_Projection{` +
		`Projection:` + fmt.Sprintf("%#v", this.Projection) + `}`}, ", ")
	return s
}
func (this *PlanNode_SortMerge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&physicalpb.PlanNode_SortMerge{` +
		`SortMerge:` + fmt.Sprintf("%#v", this.SortMerge) + `}`}, ", ")
	return s
}
func (this *AggregateRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&physicalpb.AggregateRange{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	if this.PartitionBy != nil {
		s = append(s, "PartitionBy: "+fmt.Sprintf("%#v", this.PartitionBy)+",\n")
	}
	s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	s = append(s, "StartUnixNanos: "+fmt.Sprintf("%#v", this.StartUnixNanos)+",\n")
	s = append(s, "EndUnixNanos: "+fmt.Sprintf("%#v", this.EndUnixNanos)+",\n")
	s = append(s, "StepNs: "+fmt.Sprintf("%#v", this.StepNs)+",\n")
	s = append(s, "RangeNs: "+fmt.Sprintf("%#v", this.RangeNs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AggregateVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&physicalpb.AggregateVector{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	if this.GroupBy != nil {
		s = append(s, "GroupBy: "+fmt.Sprintf("%#v", this.GroupBy)+",\n")
	}
	s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataObjScan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&physicalpb.DataObjScan{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "Section: "+fmt.Sprintf("%#v", this.Section)+",\n")
	s = append(s, "StreamIds: "+fmt.Sprintf("%#v", this.StreamIds)+",\n")
	if this.Projections != nil {
		s = append(s, "Projections: "+fmt.Sprintf("%#v", this.Projections)+",\n")
	}
	if this.Predicates != nil {
		s = append(s, "Predicates: "+fmt.Sprintf("%#v", this.Predicates)+",\n")
	}
	s = append(s, "SortOrder: "+fmt.Sprintf("%#v", this.SortOrder)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.Filter{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	if this.Predicates != nil {
		s = append(s, "Predicates: "+fmt.Sprintf("%#v", this.Predicates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Limit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&physicalpb.Limit{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Skip: "+fmt.Sprintf("%#v", this.Skip)+",\n")
	s = append(s, "Fetch: "+fmt.Sprintf("%#v", this.Fetch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Merge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&physicalpb.Merge{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Parse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&physicalpb.Parse{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Operation: "+fmt.Sprintf("%#v", this.Operation)+",\n")
	s = append(s, "RequestedKeys: "+fmt.Sprintf("%#v", this.RequestedKeys)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Projection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&physicalpb.Projection{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	if this.Columns != nil {
		s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SortMerge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&physicalpb.SortMerge{")
	s = append(s, "Id: "+strings.Replace(this.Id.GoString(), `&`, ``, 1)+",\n")
	if this.Column != nil {
		s = append(s, "Column: "+fmt.Sprintf("%#v", this.Column)+",\n")
	}
	s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPhysicalpb(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Edges) > 0 {
		for iNdEx := len(m.Edges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Edges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlanEdge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanEdge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanEdge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Child.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PlanNodeID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanNodeID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanNodeID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Value.Size()
		i -= size
		if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PlanNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlanNode_AggregateRange) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_AggregateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AggregateRange != nil {
		{
			size, err := m.AggregateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PlanNode_AggregateVector) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_AggregateVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AggregateVector != nil {
		{
			size, err := m.AggregateVector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PlanNode_Scan) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_Scan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scan != nil {
		{
			size, err := m.Scan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PlanNode_Filter) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PlanNode_Limit) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_Limit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Limit != nil {
		{
			size, err := m.Limit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PlanNode_Merge) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *PlanNode_Parse) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_Parse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Parse != nil {
		{
			size, err := m.Parse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *PlanNode_Projection) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Projection != nil {
		{
			size, err := m.Projection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *PlanNode_SortMerge) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PlanNode_SortMerge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SortMerge != nil {
		{
			size, err := m.SortMerge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AggregateRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RangeNs != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.RangeNs))
		i--
		dAtA[i] = 0x38
	}
	if m.StepNs != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.StepNs))
		i--
		dAtA[i] = 0x30
	}
	if m.EndUnixNanos != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.EndUnixNanos))
		i--
		dAtA[i] = 0x28
	}
	if m.StartUnixNanos != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.StartUnixNanos))
		i--
		dAtA[i] = 0x20
	}
	if m.Operation != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PartitionBy) > 0 {
		for iNdEx := len(m.PartitionBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AggregateVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupBy) > 0 {
		for iNdEx := len(m.GroupBy) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GroupBy[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DataObjScan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataObjScan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataObjScan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x40
	}
	if m.SortOrder != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.SortOrder))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Predicates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.StreamIds) > 0 {
		dAtA16 := make([]byte, len(m.StreamIds)*10)
		var j15 int
		for _, num1 := range m.StreamIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintPhysicalpb(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x22
	}
	if m.Section != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Section))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintPhysicalpb(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Predicates) > 0 {
		for iNdEx := len(m.Predicates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Predicates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Limit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Limit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fetch != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Fetch))
		i--
		dAtA[i] = 0x18
	}
	if m.Skip != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Skip))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Parse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Parse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestedKeys) > 0 {
		for iNdEx := len(m.RequestedKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestedKeys[iNdEx])
			copy(dAtA[i:], m.RequestedKeys[iNdEx])
			i = encodeVarintPhysicalpb(dAtA, i, uint64(len(m.RequestedKeys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Operation != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Projection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Projection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Projection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SortMerge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortMerge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SortMerge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != 0 {
		i = encodeVarintPhysicalpb(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x18
	}
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPhysicalpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintPhysicalpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPhysicalpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Plan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if len(m.Edges) > 0 {
		for _, e := range m.Edges {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	return n
}

func (m *PlanEdge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Parent.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	l = m.Child.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	return n
}

func (m *PlanNodeID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Value.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	return n
}

func (m *PlanNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *PlanNode_AggregateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregateRange != nil {
		l = m.AggregateRange.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *PlanNode_AggregateVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregateVector != nil {
		l = m.AggregateVector.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *PlanNode_Scan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *PlanNode_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *PlanNode_Limit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != nil {
		l = m.Limit.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *PlanNode_Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *PlanNode_Parse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parse != nil {
		l = m.Parse.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *PlanNode_Projection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Projection != nil {
		l = m.Projection.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *PlanNode_SortMerge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SortMerge != nil {
		l = m.SortMerge.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	return n
}
func (m *AggregateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	if len(m.PartitionBy) > 0 {
		for _, e := range m.PartitionBy {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if m.Operation != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Operation))
	}
	if m.StartUnixNanos != 0 {
		n += 1 + sovPhysicalpb(uint64(m.StartUnixNanos))
	}
	if m.EndUnixNanos != 0 {
		n += 1 + sovPhysicalpb(uint64(m.EndUnixNanos))
	}
	if m.StepNs != 0 {
		n += 1 + sovPhysicalpb(uint64(m.StepNs))
	}
	if m.RangeNs != 0 {
		n += 1 + sovPhysicalpb(uint64(m.RangeNs))
	}
	return n
}

func (m *AggregateVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	if len(m.GroupBy) > 0 {
		for _, e := range m.GroupBy {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if m.Operation != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Operation))
	}
	return n
}

func (m *DataObjScan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	if m.Section != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Section))
	}
	if len(m.StreamIds) > 0 {
		l = 0
		for _, e := range m.StreamIds {
			l += sovPhysicalpb(uint64(e))
		}
		n += 1 + sovPhysicalpb(uint64(l)) + l
	}
	if len(m.Projections) > 0 {
		for _, e := range m.Projections {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if len(m.Predicates) > 0 {
		for _, e := range m.Predicates {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	if m.SortOrder != 0 {
		n += 1 + sovPhysicalpb(uint64(m.SortOrder))
	}
	if m.Limit != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Limit))
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	if len(m.Predicates) > 0 {
		for _, e := range m.Predicates {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	return n
}

func (m *Limit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	if m.Skip != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Skip))
	}
	if m.Fetch != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Fetch))
	}
	return n
}

func (m *Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	return n
}

func (m *Parse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	if m.Operation != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Operation))
	}
	if len(m.RequestedKeys) > 0 {
		for _, s := range m.RequestedKeys {
			l = len(s)
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	return n
}

func (m *Projection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovPhysicalpb(uint64(l))
		}
	}
	return n
}

func (m *SortMerge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Id.Size()
	n += 1 + l + sovPhysicalpb(uint64(l))
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovPhysicalpb(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovPhysicalpb(uint64(m.Order))
	}
	return n
}

func sovPhysicalpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPhysicalpb(x uint64) (n int) {
	return sovPhysicalpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Plan) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*PlanNode{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "PlanNode", "PlanNode", 1) + ","
	}
	repeatedStringForNodes += "}"
	repeatedStringForEdges := "[]*PlanEdge{"
	for _, f := range this.Edges {
		repeatedStringForEdges += strings.Replace(f.String(), "PlanEdge", "PlanEdge", 1) + ","
	}
	repeatedStringForEdges += "}"
	s := strings.Join([]string{`&Plan{`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`Edges:` + repeatedStringForEdges + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanEdge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanEdge{`,
		`Parent:` + strings.Replace(strings.Replace(this.Parent.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`Child:` + strings.Replace(strings.Replace(this.Child.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNodeID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNodeID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_AggregateRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_AggregateRange{`,
		`AggregateRange:` + strings.Replace(fmt.Sprintf("%v", this.AggregateRange), "AggregateRange", "AggregateRange", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_AggregateVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_AggregateVector{`,
		`AggregateVector:` + strings.Replace(fmt.Sprintf("%v", this.AggregateVector), "AggregateVector", "AggregateVector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_Scan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_Scan{`,
		`Scan:` + strings.Replace(fmt.Sprintf("%v", this.Scan), "DataObjScan", "DataObjScan", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_Filter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_Filter{`,
		`Filter:` + strings.Replace(fmt.Sprintf("%v", this.Filter), "Filter", "Filter", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_Limit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_Limit{`,
		`Limit:` + strings.Replace(fmt.Sprintf("%v", this.Limit), "Limit", "Limit", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_Merge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_Merge{`,
		`Merge:` + strings.Replace(fmt.Sprintf("%v", this.Merge), "Merge", "Merge", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_Parse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_Parse{`,
		`Parse:` + strings.Replace(fmt.Sprintf("%v", this.Parse), "Parse", "Parse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_Projection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_Projection{`,
		`Projection:` + strings.Replace(fmt.Sprintf("%v", this.Projection), "Projection", "Projection", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanNode_SortMerge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlanNode_SortMerge{`,
		`SortMerge:` + strings.Replace(fmt.Sprintf("%v", this.SortMerge), "SortMerge", "SortMerge", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateRange) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPartitionBy := "[]*ColumnExpression{"
	for _, f := range this.PartitionBy {
		repeatedStringForPartitionBy += strings.Replace(fmt.Sprintf("%v", f), "ColumnExpression", "ColumnExpression", 1) + ","
	}
	repeatedStringForPartitionBy += "}"
	s := strings.Join([]string{`&AggregateRange{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`PartitionBy:` + repeatedStringForPartitionBy + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`StartUnixNanos:` + fmt.Sprintf("%v", this.StartUnixNanos) + `,`,
		`EndUnixNanos:` + fmt.Sprintf("%v", this.EndUnixNanos) + `,`,
		`StepNs:` + fmt.Sprintf("%v", this.StepNs) + `,`,
		`RangeNs:` + fmt.Sprintf("%v", this.RangeNs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregateVector) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGroupBy := "[]*ColumnExpression{"
	for _, f := range this.GroupBy {
		repeatedStringForGroupBy += strings.Replace(fmt.Sprintf("%v", f), "ColumnExpression", "ColumnExpression", 1) + ","
	}
	repeatedStringForGroupBy += "}"
	s := strings.Join([]string{`&AggregateVector{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`GroupBy:` + repeatedStringForGroupBy + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataObjScan) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForProjections := "[]*ColumnExpression{"
	for _, f := range this.Projections {
		repeatedStringForProjections += strings.Replace(fmt.Sprintf("%v", f), "ColumnExpression", "ColumnExpression", 1) + ","
	}
	repeatedStringForProjections += "}"
	repeatedStringForPredicates := "[]*Expression{"
	for _, f := range this.Predicates {
		repeatedStringForPredicates += strings.Replace(fmt.Sprintf("%v", f), "Expression", "Expression", 1) + ","
	}
	repeatedStringForPredicates += "}"
	s := strings.Join([]string{`&DataObjScan{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Section:` + fmt.Sprintf("%v", this.Section) + `,`,
		`StreamIds:` + fmt.Sprintf("%v", this.StreamIds) + `,`,
		`Projections:` + repeatedStringForProjections + `,`,
		`Predicates:` + repeatedStringForPredicates + `,`,
		`SortOrder:` + fmt.Sprintf("%v", this.SortOrder) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Filter) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPredicates := "[]*Expression{"
	for _, f := range this.Predicates {
		repeatedStringForPredicates += strings.Replace(fmt.Sprintf("%v", f), "Expression", "Expression", 1) + ","
	}
	repeatedStringForPredicates += "}"
	s := strings.Join([]string{`&Filter{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`Predicates:` + repeatedStringForPredicates + `,`,
		`}`,
	}, "")
	return s
}
func (this *Limit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Limit{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`Skip:` + fmt.Sprintf("%v", this.Skip) + `,`,
		`Fetch:` + fmt.Sprintf("%v", this.Fetch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Merge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Merge{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Parse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Parse{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
		`RequestedKeys:` + fmt.Sprintf("%v", this.RequestedKeys) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Projection) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForColumns := "[]*ColumnExpression{"
	for _, f := range this.Columns {
		repeatedStringForColumns += strings.Replace(fmt.Sprintf("%v", f), "ColumnExpression", "ColumnExpression", 1) + ","
	}
	repeatedStringForColumns += "}"
	s := strings.Join([]string{`&Projection{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`Columns:` + repeatedStringForColumns + `,`,
		`}`,
	}, "")
	return s
}
func (this *SortMerge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SortMerge{`,
		`Id:` + strings.Replace(strings.Replace(this.Id.String(), "PlanNodeID", "PlanNodeID", 1), `&`, ``, 1) + `,`,
		`Column:` + strings.Replace(fmt.Sprintf("%v", this.Column), "ColumnExpression", "ColumnExpression", 1) + `,`,
		`Order:` + fmt.Sprintf("%v", this.Order) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPhysicalpb(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &PlanNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edges = append(m.Edges, &PlanEdge{})
			if err := m.Edges[len(m.Edges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanEdge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanEdge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanEdge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Child", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Child.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanNodeID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanNodeID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanNodeID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AggregateRange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_AggregateRange{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateVector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AggregateVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_AggregateVector{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataObjScan{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_Scan{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_Filter{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Limit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_Limit{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Merge{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_Merge{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Parse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_Parse{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Projection{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_Projection{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortMerge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SortMerge{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &PlanNode_SortMerge{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionBy = append(m.PartitionBy, &ColumnExpression{})
			if err := m.PartitionBy[len(m.PartitionBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= AggregateRangeOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartUnixNanos", wireType)
			}
			m.StartUnixNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartUnixNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndUnixNanos", wireType)
			}
			m.EndUnixNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndUnixNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepNs", wireType)
			}
			m.StepNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeNs", wireType)
			}
			m.RangeNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, &ColumnExpression{})
			if err := m.GroupBy[len(m.GroupBy)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= AggregateVectorOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataObjScan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataObjScan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataObjScan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Section", wireType)
			}
			m.Section = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Section |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StreamIds = append(m.StreamIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPhysicalpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPhysicalpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPhysicalpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StreamIds) == 0 {
					m.StreamIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPhysicalpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StreamIds = append(m.StreamIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamIds", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, &ColumnExpression{})
			if err := m.Projections[len(m.Projections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, &Expression{})
			if err := m.Predicates[len(m.Predicates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortOrder", wireType)
			}
			m.SortOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortOrder |= SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Predicates = append(m.Predicates, &Expression{})
			if err := m.Predicates[len(m.Predicates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			m.Skip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Skip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fetch", wireType)
			}
			m.Fetch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fetch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= ParseOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedKeys = append(m.RequestedKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Projection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Projection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Projection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnExpression{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortMerge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortMerge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortMerge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Column == nil {
				m.Column = &ColumnExpression{}
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPhysicalpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPhysicalpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPhysicalpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPhysicalpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPhysicalpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPhysicalpb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPhysicalpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPhysicalpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPhysicalpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPhysicalpb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPhysicalpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPhysicalpb   = fmt.Errorf("proto: integer overflow")
)
